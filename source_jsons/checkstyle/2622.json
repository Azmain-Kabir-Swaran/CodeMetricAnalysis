{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "HandlerFactory.java",
  "functionName": "getHandler",
  "functionId": "getHandler___indentCheck-IndentationCheck__ast-DetailAST__parent-AbstractExpressionHandler",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
  "functionStartLine": 139,
  "functionEndLine": 156,
  "numCommitsSeen": 99,
  "timeTaken": 3832,
  "changeHistory": [
    "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8",
    "0d8e93ce79ea33b72b3e904d8796984271ee3d8d",
    "5478613082bac0329d25cffcfae5fab219d25118",
    "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
    "2880edd6554400955fb950bf8127311c436d2a7a",
    "d28871069bb3461cbf277858fbf9696340957506",
    "8f19f1d70630f210f33ebd51d42d04ca9727ff36",
    "eb5896a4a1d66552f5100046413f15d62b485b62",
    "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1",
    "9f2bf96b2001eb2e3886950a41e076c8a01d57d8",
    "d84869bcff9a2f0ad8d6f1d7741e07d22a78e4a6",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "22705bd0d4d4867f646b8c3aca115d7b3cb9c022",
    "ef58eba6d1b95443ff240ed05634c7e373b3445a",
    "f1afaf83f39b83cc3bd07a2388448b262652a76b",
    "35d1673788bbbac8263fdb69275dc6a63b095a24",
    "342ae1315c775fa512a5278d901bbd4fb23fd7c1",
    "0855fff95e4aac170ac5ab74cd1872f20555a214",
    "e464c231eccec72f964131d9aeb5e49982c4b3bb",
    "d1f564190c0e9b57d7534b1a8e2b9d7c35d439e2",
    "eaad55fdba73e17e103dc6600867f26fd6a3896b",
    "9aab61241e7970ccfb4a9ee66c8eb7f062d31955"
  ],
  "changeHistoryShort": {
    "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8": "Ybodychange",
    "0d8e93ce79ea33b72b3e904d8796984271ee3d8d": "Ybodychange",
    "5478613082bac0329d25cffcfae5fab219d25118": "Ybodychange",
    "cdf3e56bacd3895262af8a1df9ca5c81f4071970": "Ybodychange",
    "2880edd6554400955fb950bf8127311c436d2a7a": "Ybodychange",
    "d28871069bb3461cbf277858fbf9696340957506": "Ybodychange",
    "8f19f1d70630f210f33ebd51d42d04ca9727ff36": "Ybodychange",
    "eb5896a4a1d66552f5100046413f15d62b485b62": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1": "Ybodychange",
    "9f2bf96b2001eb2e3886950a41e076c8a01d57d8": "Ybodychange",
    "d84869bcff9a2f0ad8d6f1d7741e07d22a78e4a6": "Ymultichange(Yparameterchange,Ybodychange)",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "22705bd0d4d4867f646b8c3aca115d7b3cb9c022": "Ybodychange",
    "ef58eba6d1b95443ff240ed05634c7e373b3445a": "Ybodychange",
    "f1afaf83f39b83cc3bd07a2388448b262652a76b": "Ybodychange",
    "35d1673788bbbac8263fdb69275dc6a63b095a24": "Ybodychange",
    "342ae1315c775fa512a5278d901bbd4fb23fd7c1": "Ybodychange",
    "0855fff95e4aac170ac5ab74cd1872f20555a214": "Ybodychange",
    "e464c231eccec72f964131d9aeb5e49982c4b3bb": "Ybodychange",
    "d1f564190c0e9b57d7534b1a8e2b9d7c35d439e2": "Ybodychange",
    "eaad55fdba73e17e103dc6600867f26fd6a3896b": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
    "9aab61241e7970ccfb4a9ee66c8eb7f062d31955": "Yintroduced"
  },
  "changeHistoryDetails": {
    "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8": {
      "type": "Ybodychange",
      "commitMessage": "Issue #5812: Rename all utility classes to xxxxUtil\n",
      "commitDate": "03/06/18 9:40 PM",
      "commitName": "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8",
      "commitAuthor": "Pavel Bludov",
      "commitDateOld": "18/04/18 1:06 PM",
      "commitNameOld": "6893affeac7285afd16f8a389c7d65023d0c327a",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 46.36,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,18 +1,18 @@\n     public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n         DetailAST ast, AbstractExpressionHandler parent) {\n         final AbstractExpressionHandler resultHandler;\n         final AbstractExpressionHandler handler \u003d\n             createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             resultHandler \u003d handler;\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             resultHandler \u003d createMethodCallHandler(indentCheck, ast, parent);\n         }\n         else {\n             final Constructor\u003c?\u003e handlerCtor \u003d typeHandlers.get(ast.getType());\n-            resultHandler \u003d (AbstractExpressionHandler) CommonUtils.invokeConstructor(\n+            resultHandler \u003d (AbstractExpressionHandler) CommonUtil.invokeConstructor(\n                 handlerCtor, indentCheck, ast, parent);\n         }\n         return resultHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, AbstractExpressionHandler parent) {\n        final AbstractExpressionHandler resultHandler;\n        final AbstractExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            resultHandler \u003d handler;\n        }\n        else if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            resultHandler \u003d createMethodCallHandler(indentCheck, ast, parent);\n        }\n        else {\n            final Constructor\u003c?\u003e handlerCtor \u003d typeHandlers.get(ast.getType());\n            resultHandler \u003d (AbstractExpressionHandler) CommonUtil.invokeConstructor(\n                handlerCtor, indentCheck, ast, parent);\n        }\n        return resultHandler;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "0d8e93ce79ea33b72b3e904d8796984271ee3d8d": {
      "type": "Ybodychange",
      "commitMessage": "minor: enforce FinalLocalVariableCheck on checkstyle code\n",
      "commitDate": "24/01/16 6:35 AM",
      "commitName": "0d8e93ce79ea33b72b3e904d8796984271ee3d8d",
      "commitAuthor": "Bhavik Patel",
      "commitDateOld": "04/01/16 4:25 PM",
      "commitNameOld": "617ebf2bf27d284dcc7b866f85439fcf6dab3402",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 19.59,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,18 +1,18 @@\n     public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n         DetailAST ast, AbstractExpressionHandler parent) {\n-        AbstractExpressionHandler resultHandler;\n+        final AbstractExpressionHandler resultHandler;\n         final AbstractExpressionHandler handler \u003d\n             createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             resultHandler \u003d handler;\n         }\n         else if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             resultHandler \u003d createMethodCallHandler(indentCheck, ast, parent);\n         }\n         else {\n             final Constructor\u003c?\u003e handlerCtor \u003d typeHandlers.get(ast.getType());\n             resultHandler \u003d (AbstractExpressionHandler) CommonUtils.invokeConstructor(\n                 handlerCtor, indentCheck, ast, parent);\n         }\n         return resultHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, AbstractExpressionHandler parent) {\n        final AbstractExpressionHandler resultHandler;\n        final AbstractExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            resultHandler \u003d handler;\n        }\n        else if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            resultHandler \u003d createMethodCallHandler(indentCheck, ast, parent);\n        }\n        else {\n            final Constructor\u003c?\u003e handlerCtor \u003d typeHandlers.get(ast.getType());\n            resultHandler \u003d (AbstractExpressionHandler) CommonUtils.invokeConstructor(\n                handlerCtor, indentCheck, ast, parent);\n        }\n        return resultHandler;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "5478613082bac0329d25cffcfae5fab219d25118": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: partial fix of ReturnCount violations\n",
      "commitDate": "27/08/15 5:34 AM",
      "commitName": "5478613082bac0329d25cffcfae5fab219d25118",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": "27/08/15 5:17 AM",
      "commitNameOld": "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,18 @@\n     public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n         DetailAST ast, AbstractExpressionHandler parent) {\n+        AbstractExpressionHandler resultHandler;\n         final AbstractExpressionHandler handler \u003d\n             createdHandlers.get(ast);\n         if (handler !\u003d null) {\n-            return handler;\n+            resultHandler \u003d handler;\n         }\n-\n-        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n-            return createMethodCallHandler(indentCheck, ast, parent);\n+        else if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n+            resultHandler \u003d createMethodCallHandler(indentCheck, ast, parent);\n         }\n-\n-        final Constructor\u003c?\u003e handlerCtor \u003d\n-            typeHandlers.get(ast.getType());\n-        return (AbstractExpressionHandler) CommonUtils.invokeConstructor(\n-            handlerCtor, indentCheck, ast, parent);\n+        else {\n+            final Constructor\u003c?\u003e handlerCtor \u003d typeHandlers.get(ast.getType());\n+            resultHandler \u003d (AbstractExpressionHandler) CommonUtils.invokeConstructor(\n+                handlerCtor, indentCheck, ast, parent);\n+        }\n+        return resultHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, AbstractExpressionHandler parent) {\n        AbstractExpressionHandler resultHandler;\n        final AbstractExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            resultHandler \u003d handler;\n        }\n        else if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            resultHandler \u003d createMethodCallHandler(indentCheck, ast, parent);\n        }\n        else {\n            final Constructor\u003c?\u003e handlerCtor \u003d typeHandlers.get(ast.getType());\n            resultHandler \u003d (AbstractExpressionHandler) CommonUtils.invokeConstructor(\n                handlerCtor, indentCheck, ast, parent);\n        }\n        return resultHandler;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "cdf3e56bacd3895262af8a1df9ca5c81f4071970": {
      "type": "Ybodychange",
      "commitMessage": "Utils class has been splitted to CommonUtils and TokenUtils. Issue #1898\n",
      "commitDate": "27/08/15 5:17 AM",
      "commitName": "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
      "commitAuthor": "Ilja Dubinin",
      "commitDateOld": "27/08/15 5:17 AM",
      "commitNameOld": "ed595de84fba2db507adaf01d04cb089a5e0bac5",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,17 @@\n     public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n         DetailAST ast, AbstractExpressionHandler parent) {\n         final AbstractExpressionHandler handler \u003d\n             createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(indentCheck, ast, parent);\n         }\n \n         final Constructor\u003c?\u003e handlerCtor \u003d\n             typeHandlers.get(ast.getType());\n-        return (AbstractExpressionHandler) Utils.invokeConstructor(\n+        return (AbstractExpressionHandler) CommonUtils.invokeConstructor(\n             handlerCtor, indentCheck, ast, parent);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, AbstractExpressionHandler parent) {\n        final AbstractExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(indentCheck, ast, parent);\n        }\n\n        final Constructor\u003c?\u003e handlerCtor \u003d\n            typeHandlers.get(ast.getType());\n        return (AbstractExpressionHandler) CommonUtils.invokeConstructor(\n            handlerCtor, indentCheck, ast, parent);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "2880edd6554400955fb950bf8127311c436d2a7a": {
      "type": "Ybodychange",
      "commitMessage": "Decrease scope of variables. #1538\n",
      "commitDate": "02/08/15 6:48 PM",
      "commitName": "2880edd6554400955fb950bf8127311c436d2a7a",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "02/08/15 6:48 PM",
      "commitNameOld": "d49eaaf2e42538bc7f01510eb3ca2812b253c98a",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,17 @@\n     public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n         DetailAST ast, AbstractExpressionHandler parent) {\n         final AbstractExpressionHandler handler \u003d\n             createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(indentCheck, ast, parent);\n         }\n \n-        AbstractExpressionHandler expHandler \u003d null;\n         final Constructor\u003c?\u003e handlerCtor \u003d\n             typeHandlers.get(ast.getType());\n-        expHandler \u003d (AbstractExpressionHandler) Utils.invokeConstructor(\n-                handlerCtor, indentCheck, ast, parent);\n-        return expHandler;\n+        return (AbstractExpressionHandler) Utils.invokeConstructor(\n+            handlerCtor, indentCheck, ast, parent);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, AbstractExpressionHandler parent) {\n        final AbstractExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(indentCheck, ast, parent);\n        }\n\n        final Constructor\u003c?\u003e handlerCtor \u003d\n            typeHandlers.get(ast.getType());\n        return (AbstractExpressionHandler) Utils.invokeConstructor(\n            handlerCtor, indentCheck, ast, parent);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "d28871069bb3461cbf277858fbf9696340957506": {
      "type": "Ybodychange",
      "commitMessage": "Remove dead code from HandlerFactory in Indentation check. #1270\n",
      "commitDate": "20/07/15 8:43 PM",
      "commitName": "d28871069bb3461cbf277858fbf9696340957506",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "08/07/15 6:32 PM",
      "commitNameOld": "8f19f1d70630f210f33ebd51d42d04ca9727ff36",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 12.09,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,19 @@\n     public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n         DetailAST ast, AbstractExpressionHandler parent) {\n         final AbstractExpressionHandler handler \u003d\n             createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(indentCheck, ast, parent);\n         }\n \n         AbstractExpressionHandler expHandler \u003d null;\n         final Constructor\u003c?\u003e handlerCtor \u003d\n             typeHandlers.get(ast.getType());\n-        if (handlerCtor !\u003d null) {\n-            expHandler \u003d (AbstractExpressionHandler) Utils.invokeConstructor(\n-                    handlerCtor, indentCheck, ast, parent);\n-        }\n+        expHandler \u003d (AbstractExpressionHandler) Utils.invokeConstructor(\n+                handlerCtor, indentCheck, ast, parent);\n         return expHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, AbstractExpressionHandler parent) {\n        final AbstractExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(indentCheck, ast, parent);\n        }\n\n        AbstractExpressionHandler expHandler \u003d null;\n        final Constructor\u003c?\u003e handlerCtor \u003d\n            typeHandlers.get(ast.getType());\n        expHandler \u003d (AbstractExpressionHandler) Utils.invokeConstructor(\n                handlerCtor, indentCheck, ast, parent);\n        return expHandler;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "8f19f1d70630f210f33ebd51d42d04ca9727ff36": {
      "type": "Ybodychange",
      "commitMessage": "Remove non-testable reflection code from HandlerFactory. #1270\n\nIn `HandlerFactory` any reflection-related exception would mean programmer\u0027s mistake with no recovery. In such cases checked exceptions are useless, so new methods in utils are provided to wrap any checked exceptions into unchecked ones.\n",
      "commitDate": "08/07/15 6:32 PM",
      "commitName": "8f19f1d70630f210f33ebd51d42d04ca9727ff36",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "18/06/15 10:52 AM",
      "commitNameOld": "eb5896a4a1d66552f5100046413f15d62b485b62",
      "commitAuthorOld": "Bhavik Patel",
      "daysBetweenCommits": 20.32,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,21 @@\n     public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n         DetailAST ast, AbstractExpressionHandler parent) {\n         final AbstractExpressionHandler handler \u003d\n             createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(indentCheck, ast, parent);\n         }\n \n         AbstractExpressionHandler expHandler \u003d null;\n-        try {\n-            final Constructor\u003c?\u003e handlerCtor \u003d\n-                typeHandlers.get(ast.getType());\n-            if (handlerCtor !\u003d null) {\n-                expHandler \u003d (AbstractExpressionHandler) handlerCtor.newInstance(\n-                        indentCheck, ast, parent);\n-            }\n-        }\n-        catch (final InstantiationException | InvocationTargetException e) {\n-            final String message \u003d \"couldn\u0027t instantiate constructor for \" + ast;\n-            LOG.debug(message, e);\n-            throw new RuntimeException(message);\n-        }\n-        catch (final IllegalAccessException e) {\n-            final String message \u003d \"couldn\u0027t access constructor for \" + ast;\n-            LOG.debug(message, e);\n-            throw new RuntimeException(message);\n-        }\n-        if (expHandler \u003d\u003d null) {\n-            throw new RuntimeException(\"no handler for type \" + ast.getType());\n+        final Constructor\u003c?\u003e handlerCtor \u003d\n+            typeHandlers.get(ast.getType());\n+        if (handlerCtor !\u003d null) {\n+            expHandler \u003d (AbstractExpressionHandler) Utils.invokeConstructor(\n+                    handlerCtor, indentCheck, ast, parent);\n         }\n         return expHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, AbstractExpressionHandler parent) {\n        final AbstractExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(indentCheck, ast, parent);\n        }\n\n        AbstractExpressionHandler expHandler \u003d null;\n        final Constructor\u003c?\u003e handlerCtor \u003d\n            typeHandlers.get(ast.getType());\n        if (handlerCtor !\u003d null) {\n            expHandler \u003d (AbstractExpressionHandler) Utils.invokeConstructor(\n                    handlerCtor, indentCheck, ast, parent);\n        }\n        return expHandler;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "eb5896a4a1d66552f5100046413f15d62b485b62": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "Fix PMD violations for AbstractNaming rule #983\n",
      "commitDate": "18/06/15 10:52 AM",
      "commitName": "eb5896a4a1d66552f5100046413f15d62b485b62",
      "commitAuthor": "Bhavik Patel",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fix PMD violations for AbstractNaming rule #983\n",
          "commitDate": "18/06/15 10:52 AM",
          "commitName": "eb5896a4a1d66552f5100046413f15d62b485b62",
          "commitAuthor": "Bhavik Patel",
          "commitDateOld": "17/05/15 4:47 AM",
          "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 32.25,
          "commitsBetweenForRepo": 181,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,36 @@\n-    public ExpressionHandler getHandler(IndentationCheck indentCheck,\n-        DetailAST ast, ExpressionHandler parent) {\n-        final ExpressionHandler handler \u003d\n+    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n+        DetailAST ast, AbstractExpressionHandler parent) {\n+        final AbstractExpressionHandler handler \u003d\n             createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(indentCheck, ast, parent);\n         }\n \n-        ExpressionHandler expHandler \u003d null;\n+        AbstractExpressionHandler expHandler \u003d null;\n         try {\n             final Constructor\u003c?\u003e handlerCtor \u003d\n                 typeHandlers.get(ast.getType());\n             if (handlerCtor !\u003d null) {\n-                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n+                expHandler \u003d (AbstractExpressionHandler) handlerCtor.newInstance(\n                         indentCheck, ast, parent);\n             }\n         }\n         catch (final InstantiationException | InvocationTargetException e) {\n             final String message \u003d \"couldn\u0027t instantiate constructor for \" + ast;\n             LOG.debug(message, e);\n             throw new RuntimeException(message);\n         }\n         catch (final IllegalAccessException e) {\n             final String message \u003d \"couldn\u0027t access constructor for \" + ast;\n             LOG.debug(message, e);\n             throw new RuntimeException(message);\n         }\n         if (expHandler \u003d\u003d null) {\n             throw new RuntimeException(\"no handler for type \" + ast.getType());\n         }\n         return expHandler;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, AbstractExpressionHandler parent) {\n        final AbstractExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(indentCheck, ast, parent);\n        }\n\n        AbstractExpressionHandler expHandler \u003d null;\n        try {\n            final Constructor\u003c?\u003e handlerCtor \u003d\n                typeHandlers.get(ast.getType());\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (AbstractExpressionHandler) handlerCtor.newInstance(\n                        indentCheck, ast, parent);\n            }\n        }\n        catch (final InstantiationException | InvocationTargetException e) {\n            final String message \u003d \"couldn\u0027t instantiate constructor for \" + ast;\n            LOG.debug(message, e);\n            throw new RuntimeException(message);\n        }\n        catch (final IllegalAccessException e) {\n            final String message \u003d \"couldn\u0027t access constructor for \" + ast;\n            LOG.debug(message, e);\n            throw new RuntimeException(message);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + ast.getType());\n        }\n        return expHandler;\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
          "extendedDetails": {
            "oldValue": "[indentCheck-IndentationCheck, ast-DetailAST, parent-ExpressionHandler]",
            "newValue": "[indentCheck-IndentationCheck, ast-DetailAST, parent-AbstractExpressionHandler]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "Fix PMD violations for AbstractNaming rule #983\n",
          "commitDate": "18/06/15 10:52 AM",
          "commitName": "eb5896a4a1d66552f5100046413f15d62b485b62",
          "commitAuthor": "Bhavik Patel",
          "commitDateOld": "17/05/15 4:47 AM",
          "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 32.25,
          "commitsBetweenForRepo": 181,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,36 @@\n-    public ExpressionHandler getHandler(IndentationCheck indentCheck,\n-        DetailAST ast, ExpressionHandler parent) {\n-        final ExpressionHandler handler \u003d\n+    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n+        DetailAST ast, AbstractExpressionHandler parent) {\n+        final AbstractExpressionHandler handler \u003d\n             createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(indentCheck, ast, parent);\n         }\n \n-        ExpressionHandler expHandler \u003d null;\n+        AbstractExpressionHandler expHandler \u003d null;\n         try {\n             final Constructor\u003c?\u003e handlerCtor \u003d\n                 typeHandlers.get(ast.getType());\n             if (handlerCtor !\u003d null) {\n-                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n+                expHandler \u003d (AbstractExpressionHandler) handlerCtor.newInstance(\n                         indentCheck, ast, parent);\n             }\n         }\n         catch (final InstantiationException | InvocationTargetException e) {\n             final String message \u003d \"couldn\u0027t instantiate constructor for \" + ast;\n             LOG.debug(message, e);\n             throw new RuntimeException(message);\n         }\n         catch (final IllegalAccessException e) {\n             final String message \u003d \"couldn\u0027t access constructor for \" + ast;\n             LOG.debug(message, e);\n             throw new RuntimeException(message);\n         }\n         if (expHandler \u003d\u003d null) {\n             throw new RuntimeException(\"no handler for type \" + ast.getType());\n         }\n         return expHandler;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, AbstractExpressionHandler parent) {\n        final AbstractExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(indentCheck, ast, parent);\n        }\n\n        AbstractExpressionHandler expHandler \u003d null;\n        try {\n            final Constructor\u003c?\u003e handlerCtor \u003d\n                typeHandlers.get(ast.getType());\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (AbstractExpressionHandler) handlerCtor.newInstance(\n                        indentCheck, ast, parent);\n            }\n        }\n        catch (final InstantiationException | InvocationTargetException e) {\n            final String message \u003d \"couldn\u0027t instantiate constructor for \" + ast;\n            LOG.debug(message, e);\n            throw new RuntimeException(message);\n        }\n        catch (final IllegalAccessException e) {\n            final String message \u003d \"couldn\u0027t access constructor for \" + ast;\n            LOG.debug(message, e);\n            throw new RuntimeException(message);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + ast.getType());\n        }\n        return expHandler;\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
          "extendedDetails": {
            "oldValue": "ExpressionHandler",
            "newValue": "AbstractExpressionHandler"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fix PMD violations for AbstractNaming rule #983\n",
          "commitDate": "18/06/15 10:52 AM",
          "commitName": "eb5896a4a1d66552f5100046413f15d62b485b62",
          "commitAuthor": "Bhavik Patel",
          "commitDateOld": "17/05/15 4:47 AM",
          "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
          "commitAuthorOld": "Michal Kordas",
          "daysBetweenCommits": 32.25,
          "commitsBetweenForRepo": 181,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,36 @@\n-    public ExpressionHandler getHandler(IndentationCheck indentCheck,\n-        DetailAST ast, ExpressionHandler parent) {\n-        final ExpressionHandler handler \u003d\n+    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n+        DetailAST ast, AbstractExpressionHandler parent) {\n+        final AbstractExpressionHandler handler \u003d\n             createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(indentCheck, ast, parent);\n         }\n \n-        ExpressionHandler expHandler \u003d null;\n+        AbstractExpressionHandler expHandler \u003d null;\n         try {\n             final Constructor\u003c?\u003e handlerCtor \u003d\n                 typeHandlers.get(ast.getType());\n             if (handlerCtor !\u003d null) {\n-                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n+                expHandler \u003d (AbstractExpressionHandler) handlerCtor.newInstance(\n                         indentCheck, ast, parent);\n             }\n         }\n         catch (final InstantiationException | InvocationTargetException e) {\n             final String message \u003d \"couldn\u0027t instantiate constructor for \" + ast;\n             LOG.debug(message, e);\n             throw new RuntimeException(message);\n         }\n         catch (final IllegalAccessException e) {\n             final String message \u003d \"couldn\u0027t access constructor for \" + ast;\n             LOG.debug(message, e);\n             throw new RuntimeException(message);\n         }\n         if (expHandler \u003d\u003d null) {\n             throw new RuntimeException(\"no handler for type \" + ast.getType());\n         }\n         return expHandler;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public AbstractExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, AbstractExpressionHandler parent) {\n        final AbstractExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(indentCheck, ast, parent);\n        }\n\n        AbstractExpressionHandler expHandler \u003d null;\n        try {\n            final Constructor\u003c?\u003e handlerCtor \u003d\n                typeHandlers.get(ast.getType());\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (AbstractExpressionHandler) handlerCtor.newInstance(\n                        indentCheck, ast, parent);\n            }\n        }\n        catch (final InstantiationException | InvocationTargetException e) {\n            final String message \u003d \"couldn\u0027t instantiate constructor for \" + ast;\n            LOG.debug(message, e);\n            throw new RuntimeException(message);\n        }\n        catch (final IllegalAccessException e) {\n            final String message \u003d \"couldn\u0027t access constructor for \" + ast;\n            LOG.debug(message, e);\n            throw new RuntimeException(message);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + ast.getType());\n        }\n        return expHandler;\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
          "extendedDetails": {}
        }
      ]
    },
    "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1": {
      "type": "Ybodychange",
      "commitMessage": "Fix PMD violations from \u0027logging-jakarta\u0027 ruleset, issue #871\n",
      "commitDate": "13/04/15 2:43 PM",
      "commitName": "ee518dfe86b29d1fa4d76f0dc0c11fb83afafda1",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "21/03/15 3:35 PM",
      "commitNameOld": "91d979ef8eab8d8f6fe5e5b64ec0586b49ea0315",
      "commitAuthorOld": "Damian Szczepanik",
      "daysBetweenCommits": 22.96,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,37 @@\n     public ExpressionHandler getHandler(IndentationCheck indentCheck,\n         DetailAST ast, ExpressionHandler parent)\n     {\n         final ExpressionHandler handler \u003d\n             createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(indentCheck, ast, parent);\n         }\n \n         ExpressionHandler expHandler \u003d null;\n         try {\n             final Constructor\u003c?\u003e handlerCtor \u003d\n                 typeHandlers.get(ast.getType());\n             if (handlerCtor !\u003d null) {\n                 expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                         indentCheck, ast, parent);\n             }\n         }\n-        catch (final InstantiationException e) {\n-            LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n-            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n-                                       + ast);\n+        catch (final InstantiationException | InvocationTargetException e) {\n+            final String message \u003d \"couldn\u0027t instantiate constructor for \" + ast;\n+            LOG.debug(message, e);\n+            throw new RuntimeException(message);\n         }\n         catch (final IllegalAccessException e) {\n-            LOG.debug(\"couldn\u0027t access constructor for \" + ast, e);\n-            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n-                                       + ast);\n-        }\n-        catch (final InvocationTargetException e) {\n-            LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n-            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n-                                       + ast);\n+            final String message \u003d \"couldn\u0027t access constructor for \" + ast;\n+            LOG.debug(message, e);\n+            throw new RuntimeException(message);\n         }\n         if (expHandler \u003d\u003d null) {\n             throw new RuntimeException(\"no handler for type \" + ast.getType());\n         }\n         return expHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, ExpressionHandler parent)\n    {\n        final ExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(indentCheck, ast, parent);\n        }\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            final Constructor\u003c?\u003e handlerCtor \u003d\n                typeHandlers.get(ast.getType());\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                        indentCheck, ast, parent);\n            }\n        }\n        catch (final InstantiationException | InvocationTargetException e) {\n            final String message \u003d \"couldn\u0027t instantiate constructor for \" + ast;\n            LOG.debug(message, e);\n            throw new RuntimeException(message);\n        }\n        catch (final IllegalAccessException e) {\n            final String message \u003d \"couldn\u0027t access constructor for \" + ast;\n            LOG.debug(message, e);\n            throw new RuntimeException(message);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + ast.getType());\n        }\n        return expHandler;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "9f2bf96b2001eb2e3886950a41e076c8a01d57d8": {
      "type": "Ybodychange",
      "commitMessage": "Delete ///CLOVER comments\n\nIssue #823\n",
      "commitDate": "20/03/15 12:57 PM",
      "commitName": "9f2bf96b2001eb2e3886950a41e076c8a01d57d8",
      "commitAuthor": "Damian Szczepanik",
      "commitDateOld": "10/03/15 2:36 PM",
      "commitNameOld": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 9.93,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,42 @@\n     public ExpressionHandler getHandler(IndentationCheck indentCheck,\n         DetailAST ast, ExpressionHandler parent)\n     {\n         final ExpressionHandler handler \u003d\n             createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(indentCheck, ast, parent);\n         }\n \n         ExpressionHandler expHandler \u003d null;\n         try {\n             final Constructor\u003c?\u003e handlerCtor \u003d\n                 typeHandlers.get(ast.getType());\n             if (handlerCtor !\u003d null) {\n                 expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                         indentCheck, ast, parent);\n             }\n         }\n-        ///CLOVER:OFF\n         catch (final InstantiationException e) {\n             LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + ast);\n         }\n         catch (final IllegalAccessException e) {\n             LOG.debug(\"couldn\u0027t access constructor for \" + ast, e);\n             throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                        + ast);\n         }\n         catch (final InvocationTargetException e) {\n             LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + ast);\n         }\n         if (expHandler \u003d\u003d null) {\n             throw new RuntimeException(\"no handler for type \" + ast.getType());\n         }\n-        ///CLOVER:ON\n         return expHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, ExpressionHandler parent)\n    {\n        final ExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(indentCheck, ast, parent);\n        }\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            final Constructor\u003c?\u003e handlerCtor \u003d\n                typeHandlers.get(ast.getType());\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                        indentCheck, ast, parent);\n            }\n        }\n        catch (final InstantiationException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + ast);\n        }\n        catch (final IllegalAccessException e) {\n            LOG.debug(\"couldn\u0027t access constructor for \" + ast, e);\n            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                       + ast);\n        }\n        catch (final InvocationTargetException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + ast);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + ast.getType());\n        }\n        return expHandler;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "d84869bcff9a2f0ad8d6f1d7741e07d22a78e4a6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, indentation, #512\n",
      "commitDate": "19/01/15 6:34 AM",
      "commitName": "d84869bcff9a2f0ad8d6f1d7741e07d22a78e4a6",
      "commitAuthor": "alexkravin",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Prefixes, indentation, #512\n",
          "commitDate": "19/01/15 6:34 AM",
          "commitName": "d84869bcff9a2f0ad8d6f1d7741e07d22a78e4a6",
          "commitAuthor": "alexkravin",
          "commitDateOld": "13/10/14 4:21 PM",
          "commitNameOld": "e3a48d1527341456a798c3f0c1986de6898a8c60",
          "commitAuthorOld": "maxvetrenko",
          "daysBetweenCommits": 97.63,
          "commitsBetweenForRepo": 303,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,44 @@\n-    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n-        DetailAST aAst, ExpressionHandler aParent)\n+    public ExpressionHandler getHandler(IndentationCheck indentCheck,\n+        DetailAST ast, ExpressionHandler parent)\n     {\n         final ExpressionHandler handler \u003d\n-            mCreatedHandlers.get(aAst);\n+            createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n-        if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n-            return createMethodCallHandler(aIndentCheck, aAst, aParent);\n+        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n+            return createMethodCallHandler(indentCheck, ast, parent);\n         }\n \n         ExpressionHandler expHandler \u003d null;\n         try {\n             final Constructor\u003c?\u003e handlerCtor \u003d\n-                mTypeHandlers.get(aAst.getType());\n+                typeHandlers.get(ast.getType());\n             if (handlerCtor !\u003d null) {\n                 expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n-                        aIndentCheck, aAst, aParent);\n+                        indentCheck, ast, parent);\n             }\n         }\n         ///CLOVER:OFF\n         catch (final InstantiationException e) {\n-            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n+            LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n-                                       + aAst);\n+                                       + ast);\n         }\n         catch (final IllegalAccessException e) {\n-            LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n+            LOG.debug(\"couldn\u0027t access constructor for \" + ast, e);\n             throw new RuntimeException(\"couldn\u0027t access constructor for \"\n-                                       + aAst);\n+                                       + ast);\n         }\n         catch (final InvocationTargetException e) {\n-            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n+            LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n-                                       + aAst);\n+                                       + ast);\n         }\n         if (expHandler \u003d\u003d null) {\n-            throw new RuntimeException(\"no handler for type \" + aAst.getType());\n+            throw new RuntimeException(\"no handler for type \" + ast.getType());\n         }\n         ///CLOVER:ON\n         return expHandler;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public ExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, ExpressionHandler parent)\n    {\n        final ExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(indentCheck, ast, parent);\n        }\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            final Constructor\u003c?\u003e handlerCtor \u003d\n                typeHandlers.get(ast.getType());\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                        indentCheck, ast, parent);\n            }\n        }\n        ///CLOVER:OFF\n        catch (final InstantiationException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + ast);\n        }\n        catch (final IllegalAccessException e) {\n            LOG.debug(\"couldn\u0027t access constructor for \" + ast, e);\n            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                       + ast);\n        }\n        catch (final InvocationTargetException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + ast);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + ast.getType());\n        }\n        ///CLOVER:ON\n        return expHandler;\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
          "extendedDetails": {
            "oldValue": "[aIndentCheck-IndentationCheck, aAst-DetailAST, aParent-ExpressionHandler]",
            "newValue": "[indentCheck-IndentationCheck, ast-DetailAST, parent-ExpressionHandler]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Prefixes, indentation, #512\n",
          "commitDate": "19/01/15 6:34 AM",
          "commitName": "d84869bcff9a2f0ad8d6f1d7741e07d22a78e4a6",
          "commitAuthor": "alexkravin",
          "commitDateOld": "13/10/14 4:21 PM",
          "commitNameOld": "e3a48d1527341456a798c3f0c1986de6898a8c60",
          "commitAuthorOld": "maxvetrenko",
          "daysBetweenCommits": 97.63,
          "commitsBetweenForRepo": 303,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,44 @@\n-    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n-        DetailAST aAst, ExpressionHandler aParent)\n+    public ExpressionHandler getHandler(IndentationCheck indentCheck,\n+        DetailAST ast, ExpressionHandler parent)\n     {\n         final ExpressionHandler handler \u003d\n-            mCreatedHandlers.get(aAst);\n+            createdHandlers.get(ast);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n-        if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n-            return createMethodCallHandler(aIndentCheck, aAst, aParent);\n+        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n+            return createMethodCallHandler(indentCheck, ast, parent);\n         }\n \n         ExpressionHandler expHandler \u003d null;\n         try {\n             final Constructor\u003c?\u003e handlerCtor \u003d\n-                mTypeHandlers.get(aAst.getType());\n+                typeHandlers.get(ast.getType());\n             if (handlerCtor !\u003d null) {\n                 expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n-                        aIndentCheck, aAst, aParent);\n+                        indentCheck, ast, parent);\n             }\n         }\n         ///CLOVER:OFF\n         catch (final InstantiationException e) {\n-            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n+            LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n-                                       + aAst);\n+                                       + ast);\n         }\n         catch (final IllegalAccessException e) {\n-            LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n+            LOG.debug(\"couldn\u0027t access constructor for \" + ast, e);\n             throw new RuntimeException(\"couldn\u0027t access constructor for \"\n-                                       + aAst);\n+                                       + ast);\n         }\n         catch (final InvocationTargetException e) {\n-            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n+            LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n-                                       + aAst);\n+                                       + ast);\n         }\n         if (expHandler \u003d\u003d null) {\n-            throw new RuntimeException(\"no handler for type \" + aAst.getType());\n+            throw new RuntimeException(\"no handler for type \" + ast.getType());\n         }\n         ///CLOVER:ON\n         return expHandler;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public ExpressionHandler getHandler(IndentationCheck indentCheck,\n        DetailAST ast, ExpressionHandler parent)\n    {\n        final ExpressionHandler handler \u003d\n            createdHandlers.get(ast);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (ast.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(indentCheck, ast, parent);\n        }\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            final Constructor\u003c?\u003e handlerCtor \u003d\n                typeHandlers.get(ast.getType());\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                        indentCheck, ast, parent);\n            }\n        }\n        ///CLOVER:OFF\n        catch (final InstantiationException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + ast);\n        }\n        catch (final IllegalAccessException e) {\n            LOG.debug(\"couldn\u0027t access constructor for \" + ast, e);\n            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                       + ast);\n        }\n        catch (final InvocationTargetException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + ast, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + ast);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + ast.getType());\n        }\n        ///CLOVER:ON\n        return expHandler;\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
          "extendedDetails": {}
        }
      ]
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": "04/03/14 9:18 AM",
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": "26/02/14 10:35 PM",
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent)\n    {\n        final ExpressionHandler handler \u003d\n            mCreatedHandlers.get(aAst);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(aIndentCheck, aAst, aParent);\n        }\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            final Constructor\u003c?\u003e handlerCtor \u003d\n                mTypeHandlers.get(aAst.getType());\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                        aIndentCheck, aAst, aParent);\n            }\n        }\n        ///CLOVER:OFF\n        catch (final InstantiationException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        catch (final IllegalAccessException e) {\n            LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                       + aAst);\n        }\n        catch (final InvocationTargetException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + aAst.getType());\n        }\n        ///CLOVER:ON\n        return expHandler;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {
        "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java"
      }
    },
    "22705bd0d4d4867f646b8c3aca115d7b3cb9c022": {
      "type": "Ybodychange",
      "commitMessage": "Removal of explicit boxing.\n",
      "commitDate": "20/12/07 3:36 AM",
      "commitName": "22705bd0d4d4867f646b8c3aca115d7b3cb9c022",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "20/12/07 3:08 AM",
      "commitNameOld": "ef58eba6d1b95443ff240ed05634c7e373b3445a",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,44 @@\n     public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n         DetailAST aAst, ExpressionHandler aParent)\n     {\n         final ExpressionHandler handler \u003d\n             mCreatedHandlers.get(aAst);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(aIndentCheck, aAst, aParent);\n         }\n \n-        final Integer type \u003d new Integer(aAst.getType());\n-\n         ExpressionHandler expHandler \u003d null;\n         try {\n             final Constructor\u003c?\u003e handlerCtor \u003d\n-                mTypeHandlers.get(type);\n+                mTypeHandlers.get(aAst.getType());\n             if (handlerCtor !\u003d null) {\n                 expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                         aIndentCheck, aAst, aParent);\n             }\n         }\n         ///CLOVER:OFF\n         catch (final InstantiationException e) {\n             LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + aAst);\n         }\n         catch (final IllegalAccessException e) {\n             LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                        + aAst);\n         }\n         catch (final InvocationTargetException e) {\n             LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + aAst);\n         }\n         if (expHandler \u003d\u003d null) {\n-            throw new RuntimeException(\"no handler for type \" + type);\n+            throw new RuntimeException(\"no handler for type \" + aAst.getType());\n         }\n         ///CLOVER:ON\n         return expHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent)\n    {\n        final ExpressionHandler handler \u003d\n            mCreatedHandlers.get(aAst);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(aIndentCheck, aAst, aParent);\n        }\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            final Constructor\u003c?\u003e handlerCtor \u003d\n                mTypeHandlers.get(aAst.getType());\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                        aIndentCheck, aAst, aParent);\n            }\n        }\n        ///CLOVER:OFF\n        catch (final InstantiationException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        catch (final IllegalAccessException e) {\n            LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                       + aAst);\n        }\n        catch (final InvocationTargetException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + aAst.getType());\n        }\n        ///CLOVER:ON\n        return expHandler;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "ef58eba6d1b95443ff240ed05634c7e373b3445a": {
      "type": "Ybodychange",
      "commitMessage": "General clean up with the new logging.\n",
      "commitDate": "20/12/07 3:08 AM",
      "commitName": "ef58eba6d1b95443ff240ed05634c7e373b3445a",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "15/12/07 2:28 AM",
      "commitNameOld": "e50e1fcd1c17ba1f73d11df38382907cc163a1d1",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 5.03,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,46 @@\n     public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n         DetailAST aAst, ExpressionHandler aParent)\n     {\n         final ExpressionHandler handler \u003d\n             mCreatedHandlers.get(aAst);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(aIndentCheck, aAst, aParent);\n         }\n \n         final Integer type \u003d new Integer(aAst.getType());\n \n         ExpressionHandler expHandler \u003d null;\n         try {\n             final Constructor\u003c?\u003e handlerCtor \u003d\n                 mTypeHandlers.get(type);\n             if (handlerCtor !\u003d null) {\n                 expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n-                    new Object[] {\n-                        aIndentCheck,\n-                        aAst,\n-                        aParent,\n-                    }\n-                );\n+                        aIndentCheck, aAst, aParent);\n             }\n         }\n         ///CLOVER:OFF\n         catch (final InstantiationException e) {\n             LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + aAst);\n         }\n         catch (final IllegalAccessException e) {\n             LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                        + aAst);\n         }\n         catch (final InvocationTargetException e) {\n             LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + aAst);\n         }\n         if (expHandler \u003d\u003d null) {\n             throw new RuntimeException(\"no handler for type \" + type);\n         }\n         ///CLOVER:ON\n         return expHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent)\n    {\n        final ExpressionHandler handler \u003d\n            mCreatedHandlers.get(aAst);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(aIndentCheck, aAst, aParent);\n        }\n\n        final Integer type \u003d new Integer(aAst.getType());\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            final Constructor\u003c?\u003e handlerCtor \u003d\n                mTypeHandlers.get(type);\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                        aIndentCheck, aAst, aParent);\n            }\n        }\n        ///CLOVER:OFF\n        catch (final InstantiationException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        catch (final IllegalAccessException e) {\n            LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                       + aAst);\n        }\n        catch (final InvocationTargetException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + type);\n        }\n        ///CLOVER:ON\n        return expHandler;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "f1afaf83f39b83cc3bd07a2388448b262652a76b": {
      "type": "Ybodychange",
      "commitMessage": "Finish of adding generics.\n",
      "commitDate": "15/12/07 12:14 AM",
      "commitName": "f1afaf83f39b83cc3bd07a2388448b262652a76b",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "27/01/07 6:51 AM",
      "commitNameOld": "1efc394250b8f1c79bd7f8344b738a7d13396ed3",
      "commitAuthorOld": "Lars Khne",
      "daysBetweenCommits": 321.72,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n     public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n         DetailAST aAst, ExpressionHandler aParent)\n     {\n         final ExpressionHandler handler \u003d\n-            (ExpressionHandler) mCreatedHandlers.get(aAst);\n+            mCreatedHandlers.get(aAst);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(aIndentCheck, aAst, aParent);\n         }\n \n         final Integer type \u003d new Integer(aAst.getType());\n \n         ExpressionHandler expHandler \u003d null;\n         try {\n-            final Constructor handlerCtor \u003d\n-                (Constructor) mTypeHandlers.get(type);\n+            final Constructor\u003c?\u003e handlerCtor \u003d\n+                mTypeHandlers.get(type);\n             if (handlerCtor !\u003d null) {\n                 expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                     new Object[] {\n                         aIndentCheck,\n                         aAst,\n                         aParent,\n                     }\n                 );\n             }\n         }\n         ///CLOVER:OFF\n         catch (final InstantiationException e) {\n             LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + aAst);\n         }\n         catch (final IllegalAccessException e) {\n             LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                        + aAst);\n         }\n         catch (final InvocationTargetException e) {\n             LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + aAst);\n         }\n         if (expHandler \u003d\u003d null) {\n             throw new RuntimeException(\"no handler for type \" + type);\n         }\n         ///CLOVER:ON\n         return expHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent)\n    {\n        final ExpressionHandler handler \u003d\n            mCreatedHandlers.get(aAst);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(aIndentCheck, aAst, aParent);\n        }\n\n        final Integer type \u003d new Integer(aAst.getType());\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            final Constructor\u003c?\u003e handlerCtor \u003d\n                mTypeHandlers.get(type);\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                    new Object[] {\n                        aIndentCheck,\n                        aAst,\n                        aParent,\n                    }\n                );\n            }\n        }\n        ///CLOVER:OFF\n        catch (final InstantiationException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        catch (final IllegalAccessException e) {\n            LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                       + aAst);\n        }\n        catch (final InvocationTargetException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + type);\n        }\n        ///CLOVER:ON\n        return expHandler;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "35d1673788bbbac8263fdb69275dc6a63b095a24": {
      "type": "Ybodychange",
      "commitMessage": "Making local variables final where possible.\n",
      "commitDate": "06/07/06 8:44 PM",
      "commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "06/07/06 8:33 PM",
      "commitNameOld": "f4a92dad02a3a36b5e2e988bba04debb1e2c9db9",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,51 @@\n     public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n         DetailAST aAst, ExpressionHandler aParent)\n     {\n-        ExpressionHandler handler \u003d\n+        final ExpressionHandler handler \u003d\n             (ExpressionHandler) mCreatedHandlers.get(aAst);\n         if (handler !\u003d null) {\n             return handler;\n         }\n \n         if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(aIndentCheck, aAst, aParent);\n         }\n \n-        Integer type \u003d new Integer(aAst.getType());\n+        final Integer type \u003d new Integer(aAst.getType());\n \n         ExpressionHandler expHandler \u003d null;\n         try {\n-            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(type);\n+            final Constructor handlerCtor \u003d\n+                (Constructor) mTypeHandlers.get(type);\n             if (handlerCtor !\u003d null) {\n                 expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                     new Object[] {\n                         aIndentCheck,\n                         aAst,\n                         aParent,\n                     }\n                 );\n             }\n         }\n         ///CLOVER:OFF\n-        catch (InstantiationException e) {\n+        catch (final InstantiationException e) {\n             LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + aAst);\n         }\n-        catch (IllegalAccessException e) {\n+        catch (final IllegalAccessException e) {\n             LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                        + aAst);\n         }\n-        catch (InvocationTargetException e) {\n+        catch (final InvocationTargetException e) {\n             LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + aAst);\n         }\n         if (expHandler \u003d\u003d null) {\n             throw new RuntimeException(\"no handler for type \" + type);\n         }\n         ///CLOVER:ON\n         return expHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent)\n    {\n        final ExpressionHandler handler \u003d\n            (ExpressionHandler) mCreatedHandlers.get(aAst);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(aIndentCheck, aAst, aParent);\n        }\n\n        final Integer type \u003d new Integer(aAst.getType());\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            final Constructor handlerCtor \u003d\n                (Constructor) mTypeHandlers.get(type);\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                    new Object[] {\n                        aIndentCheck,\n                        aAst,\n                        aParent,\n                    }\n                );\n            }\n        }\n        ///CLOVER:OFF\n        catch (final InstantiationException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        catch (final IllegalAccessException e) {\n            LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                       + aAst);\n        }\n        catch (final InvocationTargetException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + type);\n        }\n        ///CLOVER:ON\n        return expHandler;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "342ae1315c775fa512a5278d901bbd4fb23fd7c1": {
      "type": "Ybodychange",
      "commitMessage": "Three more fixes for Indentation check (bugs 1251988, 1260079, 1336737).\n",
      "commitDate": "25/10/05 12:15 PM",
      "commitName": "342ae1315c775fa512a5278d901bbd4fb23fd7c1",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": "23/07/05 1:44 AM",
      "commitNameOld": "50559c68761e235f57e48cd2dc28928b417d7745",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 94.44,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,50 @@\n     public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n         DetailAST aAst, ExpressionHandler aParent)\n     {\n+        ExpressionHandler handler \u003d\n+            (ExpressionHandler) mCreatedHandlers.get(aAst);\n+        if (handler !\u003d null) {\n+            return handler;\n+        }\n+\n         if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(aIndentCheck, aAst, aParent);\n         }\n \n         Integer type \u003d new Integer(aAst.getType());\n \n         ExpressionHandler expHandler \u003d null;\n         try {\n             Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(type);\n             if (handlerCtor !\u003d null) {\n                 expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                     new Object[] {\n                         aIndentCheck,\n                         aAst,\n                         aParent,\n                     }\n                 );\n             }\n         }\n         ///CLOVER:OFF\n         catch (InstantiationException e) {\n             LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + aAst);\n         }\n         catch (IllegalAccessException e) {\n             LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                        + aAst);\n         }\n         catch (InvocationTargetException e) {\n             LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + aAst);\n         }\n         if (expHandler \u003d\u003d null) {\n             throw new RuntimeException(\"no handler for type \" + type);\n         }\n         ///CLOVER:ON\n         return expHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent)\n    {\n        ExpressionHandler handler \u003d\n            (ExpressionHandler) mCreatedHandlers.get(aAst);\n        if (handler !\u003d null) {\n            return handler;\n        }\n\n        if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(aIndentCheck, aAst, aParent);\n        }\n\n        Integer type \u003d new Integer(aAst.getType());\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(type);\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                    new Object[] {\n                        aIndentCheck,\n                        aAst,\n                        aParent,\n                    }\n                );\n            }\n        }\n        ///CLOVER:OFF\n        catch (InstantiationException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        catch (IllegalAccessException e) {\n            LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                       + aAst);\n        }\n        catch (InvocationTargetException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + type);\n        }\n        ///CLOVER:ON\n        return expHandler;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "0855fff95e4aac170ac5ab74cd1872f20555a214": {
      "type": "Ybodychange",
      "commitMessage": "Fix for NoSuchMethodError when line wrapped at dot operator (bug 790209)\n",
      "commitDate": "18/08/03 9:54 PM",
      "commitName": "0855fff95e4aac170ac5ab74cd1872f20555a214",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": "14/07/03 5:31 AM",
      "commitNameOld": "51dae59b8dcfb5a34f2a8a5b3e788eb6599a1df3",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 35.68,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,44 @@\n     public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n         DetailAST aAst, ExpressionHandler aParent)\n     {\n         if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n             return createMethodCallHandler(aIndentCheck, aAst, aParent);\n         }\n \n         Integer type \u003d new Integer(aAst.getType());\n \n         ExpressionHandler expHandler \u003d null;\n         try {\n             Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(type);\n             if (handlerCtor !\u003d null) {\n                 expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                     new Object[] {\n                         aIndentCheck,\n                         aAst,\n                         aParent,\n                     }\n                 );\n             }\n         }\n         ///CLOVER:OFF\n         catch (InstantiationException e) {\n+            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n-                                       + aAst, e);\n+                                       + aAst);\n         }\n         catch (IllegalAccessException e) {\n+            LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t access constructor for \"\n-                                       + aAst,\n-                                       e);\n+                                       + aAst);\n         }\n         catch (InvocationTargetException e) {\n+            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n-                                       + aAst, e);\n+                                       + aAst);\n         }\n         if (expHandler \u003d\u003d null) {\n             throw new RuntimeException(\"no handler for type \" + type);\n         }\n         ///CLOVER:ON\n         return expHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent)\n    {\n        if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(aIndentCheck, aAst, aParent);\n        }\n\n        Integer type \u003d new Integer(aAst.getType());\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(type);\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                    new Object[] {\n                        aIndentCheck,\n                        aAst,\n                        aParent,\n                    }\n                );\n            }\n        }\n        ///CLOVER:OFF\n        catch (InstantiationException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        catch (IllegalAccessException e) {\n            LOG.debug(\"couldn\u0027t access constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                       + aAst);\n        }\n        catch (InvocationTargetException e) {\n            LOG.debug(\"couldn\u0027t instantiate constructor for \" + aAst, e);\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + type);\n        }\n        ///CLOVER:ON\n        return expHandler;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "e464c231eccec72f964131d9aeb5e49982c4b3bb": {
      "type": "Ybodychange",
      "commitMessage": "Indentation:\nFixes for several TODO comments.\nAdded AssignHandler.\n",
      "commitDate": "14/06/03 10:47 AM",
      "commitName": "e464c231eccec72f964131d9aeb5e49982c4b3bb",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": "09/06/03 12:48 AM",
      "commitNameOld": "889587fdd22ba03ea670e404d36810e9af113c9d",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 5.42,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,42 @@\n     public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n         DetailAST aAst, ExpressionHandler aParent)\n     {\n-        int type \u003d aAst.getType();\n+        if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n+            return createMethodCallHandler(aIndentCheck, aAst, aParent);\n+        }\n+\n+        Integer type \u003d new Integer(aAst.getType());\n \n         ExpressionHandler expHandler \u003d null;\n         try {\n-            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n-                new Integer(type));\n+            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(type);\n             if (handlerCtor !\u003d null) {\n                 expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                     new Object[] {\n                         aIndentCheck,\n                         aAst,\n                         aParent,\n                     }\n                 );\n             }\n         }\n+        ///CLOVER:OFF\n         catch (InstantiationException e) {\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + aAst, e);\n         }\n         catch (IllegalAccessException e) {\n             throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                        + aAst,\n                                        e);\n         }\n         catch (InvocationTargetException e) {\n             throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                        + aAst, e);\n         }\n         if (expHandler \u003d\u003d null) {\n             throw new RuntimeException(\"no handler for type \" + type);\n         }\n+        ///CLOVER:ON\n         return expHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent)\n    {\n        if (aAst.getType() \u003d\u003d TokenTypes.METHOD_CALL) {\n            return createMethodCallHandler(aIndentCheck, aAst, aParent);\n        }\n\n        Integer type \u003d new Integer(aAst.getType());\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(type);\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                    new Object[] {\n                        aIndentCheck,\n                        aAst,\n                        aParent,\n                    }\n                );\n            }\n        }\n        ///CLOVER:OFF\n        catch (InstantiationException e) {\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst, e);\n        }\n        catch (IllegalAccessException e) {\n            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                       + aAst,\n                                       e);\n        }\n        catch (InvocationTargetException e) {\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst, e);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + type);\n        }\n        ///CLOVER:ON\n        return expHandler;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "d1f564190c0e9b57d7534b1a8e2b9d7c35d439e2": {
      "type": "Ybodychange",
      "commitMessage": "Replace error loggin (using System.out) with throwing exception,\nbecause these are real exceptions.\n",
      "commitDate": "16/05/03 11:39 AM",
      "commitName": "d1f564190c0e9b57d7534b1a8e2b9d7c35d439e2",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": "14/05/03 1:11 AM",
      "commitNameOld": "a4d63db21d57ab53aff8a467f89df3867518ab91",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 2.44,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,37 @@\n     public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n         DetailAST aAst, ExpressionHandler aParent)\n     {\n         int type \u003d aAst.getType();\n \n         ExpressionHandler expHandler \u003d null;\n         try {\n             Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n                 new Integer(type));\n             if (handlerCtor !\u003d null) {\n                 expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                     new Object[] {\n                         aIndentCheck,\n                         aAst,\n                         aParent\n                     }\n                 );\n             }\n         }\n         catch (InstantiationException e) {\n-            System.out.println(\"couldn\u0027t instantiate constructor for \"\n-                + aAst);\n-            e.printStackTrace();\n+            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n+                                       + aAst, e);\n         }\n         catch (IllegalAccessException e) {\n-            System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n-            e.printStackTrace();\n+            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n+                                       + aAst,\n+                                       e);\n         }\n         catch (InvocationTargetException e) {\n-            System.out.println(\"couldn\u0027t instantiate constructor for \"\n-                + aAst);\n-            e.printStackTrace();\n+            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n+                                       + aAst, e);\n         }\n         if (expHandler \u003d\u003d null) {\n-            System.err.println(\"no handler for type \" + type);\n+            throw new RuntimeException(\"no handler for type \" + type);\n         }\n         return expHandler;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent)\n    {\n        int type \u003d aAst.getType();\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n                new Integer(type));\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                    new Object[] {\n                        aIndentCheck,\n                        aAst,\n                        aParent\n                    }\n                );\n            }\n        }\n        catch (InstantiationException e) {\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst, e);\n        }\n        catch (IllegalAccessException e) {\n            throw new RuntimeException(\"couldn\u0027t access constructor for \"\n                                       + aAst,\n                                       e);\n        }\n        catch (InvocationTargetException e) {\n            throw new RuntimeException(\"couldn\u0027t instantiate constructor for \"\n                                       + aAst, e);\n        }\n        if (expHandler \u003d\u003d null) {\n            throw new RuntimeException(\"no handler for type \" + type);\n        }\n        return expHandler;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
      "extendedDetails": {}
    },
    "eaad55fdba73e17e103dc6600867f26fd6a3896b": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "Refactoring of original IndentationCheck made by Jeff Weston (Sir Toby) applied.\nFixed two know problems:\n - with static init block (catched by testValidBlockWithChecker())\n - with throws in method definition.\n   unit-test (testInvalidMethodWithChecker()) fixed too.\n",
      "commitDate": "11/05/03 12:53 AM",
      "commitName": "eaad55fdba73e17e103dc6600867f26fd6a3896b",
      "commitAuthor": "Oleg Sukhodolsky",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Refactoring of original IndentationCheck made by Jeff Weston (Sir Toby) applied.\nFixed two know problems:\n - with static init block (catched by testValidBlockWithChecker())\n - with throws in method definition.\n   unit-test (testInvalidMethodWithChecker()) fixed too.\n",
          "commitDate": "11/05/03 12:53 AM",
          "commitName": "eaad55fdba73e17e103dc6600867f26fd6a3896b",
          "commitAuthor": "Oleg Sukhodolsky",
          "commitDateOld": "11/05/03 12:31 AM",
          "commitNameOld": "bf6758b29dbb6f0e22d4951ea3bd25fdf45299fc",
          "commitAuthorOld": "Lars Khne",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,38 @@\n-        private ExpressionHandler getHandler(DetailAST aAst, \n-            ExpressionHandler aParent) \n-        {\n-            int type \u003d aAst.getType();            \n-            \n-            ExpressionHandler expHandler \u003d null;\n-            try {\n-                Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n-                    new Integer(type));\n-                if (handlerCtor !\u003d null) {\n-                    expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n-                        new Object[] {\n-                            IndentationCheck.this,\n-                            aAst,\n-                            aParent\n-                        }\n-                    );\n-                }\n-            } \n-            catch (InstantiationException e) {\n-                System.out.println(\"couldn\u0027t instantiate constructor for \" \n-                    + aAst);\n-                e.printStackTrace();\n-            } \n-            catch (IllegalAccessException e) {\n-                System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n-                e.printStackTrace();\n-            } \n-            catch (InvocationTargetException e) {\n-                System.out.println(\"couldn\u0027t instantiate constructor for \" \n-                    + aAst);\n-                e.printStackTrace();\n+    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n+        DetailAST aAst, ExpressionHandler aParent) \n+    {\n+        int type \u003d aAst.getType();\n+\n+        ExpressionHandler expHandler \u003d null;\n+        try {\n+            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n+                new Integer(type));\n+            if (handlerCtor !\u003d null) {\n+                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n+                    new Object[] {\n+                        aIndentCheck,\n+                        aAst,\n+                        aParent\n+                    }\n+                );\n             }\n-            if (expHandler \u003d\u003d null) {\n-                System.err.println(\"no handler for type \" + type);\n-            }\n-            return expHandler;\n-        }\n\\ No newline at end of file\n+        } \n+        catch (InstantiationException e) {\n+            System.out.println(\"couldn\u0027t instantiate constructor for \" \n+                + aAst);\n+            e.printStackTrace();\n+        } \n+        catch (IllegalAccessException e) {\n+            System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n+            e.printStackTrace();\n+        } \n+        catch (InvocationTargetException e) {\n+            System.out.println(\"couldn\u0027t instantiate constructor for \" \n+                + aAst);\n+            e.printStackTrace();\n+        }\n+        if (expHandler \u003d\u003d null) {\n+            System.err.println(\"no handler for type \" + type);\n+        }\n+        return expHandler;\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent) \n    {\n        int type \u003d aAst.getType();\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n                new Integer(type));\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                    new Object[] {\n                        aIndentCheck,\n                        aAst,\n                        aParent\n                    }\n                );\n            }\n        } \n        catch (InstantiationException e) {\n            System.out.println(\"couldn\u0027t instantiate constructor for \" \n                + aAst);\n            e.printStackTrace();\n        } \n        catch (IllegalAccessException e) {\n            System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n            e.printStackTrace();\n        } \n        catch (InvocationTargetException e) {\n            System.out.println(\"couldn\u0027t instantiate constructor for \" \n                + aAst);\n            e.printStackTrace();\n        }\n        if (expHandler \u003d\u003d null) {\n            System.err.println(\"no handler for type \" + type);\n        }\n        return expHandler;\n    }",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
          "extendedDetails": {
            "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/IndentationCheck.java",
            "newPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
            "oldMethodName": "getHandler",
            "newMethodName": "getHandler"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Refactoring of original IndentationCheck made by Jeff Weston (Sir Toby) applied.\nFixed two know problems:\n - with static init block (catched by testValidBlockWithChecker())\n - with throws in method definition.\n   unit-test (testInvalidMethodWithChecker()) fixed too.\n",
          "commitDate": "11/05/03 12:53 AM",
          "commitName": "eaad55fdba73e17e103dc6600867f26fd6a3896b",
          "commitAuthor": "Oleg Sukhodolsky",
          "commitDateOld": "11/05/03 12:31 AM",
          "commitNameOld": "bf6758b29dbb6f0e22d4951ea3bd25fdf45299fc",
          "commitAuthorOld": "Lars Khne",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,38 @@\n-        private ExpressionHandler getHandler(DetailAST aAst, \n-            ExpressionHandler aParent) \n-        {\n-            int type \u003d aAst.getType();            \n-            \n-            ExpressionHandler expHandler \u003d null;\n-            try {\n-                Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n-                    new Integer(type));\n-                if (handlerCtor !\u003d null) {\n-                    expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n-                        new Object[] {\n-                            IndentationCheck.this,\n-                            aAst,\n-                            aParent\n-                        }\n-                    );\n-                }\n-            } \n-            catch (InstantiationException e) {\n-                System.out.println(\"couldn\u0027t instantiate constructor for \" \n-                    + aAst);\n-                e.printStackTrace();\n-            } \n-            catch (IllegalAccessException e) {\n-                System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n-                e.printStackTrace();\n-            } \n-            catch (InvocationTargetException e) {\n-                System.out.println(\"couldn\u0027t instantiate constructor for \" \n-                    + aAst);\n-                e.printStackTrace();\n+    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n+        DetailAST aAst, ExpressionHandler aParent) \n+    {\n+        int type \u003d aAst.getType();\n+\n+        ExpressionHandler expHandler \u003d null;\n+        try {\n+            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n+                new Integer(type));\n+            if (handlerCtor !\u003d null) {\n+                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n+                    new Object[] {\n+                        aIndentCheck,\n+                        aAst,\n+                        aParent\n+                    }\n+                );\n             }\n-            if (expHandler \u003d\u003d null) {\n-                System.err.println(\"no handler for type \" + type);\n-            }\n-            return expHandler;\n-        }\n\\ No newline at end of file\n+        } \n+        catch (InstantiationException e) {\n+            System.out.println(\"couldn\u0027t instantiate constructor for \" \n+                + aAst);\n+            e.printStackTrace();\n+        } \n+        catch (IllegalAccessException e) {\n+            System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n+            e.printStackTrace();\n+        } \n+        catch (InvocationTargetException e) {\n+            System.out.println(\"couldn\u0027t instantiate constructor for \" \n+                + aAst);\n+            e.printStackTrace();\n+        }\n+        if (expHandler \u003d\u003d null) {\n+            System.err.println(\"no handler for type \" + type);\n+        }\n+        return expHandler;\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent) \n    {\n        int type \u003d aAst.getType();\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n                new Integer(type));\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                    new Object[] {\n                        aIndentCheck,\n                        aAst,\n                        aParent\n                    }\n                );\n            }\n        } \n        catch (InstantiationException e) {\n            System.out.println(\"couldn\u0027t instantiate constructor for \" \n                + aAst);\n            e.printStackTrace();\n        } \n        catch (IllegalAccessException e) {\n            System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n            e.printStackTrace();\n        } \n        catch (InvocationTargetException e) {\n            System.out.println(\"couldn\u0027t instantiate constructor for \" \n                + aAst);\n            e.printStackTrace();\n        }\n        if (expHandler \u003d\u003d null) {\n            System.err.println(\"no handler for type \" + type);\n        }\n        return expHandler;\n    }",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Refactoring of original IndentationCheck made by Jeff Weston (Sir Toby) applied.\nFixed two know problems:\n - with static init block (catched by testValidBlockWithChecker())\n - with throws in method definition.\n   unit-test (testInvalidMethodWithChecker()) fixed too.\n",
          "commitDate": "11/05/03 12:53 AM",
          "commitName": "eaad55fdba73e17e103dc6600867f26fd6a3896b",
          "commitAuthor": "Oleg Sukhodolsky",
          "commitDateOld": "11/05/03 12:31 AM",
          "commitNameOld": "bf6758b29dbb6f0e22d4951ea3bd25fdf45299fc",
          "commitAuthorOld": "Lars Khne",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,38 @@\n-        private ExpressionHandler getHandler(DetailAST aAst, \n-            ExpressionHandler aParent) \n-        {\n-            int type \u003d aAst.getType();            \n-            \n-            ExpressionHandler expHandler \u003d null;\n-            try {\n-                Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n-                    new Integer(type));\n-                if (handlerCtor !\u003d null) {\n-                    expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n-                        new Object[] {\n-                            IndentationCheck.this,\n-                            aAst,\n-                            aParent\n-                        }\n-                    );\n-                }\n-            } \n-            catch (InstantiationException e) {\n-                System.out.println(\"couldn\u0027t instantiate constructor for \" \n-                    + aAst);\n-                e.printStackTrace();\n-            } \n-            catch (IllegalAccessException e) {\n-                System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n-                e.printStackTrace();\n-            } \n-            catch (InvocationTargetException e) {\n-                System.out.println(\"couldn\u0027t instantiate constructor for \" \n-                    + aAst);\n-                e.printStackTrace();\n+    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n+        DetailAST aAst, ExpressionHandler aParent) \n+    {\n+        int type \u003d aAst.getType();\n+\n+        ExpressionHandler expHandler \u003d null;\n+        try {\n+            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n+                new Integer(type));\n+            if (handlerCtor !\u003d null) {\n+                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n+                    new Object[] {\n+                        aIndentCheck,\n+                        aAst,\n+                        aParent\n+                    }\n+                );\n             }\n-            if (expHandler \u003d\u003d null) {\n-                System.err.println(\"no handler for type \" + type);\n-            }\n-            return expHandler;\n-        }\n\\ No newline at end of file\n+        } \n+        catch (InstantiationException e) {\n+            System.out.println(\"couldn\u0027t instantiate constructor for \" \n+                + aAst);\n+            e.printStackTrace();\n+        } \n+        catch (IllegalAccessException e) {\n+            System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n+            e.printStackTrace();\n+        } \n+        catch (InvocationTargetException e) {\n+            System.out.println(\"couldn\u0027t instantiate constructor for \" \n+                + aAst);\n+            e.printStackTrace();\n+        }\n+        if (expHandler \u003d\u003d null) {\n+            System.err.println(\"no handler for type \" + type);\n+        }\n+        return expHandler;\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent) \n    {\n        int type \u003d aAst.getType();\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n                new Integer(type));\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                    new Object[] {\n                        aIndentCheck,\n                        aAst,\n                        aParent\n                    }\n                );\n            }\n        } \n        catch (InstantiationException e) {\n            System.out.println(\"couldn\u0027t instantiate constructor for \" \n                + aAst);\n            e.printStackTrace();\n        } \n        catch (IllegalAccessException e) {\n            System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n            e.printStackTrace();\n        } \n        catch (InvocationTargetException e) {\n            System.out.println(\"couldn\u0027t instantiate constructor for \" \n                + aAst);\n            e.printStackTrace();\n        }\n        if (expHandler \u003d\u003d null) {\n            System.err.println(\"no handler for type \" + type);\n        }\n        return expHandler;\n    }",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "Refactoring of original IndentationCheck made by Jeff Weston (Sir Toby) applied.\nFixed two know problems:\n - with static init block (catched by testValidBlockWithChecker())\n - with throws in method definition.\n   unit-test (testInvalidMethodWithChecker()) fixed too.\n",
          "commitDate": "11/05/03 12:53 AM",
          "commitName": "eaad55fdba73e17e103dc6600867f26fd6a3896b",
          "commitAuthor": "Oleg Sukhodolsky",
          "commitDateOld": "11/05/03 12:31 AM",
          "commitNameOld": "bf6758b29dbb6f0e22d4951ea3bd25fdf45299fc",
          "commitAuthorOld": "Lars Khne",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,38 @@\n-        private ExpressionHandler getHandler(DetailAST aAst, \n-            ExpressionHandler aParent) \n-        {\n-            int type \u003d aAst.getType();            \n-            \n-            ExpressionHandler expHandler \u003d null;\n-            try {\n-                Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n-                    new Integer(type));\n-                if (handlerCtor !\u003d null) {\n-                    expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n-                        new Object[] {\n-                            IndentationCheck.this,\n-                            aAst,\n-                            aParent\n-                        }\n-                    );\n-                }\n-            } \n-            catch (InstantiationException e) {\n-                System.out.println(\"couldn\u0027t instantiate constructor for \" \n-                    + aAst);\n-                e.printStackTrace();\n-            } \n-            catch (IllegalAccessException e) {\n-                System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n-                e.printStackTrace();\n-            } \n-            catch (InvocationTargetException e) {\n-                System.out.println(\"couldn\u0027t instantiate constructor for \" \n-                    + aAst);\n-                e.printStackTrace();\n+    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n+        DetailAST aAst, ExpressionHandler aParent) \n+    {\n+        int type \u003d aAst.getType();\n+\n+        ExpressionHandler expHandler \u003d null;\n+        try {\n+            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n+                new Integer(type));\n+            if (handlerCtor !\u003d null) {\n+                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n+                    new Object[] {\n+                        aIndentCheck,\n+                        aAst,\n+                        aParent\n+                    }\n+                );\n             }\n-            if (expHandler \u003d\u003d null) {\n-                System.err.println(\"no handler for type \" + type);\n-            }\n-            return expHandler;\n-        }\n\\ No newline at end of file\n+        } \n+        catch (InstantiationException e) {\n+            System.out.println(\"couldn\u0027t instantiate constructor for \" \n+                + aAst);\n+            e.printStackTrace();\n+        } \n+        catch (IllegalAccessException e) {\n+            System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n+            e.printStackTrace();\n+        } \n+        catch (InvocationTargetException e) {\n+            System.out.println(\"couldn\u0027t instantiate constructor for \" \n+                + aAst);\n+            e.printStackTrace();\n+        }\n+        if (expHandler \u003d\u003d null) {\n+            System.err.println(\"no handler for type \" + type);\n+        }\n+        return expHandler;\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    public ExpressionHandler getHandler(IndentationCheck aIndentCheck,\n        DetailAST aAst, ExpressionHandler aParent) \n    {\n        int type \u003d aAst.getType();\n\n        ExpressionHandler expHandler \u003d null;\n        try {\n            Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n                new Integer(type));\n            if (handlerCtor !\u003d null) {\n                expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                    new Object[] {\n                        aIndentCheck,\n                        aAst,\n                        aParent\n                    }\n                );\n            }\n        } \n        catch (InstantiationException e) {\n            System.out.println(\"couldn\u0027t instantiate constructor for \" \n                + aAst);\n            e.printStackTrace();\n        } \n        catch (IllegalAccessException e) {\n            System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n            e.printStackTrace();\n        } \n        catch (InvocationTargetException e) {\n            System.out.println(\"couldn\u0027t instantiate constructor for \" \n                + aAst);\n            e.printStackTrace();\n        }\n        if (expHandler \u003d\u003d null) {\n            System.err.println(\"no handler for type \" + type);\n        }\n        return expHandler;\n    }",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java",
          "extendedDetails": {
            "oldValue": "[aAst-DetailAST, aParent-ExpressionHandler]",
            "newValue": "[aIndentCheck-IndentationCheck, aAst-DetailAST, aParent-ExpressionHandler]"
          }
        }
      ]
    },
    "9aab61241e7970ccfb4a9ee66c8eb7f062d31955": {
      "type": "Yintroduced",
      "commitMessage": "added IndentationCheck, contributed by John Richardson\nThis check currently fails to pass checkstyle.checkstyle\nbecause most methods are missing javadoc, I hope somebody\ncan help me adding it\n",
      "commitDate": "24/04/03 10:21 PM",
      "commitName": "9aab61241e7970ccfb4a9ee66c8eb7f062d31955",
      "commitAuthor": "Lars Khne",
      "diff": "@@ -0,0 +1,38 @@\n+        private ExpressionHandler getHandler(DetailAST aAst, \n+            ExpressionHandler aParent) \n+        {\n+            int type \u003d aAst.getType();            \n+            \n+            ExpressionHandler expHandler \u003d null;\n+            try {\n+                Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n+                    new Integer(type));\n+                if (handlerCtor !\u003d null) {\n+                    expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n+                        new Object[] {\n+                            IndentationCheck.this,\n+                            aAst,\n+                            aParent\n+                        }\n+                    );\n+                }\n+            } \n+            catch (InstantiationException e) {\n+                System.out.println(\"couldn\u0027t instantiate constructor for \" \n+                    + aAst);\n+                e.printStackTrace();\n+            } \n+            catch (IllegalAccessException e) {\n+                System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n+                e.printStackTrace();\n+            } \n+            catch (InvocationTargetException e) {\n+                System.out.println(\"couldn\u0027t instantiate constructor for \" \n+                    + aAst);\n+                e.printStackTrace();\n+            }\n+            if (expHandler \u003d\u003d null) {\n+                System.err.println(\"no handler for type \" + type);\n+            }\n+            return expHandler;\n+        }\n\\ No newline at end of file\n",
      "actualSource": "        private ExpressionHandler getHandler(DetailAST aAst, \n            ExpressionHandler aParent) \n        {\n            int type \u003d aAst.getType();            \n            \n            ExpressionHandler expHandler \u003d null;\n            try {\n                Constructor handlerCtor \u003d (Constructor) mTypeHandlers.get(\n                    new Integer(type));\n                if (handlerCtor !\u003d null) {\n                    expHandler \u003d (ExpressionHandler) handlerCtor.newInstance(\n                        new Object[] {\n                            IndentationCheck.this,\n                            aAst,\n                            aParent\n                        }\n                    );\n                }\n            } \n            catch (InstantiationException e) {\n                System.out.println(\"couldn\u0027t instantiate constructor for \" \n                    + aAst);\n                e.printStackTrace();\n            } \n            catch (IllegalAccessException e) {\n                System.out.println(\"couldn\u0027t access constructor for \" + aAst);\n                e.printStackTrace();\n            } \n            catch (InvocationTargetException e) {\n                System.out.println(\"couldn\u0027t instantiate constructor for \" \n                    + aAst);\n                e.printStackTrace();\n            }\n            if (expHandler \u003d\u003d null) {\n                System.err.println(\"no handler for type \" + type);\n            }\n            return expHandler;\n        }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/IndentationCheck.java"
    }
  }
}