{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "EmptyLineSeparatorCheck.java",
  "functionName": "visitToken",
  "functionId": "visitToken___ast-DetailAST",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
  "functionStartLine": 345,
  "functionEndLine": 363,
  "numCommitsSeen": 60,
  "timeTaken": 2853,
  "changeHistory": [
    "52a20827fd243de91654dd7b7fc190b2f434e486",
    "8c3743118478035f927056f958eb50a58aa30c2a",
    "4e4e659ba5c239b0d1216ab9a7630f229a5d6ecb",
    "65fe91df6a9712f3ec7af2ed963867a50303b0e9",
    "753e733c95f0a5183dfc3b29835f8b86e5df5316",
    "3b26b571a8dae611366c481aa1fce606ca1f1cfa",
    "fb5cf249885869256567d41798e14f2964a26192",
    "a0acabc125d3398e13655302500423c01e10dcb0",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "b9f232ffe08853fbfd0239d53d683d4fe5c6b817",
    "244eb9d0a9768cfba0b3b0561657ff3f56517c5d",
    "2db0dab62fc4986c3bebb38a1b8cac857f37664a",
    "209b22885ab63ab87c939a24c3ab5d9cf43d911d",
    "3f853ae96a24f2079901c3d47c6e6a7fa0604654",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
    "d97a2df674716efb7deda50180ae933bdc46d68a",
    "0518b753a40f1857516b356654e5d01834af2109",
    "a5031acb330edaa2311acbce4945f7b44fc76b29",
    "d9452c8d5e2cffcad33fbf763db8473fcbb42eab"
  ],
  "changeHistoryShort": {
    "52a20827fd243de91654dd7b7fc190b2f434e486": "Ybodychange",
    "8c3743118478035f927056f958eb50a58aa30c2a": "Ybodychange",
    "4e4e659ba5c239b0d1216ab9a7630f229a5d6ecb": "Ybodychange",
    "65fe91df6a9712f3ec7af2ed963867a50303b0e9": "Ybodychange",
    "753e733c95f0a5183dfc3b29835f8b86e5df5316": "Ybodychange",
    "3b26b571a8dae611366c481aa1fce606ca1f1cfa": "Ybodychange",
    "fb5cf249885869256567d41798e14f2964a26192": "Ybodychange",
    "a0acabc125d3398e13655302500423c01e10dcb0": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "b9f232ffe08853fbfd0239d53d683d4fe5c6b817": "Ybodychange",
    "244eb9d0a9768cfba0b3b0561657ff3f56517c5d": "Ybodychange",
    "2db0dab62fc4986c3bebb38a1b8cac857f37664a": "Ybodychange",
    "209b22885ab63ab87c939a24c3ab5d9cf43d911d": "Ybodychange",
    "3f853ae96a24f2079901c3d47c6e6a7fa0604654": "Ybodychange",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": "Ybodychange",
    "d97a2df674716efb7deda50180ae933bdc46d68a": "Ymultichange(Yparameterchange,Ybodychange)",
    "0518b753a40f1857516b356654e5d01834af2109": "Ybodychange",
    "a5031acb330edaa2311acbce4945f7b44fc76b29": "Ybodychange",
    "d9452c8d5e2cffcad33fbf763db8473fcbb42eab": "Yintroduced"
  },
  "changeHistoryDetails": {
    "52a20827fd243de91654dd7b7fc190b2f434e486": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4763: fix empty statement for comment under package\n",
      "commitDate": "20/12/19 10:31 AM",
      "commitName": "52a20827fd243de91654dd7b7fc190b2f434e486",
      "commitAuthor": "Andrei Paikin",
      "commitDateOld": "24/05/19 10:44 PM",
      "commitNameOld": "52ef591650329fc084db36637d7c10bf001071f4",
      "commitAuthorOld": "pbludov",
      "daysBetweenCommits": 209.53,
      "commitsBetweenForRepo": 448,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,19 @@\n     public void visitToken(DetailAST ast) {\n         checkComments(ast);\n         if (hasMultipleLinesBefore(ast)) {\n             log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n         }\n         if (!allowMultipleEmptyLinesInsideClassMembers) {\n             processMultipleLinesInside(ast);\n         }\n-\n+        if (ast.getType() \u003d\u003d TokenTypes.PACKAGE_DEF) {\n+            checkCommentInModifiers(ast);\n+        }\n         DetailAST nextToken \u003d ast.getNextSibling();\n         while (nextToken !\u003d null \u0026\u0026 isComment(nextToken)) {\n             nextToken \u003d nextToken.getNextSibling();\n         }\n         if (nextToken !\u003d null) {\n-            final int astType \u003d ast.getType();\n-            switch (astType) {\n-                case TokenTypes.VARIABLE_DEF:\n-                    processVariableDef(ast, nextToken);\n-                    break;\n-                case TokenTypes.IMPORT:\n-                case TokenTypes.STATIC_IMPORT:\n-                    processImport(ast, nextToken);\n-                    break;\n-                case TokenTypes.PACKAGE_DEF:\n-                    processPackage(ast, nextToken);\n-                    break;\n-                default:\n-                    if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n-                        if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n-                            log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n-                        }\n-                    }\n-                    else if (!hasEmptyLineAfter(ast)) {\n-                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n-                            nextToken.getText());\n-                    }\n-            }\n+            checkToken(ast, nextToken);\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        checkComments(ast);\n        if (hasMultipleLinesBefore(ast)) {\n            log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n        }\n        if (!allowMultipleEmptyLinesInsideClassMembers) {\n            processMultipleLinesInside(ast);\n        }\n        if (ast.getType() \u003d\u003d TokenTypes.PACKAGE_DEF) {\n            checkCommentInModifiers(ast);\n        }\n        DetailAST nextToken \u003d ast.getNextSibling();\n        while (nextToken !\u003d null \u0026\u0026 isComment(nextToken)) {\n            nextToken \u003d nextToken.getNextSibling();\n        }\n        if (nextToken !\u003d null) {\n            checkToken(ast, nextToken);\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "8c3743118478035f927056f958eb50a58aa30c2a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #5981: add validation of new lines before comments\n",
      "commitDate": "27/04/19 8:48 AM",
      "commitName": "8c3743118478035f927056f958eb50a58aa30c2a",
      "commitAuthor": "kazachka",
      "commitDateOld": "15/01/19 5:46 AM",
      "commitNameOld": "a73ff0890c27cbe8affc1a55f2710a231687bd85",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 102.08,
      "commitsBetweenForRepo": 207,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,39 @@\n     public void visitToken(DetailAST ast) {\n+        checkComments(ast);\n         if (hasMultipleLinesBefore(ast)) {\n             log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n         }\n         if (!allowMultipleEmptyLinesInsideClassMembers) {\n             processMultipleLinesInside(ast);\n         }\n \n         DetailAST nextToken \u003d ast.getNextSibling();\n         while (nextToken !\u003d null \u0026\u0026 isComment(nextToken)) {\n             nextToken \u003d nextToken.getNextSibling();\n         }\n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     processVariableDef(ast, nextToken);\n                     break;\n                 case TokenTypes.IMPORT:\n                 case TokenTypes.STATIC_IMPORT:\n                     processImport(ast, nextToken);\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     processPackage(ast, nextToken);\n                     break;\n                 default:\n                     if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n                         if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n                             log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n                         }\n                     }\n                     else if (!hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                             nextToken.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        checkComments(ast);\n        if (hasMultipleLinesBefore(ast)) {\n            log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n        }\n        if (!allowMultipleEmptyLinesInsideClassMembers) {\n            processMultipleLinesInside(ast);\n        }\n\n        DetailAST nextToken \u003d ast.getNextSibling();\n        while (nextToken !\u003d null \u0026\u0026 isComment(nextToken)) {\n            nextToken \u003d nextToken.getNextSibling();\n        }\n        if (nextToken !\u003d null) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    processVariableDef(ast, nextToken);\n                    break;\n                case TokenTypes.IMPORT:\n                case TokenTypes.STATIC_IMPORT:\n                    processImport(ast, nextToken);\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    processPackage(ast, nextToken);\n                    break;\n                default:\n                    if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n                        if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n                            log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n                        }\n                    }\n                    else if (!hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                            nextToken.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "4e4e659ba5c239b0d1216ab9a7630f229a5d6ecb": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4625: Unite type/static import for EmptyLineSeparatorCheck\n",
      "commitDate": "03/07/18 8:20 PM",
      "commitName": "4e4e659ba5c239b0d1216ab9a7630f229a5d6ecb",
      "commitAuthor": "Pavel Bludov",
      "commitDateOld": "03/06/18 9:40 PM",
      "commitNameOld": "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8",
      "commitAuthorOld": "Pavel Bludov",
      "daysBetweenCommits": 29.94,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,38 @@\n     public void visitToken(DetailAST ast) {\n         if (hasMultipleLinesBefore(ast)) {\n             log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n         }\n         if (!allowMultipleEmptyLinesInsideClassMembers) {\n             processMultipleLinesInside(ast);\n         }\n \n         DetailAST nextToken \u003d ast.getNextSibling();\n         while (nextToken !\u003d null \u0026\u0026 isComment(nextToken)) {\n             nextToken \u003d nextToken.getNextSibling();\n         }\n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     processVariableDef(ast, nextToken);\n                     break;\n                 case TokenTypes.IMPORT:\n-                    processImport(ast, nextToken, astType);\n+                case TokenTypes.STATIC_IMPORT:\n+                    processImport(ast, nextToken);\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     processPackage(ast, nextToken);\n                     break;\n                 default:\n                     if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n                         if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n                             log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n                         }\n                     }\n                     else if (!hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                             nextToken.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        if (hasMultipleLinesBefore(ast)) {\n            log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n        }\n        if (!allowMultipleEmptyLinesInsideClassMembers) {\n            processMultipleLinesInside(ast);\n        }\n\n        DetailAST nextToken \u003d ast.getNextSibling();\n        while (nextToken !\u003d null \u0026\u0026 isComment(nextToken)) {\n            nextToken \u003d nextToken.getNextSibling();\n        }\n        if (nextToken !\u003d null) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    processVariableDef(ast, nextToken);\n                    break;\n                case TokenTypes.IMPORT:\n                case TokenTypes.STATIC_IMPORT:\n                    processImport(ast, nextToken);\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    processPackage(ast, nextToken);\n                    break;\n                default:\n                    if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n                        if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n                            log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n                        }\n                    }\n                    else if (!hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                            nextToken.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "65fe91df6a9712f3ec7af2ed963867a50303b0e9": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3426: remove warning on PACKAGE_DEF preceded by javadoc not separated by line\n",
      "commitDate": "12/12/16 6:04 AM",
      "commitName": "65fe91df6a9712f3ec7af2ed963867a50303b0e9",
      "commitAuthor": "kazachka",
      "commitDateOld": "29/03/16 3:25 PM",
      "commitNameOld": "753e733c95f0a5183dfc3b29835f8b86e5df5316",
      "commitAuthorOld": "Vladislav Lisetskiy",
      "daysBetweenCommits": 257.65,
      "commitsBetweenForRepo": 480,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,37 @@\n     public void visitToken(DetailAST ast) {\n         if (hasMultipleLinesBefore(ast)) {\n             log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n         }\n         if (!allowMultipleEmptyLinesInsideClassMembers) {\n             processMultipleLinesInside(ast);\n         }\n \n-        final DetailAST nextToken \u003d ast.getNextSibling();\n+        DetailAST nextToken \u003d ast.getNextSibling();\n+        while (nextToken !\u003d null \u0026\u0026 isComment(nextToken)) {\n+            nextToken \u003d nextToken.getNextSibling();\n+        }\n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     processVariableDef(ast, nextToken);\n                     break;\n                 case TokenTypes.IMPORT:\n                     processImport(ast, nextToken, astType);\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     processPackage(ast, nextToken);\n                     break;\n                 default:\n                     if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n                         if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n                             log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n                         }\n                     }\n                     else if (!hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                             nextToken.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        if (hasMultipleLinesBefore(ast)) {\n            log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n        }\n        if (!allowMultipleEmptyLinesInsideClassMembers) {\n            processMultipleLinesInside(ast);\n        }\n\n        DetailAST nextToken \u003d ast.getNextSibling();\n        while (nextToken !\u003d null \u0026\u0026 isComment(nextToken)) {\n            nextToken \u003d nextToken.getNextSibling();\n        }\n        if (nextToken !\u003d null) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    processVariableDef(ast, nextToken);\n                    break;\n                case TokenTypes.IMPORT:\n                    processImport(ast, nextToken, astType);\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    processPackage(ast, nextToken);\n                    break;\n                default:\n                    if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n                        if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n                            log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n                        }\n                    }\n                    else if (!hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                            nextToken.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "753e733c95f0a5183dfc3b29835f8b86e5df5316": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2944: add EmptyLineSeparator option to check empty lines inside methods\n",
      "commitDate": "29/03/16 3:25 PM",
      "commitName": "753e733c95f0a5183dfc3b29835f8b86e5df5316",
      "commitAuthor": "Vladislav Lisetskiy",
      "commitDateOld": "17/03/16 6:39 AM",
      "commitNameOld": "167dd96d8ca503a472bf003f187191d6b0ce586c",
      "commitAuthorOld": "Rasmus Kaj",
      "daysBetweenCommits": 12.36,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,34 @@\n     public void visitToken(DetailAST ast) {\n         if (hasMultipleLinesBefore(ast)) {\n             log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n         }\n+        if (!allowMultipleEmptyLinesInsideClassMembers) {\n+            processMultipleLinesInside(ast);\n+        }\n \n         final DetailAST nextToken \u003d ast.getNextSibling();\n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     processVariableDef(ast, nextToken);\n                     break;\n                 case TokenTypes.IMPORT:\n                     processImport(ast, nextToken, astType);\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     processPackage(ast, nextToken);\n                     break;\n                 default:\n                     if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n                         if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n                             log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n                         }\n                     }\n                     else if (!hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                             nextToken.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        if (hasMultipleLinesBefore(ast)) {\n            log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n        }\n        if (!allowMultipleEmptyLinesInsideClassMembers) {\n            processMultipleLinesInside(ast);\n        }\n\n        final DetailAST nextToken \u003d ast.getNextSibling();\n        if (nextToken !\u003d null) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    processVariableDef(ast, nextToken);\n                    break;\n                case TokenTypes.IMPORT:\n                    processImport(ast, nextToken, astType);\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    processPackage(ast, nextToken);\n                    break;\n                default:\n                    if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n                        if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n                            log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n                        }\n                    }\n                    else if (!hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                            nextToken.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "3b26b571a8dae611366c481aa1fce606ca1f1cfa": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2067: Fix false-negatives in EmptyLineSeparatorCheck\n",
      "commitDate": "11/11/15 12:46 PM",
      "commitName": "3b26b571a8dae611366c481aa1fce606ca1f1cfa",
      "commitAuthor": "Vladislav Lisetskiy",
      "commitDateOld": "18/10/15 5:51 AM",
      "commitNameOld": "caa58734b9891ec51a113f861f6f1225ae6b499d",
      "commitAuthorOld": "Pavel Baranchikov",
      "daysBetweenCommits": 24.33,
      "commitsBetweenForRepo": 176,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,31 @@\n     public void visitToken(DetailAST ast) {\n-        final DetailAST nextToken \u003d ast.getNextSibling();\n+        if (hasMultipleLinesBefore(ast)) {\n+            log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+        }\n \n+        final DetailAST nextToken \u003d ast.getNextSibling();\n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     processVariableDef(ast, nextToken);\n                     break;\n                 case TokenTypes.IMPORT:\n                     processImport(ast, nextToken, astType);\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     processPackage(ast, nextToken);\n                     break;\n                 default:\n-                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n-                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n+                    if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n+                        if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n+                            log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n+                        }\n                     }\n-                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+                    else if (!hasEmptyLineAfter(ast)) {\n+                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n+                            nextToken.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        if (hasMultipleLinesBefore(ast)) {\n            log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n        }\n\n        final DetailAST nextToken \u003d ast.getNextSibling();\n        if (nextToken !\u003d null) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    processVariableDef(ast, nextToken);\n                    break;\n                case TokenTypes.IMPORT:\n                    processImport(ast, nextToken, astType);\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    processPackage(ast, nextToken);\n                    break;\n                default:\n                    if (nextToken.getType() \u003d\u003d TokenTypes.RCURLY) {\n                        if (hasNotAllowedTwoEmptyLinesBefore(nextToken)) {\n                            log(ast.getLineNo(), MSG_MULTIPLE_LINES_AFTER, ast.getText());\n                        }\n                    }\n                    else if (!hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                            nextToken.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "fb5cf249885869256567d41798e14f2964a26192": {
      "type": "Ybodychange",
      "commitMessage": "EmptyLineSeparator updated to follow Cyclomatic Complexity rule. #954\n",
      "commitDate": "14/06/15 9:56 PM",
      "commitName": "fb5cf249885869256567d41798e14f2964a26192",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "17/05/15 4:47 AM",
      "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 28.71,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,25 @@\n     public void visitToken(DetailAST ast) {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n-                    if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n-                        if (allowNoEmptyLineBetweenFields\n-                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n-                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n-                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n-                                 nextToken.getText());\n-                        }\n-                        else if (!allowNoEmptyLineBetweenFields\n-                                 \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n-                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n-                                 nextToken.getText());\n-                        }\n-                    }\n-                    if (isTypeField(ast) \u0026\u0026 hasNotAllowedTwoEmptyLinesBefore(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n-                    }\n+                    processVariableDef(ast, nextToken);\n                     break;\n                 case TokenTypes.IMPORT:\n-                    if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n-                        || ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n-                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null) {\n-                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n-                    }\n-                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n-                    }\n+                    processImport(ast, nextToken, astType);\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n-                    if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n-                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n-                    }\n-                    if (!hasEmptyLineAfter(ast)) {\n-                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n-                    }\n-                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n-                    }\n+                    processPackage(ast, nextToken);\n                     break;\n                 default:\n                     if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final DetailAST nextToken \u003d ast.getNextSibling();\n\n        if (nextToken !\u003d null) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    processVariableDef(ast, nextToken);\n                    break;\n                case TokenTypes.IMPORT:\n                    processImport(ast, nextToken, astType);\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    processPackage(ast, nextToken);\n                    break;\n                default:\n                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "a0acabc125d3398e13655302500423c01e10dcb0": {
      "type": "Ybodychange",
      "commitMessage": "Fix FallThrough check violation in code, issue #945\n",
      "commitDate": "03/05/15 11:34 AM",
      "commitName": "a0acabc125d3398e13655302500423c01e10dcb0",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "10/03/15 2:36 PM",
      "commitNameOld": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 53.87,
      "commitsBetweenForRepo": 271,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,60 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                         else if (!allowNoEmptyLineBetweenFields\n                                  \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                     }\n                     if (isTypeField(ast) \u0026\u0026 hasNotAllowedTwoEmptyLinesBefore(ast))\n                     {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                         || ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null)\n                     {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                         log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                     }\n+                    if (!hasEmptyLineAfter(ast)) {\n+                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n+                    }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n+                    break;\n                 default:\n                     if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final DetailAST nextToken \u003d ast.getNextSibling();\n\n        if (nextToken !\u003d null) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        if (allowNoEmptyLineBetweenFields\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                        {\n                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                 nextToken.getText());\n                        }\n                        else if (!allowNoEmptyLineBetweenFields\n                                 \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                        {\n                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                 nextToken.getText());\n                        }\n                    }\n                    if (isTypeField(ast) \u0026\u0026 hasNotAllowedTwoEmptyLinesBefore(ast))\n                    {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                case TokenTypes.IMPORT:\n                    if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                        || ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null)\n                    {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                    }\n                    if (!hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                default:\n                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": "10/03/15 2:36 PM",
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "10/03/15 12:58 PM",
      "commitNameOld": "b9f232ffe08853fbfd0239d53d683d4fe5c6b817",
      "commitAuthorOld": "liscju",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                         else if (!allowNoEmptyLineBetweenFields\n                                  \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                     }\n                     if (isTypeField(ast) \u0026\u0026 hasNotAllowedTwoEmptyLinesBefore(ast))\n                     {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n-                        || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n-                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n+                        || ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n+                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null)\n                     {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                         log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                     }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                 default:\n                     if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final DetailAST nextToken \u003d ast.getNextSibling();\n\n        if (nextToken !\u003d null) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        if (allowNoEmptyLineBetweenFields\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                        {\n                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                 nextToken.getText());\n                        }\n                        else if (!allowNoEmptyLineBetweenFields\n                                 \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                        {\n                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                 nextToken.getText());\n                        }\n                    }\n                    if (isTypeField(ast) \u0026\u0026 hasNotAllowedTwoEmptyLinesBefore(ast))\n                    {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                case TokenTypes.IMPORT:\n                    if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                        || ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null)\n                    {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                    }\n                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                default:\n                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "b9f232ffe08853fbfd0239d53d683d4fe5c6b817": {
      "type": "Ybodychange",
      "commitMessage": "Fix bug with multiple imports, part of issue #706\n",
      "commitDate": "10/03/15 12:58 PM",
      "commitName": "b9f232ffe08853fbfd0239d53d683d4fe5c6b817",
      "commitAuthor": "liscju",
      "commitDateOld": "06/03/15 7:41 AM",
      "commitNameOld": "244eb9d0a9768cfba0b3b0561657ff3f56517c5d",
      "commitAuthorOld": "liscju",
      "daysBetweenCommits": 4.18,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,56 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                         else if (!allowNoEmptyLineBetweenFields\n                                  \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                     }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n-                             \u0026\u0026 isPrePreviousLineEmpty(ast))\n+                    if (isTypeField(ast) \u0026\u0026 hasNotAllowedTwoEmptyLinesBefore(ast))\n                     {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                         || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                     {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                         log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                     }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                 default:\n                     if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final DetailAST nextToken \u003d ast.getNextSibling();\n\n        if (nextToken !\u003d null) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        if (allowNoEmptyLineBetweenFields\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                        {\n                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                 nextToken.getText());\n                        }\n                        else if (!allowNoEmptyLineBetweenFields\n                                 \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                        {\n                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                 nextToken.getText());\n                        }\n                    }\n                    if (isTypeField(ast) \u0026\u0026 hasNotAllowedTwoEmptyLinesBefore(ast))\n                    {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                case TokenTypes.IMPORT:\n                    if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                        || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                    {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                    }\n                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                default:\n                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (hasNotAllowedTwoEmptyLinesBefore(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "244eb9d0a9768cfba0b3b0561657ff3f56517c5d": {
      "type": "Ybodychange",
      "commitMessage": "Fix bugs with multiple fields, part of issue #706\n",
      "commitDate": "06/03/15 7:41 AM",
      "commitName": "244eb9d0a9768cfba0b3b0561657ff3f56517c5d",
      "commitAuthor": "liscju",
      "commitDateOld": "18/02/15 1:14 PM",
      "commitNameOld": "c9a9e6508c15e00cf6820b213d79d5ebf41c6343",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 15.77,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,57 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n-                        else if ((!allowNoEmptyLineBetweenFields || !allowMultipleEmptyLines)\n+                        else if (!allowNoEmptyLineBetweenFields\n                                  \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n                             log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                     }\n                     if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n                              \u0026\u0026 isPrePreviousLineEmpty(ast))\n                     {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                         || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                     {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                         log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                     }\n                     if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                 default:\n                     if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                     }\n                     if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                         log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final DetailAST nextToken \u003d ast.getNextSibling();\n\n        if (nextToken !\u003d null) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        if (allowNoEmptyLineBetweenFields\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                        {\n                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                 nextToken.getText());\n                        }\n                        else if (!allowNoEmptyLineBetweenFields\n                                 \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                        {\n                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                 nextToken.getText());\n                        }\n                    }\n                    if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n                             \u0026\u0026 isPrePreviousLineEmpty(ast))\n                    {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                case TokenTypes.IMPORT:\n                    if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                        || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                    {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                    }\n                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                default:\n                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "2db0dab62fc4986c3bebb38a1b8cac857f37664a": {
      "type": "Ybodychange",
      "commitMessage": "Empty Line Separator Check, added option for managing empty lines between class members, issue #530\n",
      "commitDate": "01/02/15 2:00 AM",
      "commitName": "2db0dab62fc4986c3bebb38a1b8cac857f37664a",
      "commitAuthor": "alexkravin",
      "commitDateOld": "31/01/15 7:48 PM",
      "commitNameOld": "209b22885ab63ab87c939a24c3ab5d9cf43d911d",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,57 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n-        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n+        if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n-                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n+                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n+                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                         {\n-                            log(nextToken.getLineNo(), \"empty.line.separator\",\n+                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n-                        else if (!allowNoEmptyLineBetweenFields) {\n-                            log(nextToken.getLineNo(), \"empty.line.separator\",\n+                        else if ((!allowNoEmptyLineBetweenFields || !allowMultipleEmptyLines)\n+                                 \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n+                        {\n+                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                     }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n+                             \u0026\u0026 isPrePreviousLineEmpty(ast))\n+                    {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+                    }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                         || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                     {\n-                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n+                    }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n-                        log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n+                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n+                    }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                 default:\n-                    if (!hasEmptyLineAfter(ast)) {\n-                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n+                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n+                    }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final DetailAST nextToken \u003d ast.getNextSibling();\n\n        if (nextToken !\u003d null) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        if (allowNoEmptyLineBetweenFields\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                        {\n                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                 nextToken.getText());\n                        }\n                        else if ((!allowNoEmptyLineBetweenFields || !allowMultipleEmptyLines)\n                                 \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY)\n                        {\n                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                 nextToken.getText());\n                        }\n                    }\n                    if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n                             \u0026\u0026 isPrePreviousLineEmpty(ast))\n                    {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                case TokenTypes.IMPORT:\n                    if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                        || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                    {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                    }\n                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                default:\n                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "209b22885ab63ab87c939a24c3ab5d9cf43d911d": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Empty Line Separator Check, added option for managing empty lines between class members, issue #530\"\n\nThis reverts commit 3f853ae96a24f2079901c3d47c6e6a7fa0604654.\n",
      "commitDate": "31/01/15 7:48 PM",
      "commitName": "209b22885ab63ab87c939a24c3ab5d9cf43d911d",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "28/01/15 10:14 PM",
      "commitNameOld": "3f853ae96a24f2079901c3d47c6e6a7fa0604654",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 2.9,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,40 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n-        if (nextToken !\u003d null) {\n+        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                         {\n-                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n+                            log(nextToken.getLineNo(), \"empty.line.separator\",\n                                  nextToken.getText());\n                         }\n-                        else if (!allowNoEmptyLineBetweenFields || !allowMultipleEmptyLines) {\n-                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n+                        else if (!allowNoEmptyLineBetweenFields) {\n+                            log(nextToken.getLineNo(), \"empty.line.separator\",\n                                  nextToken.getText());\n                         }\n                     }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n-                             \u0026\u0026 isPrePreviousLineEmpty(ast))\n-                    {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n-                    }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                         || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                     {\n-                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n-                    }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n-                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n-                    }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+                        log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n                     }\n                 default:\n-                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n-                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n-                    }\n-                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n-                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+                    if (!hasEmptyLineAfter(ast)) {\n+                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final DetailAST nextToken \u003d ast.getNextSibling();\n\n        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        if (allowNoEmptyLineBetweenFields\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                        {\n                            log(nextToken.getLineNo(), \"empty.line.separator\",\n                                 nextToken.getText());\n                        }\n                        else if (!allowNoEmptyLineBetweenFields) {\n                            log(nextToken.getLineNo(), \"empty.line.separator\",\n                                 nextToken.getText());\n                        }\n                    }\n                    break;\n                case TokenTypes.IMPORT:\n                    if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                        || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                    {\n                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                    }\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                        log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n                    }\n                default:\n                    if (!hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "3f853ae96a24f2079901c3d47c6e6a7fa0604654": {
      "type": "Ybodychange",
      "commitMessage": "Empty Line Separator Check, added option for managing empty lines between class members, issue #530\n",
      "commitDate": "28/01/15 10:14 PM",
      "commitName": "3f853ae96a24f2079901c3d47c6e6a7fa0604654",
      "commitAuthor": "alexkravin",
      "commitDateOld": "22/01/15 4:31 AM",
      "commitNameOld": "7487028f2ab4b37432ce6e87416a308adbab9282",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 6.74,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,54 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n-        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n+        if (nextToken !\u003d null) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n                 case TokenTypes.VARIABLE_DEF:\n                     if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                         if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                         {\n-                            log(nextToken.getLineNo(), \"empty.line.separator\",\n+                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n-                        else if (!allowNoEmptyLineBetweenFields) {\n-                            log(nextToken.getLineNo(), \"empty.line.separator\",\n+                        else if (!allowNoEmptyLineBetweenFields || !allowMultipleEmptyLines) {\n+                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                  nextToken.getText());\n                         }\n                     }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n+                             \u0026\u0026 isPrePreviousLineEmpty(ast))\n+                    {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n+                    }\n                     break;\n                 case TokenTypes.IMPORT:\n                     if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                         || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                     {\n-                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n+                    }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                     break;\n                 case TokenTypes.PACKAGE_DEF:\n                     if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n-                        log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n+                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n+                    }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n                 default:\n-                    if (!hasEmptyLineAfter(ast)) {\n-                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n+                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n+                    }\n+                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n+                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                     }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final DetailAST nextToken \u003d ast.getNextSibling();\n\n        if (nextToken !\u003d null) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n                case TokenTypes.VARIABLE_DEF:\n                    if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        if (allowNoEmptyLineBetweenFields\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                        {\n                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                 nextToken.getText());\n                        }\n                        else if (!allowNoEmptyLineBetweenFields || !allowMultipleEmptyLines) {\n                            log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED,\n                                 nextToken.getText());\n                        }\n                    }\n                    if (!allowMultipleEmptyLines \u0026\u0026 isTypeField(ast)\n                             \u0026\u0026 isPrePreviousLineEmpty(ast))\n                    {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                case TokenTypes.IMPORT:\n                    if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                        || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                    {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                    break;\n                case TokenTypes.PACKAGE_DEF:\n                    if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                        log(ast.getLineNo(), MSG_SHOULD_BE_SEPARATED, ast.getText());\n                    }\n                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n                default:\n                    if (nextToken.getType() !\u003d TokenTypes.RCURLY \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                        log(nextToken.getLineNo(), MSG_SHOULD_BE_SEPARATED, nextToken.getText());\n                    }\n                    if (!allowMultipleEmptyLines \u0026\u0026 isPrePreviousLineEmpty(ast)) {\n                        log(ast.getLineNo(), MSG_MULTIPLE_LINES, ast.getText());\n                    }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": {
      "type": "Ybodychange",
      "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
      "commitDate": "19/01/15 6:38 AM",
      "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
      "commitAuthor": "alexkravin",
      "commitDateOld": "19/01/15 6:20 AM",
      "commitNameOld": "d97a2df674716efb7deda50180ae933bdc46d68a",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n     public void visitToken(DetailAST ast)\n     {\n         final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n             final int astType \u003d ast.getType();\n             switch (astType) {\n             case TokenTypes.VARIABLE_DEF:\n-                if (iastypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n+                if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                     if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                     {\n                         log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                     }\n                     else if (!allowNoEmptyLineBetweenFields) {\n                         log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                     }\n                 }\n                 break;\n             case TokenTypes.IMPORT:\n                 if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                     || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                             \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                 {\n                     log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n                 break;\n             case TokenTypes.PACKAGE_DEF:\n                 if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                     log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n                 }\n             default:\n                 if (!hasEmptyLineAfter(ast)) {\n                     log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final DetailAST nextToken \u003d ast.getNextSibling();\n\n        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n            case TokenTypes.VARIABLE_DEF:\n                if (isTypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                    if (allowNoEmptyLineBetweenFields\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                    {\n                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                    }\n                    else if (!allowNoEmptyLineBetweenFields) {\n                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                    }\n                }\n                break;\n            case TokenTypes.IMPORT:\n                if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                    || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                {\n                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                }\n                break;\n            case TokenTypes.PACKAGE_DEF:\n                if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                    log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n                }\n            default:\n                if (!hasEmptyLineAfter(ast)) {\n                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "d97a2df674716efb7deda50180ae933bdc46d68a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, whitespace, #512\n",
      "commitDate": "19/01/15 6:20 AM",
      "commitName": "d97a2df674716efb7deda50180ae933bdc46d68a",
      "commitAuthor": "alexkravin",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Prefixes, whitespace, #512\n",
          "commitDate": "19/01/15 6:20 AM",
          "commitName": "d97a2df674716efb7deda50180ae933bdc46d68a",
          "commitAuthor": "alexkravin",
          "commitDateOld": "08/08/14 1:44 PM",
          "commitNameOld": "0518b753a40f1857516b356654e5d01834af2109",
          "commitAuthorOld": "Max",
          "daysBetweenCommits": 163.73,
          "commitsBetweenForRepo": 372,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,38 @@\n-    public void visitToken(DetailAST aAST)\n+    public void visitToken(DetailAST ast)\n     {\n-        final DetailAST nextToken \u003d aAST.getNextSibling();\n+        final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n-            final int astType \u003d aAST.getType();\n+            final int astType \u003d ast.getType();\n             switch (astType) {\n             case TokenTypes.VARIABLE_DEF:\n-                if (isTypeField(aAST) \u0026\u0026 !hasEmptyLineAfter(aAST)) {\n-                    if (mAllowNoEmptyLineBetweenFields\n+                if (iastypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n+                    if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                     {\n                         log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                     }\n-                    else if (!mAllowNoEmptyLineBetweenFields) {\n+                    else if (!allowNoEmptyLineBetweenFields) {\n                         log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                     }\n                 }\n                 break;\n             case TokenTypes.IMPORT:\n-                if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(aAST)\n-                    || (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)\n-                            \u0026\u0026 aAST.getPreviousSibling() \u003d\u003d null))\n+                if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n+                    || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n+                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                 {\n                     log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n                 break;\n             case TokenTypes.PACKAGE_DEF:\n-                if (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)) {\n-                    log(aAST.getLineNo(), \"empty.line.separator\", aAST.getText());\n+                if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n+                    log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n                 }\n             default:\n-                if (!hasEmptyLineAfter(aAST)) {\n+                if (!hasEmptyLineAfter(ast)) {\n                     log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final DetailAST nextToken \u003d ast.getNextSibling();\n\n        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n            case TokenTypes.VARIABLE_DEF:\n                if (iastypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                    if (allowNoEmptyLineBetweenFields\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                    {\n                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                    }\n                    else if (!allowNoEmptyLineBetweenFields) {\n                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                    }\n                }\n                break;\n            case TokenTypes.IMPORT:\n                if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                    || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                {\n                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                }\n                break;\n            case TokenTypes.PACKAGE_DEF:\n                if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                    log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n                }\n            default:\n                if (!hasEmptyLineAfter(ast)) {\n                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                }\n            }\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
          "extendedDetails": {
            "oldValue": "[aAST-DetailAST]",
            "newValue": "[ast-DetailAST]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Prefixes, whitespace, #512\n",
          "commitDate": "19/01/15 6:20 AM",
          "commitName": "d97a2df674716efb7deda50180ae933bdc46d68a",
          "commitAuthor": "alexkravin",
          "commitDateOld": "08/08/14 1:44 PM",
          "commitNameOld": "0518b753a40f1857516b356654e5d01834af2109",
          "commitAuthorOld": "Max",
          "daysBetweenCommits": 163.73,
          "commitsBetweenForRepo": 372,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,38 @@\n-    public void visitToken(DetailAST aAST)\n+    public void visitToken(DetailAST ast)\n     {\n-        final DetailAST nextToken \u003d aAST.getNextSibling();\n+        final DetailAST nextToken \u003d ast.getNextSibling();\n \n         if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n-            final int astType \u003d aAST.getType();\n+            final int astType \u003d ast.getType();\n             switch (astType) {\n             case TokenTypes.VARIABLE_DEF:\n-                if (isTypeField(aAST) \u0026\u0026 !hasEmptyLineAfter(aAST)) {\n-                    if (mAllowNoEmptyLineBetweenFields\n+                if (iastypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n+                    if (allowNoEmptyLineBetweenFields\n                             \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                     {\n                         log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                     }\n-                    else if (!mAllowNoEmptyLineBetweenFields) {\n+                    else if (!allowNoEmptyLineBetweenFields) {\n                         log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                     }\n                 }\n                 break;\n             case TokenTypes.IMPORT:\n-                if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(aAST)\n-                    || (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)\n-                            \u0026\u0026 aAST.getPreviousSibling() \u003d\u003d null))\n+                if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n+                    || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n+                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                 {\n                     log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n                 break;\n             case TokenTypes.PACKAGE_DEF:\n-                if (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)) {\n-                    log(aAST.getLineNo(), \"empty.line.separator\", aAST.getText());\n+                if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n+                    log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n                 }\n             default:\n-                if (!hasEmptyLineAfter(aAST)) {\n+                if (!hasEmptyLineAfter(ast)) {\n                     log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final DetailAST nextToken \u003d ast.getNextSibling();\n\n        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n            final int astType \u003d ast.getType();\n            switch (astType) {\n            case TokenTypes.VARIABLE_DEF:\n                if (iastypeField(ast) \u0026\u0026 !hasEmptyLineAfter(ast)) {\n                    if (allowNoEmptyLineBetweenFields\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                    {\n                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                    }\n                    else if (!allowNoEmptyLineBetweenFields) {\n                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                    }\n                }\n                break;\n            case TokenTypes.IMPORT:\n                if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(ast)\n                    || (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)\n                            \u0026\u0026 ast.getPreviousSibling() \u003d\u003d null))\n                {\n                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                }\n                break;\n            case TokenTypes.PACKAGE_DEF:\n                if (ast.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(ast)) {\n                    log(ast.getLineNo(), \"empty.line.separator\", ast.getText());\n                }\n            default:\n                if (!hasEmptyLineAfter(ast)) {\n                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                }\n            }\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
          "extendedDetails": {}
        }
      ]
    },
    "0518b753a40f1857516b356654e5d01834af2109": {
      "type": "Ybodychange",
      "commitMessage": "Update for EmptyLineSeparatorCheck #227\n",
      "commitDate": "08/08/14 1:44 PM",
      "commitName": "0518b753a40f1857516b356654e5d01834af2109",
      "commitAuthor": "Max",
      "commitDateOld": "06/08/14 10:49 PM",
      "commitNameOld": "a5031acb330edaa2311acbce4945f7b44fc76b29",
      "commitAuthorOld": "Max",
      "daysBetweenCommits": 1.62,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,38 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final DetailAST nextToken \u003d aAST.getNextSibling();\n \n         if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n             final int astType \u003d aAST.getType();\n             switch (astType) {\n             case TokenTypes.VARIABLE_DEF:\n                 if (isTypeField(aAST) \u0026\u0026 !hasEmptyLineAfter(aAST)) {\n-                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                    if (mAllowNoEmptyLineBetweenFields\n+                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n+                    {\n+                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                    }\n+                    else if (!mAllowNoEmptyLineBetweenFields) {\n+                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n+                    }\n                 }\n                 break;\n             case TokenTypes.IMPORT:\n                 if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(aAST)\n                     || (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)\n                             \u0026\u0026 aAST.getPreviousSibling() \u003d\u003d null))\n                 {\n                     log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n                 break;\n             case TokenTypes.PACKAGE_DEF:\n                 if (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)) {\n                     log(aAST.getLineNo(), \"empty.line.separator\", aAST.getText());\n                 }\n             default:\n                 if (!hasEmptyLineAfter(aAST)) {\n                     log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST aAST)\n    {\n        final DetailAST nextToken \u003d aAST.getNextSibling();\n\n        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n            final int astType \u003d aAST.getType();\n            switch (astType) {\n            case TokenTypes.VARIABLE_DEF:\n                if (isTypeField(aAST) \u0026\u0026 !hasEmptyLineAfter(aAST)) {\n                    if (mAllowNoEmptyLineBetweenFields\n                            \u0026\u0026 nextToken.getType() !\u003d TokenTypes.VARIABLE_DEF)\n                    {\n                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                    }\n                    else if (!mAllowNoEmptyLineBetweenFields) {\n                        log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                    }\n                }\n                break;\n            case TokenTypes.IMPORT:\n                if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(aAST)\n                    || (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)\n                            \u0026\u0026 aAST.getPreviousSibling() \u003d\u003d null))\n                {\n                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                }\n                break;\n            case TokenTypes.PACKAGE_DEF:\n                if (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)) {\n                    log(aAST.getLineNo(), \"empty.line.separator\", aAST.getText());\n                }\n            default:\n                if (!hasEmptyLineAfter(aAST)) {\n                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "a5031acb330edaa2311acbce4945f7b44fc76b29": {
      "type": "Ybodychange",
      "commitMessage": "EmptyLineSeparatorCheck was updated #218\n",
      "commitDate": "06/08/14 10:49 PM",
      "commitName": "a5031acb330edaa2311acbce4945f7b44fc76b29",
      "commitAuthor": "Max",
      "commitDateOld": "16/07/14 12:06 PM",
      "commitNameOld": "af8d57317fd308e72ab9041200df10506b96870f",
      "commitAuthorOld": "Max",
      "daysBetweenCommits": 21.45,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,31 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final DetailAST nextToken \u003d aAST.getNextSibling();\n \n         if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n             final int astType \u003d aAST.getType();\n             switch (astType) {\n             case TokenTypes.VARIABLE_DEF:\n-                if (isTypeField(aAST) \u0026\u0026 !hasBlankLineAfter(aAST)) {\n-                    log(nextToken.getLineNo(),\n-                            \"empty.line.separator\", nextToken.getText());\n+                if (isTypeField(aAST) \u0026\u0026 !hasEmptyLineAfter(aAST)) {\n+                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n                 break;\n             case TokenTypes.IMPORT:\n-                if (astType !\u003d nextToken.getType()\n-                    \u0026\u0026 !hasBlankLineAfter(aAST))\n+                if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(aAST)\n+                    || (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)\n+                            \u0026\u0026 aAST.getPreviousSibling() \u003d\u003d null))\n                 {\n-                    log(nextToken.getLineNo(),\n-                            \"empty.line.separator\", nextToken.getText());\n+                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n                 break;\n+            case TokenTypes.PACKAGE_DEF:\n+                if (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)) {\n+                    log(aAST.getLineNo(), \"empty.line.separator\", aAST.getText());\n+                }\n             default:\n-                if (!hasBlankLineAfter(aAST)) {\n-                    log(nextToken.getLineNo(),\n-                            \"empty.line.separator\", nextToken.getText());\n+                if (!hasEmptyLineAfter(aAST)) {\n+                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST aAST)\n    {\n        final DetailAST nextToken \u003d aAST.getNextSibling();\n\n        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n            final int astType \u003d aAST.getType();\n            switch (astType) {\n            case TokenTypes.VARIABLE_DEF:\n                if (isTypeField(aAST) \u0026\u0026 !hasEmptyLineAfter(aAST)) {\n                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                }\n                break;\n            case TokenTypes.IMPORT:\n                if (astType !\u003d nextToken.getType() \u0026\u0026 !hasEmptyLineAfter(aAST)\n                    || (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)\n                            \u0026\u0026 aAST.getPreviousSibling() \u003d\u003d null))\n                {\n                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                }\n                break;\n            case TokenTypes.PACKAGE_DEF:\n                if (aAST.getLineNo() \u003e 1 \u0026\u0026 !hasEmptyLineBefore(aAST)) {\n                    log(aAST.getLineNo(), \"empty.line.separator\", aAST.getText());\n                }\n            default:\n                if (!hasEmptyLineAfter(aAST)) {\n                    log(nextToken.getLineNo(), \"empty.line.separator\", nextToken.getText());\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java",
      "extendedDetails": {}
    },
    "d9452c8d5e2cffcad33fbf763db8473fcbb42eab": {
      "type": "Yintroduced",
      "commitMessage": "EmptyLineSeparatorCheck #186. Exactly one blank line separates each section that is present.\n",
      "commitDate": "15/07/14 8:08 PM",
      "commitName": "d9452c8d5e2cffcad33fbf763db8473fcbb42eab",
      "commitAuthor": "Max",
      "diff": "@@ -0,0 +1,29 @@\n+    public void visitToken(DetailAST aAST)\n+    {\n+        final DetailAST nextToken \u003d aAST.getNextSibling();\n+\n+        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n+            final int astType \u003d aAST.getType();\n+            switch (astType) {\n+            case TokenTypes.VARIABLE_DEF:\n+                if (isTypeField(aAST) \u0026\u0026 !hasBlankLineAfter(aAST)) {\n+                    log(nextToken.getLineNo(),\n+                            \"empty.line.separator\", nextToken.getText());\n+                }\n+                break;\n+            case TokenTypes.IMPORT:\n+                if (astType !\u003d nextToken.getType()\n+                    \u0026\u0026 !hasBlankLineAfter(aAST))\n+                {\n+                    log(nextToken.getLineNo(),\n+                            \"empty.line.separator\", nextToken.getText());\n+                }\n+                break;\n+            default:\n+                if (!hasBlankLineAfter(aAST)) {\n+                    log(nextToken.getLineNo(),\n+                            \"empty.line.separator\", nextToken.getText());\n+                }\n+            }\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST aAST)\n    {\n        final DetailAST nextToken \u003d aAST.getNextSibling();\n\n        if (nextToken !\u003d null \u0026\u0026 nextToken.getType() !\u003d TokenTypes.RCURLY) {\n            final int astType \u003d aAST.getType();\n            switch (astType) {\n            case TokenTypes.VARIABLE_DEF:\n                if (isTypeField(aAST) \u0026\u0026 !hasBlankLineAfter(aAST)) {\n                    log(nextToken.getLineNo(),\n                            \"empty.line.separator\", nextToken.getText());\n                }\n                break;\n            case TokenTypes.IMPORT:\n                if (astType !\u003d nextToken.getType()\n                    \u0026\u0026 !hasBlankLineAfter(aAST))\n                {\n                    log(nextToken.getLineNo(),\n                            \"empty.line.separator\", nextToken.getText());\n                }\n                break;\n            default:\n                if (!hasBlankLineAfter(aAST)) {\n                    log(nextToken.getLineNo(),\n                            \"empty.line.separator\", nextToken.getText());\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java"
    }
  }
}