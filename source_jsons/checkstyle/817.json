{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ConfigurationLoader.java",
  "functionName": "parsePropertyString",
  "functionId": "parsePropertyString___value-String__fragments-List__String____propertyRefs-List__String__",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
  "functionStartLine": 406,
  "functionEndLine": 456,
  "numCommitsSeen": 238,
  "timeTaken": 3181,
  "changeHistory": [
    "84dbecdb8b2279470ec416f7a66ca0c7a8cf9687",
    "96641268d6ecdae405692c7e4471856a342cc062",
    "423ed9e469db620671459827b58c89025d8f6c66",
    "085ce12db0983590844ccc24ea49f91686a30ed8",
    "6c19362738598c7addaafc1f906058f49fadc2a4",
    "dd6b080a16e0933b3d19305f84ba01c8893839f3",
    "a733182557aa0dc686be57f7f5a7009a7015274b",
    "1c42e3eeb9aeebc47b2373541c1cc8d311d8b671",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "f1afaf83f39b83cc3bd07a2388448b262652a76b",
    "ee2e1a5cb3c7dd02bf6b63c418126e41735ee0ea",
    "33b6e5d9fc6fae514f508e580d84626dd202c0bb",
    "a955b402b7db322df8f073a0e8f7a3abd8449f17"
  ],
  "changeHistoryShort": {
    "84dbecdb8b2279470ec416f7a66ca0c7a8cf9687": "Ybodychange",
    "96641268d6ecdae405692c7e4471856a342cc062": "Ybodychange",
    "423ed9e469db620671459827b58c89025d8f6c66": "Ybodychange",
    "085ce12db0983590844ccc24ea49f91686a30ed8": "Ybodychange",
    "6c19362738598c7addaafc1f906058f49fadc2a4": "Ybodychange",
    "dd6b080a16e0933b3d19305f84ba01c8893839f3": "Ybodychange",
    "a733182557aa0dc686be57f7f5a7009a7015274b": "Ybodychange",
    "1c42e3eeb9aeebc47b2373541c1cc8d311d8b671": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": "Ymultichange(Yparameterchange,Ybodychange)",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "f1afaf83f39b83cc3bd07a2388448b262652a76b": "Yparameterchange",
    "ee2e1a5cb3c7dd02bf6b63c418126e41735ee0ea": "Ymultichange(Ymovefromfile,Ymodifierchange)",
    "33b6e5d9fc6fae514f508e580d84626dd202c0bb": "Ymultichange(Yparameterchange,Ybodychange)",
    "a955b402b7db322df8f073a0e8f7a3abd8449f17": "Yintroduced"
  },
  "changeHistoryDetails": {
    "84dbecdb8b2279470ec416f7a66ca0c7a8cf9687": {
      "type": "Ybodychange",
      "commitMessage": "Issue #5949: fix \u0027if statement with identical branches\u0027 violations\n",
      "commitDate": "23/06/18 7:20 AM",
      "commitName": "84dbecdb8b2279470ec416f7a66ca0c7a8cf9687",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "09/06/18 10:46 AM",
      "commitNameOld": "6be04d9e540bb1a76419030b1b608c2960af2692",
      "commitAuthorOld": "Subbu Dantu",
      "daysBetweenCommits": 13.86,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,51 @@\n     private static void parsePropertyString(String value,\n                                            List\u003cString\u003e fragments,\n                                            List\u003cString\u003e propertyRefs)\n             throws CheckstyleException {\n         int prev \u003d 0;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n         int pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n         while (pos \u003e\u003d 0) {\n             //if there was any text before this, add it as a fragment\n             if (pos \u003e 0) {\n                 fragments.add(value.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d value.length() - 1) {\n                 fragments.add(String.valueOf(DOLLAR_SIGN));\n                 prev \u003d pos + 1;\n             }\n             else if (value.charAt(pos + 1) \u003d\u003d \u0027{\u0027) {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003d\u003d -1) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + value);\n                 }\n                 final String propertyName \u003d value.substring(pos + 2, endName);\n                 fragments.add(null);\n                 propertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n             else {\n                 if (value.charAt(pos + 1) \u003d\u003d DOLLAR_SIGN) {\n                     //backwards compatibility two $ map to one mode\n                     fragments.add(String.valueOf(DOLLAR_SIGN));\n-                    prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                     fragments.add(value.substring(pos, pos + 2));\n-                    prev \u003d pos + 2;\n                 }\n+                prev \u003d pos + 2;\n             }\n \n             //search for the next instance of $ from the \u0027prev\u0027 position\n             pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c value.length()) {\n             fragments.add(value.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private static void parsePropertyString(String value,\n                                           List\u003cString\u003e fragments,\n                                           List\u003cString\u003e propertyRefs)\n            throws CheckstyleException {\n        int prev \u003d 0;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        int pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n        while (pos \u003e\u003d 0) {\n            //if there was any text before this, add it as a fragment\n            if (pos \u003e 0) {\n                fragments.add(value.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d value.length() - 1) {\n                fragments.add(String.valueOf(DOLLAR_SIGN));\n                prev \u003d pos + 1;\n            }\n            else if (value.charAt(pos + 1) \u003d\u003d \u0027{\u0027) {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                if (endName \u003d\u003d -1) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + value);\n                }\n                final String propertyName \u003d value.substring(pos + 2, endName);\n                fragments.add(null);\n                propertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n            else {\n                if (value.charAt(pos + 1) \u003d\u003d DOLLAR_SIGN) {\n                    //backwards compatibility two $ map to one mode\n                    fragments.add(String.valueOf(DOLLAR_SIGN));\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    fragments.add(value.substring(pos, pos + 2));\n                }\n                prev \u003d pos + 2;\n            }\n\n            //search for the next instance of $ from the \u0027prev\u0027 position\n            pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c value.length()) {\n            fragments.add(value.substring(prev));\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
      "extendedDetails": {}
    },
    "96641268d6ecdae405692c7e4471856a342cc062": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4400: increase coverage of pitest-checkstyle-common profile to 100%\n",
      "commitDate": "07/07/17 5:45 AM",
      "commitName": "96641268d6ecdae405692c7e4471856a342cc062",
      "commitAuthor": "vasilyeva",
      "commitDateOld": "02/07/17 7:43 PM",
      "commitNameOld": "036582d728d2e2bb37f360bb3a74f899f04d587d",
      "commitAuthorOld": "Andrew Kuchev",
      "daysBetweenCommits": 4.42,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     private static void parsePropertyString(String value,\n                                            List\u003cString\u003e fragments,\n                                            List\u003cString\u003e propertyRefs)\n             throws CheckstyleException {\n         int prev \u003d 0;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n         int pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n         while (pos \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             if (pos \u003e 0) {\n                 fragments.add(value.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d value.length() - 1) {\n                 fragments.add(String.valueOf(DOLLAR_SIGN));\n                 prev \u003d pos + 1;\n             }\n             else if (value.charAt(pos + 1) \u003d\u003d \u0027{\u0027) {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n-                if (endName \u003c 0) {\n+                if (endName \u003d\u003d -1) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + value);\n                 }\n                 final String propertyName \u003d value.substring(pos + 2, endName);\n                 fragments.add(null);\n                 propertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n             else {\n                 if (value.charAt(pos + 1) \u003d\u003d DOLLAR_SIGN) {\n                     //backwards compatibility two $ map to one mode\n                     fragments.add(String.valueOf(DOLLAR_SIGN));\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                     fragments.add(value.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n             }\n \n             //search for the next instance of $ from the \u0027prev\u0027 position\n             pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c value.length()) {\n             fragments.add(value.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private static void parsePropertyString(String value,\n                                           List\u003cString\u003e fragments,\n                                           List\u003cString\u003e propertyRefs)\n            throws CheckstyleException {\n        int prev \u003d 0;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        int pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n        while (pos \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            if (pos \u003e 0) {\n                fragments.add(value.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d value.length() - 1) {\n                fragments.add(String.valueOf(DOLLAR_SIGN));\n                prev \u003d pos + 1;\n            }\n            else if (value.charAt(pos + 1) \u003d\u003d \u0027{\u0027) {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                if (endName \u003d\u003d -1) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + value);\n                }\n                final String propertyName \u003d value.substring(pos + 2, endName);\n                fragments.add(null);\n                propertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n            else {\n                if (value.charAt(pos + 1) \u003d\u003d DOLLAR_SIGN) {\n                    //backwards compatibility two $ map to one mode\n                    fragments.add(String.valueOf(DOLLAR_SIGN));\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    fragments.add(value.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n            }\n\n            //search for the next instance of $ from the \u0027prev\u0027 position\n            pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c value.length()) {\n            fragments.add(value.substring(prev));\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
      "extendedDetails": {}
    },
    "423ed9e469db620671459827b58c89025d8f6c66": {
      "type": "Ybodychange",
      "commitMessage": "Issue #974: PMD violation ConfusingTernary (partial fix)\n",
      "commitDate": "07/10/15 5:55 PM",
      "commitName": "423ed9e469db620671459827b58c89025d8f6c66",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "03/10/15 2:47 PM",
      "commitNameOld": "cdb6546adbf1e9fcc5b6c1fe9fd9b01d456d02c1",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 4.13,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,53 @@\n     private static void parsePropertyString(String value,\n                                            List\u003cString\u003e fragments,\n                                            List\u003cString\u003e propertyRefs)\n         throws CheckstyleException {\n         int prev \u003d 0;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n         int pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n         while (pos \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             if (pos \u003e 0) {\n                 fragments.add(value.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d value.length() - 1) {\n                 fragments.add(String.valueOf(DOLLAR_SIGN));\n                 prev \u003d pos + 1;\n             }\n-            else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n-                if (value.charAt(pos + 1) \u003d\u003d DOLLAR_SIGN) {\n-                    //backwards compatibility two $ map to one mode\n-                    fragments.add(String.valueOf(DOLLAR_SIGN));\n-                    prev \u003d pos + 2;\n-                }\n-                else {\n-                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n-                    fragments.add(value.substring(pos, pos + 2));\n-                    prev \u003d pos + 2;\n-                }\n-\n-            }\n-            else {\n+            else if (value.charAt(pos + 1) \u003d\u003d \u0027{\u0027) {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + value);\n                 }\n                 final String propertyName \u003d value.substring(pos + 2, endName);\n                 fragments.add(null);\n                 propertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n+            else {\n+                if (value.charAt(pos + 1) \u003d\u003d DOLLAR_SIGN) {\n+                    //backwards compatibility two $ map to one mode\n+                    fragments.add(String.valueOf(DOLLAR_SIGN));\n+                    prev \u003d pos + 2;\n+                }\n+                else {\n+                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n+                    fragments.add(value.substring(pos, pos + 2));\n+                    prev \u003d pos + 2;\n+                }\n+            }\n \n             //search for the next instance of $ from the \u0027prev\u0027 position\n             pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c value.length()) {\n             fragments.add(value.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private static void parsePropertyString(String value,\n                                           List\u003cString\u003e fragments,\n                                           List\u003cString\u003e propertyRefs)\n        throws CheckstyleException {\n        int prev \u003d 0;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        int pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n        while (pos \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            if (pos \u003e 0) {\n                fragments.add(value.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d value.length() - 1) {\n                fragments.add(String.valueOf(DOLLAR_SIGN));\n                prev \u003d pos + 1;\n            }\n            else if (value.charAt(pos + 1) \u003d\u003d \u0027{\u0027) {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + value);\n                }\n                final String propertyName \u003d value.substring(pos + 2, endName);\n                fragments.add(null);\n                propertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n            else {\n                if (value.charAt(pos + 1) \u003d\u003d DOLLAR_SIGN) {\n                    //backwards compatibility two $ map to one mode\n                    fragments.add(String.valueOf(DOLLAR_SIGN));\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    fragments.add(value.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n            }\n\n            //search for the next instance of $ from the \u0027prev\u0027 position\n            pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c value.length()) {\n            fragments.add(value.substring(prev));\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
      "extendedDetails": {}
    },
    "085ce12db0983590844ccc24ea49f91686a30ed8": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: MultipleStringLiterals violations fixed\n",
      "commitDate": "25/08/15 4:00 PM",
      "commitName": "085ce12db0983590844ccc24ea49f91686a30ed8",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": "25/08/15 5:12 AM",
      "commitNameOld": "8c3e4a50749044ae3177fc4c84db9c4fd93abca2",
      "commitAuthorOld": "Ruslan Diachenko",
      "daysBetweenCommits": 0.45,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n     private static void parsePropertyString(String value,\n                                            List\u003cString\u003e fragments,\n                                            List\u003cString\u003e propertyRefs)\n         throws CheckstyleException {\n         int prev \u003d 0;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n-        int pos \u003d value.indexOf(\u0027$\u0027, prev);\n+        int pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n         while (pos \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             if (pos \u003e 0) {\n                 fragments.add(value.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d value.length() - 1) {\n-                fragments.add(\"$\");\n+                fragments.add(String.valueOf(DOLLAR_SIGN));\n                 prev \u003d pos + 1;\n             }\n             else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n-                if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n+                if (value.charAt(pos + 1) \u003d\u003d DOLLAR_SIGN) {\n                     //backwards compatibility two $ map to one mode\n-                    fragments.add(\"$\");\n+                    fragments.add(String.valueOf(DOLLAR_SIGN));\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                     fragments.add(value.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + value);\n                 }\n                 final String propertyName \u003d value.substring(pos + 2, endName);\n                 fragments.add(null);\n                 propertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n \n             //search for the next instance of $ from the \u0027prev\u0027 position\n-            pos \u003d value.indexOf(\u0027$\u0027, prev);\n+            pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c value.length()) {\n             fragments.add(value.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private static void parsePropertyString(String value,\n                                           List\u003cString\u003e fragments,\n                                           List\u003cString\u003e propertyRefs)\n        throws CheckstyleException {\n        int prev \u003d 0;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        int pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n        while (pos \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            if (pos \u003e 0) {\n                fragments.add(value.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d value.length() - 1) {\n                fragments.add(String.valueOf(DOLLAR_SIGN));\n                prev \u003d pos + 1;\n            }\n            else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                if (value.charAt(pos + 1) \u003d\u003d DOLLAR_SIGN) {\n                    //backwards compatibility two $ map to one mode\n                    fragments.add(String.valueOf(DOLLAR_SIGN));\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    fragments.add(value.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + value);\n                }\n                final String propertyName \u003d value.substring(pos + 2, endName);\n                fragments.add(null);\n                propertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n\n            //search for the next instance of $ from the \u0027prev\u0027 position\n            pos \u003d value.indexOf(DOLLAR_SIGN, prev);\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c value.length()) {\n            fragments.add(value.substring(prev));\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
      "extendedDetails": {}
    },
    "6c19362738598c7addaafc1f906058f49fadc2a4": {
      "type": "Ybodychange",
      "commitMessage": "Sections of code should not be \"commented out\". Issue #46\n",
      "commitDate": "18/08/15 8:47 PM",
      "commitName": "6c19362738598c7addaafc1f906058f49fadc2a4",
      "commitAuthor": "Ilja Dubinin",
      "commitDateOld": "18/08/15 1:25 AM",
      "commitNameOld": "54ccca18635a4aeea90da86d30590df498f76b08",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 0.81,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,54 @@\n     private static void parsePropertyString(String value,\n                                            List\u003cString\u003e fragments,\n                                            List\u003cString\u003e propertyRefs)\n         throws CheckstyleException {\n         int prev \u003d 0;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n         int pos \u003d value.indexOf(\u0027$\u0027, prev);\n         while (pos \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             if (pos \u003e 0) {\n                 fragments.add(value.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d value.length() - 1) {\n                 fragments.add(\"$\");\n                 prev \u003d pos + 1;\n             }\n             else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n-                //peek ahead to see if the next char is a property or not\n-                //not a property: insert the char as a literal\n-                /*\n-                fragments.addElement(value.substring(pos + 1, pos + 2));\n-                prev \u003d pos + 2;\n-                */\n                 if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                     //backwards compatibility two $ map to one mode\n                     fragments.add(\"$\");\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                     fragments.add(value.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + value);\n                 }\n                 final String propertyName \u003d value.substring(pos + 2, endName);\n                 fragments.add(null);\n                 propertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n \n             //search for the next instance of $ from the \u0027prev\u0027 position\n             pos \u003d value.indexOf(\u0027$\u0027, prev);\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c value.length()) {\n             fragments.add(value.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private static void parsePropertyString(String value,\n                                           List\u003cString\u003e fragments,\n                                           List\u003cString\u003e propertyRefs)\n        throws CheckstyleException {\n        int prev \u003d 0;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        int pos \u003d value.indexOf(\u0027$\u0027, prev);\n        while (pos \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            if (pos \u003e 0) {\n                fragments.add(value.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d value.length() - 1) {\n                fragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    fragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    fragments.add(value.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + value);\n                }\n                final String propertyName \u003d value.substring(pos + 2, endName);\n                fragments.add(null);\n                propertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n\n            //search for the next instance of $ from the \u0027prev\u0027 position\n            pos \u003d value.indexOf(\u0027$\u0027, prev);\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c value.length()) {\n            fragments.add(value.substring(prev));\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
      "extendedDetails": {}
    },
    "dd6b080a16e0933b3d19305f84ba01c8893839f3": {
      "type": "Ybodychange",
      "commitMessage": "all TODO/FIXME were removed , some of them converted to issues\n",
      "commitDate": "23/04/15 10:38 AM",
      "commitName": "dd6b080a16e0933b3d19305f84ba01c8893839f3",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "22/04/15 1:37 PM",
      "commitNameOld": "a733182557aa0dc686be57f7f5a7009a7015274b",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 0.88,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,61 @@\n     private static void parsePropertyString(String value,\n                                            List\u003cString\u003e fragments,\n                                            List\u003cString\u003e propertyRefs)\n         throws CheckstyleException\n     {\n         int prev \u003d 0;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n         int pos \u003d value.indexOf(\u0027$\u0027, prev);\n         while (pos \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n-            //TODO, this check could be modified to go if pos\u003eprev;\n-            //seems like this current version could stick empty strings\n-            //into the list\n             if (pos \u003e 0) {\n                 fragments.add(value.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d value.length() - 1) {\n                 fragments.add(\"$\");\n                 prev \u003d pos + 1;\n             }\n             else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                 //peek ahead to see if the next char is a property or not\n                 //not a property: insert the char as a literal\n                 /*\n                 fragments.addElement(value.substring(pos + 1, pos + 2));\n                 prev \u003d pos + 2;\n                 */\n                 if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                     //backwards compatibility two $ map to one mode\n                     fragments.add(\"$\");\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                     fragments.add(value.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + value);\n                 }\n                 final String propertyName \u003d value.substring(pos + 2, endName);\n                 fragments.add(null);\n                 propertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n \n             //search for the next instance of $ from the \u0027prev\u0027 position\n             pos \u003d value.indexOf(\u0027$\u0027, prev);\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c value.length()) {\n             fragments.add(value.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private static void parsePropertyString(String value,\n                                           List\u003cString\u003e fragments,\n                                           List\u003cString\u003e propertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        int pos \u003d value.indexOf(\u0027$\u0027, prev);\n        while (pos \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            if (pos \u003e 0) {\n                fragments.add(value.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d value.length() - 1) {\n                fragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    fragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    fragments.add(value.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + value);\n                }\n                final String propertyName \u003d value.substring(pos + 2, endName);\n                fragments.add(null);\n                propertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n\n            //search for the next instance of $ from the \u0027prev\u0027 position\n            pos \u003d value.indexOf(\u0027$\u0027, prev);\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c value.length()) {\n            fragments.add(value.substring(prev));\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
      "extendedDetails": {}
    },
    "a733182557aa0dc686be57f7f5a7009a7015274b": {
      "type": "Ybodychange",
      "commitMessage": "PMD Rule:AssignmentInOperand Priority:3 Avoid assignments in operands. Issue #744\n",
      "commitDate": "22/04/15 1:37 PM",
      "commitName": "a733182557aa0dc686be57f7f5a7009a7015274b",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "15/04/15 8:56 AM",
      "commitNameOld": "1c42e3eeb9aeebc47b2373541c1cc8d311d8b671",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 7.2,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,64 @@\n     private static void parsePropertyString(String value,\n                                            List\u003cString\u003e fragments,\n                                            List\u003cString\u003e propertyRefs)\n         throws CheckstyleException\n     {\n         int prev \u003d 0;\n-        int pos;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n-        while ((pos \u003d value.indexOf(\u0027$\u0027, prev)) \u003e\u003d 0) {\n+        int pos \u003d value.indexOf(\u0027$\u0027, prev);\n+        while (pos \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             //TODO, this check could be modified to go if pos\u003eprev;\n             //seems like this current version could stick empty strings\n             //into the list\n             if (pos \u003e 0) {\n                 fragments.add(value.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d value.length() - 1) {\n                 fragments.add(\"$\");\n                 prev \u003d pos + 1;\n             }\n             else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                 //peek ahead to see if the next char is a property or not\n                 //not a property: insert the char as a literal\n                 /*\n                 fragments.addElement(value.substring(pos + 1, pos + 2));\n                 prev \u003d pos + 2;\n                 */\n                 if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                     //backwards compatibility two $ map to one mode\n                     fragments.add(\"$\");\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                     fragments.add(value.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + value);\n                 }\n                 final String propertyName \u003d value.substring(pos + 2, endName);\n                 fragments.add(null);\n                 propertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n+\n+            //search for the next instance of $ from the \u0027prev\u0027 position\n+            pos \u003d value.indexOf(\u0027$\u0027, prev);\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c value.length()) {\n             fragments.add(value.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private static void parsePropertyString(String value,\n                                           List\u003cString\u003e fragments,\n                                           List\u003cString\u003e propertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        int pos \u003d value.indexOf(\u0027$\u0027, prev);\n        while (pos \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            //TODO, this check could be modified to go if pos\u003eprev;\n            //seems like this current version could stick empty strings\n            //into the list\n            if (pos \u003e 0) {\n                fragments.add(value.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d value.length() - 1) {\n                fragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    fragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    fragments.add(value.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + value);\n                }\n                final String propertyName \u003d value.substring(pos + 2, endName);\n                fragments.add(null);\n                propertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n\n            //search for the next instance of $ from the \u0027prev\u0027 position\n            pos \u003d value.indexOf(\u0027$\u0027, prev);\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c value.length()) {\n            fragments.add(value.substring(prev));\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
      "extendedDetails": {}
    },
    "1c42e3eeb9aeebc47b2373541c1cc8d311d8b671": {
      "type": "Ybodychange",
      "commitMessage": "Fix PMD violations from \u0027strings\u0027 ruleset, issue #873\n",
      "commitDate": "15/04/15 8:56 AM",
      "commitName": "1c42e3eeb9aeebc47b2373541c1cc8d311d8b671",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "26/03/15 12:35 PM",
      "commitNameOld": "6e6d912013f9c04733014ed393b25d35a8f31882",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 19.85,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n     private static void parsePropertyString(String value,\n                                            List\u003cString\u003e fragments,\n                                            List\u003cString\u003e propertyRefs)\n         throws CheckstyleException\n     {\n         int prev \u003d 0;\n         int pos;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n-        while ((pos \u003d value.indexOf(\"$\", prev)) \u003e\u003d 0) {\n+        while ((pos \u003d value.indexOf(\u0027$\u0027, prev)) \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             //TODO, this check could be modified to go if pos\u003eprev;\n             //seems like this current version could stick empty strings\n             //into the list\n             if (pos \u003e 0) {\n                 fragments.add(value.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d value.length() - 1) {\n                 fragments.add(\"$\");\n                 prev \u003d pos + 1;\n             }\n             else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                 //peek ahead to see if the next char is a property or not\n                 //not a property: insert the char as a literal\n                 /*\n                 fragments.addElement(value.substring(pos + 1, pos + 2));\n                 prev \u003d pos + 2;\n                 */\n                 if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                     //backwards compatibility two $ map to one mode\n                     fragments.add(\"$\");\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                     fragments.add(value.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + value);\n                 }\n                 final String propertyName \u003d value.substring(pos + 2, endName);\n                 fragments.add(null);\n                 propertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c value.length()) {\n             fragments.add(value.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private static void parsePropertyString(String value,\n                                           List\u003cString\u003e fragments,\n                                           List\u003cString\u003e propertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        int pos;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        while ((pos \u003d value.indexOf(\u0027$\u0027, prev)) \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            //TODO, this check could be modified to go if pos\u003eprev;\n            //seems like this current version could stick empty strings\n            //into the list\n            if (pos \u003e 0) {\n                fragments.add(value.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d value.length() - 1) {\n                fragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    fragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    fragments.add(value.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + value);\n                }\n                final String propertyName \u003d value.substring(pos + 2, endName);\n                fragments.add(null);\n                propertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c value.length()) {\n            fragments.add(value.substring(prev));\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
      "extendedDetails": {}
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": "10/03/15 2:36 PM",
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "10/03/15 7:46 AM",
      "commitNameOld": "89005ddf6d5d8b494e4451d16df9fd8996c735a9",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n     private static void parsePropertyString(String value,\n                                            List\u003cString\u003e fragments,\n                                            List\u003cString\u003e propertyRefs)\n         throws CheckstyleException\n     {\n         int prev \u003d 0;\n         int pos;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n         while ((pos \u003d value.indexOf(\"$\", prev)) \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             //TODO, this check could be modified to go if pos\u003eprev;\n             //seems like this current version could stick empty strings\n             //into the list\n             if (pos \u003e 0) {\n                 fragments.add(value.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n-            if (pos \u003d\u003d (value.length() - 1)) {\n+            if (pos \u003d\u003d value.length() - 1) {\n                 fragments.add(\"$\");\n                 prev \u003d pos + 1;\n             }\n             else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                 //peek ahead to see if the next char is a property or not\n                 //not a property: insert the char as a literal\n                 /*\n                 fragments.addElement(value.substring(pos + 1, pos + 2));\n                 prev \u003d pos + 2;\n                 */\n                 if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                     //backwards compatibility two $ map to one mode\n                     fragments.add(\"$\");\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                     fragments.add(value.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + value);\n                 }\n                 final String propertyName \u003d value.substring(pos + 2, endName);\n                 fragments.add(null);\n                 propertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c value.length()) {\n             fragments.add(value.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private static void parsePropertyString(String value,\n                                           List\u003cString\u003e fragments,\n                                           List\u003cString\u003e propertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        int pos;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        while ((pos \u003d value.indexOf(\"$\", prev)) \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            //TODO, this check could be modified to go if pos\u003eprev;\n            //seems like this current version could stick empty strings\n            //into the list\n            if (pos \u003e 0) {\n                fragments.add(value.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d value.length() - 1) {\n                fragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    fragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    fragments.add(value.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + value);\n                }\n                final String propertyName \u003d value.substring(pos + 2, endName);\n                fragments.add(null);\n                propertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c value.length()) {\n            fragments.add(value.substring(prev));\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
      "extendedDetails": {}
    },
    "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
      "commitDate": "19/01/15 6:38 AM",
      "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
      "commitAuthor": "alexkravin",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
          "commitDate": "19/01/15 6:38 AM",
          "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
          "commitAuthor": "alexkravin",
          "commitDateOld": "04/03/14 9:18 AM",
          "commitNameOld": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
          "commitAuthorOld": "Ivan Sopov",
          "daysBetweenCommits": 320.89,
          "commitsBetweenForRepo": 476,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,61 @@\n-    private static void parsePropertyString(String aValue,\n-                                           List\u003cString\u003e aFragments,\n-                                           List\u003cString\u003e aPropertyRefs)\n+    private static void parsePropertyString(String value,\n+                                           List\u003cString\u003e fragments,\n+                                           List\u003cString\u003e propertyRefs)\n         throws CheckstyleException\n     {\n         int prev \u003d 0;\n         int pos;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n-        while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n+        while ((pos \u003d value.indexOf(\"$\", prev)) \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             //TODO, this check could be modified to go if pos\u003eprev;\n             //seems like this current version could stick empty strings\n             //into the list\n             if (pos \u003e 0) {\n-                aFragments.add(aValue.substring(prev, pos));\n+                fragments.add(value.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n-            if (pos \u003d\u003d (aValue.length() - 1)) {\n-                aFragments.add(\"$\");\n+            if (pos \u003d\u003d (value.length() - 1)) {\n+                fragments.add(\"$\");\n                 prev \u003d pos + 1;\n             }\n-            else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n+            else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                 //peek ahead to see if the next char is a property or not\n                 //not a property: insert the char as a literal\n                 /*\n                 fragments.addElement(value.substring(pos + 1, pos + 2));\n                 prev \u003d pos + 2;\n                 */\n-                if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n+                if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                     //backwards compatibility two $ map to one mode\n-                    aFragments.add(\"$\");\n+                    fragments.add(\"$\");\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n-                    aFragments.add(aValue.substring(pos, pos + 2));\n+                    fragments.add(value.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n-                final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n+                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n-                                                    + aValue);\n+                                                    + value);\n                 }\n-                final String propertyName \u003d aValue.substring(pos + 2, endName);\n-                aFragments.add(null);\n-                aPropertyRefs.add(propertyName);\n+                final String propertyName \u003d value.substring(pos + 2, endName);\n+                fragments.add(null);\n+                propertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n-        if (prev \u003c aValue.length()) {\n-            aFragments.add(aValue.substring(prev));\n+        if (prev \u003c value.length()) {\n+            fragments.add(value.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private static void parsePropertyString(String value,\n                                           List\u003cString\u003e fragments,\n                                           List\u003cString\u003e propertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        int pos;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        while ((pos \u003d value.indexOf(\"$\", prev)) \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            //TODO, this check could be modified to go if pos\u003eprev;\n            //seems like this current version could stick empty strings\n            //into the list\n            if (pos \u003e 0) {\n                fragments.add(value.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d (value.length() - 1)) {\n                fragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    fragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    fragments.add(value.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + value);\n                }\n                final String propertyName \u003d value.substring(pos + 2, endName);\n                fragments.add(null);\n                propertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c value.length()) {\n            fragments.add(value.substring(prev));\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
          "extendedDetails": {
            "oldValue": "[aValue-String, aFragments-List\u003cString\u003e, aPropertyRefs-List\u003cString\u003e]",
            "newValue": "[value-String, fragments-List\u003cString\u003e, propertyRefs-List\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Prefixes, checkstyle, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java\n",
          "commitDate": "19/01/15 6:38 AM",
          "commitName": "b8ca6a585b824e91b3b8c72dd5cc53c0eb0ab0f1",
          "commitAuthor": "alexkravin",
          "commitDateOld": "04/03/14 9:18 AM",
          "commitNameOld": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
          "commitAuthorOld": "Ivan Sopov",
          "daysBetweenCommits": 320.89,
          "commitsBetweenForRepo": 476,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,61 @@\n-    private static void parsePropertyString(String aValue,\n-                                           List\u003cString\u003e aFragments,\n-                                           List\u003cString\u003e aPropertyRefs)\n+    private static void parsePropertyString(String value,\n+                                           List\u003cString\u003e fragments,\n+                                           List\u003cString\u003e propertyRefs)\n         throws CheckstyleException\n     {\n         int prev \u003d 0;\n         int pos;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n-        while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n+        while ((pos \u003d value.indexOf(\"$\", prev)) \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             //TODO, this check could be modified to go if pos\u003eprev;\n             //seems like this current version could stick empty strings\n             //into the list\n             if (pos \u003e 0) {\n-                aFragments.add(aValue.substring(prev, pos));\n+                fragments.add(value.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n-            if (pos \u003d\u003d (aValue.length() - 1)) {\n-                aFragments.add(\"$\");\n+            if (pos \u003d\u003d (value.length() - 1)) {\n+                fragments.add(\"$\");\n                 prev \u003d pos + 1;\n             }\n-            else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n+            else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                 //peek ahead to see if the next char is a property or not\n                 //not a property: insert the char as a literal\n                 /*\n                 fragments.addElement(value.substring(pos + 1, pos + 2));\n                 prev \u003d pos + 2;\n                 */\n-                if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n+                if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                     //backwards compatibility two $ map to one mode\n-                    aFragments.add(\"$\");\n+                    fragments.add(\"$\");\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n-                    aFragments.add(aValue.substring(pos, pos + 2));\n+                    fragments.add(value.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n-                final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n+                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n-                                                    + aValue);\n+                                                    + value);\n                 }\n-                final String propertyName \u003d aValue.substring(pos + 2, endName);\n-                aFragments.add(null);\n-                aPropertyRefs.add(propertyName);\n+                final String propertyName \u003d value.substring(pos + 2, endName);\n+                fragments.add(null);\n+                propertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n-        if (prev \u003c aValue.length()) {\n-            aFragments.add(aValue.substring(prev));\n+        if (prev \u003c value.length()) {\n+            fragments.add(value.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private static void parsePropertyString(String value,\n                                           List\u003cString\u003e fragments,\n                                           List\u003cString\u003e propertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        int pos;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        while ((pos \u003d value.indexOf(\"$\", prev)) \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            //TODO, this check could be modified to go if pos\u003eprev;\n            //seems like this current version could stick empty strings\n            //into the list\n            if (pos \u003e 0) {\n                fragments.add(value.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d (value.length() - 1)) {\n                fragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (value.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (value.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    fragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    fragments.add(value.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d value.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + value);\n                }\n                final String propertyName \u003d value.substring(pos + 2, endName);\n                fragments.add(null);\n                propertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c value.length()) {\n            fragments.add(value.substring(prev));\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
          "extendedDetails": {}
        }
      ]
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": "04/03/14 9:18 AM",
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": "26/02/14 10:35 PM",
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private static void parsePropertyString(String aValue,\n                                           List\u003cString\u003e aFragments,\n                                           List\u003cString\u003e aPropertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        int pos;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            //TODO, this check could be modified to go if pos\u003eprev;\n            //seems like this current version could stick empty strings\n            //into the list\n            if (pos \u003e 0) {\n                aFragments.add(aValue.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d (aValue.length() - 1)) {\n                aFragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    aFragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    aFragments.add(aValue.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + aValue);\n                }\n                final String propertyName \u003d aValue.substring(pos + 2, endName);\n                aFragments.add(null);\n                aPropertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c aValue.length()) {\n            aFragments.add(aValue.substring(prev));\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
      "extendedDetails": {
        "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java"
      }
    },
    "f1afaf83f39b83cc3bd07a2388448b262652a76b": {
      "type": "Yparameterchange",
      "commitMessage": "Finish of adding generics.\n",
      "commitDate": "15/12/07 12:14 AM",
      "commitName": "f1afaf83f39b83cc3bd07a2388448b262652a76b",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "27/01/07 6:51 AM",
      "commitNameOld": "1efc394250b8f1c79bd7f8344b738a7d13396ed3",
      "commitAuthorOld": "Lars Khne",
      "daysBetweenCommits": 321.72,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n     private static void parsePropertyString(String aValue,\n-                                           List aFragments,\n-                                           List aPropertyRefs)\n+                                           List\u003cString\u003e aFragments,\n+                                           List\u003cString\u003e aPropertyRefs)\n         throws CheckstyleException\n     {\n         int prev \u003d 0;\n         int pos;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n         while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             //TODO, this check could be modified to go if pos\u003eprev;\n             //seems like this current version could stick empty strings\n             //into the list\n             if (pos \u003e 0) {\n                 aFragments.add(aValue.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d (aValue.length() - 1)) {\n                 aFragments.add(\"$\");\n                 prev \u003d pos + 1;\n             }\n             else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                 //peek ahead to see if the next char is a property or not\n                 //not a property: insert the char as a literal\n                 /*\n                 fragments.addElement(value.substring(pos + 1, pos + 2));\n                 prev \u003d pos + 2;\n                 */\n                 if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                     //backwards compatibility two $ map to one mode\n                     aFragments.add(\"$\");\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                     aFragments.add(aValue.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + aValue);\n                 }\n                 final String propertyName \u003d aValue.substring(pos + 2, endName);\n                 aFragments.add(null);\n                 aPropertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c aValue.length()) {\n             aFragments.add(aValue.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private static void parsePropertyString(String aValue,\n                                           List\u003cString\u003e aFragments,\n                                           List\u003cString\u003e aPropertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        int pos;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            //TODO, this check could be modified to go if pos\u003eprev;\n            //seems like this current version could stick empty strings\n            //into the list\n            if (pos \u003e 0) {\n                aFragments.add(aValue.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d (aValue.length() - 1)) {\n                aFragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    aFragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    aFragments.add(aValue.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + aValue);\n                }\n                final String propertyName \u003d aValue.substring(pos + 2, endName);\n                aFragments.add(null);\n                aPropertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c aValue.length()) {\n            aFragments.add(aValue.substring(prev));\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
      "extendedDetails": {
        "oldValue": "[aValue-String, aFragments-List, aPropertyRefs-List]",
        "newValue": "[aValue-String, aFragments-List\u003cString\u003e, aPropertyRefs-List\u003cString\u003e]"
      }
    },
    "ee2e1a5cb3c7dd02bf6b63c418126e41735ee0ea": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange)",
      "commitMessage": "moved property expansion from api package to private method of ConfigurationLoader (bug #670594)\nalso added property expansion of ANT properties\n",
      "commitDate": "28/01/03 11:56 AM",
      "commitName": "ee2e1a5cb3c7dd02bf6b63c418126e41735ee0ea",
      "commitAuthor": "Lars Khne",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "moved property expansion from api package to private method of ConfigurationLoader (bug #670594)\nalso added property expansion of ANT properties\n",
          "commitDate": "28/01/03 11:56 AM",
          "commitName": "ee2e1a5cb3c7dd02bf6b63c418126e41735ee0ea",
          "commitAuthor": "Lars Khne",
          "commitDateOld": "28/01/03 11:32 AM",
          "commitNameOld": "9d11d6a0b07b63e3581468183f2ec359bafbf300",
          "commitAuthorOld": "Lars Khne",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,61 @@\n-    public static void parsePropertyString(String aValue,\n+    private static void parsePropertyString(String aValue,\n                                            List aFragments,\n                                            List aPropertyRefs)\n         throws CheckstyleException\n     {\n         int prev \u003d 0;\n         int pos;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n         while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             //TODO, this check could be modified to go if pos\u003eprev;\n             //seems like this current version could stick empty strings\n             //into the list\n             if (pos \u003e 0) {\n                 aFragments.add(aValue.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d (aValue.length() - 1)) {\n                 aFragments.add(\"$\");\n                 prev \u003d pos + 1;\n             }\n             else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                 //peek ahead to see if the next char is a property or not\n                 //not a property: insert the char as a literal\n                 /*\n                 fragments.addElement(value.substring(pos + 1, pos + 2));\n                 prev \u003d pos + 2;\n                 */\n                 if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                     //backwards compatibility two $ map to one mode\n                     aFragments.add(\"$\");\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                     aFragments.add(aValue.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + aValue);\n                 }\n                 final String propertyName \u003d aValue.substring(pos + 2, endName);\n                 aFragments.add(null);\n                 aPropertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c aValue.length()) {\n             aFragments.add(aValue.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private static void parsePropertyString(String aValue,\n                                           List aFragments,\n                                           List aPropertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        int pos;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            //TODO, this check could be modified to go if pos\u003eprev;\n            //seems like this current version could stick empty strings\n            //into the list\n            if (pos \u003e 0) {\n                aFragments.add(aValue.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d (aValue.length() - 1)) {\n                aFragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    aFragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    aFragments.add(aValue.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + aValue);\n                }\n                final String propertyName \u003d aValue.substring(pos + 2, endName);\n                aFragments.add(null);\n                aPropertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c aValue.length()) {\n            aFragments.add(aValue.substring(prev));\n        }\n    }",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
          "extendedDetails": {
            "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/api/Utils.java",
            "newPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
            "oldMethodName": "parsePropertyString",
            "newMethodName": "parsePropertyString"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "moved property expansion from api package to private method of ConfigurationLoader (bug #670594)\nalso added property expansion of ANT properties\n",
          "commitDate": "28/01/03 11:56 AM",
          "commitName": "ee2e1a5cb3c7dd02bf6b63c418126e41735ee0ea",
          "commitAuthor": "Lars Khne",
          "commitDateOld": "28/01/03 11:32 AM",
          "commitNameOld": "9d11d6a0b07b63e3581468183f2ec359bafbf300",
          "commitAuthorOld": "Lars Khne",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,61 @@\n-    public static void parsePropertyString(String aValue,\n+    private static void parsePropertyString(String aValue,\n                                            List aFragments,\n                                            List aPropertyRefs)\n         throws CheckstyleException\n     {\n         int prev \u003d 0;\n         int pos;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n         while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             //TODO, this check could be modified to go if pos\u003eprev;\n             //seems like this current version could stick empty strings\n             //into the list\n             if (pos \u003e 0) {\n                 aFragments.add(aValue.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d (aValue.length() - 1)) {\n                 aFragments.add(\"$\");\n                 prev \u003d pos + 1;\n             }\n             else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                 //peek ahead to see if the next char is a property or not\n                 //not a property: insert the char as a literal\n                 /*\n                 fragments.addElement(value.substring(pos + 1, pos + 2));\n                 prev \u003d pos + 2;\n                 */\n                 if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                     //backwards compatibility two $ map to one mode\n                     aFragments.add(\"$\");\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                     aFragments.add(aValue.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + aValue);\n                 }\n                 final String propertyName \u003d aValue.substring(pos + 2, endName);\n                 aFragments.add(null);\n                 aPropertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c aValue.length()) {\n             aFragments.add(aValue.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private static void parsePropertyString(String aValue,\n                                           List aFragments,\n                                           List aPropertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        int pos;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            //TODO, this check could be modified to go if pos\u003eprev;\n            //seems like this current version could stick empty strings\n            //into the list\n            if (pos \u003e 0) {\n                aFragments.add(aValue.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d (aValue.length() - 1)) {\n                aFragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    aFragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    aFragments.add(aValue.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + aValue);\n                }\n                final String propertyName \u003d aValue.substring(pos + 2, endName);\n                aFragments.add(null);\n                aPropertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c aValue.length()) {\n            aFragments.add(aValue.substring(prev));\n        }\n    }",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[private, static]"
          }
        }
      ]
    },
    "33b6e5d9fc6fae514f508e580d84626dd202c0bb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Brought the code into the 21st century. Do not have\nthe requirement to run on JDK 1.1. I wish ANT would\nmove on as well.\n",
      "commitDate": "30/11/02 7:56 PM",
      "commitName": "33b6e5d9fc6fae514f508e580d84626dd202c0bb",
      "commitAuthor": "Oliver Burn",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Brought the code into the 21st century. Do not have\nthe requirement to run on JDK 1.1. I wish ANT would\nmove on as well.\n",
          "commitDate": "30/11/02 7:56 PM",
          "commitName": "33b6e5d9fc6fae514f508e580d84626dd202c0bb",
          "commitAuthor": "Oliver Burn",
          "commitDateOld": "30/11/02 10:45 AM",
          "commitNameOld": "b21944b2f1d183f6180918e4119b42bc82c0c8a1",
          "commitAuthorOld": "Lars Khne",
          "daysBetweenCommits": 0.38,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,61 @@\n-    public static void parsePropertyString(String aValue, Vector aFragments,\n-                                           Vector aPropertyRefs)\n+    public static void parsePropertyString(String aValue,\n+                                           List aFragments,\n+                                           List aPropertyRefs)\n         throws CheckstyleException\n     {\n         int prev \u003d 0;\n         int pos;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n         while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             //TODO, this check could be modified to go if pos\u003eprev;\n             //seems like this current version could stick empty strings\n             //into the list\n             if (pos \u003e 0) {\n-                aFragments.addElement(aValue.substring(prev, pos));\n+                aFragments.add(aValue.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d (aValue.length() - 1)) {\n-                aFragments.addElement(\"$\");\n+                aFragments.add(\"$\");\n                 prev \u003d pos + 1;\n             }\n             else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                 //peek ahead to see if the next char is a property or not\n                 //not a property: insert the char as a literal\n                 /*\n                 fragments.addElement(value.substring(pos + 1, pos + 2));\n                 prev \u003d pos + 2;\n                 */\n                 if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                     //backwards compatibility two $ map to one mode\n-                    aFragments.addElement(\"$\");\n+                    aFragments.add(\"$\");\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n-                    aFragments.addElement(aValue.substring(pos, pos + 2));\n+                    aFragments.add(aValue.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + aValue);\n                 }\n                 final String propertyName \u003d aValue.substring(pos + 2, endName);\n-                aFragments.addElement(null);\n-                aPropertyRefs.addElement(propertyName);\n+                aFragments.add(null);\n+                aPropertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c aValue.length()) {\n-            aFragments.addElement(aValue.substring(prev));\n+            aFragments.add(aValue.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public static void parsePropertyString(String aValue,\n                                           List aFragments,\n                                           List aPropertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        int pos;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            //TODO, this check could be modified to go if pos\u003eprev;\n            //seems like this current version could stick empty strings\n            //into the list\n            if (pos \u003e 0) {\n                aFragments.add(aValue.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d (aValue.length() - 1)) {\n                aFragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    aFragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    aFragments.add(aValue.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + aValue);\n                }\n                final String propertyName \u003d aValue.substring(pos + 2, endName);\n                aFragments.add(null);\n                aPropertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c aValue.length()) {\n            aFragments.add(aValue.substring(prev));\n        }\n    }",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/api/Utils.java",
          "extendedDetails": {
            "oldValue": "[aValue-String, aFragments-Vector, aPropertyRefs-Vector]",
            "newValue": "[aValue-String, aFragments-List, aPropertyRefs-List]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Brought the code into the 21st century. Do not have\nthe requirement to run on JDK 1.1. I wish ANT would\nmove on as well.\n",
          "commitDate": "30/11/02 7:56 PM",
          "commitName": "33b6e5d9fc6fae514f508e580d84626dd202c0bb",
          "commitAuthor": "Oliver Burn",
          "commitDateOld": "30/11/02 10:45 AM",
          "commitNameOld": "b21944b2f1d183f6180918e4119b42bc82c0c8a1",
          "commitAuthorOld": "Lars Khne",
          "daysBetweenCommits": 0.38,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,61 @@\n-    public static void parsePropertyString(String aValue, Vector aFragments,\n-                                           Vector aPropertyRefs)\n+    public static void parsePropertyString(String aValue,\n+                                           List aFragments,\n+                                           List aPropertyRefs)\n         throws CheckstyleException\n     {\n         int prev \u003d 0;\n         int pos;\n         //search for the next instance of $ from the \u0027prev\u0027 position\n         while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n \n             //if there was any text before this, add it as a fragment\n             //TODO, this check could be modified to go if pos\u003eprev;\n             //seems like this current version could stick empty strings\n             //into the list\n             if (pos \u003e 0) {\n-                aFragments.addElement(aValue.substring(prev, pos));\n+                aFragments.add(aValue.substring(prev, pos));\n             }\n             //if we are at the end of the string, we tack on a $\n             //then move past it\n             if (pos \u003d\u003d (aValue.length() - 1)) {\n-                aFragments.addElement(\"$\");\n+                aFragments.add(\"$\");\n                 prev \u003d pos + 1;\n             }\n             else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                 //peek ahead to see if the next char is a property or not\n                 //not a property: insert the char as a literal\n                 /*\n                 fragments.addElement(value.substring(pos + 1, pos + 2));\n                 prev \u003d pos + 2;\n                 */\n                 if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                     //backwards compatibility two $ map to one mode\n-                    aFragments.addElement(\"$\");\n+                    aFragments.add(\"$\");\n                     prev \u003d pos + 2;\n                 }\n                 else {\n                     //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n-                    aFragments.addElement(aValue.substring(pos, pos + 2));\n+                    aFragments.add(aValue.substring(pos, pos + 2));\n                     prev \u003d pos + 2;\n                 }\n \n             }\n             else {\n                 //property found, extract its name or bail on a typo\n                 final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n                 if (endName \u003c 0) {\n                     throw new CheckstyleException(\"Syntax error in property: \"\n                                                     + aValue);\n                 }\n                 final String propertyName \u003d aValue.substring(pos + 2, endName);\n-                aFragments.addElement(null);\n-                aPropertyRefs.addElement(propertyName);\n+                aFragments.add(null);\n+                aPropertyRefs.add(propertyName);\n                 prev \u003d endName + 1;\n             }\n         }\n         //no more $ signs found\n         //if there is any tail to the file, append it\n         if (prev \u003c aValue.length()) {\n-            aFragments.addElement(aValue.substring(prev));\n+            aFragments.add(aValue.substring(prev));\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public static void parsePropertyString(String aValue,\n                                           List aFragments,\n                                           List aPropertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        int pos;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            //TODO, this check could be modified to go if pos\u003eprev;\n            //seems like this current version could stick empty strings\n            //into the list\n            if (pos \u003e 0) {\n                aFragments.add(aValue.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d (aValue.length() - 1)) {\n                aFragments.add(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    aFragments.add(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    aFragments.add(aValue.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n\n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + aValue);\n                }\n                final String propertyName \u003d aValue.substring(pos + 2, endName);\n                aFragments.add(null);\n                aPropertyRefs.add(propertyName);\n                prev \u003d endName + 1;\n            }\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c aValue.length()) {\n            aFragments.add(aValue.substring(prev));\n        }\n    }",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/api/Utils.java",
          "extendedDetails": {}
        }
      ]
    },
    "a955b402b7db322df8f073a0e8f7a3abd8449f17": {
      "type": "Yintroduced",
      "commitMessage": "code for properties expansion copied from ant\n",
      "commitDate": "30/11/02 9:07 AM",
      "commitName": "a955b402b7db322df8f073a0e8f7a3abd8449f17",
      "commitAuthor": "Rick Giles",
      "diff": "@@ -0,0 +1,60 @@\n+    public static void parsePropertyString(String aValue, Vector aFragments, \n+                                           Vector aPropertyRefs)\n+        throws CheckstyleException\n+    {\n+        int prev \u003d 0;\n+        int pos;\n+        //search for the next instance of $ from the \u0027prev\u0027 position\n+        while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n+\n+            //if there was any text before this, add it as a fragment\n+            //TODO, this check could be modified to go if pos\u003eprev;\n+            //seems like this current version could stick empty strings\n+            //into the list\n+            if (pos \u003e 0) {\n+                aFragments.addElement(aValue.substring(prev, pos));\n+            }\n+            //if we are at the end of the string, we tack on a $\n+            //then move past it\n+            if (pos \u003d\u003d (aValue.length() - 1)) {\n+                aFragments.addElement(\"$\");\n+                prev \u003d pos + 1;\n+            }\n+            else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n+                //peek ahead to see if the next char is a property or not\n+                //not a property: insert the char as a literal\n+                /*\n+                fragments.addElement(value.substring(pos + 1, pos + 2));\n+                prev \u003d pos + 2;\n+                */\n+                if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n+                    //backwards compatibility two $ map to one mode\n+                    aFragments.addElement(\"$\");\n+                    prev \u003d pos + 2;\n+                }\n+                else {\n+                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n+                    aFragments.addElement(aValue.substring(pos, pos + 2));\n+                    prev \u003d pos + 2;\n+                }\n+                \n+            }\n+            else {\n+                //property found, extract its name or bail on a typo\n+                final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n+                if (endName \u003c 0) {\n+                    throw new CheckstyleException(\"Syntax error in property: \"\n+                                                    + aValue);\n+                }\n+                final String propertyName \u003d aValue.substring(pos + 2, endName);\n+                aFragments.addElement(null);\n+                aPropertyRefs.addElement(propertyName);\n+                prev \u003d endName + 1;\n+            }\n+        }\n+        //no more $ signs found\n+        //if there is any tail to the file, append it\n+        if (prev \u003c aValue.length()) {\n+            aFragments.addElement(aValue.substring(prev));\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public static void parsePropertyString(String aValue, Vector aFragments, \n                                           Vector aPropertyRefs)\n        throws CheckstyleException\n    {\n        int prev \u003d 0;\n        int pos;\n        //search for the next instance of $ from the \u0027prev\u0027 position\n        while ((pos \u003d aValue.indexOf(\"$\", prev)) \u003e\u003d 0) {\n\n            //if there was any text before this, add it as a fragment\n            //TODO, this check could be modified to go if pos\u003eprev;\n            //seems like this current version could stick empty strings\n            //into the list\n            if (pos \u003e 0) {\n                aFragments.addElement(aValue.substring(prev, pos));\n            }\n            //if we are at the end of the string, we tack on a $\n            //then move past it\n            if (pos \u003d\u003d (aValue.length() - 1)) {\n                aFragments.addElement(\"$\");\n                prev \u003d pos + 1;\n            }\n            else if (aValue.charAt(pos + 1) !\u003d \u0027{\u0027) {\n                //peek ahead to see if the next char is a property or not\n                //not a property: insert the char as a literal\n                /*\n                fragments.addElement(value.substring(pos + 1, pos + 2));\n                prev \u003d pos + 2;\n                */\n                if (aValue.charAt(pos + 1) \u003d\u003d \u0027$\u0027) {\n                    //backwards compatibility two $ map to one mode\n                    aFragments.addElement(\"$\");\n                    prev \u003d pos + 2;\n                }\n                else {\n                    //new behaviour: $X maps to $X for all values of X!\u003d\u0027$\u0027\n                    aFragments.addElement(aValue.substring(pos, pos + 2));\n                    prev \u003d pos + 2;\n                }\n                \n            }\n            else {\n                //property found, extract its name or bail on a typo\n                final int endName \u003d aValue.indexOf(\u0027}\u0027, pos);\n                if (endName \u003c 0) {\n                    throw new CheckstyleException(\"Syntax error in property: \"\n                                                    + aValue);\n                }\n                final String propertyName \u003d aValue.substring(pos + 2, endName);\n                aFragments.addElement(null);\n                aPropertyRefs.addElement(propertyName);\n                prev \u003d endName + 1;\n            }\n        }\n        //no more $ signs found\n        //if there is any tail to the file, append it\n        if (prev \u003c aValue.length()) {\n            aFragments.addElement(aValue.substring(prev));\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/api/Utils.java"
    }
  }
}