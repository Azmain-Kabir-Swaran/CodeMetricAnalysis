{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "OverloadMethodsDeclarationOrderCheck.java",
  "functionName": "checkOverloadMethodsGrouping",
  "functionId": "checkOverloadMethodsGrouping___objectBlock-DetailAST",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java",
  "functionStartLine": 108,
  "functionEndLine": 133,
  "numCommitsSeen": 32,
  "timeTaken": 1476,
  "changeHistory": [
    "a231f5202c6769f9c664eb53a1bb370ec8788c96",
    "31f6765fdcf2233ca6c53730c2fc196576557f66",
    "27149f3504a2f350b74f456a9bffbae76a460060",
    "ff5cbc39c4882b3a3dcdbedcad9393e170148725",
    "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000",
    "3a51c61b4aa4b8feaa7eae8648a28d94d62bab0c",
    "6cd89ebebaec931a33ffde42b295eb6a20dc07e1"
  ],
  "changeHistoryShort": {
    "a231f5202c6769f9c664eb53a1bb370ec8788c96": "Ybodychange",
    "31f6765fdcf2233ca6c53730c2fc196576557f66": "Ybodychange",
    "27149f3504a2f350b74f456a9bffbae76a460060": "Ybodychange",
    "ff5cbc39c4882b3a3dcdbedcad9393e170148725": "Ybodychange",
    "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000": "Ymultichange(Yparameterchange,Ybodychange)",
    "3a51c61b4aa4b8feaa7eae8648a28d94d62bab0c": "Ymultichange(Ymovefromfile,Ybodychange)",
    "6cd89ebebaec931a33ffde42b295eb6a20dc07e1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a231f5202c6769f9c664eb53a1bb370ec8788c96": {
      "type": "Ybodychange",
      "commitMessage": "Issue #7756: Update AbstractChecks to log DetailAST - OverloadMethodsDeclarationOrder\n",
      "commitDate": "14/04/20 6:14 PM",
      "commitName": "a231f5202c6769f9c664eb53a1bb370ec8788c96",
      "commitAuthor": "nmancus1",
      "commitDateOld": "13/04/20 9:46 PM",
      "commitNameOld": "ac8f555dde1cedbd611d269958ec9829f0b5ecf6",
      "commitAuthorOld": "Guneshi Wickramaarachchi",
      "daysBetweenCommits": 0.85,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,26 @@\n     private void checkOverloadMethodsGrouping(DetailAST objectBlock) {\n         final int allowedDistance \u003d 1;\n         DetailAST currentToken \u003d objectBlock.getFirstChild();\n         final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003c\u003e();\n         final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003c\u003e();\n         int currentIndex \u003d 0;\n         while (currentToken !\u003d null) {\n             if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 currentIndex++;\n                 final String methodName \u003d\n                         currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                 if (methodIndexMap.containsKey(methodName)) {\n                     final int previousIndex \u003d methodIndexMap.get(methodName);\n                     if (currentIndex - previousIndex \u003e allowedDistance) {\n                         final int previousLineWithOverloadMethod \u003d\n                                 methodLineNumberMap.get(methodName);\n-                        log(currentToken.getLineNo(), MSG_KEY,\n+                        log(currentToken, MSG_KEY,\n                                 previousLineWithOverloadMethod);\n                     }\n                 }\n                 methodIndexMap.put(methodName, currentIndex);\n                 methodLineNumberMap.put(methodName, currentToken.getLineNo());\n             }\n             currentToken \u003d currentToken.getNextSibling();\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkOverloadMethodsGrouping(DetailAST objectBlock) {\n        final int allowedDistance \u003d 1;\n        DetailAST currentToken \u003d objectBlock.getFirstChild();\n        final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003c\u003e();\n        final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003c\u003e();\n        int currentIndex \u003d 0;\n        while (currentToken !\u003d null) {\n            if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                currentIndex++;\n                final String methodName \u003d\n                        currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                if (methodIndexMap.containsKey(methodName)) {\n                    final int previousIndex \u003d methodIndexMap.get(methodName);\n                    if (currentIndex - previousIndex \u003e allowedDistance) {\n                        final int previousLineWithOverloadMethod \u003d\n                                methodLineNumberMap.get(methodName);\n                        log(currentToken, MSG_KEY,\n                                previousLineWithOverloadMethod);\n                    }\n                }\n                methodIndexMap.put(methodName, currentIndex);\n                methodLineNumberMap.put(methodName, currentToken.getLineNo());\n            }\n            currentToken \u003d currentToken.getNextSibling();\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java",
      "extendedDetails": {}
    },
    "31f6765fdcf2233ca6c53730c2fc196576557f66": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2080: Fix typos in code\n\nFixes some `SpellCheckingInspection` inspection violations.\n\nDescription:\n\u003eSpellchecker inspection helps locate typos and misspelling in your code, comments and literals.\n",
      "commitDate": "04/09/15 2:48 PM",
      "commitName": "31f6765fdcf2233ca6c53730c2fc196576557f66",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "16/08/15 8:41 PM",
      "commitNameOld": "d56a2a366c6f9e3e8639d492d548ae562b75dc81",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 18.76,
      "commitsBetweenForRepo": 421,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,26 @@\n     private void checkOverloadMethodsGrouping(DetailAST objectBlock) {\n         final int allowedDistance \u003d 1;\n         DetailAST currentToken \u003d objectBlock.getFirstChild();\n         final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003c\u003e();\n         final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003c\u003e();\n         int currentIndex \u003d 0;\n         while (currentToken !\u003d null) {\n             if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 currentIndex++;\n                 final String methodName \u003d\n                         currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                 if (methodIndexMap.containsKey(methodName)) {\n-                    final int priviousIndex \u003d methodIndexMap.get(methodName);\n-                    if (currentIndex - priviousIndex \u003e allowedDistance) {\n+                    final int previousIndex \u003d methodIndexMap.get(methodName);\n+                    if (currentIndex - previousIndex \u003e allowedDistance) {\n                         final int previousLineWithOverloadMethod \u003d\n                                 methodLineNumberMap.get(methodName);\n                         log(currentToken.getLineNo(), MSG_KEY,\n                                 previousLineWithOverloadMethod);\n                     }\n                 }\n                 methodIndexMap.put(methodName, currentIndex);\n                 methodLineNumberMap.put(methodName, currentToken.getLineNo());\n             }\n             currentToken \u003d currentToken.getNextSibling();\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkOverloadMethodsGrouping(DetailAST objectBlock) {\n        final int allowedDistance \u003d 1;\n        DetailAST currentToken \u003d objectBlock.getFirstChild();\n        final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003c\u003e();\n        final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003c\u003e();\n        int currentIndex \u003d 0;\n        while (currentToken !\u003d null) {\n            if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                currentIndex++;\n                final String methodName \u003d\n                        currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                if (methodIndexMap.containsKey(methodName)) {\n                    final int previousIndex \u003d methodIndexMap.get(methodName);\n                    if (currentIndex - previousIndex \u003e allowedDistance) {\n                        final int previousLineWithOverloadMethod \u003d\n                                methodLineNumberMap.get(methodName);\n                        log(currentToken.getLineNo(), MSG_KEY,\n                                previousLineWithOverloadMethod);\n                    }\n                }\n                methodIndexMap.put(methodName, currentIndex);\n                methodLineNumberMap.put(methodName, currentToken.getLineNo());\n            }\n            currentToken \u003d currentToken.getNextSibling();\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java",
      "extendedDetails": {}
    },
    "27149f3504a2f350b74f456a9bffbae76a460060": {
      "type": "Ybodychange",
      "commitMessage": "Refactored UTs, coding package, issue #537\n",
      "commitDate": "20/02/15 5:02 AM",
      "commitName": "27149f3504a2f350b74f456a9bffbae76a460060",
      "commitAuthor": "alexkravin",
      "commitDateOld": "18/02/15 1:14 PM",
      "commitNameOld": "c9a9e6508c15e00cf6820b213d79d5ebf41c6343",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n     private void checkOverloadMethodsGrouping(DetailAST objectBlock)\n     {\n         final int allowedDistance \u003d 1;\n         DetailAST currentToken \u003d objectBlock.getFirstChild();\n         final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003c\u003e();\n         final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003c\u003e();\n         int currentIndex \u003d 0;\n         while (currentToken !\u003d null) {\n             if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 currentIndex++;\n                 final String methodName \u003d\n                         currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                 if (methodIndexMap.containsKey(methodName)) {\n                     final int priviousIndex \u003d methodIndexMap.get(methodName);\n                     if (currentIndex - priviousIndex \u003e allowedDistance) {\n                         final int previousLineWithOverloadMethod \u003d\n                                 methodLineNumberMap.get(methodName);\n-                        log(currentToken.getLineNo(), \"overload.methods.declaration\",\n+                        log(currentToken.getLineNo(), MSG_KEY,\n                                 previousLineWithOverloadMethod);\n                     }\n                 }\n                 methodIndexMap.put(methodName, currentIndex);\n                 methodLineNumberMap.put(methodName, currentToken.getLineNo());\n             }\n             currentToken \u003d currentToken.getNextSibling();\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkOverloadMethodsGrouping(DetailAST objectBlock)\n    {\n        final int allowedDistance \u003d 1;\n        DetailAST currentToken \u003d objectBlock.getFirstChild();\n        final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003c\u003e();\n        final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003c\u003e();\n        int currentIndex \u003d 0;\n        while (currentToken !\u003d null) {\n            if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                currentIndex++;\n                final String methodName \u003d\n                        currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                if (methodIndexMap.containsKey(methodName)) {\n                    final int priviousIndex \u003d methodIndexMap.get(methodName);\n                    if (currentIndex - priviousIndex \u003e allowedDistance) {\n                        final int previousLineWithOverloadMethod \u003d\n                                methodLineNumberMap.get(methodName);\n                        log(currentToken.getLineNo(), MSG_KEY,\n                                previousLineWithOverloadMethod);\n                    }\n                }\n                methodIndexMap.put(methodName, currentIndex);\n                methodLineNumberMap.put(methodName, currentToken.getLineNo());\n            }\n            currentToken \u003d currentToken.getNextSibling();\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java",
      "extendedDetails": {}
    },
    "ff5cbc39c4882b3a3dcdbedcad9393e170148725": {
      "type": "Ybodychange",
      "commitMessage": "Replace verbose type arguments with diamond type \u003c\u003e\n\nThis syntax is not supported under Java 6 or earlier, but Checkstyle codebase uses Java 7 already.\n",
      "commitDate": "15/02/15 8:22 AM",
      "commitName": "ff5cbc39c4882b3a3dcdbedcad9393e170148725",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "08/02/15 1:46 PM",
      "commitNameOld": "abe2b200312ee72aa552026b1a34e8bd72bfdc4e",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 6.77,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n     private void checkOverloadMethodsGrouping(DetailAST objectBlock)\n     {\n         final int allowedDistance \u003d 1;\n         DetailAST currentToken \u003d objectBlock.getFirstChild();\n-        final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003cString, Integer\u003e();\n-        final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003cString, Integer\u003e();\n+        final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003c\u003e();\n+        final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003c\u003e();\n         int currentIndex \u003d 0;\n         while (currentToken !\u003d null) {\n             if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 currentIndex++;\n                 final String methodName \u003d\n                         currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                 if (methodIndexMap.containsKey(methodName)) {\n                     final int priviousIndex \u003d methodIndexMap.get(methodName);\n                     if (currentIndex - priviousIndex \u003e allowedDistance) {\n                         final int previousLineWithOverloadMethod \u003d\n                                 methodLineNumberMap.get(methodName);\n                         log(currentToken.getLineNo(), \"overload.methods.declaration\",\n                                 previousLineWithOverloadMethod);\n                     }\n                 }\n                 methodIndexMap.put(methodName, currentIndex);\n                 methodLineNumberMap.put(methodName, currentToken.getLineNo());\n             }\n             currentToken \u003d currentToken.getNextSibling();\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkOverloadMethodsGrouping(DetailAST objectBlock)\n    {\n        final int allowedDistance \u003d 1;\n        DetailAST currentToken \u003d objectBlock.getFirstChild();\n        final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003c\u003e();\n        final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003c\u003e();\n        int currentIndex \u003d 0;\n        while (currentToken !\u003d null) {\n            if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                currentIndex++;\n                final String methodName \u003d\n                        currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                if (methodIndexMap.containsKey(methodName)) {\n                    final int priviousIndex \u003d methodIndexMap.get(methodName);\n                    if (currentIndex - priviousIndex \u003e allowedDistance) {\n                        final int previousLineWithOverloadMethod \u003d\n                                methodLineNumberMap.get(methodName);\n                        log(currentToken.getLineNo(), \"overload.methods.declaration\",\n                                previousLineWithOverloadMethod);\n                    }\n                }\n                methodIndexMap.put(methodName, currentIndex);\n                methodLineNumberMap.put(methodName, currentToken.getLineNo());\n            }\n            currentToken \u003d currentToken.getNextSibling();\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java",
      "extendedDetails": {}
    },
    "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, coding, #512\n",
      "commitDate": "19/01/15 6:20 AM",
      "commitName": "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000",
      "commitAuthor": "alexkravin",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Prefixes, coding, #512\n",
          "commitDate": "19/01/15 6:20 AM",
          "commitName": "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000",
          "commitAuthor": "alexkravin",
          "commitDateOld": "08/10/14 8:38 PM",
          "commitNameOld": "8d8f85faa6ce03e3f4dd52c635c59966e911d35a",
          "commitAuthorOld": "Andrew Gaul",
          "daysBetweenCommits": 102.45,
          "commitsBetweenForRepo": 308,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,27 @@\n-    private void checkOverloadMethodsGrouping(DetailAST aObjectBlock)\n+    private void checkOverloadMethodsGrouping(DetailAST objectBlock)\n     {\n         final int allowedDistance \u003d 1;\n-        DetailAST currentToken \u003d aObjectBlock.getFirstChild();\n+        DetailAST currentToken \u003d objectBlock.getFirstChild();\n         final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003cString, Integer\u003e();\n         final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003cString, Integer\u003e();\n         int currentIndex \u003d 0;\n         while (currentToken !\u003d null) {\n             if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 currentIndex++;\n                 final String methodName \u003d\n                         currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                 if (methodIndexMap.containsKey(methodName)) {\n                     final int priviousIndex \u003d methodIndexMap.get(methodName);\n                     if (currentIndex - priviousIndex \u003e allowedDistance) {\n                         final int previousLineWithOverloadMethod \u003d\n                                 methodLineNumberMap.get(methodName);\n                         log(currentToken.getLineNo(), \"overload.methods.declaration\",\n                                 previousLineWithOverloadMethod);\n                     }\n                 }\n                 methodIndexMap.put(methodName, currentIndex);\n                 methodLineNumberMap.put(methodName, currentToken.getLineNo());\n             }\n             currentToken \u003d currentToken.getNextSibling();\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void checkOverloadMethodsGrouping(DetailAST objectBlock)\n    {\n        final int allowedDistance \u003d 1;\n        DetailAST currentToken \u003d objectBlock.getFirstChild();\n        final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003cString, Integer\u003e();\n        final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003cString, Integer\u003e();\n        int currentIndex \u003d 0;\n        while (currentToken !\u003d null) {\n            if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                currentIndex++;\n                final String methodName \u003d\n                        currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                if (methodIndexMap.containsKey(methodName)) {\n                    final int priviousIndex \u003d methodIndexMap.get(methodName);\n                    if (currentIndex - priviousIndex \u003e allowedDistance) {\n                        final int previousLineWithOverloadMethod \u003d\n                                methodLineNumberMap.get(methodName);\n                        log(currentToken.getLineNo(), \"overload.methods.declaration\",\n                                previousLineWithOverloadMethod);\n                    }\n                }\n                methodIndexMap.put(methodName, currentIndex);\n                methodLineNumberMap.put(methodName, currentToken.getLineNo());\n            }\n            currentToken \u003d currentToken.getNextSibling();\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java",
          "extendedDetails": {
            "oldValue": "[aObjectBlock-DetailAST]",
            "newValue": "[objectBlock-DetailAST]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Prefixes, coding, #512\n",
          "commitDate": "19/01/15 6:20 AM",
          "commitName": "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000",
          "commitAuthor": "alexkravin",
          "commitDateOld": "08/10/14 8:38 PM",
          "commitNameOld": "8d8f85faa6ce03e3f4dd52c635c59966e911d35a",
          "commitAuthorOld": "Andrew Gaul",
          "daysBetweenCommits": 102.45,
          "commitsBetweenForRepo": 308,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,27 @@\n-    private void checkOverloadMethodsGrouping(DetailAST aObjectBlock)\n+    private void checkOverloadMethodsGrouping(DetailAST objectBlock)\n     {\n         final int allowedDistance \u003d 1;\n-        DetailAST currentToken \u003d aObjectBlock.getFirstChild();\n+        DetailAST currentToken \u003d objectBlock.getFirstChild();\n         final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003cString, Integer\u003e();\n         final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003cString, Integer\u003e();\n         int currentIndex \u003d 0;\n         while (currentToken !\u003d null) {\n             if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 currentIndex++;\n                 final String methodName \u003d\n                         currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                 if (methodIndexMap.containsKey(methodName)) {\n                     final int priviousIndex \u003d methodIndexMap.get(methodName);\n                     if (currentIndex - priviousIndex \u003e allowedDistance) {\n                         final int previousLineWithOverloadMethod \u003d\n                                 methodLineNumberMap.get(methodName);\n                         log(currentToken.getLineNo(), \"overload.methods.declaration\",\n                                 previousLineWithOverloadMethod);\n                     }\n                 }\n                 methodIndexMap.put(methodName, currentIndex);\n                 methodLineNumberMap.put(methodName, currentToken.getLineNo());\n             }\n             currentToken \u003d currentToken.getNextSibling();\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void checkOverloadMethodsGrouping(DetailAST objectBlock)\n    {\n        final int allowedDistance \u003d 1;\n        DetailAST currentToken \u003d objectBlock.getFirstChild();\n        final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003cString, Integer\u003e();\n        final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003cString, Integer\u003e();\n        int currentIndex \u003d 0;\n        while (currentToken !\u003d null) {\n            if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                currentIndex++;\n                final String methodName \u003d\n                        currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                if (methodIndexMap.containsKey(methodName)) {\n                    final int priviousIndex \u003d methodIndexMap.get(methodName);\n                    if (currentIndex - priviousIndex \u003e allowedDistance) {\n                        final int previousLineWithOverloadMethod \u003d\n                                methodLineNumberMap.get(methodName);\n                        log(currentToken.getLineNo(), \"overload.methods.declaration\",\n                                previousLineWithOverloadMethod);\n                    }\n                }\n                methodIndexMap.put(methodName, currentIndex);\n                methodLineNumberMap.put(methodName, currentToken.getLineNo());\n            }\n            currentToken \u003d currentToken.getNextSibling();\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java",
          "extendedDetails": {}
        }
      ]
    },
    "3a51c61b4aa4b8feaa7eae8648a28d94d62bab0c": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "OverrideMethodsDeclarationOrderCheck #32\n",
      "commitDate": "07/08/14 9:23 AM",
      "commitName": "3a51c61b4aa4b8feaa7eae8648a28d94d62bab0c",
      "commitAuthor": "Max",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "OverrideMethodsDeclarationOrderCheck #32\n",
          "commitDate": "07/08/14 9:23 AM",
          "commitName": "3a51c61b4aa4b8feaa7eae8648a28d94d62bab0c",
          "commitAuthor": "Max",
          "commitDateOld": "06/08/14 10:50 PM",
          "commitNameOld": "c4e886312aae13b6cfadceed25b1b8aec18d4a96",
          "commitAuthorOld": "Max",
          "daysBetweenCommits": 0.44,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,27 @@\n     private void checkOverloadMethodsGrouping(DetailAST aObjectBlock)\n     {\n         final int allowedDistance \u003d 1;\n         DetailAST currentToken \u003d aObjectBlock.getFirstChild();\n-        final Map\u003cString, Integer\u003e methodIndexMap \u003d\n-                new HashMap\u003cString, Integer\u003e();\n+        final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003cString, Integer\u003e();\n+        final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003cString, Integer\u003e();\n         int currentIndex \u003d 0;\n         while (currentToken !\u003d null) {\n             if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 currentIndex++;\n                 final String methodName \u003d\n                         currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                 if (methodIndexMap.containsKey(methodName)) {\n                     final int priviousIndex \u003d methodIndexMap.get(methodName);\n                     if (currentIndex - priviousIndex \u003e allowedDistance) {\n-                        log(currentToken, \"declaration.order.overloads\");\n+                        final int previousLineWithOverloadMethod \u003d\n+                                methodLineNumberMap.get(methodName);\n+                        log(currentToken.getLineNo(), \"overload.methods.declaration\",\n+                                previousLineWithOverloadMethod);\n                     }\n                 }\n                 methodIndexMap.put(methodName, currentIndex);\n+                methodLineNumberMap.put(methodName, currentToken.getLineNo());\n             }\n             currentToken \u003d currentToken.getNextSibling();\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void checkOverloadMethodsGrouping(DetailAST aObjectBlock)\n    {\n        final int allowedDistance \u003d 1;\n        DetailAST currentToken \u003d aObjectBlock.getFirstChild();\n        final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003cString, Integer\u003e();\n        final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003cString, Integer\u003e();\n        int currentIndex \u003d 0;\n        while (currentToken !\u003d null) {\n            if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                currentIndex++;\n                final String methodName \u003d\n                        currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                if (methodIndexMap.containsKey(methodName)) {\n                    final int priviousIndex \u003d methodIndexMap.get(methodName);\n                    if (currentIndex - priviousIndex \u003e allowedDistance) {\n                        final int previousLineWithOverloadMethod \u003d\n                                methodLineNumberMap.get(methodName);\n                        log(currentToken.getLineNo(), \"overload.methods.declaration\",\n                                previousLineWithOverloadMethod);\n                    }\n                }\n                methodIndexMap.put(methodName, currentIndex);\n                methodLineNumberMap.put(methodName, currentToken.getLineNo());\n            }\n            currentToken \u003d currentToken.getNextSibling();\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java",
          "extendedDetails": {
            "oldPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java",
            "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java",
            "oldMethodName": "checkOverloadMethodsGrouping",
            "newMethodName": "checkOverloadMethodsGrouping"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "OverrideMethodsDeclarationOrderCheck #32\n",
          "commitDate": "07/08/14 9:23 AM",
          "commitName": "3a51c61b4aa4b8feaa7eae8648a28d94d62bab0c",
          "commitAuthor": "Max",
          "commitDateOld": "06/08/14 10:50 PM",
          "commitNameOld": "c4e886312aae13b6cfadceed25b1b8aec18d4a96",
          "commitAuthorOld": "Max",
          "daysBetweenCommits": 0.44,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,27 @@\n     private void checkOverloadMethodsGrouping(DetailAST aObjectBlock)\n     {\n         final int allowedDistance \u003d 1;\n         DetailAST currentToken \u003d aObjectBlock.getFirstChild();\n-        final Map\u003cString, Integer\u003e methodIndexMap \u003d\n-                new HashMap\u003cString, Integer\u003e();\n+        final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003cString, Integer\u003e();\n+        final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003cString, Integer\u003e();\n         int currentIndex \u003d 0;\n         while (currentToken !\u003d null) {\n             if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                 currentIndex++;\n                 final String methodName \u003d\n                         currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                 if (methodIndexMap.containsKey(methodName)) {\n                     final int priviousIndex \u003d methodIndexMap.get(methodName);\n                     if (currentIndex - priviousIndex \u003e allowedDistance) {\n-                        log(currentToken, \"declaration.order.overloads\");\n+                        final int previousLineWithOverloadMethod \u003d\n+                                methodLineNumberMap.get(methodName);\n+                        log(currentToken.getLineNo(), \"overload.methods.declaration\",\n+                                previousLineWithOverloadMethod);\n                     }\n                 }\n                 methodIndexMap.put(methodName, currentIndex);\n+                methodLineNumberMap.put(methodName, currentToken.getLineNo());\n             }\n             currentToken \u003d currentToken.getNextSibling();\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void checkOverloadMethodsGrouping(DetailAST aObjectBlock)\n    {\n        final int allowedDistance \u003d 1;\n        DetailAST currentToken \u003d aObjectBlock.getFirstChild();\n        final Map\u003cString, Integer\u003e methodIndexMap \u003d new HashMap\u003cString, Integer\u003e();\n        final Map\u003cString, Integer\u003e methodLineNumberMap \u003d new HashMap\u003cString, Integer\u003e();\n        int currentIndex \u003d 0;\n        while (currentToken !\u003d null) {\n            if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                currentIndex++;\n                final String methodName \u003d\n                        currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                if (methodIndexMap.containsKey(methodName)) {\n                    final int priviousIndex \u003d methodIndexMap.get(methodName);\n                    if (currentIndex - priviousIndex \u003e allowedDistance) {\n                        final int previousLineWithOverloadMethod \u003d\n                                methodLineNumberMap.get(methodName);\n                        log(currentToken.getLineNo(), \"overload.methods.declaration\",\n                                previousLineWithOverloadMethod);\n                    }\n                }\n                methodIndexMap.put(methodName, currentIndex);\n                methodLineNumberMap.put(methodName, currentToken.getLineNo());\n            }\n            currentToken \u003d currentToken.getNextSibling();\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java",
          "extendedDetails": {}
        }
      ]
    },
    "6cd89ebebaec931a33ffde42b295eb6a20dc07e1": {
      "type": "Yintroduced",
      "commitMessage": "Update for existing Check: DeclarationOrder #4\n",
      "commitDate": "30/06/14 9:37 PM",
      "commitName": "6cd89ebebaec931a33ffde42b295eb6a20dc07e1",
      "commitAuthor": "Max",
      "diff": "@@ -0,0 +1,23 @@\n+    private void checkOverloadMethodsGrouping(DetailAST aObjectBlock)\n+    {\n+        final int allowedDistance \u003d 1;\n+        DetailAST currentToken \u003d aObjectBlock.getFirstChild();\n+        final Map\u003cString, Integer\u003e methodIndexMap \u003d\n+                new HashMap\u003cString, Integer\u003e();\n+        int currentIndex \u003d 0;\n+        while (currentToken !\u003d null) {\n+            if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n+                currentIndex++;\n+                final String methodName \u003d\n+                        currentToken.findFirstToken(TokenTypes.IDENT).getText();\n+                if (methodIndexMap.containsKey(methodName)) {\n+                    final int priviousIndex \u003d methodIndexMap.get(methodName);\n+                    if (currentIndex - priviousIndex \u003e allowedDistance) {\n+                        log(currentToken, \"declaration.order.overloads\");\n+                    }\n+                }\n+                methodIndexMap.put(methodName, currentIndex);\n+            }\n+            currentToken \u003d currentToken.getNextSibling();\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkOverloadMethodsGrouping(DetailAST aObjectBlock)\n    {\n        final int allowedDistance \u003d 1;\n        DetailAST currentToken \u003d aObjectBlock.getFirstChild();\n        final Map\u003cString, Integer\u003e methodIndexMap \u003d\n                new HashMap\u003cString, Integer\u003e();\n        int currentIndex \u003d 0;\n        while (currentToken !\u003d null) {\n            if (currentToken.getType() \u003d\u003d TokenTypes.METHOD_DEF) {\n                currentIndex++;\n                final String methodName \u003d\n                        currentToken.findFirstToken(TokenTypes.IDENT).getText();\n                if (methodIndexMap.containsKey(methodName)) {\n                    final int priviousIndex \u003d methodIndexMap.get(methodName);\n                    if (currentIndex - priviousIndex \u003e allowedDistance) {\n                        log(currentToken, \"declaration.order.overloads\");\n                    }\n                }\n                methodIndexMap.put(methodName, currentIndex);\n            }\n            currentToken \u003d currentToken.getNextSibling();\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java"
    }
  }
}