{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LineWrappingHandler.java",
  "functionName": "checkAnnotationIndentation",
  "functionId": "checkAnnotationIndentation___atNode-DetailAST__firstNodesOnLines-NavigableMap__Integer,DetailAST____indentLevel-int",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
  "functionStartLine": 247,
  "functionEndLine": 275,
  "numCommitsSeen": 81,
  "timeTaken": 2782,
  "changeHistory": [
    "8bf05ced07bb04c7240ae9f60ecda3c628e9b6f6",
    "b02eed8a546c711c74566afb4c27366b4a185a03",
    "4bc519ac0589a96699d739d966e90f7930bf9f76",
    "6155da61d3e2804bb37e3c08a3794f3992fafaff",
    "f111cc06fb4744981f79173db4659b8a8f12d5aa",
    "a0fed4c0e90c488101c4ecb27f3f6a412c8f9a4e",
    "f6685bca1e8a6853e6192e2a3f71f1f365496eee",
    "d10b2c45ffc6c390bade5218b4d315a128485bcf",
    "2ff20f4af36062db07fa245ab6b3a1d8ab2fe16c",
    "d84869bcff9a2f0ad8d6f1d7741e07d22a78e4a6",
    "17ebdc5c3740d37f29b8dc09c4ce4a42d2982b1e",
    "e3a48d1527341456a798c3f0c1986de6898a8c60"
  ],
  "changeHistoryShort": {
    "8bf05ced07bb04c7240ae9f60ecda3c628e9b6f6": "Ybodychange",
    "b02eed8a546c711c74566afb4c27366b4a185a03": "Ybodychange",
    "4bc519ac0589a96699d739d966e90f7930bf9f76": "Ybodychange",
    "6155da61d3e2804bb37e3c08a3794f3992fafaff": "Ybodychange",
    "f111cc06fb4744981f79173db4659b8a8f12d5aa": "Ybodychange",
    "a0fed4c0e90c488101c4ecb27f3f6a412c8f9a4e": "Yparameterchange",
    "f6685bca1e8a6853e6192e2a3f71f1f365496eee": "Ybodychange",
    "d10b2c45ffc6c390bade5218b4d315a128485bcf": "Ybodychange",
    "2ff20f4af36062db07fa245ab6b3a1d8ab2fe16c": "Ybodychange",
    "d84869bcff9a2f0ad8d6f1d7741e07d22a78e4a6": "Ymultichange(Yparameterchange,Ybodychange)",
    "17ebdc5c3740d37f29b8dc09c4ce4a42d2982b1e": "Ymultichange(Yparameterchange,Ybodychange)",
    "e3a48d1527341456a798c3f0c1986de6898a8c60": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8bf05ced07bb04c7240ae9f60ecda3c628e9b6f6": {
      "type": "Ybodychange",
      "commitMessage": "Issue #7518: refactor line comparison\n",
      "commitDate": "06/02/20 6:58 PM",
      "commitName": "8bf05ced07bb04c7240ae9f60ecda3c628e9b6f6",
      "commitAuthor": "Andrei_Paikin",
      "commitDateOld": "01/01/20 4:38 PM",
      "commitNameOld": "ae9edbd4a8645c8cc1a99ad6890dd0006700d1cb",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 36.1,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n     private void checkAnnotationIndentation(DetailAST atNode,\n             NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines, int indentLevel) {\n         final int firstNodeIndent \u003d getLineStart(atNode);\n         final int currentIndent \u003d firstNodeIndent + indentLevel;\n         final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n         final DetailAST lastAnnotationNode \u003d atNode.getParent().getLastChild();\n         final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n         while (firstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n \n             final DetailAST parentNode \u003d node.getParent();\n             final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                 node.getLineNo() \u003d\u003d lastAnnotationLine\n                     \u0026\u0026 isEndOfScope(lastAnnotationNode, node);\n             if (isCurrentNodeCloseAnnotationAloneInLine\n                     || node.getType() \u003d\u003d TokenTypes.AT\n                     \u0026\u0026 (parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS\n                         || parentNode.getParent().getType() \u003d\u003d TokenTypes.ANNOTATIONS)\n-                    || node.getLineNo() \u003d\u003d atNode.getLineNo()) {\n+                    || TokenUtil.areOnSameLine(node, atNode)) {\n                 logWarningMessage(node, firstNodeIndent);\n             }\n             else {\n                 logWarningMessage(node, currentIndent);\n             }\n             itr.remove();\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines, int indentLevel) {\n        final int firstNodeIndent \u003d getLineStart(atNode);\n        final int currentIndent \u003d firstNodeIndent + indentLevel;\n        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d atNode.getParent().getLastChild();\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (firstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            final DetailAST parentNode \u003d node.getParent();\n            final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                node.getLineNo() \u003d\u003d lastAnnotationLine\n                    \u0026\u0026 isEndOfScope(lastAnnotationNode, node);\n            if (isCurrentNodeCloseAnnotationAloneInLine\n                    || node.getType() \u003d\u003d TokenTypes.AT\n                    \u0026\u0026 (parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS\n                        || parentNode.getParent().getType() \u003d\u003d TokenTypes.ANNOTATIONS)\n                    || TokenUtil.areOnSameLine(node, atNode)) {\n                logWarningMessage(node, firstNodeIndent);\n            }\n            else {\n                logWarningMessage(node, currentIndent);\n            }\n            itr.remove();\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
      "extendedDetails": {}
    },
    "b02eed8a546c711c74566afb4c27366b4a185a03": {
      "type": "Ybodychange",
      "commitMessage": "Issue #5154: Incorrect indentation check for method preceded by annotation, with method parameter on separate line\n",
      "commitDate": "16/12/17 8:49 AM",
      "commitName": "b02eed8a546c711c74566afb4c27366b4a185a03",
      "commitAuthor": "BBG",
      "commitDateOld": "19/08/17 10:29 PM",
      "commitNameOld": "6054b46c9b717a03cf000c7884d0256335fc01e9",
      "commitAuthorOld": "vasilyeva",
      "daysBetweenCommits": 118.47,
      "commitsBetweenForRepo": 329,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,29 @@\n     private void checkAnnotationIndentation(DetailAST atNode,\n             NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines, int indentLevel) {\n         final int firstNodeIndent \u003d getLineStart(atNode);\n         final int currentIndent \u003d firstNodeIndent + indentLevel;\n         final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n         final DetailAST lastAnnotationNode \u003d atNode.getParent().getLastChild();\n         final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n         while (firstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n \n             final DetailAST parentNode \u003d node.getParent();\n             final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                 node.getLineNo() \u003d\u003d lastAnnotationLine\n                     \u0026\u0026 isEndOfScope(lastAnnotationNode, node);\n             if (isCurrentNodeCloseAnnotationAloneInLine\n                     || node.getType() \u003d\u003d TokenTypes.AT\n                     \u0026\u0026 (parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS\n-                        || parentNode.getParent().getType() \u003d\u003d TokenTypes.ANNOTATIONS)) {\n+                        || parentNode.getParent().getType() \u003d\u003d TokenTypes.ANNOTATIONS)\n+                    || node.getLineNo() \u003d\u003d atNode.getLineNo()) {\n                 logWarningMessage(node, firstNodeIndent);\n             }\n             else {\n                 logWarningMessage(node, currentIndent);\n             }\n             itr.remove();\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines, int indentLevel) {\n        final int firstNodeIndent \u003d getLineStart(atNode);\n        final int currentIndent \u003d firstNodeIndent + indentLevel;\n        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d atNode.getParent().getLastChild();\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (firstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            final DetailAST parentNode \u003d node.getParent();\n            final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                node.getLineNo() \u003d\u003d lastAnnotationLine\n                    \u0026\u0026 isEndOfScope(lastAnnotationNode, node);\n            if (isCurrentNodeCloseAnnotationAloneInLine\n                    || node.getType() \u003d\u003d TokenTypes.AT\n                    \u0026\u0026 (parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS\n                        || parentNode.getParent().getType() \u003d\u003d TokenTypes.ANNOTATIONS)\n                    || node.getLineNo() \u003d\u003d atNode.getLineNo()) {\n                logWarningMessage(node, firstNodeIndent);\n            }\n            else {\n                logWarningMessage(node, currentIndent);\n            }\n            itr.remove();\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
      "extendedDetails": {}
    },
    "4bc519ac0589a96699d739d966e90f7930bf9f76": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3733: Modify indent check to handle multiple, stacked annotations\n",
      "commitDate": "15/02/17 5:02 AM",
      "commitName": "4bc519ac0589a96699d739d966e90f7930bf9f76",
      "commitAuthor": "shawn.kovalchick",
      "commitDateOld": "27/01/17 6:31 AM",
      "commitNameOld": "b4a337a599e853cdc44b19a76da28fcfab2956cd",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 18.94,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,28 @@\n     private void checkAnnotationIndentation(DetailAST atNode,\n             NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines, int indentLevel) {\n         final int firstNodeIndent \u003d getLineStart(atNode);\n         final int currentIndent \u003d firstNodeIndent + indentLevel;\n         final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n-        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n+        final DetailAST lastAnnotationNode \u003d atNode.getParent().getLastChild();\n         final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n         while (firstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n \n-            if (node.getLineNo() \u003c\u003d lastAnnotationLine) {\n-                final DetailAST parentNode \u003d node.getParent();\n-                final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n-                        node.getLineNo() \u003d\u003d lastAnnotationLine\n-                        \u0026\u0026 node.equals(lastAnnotationNode);\n-                if (isCurrentNodeCloseAnnotationAloneInLine\n-                        || node.getType() \u003d\u003d TokenTypes.AT\n-                        \u0026\u0026 (parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS\n-                            || parentNode.getParent().getType() \u003d\u003d TokenTypes.ANNOTATIONS)) {\n-                    logWarningMessage(node, firstNodeIndent);\n-                }\n-                else {\n-                    logWarningMessage(node, currentIndent);\n-                }\n-                itr.remove();\n+            final DetailAST parentNode \u003d node.getParent();\n+            final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n+                node.getLineNo() \u003d\u003d lastAnnotationLine\n+                    \u0026\u0026 isEndOfScope(lastAnnotationNode, node);\n+            if (isCurrentNodeCloseAnnotationAloneInLine\n+                    || node.getType() \u003d\u003d TokenTypes.AT\n+                    \u0026\u0026 (parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS\n+                        || parentNode.getParent().getType() \u003d\u003d TokenTypes.ANNOTATIONS)) {\n+                logWarningMessage(node, firstNodeIndent);\n             }\n             else {\n-                break;\n+                logWarningMessage(node, currentIndent);\n             }\n+            itr.remove();\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines, int indentLevel) {\n        final int firstNodeIndent \u003d getLineStart(atNode);\n        final int currentIndent \u003d firstNodeIndent + indentLevel;\n        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d atNode.getParent().getLastChild();\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (firstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            final DetailAST parentNode \u003d node.getParent();\n            final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                node.getLineNo() \u003d\u003d lastAnnotationLine\n                    \u0026\u0026 isEndOfScope(lastAnnotationNode, node);\n            if (isCurrentNodeCloseAnnotationAloneInLine\n                    || node.getType() \u003d\u003d TokenTypes.AT\n                    \u0026\u0026 (parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS\n                        || parentNode.getParent().getType() \u003d\u003d TokenTypes.ANNOTATIONS)) {\n                logWarningMessage(node, firstNodeIndent);\n            }\n            else {\n                logWarningMessage(node, currentIndent);\n            }\n            itr.remove();\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
      "extendedDetails": {}
    },
    "6155da61d3e2804bb37e3c08a3794f3992fafaff": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2618: refactored indentation import and package logic (#3223)",
      "commitDate": "03/06/16 6:11 AM",
      "commitName": "6155da61d3e2804bb37e3c08a3794f3992fafaff",
      "commitAuthor": "rnveach",
      "commitDateOld": "07/05/16 6:37 AM",
      "commitNameOld": "9e9a0b424551418e80c5a7e7badadfe80958ec82",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 26.98,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,33 @@\n     private void checkAnnotationIndentation(DetailAST atNode,\n             NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines, int indentLevel) {\n         final int firstNodeIndent \u003d getLineStart(atNode);\n         final int currentIndent \u003d firstNodeIndent + indentLevel;\n         final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n         final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n         final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n         while (firstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n \n             if (node.getLineNo() \u003c\u003d lastAnnotationLine) {\n                 final DetailAST parentNode \u003d node.getParent();\n                 final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                         node.getLineNo() \u003d\u003d lastAnnotationLine\n                         \u0026\u0026 node.equals(lastAnnotationNode);\n                 if (isCurrentNodeCloseAnnotationAloneInLine\n                         || node.getType() \u003d\u003d TokenTypes.AT\n-                        \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS) {\n+                        \u0026\u0026 (parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS\n+                            || parentNode.getParent().getType() \u003d\u003d TokenTypes.ANNOTATIONS)) {\n                     logWarningMessage(node, firstNodeIndent);\n                 }\n                 else {\n                     logWarningMessage(node, currentIndent);\n                 }\n                 itr.remove();\n             }\n             else {\n                 break;\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines, int indentLevel) {\n        final int firstNodeIndent \u003d getLineStart(atNode);\n        final int currentIndent \u003d firstNodeIndent + indentLevel;\n        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (firstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            if (node.getLineNo() \u003c\u003d lastAnnotationLine) {\n                final DetailAST parentNode \u003d node.getParent();\n                final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                        node.getLineNo() \u003d\u003d lastAnnotationLine\n                        \u0026\u0026 node.equals(lastAnnotationNode);\n                if (isCurrentNodeCloseAnnotationAloneInLine\n                        || node.getType() \u003d\u003d TokenTypes.AT\n                        \u0026\u0026 (parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS\n                            || parentNode.getParent().getType() \u003d\u003d TokenTypes.ANNOTATIONS)) {\n                    logWarningMessage(node, firstNodeIndent);\n                }\n                else {\n                    logWarningMessage(node, currentIndent);\n                }\n                itr.remove();\n            }\n            else {\n                break;\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
      "extendedDetails": {}
    },
    "f111cc06fb4744981f79173db4659b8a8f12d5aa": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2950: rewrote LineWrappingHandler for easier use (#2951)",
      "commitDate": "24/04/16 5:35 AM",
      "commitName": "f111cc06fb4744981f79173db4659b8a8f12d5aa",
      "commitAuthor": "rnveach",
      "commitDateOld": "22/04/16 5:11 AM",
      "commitNameOld": "585738d956083eb27fb57a6e3f43c9c05ef43d70",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 2.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n     private void checkAnnotationIndentation(DetailAST atNode,\n             NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines, int indentLevel) {\n-        final int firstNodeIndent \u003d expandedTabsColumnNo(atNode);\n+        final int firstNodeIndent \u003d getLineStart(atNode);\n         final int currentIndent \u003d firstNodeIndent + indentLevel;\n         final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n         final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n         final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n         while (firstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n \n             if (node.getLineNo() \u003c\u003d lastAnnotationLine) {\n                 final DetailAST parentNode \u003d node.getParent();\n                 final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                         node.getLineNo() \u003d\u003d lastAnnotationLine\n                         \u0026\u0026 node.equals(lastAnnotationNode);\n                 if (isCurrentNodeCloseAnnotationAloneInLine\n                         || node.getType() \u003d\u003d TokenTypes.AT\n                         \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS) {\n                     logWarningMessage(node, firstNodeIndent);\n                 }\n                 else {\n                     logWarningMessage(node, currentIndent);\n                 }\n                 itr.remove();\n             }\n             else {\n                 break;\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines, int indentLevel) {\n        final int firstNodeIndent \u003d getLineStart(atNode);\n        final int currentIndent \u003d firstNodeIndent + indentLevel;\n        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (firstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            if (node.getLineNo() \u003c\u003d lastAnnotationLine) {\n                final DetailAST parentNode \u003d node.getParent();\n                final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                        node.getLineNo() \u003d\u003d lastAnnotationLine\n                        \u0026\u0026 node.equals(lastAnnotationNode);\n                if (isCurrentNodeCloseAnnotationAloneInLine\n                        || node.getType() \u003d\u003d TokenTypes.AT\n                        \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS) {\n                    logWarningMessage(node, firstNodeIndent);\n                }\n                else {\n                    logWarningMessage(node, currentIndent);\n                }\n                itr.remove();\n            }\n            else {\n                break;\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
      "extendedDetails": {}
    },
    "a0fed4c0e90c488101c4ecb27f3f6a412c8f9a4e": {
      "type": "Yparameterchange",
      "commitMessage": "minor: refactored LineWrappingHandler",
      "commitDate": "24/02/16 5:08 AM",
      "commitName": "a0fed4c0e90c488101c4ecb27f3f6a412c8f9a4e",
      "commitAuthor": "rnveach",
      "commitDateOld": "16/02/16 6:06 AM",
      "commitNameOld": "7572ba1f8e392bd0a57e87c48f4d3abefb83fe6a",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 7.96,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n     private void checkAnnotationIndentation(DetailAST atNode,\n-            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines) {\n+            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines, int indentLevel) {\n         final int firstNodeIndent \u003d expandedTabsColumnNo(atNode);\n         final int currentIndent \u003d firstNodeIndent + indentLevel;\n         final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n         final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n         final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n         while (firstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n \n             if (node.getLineNo() \u003c\u003d lastAnnotationLine) {\n                 final DetailAST parentNode \u003d node.getParent();\n                 final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                         node.getLineNo() \u003d\u003d lastAnnotationLine\n                         \u0026\u0026 node.equals(lastAnnotationNode);\n                 if (isCurrentNodeCloseAnnotationAloneInLine\n                         || node.getType() \u003d\u003d TokenTypes.AT\n                         \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS) {\n                     logWarningMessage(node, firstNodeIndent);\n                 }\n                 else {\n                     logWarningMessage(node, currentIndent);\n                 }\n                 itr.remove();\n             }\n             else {\n                 break;\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines, int indentLevel) {\n        final int firstNodeIndent \u003d expandedTabsColumnNo(atNode);\n        final int currentIndent \u003d firstNodeIndent + indentLevel;\n        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (firstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            if (node.getLineNo() \u003c\u003d lastAnnotationLine) {\n                final DetailAST parentNode \u003d node.getParent();\n                final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                        node.getLineNo() \u003d\u003d lastAnnotationLine\n                        \u0026\u0026 node.equals(lastAnnotationNode);\n                if (isCurrentNodeCloseAnnotationAloneInLine\n                        || node.getType() \u003d\u003d TokenTypes.AT\n                        \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS) {\n                    logWarningMessage(node, firstNodeIndent);\n                }\n                else {\n                    logWarningMessage(node, currentIndent);\n                }\n                itr.remove();\n            }\n            else {\n                break;\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
      "extendedDetails": {
        "oldValue": "[atNode-DetailAST, firstNodesOnLines-NavigableMap\u003cInteger,DetailAST\u003e]",
        "newValue": "[atNode-DetailAST, firstNodesOnLines-NavigableMap\u003cInteger,DetailAST\u003e, indentLevel-int]"
      }
    },
    "f6685bca1e8a6853e6192e2a3f71f1f365496eee": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2795: fixed handling of tabs in LineWrapping",
      "commitDate": "05/02/16 5:57 AM",
      "commitName": "f6685bca1e8a6853e6192e2a3f71f1f365496eee",
      "commitAuthor": "rnveach",
      "commitDateOld": "21/01/16 6:41 AM",
      "commitNameOld": "28da7d5666e32903523b1f97d830589fcb4bee4c",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 14.97,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n     private void checkAnnotationIndentation(DetailAST atNode,\n             NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines) {\n-        final int currentIndent \u003d atNode.getColumnNo() + indentLevel;\n-        final int firstNodeIndent \u003d atNode.getColumnNo();\n+        final int firstNodeIndent \u003d expandedTabsColumnNo(atNode);\n+        final int currentIndent \u003d firstNodeIndent + indentLevel;\n         final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n         final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n         final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n         while (firstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n \n             if (node.getLineNo() \u003c\u003d lastAnnotationLine) {\n                 final DetailAST parentNode \u003d node.getParent();\n                 final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                         node.getLineNo() \u003d\u003d lastAnnotationLine\n                         \u0026\u0026 node.equals(lastAnnotationNode);\n                 if (isCurrentNodeCloseAnnotationAloneInLine\n                         || node.getType() \u003d\u003d TokenTypes.AT\n                         \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS) {\n                     logWarningMessage(node, firstNodeIndent);\n                 }\n                 else {\n                     logWarningMessage(node, currentIndent);\n                 }\n                 itr.remove();\n             }\n             else {\n                 break;\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines) {\n        final int firstNodeIndent \u003d expandedTabsColumnNo(atNode);\n        final int currentIndent \u003d firstNodeIndent + indentLevel;\n        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (firstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            if (node.getLineNo() \u003c\u003d lastAnnotationLine) {\n                final DetailAST parentNode \u003d node.getParent();\n                final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                        node.getLineNo() \u003d\u003d lastAnnotationLine\n                        \u0026\u0026 node.equals(lastAnnotationNode);\n                if (isCurrentNodeCloseAnnotationAloneInLine\n                        || node.getType() \u003d\u003d TokenTypes.AT\n                        \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS) {\n                    logWarningMessage(node, firstNodeIndent);\n                }\n                else {\n                    logWarningMessage(node, currentIndent);\n                }\n                itr.remove();\n            }\n            else {\n                break;\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
      "extendedDetails": {}
    },
    "d10b2c45ffc6c390bade5218b4d315a128485bcf": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1349: Fix IndentationCheck to accept proper right parenthesis of annotation\n",
      "commitDate": "03/01/16 10:12 AM",
      "commitName": "d10b2c45ffc6c390bade5218b4d315a128485bcf",
      "commitAuthor": "liscju",
      "commitDateOld": "01/10/15 6:53 AM",
      "commitNameOld": "eeec3dc1d23916462560403a27a4ae94260d61f3",
      "commitAuthorOld": "Pieter Noordhuis",
      "daysBetweenCommits": 94.18,
      "commitsBetweenForRepo": 527,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,32 @@\n     private void checkAnnotationIndentation(DetailAST atNode,\n             NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines) {\n         final int currentIndent \u003d atNode.getColumnNo() + indentLevel;\n         final int firstNodeIndent \u003d atNode.getColumnNo();\n         final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n         final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n         final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n         while (firstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n \n-            if (node.getLineNo() \u003c lastAnnotationLine\n-                    || node.getLineNo() \u003d\u003d lastAnnotationLine) {\n+            if (node.getLineNo() \u003c\u003d lastAnnotationLine) {\n                 final DetailAST parentNode \u003d node.getParent();\n-                if (node.getType() \u003d\u003d TokenTypes.AT\n+                final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n+                        node.getLineNo() \u003d\u003d lastAnnotationLine\n+                        \u0026\u0026 node.equals(lastAnnotationNode);\n+                if (isCurrentNodeCloseAnnotationAloneInLine\n+                        || node.getType() \u003d\u003d TokenTypes.AT\n                         \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS) {\n                     logWarningMessage(node, firstNodeIndent);\n                 }\n                 else {\n                     logWarningMessage(node, currentIndent);\n                 }\n                 itr.remove();\n             }\n             else {\n                 break;\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines) {\n        final int currentIndent \u003d atNode.getColumnNo() + indentLevel;\n        final int firstNodeIndent \u003d atNode.getColumnNo();\n        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (firstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            if (node.getLineNo() \u003c\u003d lastAnnotationLine) {\n                final DetailAST parentNode \u003d node.getParent();\n                final boolean isCurrentNodeCloseAnnotationAloneInLine \u003d\n                        node.getLineNo() \u003d\u003d lastAnnotationLine\n                        \u0026\u0026 node.equals(lastAnnotationNode);\n                if (isCurrentNodeCloseAnnotationAloneInLine\n                        || node.getType() \u003d\u003d TokenTypes.AT\n                        \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS) {\n                    logWarningMessage(node, firstNodeIndent);\n                }\n                else {\n                    logWarningMessage(node, currentIndent);\n                }\n                itr.remove();\n            }\n            else {\n                break;\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
      "extendedDetails": {}
    },
    "2ff20f4af36062db07fa245ab6b3a1d8ab2fe16c": {
      "type": "Ybodychange",
      "commitMessage": "Add test coverage to LineWrappingHandler in Indentation check. #1270\n",
      "commitDate": "20/07/15 8:54 PM",
      "commitName": "2ff20f4af36062db07fa245ab6b3a1d8ab2fe16c",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "17/07/15 9:51 PM",
      "commitNameOld": "4c078ba710068498ca513ce115993e30dab4562a",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.96,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,29 @@\n     private void checkAnnotationIndentation(DetailAST atNode,\n             NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines) {\n         final int currentIndent \u003d atNode.getColumnNo() + indentLevel;\n         final int firstNodeIndent \u003d atNode.getColumnNo();\n         final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n         final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n         final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n-        final int lastAnnotattionColumn \u003d lastAnnotationNode.getColumnNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n-        while (itr.hasNext() \u0026\u0026 firstNodesOnLines.size() \u003e 1) {\n+        while (firstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n \n             if (node.getLineNo() \u003c lastAnnotationLine\n-                    || node.getLineNo() \u003d\u003d lastAnnotationLine\n-                    \u0026\u0026 node.getColumnNo() \u003c\u003d lastAnnotattionColumn) {\n+                    || node.getLineNo() \u003d\u003d lastAnnotationLine) {\n                 final DetailAST parentNode \u003d node.getParent();\n                 if (node.getType() \u003d\u003d TokenTypes.AT\n                         \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS) {\n                     logWarningMessage(node, firstNodeIndent);\n                 }\n                 else {\n                     logWarningMessage(node, currentIndent);\n                 }\n                 itr.remove();\n             }\n             else {\n                 break;\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines) {\n        final int currentIndent \u003d atNode.getColumnNo() + indentLevel;\n        final int firstNodeIndent \u003d atNode.getColumnNo();\n        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (firstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            if (node.getLineNo() \u003c lastAnnotationLine\n                    || node.getLineNo() \u003d\u003d lastAnnotationLine) {\n                final DetailAST parentNode \u003d node.getParent();\n                if (node.getType() \u003d\u003d TokenTypes.AT\n                        \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS) {\n                    logWarningMessage(node, firstNodeIndent);\n                }\n                else {\n                    logWarningMessage(node, currentIndent);\n                }\n                itr.remove();\n            }\n            else {\n                break;\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
      "extendedDetails": {}
    },
    "d84869bcff9a2f0ad8d6f1d7741e07d22a78e4a6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, indentation, #512\n",
      "commitDate": "19/01/15 6:34 AM",
      "commitName": "d84869bcff9a2f0ad8d6f1d7741e07d22a78e4a6",
      "commitAuthor": "alexkravin",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Prefixes, indentation, #512\n",
          "commitDate": "19/01/15 6:34 AM",
          "commitName": "d84869bcff9a2f0ad8d6f1d7741e07d22a78e4a6",
          "commitAuthor": "alexkravin",
          "commitDateOld": "05/01/15 2:08 PM",
          "commitNameOld": "6a9e1b3f93b487b86be7def11a0c9880f01ac29f",
          "commitAuthorOld": "maxvetrenko",
          "daysBetweenCommits": 13.69,
          "commitsBetweenForRepo": 31,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,34 @@\n-    private void checkAnnotationIndentation(DetailAST aAtNode,\n-            NavigableMap\u003cInteger, DetailAST\u003e aFirstNodesOnLines)\n+    private void checkAnnotationIndentation(DetailAST atNode,\n+            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines)\n     {\n-        final int currentIndent \u003d aAtNode.getColumnNo() + mIndentLevel;\n-        final int firstNodeIndent \u003d aAtNode.getColumnNo();\n-        final Collection\u003cDetailAST\u003e values \u003d aFirstNodesOnLines.values();\n-        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(aAtNode);\n+        final int currentIndent \u003d atNode.getColumnNo() + indentLevel;\n+        final int firstNodeIndent \u003d atNode.getColumnNo();\n+        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n+        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n         final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n         final int lastAnnotattionColumn \u003d lastAnnotationNode.getColumnNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n-        while (itr.hasNext() \u0026\u0026 aFirstNodesOnLines.size() \u003e 1) {\n+        while (itr.hasNext() \u0026\u0026 firstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n \n             if (node.getLineNo() \u003c lastAnnotationLine\n                     || node.getLineNo() \u003d\u003d lastAnnotationLine\n                     \u0026\u0026 node.getColumnNo() \u003c\u003d lastAnnotattionColumn)\n             {\n                 final DetailAST parentNode \u003d node.getParent();\n                 if (node.getType() \u003d\u003d TokenTypes.AT\n                         \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS)\n                 {\n                     logWarningMessage(node, firstNodeIndent);\n                 }\n                 else {\n                     logWarningMessage(node, currentIndent);\n                 }\n                 itr.remove();\n             }\n             else {\n                 break;\n             }\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines)\n    {\n        final int currentIndent \u003d atNode.getColumnNo() + indentLevel;\n        final int firstNodeIndent \u003d atNode.getColumnNo();\n        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n        final int lastAnnotattionColumn \u003d lastAnnotationNode.getColumnNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (itr.hasNext() \u0026\u0026 firstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            if (node.getLineNo() \u003c lastAnnotationLine\n                    || node.getLineNo() \u003d\u003d lastAnnotationLine\n                    \u0026\u0026 node.getColumnNo() \u003c\u003d lastAnnotattionColumn)\n            {\n                final DetailAST parentNode \u003d node.getParent();\n                if (node.getType() \u003d\u003d TokenTypes.AT\n                        \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS)\n                {\n                    logWarningMessage(node, firstNodeIndent);\n                }\n                else {\n                    logWarningMessage(node, currentIndent);\n                }\n                itr.remove();\n            }\n            else {\n                break;\n            }\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
          "extendedDetails": {
            "oldValue": "[aAtNode-DetailAST, aFirstNodesOnLines-NavigableMap\u003cInteger,DetailAST\u003e]",
            "newValue": "[atNode-DetailAST, firstNodesOnLines-NavigableMap\u003cInteger,DetailAST\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Prefixes, indentation, #512\n",
          "commitDate": "19/01/15 6:34 AM",
          "commitName": "d84869bcff9a2f0ad8d6f1d7741e07d22a78e4a6",
          "commitAuthor": "alexkravin",
          "commitDateOld": "05/01/15 2:08 PM",
          "commitNameOld": "6a9e1b3f93b487b86be7def11a0c9880f01ac29f",
          "commitAuthorOld": "maxvetrenko",
          "daysBetweenCommits": 13.69,
          "commitsBetweenForRepo": 31,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,34 @@\n-    private void checkAnnotationIndentation(DetailAST aAtNode,\n-            NavigableMap\u003cInteger, DetailAST\u003e aFirstNodesOnLines)\n+    private void checkAnnotationIndentation(DetailAST atNode,\n+            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines)\n     {\n-        final int currentIndent \u003d aAtNode.getColumnNo() + mIndentLevel;\n-        final int firstNodeIndent \u003d aAtNode.getColumnNo();\n-        final Collection\u003cDetailAST\u003e values \u003d aFirstNodesOnLines.values();\n-        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(aAtNode);\n+        final int currentIndent \u003d atNode.getColumnNo() + indentLevel;\n+        final int firstNodeIndent \u003d atNode.getColumnNo();\n+        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n+        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n         final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n         final int lastAnnotattionColumn \u003d lastAnnotationNode.getColumnNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n-        while (itr.hasNext() \u0026\u0026 aFirstNodesOnLines.size() \u003e 1) {\n+        while (itr.hasNext() \u0026\u0026 firstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n \n             if (node.getLineNo() \u003c lastAnnotationLine\n                     || node.getLineNo() \u003d\u003d lastAnnotationLine\n                     \u0026\u0026 node.getColumnNo() \u003c\u003d lastAnnotattionColumn)\n             {\n                 final DetailAST parentNode \u003d node.getParent();\n                 if (node.getType() \u003d\u003d TokenTypes.AT\n                         \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS)\n                 {\n                     logWarningMessage(node, firstNodeIndent);\n                 }\n                 else {\n                     logWarningMessage(node, currentIndent);\n                 }\n                 itr.remove();\n             }\n             else {\n                 break;\n             }\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap\u003cInteger, DetailAST\u003e firstNodesOnLines)\n    {\n        final int currentIndent \u003d atNode.getColumnNo() + indentLevel;\n        final int firstNodeIndent \u003d atNode.getColumnNo();\n        final Collection\u003cDetailAST\u003e values \u003d firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(atNode);\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n        final int lastAnnotattionColumn \u003d lastAnnotationNode.getColumnNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (itr.hasNext() \u0026\u0026 firstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            if (node.getLineNo() \u003c lastAnnotationLine\n                    || node.getLineNo() \u003d\u003d lastAnnotationLine\n                    \u0026\u0026 node.getColumnNo() \u003c\u003d lastAnnotattionColumn)\n            {\n                final DetailAST parentNode \u003d node.getParent();\n                if (node.getType() \u003d\u003d TokenTypes.AT\n                        \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS)\n                {\n                    logWarningMessage(node, firstNodeIndent);\n                }\n                else {\n                    logWarningMessage(node, currentIndent);\n                }\n                itr.remove();\n            }\n            else {\n                break;\n            }\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
          "extendedDetails": {}
        }
      ]
    },
    "17ebdc5c3740d37f29b8dc09c4ce4a42d2982b1e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Fixed cases with difficult annotations. #321\n",
      "commitDate": "19/12/14 10:22 PM",
      "commitName": "17ebdc5c3740d37f29b8dc09c4ce4a42d2982b1e",
      "commitAuthor": "maxvetrenko",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Fixed cases with difficult annotations. #321\n",
          "commitDate": "19/12/14 10:22 PM",
          "commitName": "17ebdc5c3740d37f29b8dc09c4ce4a42d2982b1e",
          "commitAuthor": "maxvetrenko",
          "commitDateOld": "13/10/14 4:21 PM",
          "commitNameOld": "e3a48d1527341456a798c3f0c1986de6898a8c60",
          "commitAuthorOld": "maxvetrenko",
          "daysBetweenCommits": 67.29,
          "commitsBetweenForRepo": 236,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,34 @@\n-    private void checkAnnotationIndentation(DetailAST aModifiersNode,\n+    private void checkAnnotationIndentation(DetailAST aAtNode,\n             NavigableMap\u003cInteger, DetailAST\u003e aFirstNodesOnLines)\n     {\n-        final int currentIndent \u003d aModifiersNode.getColumnNo() + mIndentLevel;\n-        final int firstNodeIndent \u003d aModifiersNode.getColumnNo();\n+        final int currentIndent \u003d aAtNode.getColumnNo() + mIndentLevel;\n+        final int firstNodeIndent \u003d aAtNode.getColumnNo();\n         final Collection\u003cDetailAST\u003e values \u003d aFirstNodesOnLines.values();\n+        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(aAtNode);\n+        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n+        final int lastAnnotattionColumn \u003d lastAnnotationNode.getColumnNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n         while (itr.hasNext() \u0026\u0026 aFirstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n-            final int parentType \u003d node.getParent().getType();\n \n-            if (node.getType() \u003d\u003d TokenTypes.AT) {\n-\n-                if (isAnnotationAloneOnLine(node.getParent())) {\n-                    logWarningMessage(node, firstNodeIndent);\n-                    itr.remove();\n-                }\n-            }\n-            else if (parentType !\u003d TokenTypes.MODIFIERS\n-                    \u0026\u0026 !hasTypeNodeAsParent(node)\n-                    \u0026\u0026 parentType !\u003d TokenTypes.ENUM_DEF\n-                    \u0026\u0026 parentType !\u003d TokenTypes.CTOR_DEF\n-                    \u0026\u0026 node.getType() !\u003d TokenTypes.LITERAL_CLASS)\n+            if (node.getLineNo() \u003c lastAnnotationLine\n+                    || node.getLineNo() \u003d\u003d lastAnnotationLine\n+                    \u0026\u0026 node.getColumnNo() \u003c\u003d lastAnnotattionColumn)\n             {\n-                logWarningMessage(node, currentIndent);\n+                final DetailAST parentNode \u003d node.getParent();\n+                if (node.getType() \u003d\u003d TokenTypes.AT\n+                        \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS)\n+                {\n+                    logWarningMessage(node, firstNodeIndent);\n+                }\n+                else {\n+                    logWarningMessage(node, currentIndent);\n+                }\n                 itr.remove();\n             }\n+            else {\n+                break;\n+            }\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void checkAnnotationIndentation(DetailAST aAtNode,\n            NavigableMap\u003cInteger, DetailAST\u003e aFirstNodesOnLines)\n    {\n        final int currentIndent \u003d aAtNode.getColumnNo() + mIndentLevel;\n        final int firstNodeIndent \u003d aAtNode.getColumnNo();\n        final Collection\u003cDetailAST\u003e values \u003d aFirstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(aAtNode);\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n        final int lastAnnotattionColumn \u003d lastAnnotationNode.getColumnNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (itr.hasNext() \u0026\u0026 aFirstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            if (node.getLineNo() \u003c lastAnnotationLine\n                    || node.getLineNo() \u003d\u003d lastAnnotationLine\n                    \u0026\u0026 node.getColumnNo() \u003c\u003d lastAnnotattionColumn)\n            {\n                final DetailAST parentNode \u003d node.getParent();\n                if (node.getType() \u003d\u003d TokenTypes.AT\n                        \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS)\n                {\n                    logWarningMessage(node, firstNodeIndent);\n                }\n                else {\n                    logWarningMessage(node, currentIndent);\n                }\n                itr.remove();\n            }\n            else {\n                break;\n            }\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
          "extendedDetails": {
            "oldValue": "[aModifiersNode-DetailAST, aFirstNodesOnLines-NavigableMap\u003cInteger,DetailAST\u003e]",
            "newValue": "[aAtNode-DetailAST, aFirstNodesOnLines-NavigableMap\u003cInteger,DetailAST\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Fixed cases with difficult annotations. #321\n",
          "commitDate": "19/12/14 10:22 PM",
          "commitName": "17ebdc5c3740d37f29b8dc09c4ce4a42d2982b1e",
          "commitAuthor": "maxvetrenko",
          "commitDateOld": "13/10/14 4:21 PM",
          "commitNameOld": "e3a48d1527341456a798c3f0c1986de6898a8c60",
          "commitAuthorOld": "maxvetrenko",
          "daysBetweenCommits": 67.29,
          "commitsBetweenForRepo": 236,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,34 @@\n-    private void checkAnnotationIndentation(DetailAST aModifiersNode,\n+    private void checkAnnotationIndentation(DetailAST aAtNode,\n             NavigableMap\u003cInteger, DetailAST\u003e aFirstNodesOnLines)\n     {\n-        final int currentIndent \u003d aModifiersNode.getColumnNo() + mIndentLevel;\n-        final int firstNodeIndent \u003d aModifiersNode.getColumnNo();\n+        final int currentIndent \u003d aAtNode.getColumnNo() + mIndentLevel;\n+        final int firstNodeIndent \u003d aAtNode.getColumnNo();\n         final Collection\u003cDetailAST\u003e values \u003d aFirstNodesOnLines.values();\n+        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(aAtNode);\n+        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n+        final int lastAnnotattionColumn \u003d lastAnnotationNode.getColumnNo();\n \n         final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n         while (itr.hasNext() \u0026\u0026 aFirstNodesOnLines.size() \u003e 1) {\n             final DetailAST node \u003d itr.next();\n-            final int parentType \u003d node.getParent().getType();\n \n-            if (node.getType() \u003d\u003d TokenTypes.AT) {\n-\n-                if (isAnnotationAloneOnLine(node.getParent())) {\n-                    logWarningMessage(node, firstNodeIndent);\n-                    itr.remove();\n-                }\n-            }\n-            else if (parentType !\u003d TokenTypes.MODIFIERS\n-                    \u0026\u0026 !hasTypeNodeAsParent(node)\n-                    \u0026\u0026 parentType !\u003d TokenTypes.ENUM_DEF\n-                    \u0026\u0026 parentType !\u003d TokenTypes.CTOR_DEF\n-                    \u0026\u0026 node.getType() !\u003d TokenTypes.LITERAL_CLASS)\n+            if (node.getLineNo() \u003c lastAnnotationLine\n+                    || node.getLineNo() \u003d\u003d lastAnnotationLine\n+                    \u0026\u0026 node.getColumnNo() \u003c\u003d lastAnnotattionColumn)\n             {\n-                logWarningMessage(node, currentIndent);\n+                final DetailAST parentNode \u003d node.getParent();\n+                if (node.getType() \u003d\u003d TokenTypes.AT\n+                        \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS)\n+                {\n+                    logWarningMessage(node, firstNodeIndent);\n+                }\n+                else {\n+                    logWarningMessage(node, currentIndent);\n+                }\n                 itr.remove();\n             }\n+            else {\n+                break;\n+            }\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void checkAnnotationIndentation(DetailAST aAtNode,\n            NavigableMap\u003cInteger, DetailAST\u003e aFirstNodesOnLines)\n    {\n        final int currentIndent \u003d aAtNode.getColumnNo() + mIndentLevel;\n        final int firstNodeIndent \u003d aAtNode.getColumnNo();\n        final Collection\u003cDetailAST\u003e values \u003d aFirstNodesOnLines.values();\n        final DetailAST lastAnnotationNode \u003d getLastAnnotationNode(aAtNode);\n        final int lastAnnotationLine \u003d lastAnnotationNode.getLineNo();\n        final int lastAnnotattionColumn \u003d lastAnnotationNode.getColumnNo();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (itr.hasNext() \u0026\u0026 aFirstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n\n            if (node.getLineNo() \u003c lastAnnotationLine\n                    || node.getLineNo() \u003d\u003d lastAnnotationLine\n                    \u0026\u0026 node.getColumnNo() \u003c\u003d lastAnnotattionColumn)\n            {\n                final DetailAST parentNode \u003d node.getParent();\n                if (node.getType() \u003d\u003d TokenTypes.AT\n                        \u0026\u0026 parentNode.getParent().getType() \u003d\u003d TokenTypes.MODIFIERS)\n                {\n                    logWarningMessage(node, firstNodeIndent);\n                }\n                else {\n                    logWarningMessage(node, currentIndent);\n                }\n                itr.remove();\n            }\n            else {\n                break;\n            }\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java",
          "extendedDetails": {}
        }
      ]
    },
    "e3a48d1527341456a798c3f0c1986de6898a8c60": {
      "type": "Yintroduced",
      "commitMessage": "Update for IndentationCheck. #294\n",
      "commitDate": "13/10/14 4:21 PM",
      "commitName": "e3a48d1527341456a798c3f0c1986de6898a8c60",
      "commitAuthor": "maxvetrenko",
      "diff": "@@ -0,0 +1,30 @@\n+    private void checkAnnotationIndentation(DetailAST aModifiersNode,\n+            NavigableMap\u003cInteger, DetailAST\u003e aFirstNodesOnLines)\n+    {\n+        final int currentIndent \u003d aModifiersNode.getColumnNo() + mIndentLevel;\n+        final int firstNodeIndent \u003d aModifiersNode.getColumnNo();\n+        final Collection\u003cDetailAST\u003e values \u003d aFirstNodesOnLines.values();\n+\n+        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n+        while (itr.hasNext() \u0026\u0026 aFirstNodesOnLines.size() \u003e 1) {\n+            final DetailAST node \u003d itr.next();\n+            final int parentType \u003d node.getParent().getType();\n+\n+            if (node.getType() \u003d\u003d TokenTypes.AT) {\n+\n+                if (isAnnotationAloneOnLine(node.getParent())) {\n+                    logWarningMessage(node, firstNodeIndent);\n+                    itr.remove();\n+                }\n+            }\n+            else if (parentType !\u003d TokenTypes.MODIFIERS\n+                    \u0026\u0026 !hasTypeNodeAsParent(node)\n+                    \u0026\u0026 parentType !\u003d TokenTypes.ENUM_DEF\n+                    \u0026\u0026 parentType !\u003d TokenTypes.CTOR_DEF\n+                    \u0026\u0026 node.getType() !\u003d TokenTypes.LITERAL_CLASS)\n+            {\n+                logWarningMessage(node, currentIndent);\n+                itr.remove();\n+            }\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkAnnotationIndentation(DetailAST aModifiersNode,\n            NavigableMap\u003cInteger, DetailAST\u003e aFirstNodesOnLines)\n    {\n        final int currentIndent \u003d aModifiersNode.getColumnNo() + mIndentLevel;\n        final int firstNodeIndent \u003d aModifiersNode.getColumnNo();\n        final Collection\u003cDetailAST\u003e values \u003d aFirstNodesOnLines.values();\n\n        final Iterator\u003cDetailAST\u003e itr \u003d values.iterator();\n        while (itr.hasNext() \u0026\u0026 aFirstNodesOnLines.size() \u003e 1) {\n            final DetailAST node \u003d itr.next();\n            final int parentType \u003d node.getParent().getType();\n\n            if (node.getType() \u003d\u003d TokenTypes.AT) {\n\n                if (isAnnotationAloneOnLine(node.getParent())) {\n                    logWarningMessage(node, firstNodeIndent);\n                    itr.remove();\n                }\n            }\n            else if (parentType !\u003d TokenTypes.MODIFIERS\n                    \u0026\u0026 !hasTypeNodeAsParent(node)\n                    \u0026\u0026 parentType !\u003d TokenTypes.ENUM_DEF\n                    \u0026\u0026 parentType !\u003d TokenTypes.CTOR_DEF\n                    \u0026\u0026 node.getType() !\u003d TokenTypes.LITERAL_CLASS)\n            {\n                logWarningMessage(node, currentIndent);\n                itr.remove();\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java"
    }
  }
}