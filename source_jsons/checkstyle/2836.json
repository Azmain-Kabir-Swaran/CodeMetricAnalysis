{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RegexpHeaderCheck.java",
  "functionName": "processFiltered",
  "functionId": "processFiltered___file-File__fileText-FileText",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
  "functionStartLine": 241,
  "functionEndLine": 273,
  "numCommitsSeen": 111,
  "timeTaken": 2995,
  "changeHistory": [
    "45f16499d69ea7af0b2934108df32039b969767f",
    "0c2abadbb7f2887f31011157d62edf40bea131c3",
    "82979737c4201b4913ea30b9c9431e71783d1c02",
    "30c3a362d45721e6925fe89ba71f0fe69d0fc471",
    "9c21acf16a4d0dbae220f42c26f4917152c379d1",
    "8c3e4a50749044ae3177fc4c84db9c4fd93abca2",
    "23a1b6253f6296c1a3888361953da47f2808ca3d",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "29027109bf962f47b6a6000fdca69b5679ce4b43",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "b83c9aceef9577eaada5cfd78bc7b2cd04a176d1",
    "f66b504b06f8c479d338fb5b2797392dfa3ef359",
    "bf16d371dab210594755d04afc4697269ed088c0"
  ],
  "changeHistoryShort": {
    "45f16499d69ea7af0b2934108df32039b969767f": "Ybodychange",
    "0c2abadbb7f2887f31011157d62edf40bea131c3": "Ybodychange",
    "82979737c4201b4913ea30b9c9431e71783d1c02": "Ymultichange(Yparameterchange,Ybodychange)",
    "30c3a362d45721e6925fe89ba71f0fe69d0fc471": "Ybodychange",
    "9c21acf16a4d0dbae220f42c26f4917152c379d1": "Ybodychange",
    "8c3e4a50749044ae3177fc4c84db9c4fd93abca2": "Ybodychange",
    "23a1b6253f6296c1a3888361953da47f2808ca3d": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "29027109bf962f47b6a6000fdca69b5679ce4b43": "Ymultichange(Yparameterchange,Ybodychange)",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "b83c9aceef9577eaada5cfd78bc7b2cd04a176d1": "Ybodychange",
    "f66b504b06f8c479d338fb5b2797392dfa3ef359": "Ybodychange",
    "bf16d371dab210594755d04afc4697269ed088c0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "45f16499d69ea7af0b2934108df32039b969767f": {
      "type": "Ybodychange",
      "commitMessage": "Issue #5511: Allow blank lines in Header\n",
      "commitDate": "14/04/18 9:35 PM",
      "commitName": "45f16499d69ea7af0b2934108df32039b969767f",
      "commitAuthor": "Paul Campbell",
      "commitDateOld": "02/01/18 1:24 PM",
      "commitNameOld": "dabb75d43c7e02317565dde4c5e60f380d3b16b8",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 102.3,
      "commitsBetweenForRepo": 233,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,33 @@\n     protected void processFiltered(File file, FileText fileText) {\n         final int headerSize \u003d getHeaderLines().size();\n         final int fileSize \u003d fileText.size();\n \n         if (headerSize - multiLines.length \u003e fileSize) {\n             log(1, MSG_HEADER_MISSING);\n         }\n         else {\n             int headerLineNo \u003d 0;\n             int index;\n             for (index \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 index \u003c fileSize; index++) {\n                 final String line \u003d fileText.get(index);\n                 boolean isMatch \u003d isMatch(line, headerLineNo);\n                 while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                     isMatch \u003d headerLineNo \u003d\u003d headerSize\n                             || isMatch(line, headerLineNo);\n                 }\n                 if (!isMatch) {\n-                    log(index + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n-                            headerLineNo));\n+                    log(index + 1, MSG_HEADER_MISMATCH, getHeaderLine(headerLineNo));\n                     break;\n                 }\n                 if (!isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                 }\n             }\n             if (index \u003d\u003d fileSize) {\n                 // if file finished, but we have at least one non-multi-line\n                 // header isn\u0027t completed\n                 logFirstSinglelineLine(headerLineNo, headerSize);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processFiltered(File file, FileText fileText) {\n        final int headerSize \u003d getHeaderLines().size();\n        final int fileSize \u003d fileText.size();\n\n        if (headerSize - multiLines.length \u003e fileSize) {\n            log(1, MSG_HEADER_MISSING);\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int index;\n            for (index \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 index \u003c fileSize; index++) {\n                final String line \u003d fileText.get(index);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d headerLineNo \u003d\u003d headerSize\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(index + 1, MSG_HEADER_MISMATCH, getHeaderLine(headerLineNo));\n                    break;\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (index \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                logFirstSinglelineLine(headerLineNo, headerSize);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
      "extendedDetails": {}
    },
    "0c2abadbb7f2887f31011157d62edf40bea131c3": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4641: Avoid usage of getLines method from FileText\n",
      "commitDate": "10/07/17 12:57 PM",
      "commitName": "0c2abadbb7f2887f31011157d62edf40bea131c3",
      "commitAuthor": "Timur",
      "commitDateOld": "06/07/17 1:22 PM",
      "commitNameOld": "82979737c4201b4913ea30b9c9431e71783d1c02",
      "commitAuthorOld": "Timur",
      "daysBetweenCommits": 3.98,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,34 @@\n     protected void processFiltered(File file, FileText fileText) {\n         final int headerSize \u003d getHeaderLines().size();\n-        final List\u003cString\u003e lines \u003d fileText.getLines();\n-        final int fileSize \u003d lines.size();\n+        final int fileSize \u003d fileText.size();\n \n         if (headerSize - multiLines.length \u003e fileSize) {\n             log(1, MSG_HEADER_MISSING);\n         }\n         else {\n             int headerLineNo \u003d 0;\n             int index;\n             for (index \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 index \u003c fileSize; index++) {\n-                final String line \u003d lines.get(index);\n+                final String line \u003d fileText.get(index);\n                 boolean isMatch \u003d isMatch(line, headerLineNo);\n                 while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                     isMatch \u003d headerLineNo \u003d\u003d headerSize\n                             || isMatch(line, headerLineNo);\n                 }\n                 if (!isMatch) {\n                     log(index + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n                             headerLineNo));\n                     break;\n                 }\n                 if (!isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                 }\n             }\n             if (index \u003d\u003d fileSize) {\n                 // if file finished, but we have at least one non-multi-line\n                 // header isn\u0027t completed\n                 logFirstSinglelineLine(headerLineNo, headerSize);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processFiltered(File file, FileText fileText) {\n        final int headerSize \u003d getHeaderLines().size();\n        final int fileSize \u003d fileText.size();\n\n        if (headerSize - multiLines.length \u003e fileSize) {\n            log(1, MSG_HEADER_MISSING);\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int index;\n            for (index \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 index \u003c fileSize; index++) {\n                final String line \u003d fileText.get(index);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d headerLineNo \u003d\u003d headerSize\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(index + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n                            headerLineNo));\n                    break;\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (index \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                logFirstSinglelineLine(headerLineNo, headerSize);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
      "extendedDetails": {}
    },
    "82979737c4201b4913ea30b9c9431e71783d1c02": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Issue #3034: FileText should not extends AbstractList\n",
      "commitDate": "06/07/17 1:22 PM",
      "commitName": "82979737c4201b4913ea30b9c9431e71783d1c02",
      "commitAuthor": "Timur",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Issue #3034: FileText should not extends AbstractList\n",
          "commitDate": "06/07/17 1:22 PM",
          "commitName": "82979737c4201b4913ea30b9c9431e71783d1c02",
          "commitAuthor": "Timur",
          "commitDateOld": "12/06/17 10:11 AM",
          "commitNameOld": "4a087c020c2b97130e94f9292b94cb4bc1f6ed93",
          "commitAuthorOld": "sagar-shah94",
          "daysBetweenCommits": 24.13,
          "commitsBetweenForRepo": 134,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,35 @@\n-    protected void processFiltered(File file, List\u003cString\u003e lines) {\n+    protected void processFiltered(File file, FileText fileText) {\n         final int headerSize \u003d getHeaderLines().size();\n+        final List\u003cString\u003e lines \u003d fileText.getLines();\n         final int fileSize \u003d lines.size();\n \n         if (headerSize - multiLines.length \u003e fileSize) {\n             log(1, MSG_HEADER_MISSING);\n         }\n         else {\n             int headerLineNo \u003d 0;\n             int index;\n             for (index \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 index \u003c fileSize; index++) {\n                 final String line \u003d lines.get(index);\n                 boolean isMatch \u003d isMatch(line, headerLineNo);\n                 while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                     isMatch \u003d headerLineNo \u003d\u003d headerSize\n                             || isMatch(line, headerLineNo);\n                 }\n                 if (!isMatch) {\n                     log(index + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n                             headerLineNo));\n                     break;\n                 }\n                 if (!isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                 }\n             }\n             if (index \u003d\u003d fileSize) {\n                 // if file finished, but we have at least one non-multi-line\n                 // header isn\u0027t completed\n                 logFirstSinglelineLine(headerLineNo, headerSize);\n             }\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    protected void processFiltered(File file, FileText fileText) {\n        final int headerSize \u003d getHeaderLines().size();\n        final List\u003cString\u003e lines \u003d fileText.getLines();\n        final int fileSize \u003d lines.size();\n\n        if (headerSize - multiLines.length \u003e fileSize) {\n            log(1, MSG_HEADER_MISSING);\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int index;\n            for (index \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 index \u003c fileSize; index++) {\n                final String line \u003d lines.get(index);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d headerLineNo \u003d\u003d headerSize\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(index + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n                            headerLineNo));\n                    break;\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (index \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                logFirstSinglelineLine(headerLineNo, headerSize);\n            }\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
          "extendedDetails": {
            "oldValue": "[file-File, lines-List\u003cString\u003e]",
            "newValue": "[file-File, fileText-FileText]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Issue #3034: FileText should not extends AbstractList\n",
          "commitDate": "06/07/17 1:22 PM",
          "commitName": "82979737c4201b4913ea30b9c9431e71783d1c02",
          "commitAuthor": "Timur",
          "commitDateOld": "12/06/17 10:11 AM",
          "commitNameOld": "4a087c020c2b97130e94f9292b94cb4bc1f6ed93",
          "commitAuthorOld": "sagar-shah94",
          "daysBetweenCommits": 24.13,
          "commitsBetweenForRepo": 134,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,35 @@\n-    protected void processFiltered(File file, List\u003cString\u003e lines) {\n+    protected void processFiltered(File file, FileText fileText) {\n         final int headerSize \u003d getHeaderLines().size();\n+        final List\u003cString\u003e lines \u003d fileText.getLines();\n         final int fileSize \u003d lines.size();\n \n         if (headerSize - multiLines.length \u003e fileSize) {\n             log(1, MSG_HEADER_MISSING);\n         }\n         else {\n             int headerLineNo \u003d 0;\n             int index;\n             for (index \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 index \u003c fileSize; index++) {\n                 final String line \u003d lines.get(index);\n                 boolean isMatch \u003d isMatch(line, headerLineNo);\n                 while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                     isMatch \u003d headerLineNo \u003d\u003d headerSize\n                             || isMatch(line, headerLineNo);\n                 }\n                 if (!isMatch) {\n                     log(index + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n                             headerLineNo));\n                     break;\n                 }\n                 if (!isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                 }\n             }\n             if (index \u003d\u003d fileSize) {\n                 // if file finished, but we have at least one non-multi-line\n                 // header isn\u0027t completed\n                 logFirstSinglelineLine(headerLineNo, headerSize);\n             }\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    protected void processFiltered(File file, FileText fileText) {\n        final int headerSize \u003d getHeaderLines().size();\n        final List\u003cString\u003e lines \u003d fileText.getLines();\n        final int fileSize \u003d lines.size();\n\n        if (headerSize - multiLines.length \u003e fileSize) {\n            log(1, MSG_HEADER_MISSING);\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int index;\n            for (index \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 index \u003c fileSize; index++) {\n                final String line \u003d lines.get(index);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d headerLineNo \u003d\u003d headerSize\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(index + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n                            headerLineNo));\n                    break;\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (index \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                logFirstSinglelineLine(headerLineNo, headerSize);\n            }\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
          "extendedDetails": {}
        }
      ]
    },
    "30c3a362d45721e6925fe89ba71f0fe69d0fc471": {
      "type": "Ybodychange",
      "commitMessage": "Issue #985: Fix PMD violations for ShortVariable rule\n",
      "commitDate": "06/10/15 5:46 PM",
      "commitName": "30c3a362d45721e6925fe89ba71f0fe69d0fc471",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "31/08/15 11:24 AM",
      "commitNameOld": "2b861bd6e16584e22bb115ff7abd65c35072eb92",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 36.27,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) {\n         final int headerSize \u003d getHeaderLines().size();\n         final int fileSize \u003d lines.size();\n \n         if (headerSize - multiLines.length \u003e fileSize) {\n             log(1, MSG_HEADER_MISSING);\n         }\n         else {\n             int headerLineNo \u003d 0;\n-            int i;\n-            for (i \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 i \u003c fileSize; i++) {\n-                final String line \u003d lines.get(i);\n+            int index;\n+            for (index \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 index \u003c fileSize; index++) {\n+                final String line \u003d lines.get(index);\n                 boolean isMatch \u003d isMatch(line, headerLineNo);\n                 while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                     isMatch \u003d headerLineNo \u003d\u003d headerSize\n                             || isMatch(line, headerLineNo);\n                 }\n                 if (!isMatch) {\n-                    log(i + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n+                    log(index + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n                             headerLineNo));\n                     break;\n                 }\n                 if (!isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                 }\n             }\n-            if (i \u003d\u003d fileSize) {\n+            if (index \u003d\u003d fileSize) {\n                 // if file finished, but we have at least one non-multi-line\n                 // header isn\u0027t completed\n                 logFirstSinglelineLine(headerLineNo, headerSize);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processFiltered(File file, List\u003cString\u003e lines) {\n        final int headerSize \u003d getHeaderLines().size();\n        final int fileSize \u003d lines.size();\n\n        if (headerSize - multiLines.length \u003e fileSize) {\n            log(1, MSG_HEADER_MISSING);\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int index;\n            for (index \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 index \u003c fileSize; index++) {\n                final String line \u003d lines.get(index);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d headerLineNo \u003d\u003d headerSize\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(index + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n                            headerLineNo));\n                    break;\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (index \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                logFirstSinglelineLine(headerLineNo, headerSize);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
      "extendedDetails": {}
    },
    "9c21acf16a4d0dbae220f42c26f4917152c379d1": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: Fixed CyclomaticComplexity violations in RegexpHeaderCheck\n",
      "commitDate": "30/08/15 6:54 AM",
      "commitName": "9c21acf16a4d0dbae220f42c26f4917152c379d1",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": "27/08/15 10:27 PM",
      "commitNameOld": "cb5a59fc6baf5de204e3cc99be6ba9865e44350a",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.35,
      "commitsBetweenForRepo": 103,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,34 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) {\n         final int headerSize \u003d getHeaderLines().size();\n         final int fileSize \u003d lines.size();\n \n         if (headerSize - multiLines.length \u003e fileSize) {\n             log(1, MSG_HEADER_MISSING);\n         }\n         else {\n             int headerLineNo \u003d 0;\n             int i;\n             for (i \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 i \u003c fileSize; i++) {\n                 final String line \u003d lines.get(i);\n                 boolean isMatch \u003d isMatch(line, headerLineNo);\n                 while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                     isMatch \u003d headerLineNo \u003d\u003d headerSize\n                             || isMatch(line, headerLineNo);\n                 }\n                 if (!isMatch) {\n                     log(i + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n                             headerLineNo));\n                     break;\n                 }\n                 if (!isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                 }\n             }\n             if (i \u003d\u003d fileSize) {\n                 // if file finished, but we have at least one non-multi-line\n                 // header isn\u0027t completed\n-                for (; headerLineNo \u003c headerSize; headerLineNo++) {\n-                    if (!isMultiLine(headerLineNo)) {\n-                        log(1, MSG_HEADER_MISSING);\n-                        break;\n-                    }\n-                }\n+                logFirstSinglelineLine(headerLineNo, headerSize);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processFiltered(File file, List\u003cString\u003e lines) {\n        final int headerSize \u003d getHeaderLines().size();\n        final int fileSize \u003d lines.size();\n\n        if (headerSize - multiLines.length \u003e fileSize) {\n            log(1, MSG_HEADER_MISSING);\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int i;\n            for (i \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 i \u003c fileSize; i++) {\n                final String line \u003d lines.get(i);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d headerLineNo \u003d\u003d headerSize\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(i + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n                            headerLineNo));\n                    break;\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (i \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                logFirstSinglelineLine(headerLineNo, headerSize);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
      "extendedDetails": {}
    },
    "8c3e4a50749044ae3177fc4c84db9c4fd93abca2": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: MultipleStringLiterals violations partial fix\n",
      "commitDate": "25/08/15 5:12 AM",
      "commitName": "8c3e4a50749044ae3177fc4c84db9c4fd93abca2",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": "21/08/15 5:05 AM",
      "commitNameOld": "23a1b6253f6296c1a3888361953da47f2808ca3d",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 4.0,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) {\n         final int headerSize \u003d getHeaderLines().size();\n         final int fileSize \u003d lines.size();\n \n         if (headerSize - multiLines.length \u003e fileSize) {\n-            log(1, \"header.missing\");\n+            log(1, MSG_HEADER_MISSING);\n         }\n         else {\n             int headerLineNo \u003d 0;\n             int i;\n             for (i \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 i \u003c fileSize; i++) {\n                 final String line \u003d lines.get(i);\n                 boolean isMatch \u003d isMatch(line, headerLineNo);\n                 while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                     isMatch \u003d headerLineNo \u003d\u003d headerSize\n                             || isMatch(line, headerLineNo);\n                 }\n                 if (!isMatch) {\n-                    log(i + 1, \"header.mismatch\", getHeaderLines().get(\n+                    log(i + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n                             headerLineNo));\n                     break;\n                 }\n                 if (!isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                 }\n             }\n             if (i \u003d\u003d fileSize) {\n                 // if file finished, but we have at least one non-multi-line\n                 // header isn\u0027t completed\n                 for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                     if (!isMultiLine(headerLineNo)) {\n-                        log(1, \"header.missing\");\n+                        log(1, MSG_HEADER_MISSING);\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processFiltered(File file, List\u003cString\u003e lines) {\n        final int headerSize \u003d getHeaderLines().size();\n        final int fileSize \u003d lines.size();\n\n        if (headerSize - multiLines.length \u003e fileSize) {\n            log(1, MSG_HEADER_MISSING);\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int i;\n            for (i \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 i \u003c fileSize; i++) {\n                final String line \u003d lines.get(i);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d headerLineNo \u003d\u003d headerSize\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(i + 1, MSG_HEADER_MISMATCH, getHeaderLines().get(\n                            headerLineNo));\n                    break;\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (i \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                    if (!isMultiLine(headerLineNo)) {\n                        log(1, MSG_HEADER_MISSING);\n                        break;\n                    }\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
      "extendedDetails": {}
    },
    "23a1b6253f6296c1a3888361953da47f2808ca3d": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: Fix for \u0027Don\u0027t use trailing comments\u0027 (partial)\n",
      "commitDate": "21/08/15 5:05 AM",
      "commitName": "23a1b6253f6296c1a3888361953da47f2808ca3d",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": "18/08/15 1:25 AM",
      "commitNameOld": "54ccca18635a4aeea90da86d30590df498f76b08",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 3.15,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines) {\n         final int headerSize \u003d getHeaderLines().size();\n         final int fileSize \u003d lines.size();\n \n         if (headerSize - multiLines.length \u003e fileSize) {\n             log(1, \"header.missing\");\n         }\n         else {\n             int headerLineNo \u003d 0;\n             int i;\n             for (i \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 i \u003c fileSize; i++) {\n                 final String line \u003d lines.get(i);\n                 boolean isMatch \u003d isMatch(line, headerLineNo);\n                 while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                     isMatch \u003d headerLineNo \u003d\u003d headerSize\n                             || isMatch(line, headerLineNo);\n                 }\n                 if (!isMatch) {\n                     log(i + 1, \"header.mismatch\", getHeaderLines().get(\n                             headerLineNo));\n-                    break; // stop checking\n+                    break;\n                 }\n                 if (!isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                 }\n             }\n             if (i \u003d\u003d fileSize) {\n                 // if file finished, but we have at least one non-multi-line\n                 // header isn\u0027t completed\n                 for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                     if (!isMultiLine(headerLineNo)) {\n                         log(1, \"header.missing\");\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processFiltered(File file, List\u003cString\u003e lines) {\n        final int headerSize \u003d getHeaderLines().size();\n        final int fileSize \u003d lines.size();\n\n        if (headerSize - multiLines.length \u003e fileSize) {\n            log(1, \"header.missing\");\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int i;\n            for (i \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 i \u003c fileSize; i++) {\n                final String line \u003d lines.get(i);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d headerLineNo \u003d\u003d headerSize\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(i + 1, \"header.mismatch\", getHeaderLines().get(\n                            headerLineNo));\n                    break;\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (i \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                    if (!isMultiLine(headerLineNo)) {\n                        log(1, \"header.missing\");\n                        break;\n                    }\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
      "extendedDetails": {}
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": "10/03/15 2:36 PM",
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "18/02/15 1:14 PM",
      "commitNameOld": "c9a9e6508c15e00cf6820b213d79d5ebf41c6343",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 20.02,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n     protected void processFiltered(File file, List\u003cString\u003e lines)\n     {\n         final int headerSize \u003d getHeaderLines().size();\n         final int fileSize \u003d lines.size();\n \n         if (headerSize - multiLines.length \u003e fileSize) {\n             log(1, \"header.missing\");\n         }\n         else {\n             int headerLineNo \u003d 0;\n             int i;\n-            for (i \u003d 0; (headerLineNo \u003c headerSize) \u0026\u0026 (i \u003c fileSize); i++) {\n+            for (i \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 i \u003c fileSize; i++) {\n                 final String line \u003d lines.get(i);\n                 boolean isMatch \u003d isMatch(line, headerLineNo);\n                 while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n-                    isMatch \u003d (headerLineNo \u003d\u003d headerSize)\n+                    isMatch \u003d headerLineNo \u003d\u003d headerSize\n                             || isMatch(line, headerLineNo);\n                 }\n                 if (!isMatch) {\n                     log(i + 1, \"header.mismatch\", getHeaderLines().get(\n                             headerLineNo));\n                     break; // stop checking\n                 }\n                 if (!isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                 }\n             }\n             if (i \u003d\u003d fileSize) {\n                 // if file finished, but we have at least one non-multi-line\n                 // header isn\u0027t completed\n                 for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                     if (!isMultiLine(headerLineNo)) {\n                         log(1, \"header.missing\");\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processFiltered(File file, List\u003cString\u003e lines)\n    {\n        final int headerSize \u003d getHeaderLines().size();\n        final int fileSize \u003d lines.size();\n\n        if (headerSize - multiLines.length \u003e fileSize) {\n            log(1, \"header.missing\");\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int i;\n            for (i \u003d 0; headerLineNo \u003c headerSize \u0026\u0026 i \u003c fileSize; i++) {\n                final String line \u003d lines.get(i);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d headerLineNo \u003d\u003d headerSize\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(i + 1, \"header.mismatch\", getHeaderLines().get(\n                            headerLineNo));\n                    break; // stop checking\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (i \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                    if (!isMultiLine(headerLineNo)) {\n                        log(1, \"header.missing\");\n                        break;\n                    }\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
      "extendedDetails": {}
    },
    "29027109bf962f47b6a6000fdca69b5679ce4b43": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, header, #512\n",
      "commitDate": "19/01/15 6:35 AM",
      "commitName": "29027109bf962f47b6a6000fdca69b5679ce4b43",
      "commitAuthor": "alexkravin",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Prefixes, header, #512\n",
          "commitDate": "19/01/15 6:35 AM",
          "commitName": "29027109bf962f47b6a6000fdca69b5679ce4b43",
          "commitAuthor": "alexkravin",
          "commitDateOld": "09/01/15 8:44 AM",
          "commitNameOld": "dcb3029c008907edf6aa4b59a51349f0ca94f54b",
          "commitAuthorOld": "alexkravin",
          "daysBetweenCommits": 9.91,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,40 @@\n-    protected void processFiltered(File aFile, List\u003cString\u003e aLines)\n+    protected void processFiltered(File file, List\u003cString\u003e lines)\n     {\n         final int headerSize \u003d getHeaderLines().size();\n-        final int fileSize \u003d aLines.size();\n+        final int fileSize \u003d lines.size();\n \n-        if (headerSize - mMultiLines.length \u003e fileSize) {\n+        if (headerSize - multiLines.length \u003e fileSize) {\n             log(1, \"header.missing\");\n         }\n         else {\n             int headerLineNo \u003d 0;\n             int i;\n             for (i \u003d 0; (headerLineNo \u003c headerSize) \u0026\u0026 (i \u003c fileSize); i++) {\n-                final String line \u003d aLines.get(i);\n+                final String line \u003d lines.get(i);\n                 boolean isMatch \u003d isMatch(line, headerLineNo);\n                 while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                     isMatch \u003d (headerLineNo \u003d\u003d headerSize)\n                             || isMatch(line, headerLineNo);\n                 }\n                 if (!isMatch) {\n                     log(i + 1, \"header.mismatch\", getHeaderLines().get(\n                             headerLineNo));\n                     break; // stop checking\n                 }\n                 if (!isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                 }\n             }\n             if (i \u003d\u003d fileSize) {\n                 // if file finished, but we have at least one non-multi-line\n                 // header isn\u0027t completed\n                 for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                     if (!isMultiLine(headerLineNo)) {\n                         log(1, \"header.missing\");\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    protected void processFiltered(File file, List\u003cString\u003e lines)\n    {\n        final int headerSize \u003d getHeaderLines().size();\n        final int fileSize \u003d lines.size();\n\n        if (headerSize - multiLines.length \u003e fileSize) {\n            log(1, \"header.missing\");\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int i;\n            for (i \u003d 0; (headerLineNo \u003c headerSize) \u0026\u0026 (i \u003c fileSize); i++) {\n                final String line \u003d lines.get(i);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d (headerLineNo \u003d\u003d headerSize)\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(i + 1, \"header.mismatch\", getHeaderLines().get(\n                            headerLineNo));\n                    break; // stop checking\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (i \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                    if (!isMultiLine(headerLineNo)) {\n                        log(1, \"header.missing\");\n                        break;\n                    }\n                }\n            }\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
          "extendedDetails": {
            "oldValue": "[aFile-File, aLines-List\u003cString\u003e]",
            "newValue": "[file-File, lines-List\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Prefixes, header, #512\n",
          "commitDate": "19/01/15 6:35 AM",
          "commitName": "29027109bf962f47b6a6000fdca69b5679ce4b43",
          "commitAuthor": "alexkravin",
          "commitDateOld": "09/01/15 8:44 AM",
          "commitNameOld": "dcb3029c008907edf6aa4b59a51349f0ca94f54b",
          "commitAuthorOld": "alexkravin",
          "daysBetweenCommits": 9.91,
          "commitsBetweenForRepo": 27,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,40 @@\n-    protected void processFiltered(File aFile, List\u003cString\u003e aLines)\n+    protected void processFiltered(File file, List\u003cString\u003e lines)\n     {\n         final int headerSize \u003d getHeaderLines().size();\n-        final int fileSize \u003d aLines.size();\n+        final int fileSize \u003d lines.size();\n \n-        if (headerSize - mMultiLines.length \u003e fileSize) {\n+        if (headerSize - multiLines.length \u003e fileSize) {\n             log(1, \"header.missing\");\n         }\n         else {\n             int headerLineNo \u003d 0;\n             int i;\n             for (i \u003d 0; (headerLineNo \u003c headerSize) \u0026\u0026 (i \u003c fileSize); i++) {\n-                final String line \u003d aLines.get(i);\n+                final String line \u003d lines.get(i);\n                 boolean isMatch \u003d isMatch(line, headerLineNo);\n                 while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                     isMatch \u003d (headerLineNo \u003d\u003d headerSize)\n                             || isMatch(line, headerLineNo);\n                 }\n                 if (!isMatch) {\n                     log(i + 1, \"header.mismatch\", getHeaderLines().get(\n                             headerLineNo));\n                     break; // stop checking\n                 }\n                 if (!isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                 }\n             }\n             if (i \u003d\u003d fileSize) {\n                 // if file finished, but we have at least one non-multi-line\n                 // header isn\u0027t completed\n                 for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                     if (!isMultiLine(headerLineNo)) {\n                         log(1, \"header.missing\");\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    protected void processFiltered(File file, List\u003cString\u003e lines)\n    {\n        final int headerSize \u003d getHeaderLines().size();\n        final int fileSize \u003d lines.size();\n\n        if (headerSize - multiLines.length \u003e fileSize) {\n            log(1, \"header.missing\");\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int i;\n            for (i \u003d 0; (headerLineNo \u003c headerSize) \u0026\u0026 (i \u003c fileSize); i++) {\n                final String line \u003d lines.get(i);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d (headerLineNo \u003d\u003d headerSize)\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(i + 1, \"header.mismatch\", getHeaderLines().get(\n                            headerLineNo));\n                    break; // stop checking\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (i \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                    if (!isMultiLine(headerLineNo)) {\n                        log(1, \"header.missing\");\n                        break;\n                    }\n                }\n            }\n        }\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
          "extendedDetails": {}
        }
      ]
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": "04/03/14 9:18 AM",
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": "26/02/14 10:35 PM",
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    protected void processFiltered(File aFile, List\u003cString\u003e aLines)\n    {\n        final int headerSize \u003d getHeaderLines().size();\n        final int fileSize \u003d aLines.size();\n\n        if (headerSize - mMultiLines.length \u003e fileSize) {\n            log(1, \"header.missing\");\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int i;\n            for (i \u003d 0; (headerLineNo \u003c headerSize) \u0026\u0026 (i \u003c fileSize); i++) {\n                final String line \u003d aLines.get(i);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d (headerLineNo \u003d\u003d headerSize)\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(i + 1, \"header.mismatch\", getHeaderLines().get(\n                            headerLineNo));\n                    break; // stop checking\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (i \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                    if (!isMultiLine(headerLineNo)) {\n                        log(1, \"header.missing\");\n                        break;\n                    }\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
      "extendedDetails": {
        "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java"
      }
    },
    "b83c9aceef9577eaada5cfd78bc7b2cd04a176d1": {
      "type": "Ybodychange",
      "commitMessage": "Simplified the code by removing HeaderInfo classes, they were introduced to avoid code duplication between header checks in two separate inheritance trees (Java Check vs. FileSetCheck). Now that we have only FileSetChecks as Header checks, this delegation is no longer necessary.\n",
      "commitDate": "05/02/09 1:22 PM",
      "commitName": "b83c9aceef9577eaada5cfd78bc7b2cd04a176d1",
      "commitAuthor": "Lars Khne",
      "commitDateOld": "16/11/08 3:11 AM",
      "commitNameOld": "f66b504b06f8c479d338fb5b2797392dfa3ef359",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 81.42,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,40 @@\n     protected void processFiltered(File aFile, List\u003cString\u003e aLines)\n     {\n-        final int headerSize \u003d getRegexpHeaderInfo().getHeaderLines().size();\n+        final int headerSize \u003d getHeaderLines().size();\n         final int fileSize \u003d aLines.size();\n \n-        if (headerSize - getRegexpHeaderInfo().getMultLines().length \u003e fileSize)\n-        {\n+        if (headerSize - mMultiLines.length \u003e fileSize) {\n             log(1, \"header.missing\");\n         }\n         else {\n             int headerLineNo \u003d 0;\n             int i;\n             for (i \u003d 0; (headerLineNo \u003c headerSize) \u0026\u0026 (i \u003c fileSize); i++) {\n                 final String line \u003d aLines.get(i);\n                 boolean isMatch \u003d isMatch(line, headerLineNo);\n                 while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                     isMatch \u003d (headerLineNo \u003d\u003d headerSize)\n                             || isMatch(line, headerLineNo);\n                 }\n                 if (!isMatch) {\n                     log(i + 1, \"header.mismatch\", getHeaderLines().get(\n                             headerLineNo));\n                     break; // stop checking\n                 }\n                 if (!isMultiLine(headerLineNo)) {\n                     headerLineNo++;\n                 }\n             }\n             if (i \u003d\u003d fileSize) {\n                 // if file finished, but we have at least one non-multi-line\n                 // header isn\u0027t completed\n                 for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                     if (!isMultiLine(headerLineNo)) {\n                         log(1, \"header.missing\");\n                         break;\n                     }\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processFiltered(File aFile, List\u003cString\u003e aLines)\n    {\n        final int headerSize \u003d getHeaderLines().size();\n        final int fileSize \u003d aLines.size();\n\n        if (headerSize - mMultiLines.length \u003e fileSize) {\n            log(1, \"header.missing\");\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int i;\n            for (i \u003d 0; (headerLineNo \u003c headerSize) \u0026\u0026 (i \u003c fileSize); i++) {\n                final String line \u003d aLines.get(i);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d (headerLineNo \u003d\u003d headerSize)\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(i + 1, \"header.mismatch\", getHeaderLines().get(\n                            headerLineNo));\n                    break; // stop checking\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (i \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                    if (!isMultiLine(headerLineNo)) {\n                        log(1, \"header.missing\");\n                        break;\n                    }\n                }\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
      "extendedDetails": {}
    },
    "f66b504b06f8c479d338fb5b2797392dfa3ef359": {
      "type": "Ybodychange",
      "commitMessage": "consolidation of code.\n",
      "commitDate": "16/11/08 3:11 AM",
      "commitName": "f66b504b06f8c479d338fb5b2797392dfa3ef359",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "16/11/08 2:30 AM",
      "commitNameOld": "bf16d371dab210594755d04afc4697269ed088c0",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,4 +1,41 @@\n     protected void processFiltered(File aFile, List\u003cString\u003e aLines)\n     {\n-        mRegexpHeaderChecker.checkLines(aLines);\n+        final int headerSize \u003d getRegexpHeaderInfo().getHeaderLines().size();\n+        final int fileSize \u003d aLines.size();\n+\n+        if (headerSize - getRegexpHeaderInfo().getMultLines().length \u003e fileSize)\n+        {\n+            log(1, \"header.missing\");\n+        }\n+        else {\n+            int headerLineNo \u003d 0;\n+            int i;\n+            for (i \u003d 0; (headerLineNo \u003c headerSize) \u0026\u0026 (i \u003c fileSize); i++) {\n+                final String line \u003d aLines.get(i);\n+                boolean isMatch \u003d isMatch(line, headerLineNo);\n+                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n+                    headerLineNo++;\n+                    isMatch \u003d (headerLineNo \u003d\u003d headerSize)\n+                            || isMatch(line, headerLineNo);\n+                }\n+                if (!isMatch) {\n+                    log(i + 1, \"header.mismatch\", getHeaderLines().get(\n+                            headerLineNo));\n+                    break; // stop checking\n+                }\n+                if (!isMultiLine(headerLineNo)) {\n+                    headerLineNo++;\n+                }\n+            }\n+            if (i \u003d\u003d fileSize) {\n+                // if file finished, but we have at least one non-multi-line\n+                // header isn\u0027t completed\n+                for (; headerLineNo \u003c headerSize; headerLineNo++) {\n+                    if (!isMultiLine(headerLineNo)) {\n+                        log(1, \"header.missing\");\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processFiltered(File aFile, List\u003cString\u003e aLines)\n    {\n        final int headerSize \u003d getRegexpHeaderInfo().getHeaderLines().size();\n        final int fileSize \u003d aLines.size();\n\n        if (headerSize - getRegexpHeaderInfo().getMultLines().length \u003e fileSize)\n        {\n            log(1, \"header.missing\");\n        }\n        else {\n            int headerLineNo \u003d 0;\n            int i;\n            for (i \u003d 0; (headerLineNo \u003c headerSize) \u0026\u0026 (i \u003c fileSize); i++) {\n                final String line \u003d aLines.get(i);\n                boolean isMatch \u003d isMatch(line, headerLineNo);\n                while (!isMatch \u0026\u0026 isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                    isMatch \u003d (headerLineNo \u003d\u003d headerSize)\n                            || isMatch(line, headerLineNo);\n                }\n                if (!isMatch) {\n                    log(i + 1, \"header.mismatch\", getHeaderLines().get(\n                            headerLineNo));\n                    break; // stop checking\n                }\n                if (!isMultiLine(headerLineNo)) {\n                    headerLineNo++;\n                }\n            }\n            if (i \u003d\u003d fileSize) {\n                // if file finished, but we have at least one non-multi-line\n                // header isn\u0027t completed\n                for (; headerLineNo \u003c headerSize; headerLineNo++) {\n                    if (!isMultiLine(headerLineNo)) {\n                        log(1, \"header.missing\");\n                        break;\n                    }\n                }\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java",
      "extendedDetails": {}
    },
    "bf16d371dab210594755d04afc4697269ed088c0": {
      "type": "Yintroduced",
      "commitMessage": "converting the header checks to be fileset based.\n",
      "commitDate": "16/11/08 2:30 AM",
      "commitName": "bf16d371dab210594755d04afc4697269ed088c0",
      "commitAuthor": "Oliver Burn",
      "diff": "@@ -0,0 +1,4 @@\n+    protected void processFiltered(File aFile, List\u003cString\u003e aLines)\n+    {\n+        mRegexpHeaderChecker.checkLines(aLines);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    protected void processFiltered(File aFile, List\u003cString\u003e aLines)\n    {\n        mRegexpHeaderChecker.checkLines(aLines);\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java"
    }
  }
}