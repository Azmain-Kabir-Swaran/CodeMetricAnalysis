{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RegexpCheck.java",
  "functionName": "findMatch",
  "functionId": "findMatch",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpCheck.java",
  "functionStartLine": 601,
  "functionEndLine": 625,
  "numCommitsSeen": 67,
  "timeTaken": 1868,
  "changeHistory": [
    "2880edd6554400955fb950bf8127311c436d2a7a",
    "842c152be6b0bbcb754a346a6ce4b59c47469c17",
    "4f910b8be92f424f017b139df0e680e129829020",
    "edc4cc9ffc1a5b872398af9d6735b4bde75de385",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "58219b9bd31c8f7fbc4f4bba0eeb811851f276b3",
    "1ca93bdf66b630e58d979ad2aa40f02e678db5cf",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "08638b5f739d9929698860048c052da2d5f80209",
    "c2d3932843e70e4bb5df7161800aca248f9af778",
    "ab1e3089135d74b0d8c3296d0074244ca89a55e2"
  ],
  "changeHistoryShort": {
    "2880edd6554400955fb950bf8127311c436d2a7a": "Ybodychange",
    "842c152be6b0bbcb754a346a6ce4b59c47469c17": "Ybodychange",
    "4f910b8be92f424f017b139df0e680e129829020": "Yfilerename",
    "edc4cc9ffc1a5b872398af9d6735b4bde75de385": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "58219b9bd31c8f7fbc4f4bba0eeb811851f276b3": "Ybodychange",
    "1ca93bdf66b630e58d979ad2aa40f02e678db5cf": "Ybodychange",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "08638b5f739d9929698860048c052da2d5f80209": "Ybodychange",
    "c2d3932843e70e4bb5df7161800aca248f9af778": "Ybodychange",
    "ab1e3089135d74b0d8c3296d0074244ca89a55e2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2880edd6554400955fb950bf8127311c436d2a7a": {
      "type": "Ybodychange",
      "commitMessage": "Decrease scope of variables. #1538\n",
      "commitDate": "02/08/15 6:48 PM",
      "commitName": "2880edd6554400955fb950bf8127311c436d2a7a",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "02/08/15 6:41 PM",
      "commitNameOld": "fd794d428cc0854ddd4d416f0208d49f1ee9cbe1",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,27 @@\n     private void findMatch() {\n-        int startLine;\n-        boolean foundMatch;\n-        boolean ignore \u003d false;\n \n-        foundMatch \u003d matcher.find();\n+        final boolean foundMatch \u003d matcher.find();\n         if (foundMatch) {\n             final FileText text \u003d getFileContents().getText();\n             final LineColumn start \u003d text.lineColumn(matcher.start());\n-            startLine \u003d start.getLine();\n+            final int startLine \u003d start.getLine();\n \n-            ignore \u003d isIgnore(startLine, text, start);\n+            final boolean ignore \u003d isIgnore(startLine, text, start);\n \n             if (!ignore) {\n                 matchCount++;\n                 if (illegalPattern || checkForDuplicates\n                         \u0026\u0026 matchCount - 1 \u003e duplicateLimit) {\n                     errorCount++;\n                     logMessage(startLine);\n                 }\n             }\n             if (canContinueValidation(ignore)) {\n                 findMatch();\n             }\n         }\n         else if (!illegalPattern \u0026\u0026 matchCount \u003d\u003d 0) {\n             logMessage(0);\n         }\n \n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void findMatch() {\n\n        final boolean foundMatch \u003d matcher.find();\n        if (foundMatch) {\n            final FileText text \u003d getFileContents().getText();\n            final LineColumn start \u003d text.lineColumn(matcher.start());\n            final int startLine \u003d start.getLine();\n\n            final boolean ignore \u003d isIgnore(startLine, text, start);\n\n            if (!ignore) {\n                matchCount++;\n                if (illegalPattern || checkForDuplicates\n                        \u0026\u0026 matchCount - 1 \u003e duplicateLimit) {\n                    errorCount++;\n                    logMessage(startLine);\n                }\n            }\n            if (canContinueValidation(ignore)) {\n                findMatch();\n            }\n        }\n        else if (!illegalPattern \u0026\u0026 matchCount \u003d\u003d 0) {\n            logMessage(0);\n        }\n\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpCheck.java",
      "extendedDetails": {}
    },
    "842c152be6b0bbcb754a346a6ce4b59c47469c17": {
      "type": "Ybodychange",
      "commitMessage": "RegexpCheck updated to follow Cyclomatic Complexity rule. #954\n",
      "commitDate": "14/06/15 9:56 PM",
      "commitName": "842c152be6b0bbcb754a346a6ce4b59c47469c17",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "06/06/15 6:59 PM",
      "commitNameOld": "4f910b8be92f424f017b139df0e680e129829020",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 8.12,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,30 @@\n     private void findMatch() {\n         int startLine;\n-        int startColumn;\n-        int endLine;\n-        int endColumn;\n         boolean foundMatch;\n         boolean ignore \u003d false;\n \n         foundMatch \u003d matcher.find();\n-        if (!foundMatch \u0026\u0026 !illegalPattern \u0026\u0026 matchCount \u003d\u003d 0) {\n-            logMessage(0);\n-        }\n-        else if (foundMatch) {\n+        if (foundMatch) {\n             final FileText text \u003d getFileContents().getText();\n             final LineColumn start \u003d text.lineColumn(matcher.start());\n-            final LineColumn end;\n-            if (matcher.end() \u003d\u003d 0) {\n-                end \u003d text.lineColumn(0);\n-            }\n-            else {\n-                end \u003d text.lineColumn(matcher.end() - 1);\n-            }\n             startLine \u003d start.getLine();\n-            startColumn \u003d start.getColumn();\n-            endLine \u003d end.getLine();\n-            endColumn \u003d end.getColumn();\n-            if (ignoreComments) {\n-                final FileContents theFileContents \u003d getFileContents();\n-                ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n-                    startColumn, endLine, endColumn);\n-            }\n+\n+            ignore \u003d isIgnore(startLine, text, start);\n+\n             if (!ignore) {\n                 matchCount++;\n                 if (illegalPattern || checkForDuplicates\n                         \u0026\u0026 matchCount - 1 \u003e duplicateLimit) {\n                     errorCount++;\n                     logMessage(startLine);\n                 }\n             }\n-            if (errorCount \u003c errorLimit\n-                    \u0026\u0026 (ignore || illegalPattern || checkForDuplicates)) {\n+            if (canContinueValidation(ignore)) {\n                 findMatch();\n             }\n         }\n+        else if (!illegalPattern \u0026\u0026 matchCount \u003d\u003d 0) {\n+            logMessage(0);\n+        }\n+\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void findMatch() {\n        int startLine;\n        boolean foundMatch;\n        boolean ignore \u003d false;\n\n        foundMatch \u003d matcher.find();\n        if (foundMatch) {\n            final FileText text \u003d getFileContents().getText();\n            final LineColumn start \u003d text.lineColumn(matcher.start());\n            startLine \u003d start.getLine();\n\n            ignore \u003d isIgnore(startLine, text, start);\n\n            if (!ignore) {\n                matchCount++;\n                if (illegalPattern || checkForDuplicates\n                        \u0026\u0026 matchCount - 1 \u003e duplicateLimit) {\n                    errorCount++;\n                    logMessage(startLine);\n                }\n            }\n            if (canContinueValidation(ignore)) {\n                findMatch();\n            }\n        }\n        else if (!illegalPattern \u0026\u0026 matchCount \u003d\u003d 0) {\n            logMessage(0);\n        }\n\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpCheck.java",
      "extendedDetails": {}
    },
    "4f910b8be92f424f017b139df0e680e129829020": {
      "type": "Yfilerename",
      "commitMessage": "Move Regexp check from miscellaneous to regexp category. #1170\n",
      "commitDate": "06/06/15 6:59 PM",
      "commitName": "4f910b8be92f424f017b139df0e680e129829020",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "06/06/15 2:03 PM",
      "commitNameOld": "5fae8f1bd3d513d63ad4e5ba50d0517a7ccfdcbe",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.21,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void findMatch() {\n        int startLine;\n        int startColumn;\n        int endLine;\n        int endColumn;\n        boolean foundMatch;\n        boolean ignore \u003d false;\n\n        foundMatch \u003d matcher.find();\n        if (!foundMatch \u0026\u0026 !illegalPattern \u0026\u0026 matchCount \u003d\u003d 0) {\n            logMessage(0);\n        }\n        else if (foundMatch) {\n            final FileText text \u003d getFileContents().getText();\n            final LineColumn start \u003d text.lineColumn(matcher.start());\n            final LineColumn end;\n            if (matcher.end() \u003d\u003d 0) {\n                end \u003d text.lineColumn(0);\n            }\n            else {\n                end \u003d text.lineColumn(matcher.end() - 1);\n            }\n            startLine \u003d start.getLine();\n            startColumn \u003d start.getColumn();\n            endLine \u003d end.getLine();\n            endColumn \u003d end.getColumn();\n            if (ignoreComments) {\n                final FileContents theFileContents \u003d getFileContents();\n                ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                    startColumn, endLine, endColumn);\n            }\n            if (!ignore) {\n                matchCount++;\n                if (illegalPattern || checkForDuplicates\n                        \u0026\u0026 matchCount - 1 \u003e duplicateLimit) {\n                    errorCount++;\n                    logMessage(startLine);\n                }\n            }\n            if (errorCount \u003c errorLimit\n                    \u0026\u0026 (ignore || illegalPattern || checkForDuplicates)) {\n                findMatch();\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpCheck.java",
      "extendedDetails": {
        "oldPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpCheck.java"
      }
    },
    "edc4cc9ffc1a5b872398af9d6735b4bde75de385": {
      "type": "Ybodychange",
      "commitMessage": "Fix Regexp check causing exception on file with newline on top. #1129\n",
      "commitDate": "25/05/15 5:55 PM",
      "commitName": "edc4cc9ffc1a5b872398af9d6735b4bde75de385",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "17/05/15 4:47 AM",
      "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 8.55,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,45 @@\n     private void findMatch() {\n         int startLine;\n         int startColumn;\n         int endLine;\n         int endColumn;\n         boolean foundMatch;\n         boolean ignore \u003d false;\n \n         foundMatch \u003d matcher.find();\n         if (!foundMatch \u0026\u0026 !illegalPattern \u0026\u0026 matchCount \u003d\u003d 0) {\n             logMessage(0);\n         }\n         else if (foundMatch) {\n             final FileText text \u003d getFileContents().getText();\n             final LineColumn start \u003d text.lineColumn(matcher.start());\n-            final LineColumn end \u003d text.lineColumn(matcher.end() - 1);\n+            final LineColumn end;\n+            if (matcher.end() \u003d\u003d 0) {\n+                end \u003d text.lineColumn(0);\n+            }\n+            else {\n+                end \u003d text.lineColumn(matcher.end() - 1);\n+            }\n             startLine \u003d start.getLine();\n             startColumn \u003d start.getColumn();\n             endLine \u003d end.getLine();\n             endColumn \u003d end.getColumn();\n             if (ignoreComments) {\n                 final FileContents theFileContents \u003d getFileContents();\n                 ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                     startColumn, endLine, endColumn);\n             }\n             if (!ignore) {\n                 matchCount++;\n                 if (illegalPattern || checkForDuplicates\n                         \u0026\u0026 matchCount - 1 \u003e duplicateLimit) {\n                     errorCount++;\n                     logMessage(startLine);\n                 }\n             }\n             if (errorCount \u003c errorLimit\n                     \u0026\u0026 (ignore || illegalPattern || checkForDuplicates)) {\n                 findMatch();\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void findMatch() {\n        int startLine;\n        int startColumn;\n        int endLine;\n        int endColumn;\n        boolean foundMatch;\n        boolean ignore \u003d false;\n\n        foundMatch \u003d matcher.find();\n        if (!foundMatch \u0026\u0026 !illegalPattern \u0026\u0026 matchCount \u003d\u003d 0) {\n            logMessage(0);\n        }\n        else if (foundMatch) {\n            final FileText text \u003d getFileContents().getText();\n            final LineColumn start \u003d text.lineColumn(matcher.start());\n            final LineColumn end;\n            if (matcher.end() \u003d\u003d 0) {\n                end \u003d text.lineColumn(0);\n            }\n            else {\n                end \u003d text.lineColumn(matcher.end() - 1);\n            }\n            startLine \u003d start.getLine();\n            startColumn \u003d start.getColumn();\n            endLine \u003d end.getLine();\n            endColumn \u003d end.getColumn();\n            if (ignoreComments) {\n                final FileContents theFileContents \u003d getFileContents();\n                ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                    startColumn, endLine, endColumn);\n            }\n            if (!ignore) {\n                matchCount++;\n                if (illegalPattern || checkForDuplicates\n                        \u0026\u0026 matchCount - 1 \u003e duplicateLimit) {\n                    errorCount++;\n                    logMessage(startLine);\n                }\n            }\n            if (errorCount \u003c errorLimit\n                    \u0026\u0026 (ignore || illegalPattern || checkForDuplicates)) {\n                findMatch();\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java",
      "extendedDetails": {}
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": "10/03/15 2:36 PM",
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "20/02/15 5:02 AM",
      "commitNameOld": "5ede09997c283b4c418f0f540848e006be04fa87",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 18.36,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n     private void findMatch()\n     {\n         int startLine;\n         int startColumn;\n         int endLine;\n         int endColumn;\n         boolean foundMatch;\n         boolean ignore \u003d false;\n \n         foundMatch \u003d matcher.find();\n-        if (!foundMatch \u0026\u0026 !illegalPattern \u0026\u0026 (matchCount \u003d\u003d 0)) {\n+        if (!foundMatch \u0026\u0026 !illegalPattern \u0026\u0026 matchCount \u003d\u003d 0) {\n             logMessage(0);\n         }\n         else if (foundMatch) {\n             final FileText text \u003d getFileContents().getText();\n             final LineColumn start \u003d text.lineColumn(matcher.start());\n             final LineColumn end \u003d text.lineColumn(matcher.end() - 1);\n             startLine \u003d start.getLine();\n             startColumn \u003d start.getColumn();\n             endLine \u003d end.getLine();\n             endColumn \u003d end.getColumn();\n             if (ignoreComments) {\n                 final FileContents theFileContents \u003d getFileContents();\n                 ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                     startColumn, endLine, endColumn);\n             }\n             if (!ignore) {\n                 matchCount++;\n-                if (illegalPattern || (checkForDuplicates\n-                        \u0026\u0026 ((matchCount - 1) \u003e duplicateLimit)))\n+                if (illegalPattern || checkForDuplicates\n+                        \u0026\u0026 matchCount - 1 \u003e duplicateLimit)\n                 {\n                     errorCount++;\n                     logMessage(startLine);\n                 }\n             }\n-            if ((errorCount \u003c errorLimit)\n+            if (errorCount \u003c errorLimit\n                     \u0026\u0026 (ignore || illegalPattern || checkForDuplicates))\n             {\n                 findMatch();\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void findMatch()\n    {\n        int startLine;\n        int startColumn;\n        int endLine;\n        int endColumn;\n        boolean foundMatch;\n        boolean ignore \u003d false;\n\n        foundMatch \u003d matcher.find();\n        if (!foundMatch \u0026\u0026 !illegalPattern \u0026\u0026 matchCount \u003d\u003d 0) {\n            logMessage(0);\n        }\n        else if (foundMatch) {\n            final FileText text \u003d getFileContents().getText();\n            final LineColumn start \u003d text.lineColumn(matcher.start());\n            final LineColumn end \u003d text.lineColumn(matcher.end() - 1);\n            startLine \u003d start.getLine();\n            startColumn \u003d start.getColumn();\n            endLine \u003d end.getLine();\n            endColumn \u003d end.getColumn();\n            if (ignoreComments) {\n                final FileContents theFileContents \u003d getFileContents();\n                ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                    startColumn, endLine, endColumn);\n            }\n            if (!ignore) {\n                matchCount++;\n                if (illegalPattern || checkForDuplicates\n                        \u0026\u0026 matchCount - 1 \u003e duplicateLimit)\n                {\n                    errorCount++;\n                    logMessage(startLine);\n                }\n            }\n            if (errorCount \u003c errorLimit\n                    \u0026\u0026 (ignore || illegalPattern || checkForDuplicates))\n            {\n                findMatch();\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java",
      "extendedDetails": {}
    },
    "58219b9bd31c8f7fbc4f4bba0eeb811851f276b3": {
      "type": "Ybodychange",
      "commitMessage": "Prefixes, checks, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java\n",
      "commitDate": "19/01/15 6:37 AM",
      "commitName": "58219b9bd31c8f7fbc4f4bba0eeb811851f276b3",
      "commitAuthor": "alexkravin",
      "commitDateOld": "02/11/14 9:36 PM",
      "commitNameOld": "1ca93bdf66b630e58d979ad2aa40f02e678db5cf",
      "commitAuthorOld": "Vladimir Sitnikov",
      "daysBetweenCommits": 77.38,
      "commitsBetweenForRepo": 251,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n     private void findMatch()\n     {\n         int startLine;\n         int startColumn;\n         int endLine;\n         int endColumn;\n         boolean foundMatch;\n         boolean ignore \u003d false;\n \n-        foundMatch \u003d mMatcher.find();\n-        if (!foundMatch \u0026\u0026 !mIllegalPattern \u0026\u0026 (mMatchCount \u003d\u003d 0)) {\n+        foundMatch \u003d matcher.find();\n+        if (!foundMatch \u0026\u0026 !illegalPattern \u0026\u0026 (matchCount \u003d\u003d 0)) {\n             logMessage(0);\n         }\n         else if (foundMatch) {\n             final FileText text \u003d getFileContents().getText();\n-            final LineColumn start \u003d text.lineColumn(mMatcher.start());\n-            final LineColumn end \u003d text.lineColumn(mMatcher.end() - 1);\n+            final LineColumn start \u003d text.lineColumn(matcher.start());\n+            final LineColumn end \u003d text.lineColumn(matcher.end() - 1);\n             startLine \u003d start.getLine();\n             startColumn \u003d start.getColumn();\n             endLine \u003d end.getLine();\n             endColumn \u003d end.getColumn();\n-            if (mIgnoreComments) {\n+            if (ignoreComments) {\n                 final FileContents theFileContents \u003d getFileContents();\n                 ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                     startColumn, endLine, endColumn);\n             }\n             if (!ignore) {\n-                mMatchCount++;\n-                if (mIllegalPattern || (mCheckForDuplicates\n-                        \u0026\u0026 ((mMatchCount - 1) \u003e mDuplicateLimit)))\n+                matchCount++;\n+                if (illegalPattern || (checkForDuplicates\n+                        \u0026\u0026 ((matchCount - 1) \u003e duplicateLimit)))\n                 {\n-                    mErrorCount++;\n+                    errorCount++;\n                     logMessage(startLine);\n                 }\n             }\n-            if ((mErrorCount \u003c mErrorLimit)\n-                    \u0026\u0026 (ignore || mIllegalPattern || mCheckForDuplicates))\n+            if ((errorCount \u003c errorLimit)\n+                    \u0026\u0026 (ignore || illegalPattern || checkForDuplicates))\n             {\n                 findMatch();\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void findMatch()\n    {\n        int startLine;\n        int startColumn;\n        int endLine;\n        int endColumn;\n        boolean foundMatch;\n        boolean ignore \u003d false;\n\n        foundMatch \u003d matcher.find();\n        if (!foundMatch \u0026\u0026 !illegalPattern \u0026\u0026 (matchCount \u003d\u003d 0)) {\n            logMessage(0);\n        }\n        else if (foundMatch) {\n            final FileText text \u003d getFileContents().getText();\n            final LineColumn start \u003d text.lineColumn(matcher.start());\n            final LineColumn end \u003d text.lineColumn(matcher.end() - 1);\n            startLine \u003d start.getLine();\n            startColumn \u003d start.getColumn();\n            endLine \u003d end.getLine();\n            endColumn \u003d end.getColumn();\n            if (ignoreComments) {\n                final FileContents theFileContents \u003d getFileContents();\n                ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                    startColumn, endLine, endColumn);\n            }\n            if (!ignore) {\n                matchCount++;\n                if (illegalPattern || (checkForDuplicates\n                        \u0026\u0026 ((matchCount - 1) \u003e duplicateLimit)))\n                {\n                    errorCount++;\n                    logMessage(startLine);\n                }\n            }\n            if ((errorCount \u003c errorLimit)\n                    \u0026\u0026 (ignore || illegalPattern || checkForDuplicates))\n            {\n                findMatch();\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java",
      "extendedDetails": {}
    },
    "1ca93bdf66b630e58d979ad2aa40f02e678db5cf": {
      "type": "Ybodychange",
      "commitMessage": "preformance fix for RegexpCheck\n",
      "commitDate": "02/11/14 9:36 PM",
      "commitName": "1ca93bdf66b630e58d979ad2aa40f02e678db5cf",
      "commitAuthor": "Vladimir Sitnikov",
      "commitDateOld": "04/03/14 9:18 AM",
      "commitNameOld": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthorOld": "Ivan Sopov",
      "daysBetweenCommits": 243.51,
      "commitsBetweenForRepo": 224,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,42 @@\n     private void findMatch()\n     {\n         int startLine;\n         int startColumn;\n         int endLine;\n         int endColumn;\n         boolean foundMatch;\n         boolean ignore \u003d false;\n \n         foundMatch \u003d mMatcher.find();\n         if (!foundMatch \u0026\u0026 !mIllegalPattern \u0026\u0026 (mMatchCount \u003d\u003d 0)) {\n             logMessage(0);\n         }\n         else if (foundMatch) {\n-            startLine \u003d (mCharacters.get(mMatcher.start()))[0].\n-                    intValue();\n-            startColumn \u003d (mCharacters.get(mMatcher.start()))[1].\n-                    intValue();\n-            endLine \u003d (mCharacters.get(mMatcher.end() - 1))[0].\n-                    intValue();\n-            endColumn \u003d (mCharacters.get(mMatcher.end() - 1))[1].\n-                    intValue();\n+            final FileText text \u003d getFileContents().getText();\n+            final LineColumn start \u003d text.lineColumn(mMatcher.start());\n+            final LineColumn end \u003d text.lineColumn(mMatcher.end() - 1);\n+            startLine \u003d start.getLine();\n+            startColumn \u003d start.getColumn();\n+            endLine \u003d end.getLine();\n+            endColumn \u003d end.getColumn();\n             if (mIgnoreComments) {\n                 final FileContents theFileContents \u003d getFileContents();\n                 ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                     startColumn, endLine, endColumn);\n             }\n             if (!ignore) {\n                 mMatchCount++;\n                 if (mIllegalPattern || (mCheckForDuplicates\n                         \u0026\u0026 ((mMatchCount - 1) \u003e mDuplicateLimit)))\n                 {\n                     mErrorCount++;\n                     logMessage(startLine);\n                 }\n             }\n             if ((mErrorCount \u003c mErrorLimit)\n                     \u0026\u0026 (ignore || mIllegalPattern || mCheckForDuplicates))\n             {\n                 findMatch();\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void findMatch()\n    {\n        int startLine;\n        int startColumn;\n        int endLine;\n        int endColumn;\n        boolean foundMatch;\n        boolean ignore \u003d false;\n\n        foundMatch \u003d mMatcher.find();\n        if (!foundMatch \u0026\u0026 !mIllegalPattern \u0026\u0026 (mMatchCount \u003d\u003d 0)) {\n            logMessage(0);\n        }\n        else if (foundMatch) {\n            final FileText text \u003d getFileContents().getText();\n            final LineColumn start \u003d text.lineColumn(mMatcher.start());\n            final LineColumn end \u003d text.lineColumn(mMatcher.end() - 1);\n            startLine \u003d start.getLine();\n            startColumn \u003d start.getColumn();\n            endLine \u003d end.getLine();\n            endColumn \u003d end.getColumn();\n            if (mIgnoreComments) {\n                final FileContents theFileContents \u003d getFileContents();\n                ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                    startColumn, endLine, endColumn);\n            }\n            if (!ignore) {\n                mMatchCount++;\n                if (mIllegalPattern || (mCheckForDuplicates\n                        \u0026\u0026 ((mMatchCount - 1) \u003e mDuplicateLimit)))\n                {\n                    mErrorCount++;\n                    logMessage(startLine);\n                }\n            }\n            if ((mErrorCount \u003c mErrorLimit)\n                    \u0026\u0026 (ignore || mIllegalPattern || mCheckForDuplicates))\n            {\n                findMatch();\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java",
      "extendedDetails": {}
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": "04/03/14 9:18 AM",
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": "26/02/14 10:35 PM",
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void findMatch()\n    {\n        int startLine;\n        int startColumn;\n        int endLine;\n        int endColumn;\n        boolean foundMatch;\n        boolean ignore \u003d false;\n\n        foundMatch \u003d mMatcher.find();\n        if (!foundMatch \u0026\u0026 !mIllegalPattern \u0026\u0026 (mMatchCount \u003d\u003d 0)) {\n            logMessage(0);\n        }\n        else if (foundMatch) {\n            startLine \u003d (mCharacters.get(mMatcher.start()))[0].\n                    intValue();\n            startColumn \u003d (mCharacters.get(mMatcher.start()))[1].\n                    intValue();\n            endLine \u003d (mCharacters.get(mMatcher.end() - 1))[0].\n                    intValue();\n            endColumn \u003d (mCharacters.get(mMatcher.end() - 1))[1].\n                    intValue();\n            if (mIgnoreComments) {\n                final FileContents theFileContents \u003d getFileContents();\n                ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                    startColumn, endLine, endColumn);\n            }\n            if (!ignore) {\n                mMatchCount++;\n                if (mIllegalPattern || (mCheckForDuplicates\n                        \u0026\u0026 ((mMatchCount - 1) \u003e mDuplicateLimit)))\n                {\n                    mErrorCount++;\n                    logMessage(startLine);\n                }\n            }\n            if ((mErrorCount \u003c mErrorLimit)\n                    \u0026\u0026 (ignore || mIllegalPattern || mCheckForDuplicates))\n            {\n                findMatch();\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java",
      "extendedDetails": {
        "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java"
      }
    },
    "08638b5f739d9929698860048c052da2d5f80209": {
      "type": "Ybodychange",
      "commitMessage": "Start of adding generics.\n",
      "commitDate": "14/12/07 10:36 PM",
      "commitName": "08638b5f739d9929698860048c052da2d5f80209",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "27/01/07 6:51 AM",
      "commitNameOld": "1efc394250b8f1c79bd7f8344b738a7d13396ed3",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 321.66,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n     private void findMatch()\n     {\n         int startLine;\n         int startColumn;\n         int endLine;\n         int endColumn;\n         boolean foundMatch;\n         boolean ignore \u003d false;\n \n         foundMatch \u003d mMatcher.find();\n         if (!foundMatch \u0026\u0026 !mIllegalPattern \u0026\u0026 (mMatchCount \u003d\u003d 0)) {\n             logMessage(0);\n         }\n         else if (foundMatch) {\n-            startLine \u003d ((Integer[]) mCharacters.get(mMatcher.start()))[0].\n+            startLine \u003d (mCharacters.get(mMatcher.start()))[0].\n                     intValue();\n-            startColumn \u003d ((Integer[]) mCharacters.get(mMatcher.start()))[1].\n+            startColumn \u003d (mCharacters.get(mMatcher.start()))[1].\n                     intValue();\n-            endLine \u003d ((Integer[]) mCharacters.get(mMatcher.end() - 1))[0].\n+            endLine \u003d (mCharacters.get(mMatcher.end() - 1))[0].\n                     intValue();\n-            endColumn \u003d ((Integer[]) mCharacters.get(mMatcher.end() - 1))[1].\n+            endColumn \u003d (mCharacters.get(mMatcher.end() - 1))[1].\n                     intValue();\n             if (mIgnoreComments) {\n                 final FileContents theFileContents \u003d getFileContents();\n                 ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                     startColumn, endLine, endColumn);\n             }\n             if (!ignore) {\n                 mMatchCount++;\n                 if (mIllegalPattern || (mCheckForDuplicates\n                         \u0026\u0026 ((mMatchCount - 1) \u003e mDuplicateLimit)))\n                 {\n                     mErrorCount++;\n                     logMessage(startLine);\n                 }\n             }\n             if ((mErrorCount \u003c mErrorLimit)\n                     \u0026\u0026 (ignore || mIllegalPattern || mCheckForDuplicates))\n             {\n                 findMatch();\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void findMatch()\n    {\n        int startLine;\n        int startColumn;\n        int endLine;\n        int endColumn;\n        boolean foundMatch;\n        boolean ignore \u003d false;\n\n        foundMatch \u003d mMatcher.find();\n        if (!foundMatch \u0026\u0026 !mIllegalPattern \u0026\u0026 (mMatchCount \u003d\u003d 0)) {\n            logMessage(0);\n        }\n        else if (foundMatch) {\n            startLine \u003d (mCharacters.get(mMatcher.start()))[0].\n                    intValue();\n            startColumn \u003d (mCharacters.get(mMatcher.start()))[1].\n                    intValue();\n            endLine \u003d (mCharacters.get(mMatcher.end() - 1))[0].\n                    intValue();\n            endColumn \u003d (mCharacters.get(mMatcher.end() - 1))[1].\n                    intValue();\n            if (mIgnoreComments) {\n                final FileContents theFileContents \u003d getFileContents();\n                ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                    startColumn, endLine, endColumn);\n            }\n            if (!ignore) {\n                mMatchCount++;\n                if (mIllegalPattern || (mCheckForDuplicates\n                        \u0026\u0026 ((mMatchCount - 1) \u003e mDuplicateLimit)))\n                {\n                    mErrorCount++;\n                    logMessage(startLine);\n                }\n            }\n            if ((mErrorCount \u003c mErrorLimit)\n                    \u0026\u0026 (ignore || mIllegalPattern || mCheckForDuplicates))\n            {\n                findMatch();\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java",
      "extendedDetails": {}
    },
    "c2d3932843e70e4bb5df7161800aca248f9af778": {
      "type": "Ybodychange",
      "commitMessage": "Clean up the use of ()\u0027s\n",
      "commitDate": "06/07/06 8:26 PM",
      "commitName": "c2d3932843e70e4bb5df7161800aca248f9af778",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "17/06/06 7:18 AM",
      "commitNameOld": "81b52e27c5077f9a4f426d32b0e39a785052c715",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 19.55,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n     private void findMatch()\n     {\n         int startLine;\n         int startColumn;\n         int endLine;\n         int endColumn;\n         boolean foundMatch;\n         boolean ignore \u003d false;\n \n         foundMatch \u003d mMatcher.find();\n-        if (!foundMatch \u0026\u0026 !mIllegalPattern \u0026\u0026 mMatchCount \u003d\u003d 0) {\n+        if (!foundMatch \u0026\u0026 !mIllegalPattern \u0026\u0026 (mMatchCount \u003d\u003d 0)) {\n             logMessage(0);\n         }\n         else if (foundMatch) {\n             startLine \u003d ((Integer[]) mCharacters.get(mMatcher.start()))[0].\n                     intValue();\n             startColumn \u003d ((Integer[]) mCharacters.get(mMatcher.start()))[1].\n                     intValue();\n             endLine \u003d ((Integer[]) mCharacters.get(mMatcher.end() - 1))[0].\n                     intValue();\n             endColumn \u003d ((Integer[]) mCharacters.get(mMatcher.end() - 1))[1].\n                     intValue();\n             if (mIgnoreComments) {\n                 final FileContents theFileContents \u003d getFileContents();\n                 ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                     startColumn, endLine, endColumn);\n             }\n             if (!ignore) {\n                 mMatchCount++;\n                 if (mIllegalPattern || (mCheckForDuplicates\n                         \u0026\u0026 ((mMatchCount - 1) \u003e mDuplicateLimit)))\n                 {\n                     mErrorCount++;\n                     logMessage(startLine);\n                 }\n             }\n             if ((mErrorCount \u003c mErrorLimit)\n                     \u0026\u0026 (ignore || mIllegalPattern || mCheckForDuplicates))\n             {\n                 findMatch();\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void findMatch()\n    {\n        int startLine;\n        int startColumn;\n        int endLine;\n        int endColumn;\n        boolean foundMatch;\n        boolean ignore \u003d false;\n\n        foundMatch \u003d mMatcher.find();\n        if (!foundMatch \u0026\u0026 !mIllegalPattern \u0026\u0026 (mMatchCount \u003d\u003d 0)) {\n            logMessage(0);\n        }\n        else if (foundMatch) {\n            startLine \u003d ((Integer[]) mCharacters.get(mMatcher.start()))[0].\n                    intValue();\n            startColumn \u003d ((Integer[]) mCharacters.get(mMatcher.start()))[1].\n                    intValue();\n            endLine \u003d ((Integer[]) mCharacters.get(mMatcher.end() - 1))[0].\n                    intValue();\n            endColumn \u003d ((Integer[]) mCharacters.get(mMatcher.end() - 1))[1].\n                    intValue();\n            if (mIgnoreComments) {\n                final FileContents theFileContents \u003d getFileContents();\n                ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                    startColumn, endLine, endColumn);\n            }\n            if (!ignore) {\n                mMatchCount++;\n                if (mIllegalPattern || (mCheckForDuplicates\n                        \u0026\u0026 ((mMatchCount - 1) \u003e mDuplicateLimit)))\n                {\n                    mErrorCount++;\n                    logMessage(startLine);\n                }\n            }\n            if ((mErrorCount \u003c mErrorLimit)\n                    \u0026\u0026 (ignore || mIllegalPattern || mCheckForDuplicates))\n            {\n                findMatch();\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java",
      "extendedDetails": {}
    },
    "ab1e3089135d74b0d8c3296d0074244ca89a55e2": {
      "type": "Yintroduced",
      "commitMessage": "Incorporate excellent patch [ 1344344 ] Consolidation of regexp checks.\n",
      "commitDate": "06/11/05 3:54 AM",
      "commitName": "ab1e3089135d74b0d8c3296d0074244ca89a55e2",
      "commitAuthor": "Oliver Burn",
      "diff": "@@ -0,0 +1,43 @@\n+    private void findMatch()\n+    {\n+        int startLine;\n+        int startColumn;\n+        int endLine;\n+        int endColumn;\n+        boolean foundMatch;\n+        boolean ignore \u003d false;\n+\n+        foundMatch \u003d mMatcher.find();\n+        if (!foundMatch \u0026\u0026 !mIllegalPattern \u0026\u0026 mMatchCount \u003d\u003d 0) {\n+            logMessage(0);\n+        }\n+        else if (foundMatch) {\n+            startLine \u003d ((Integer[]) mCharacters.get(mMatcher.start()))[0].\n+                    intValue();\n+            startColumn \u003d ((Integer[]) mCharacters.get(mMatcher.start()))[1].\n+                    intValue();\n+            endLine \u003d ((Integer[]) mCharacters.get(mMatcher.end() - 1))[0].\n+                    intValue();\n+            endColumn \u003d ((Integer[]) mCharacters.get(mMatcher.end() - 1))[1].\n+                    intValue();\n+            if (mIgnoreComments) {\n+                final FileContents theFileContents \u003d getFileContents();\n+                ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n+                    startColumn, endLine, endColumn);\n+            }\n+            if (!ignore) {\n+                mMatchCount++;\n+                if (mIllegalPattern || (mCheckForDuplicates\n+                        \u0026\u0026 ((mMatchCount - 1) \u003e mDuplicateLimit)))\n+                {\n+                    mErrorCount++;\n+                    logMessage(startLine);\n+                }\n+            }\n+            if ((mErrorCount \u003c mErrorLimit)\n+                    \u0026\u0026 (ignore || mIllegalPattern || mCheckForDuplicates))\n+            {\n+                findMatch();\n+            }\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void findMatch()\n    {\n        int startLine;\n        int startColumn;\n        int endLine;\n        int endColumn;\n        boolean foundMatch;\n        boolean ignore \u003d false;\n\n        foundMatch \u003d mMatcher.find();\n        if (!foundMatch \u0026\u0026 !mIllegalPattern \u0026\u0026 mMatchCount \u003d\u003d 0) {\n            logMessage(0);\n        }\n        else if (foundMatch) {\n            startLine \u003d ((Integer[]) mCharacters.get(mMatcher.start()))[0].\n                    intValue();\n            startColumn \u003d ((Integer[]) mCharacters.get(mMatcher.start()))[1].\n                    intValue();\n            endLine \u003d ((Integer[]) mCharacters.get(mMatcher.end() - 1))[0].\n                    intValue();\n            endColumn \u003d ((Integer[]) mCharacters.get(mMatcher.end() - 1))[1].\n                    intValue();\n            if (mIgnoreComments) {\n                final FileContents theFileContents \u003d getFileContents();\n                ignore \u003d theFileContents.hasIntersectionWithComment(startLine,\n                    startColumn, endLine, endColumn);\n            }\n            if (!ignore) {\n                mMatchCount++;\n                if (mIllegalPattern || (mCheckForDuplicates\n                        \u0026\u0026 ((mMatchCount - 1) \u003e mDuplicateLimit)))\n                {\n                    mErrorCount++;\n                    logMessage(startLine);\n                }\n            }\n            if ((mErrorCount \u003c mErrorLimit)\n                    \u0026\u0026 (ignore || mIllegalPattern || mCheckForDuplicates))\n            {\n                findMatch();\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/RegexpCheck.java"
    }
  }
}