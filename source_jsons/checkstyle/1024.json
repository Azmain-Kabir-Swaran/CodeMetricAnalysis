{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TrailingCommentCheck.java",
  "functionName": "beginTree",
  "functionId": "beginTree___rootAST-DetailAST",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
  "functionStartLine": 177,
  "functionEndLine": 211,
  "numCommitsSeen": 79,
  "timeTaken": 3796,
  "changeHistory": [
    "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8",
    "7609e96cc998cca40b396eb3f2d7ae82f60fcce1",
    "6e8d1e06728b7defbd734253b3818a33676b62bc",
    "a963f8a21bd47624ec9f1eea72c9326e2ca01c8a",
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
    "0d8e93ce79ea33b72b3e904d8796984271ee3d8d",
    "ee0bcb28310c8b8ba24004e824a9051c89a54e97",
    "5a46bdbeeadb368fba5c78c6c3bfc772a579a86a",
    "603c5bb53ea12900f6a1c8af0c4a765af36786e3",
    "084809c3b9e0d039c818cc4d8c5e640ea9e26525",
    "8a3f5bf6d5389b9e175c9c769992faece6d76ada",
    "0a6026c9ab97dc2d5ecd9c8cc6a27197208f4e6a",
    "688d428e557d36897b6171bce17a5a031de00a90",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "5ede09997c283b4c418f0f540848e006be04fa87",
    "58219b9bd31c8f7fbc4f4bba0eeb811851f276b3",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "7552a0b72e07c9a0070e84789b5abe6d293de6e0",
    "e50e1fcd1c17ba1f73d11df38382907cc163a1d1",
    "262209477f39964a63103613f3e2c985da083371",
    "c2d3932843e70e4bb5df7161800aca248f9af778",
    "ea4085cd15fefe1e70a495798187c425295c74b6",
    "e27489c7721909245ea5055eac3b9c7c659081f6",
    "5d7063c660b241bce251f1a8c89394619f2791fb",
    "7f103f3760306b1b4c26ca5508972bc232672ad9",
    "803dafc96a33bd987f84d930b9ae3ebf7a23e097"
  ],
  "changeHistoryShort": {
    "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8": "Ybodychange",
    "7609e96cc998cca40b396eb3f2d7ae82f60fcce1": "Ybodychange",
    "6e8d1e06728b7defbd734253b3818a33676b62bc": "Ybodychange",
    "a963f8a21bd47624ec9f1eea72c9326e2ca01c8a": "Ybodychange",
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020": "Ybodychange",
    "0d8e93ce79ea33b72b3e904d8796984271ee3d8d": "Ybodychange",
    "ee0bcb28310c8b8ba24004e824a9051c89a54e97": "Ybodychange",
    "5a46bdbeeadb368fba5c78c6c3bfc772a579a86a": "Ybodychange",
    "603c5bb53ea12900f6a1c8af0c4a765af36786e3": "Ybodychange",
    "084809c3b9e0d039c818cc4d8c5e640ea9e26525": "Ybodychange",
    "8a3f5bf6d5389b9e175c9c769992faece6d76ada": "Ybodychange",
    "0a6026c9ab97dc2d5ecd9c8cc6a27197208f4e6a": "Ybodychange",
    "688d428e557d36897b6171bce17a5a031de00a90": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "5ede09997c283b4c418f0f540848e006be04fa87": "Ybodychange",
    "58219b9bd31c8f7fbc4f4bba0eeb811851f276b3": "Yparameterchange",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "7552a0b72e07c9a0070e84789b5abe6d293de6e0": "Ybodychange",
    "e50e1fcd1c17ba1f73d11df38382907cc163a1d1": "Ybodychange",
    "262209477f39964a63103613f3e2c985da083371": "Ybodychange",
    "c2d3932843e70e4bb5df7161800aca248f9af778": "Ybodychange",
    "ea4085cd15fefe1e70a495798187c425295c74b6": "Ybodychange",
    "e27489c7721909245ea5055eac3b9c7c659081f6": "Ybodychange",
    "5d7063c660b241bce251f1a8c89394619f2791fb": "Ybodychange",
    "7f103f3760306b1b4c26ca5508972bc232672ad9": "Ybodychange",
    "803dafc96a33bd987f84d930b9ae3ebf7a23e097": "Yintroduced"
  },
  "changeHistoryDetails": {
    "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8": {
      "type": "Ybodychange",
      "commitMessage": "Issue #5812: Rename all utility classes to xxxxUtil\n",
      "commitDate": "03/06/18 9:40 PM",
      "commitName": "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8",
      "commitAuthor": "Pavel Bludov",
      "commitDateOld": "18/04/18 1:06 PM",
      "commitNameOld": "6893affeac7285afd16f8a389c7d65023d0c327a",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 46.36,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n     public void beginTree(DetailAST rootAST) {\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getSingleLineComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getBlockComments();\n         final Set\u003cInteger\u003e lines \u003d new HashSet\u003c\u003e();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo - 1];\n             final String lineBefore;\n             final TextBlock comment;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n \n                 // do not check comment which doesn\u0027t end line\n                 if (comment.getText().length \u003d\u003d 1\n-                        \u0026\u0026 !CommonUtils.isBlank(line\n+                        \u0026\u0026 !CommonUtil.isBlank(line\n                             .substring(comment.getEndColNo() + 1))) {\n                     continue;\n                 }\n             }\n             if (!format.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n                 log(lineNo, MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getSingleLineComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getBlockComments();\n        final Set\u003cInteger\u003e lines \u003d new HashSet\u003c\u003e();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo - 1];\n            final String lineBefore;\n            final TextBlock comment;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n\n                // do not check comment which doesn\u0027t end line\n                if (comment.getText().length \u003d\u003d 1\n                        \u0026\u0026 !CommonUtil.isBlank(line\n                            .substring(comment.getEndColNo() + 1))) {\n                    continue;\n                }\n            }\n            if (!format.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo, MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "7609e96cc998cca40b396eb3f2d7ae82f60fcce1": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4342: Applied requested changes\n",
      "commitDate": "18/05/17 12:43 PM",
      "commitName": "7609e96cc998cca40b396eb3f2d7ae82f60fcce1",
      "commitAuthor": "Dmytro Kytsmen",
      "commitDateOld": "23/04/17 12:27 PM",
      "commitNameOld": "a18300c56e6359ef376d788b264fd47fe6e73fc6",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 25.01,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,35 @@\n     public void beginTree(DetailAST rootAST) {\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getSingleLineComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getBlockComments();\n         final Set\u003cInteger\u003e lines \u003d new HashSet\u003c\u003e();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo - 1];\n             final String lineBefore;\n             final TextBlock comment;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n \n                 // do not check comment which doesn\u0027t end line\n                 if (comment.getText().length \u003d\u003d 1\n-                        \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n+                        \u0026\u0026 !CommonUtils.isBlank(line\n+                            .substring(comment.getEndColNo() + 1))) {\n                     continue;\n                 }\n             }\n             if (!format.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n                 log(lineNo, MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getSingleLineComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getBlockComments();\n        final Set\u003cInteger\u003e lines \u003d new HashSet\u003c\u003e();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo - 1];\n            final String lineBefore;\n            final TextBlock comment;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n\n                // do not check comment which doesn\u0027t end line\n                if (comment.getText().length \u003d\u003d 1\n                        \u0026\u0026 !CommonUtils.isBlank(line\n                            .substring(comment.getEndColNo() + 1))) {\n                    continue;\n                }\n            }\n            if (!format.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo, MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "6e8d1e06728b7defbd734253b3818a33676b62bc": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3721: enforced no abbreviations in checkstyle",
      "commitDate": "17/02/17 2:04 PM",
      "commitName": "6e8d1e06728b7defbd734253b3818a33676b62bc",
      "commitAuthor": "rnveach",
      "commitDateOld": "27/01/17 6:31 AM",
      "commitNameOld": "b4a337a599e853cdc44b19a76da28fcfab2956cd",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 21.31,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n     public void beginTree(DetailAST rootAST) {\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n-                .getCppComments();\n+                .getSingleLineComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n-                .getCComments();\n+                .getBlockComments();\n         final Set\u003cInteger\u003e lines \u003d new HashSet\u003c\u003e();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo - 1];\n             final String lineBefore;\n             final TextBlock comment;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n \n                 // do not check comment which doesn\u0027t end line\n                 if (comment.getText().length \u003d\u003d 1\n                         \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                     continue;\n                 }\n             }\n             if (!format.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n                 log(lineNo, MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getSingleLineComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getBlockComments();\n        final Set\u003cInteger\u003e lines \u003d new HashSet\u003c\u003e();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo - 1];\n            final String lineBefore;\n            final TextBlock comment;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n\n                // do not check comment which doesn\u0027t end line\n                if (comment.getText().length \u003d\u003d 1\n                        \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                    continue;\n                }\n            }\n            if (!format.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo, MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "a963f8a21bd47624ec9f1eea72c9326e2ca01c8a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3255: removed unnecessary string fields for patterns",
      "commitDate": "10/11/16 10:34 AM",
      "commitName": "a963f8a21bd47624ec9f1eea72c9326e2ca01c8a",
      "commitAuthor": "rnveach",
      "commitDateOld": "09/11/16 4:34 AM",
      "commitNameOld": "8888fa5919dc31c6abe07ddc2f5fe0e29f66ef37",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 1.25,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n     public void beginTree(DetailAST rootAST) {\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d new HashSet\u003c\u003e();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo - 1];\n             final String lineBefore;\n             final TextBlock comment;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n \n                 // do not check comment which doesn\u0027t end line\n                 if (comment.getText().length \u003d\u003d 1\n                         \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                     continue;\n                 }\n             }\n-            if (!regexp.matcher(lineBefore).find()\n+            if (!format.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n                 log(lineNo, MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d new HashSet\u003c\u003e();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo - 1];\n            final String lineBefore;\n            final TextBlock comment;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n\n                // do not check comment which doesn\u0027t end line\n                if (comment.getText().length \u003d\u003d 1\n                        \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                    continue;\n                }\n            }\n            if (!format.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo, MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3433: Cut down on Checkstyle\u0027s dependencies on Guava (part 2) (#3454)\n\n",
      "commitDate": "20/09/16 7:52 PM",
      "commitName": "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": "16/07/16 10:34 PM",
      "commitNameOld": "4674e599d9342b98859f5d30f5da45db2ae38c51",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 65.89,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n     public void beginTree(DetailAST rootAST) {\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n-        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n+        final Set\u003cInteger\u003e lines \u003d new HashSet\u003c\u003e();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo - 1];\n             final String lineBefore;\n             final TextBlock comment;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n \n                 // do not check comment which doesn\u0027t end line\n                 if (comment.getText().length \u003d\u003d 1\n                         \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                     continue;\n                 }\n             }\n             if (!regexp.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n                 log(lineNo, MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d new HashSet\u003c\u003e();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo - 1];\n            final String lineBefore;\n            final TextBlock comment;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n\n                // do not check comment which doesn\u0027t end line\n                if (comment.getText().length \u003d\u003d 1\n                        \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                    continue;\n                }\n            }\n            if (!regexp.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo, MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "0d8e93ce79ea33b72b3e904d8796984271ee3d8d": {
      "type": "Ybodychange",
      "commitMessage": "minor: enforce FinalLocalVariableCheck on checkstyle code\n",
      "commitDate": "24/01/16 6:35 AM",
      "commitName": "0d8e93ce79ea33b72b3e904d8796984271ee3d8d",
      "commitAuthor": "Bhavik Patel",
      "commitDateOld": "04/01/16 4:25 PM",
      "commitNameOld": "617ebf2bf27d284dcc7b866f85439fcf6dab3402",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 19.59,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n     public void beginTree(DetailAST rootAST) {\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo - 1];\n-            String lineBefore;\n-            TextBlock comment;\n+            final String lineBefore;\n+            final TextBlock comment;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n \n                 // do not check comment which doesn\u0027t end line\n                 if (comment.getText().length \u003d\u003d 1\n                         \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                     continue;\n                 }\n             }\n             if (!regexp.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n                 log(lineNo, MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo - 1];\n            final String lineBefore;\n            final TextBlock comment;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n\n                // do not check comment which doesn\u0027t end line\n                if (comment.getText().length \u003d\u003d 1\n                        \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                    continue;\n                }\n            }\n            if (!regexp.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo, MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "ee0bcb28310c8b8ba24004e824a9051c89a54e97": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2451: removed excess hierarchy from TrailingCommentCheck",
      "commitDate": "30/10/15 5:43 AM",
      "commitName": "ee0bcb28310c8b8ba24004e824a9051c89a54e97",
      "commitAuthor": "rnveach",
      "commitDateOld": "31/08/15 9:11 PM",
      "commitNameOld": "5a46bdbeeadb368fba5c78c6c3bfc772a579a86a",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 59.36,
      "commitsBetweenForRepo": 393,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,34 @@\n     public void beginTree(DetailAST rootAST) {\n-        final Pattern blankLinePattern \u003d getRegexp();\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo - 1];\n             String lineBefore;\n             TextBlock comment;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n \n                 // do not check comment which doesn\u0027t end line\n                 if (comment.getText().length \u003d\u003d 1\n                         \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                     continue;\n                 }\n             }\n-            if (!blankLinePattern.matcher(lineBefore).find()\n+            if (!regexp.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n                 log(lineNo, MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo - 1];\n            String lineBefore;\n            TextBlock comment;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n\n                // do not check comment which doesn\u0027t end line\n                if (comment.getText().length \u003d\u003d 1\n                        \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                    continue;\n                }\n            }\n            if (!regexp.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo, MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "5a46bdbeeadb368fba5c78c6c3bfc772a579a86a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1555: Remove unnecessary unboxing\n\nFixes `UnnecessaryUnboxing` inspection violations.\n\nDescription:\n\u003eReports \"unboxing\", e.g. explicit unwrapping of wrapped primitive values. Unboxing is unnecessary under Java 5 and newer, and can be safely removed.\nThis inspection only reports if the project or module is configured to use a language level of 5.0 or higher.\n",
      "commitDate": "31/08/15 9:11 PM",
      "commitName": "5a46bdbeeadb368fba5c78c6c3bfc772a579a86a",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "31/08/15 11:51 AM",
      "commitNameOld": "c899af31c112c07ea1244f6bbe2c5c6c56818ae5",
      "commitAuthorOld": "Ruslan Diachenko",
      "daysBetweenCommits": 0.39,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n     public void beginTree(DetailAST rootAST) {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo - 1];\n             String lineBefore;\n             TextBlock comment;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n \n                 // do not check comment which doesn\u0027t end line\n                 if (comment.getText().length \u003d\u003d 1\n                         \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                     continue;\n                 }\n             }\n             if (!blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n-                log(lineNo.intValue(), MSG_KEY);\n+                log(lineNo, MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo - 1];\n            String lineBefore;\n            TextBlock comment;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n\n                // do not check comment which doesn\u0027t end line\n                if (comment.getText().length \u003d\u003d 1\n                        \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                    continue;\n                }\n            }\n            if (!blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo, MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "603c5bb53ea12900f6a1c8af0c4a765af36786e3": {
      "type": "Ybodychange",
      "commitMessage": "Issue #46: Statements shouldn\u0027t be nested too deep\n",
      "commitDate": "29/08/15 10:46 PM",
      "commitName": "603c5bb53ea12900f6a1c8af0c4a765af36786e3",
      "commitAuthor": "Ilja Dubinin",
      "commitDateOld": "27/08/15 5:25 AM",
      "commitNameOld": "fb0f73fc9c382d9279d573bfc3779b872f795aac",
      "commitAuthorOld": "Ruslan Diachenko",
      "daysBetweenCommits": 2.72,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,35 @@\n     public void beginTree(DetailAST rootAST) {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo - 1];\n             String lineBefore;\n             TextBlock comment;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n-                if (comment.getText().length \u003d\u003d 1) {\n-                    final String lineAfter \u003d\n-                        line.substring(comment.getEndColNo() + 1).trim();\n-                    if (!lineAfter.isEmpty()) {\n-                        // do not check comment which doesn\u0027t end line\n-                        continue;\n-                    }\n+\n+                // do not check comment which doesn\u0027t end line\n+                if (comment.getText().length \u003d\u003d 1\n+                        \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n+                    continue;\n                 }\n             }\n             if (!blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n                 log(lineNo.intValue(), MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo - 1];\n            String lineBefore;\n            TextBlock comment;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n\n                // do not check comment which doesn\u0027t end line\n                if (comment.getText().length \u003d\u003d 1\n                        \u0026\u0026 !line.substring(comment.getEndColNo() + 1).trim().isEmpty()) {\n                    continue;\n                }\n            }\n            if (!blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo.intValue(), MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "084809c3b9e0d039c818cc4d8c5e640ea9e26525": {
      "type": "Ybodychange",
      "commitMessage": "Simplify empty string check. #1555\n\nFixes `Simplify empty string check` inspection violations.\n\nDescription:\n\u003eReports .equals() being called to compare a String with an empty string. It is normally more performant to test a String for emptiness by comparing its .length() to zero instead.\n",
      "commitDate": "07/08/15 10:11 PM",
      "commitName": "084809c3b9e0d039c818cc4d8c5e640ea9e26525",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "07/08/15 9:12 PM",
      "commitNameOld": "8a3f5bf6d5389b9e175c9c769992faece6d76ada",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n     public void beginTree(DetailAST rootAST) {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo - 1];\n             String lineBefore;\n             TextBlock comment;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n-                    if (!\"\".equals(lineAfter)) {\n+                    if (!lineAfter.isEmpty()) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n             if (!blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n                 log(lineNo.intValue(), MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo - 1];\n            String lineBefore;\n            TextBlock comment;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!lineAfter.isEmpty()) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if (!blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo.intValue(), MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "8a3f5bf6d5389b9e175c9c769992faece6d76ada": {
      "type": "Ybodychange",
      "commitMessage": "Remove unused assignments. #1555\n\nFixes UnusedAssignment inspection violations.\n\nDescription:\n\u003eThis inspection points out the cases where a variable value is never used after its assignment, i.e.:\n- the variable never gets read after assignment OR\n- the value is always overwritten with another assignment before the next variable read OR\n - the variable initializer is redundant (for one of the above two reasons) OR\n - the variable is never used.\n",
      "commitDate": "07/08/15 9:12 PM",
      "commitName": "8a3f5bf6d5389b9e175c9c769992faece6d76ada",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "02/08/15 6:48 PM",
      "commitNameOld": "0a6026c9ab97dc2d5ecd9c8cc6a27197208f4e6a",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 5.1,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n     public void beginTree(DetailAST rootAST) {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo - 1];\n-            String lineBefore \u003d \"\";\n-            TextBlock comment \u003d null;\n+            String lineBefore;\n+            TextBlock comment;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n             if (!blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n                 log(lineNo.intValue(), MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo - 1];\n            String lineBefore;\n            TextBlock comment;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if (!blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo.intValue(), MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "0a6026c9ab97dc2d5ecd9c8cc6a27197208f4e6a": {
      "type": "Ybodychange",
      "commitMessage": "Remove unnecessary unboxing. #1538\n",
      "commitDate": "02/08/15 6:48 PM",
      "commitName": "0a6026c9ab97dc2d5ecd9c8cc6a27197208f4e6a",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "02/08/15 6:32 PM",
      "commitNameOld": "688d428e557d36897b6171bce17a5a031de00a90",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n     public void beginTree(DetailAST rootAST) {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n-            final String line \u003d getLines()[lineNo.intValue() - 1];\n+            final String line \u003d getLines()[lineNo - 1];\n             String lineBefore \u003d \"\";\n             TextBlock comment \u003d null;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n             if (!blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n                 log(lineNo.intValue(), MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo - 1];\n            String lineBefore \u003d \"\";\n            TextBlock comment \u003d null;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if (!blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo.intValue(), MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "688d428e557d36897b6171bce17a5a031de00a90": {
      "type": "Ybodychange",
      "commitMessage": "Coverage has been increased to 100% in TrailingCommentCheck. Issue 1290\n",
      "commitDate": "02/08/15 6:32 PM",
      "commitName": "688d428e557d36897b6171bce17a5a031de00a90",
      "commitAuthor": "Ilja Dubinin",
      "commitDateOld": "01/08/15 1:24 PM",
      "commitNameOld": "081c654df8d801f576506265681654a730cfc375",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 1.21,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,37 @@\n     public void beginTree(DetailAST rootAST) {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo.intValue() - 1];\n             String lineBefore \u003d \"\";\n             TextBlock comment \u003d null;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n-            else if (cComments.containsKey(lineNo)) {\n+            else {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n-            if (comment !\u003d null\n-                \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n+            if (!blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment)) {\n                 log(lineNo.intValue(), MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST) {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            TextBlock comment \u003d null;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if (!blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment)) {\n                log(lineNo.intValue(), MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": "10/03/15 2:36 PM",
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "20/02/15 5:02 AM",
      "commitNameOld": "5ede09997c283b4c418f0f540848e006be04fa87",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 18.36,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n     public void beginTree(DetailAST rootAST)\n     {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo.intValue() - 1];\n             String lineBefore \u003d \"\";\n             TextBlock comment \u003d null;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else if (cComments.containsKey(lineNo)) {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n-            if ((comment !\u003d null)\n+            if (comment !\u003d null\n                 \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment))\n             {\n                 log(lineNo.intValue(), MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST)\n    {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            TextBlock comment \u003d null;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if (comment !\u003d null\n                \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment))\n            {\n                log(lineNo.intValue(), MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "5ede09997c283b4c418f0f540848e006be04fa87": {
      "type": "Ybodychange",
      "commitMessage": "Refactored UTs, checks package, issue #537\n",
      "commitDate": "20/02/15 5:02 AM",
      "commitName": "5ede09997c283b4c418f0f540848e006be04fa87",
      "commitAuthor": "alexkravin",
      "commitDateOld": "18/02/15 1:14 PM",
      "commitNameOld": "c9a9e6508c15e00cf6820b213d79d5ebf41c6343",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n     public void beginTree(DetailAST rootAST)\n     {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo.intValue() - 1];\n             String lineBefore \u003d \"\";\n             TextBlock comment \u003d null;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else if (cComments.containsKey(lineNo)) {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n             if ((comment !\u003d null)\n                 \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment))\n             {\n-                log(lineNo.intValue(), \"trailing.comments\");\n+                log(lineNo.intValue(), MSG_KEY);\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST)\n    {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            TextBlock comment \u003d null;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if ((comment !\u003d null)\n                \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment))\n            {\n                log(lineNo.intValue(), MSG_KEY);\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "58219b9bd31c8f7fbc4f4bba0eeb811851f276b3": {
      "type": "Yparameterchange",
      "commitMessage": "Prefixes, checks, #512\n\nConflicts:\n\tsrc/main/java/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java\n",
      "commitDate": "19/01/15 6:37 AM",
      "commitName": "58219b9bd31c8f7fbc4f4bba0eeb811851f276b3",
      "commitAuthor": "alexkravin",
      "commitDateOld": "07/09/14 6:39 PM",
      "commitNameOld": "465efcd6e07314f81381551c338a50aede5d6626",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 133.54,
      "commitsBetweenForRepo": 361,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n-    public void beginTree(DetailAST aRootAST)\n+    public void beginTree(DetailAST rootAST)\n     {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo.intValue() - 1];\n             String lineBefore \u003d \"\";\n             TextBlock comment \u003d null;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else if (cComments.containsKey(lineNo)) {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n             if ((comment !\u003d null)\n                 \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment))\n             {\n                 log(lineNo.intValue(), \"trailing.comments\");\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST rootAST)\n    {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            TextBlock comment \u003d null;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if ((comment !\u003d null)\n                \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment))\n            {\n                log(lineNo.intValue(), \"trailing.comments\");\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {
        "oldValue": "[aRootAST-DetailAST]",
        "newValue": "[rootAST-DetailAST]"
      }
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": "04/03/14 9:18 AM",
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": "26/02/14 10:35 PM",
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void beginTree(DetailAST aRootAST)\n    {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            TextBlock comment \u003d null;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if ((comment !\u003d null)\n                \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment))\n            {\n                log(lineNo.intValue(), \"trailing.comments\");\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {
        "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java"
      }
    },
    "7552a0b72e07c9a0070e84789b5abe6d293de6e0": {
      "type": "Ybodychange",
      "commitMessage": "Drinking the \"Google Collections\" Kool-Aid.\n\nI like the reduced duplication.\n",
      "commitDate": "22/04/08 5:28 AM",
      "commitName": "7552a0b72e07c9a0070e84789b5abe6d293de6e0",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "13/01/08 11:42 PM",
      "commitNameOld": "fd90bd5aa5cd623b08a2e44ef05e8fac8045d333",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 99.2,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n     public void beginTree(DetailAST aRootAST)\n     {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n-        final Set\u003cInteger\u003e lines \u003d new HashSet\u003cInteger\u003e();\n+        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo.intValue() - 1];\n             String lineBefore \u003d \"\";\n             TextBlock comment \u003d null;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else if (cComments.containsKey(lineNo)) {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n             if ((comment !\u003d null)\n                 \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment))\n             {\n                 log(lineNo.intValue(), \"trailing.comments\");\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST aRootAST)\n    {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d Sets.newHashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            TextBlock comment \u003d null;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if ((comment !\u003d null)\n                \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment))\n            {\n                log(lineNo.intValue(), \"trailing.comments\");\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "e50e1fcd1c17ba1f73d11df38382907cc163a1d1": {
      "type": "Ybodychange",
      "commitMessage": "Use the new syntactic sugar \"for loop\".\n\nEnd of the cosmetic changes.\n",
      "commitDate": "15/12/07 2:28 AM",
      "commitName": "e50e1fcd1c17ba1f73d11df38382907cc163a1d1",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "14/12/07 9:40 PM",
      "commitNameOld": "262209477f39964a63103613f3e2c985da083371",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,40 @@\n     public void beginTree(DetailAST aRootAST)\n     {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                 .getCppComments();\n         final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                 .getCComments();\n         final Set\u003cInteger\u003e lines \u003d new HashSet\u003cInteger\u003e();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n-        final Iterator\u003cInteger\u003e linesIter \u003d lines.iterator();\n-        while (linesIter.hasNext()) {\n-            final Integer lineNo \u003d linesIter.next();\n-\n+        for (Integer lineNo : lines) {\n             final String line \u003d getLines()[lineNo.intValue() - 1];\n             String lineBefore \u003d \"\";\n             TextBlock comment \u003d null;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else if (cComments.containsKey(lineNo)) {\n                 final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                 comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n             if ((comment !\u003d null)\n                 \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment))\n             {\n                 log(lineNo.intValue(), \"trailing.comments\");\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST aRootAST)\n    {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d new HashSet\u003cInteger\u003e();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        for (Integer lineNo : lines) {\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            TextBlock comment \u003d null;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if ((comment !\u003d null)\n                \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment))\n            {\n                log(lineNo.intValue(), \"trailing.comments\");\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "262209477f39964a63103613f3e2c985da083371": {
      "type": "Ybodychange",
      "commitMessage": "Start of adding generics.\n",
      "commitDate": "14/12/07 9:40 PM",
      "commitName": "262209477f39964a63103613f3e2c985da083371",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "27/01/07 6:51 AM",
      "commitNameOld": "1efc394250b8f1c79bd7f8344b738a7d13396ed3",
      "commitAuthorOld": "Lars Khne",
      "daysBetweenCommits": 321.62,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,43 @@\n     public void beginTree(DetailAST aRootAST)\n     {\n         final Pattern blankLinePattern \u003d getRegexp();\n-        final Map cppComments \u003d getFileContents().getCppComments();\n-        final Map cComments \u003d getFileContents().getCComments();\n-        final Set lines \u003d new HashSet();\n+        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n+                .getCppComments();\n+        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n+                .getCComments();\n+        final Set\u003cInteger\u003e lines \u003d new HashSet\u003cInteger\u003e();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n-        final Iterator linesIter \u003d lines.iterator();\n+        final Iterator\u003cInteger\u003e linesIter \u003d lines.iterator();\n         while (linesIter.hasNext()) {\n-            final Integer lineNo \u003d (Integer) linesIter.next();\n+            final Integer lineNo \u003d linesIter.next();\n \n             final String line \u003d getLines()[lineNo.intValue() - 1];\n             String lineBefore \u003d \"\";\n             TextBlock comment \u003d null;\n             if (cppComments.containsKey(lineNo)) {\n-                comment \u003d (TextBlock) cppComments.get(lineNo);\n+                comment \u003d cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else if (cComments.containsKey(lineNo)) {\n-                final List commentList \u003d (List) cComments.get(lineNo);\n-                comment \u003d (TextBlock) commentList.get(commentList.size() - 1);\n+                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n+                comment \u003d commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n             if ((comment !\u003d null)\n                 \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment))\n             {\n                 log(lineNo.intValue(), \"trailing.comments\");\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST aRootAST)\n    {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map\u003cInteger, TextBlock\u003e cppComments \u003d getFileContents()\n                .getCppComments();\n        final Map\u003cInteger, List\u003cTextBlock\u003e\u003e cComments \u003d getFileContents()\n                .getCComments();\n        final Set\u003cInteger\u003e lines \u003d new HashSet\u003cInteger\u003e();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        final Iterator\u003cInteger\u003e linesIter \u003d lines.iterator();\n        while (linesIter.hasNext()) {\n            final Integer lineNo \u003d linesIter.next();\n\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            TextBlock comment \u003d null;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List\u003cTextBlock\u003e commentList \u003d cComments.get(lineNo);\n                comment \u003d commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if ((comment !\u003d null)\n                \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment))\n            {\n                log(lineNo.intValue(), \"trailing.comments\");\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "c2d3932843e70e4bb5df7161800aca248f9af778": {
      "type": "Ybodychange",
      "commitMessage": "Clean up the use of ()\u0027s\n",
      "commitDate": "06/07/06 8:26 PM",
      "commitName": "c2d3932843e70e4bb5df7161800aca248f9af778",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "25/12/05 8:13 AM",
      "commitNameOld": "ea4085cd15fefe1e70a495798187c425295c74b6",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 193.47,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,41 @@\n     public void beginTree(DetailAST aRootAST)\n     {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map cppComments \u003d getFileContents().getCppComments();\n         final Map cComments \u003d getFileContents().getCComments();\n         final Set lines \u003d new HashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         final Iterator linesIter \u003d lines.iterator();\n         while (linesIter.hasNext()) {\n             final Integer lineNo \u003d (Integer) linesIter.next();\n \n             final String line \u003d getLines()[lineNo.intValue() - 1];\n             String lineBefore \u003d \"\";\n             TextBlock comment \u003d null;\n             if (cppComments.containsKey(lineNo)) {\n                 comment \u003d (TextBlock) cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else if (cComments.containsKey(lineNo)) {\n                 final List commentList \u003d (List) cComments.get(lineNo);\n                 comment \u003d (TextBlock) commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n-            if (comment !\u003d null \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n+            if ((comment !\u003d null)\n+                \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                 \u0026\u0026 !isLegalComment(comment))\n             {\n                 log(lineNo.intValue(), \"trailing.comments\");\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST aRootAST)\n    {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map cppComments \u003d getFileContents().getCppComments();\n        final Map cComments \u003d getFileContents().getCComments();\n        final Set lines \u003d new HashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        final Iterator linesIter \u003d lines.iterator();\n        while (linesIter.hasNext()) {\n            final Integer lineNo \u003d (Integer) linesIter.next();\n\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            TextBlock comment \u003d null;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d (TextBlock) cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List commentList \u003d (List) cComments.get(lineNo);\n                comment \u003d (TextBlock) commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if ((comment !\u003d null)\n                \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment))\n            {\n                log(lineNo.intValue(), \"trailing.comments\");\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "ea4085cd15fefe1e70a495798187c425295c74b6": {
      "type": "Ybodychange",
      "commitMessage": "Fix for rfe 1248106 (TYPECAST is now accepted by NoWhitespaceAfter)\n\nFix for rfe 953266 (thanks to Paul Guyot (pguyot) for submitting patch)\nIllegalType can be configured to accept some abstract classes which\nmatches to regexp of illegal type names (property legalAbstractClassNames)\n\nTrailingComment now can be configured to accept some trailing comments\n(such as NOI18N) (property legalComment, rfe 1385344).\n",
      "commitDate": "25/12/05 8:13 AM",
      "commitName": "ea4085cd15fefe1e70a495798187c425295c74b6",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": "11/05/05 9:48 AM",
      "commitNameOld": "e27489c7721909245ea5055eac3b9c7c659081f6",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 227.98,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,40 @@\n     public void beginTree(DetailAST aRootAST)\n     {\n         final Pattern blankLinePattern \u003d getRegexp();\n         final Map cppComments \u003d getFileContents().getCppComments();\n         final Map cComments \u003d getFileContents().getCComments();\n         final Set lines \u003d new HashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         final Iterator linesIter \u003d lines.iterator();\n         while (linesIter.hasNext()) {\n             final Integer lineNo \u003d (Integer) linesIter.next();\n \n             final String line \u003d getLines()[lineNo.intValue() - 1];\n             String lineBefore \u003d \"\";\n+            TextBlock comment \u003d null;\n             if (cppComments.containsKey(lineNo)) {\n-                final TextBlock comment \u003d (TextBlock) cppComments.get(lineNo);\n+                comment \u003d (TextBlock) cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else if (cComments.containsKey(lineNo)) {\n                 final List commentList \u003d (List) cComments.get(lineNo);\n-                final TextBlock comment \u003d\n-                    (TextBlock) commentList.get(commentList.size() - 1);\n+                comment \u003d (TextBlock) commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n-            if (!blankLinePattern.matcher(lineBefore).find()) {\n+            if (comment !\u003d null \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n+                \u0026\u0026 !isLegalComment(comment))\n+            {\n                 log(lineNo.intValue(), \"trailing.comments\");\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST aRootAST)\n    {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map cppComments \u003d getFileContents().getCppComments();\n        final Map cComments \u003d getFileContents().getCComments();\n        final Set lines \u003d new HashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        final Iterator linesIter \u003d lines.iterator();\n        while (linesIter.hasNext()) {\n            final Integer lineNo \u003d (Integer) linesIter.next();\n\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            TextBlock comment \u003d null;\n            if (cppComments.containsKey(lineNo)) {\n                comment \u003d (TextBlock) cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List commentList \u003d (List) cComments.get(lineNo);\n                comment \u003d (TextBlock) commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if (comment !\u003d null \u0026\u0026 !blankLinePattern.matcher(lineBefore).find()\n                \u0026\u0026 !isLegalComment(comment))\n            {\n                log(lineNo.intValue(), \"trailing.comments\");\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "e27489c7721909245ea5055eac3b9c7c659081f6": {
      "type": "Ybodychange",
      "commitMessage": "initial replacing RE by Pattern (need to update docs)\n",
      "commitDate": "11/05/05 9:48 AM",
      "commitName": "e27489c7721909245ea5055eac3b9c7c659081f6",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": "09/01/05 2:50 AM",
      "commitNameOld": "0d887cde58e54d920644ee543dab346b93e8aae9",
      "commitAuthorOld": "Lars Khne",
      "daysBetweenCommits": 122.25,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n     public void beginTree(DetailAST aRootAST)\n     {\n-        final RE blankLinePattern \u003d getRegexp();\n+        final Pattern blankLinePattern \u003d getRegexp();\n         final Map cppComments \u003d getFileContents().getCppComments();\n         final Map cComments \u003d getFileContents().getCComments();\n         final Set lines \u003d new HashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         final Iterator linesIter \u003d lines.iterator();\n         while (linesIter.hasNext()) {\n             final Integer lineNo \u003d (Integer) linesIter.next();\n \n             final String line \u003d getLines()[lineNo.intValue() - 1];\n             String lineBefore \u003d \"\";\n             if (cppComments.containsKey(lineNo)) {\n                 final TextBlock comment \u003d (TextBlock) cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else if (cComments.containsKey(lineNo)) {\n                 final List commentList \u003d (List) cComments.get(lineNo);\n                 final TextBlock comment \u003d\n                     (TextBlock) commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n                     final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n-            if (!blankLinePattern.match(lineBefore)) {\n+            if (!blankLinePattern.matcher(lineBefore).find()) {\n                 log(lineNo.intValue(), \"trailing.comments\");\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST aRootAST)\n    {\n        final Pattern blankLinePattern \u003d getRegexp();\n        final Map cppComments \u003d getFileContents().getCppComments();\n        final Map cComments \u003d getFileContents().getCComments();\n        final Set lines \u003d new HashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        final Iterator linesIter \u003d lines.iterator();\n        while (linesIter.hasNext()) {\n            final Integer lineNo \u003d (Integer) linesIter.next();\n\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            if (cppComments.containsKey(lineNo)) {\n                final TextBlock comment \u003d (TextBlock) cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List commentList \u003d (List) cComments.get(lineNo);\n                final TextBlock comment \u003d\n                    (TextBlock) commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if (!blankLinePattern.matcher(lineBefore).find()) {\n                log(lineNo.intValue(), \"trailing.comments\");\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "5d7063c660b241bce251f1a8c89394619f2791fb": {
      "type": "Ybodychange",
      "commitMessage": "Tighten up code\n",
      "commitDate": "26/08/04 6:34 AM",
      "commitName": "5d7063c660b241bce251f1a8c89394619f2791fb",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "29/01/04 11:30 AM",
      "commitNameOld": "7f103f3760306b1b4c26ca5508972bc232672ad9",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 209.75,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n     public void beginTree(DetailAST aRootAST)\n     {\n         final RE blankLinePattern \u003d getRegexp();\n         final Map cppComments \u003d getFileContents().getCppComments();\n         final Map cComments \u003d getFileContents().getCComments();\n         final Set lines \u003d new HashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         final Iterator linesIter \u003d lines.iterator();\n         while (linesIter.hasNext()) {\n             final Integer lineNo \u003d (Integer) linesIter.next();\n \n             final String line \u003d getLines()[lineNo.intValue() - 1];\n             String lineBefore \u003d \"\";\n             if (cppComments.containsKey(lineNo)) {\n                 final TextBlock comment \u003d (TextBlock) cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else if (cComments.containsKey(lineNo)) {\n                 final List commentList \u003d (List) cComments.get(lineNo);\n                 final TextBlock comment \u003d\n                     (TextBlock) commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n-                    String lineAfter \u003d\n+                    final String lineAfter \u003d\n                         line.substring(comment.getEndColNo() + 1).trim();\n                     if (!\"\".equals(lineAfter)) {\n                         // do not check comment which doesn\u0027t end line\n                         continue;\n                     }\n                 }\n             }\n             if (!blankLinePattern.match(lineBefore)) {\n                 log(lineNo.intValue(), \"trailing.comments\");\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST aRootAST)\n    {\n        final RE blankLinePattern \u003d getRegexp();\n        final Map cppComments \u003d getFileContents().getCppComments();\n        final Map cComments \u003d getFileContents().getCComments();\n        final Set lines \u003d new HashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        final Iterator linesIter \u003d lines.iterator();\n        while (linesIter.hasNext()) {\n            final Integer lineNo \u003d (Integer) linesIter.next();\n\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            if (cppComments.containsKey(lineNo)) {\n                final TextBlock comment \u003d (TextBlock) cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List commentList \u003d (List) cComments.get(lineNo);\n                final TextBlock comment \u003d\n                    (TextBlock) commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    final String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if (!blankLinePattern.match(lineBefore)) {\n                log(lineNo.intValue(), \"trailing.comments\");\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "7f103f3760306b1b4c26ca5508972bc232672ad9": {
      "type": "Ybodychange",
      "commitMessage": "TrailingComment check, request 744970\n",
      "commitDate": "29/01/04 11:30 AM",
      "commitName": "7f103f3760306b1b4c26ca5508972bc232672ad9",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": "28/01/04 6:41 PM",
      "commitNameOld": "803dafc96a33bd987f84d930b9ae3ebf7a23e097",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 0.7,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,38 @@\n     public void beginTree(DetailAST aRootAST)\n     {\n         final RE blankLinePattern \u003d getRegexp();\n         final Map cppComments \u003d getFileContents().getCppComments();\n         final Map cComments \u003d getFileContents().getCComments();\n         final Set lines \u003d new HashSet();\n         lines.addAll(cppComments.keySet());\n         lines.addAll(cComments.keySet());\n \n         final Iterator linesIter \u003d lines.iterator();\n         while (linesIter.hasNext()) {\n             final Integer lineNo \u003d (Integer) linesIter.next();\n-            // I don\u0027t want handle several comments on one line :(\n-            // Perhaps I\u0027m wrong :)\n-            if (cppComments.containsKey(lineNo)\n-                \u0026\u0026 cComments.containsKey(lineNo)\n-                || cComments.containsKey(lineNo)\n-                \u0026\u0026 ((List) cComments.get(lineNo)).size() \u003e 1)\n-            {\n-                log(lineNo.intValue(), \"Too many comments.\");\n-                continue;\n-            }\n \n             final String line \u003d getLines()[lineNo.intValue() - 1];\n             String lineBefore \u003d \"\";\n-            String lineAfter \u003d \"\";\n             if (cppComments.containsKey(lineNo)) {\n                 final TextBlock comment \u003d (TextBlock) cppComments.get(lineNo);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n             }\n             else if (cComments.containsKey(lineNo)) {\n                 final List commentList \u003d (List) cComments.get(lineNo);\n                 final TextBlock comment \u003d\n-                    (TextBlock) commentList.iterator().next();\n+                    (TextBlock) commentList.get(commentList.size() - 1);\n                 lineBefore \u003d line.substring(0, comment.getStartColNo());\n                 if (comment.getText().length \u003d\u003d 1) {\n-                    lineAfter \u003d line.substring(comment.getEndColNo() + 1);\n+                    String lineAfter \u003d\n+                        line.substring(comment.getEndColNo() + 1).trim();\n+                    if (!\"\".equals(lineAfter)) {\n+                        // do not check comment which doesn\u0027t end line\n+                        continue;\n+                    }\n                 }\n             }\n-            lineAfter \u003d lineAfter.trim();\n-            if (!blankLinePattern.match(lineBefore) || !\"\".equals(lineAfter)) {\n+            if (!blankLinePattern.match(lineBefore)) {\n                 log(lineNo.intValue(), \"trailing.comments\");\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST aRootAST)\n    {\n        final RE blankLinePattern \u003d getRegexp();\n        final Map cppComments \u003d getFileContents().getCppComments();\n        final Map cComments \u003d getFileContents().getCComments();\n        final Set lines \u003d new HashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        final Iterator linesIter \u003d lines.iterator();\n        while (linesIter.hasNext()) {\n            final Integer lineNo \u003d (Integer) linesIter.next();\n\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            if (cppComments.containsKey(lineNo)) {\n                final TextBlock comment \u003d (TextBlock) cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List commentList \u003d (List) cComments.get(lineNo);\n                final TextBlock comment \u003d\n                    (TextBlock) commentList.get(commentList.size() - 1);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    String lineAfter \u003d\n                        line.substring(comment.getEndColNo() + 1).trim();\n                    if (!\"\".equals(lineAfter)) {\n                        // do not check comment which doesn\u0027t end line\n                        continue;\n                    }\n                }\n            }\n            if (!blankLinePattern.match(lineBefore)) {\n                log(lineNo.intValue(), \"trailing.comments\");\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java",
      "extendedDetails": {}
    },
    "803dafc96a33bd987f84d930b9ae3ebf7a23e097": {
      "type": "Yintroduced",
      "commitMessage": "Implemented 885993 (Wrap all comments into TextBlocks).\nDraft implementation for 744970 (Forbid endline comments)\n",
      "commitDate": "28/01/04 6:41 PM",
      "commitName": "803dafc96a33bd987f84d930b9ae3ebf7a23e097",
      "commitAuthor": "Oleg Sukhodolsky",
      "diff": "@@ -0,0 +1,45 @@\n+    public void beginTree(DetailAST aRootAST)\n+    {\n+        final RE blankLinePattern \u003d getRegexp();\n+        final Map cppComments \u003d getFileContents().getCppComments();\n+        final Map cComments \u003d getFileContents().getCComments();\n+        final Set lines \u003d new HashSet();\n+        lines.addAll(cppComments.keySet());\n+        lines.addAll(cComments.keySet());\n+\n+        final Iterator linesIter \u003d lines.iterator();\n+        while (linesIter.hasNext()) {\n+            final Integer lineNo \u003d (Integer) linesIter.next();\n+            // I don\u0027t want handle several comments on one line :(\n+            // Perhaps I\u0027m wrong :)\n+            if (cppComments.containsKey(lineNo)\n+                \u0026\u0026 cComments.containsKey(lineNo)\n+                || cComments.containsKey(lineNo)\n+                \u0026\u0026 ((List) cComments.get(lineNo)).size() \u003e 1)\n+            {\n+                log(lineNo.intValue(), \"Too many comments.\");\n+                continue;\n+            }\n+\n+            final String line \u003d getLines()[lineNo.intValue() - 1];\n+            String lineBefore \u003d \"\";\n+            String lineAfter \u003d \"\";\n+            if (cppComments.containsKey(lineNo)) {\n+                final TextBlock comment \u003d (TextBlock) cppComments.get(lineNo);\n+                lineBefore \u003d line.substring(0, comment.getStartColNo());\n+            }\n+            else if (cComments.containsKey(lineNo)) {\n+                final List commentList \u003d (List) cComments.get(lineNo);\n+                final TextBlock comment \u003d\n+                    (TextBlock) commentList.iterator().next();\n+                lineBefore \u003d line.substring(0, comment.getStartColNo());\n+                if (comment.getText().length \u003d\u003d 1) {\n+                    lineAfter \u003d line.substring(comment.getEndColNo() + 1);\n+                }\n+            }\n+            lineAfter \u003d lineAfter.trim();\n+            if (!blankLinePattern.match(lineBefore) || !\"\".equals(lineAfter)) {\n+                log(lineNo.intValue(), \"trailing.comments\");\n+            }\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void beginTree(DetailAST aRootAST)\n    {\n        final RE blankLinePattern \u003d getRegexp();\n        final Map cppComments \u003d getFileContents().getCppComments();\n        final Map cComments \u003d getFileContents().getCComments();\n        final Set lines \u003d new HashSet();\n        lines.addAll(cppComments.keySet());\n        lines.addAll(cComments.keySet());\n\n        final Iterator linesIter \u003d lines.iterator();\n        while (linesIter.hasNext()) {\n            final Integer lineNo \u003d (Integer) linesIter.next();\n            // I don\u0027t want handle several comments on one line :(\n            // Perhaps I\u0027m wrong :)\n            if (cppComments.containsKey(lineNo)\n                \u0026\u0026 cComments.containsKey(lineNo)\n                || cComments.containsKey(lineNo)\n                \u0026\u0026 ((List) cComments.get(lineNo)).size() \u003e 1)\n            {\n                log(lineNo.intValue(), \"Too many comments.\");\n                continue;\n            }\n\n            final String line \u003d getLines()[lineNo.intValue() - 1];\n            String lineBefore \u003d \"\";\n            String lineAfter \u003d \"\";\n            if (cppComments.containsKey(lineNo)) {\n                final TextBlock comment \u003d (TextBlock) cppComments.get(lineNo);\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n            }\n            else if (cComments.containsKey(lineNo)) {\n                final List commentList \u003d (List) cComments.get(lineNo);\n                final TextBlock comment \u003d\n                    (TextBlock) commentList.iterator().next();\n                lineBefore \u003d line.substring(0, comment.getStartColNo());\n                if (comment.getText().length \u003d\u003d 1) {\n                    lineAfter \u003d line.substring(comment.getEndColNo() + 1);\n                }\n            }\n            lineAfter \u003d lineAfter.trim();\n            if (!blankLinePattern.match(lineBefore) || !\"\".equals(lineAfter)) {\n                log(lineNo.intValue(), \"trailing.comments\");\n            }\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java"
    }
  }
}