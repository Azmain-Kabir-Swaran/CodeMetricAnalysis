{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JavadocUtil.java",
  "functionName": "getJavadocTags",
  "functionId": "getJavadocTags___textBlock-TextBlock__tagType-JavadocTagType",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtil.java",
  "functionStartLine": 96,
  "functionEndLine": 134,
  "numCommitsSeen": 99,
  "timeTaken": 4031,
  "changeHistory": [
    "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8",
    "d28a60c5529e182e1cdaea184415181e00b70d2a",
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
    "ed6c2ea1336f2b46b9f64dffc417f608c8de5067",
    "ce196814d857a4244a80c51d5151cc35e90b6749",
    "30c3a362d45721e6925fe89ba71f0fe69d0fc471",
    "41740f2d68baba3ae185e8303038f841e7d6fc5a",
    "ed595de84fba2db507adaf01d04cb089a5e0bac5",
    "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1",
    "9dbc71956635b56a20780d484454e177897b5788",
    "ebd4afdebe8ee09c0e6c7d1239e2ca982f87e51c",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "89005ddf6d5d8b494e4451d16df9fd8996c735a9",
    "89a51ba032fd9126651fa9efad31baf10c006ddf",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "d8286130e83dc672d30cd00eddbf6b5f77112521",
    "7d097b6fa682f8dcfedd95da2db8fed980c51705"
  ],
  "changeHistoryShort": {
    "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8": "Ymultichange(Yfilerename,Ybodychange)",
    "d28a60c5529e182e1cdaea184415181e00b70d2a": "Ybodychange",
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020": "Ybodychange",
    "ed6c2ea1336f2b46b9f64dffc417f608c8de5067": "Ybodychange",
    "ce196814d857a4244a80c51d5151cc35e90b6749": "Ymultichange(Yparameterchange,Ybodychange)",
    "30c3a362d45721e6925fe89ba71f0fe69d0fc471": "Ybodychange",
    "41740f2d68baba3ae185e8303038f841e7d6fc5a": "Ybodychange",
    "ed595de84fba2db507adaf01d04cb089a5e0bac5": "Yfilerename",
    "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1": "Ybodychange",
    "9dbc71956635b56a20780d484454e177897b5788": "Ybodychange",
    "ebd4afdebe8ee09c0e6c7d1239e2ca982f87e51c": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "89005ddf6d5d8b494e4451d16df9fd8996c735a9": "Ybodychange",
    "89a51ba032fd9126651fa9efad31baf10c006ddf": "Ymultichange(Yparameterchange,Ybodychange)",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "d8286130e83dc672d30cd00eddbf6b5f77112521": "Ymultichange(Yparameterchange,Ybodychange)",
    "7d097b6fa682f8dcfedd95da2db8fed980c51705": "Yintroduced"
  },
  "changeHistoryDetails": {
    "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "Issue #5812: Rename all utility classes to xxxxUtil\n",
      "commitDate": "03/06/18 9:40 PM",
      "commitName": "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8",
      "commitAuthor": "Pavel Bludov",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "Issue #5812: Rename all utility classes to xxxxUtil\n",
          "commitDate": "03/06/18 9:40 PM",
          "commitName": "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8",
          "commitAuthor": "Pavel Bludov",
          "commitDateOld": "03/06/18 6:34 PM",
          "commitNameOld": "2b9308a4f532e78a53e090922787175103dfeb34",
          "commitAuthorOld": "Roman Ivanov",
          "daysBetweenCommits": 0.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,39 @@\n     public static JavadocTags getJavadocTags(TextBlock textBlock,\n             JavadocTagType tagType) {\n         final boolean getBlockTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n                                          || tagType \u003d\u003d JavadocTagType.BLOCK;\n         final boolean getInlineTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n                                           || tagType \u003d\u003d JavadocTagType.INLINE;\n \n         final List\u003cTagInfo\u003e tags \u003d new ArrayList\u003c\u003e();\n \n         if (getBlockTags) {\n-            tags.addAll(BlockTagUtils.extractBlockTags(textBlock.getText()));\n+            tags.addAll(BlockTagUtil.extractBlockTags(textBlock.getText()));\n         }\n \n         if (getInlineTags) {\n-            tags.addAll(InlineTagUtils.extractInlineTags(textBlock.getText()));\n+            tags.addAll(InlineTagUtil.extractInlineTags(textBlock.getText()));\n         }\n \n         final List\u003cJavadocTag\u003e validTags \u003d new ArrayList\u003c\u003e();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d new ArrayList\u003c\u003e();\n \n         for (TagInfo tag : tags) {\n             final int col \u003d tag.getPosition().getColumn();\n \n             // Add the starting line of the comment to the line number to get the actual line number\n             // in the source.\n             // Lines are one-indexed, so need a off-by-one correction.\n             final int line \u003d textBlock.getStartLineNo() + tag.getPosition().getLine() - 1;\n \n             if (JavadocTagInfo.isValidName(tag.getName())) {\n                 validTags.add(\n                     new JavadocTag(line, col, tag.getName(), tag.getValue()));\n             }\n             else {\n                 invalidTags.add(new InvalidJavadocTag(line, col, tag.getName()));\n             }\n         }\n \n         return new JavadocTags(validTags, invalidTags);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public static JavadocTags getJavadocTags(TextBlock textBlock,\n            JavadocTagType tagType) {\n        final boolean getBlockTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n                                         || tagType \u003d\u003d JavadocTagType.BLOCK;\n        final boolean getInlineTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n                                          || tagType \u003d\u003d JavadocTagType.INLINE;\n\n        final List\u003cTagInfo\u003e tags \u003d new ArrayList\u003c\u003e();\n\n        if (getBlockTags) {\n            tags.addAll(BlockTagUtil.extractBlockTags(textBlock.getText()));\n        }\n\n        if (getInlineTags) {\n            tags.addAll(InlineTagUtil.extractInlineTags(textBlock.getText()));\n        }\n\n        final List\u003cJavadocTag\u003e validTags \u003d new ArrayList\u003c\u003e();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d new ArrayList\u003c\u003e();\n\n        for (TagInfo tag : tags) {\n            final int col \u003d tag.getPosition().getColumn();\n\n            // Add the starting line of the comment to the line number to get the actual line number\n            // in the source.\n            // Lines are one-indexed, so need a off-by-one correction.\n            final int line \u003d textBlock.getStartLineNo() + tag.getPosition().getLine() - 1;\n\n            if (JavadocTagInfo.isValidName(tag.getName())) {\n                validTags.add(\n                    new JavadocTag(line, col, tag.getName(), tag.getValue()));\n            }\n            else {\n                invalidTags.add(new InvalidJavadocTag(line, col, tag.getName()));\n            }\n        }\n\n        return new JavadocTags(validTags, invalidTags);\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtil.java",
          "extendedDetails": {
            "oldPath": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtils.java",
            "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtil.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Issue #5812: Rename all utility classes to xxxxUtil\n",
          "commitDate": "03/06/18 9:40 PM",
          "commitName": "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8",
          "commitAuthor": "Pavel Bludov",
          "commitDateOld": "03/06/18 6:34 PM",
          "commitNameOld": "2b9308a4f532e78a53e090922787175103dfeb34",
          "commitAuthorOld": "Roman Ivanov",
          "daysBetweenCommits": 0.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,39 @@\n     public static JavadocTags getJavadocTags(TextBlock textBlock,\n             JavadocTagType tagType) {\n         final boolean getBlockTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n                                          || tagType \u003d\u003d JavadocTagType.BLOCK;\n         final boolean getInlineTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n                                           || tagType \u003d\u003d JavadocTagType.INLINE;\n \n         final List\u003cTagInfo\u003e tags \u003d new ArrayList\u003c\u003e();\n \n         if (getBlockTags) {\n-            tags.addAll(BlockTagUtils.extractBlockTags(textBlock.getText()));\n+            tags.addAll(BlockTagUtil.extractBlockTags(textBlock.getText()));\n         }\n \n         if (getInlineTags) {\n-            tags.addAll(InlineTagUtils.extractInlineTags(textBlock.getText()));\n+            tags.addAll(InlineTagUtil.extractInlineTags(textBlock.getText()));\n         }\n \n         final List\u003cJavadocTag\u003e validTags \u003d new ArrayList\u003c\u003e();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d new ArrayList\u003c\u003e();\n \n         for (TagInfo tag : tags) {\n             final int col \u003d tag.getPosition().getColumn();\n \n             // Add the starting line of the comment to the line number to get the actual line number\n             // in the source.\n             // Lines are one-indexed, so need a off-by-one correction.\n             final int line \u003d textBlock.getStartLineNo() + tag.getPosition().getLine() - 1;\n \n             if (JavadocTagInfo.isValidName(tag.getName())) {\n                 validTags.add(\n                     new JavadocTag(line, col, tag.getName(), tag.getValue()));\n             }\n             else {\n                 invalidTags.add(new InvalidJavadocTag(line, col, tag.getName()));\n             }\n         }\n \n         return new JavadocTags(validTags, invalidTags);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public static JavadocTags getJavadocTags(TextBlock textBlock,\n            JavadocTagType tagType) {\n        final boolean getBlockTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n                                         || tagType \u003d\u003d JavadocTagType.BLOCK;\n        final boolean getInlineTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n                                          || tagType \u003d\u003d JavadocTagType.INLINE;\n\n        final List\u003cTagInfo\u003e tags \u003d new ArrayList\u003c\u003e();\n\n        if (getBlockTags) {\n            tags.addAll(BlockTagUtil.extractBlockTags(textBlock.getText()));\n        }\n\n        if (getInlineTags) {\n            tags.addAll(InlineTagUtil.extractInlineTags(textBlock.getText()));\n        }\n\n        final List\u003cJavadocTag\u003e validTags \u003d new ArrayList\u003c\u003e();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d new ArrayList\u003c\u003e();\n\n        for (TagInfo tag : tags) {\n            final int col \u003d tag.getPosition().getColumn();\n\n            // Add the starting line of the comment to the line number to get the actual line number\n            // in the source.\n            // Lines are one-indexed, so need a off-by-one correction.\n            final int line \u003d textBlock.getStartLineNo() + tag.getPosition().getLine() - 1;\n\n            if (JavadocTagInfo.isValidName(tag.getName())) {\n                validTags.add(\n                    new JavadocTag(line, col, tag.getName(), tag.getValue()));\n            }\n            else {\n                invalidTags.add(new InvalidJavadocTag(line, col, tag.getName()));\n            }\n        }\n\n        return new JavadocTags(validTags, invalidTags);\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtil.java",
          "extendedDetails": {}
        }
      ]
    },
    "d28a60c5529e182e1cdaea184415181e00b70d2a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2840: UnusedImportsCheck - process javadoc tags that span lines\n",
      "commitDate": "10/07/17 5:35 PM",
      "commitName": "d28a60c5529e182e1cdaea184415181e00b70d2a",
      "commitAuthor": "Nathan Naze",
      "commitDateOld": "26/06/17 5:34 PM",
      "commitNameOld": "c0eb205f6ab7abff2c409a387c853a8b51646c79",
      "commitAuthorOld": "Piyush Sharma",
      "daysBetweenCommits": 14.0,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,40 @@\n     public static JavadocTags getJavadocTags(TextBlock textBlock,\n             JavadocTagType tagType) {\n-        final String[] text \u003d textBlock.getText();\n-        final List\u003cJavadocTag\u003e tags \u003d new ArrayList\u003c\u003e();\n+\n+        final boolean getBlockTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n+                                         || tagType \u003d\u003d JavadocTagType.BLOCK;\n+        final boolean getInlineTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n+                                          || tagType \u003d\u003d JavadocTagType.INLINE;\n+\n+        final List\u003cTagInfo\u003e tags \u003d new ArrayList\u003c\u003e();\n+\n+        if (getBlockTags) {\n+            tags.addAll(BlockTagUtils.extractBlockTags(textBlock.getText()));\n+        }\n+\n+        if (getInlineTags) {\n+            tags.addAll(InlineTagUtils.extractInlineTags(textBlock.getText()));\n+        }\n+\n+        final List\u003cJavadocTag\u003e validTags \u003d new ArrayList\u003c\u003e();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d new ArrayList\u003c\u003e();\n-        for (int i \u003d 0; i \u003c text.length; i++) {\n-            final String textValue \u003d text[i];\n-            final Matcher blockTagMatcher \u003d getBlockTagPattern(i).matcher(textValue);\n-            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n-                    \u0026\u0026 blockTagMatcher.find()) {\n-                final String tagName \u003d blockTagMatcher.group(1);\n-                String content \u003d textValue.substring(blockTagMatcher.end(1));\n-                if (content.endsWith(\"*/\")) {\n-                    content \u003d content.substring(0, content.length() - 2);\n-                }\n-                final int line \u003d textBlock.getStartLineNo() + i;\n-                int col \u003d blockTagMatcher.start(1) - 1;\n-                if (i \u003d\u003d 0) {\n-                    col +\u003d textBlock.getStartColNo();\n-                }\n-                if (JavadocTagInfo.isValidName(tagName)) {\n-                    tags.add(\n-                            new JavadocTag(line, col, tagName, content.trim()));\n-                }\n-                else {\n-                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n-                }\n+\n+        for (TagInfo tag : tags) {\n+            final int col \u003d tag.getPosition().getColumn();\n+\n+            // Add the starting line of the comment to the line number to get the actual line number\n+            // in the source.\n+            // Lines are one-indexed, so need a off-by-one correction.\n+            final int line \u003d textBlock.getStartLineNo() + tag.getPosition().getLine() - 1;\n+\n+            if (JavadocTagInfo.isValidName(tag.getName())) {\n+                validTags.add(\n+                    new JavadocTag(line, col, tag.getName(), tag.getValue()));\n             }\n-            // No block tag, so look for inline validTags\n-            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n-                lookForInlineTags(textBlock, i, tags, invalidTags);\n+            else {\n+                invalidTags.add(new InvalidJavadocTag(line, col, tag.getName()));\n             }\n         }\n-        return new JavadocTags(tags, invalidTags);\n+\n+        return new JavadocTags(validTags, invalidTags);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock textBlock,\n            JavadocTagType tagType) {\n\n        final boolean getBlockTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n                                         || tagType \u003d\u003d JavadocTagType.BLOCK;\n        final boolean getInlineTags \u003d tagType \u003d\u003d JavadocTagType.ALL\n                                          || tagType \u003d\u003d JavadocTagType.INLINE;\n\n        final List\u003cTagInfo\u003e tags \u003d new ArrayList\u003c\u003e();\n\n        if (getBlockTags) {\n            tags.addAll(BlockTagUtils.extractBlockTags(textBlock.getText()));\n        }\n\n        if (getInlineTags) {\n            tags.addAll(InlineTagUtils.extractInlineTags(textBlock.getText()));\n        }\n\n        final List\u003cJavadocTag\u003e validTags \u003d new ArrayList\u003c\u003e();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d new ArrayList\u003c\u003e();\n\n        for (TagInfo tag : tags) {\n            final int col \u003d tag.getPosition().getColumn();\n\n            // Add the starting line of the comment to the line number to get the actual line number\n            // in the source.\n            // Lines are one-indexed, so need a off-by-one correction.\n            final int line \u003d textBlock.getStartLineNo() + tag.getPosition().getLine() - 1;\n\n            if (JavadocTagInfo.isValidName(tag.getName())) {\n                validTags.add(\n                    new JavadocTag(line, col, tag.getName(), tag.getValue()));\n            }\n            else {\n                invalidTags.add(new InvalidJavadocTag(line, col, tag.getName()));\n            }\n        }\n\n        return new JavadocTags(validTags, invalidTags);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtils.java",
      "extendedDetails": {}
    },
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3433: Cut down on Checkstyle\u0027s dependencies on Guava (part 2) (#3454)\n\n",
      "commitDate": "20/09/16 7:52 PM",
      "commitName": "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": "08/05/16 5:34 AM",
      "commitNameOld": "67e6b46e9fa424fbd0a2fba611a3a59b30727692",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 135.6,
      "commitsBetweenForRepo": 246,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n     public static JavadocTags getJavadocTags(TextBlock textBlock,\n             JavadocTagType tagType) {\n         final String[] text \u003d textBlock.getText();\n-        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n-        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n+        final List\u003cJavadocTag\u003e tags \u003d new ArrayList\u003c\u003e();\n+        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d new ArrayList\u003c\u003e();\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String textValue \u003d text[i];\n             final Matcher blockTagMatcher \u003d getBlockTagPattern(i).matcher(textValue);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d textValue.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d textBlock.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d textBlock.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                 lookForInlineTags(textBlock, i, tags, invalidTags);\n             }\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock textBlock,\n            JavadocTagType tagType) {\n        final String[] text \u003d textBlock.getText();\n        final List\u003cJavadocTag\u003e tags \u003d new ArrayList\u003c\u003e();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String textValue \u003d text[i];\n            final Matcher blockTagMatcher \u003d getBlockTagPattern(i).matcher(textValue);\n            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                    \u0026\u0026 blockTagMatcher.find()) {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d textValue.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d textBlock.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d textBlock.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                lookForInlineTags(textBlock, i, tags, invalidTags);\n            }\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtils.java",
      "extendedDetails": {}
    },
    "ed6c2ea1336f2b46b9f64dffc417f608c8de5067": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2631: Optimize JavadocUtils\n",
      "commitDate": "21/12/15 6:31 AM",
      "commitName": "ed6c2ea1336f2b46b9f64dffc417f608c8de5067",
      "commitAuthor": "Vladislav Lisetskiy",
      "commitDateOld": "16/10/15 4:35 PM",
      "commitNameOld": "ce196814d857a4244a80c51d5151cc35e90b6749",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 65.62,
      "commitsBetweenForRepo": 345,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,35 @@\n     public static JavadocTags getJavadocTags(TextBlock textBlock,\n             JavadocTagType tagType) {\n         final String[] text \u003d textBlock.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n-        Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String textValue \u003d text[i];\n-            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(textValue);\n+            final Matcher blockTagMatcher \u003d getBlockTagPattern(i).matcher(textValue);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d textValue.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d textBlock.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d textBlock.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                 lookForInlineTags(textBlock, i, tags, invalidTags);\n             }\n-            blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock textBlock,\n            JavadocTagType tagType) {\n        final String[] text \u003d textBlock.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String textValue \u003d text[i];\n            final Matcher blockTagMatcher \u003d getBlockTagPattern(i).matcher(textValue);\n            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                    \u0026\u0026 blockTagMatcher.find()) {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d textValue.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d textBlock.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d textBlock.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                lookForInlineTags(textBlock, i, tags, invalidTags);\n            }\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtils.java",
      "extendedDetails": {}
    },
    "ce196814d857a4244a80c51d5151cc35e90b6749": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Issue #2080: Fix typos in code\n",
      "commitDate": "16/10/15 4:35 PM",
      "commitName": "ce196814d857a4244a80c51d5151cc35e90b6749",
      "commitAuthor": "Michal Kordas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Issue #2080: Fix typos in code\n",
          "commitDate": "16/10/15 4:35 PM",
          "commitName": "ce196814d857a4244a80c51d5151cc35e90b6749",
          "commitAuthor": "Michal Kordas",
          "commitDateOld": "06/10/15 7:33 PM",
          "commitNameOld": "5f5142b2325051f9ed31130167c73d154d547211",
          "commitAuthorOld": "Roman Ivanov",
          "daysBetweenCommits": 9.88,
          "commitsBetweenForRepo": 95,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,37 @@\n-    public static JavadocTags getJavadocTags(TextBlock cmt,\n+    public static JavadocTags getJavadocTags(TextBlock textBlock,\n             JavadocTagType tagType) {\n-        final String[] text \u003d cmt.getText();\n+        final String[] text \u003d textBlock.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String textValue \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(textValue);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d textValue.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n-                final int line \u003d cmt.getStartLineNo() + i;\n+                final int line \u003d textBlock.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n-                    col +\u003d cmt.getStartColNo();\n+                    col +\u003d textBlock.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n-                lookForInlineTags(cmt, i, tags, invalidTags);\n+                lookForInlineTags(textBlock, i, tags, invalidTags);\n             }\n             blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public static JavadocTags getJavadocTags(TextBlock textBlock,\n            JavadocTagType tagType) {\n        final String[] text \u003d textBlock.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String textValue \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(textValue);\n            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                    \u0026\u0026 blockTagMatcher.find()) {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d textValue.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d textBlock.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d textBlock.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                lookForInlineTags(textBlock, i, tags, invalidTags);\n            }\n            blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtils.java",
          "extendedDetails": {
            "oldValue": "[cmt-TextBlock, tagType-JavadocTagType]",
            "newValue": "[textBlock-TextBlock, tagType-JavadocTagType]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Issue #2080: Fix typos in code\n",
          "commitDate": "16/10/15 4:35 PM",
          "commitName": "ce196814d857a4244a80c51d5151cc35e90b6749",
          "commitAuthor": "Michal Kordas",
          "commitDateOld": "06/10/15 7:33 PM",
          "commitNameOld": "5f5142b2325051f9ed31130167c73d154d547211",
          "commitAuthorOld": "Roman Ivanov",
          "daysBetweenCommits": 9.88,
          "commitsBetweenForRepo": 95,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,37 @@\n-    public static JavadocTags getJavadocTags(TextBlock cmt,\n+    public static JavadocTags getJavadocTags(TextBlock textBlock,\n             JavadocTagType tagType) {\n-        final String[] text \u003d cmt.getText();\n+        final String[] text \u003d textBlock.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String textValue \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(textValue);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d textValue.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n-                final int line \u003d cmt.getStartLineNo() + i;\n+                final int line \u003d textBlock.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n-                    col +\u003d cmt.getStartColNo();\n+                    col +\u003d textBlock.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n-                lookForInlineTags(cmt, i, tags, invalidTags);\n+                lookForInlineTags(textBlock, i, tags, invalidTags);\n             }\n             blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public static JavadocTags getJavadocTags(TextBlock textBlock,\n            JavadocTagType tagType) {\n        final String[] text \u003d textBlock.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String textValue \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(textValue);\n            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                    \u0026\u0026 blockTagMatcher.find()) {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d textValue.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d textBlock.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d textBlock.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                lookForInlineTags(textBlock, i, tags, invalidTags);\n            }\n            blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtils.java",
          "extendedDetails": {}
        }
      ]
    },
    "30c3a362d45721e6925fe89ba71f0fe69d0fc471": {
      "type": "Ybodychange",
      "commitMessage": "Issue #985: Fix PMD violations for ShortVariable rule\n",
      "commitDate": "06/10/15 5:46 PM",
      "commitName": "30c3a362d45721e6925fe89ba71f0fe69d0fc471",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "15/09/15 5:24 PM",
      "commitNameOld": "e29dc4d398c136e8ec5a08e93bde7b805153835d",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 21.02,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType) {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n-            final String s \u003d text[i];\n-            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n+            final String textValue \u003d text[i];\n+            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(textValue);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n-                String content \u003d s.substring(blockTagMatcher.end(1));\n+                String content \u003d textValue.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                 lookForInlineTags(cmt, i, tags, invalidTags);\n             }\n             blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock cmt,\n            JavadocTagType tagType) {\n        final String[] text \u003d cmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String textValue \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(textValue);\n            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                    \u0026\u0026 blockTagMatcher.find()) {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d textValue.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d cmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d cmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                lookForInlineTags(cmt, i, tags, invalidTags);\n            }\n            blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtils.java",
      "extendedDetails": {}
    },
    "41740f2d68baba3ae185e8303038f841e7d6fc5a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: Reducing JavadocUtils method length\n",
      "commitDate": "27/08/15 6:30 AM",
      "commitName": "41740f2d68baba3ae185e8303038f841e7d6fc5a",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": "27/08/15 5:17 AM",
      "commitNameOld": "cdf3e56bacd3895262af8a1df9ca5c81f4071970",
      "commitAuthorOld": "Ilja Dubinin",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,37 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType) {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n-                // Match Javadoc text after comment characters\n-                final Pattern commentPattern \u003d Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n-                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n-                final String commentContents;\n-\n-                // offset including comment characters\n-                final int commentOffset;\n-\n-                if (commentMatcher.find()) {\n-                    commentContents \u003d commentMatcher.group(1);\n-                    commentOffset \u003d commentMatcher.start(1) - 1;\n-                }\n-                else {\n-                    // No leading asterisks, still valid\n-                    commentContents \u003d s;\n-                    commentOffset \u003d 0;\n-                }\n-                final Pattern tagPattern \u003d Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n-                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n-                while (tagMatcher.find()) {\n-                    final String tagName \u003d tagMatcher.group(1);\n-                    final String tagValue \u003d tagMatcher.group(2).trim();\n-                    final int line \u003d cmt.getStartLineNo() + i;\n-                    int col \u003d commentOffset + tagMatcher.start(1) - 1;\n-                    if (i \u003d\u003d 0) {\n-                        col +\u003d cmt.getStartColNo();\n-                    }\n-                    if (JavadocTagInfo.isValidName(tagName)) {\n-                        tags.add(new JavadocTag(line, col, tagName,\n-                                tagValue));\n-                    }\n-                    else {\n-                        invalidTags.add(new InvalidJavadocTag(line, col,\n-                                tagName));\n-                    }\n-                    // else Error: Unexpected match count for inline Javadoc\n-                    // tag!\n-                }\n+                lookForInlineTags(cmt, i, tags, invalidTags);\n             }\n             blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock cmt,\n            JavadocTagType tagType) {\n        final String[] text \u003d cmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                    \u0026\u0026 blockTagMatcher.find()) {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d cmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d cmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                lookForInlineTags(cmt, i, tags, invalidTags);\n            }\n            blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtils.java",
      "extendedDetails": {}
    },
    "ed595de84fba2db507adaf01d04cb089a5e0bac5": {
      "type": "Yfilerename",
      "commitMessage": "Utils classes have been moved to utils package. Issue #1898\n",
      "commitDate": "27/08/15 5:17 AM",
      "commitName": "ed595de84fba2db507adaf01d04cb089a5e0bac5",
      "commitAuthor": "Ilja Dubinin",
      "commitDateOld": "26/08/15 6:08 PM",
      "commitNameOld": "f6113bb56d695719a8803274effb3596cb82120f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.46,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock cmt,\n            JavadocTagType tagType) {\n        final String[] text \u003d cmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                    \u0026\u0026 blockTagMatcher.find()) {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d cmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d cmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                // Match Javadoc text after comment characters\n                final Pattern commentPattern \u003d Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                final String commentContents;\n\n                // offset including comment characters\n                final int commentOffset;\n\n                if (commentMatcher.find()) {\n                    commentContents \u003d commentMatcher.group(1);\n                    commentOffset \u003d commentMatcher.start(1) - 1;\n                }\n                else {\n                    // No leading asterisks, still valid\n                    commentContents \u003d s;\n                    commentOffset \u003d 0;\n                }\n                final Pattern tagPattern \u003d Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                while (tagMatcher.find()) {\n                    final String tagName \u003d tagMatcher.group(1);\n                    final String tagValue \u003d tagMatcher.group(2).trim();\n                    final int line \u003d cmt.getStartLineNo() + i;\n                    int col \u003d commentOffset + tagMatcher.start(1) - 1;\n                    if (i \u003d\u003d 0) {\n                        col +\u003d cmt.getStartColNo();\n                    }\n                    if (JavadocTagInfo.isValidName(tagName)) {\n                        tags.add(new JavadocTag(line, col, tagName,\n                                tagValue));\n                    }\n                    else {\n                        invalidTags.add(new InvalidJavadocTag(line, col,\n                                tagName));\n                    }\n                    // else Error: Unexpected match count for inline Javadoc\n                    // tag!\n                }\n            }\n            blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtils.java",
      "extendedDetails": {
        "oldPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtils.java"
      }
    },
    "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1": {
      "type": "Ybodychange",
      "commitMessage": "Invert if statements with negated conditions. #1555\n\nFixes `NegatedIfElse` inspection violations.\n\nDescription:\n\u003eReports if statements which contain else branches and whose conditions are negated. Flipping the order of the if and else branches will usually increase the clarity of such statements.\n",
      "commitDate": "09/08/15 11:46 PM",
      "commitName": "86826e1fa3fe3d793ee4723bb84ee0fc4ca38df1",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "07/08/15 9:38 PM",
      "commitNameOld": "f1e80e4ecae727087ca135dfd02f72e2d6213efb",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.09,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType) {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                 // Match Javadoc text after comment characters\n                 final Pattern commentPattern \u003d Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                 final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n-                if (!commentMatcher.find()) {\n-                    commentContents \u003d s; // No leading asterisks, still valid\n-                    commentOffset \u003d 0;\n-                }\n-                else {\n+                if (commentMatcher.find()) {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n+                else {\n+                    commentContents \u003d s; // No leading asterisks, still valid\n+                    commentOffset \u003d 0;\n+                }\n                 final Pattern tagPattern \u003d Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                 final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n                     final String tagName \u003d tagMatcher.group(1);\n                     final String tagValue \u003d tagMatcher.group(2).trim();\n                     final int line \u003d cmt.getStartLineNo() + i;\n                     int col \u003d commentOffset + tagMatcher.start(1) - 1;\n                     if (i \u003d\u003d 0) {\n                         col +\u003d cmt.getStartColNo();\n                     }\n                     if (JavadocTagInfo.isValidName(tagName)) {\n                         tags.add(new JavadocTag(line, col, tagName,\n                                 tagValue));\n                     }\n                     else {\n                         invalidTags.add(new InvalidJavadocTag(line, col,\n                                 tagName));\n                     }\n                     // else Error: Unexpected match count for inline Javadoc\n                     // tag!\n                 }\n             }\n             blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock cmt,\n            JavadocTagType tagType) {\n        final String[] text \u003d cmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                    \u0026\u0026 blockTagMatcher.find()) {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d cmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d cmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                // Match Javadoc text after comment characters\n                final Pattern commentPattern \u003d Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                final String commentContents;\n                final int commentOffset; // offset including comment characters\n                if (commentMatcher.find()) {\n                    commentContents \u003d commentMatcher.group(1);\n                    commentOffset \u003d commentMatcher.start(1) - 1;\n                }\n                else {\n                    commentContents \u003d s; // No leading asterisks, still valid\n                    commentOffset \u003d 0;\n                }\n                final Pattern tagPattern \u003d Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                while (tagMatcher.find()) {\n                    final String tagName \u003d tagMatcher.group(1);\n                    final String tagValue \u003d tagMatcher.group(2).trim();\n                    final int line \u003d cmt.getStartLineNo() + i;\n                    int col \u003d commentOffset + tagMatcher.start(1) - 1;\n                    if (i \u003d\u003d 0) {\n                        col +\u003d cmt.getStartColNo();\n                    }\n                    if (JavadocTagInfo.isValidName(tagName)) {\n                        tags.add(new JavadocTag(line, col, tagName,\n                                tagValue));\n                    }\n                    else {\n                        invalidTags.add(new InvalidJavadocTag(line, col,\n                                tagName));\n                    }\n                    // else Error: Unexpected match count for inline Javadoc\n                    // tag!\n                }\n            }\n            blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java",
      "extendedDetails": {}
    },
    "9dbc71956635b56a20780d484454e177897b5788": {
      "type": "Ybodychange",
      "commitMessage": "Add test case and refactor JavadocUtils. #1308\n",
      "commitDate": "27/07/15 12:21 PM",
      "commitName": "9dbc71956635b56a20780d484454e177897b5788",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "13/07/15 1:46 PM",
      "commitNameOld": "e68f47ce99313c7dafade4ac4a55fccf12c09d5e",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 13.94,
      "commitsBetweenForRepo": 150,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,70 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType) {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find()) {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                 // Match Javadoc text after comment characters\n                 final Pattern commentPattern \u003d Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                 final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n                 if (!commentMatcher.find()) {\n                     commentContents \u003d s; // No leading asterisks, still valid\n                     commentOffset \u003d 0;\n                 }\n                 else {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n                 final Pattern tagPattern \u003d Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                 final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n-                    if (tagMatcher.groupCount() \u003d\u003d 2) {\n-                        final String tagName \u003d tagMatcher.group(1);\n-                        final String tagValue \u003d tagMatcher.group(2).trim();\n-                        final int line \u003d cmt.getStartLineNo() + i;\n-                        int col \u003d commentOffset + tagMatcher.start(1) - 1;\n-                        if (i \u003d\u003d 0) {\n-                            col +\u003d cmt.getStartColNo();\n-                        }\n-                        if (JavadocTagInfo.isValidName(tagName)) {\n-                            tags.add(new JavadocTag(line, col, tagName,\n-                                    tagValue));\n-                        }\n-                        else {\n-                            invalidTags.add(new InvalidJavadocTag(line, col,\n-                                    tagName));\n-                        }\n+                    final String tagName \u003d tagMatcher.group(1);\n+                    final String tagValue \u003d tagMatcher.group(2).trim();\n+                    final int line \u003d cmt.getStartLineNo() + i;\n+                    int col \u003d commentOffset + tagMatcher.start(1) - 1;\n+                    if (i \u003d\u003d 0) {\n+                        col +\u003d cmt.getStartColNo();\n+                    }\n+                    if (JavadocTagInfo.isValidName(tagName)) {\n+                        tags.add(new JavadocTag(line, col, tagName,\n+                                tagValue));\n+                    }\n+                    else {\n+                        invalidTags.add(new InvalidJavadocTag(line, col,\n+                                tagName));\n                     }\n                     // else Error: Unexpected match count for inline Javadoc\n                     // tag!\n                 }\n             }\n             blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock cmt,\n            JavadocTagType tagType) {\n        final String[] text \u003d cmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                    \u0026\u0026 blockTagMatcher.find()) {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d cmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d cmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE) {\n                // Match Javadoc text after comment characters\n                final Pattern commentPattern \u003d Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                final String commentContents;\n                final int commentOffset; // offset including comment characters\n                if (!commentMatcher.find()) {\n                    commentContents \u003d s; // No leading asterisks, still valid\n                    commentOffset \u003d 0;\n                }\n                else {\n                    commentContents \u003d commentMatcher.group(1);\n                    commentOffset \u003d commentMatcher.start(1) - 1;\n                }\n                final Pattern tagPattern \u003d Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                while (tagMatcher.find()) {\n                    final String tagName \u003d tagMatcher.group(1);\n                    final String tagValue \u003d tagMatcher.group(2).trim();\n                    final int line \u003d cmt.getStartLineNo() + i;\n                    int col \u003d commentOffset + tagMatcher.start(1) - 1;\n                    if (i \u003d\u003d 0) {\n                        col +\u003d cmt.getStartColNo();\n                    }\n                    if (JavadocTagInfo.isValidName(tagName)) {\n                        tags.add(new JavadocTag(line, col, tagName,\n                                tagValue));\n                    }\n                    else {\n                        invalidTags.add(new InvalidJavadocTag(line, col,\n                                tagName));\n                    }\n                    // else Error: Unexpected match count for inline Javadoc\n                    // tag!\n                }\n            }\n            blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java",
      "extendedDetails": {}
    },
    "ebd4afdebe8ee09c0e6c7d1239e2ca982f87e51c": {
      "type": "Ybodychange",
      "commitMessage": "Deleted cache from Utils class + unified setters with patterns\n\nIssue #845\n",
      "commitDate": "27/03/15 2:39 PM",
      "commitName": "ebd4afdebe8ee09c0e6c7d1239e2ca982f87e51c",
      "commitAuthor": "Damian Szczepanik",
      "commitDateOld": "20/03/15 12:57 PM",
      "commitNameOld": "9f2bf96b2001eb2e3886950a41e076c8a01d57d8",
      "commitAuthorOld": "Damian Szczepanik",
      "daysBetweenCommits": 7.07,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,75 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType)\n     {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n-        Pattern blockTagPattern \u003d\n-                Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n+        Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find())\n             {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE)\n             {\n                 // Match Javadoc text after comment characters\n-                final Pattern commentPattern \u003d\n-                        Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n+                final Pattern commentPattern \u003d Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                 final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n                 if (!commentMatcher.find()) {\n                     commentContents \u003d s; // No leading asterisks, still valid\n                     commentOffset \u003d 0;\n                 }\n                 else {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n-                final Pattern tagPattern \u003d\n-                        Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n+                final Pattern tagPattern \u003d Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                 final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n                     if (tagMatcher.groupCount() \u003d\u003d 2) {\n                         final String tagName \u003d tagMatcher.group(1);\n                         final String tagValue \u003d tagMatcher.group(2).trim();\n                         final int line \u003d cmt.getStartLineNo() + i;\n                         int col \u003d commentOffset + tagMatcher.start(1) - 1;\n                         if (i \u003d\u003d 0) {\n                             col +\u003d cmt.getStartColNo();\n                         }\n                         if (JavadocTagInfo.isValidName(tagName)) {\n                             tags.add(new JavadocTag(line, col, tagName,\n                                     tagValue));\n                         }\n                         else {\n                             invalidTags.add(new InvalidJavadocTag(line, col,\n                                     tagName));\n                         }\n                     }\n                     // else Error: Unexpected match count for inline Javadoc\n                     // tag!\n                 }\n             }\n-            blockTagPattern \u003d\n-                    Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n+            blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock cmt,\n            JavadocTagType tagType)\n    {\n        final String[] text \u003d cmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d Pattern.compile(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                    \u0026\u0026 blockTagMatcher.find())\n            {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d cmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d cmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE)\n            {\n                // Match Javadoc text after comment characters\n                final Pattern commentPattern \u003d Pattern.compile(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                final String commentContents;\n                final int commentOffset; // offset including comment characters\n                if (!commentMatcher.find()) {\n                    commentContents \u003d s; // No leading asterisks, still valid\n                    commentOffset \u003d 0;\n                }\n                else {\n                    commentContents \u003d commentMatcher.group(1);\n                    commentOffset \u003d commentMatcher.start(1) - 1;\n                }\n                final Pattern tagPattern \u003d Pattern.compile(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                while (tagMatcher.find()) {\n                    if (tagMatcher.groupCount() \u003d\u003d 2) {\n                        final String tagName \u003d tagMatcher.group(1);\n                        final String tagValue \u003d tagMatcher.group(2).trim();\n                        final int line \u003d cmt.getStartLineNo() + i;\n                        int col \u003d commentOffset + tagMatcher.start(1) - 1;\n                        if (i \u003d\u003d 0) {\n                            col +\u003d cmt.getStartColNo();\n                        }\n                        if (JavadocTagInfo.isValidName(tagName)) {\n                            tags.add(new JavadocTag(line, col, tagName,\n                                    tagValue));\n                        }\n                        else {\n                            invalidTags.add(new InvalidJavadocTag(line, col,\n                                    tagName));\n                        }\n                    }\n                    // else Error: Unexpected match count for inline Javadoc\n                    // tag!\n                }\n            }\n            blockTagPattern \u003d Pattern.compile(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java",
      "extendedDetails": {}
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": "10/03/15 2:36 PM",
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "10/03/15 7:46 AM",
      "commitNameOld": "89005ddf6d5d8b494e4451d16df9fd8996c735a9",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType)\n     {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d\n                 Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n             if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                     \u0026\u0026 blockTagMatcher.find())\n             {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n             else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE)\n             {\n                 // Match Javadoc text after comment characters\n                 final Pattern commentPattern \u003d\n                         Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                 final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n                 if (!commentMatcher.find()) {\n                     commentContents \u003d s; // No leading asterisks, still valid\n                     commentOffset \u003d 0;\n                 }\n                 else {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n                 final Pattern tagPattern \u003d\n                         Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                 final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n                     if (tagMatcher.groupCount() \u003d\u003d 2) {\n                         final String tagName \u003d tagMatcher.group(1);\n                         final String tagValue \u003d tagMatcher.group(2).trim();\n                         final int line \u003d cmt.getStartLineNo() + i;\n-                        int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n+                        int col \u003d commentOffset + tagMatcher.start(1) - 1;\n                         if (i \u003d\u003d 0) {\n                             col +\u003d cmt.getStartColNo();\n                         }\n                         if (JavadocTagInfo.isValidName(tagName)) {\n                             tags.add(new JavadocTag(line, col, tagName,\n                                     tagValue));\n                         }\n                         else {\n                             invalidTags.add(new InvalidJavadocTag(line, col,\n                                     tagName));\n                         }\n                     }\n                     // else Error: Unexpected match count for inline Javadoc\n                     // tag!\n                 }\n             }\n             blockTagPattern \u003d\n                     Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock cmt,\n            JavadocTagType tagType)\n    {\n        final String[] text \u003d cmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d\n                Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                    \u0026\u0026 blockTagMatcher.find())\n            {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d cmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d cmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE)\n            {\n                // Match Javadoc text after comment characters\n                final Pattern commentPattern \u003d\n                        Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                final String commentContents;\n                final int commentOffset; // offset including comment characters\n                if (!commentMatcher.find()) {\n                    commentContents \u003d s; // No leading asterisks, still valid\n                    commentOffset \u003d 0;\n                }\n                else {\n                    commentContents \u003d commentMatcher.group(1);\n                    commentOffset \u003d commentMatcher.start(1) - 1;\n                }\n                final Pattern tagPattern \u003d\n                        Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                while (tagMatcher.find()) {\n                    if (tagMatcher.groupCount() \u003d\u003d 2) {\n                        final String tagName \u003d tagMatcher.group(1);\n                        final String tagValue \u003d tagMatcher.group(2).trim();\n                        final int line \u003d cmt.getStartLineNo() + i;\n                        int col \u003d commentOffset + tagMatcher.start(1) - 1;\n                        if (i \u003d\u003d 0) {\n                            col +\u003d cmt.getStartColNo();\n                        }\n                        if (JavadocTagInfo.isValidName(tagName)) {\n                            tags.add(new JavadocTag(line, col, tagName,\n                                    tagValue));\n                        }\n                        else {\n                            invalidTags.add(new InvalidJavadocTag(line, col,\n                                    tagName));\n                        }\n                    }\n                    // else Error: Unexpected match count for inline Javadoc\n                    // tag!\n                }\n            }\n            blockTagPattern \u003d\n                    Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java",
      "extendedDetails": {}
    },
    "89005ddf6d5d8b494e4451d16df9fd8996c735a9": {
      "type": "Ybodychange",
      "commitMessage": "Replace calls to equals() on enums with identity comparison\n\nThis replacement is safe because two enum constants are equal only when they have the same identity.\n",
      "commitDate": "10/03/15 7:46 AM",
      "commitName": "89005ddf6d5d8b494e4451d16df9fd8996c735a9",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "18/02/15 1:14 PM",
      "commitNameOld": "c9a9e6508c15e00cf6820b213d79d5ebf41c6343",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 19.73,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,79 @@\n     public static JavadocTags getJavadocTags(TextBlock cmt,\n             JavadocTagType tagType)\n     {\n         final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d\n                 Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n-            if ((tagType.equals(JavadocTagType.ALL) || tagType\n-                    .equals(JavadocTagType.BLOCK)) \u0026\u0026 blockTagMatcher.find())\n+            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n+                    \u0026\u0026 blockTagMatcher.find())\n             {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n                 final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n-            else if (tagType.equals(JavadocTagType.ALL)\n-                    || tagType.equals(JavadocTagType.INLINE))\n+            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE)\n             {\n                 // Match Javadoc text after comment characters\n                 final Pattern commentPattern \u003d\n                         Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                 final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n                 if (!commentMatcher.find()) {\n                     commentContents \u003d s; // No leading asterisks, still valid\n                     commentOffset \u003d 0;\n                 }\n                 else {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n                 final Pattern tagPattern \u003d\n                         Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                 final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n                     if (tagMatcher.groupCount() \u003d\u003d 2) {\n                         final String tagName \u003d tagMatcher.group(1);\n                         final String tagValue \u003d tagMatcher.group(2).trim();\n                         final int line \u003d cmt.getStartLineNo() + i;\n                         int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                         if (i \u003d\u003d 0) {\n                             col +\u003d cmt.getStartColNo();\n                         }\n                         if (JavadocTagInfo.isValidName(tagName)) {\n                             tags.add(new JavadocTag(line, col, tagName,\n                                     tagValue));\n                         }\n                         else {\n                             invalidTags.add(new InvalidJavadocTag(line, col,\n                                     tagName));\n                         }\n                     }\n                     // else Error: Unexpected match count for inline Javadoc\n                     // tag!\n                 }\n             }\n             blockTagPattern \u003d\n                     Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock cmt,\n            JavadocTagType tagType)\n    {\n        final String[] text \u003d cmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d\n                Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.BLOCK)\n                    \u0026\u0026 blockTagMatcher.find())\n            {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d cmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d cmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType \u003d\u003d JavadocTagType.ALL || tagType \u003d\u003d JavadocTagType.INLINE)\n            {\n                // Match Javadoc text after comment characters\n                final Pattern commentPattern \u003d\n                        Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                final String commentContents;\n                final int commentOffset; // offset including comment characters\n                if (!commentMatcher.find()) {\n                    commentContents \u003d s; // No leading asterisks, still valid\n                    commentOffset \u003d 0;\n                }\n                else {\n                    commentContents \u003d commentMatcher.group(1);\n                    commentOffset \u003d commentMatcher.start(1) - 1;\n                }\n                final Pattern tagPattern \u003d\n                        Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                while (tagMatcher.find()) {\n                    if (tagMatcher.groupCount() \u003d\u003d 2) {\n                        final String tagName \u003d tagMatcher.group(1);\n                        final String tagValue \u003d tagMatcher.group(2).trim();\n                        final int line \u003d cmt.getStartLineNo() + i;\n                        int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                        if (i \u003d\u003d 0) {\n                            col +\u003d cmt.getStartColNo();\n                        }\n                        if (JavadocTagInfo.isValidName(tagName)) {\n                            tags.add(new JavadocTag(line, col, tagName,\n                                    tagValue));\n                        }\n                        else {\n                            invalidTags.add(new InvalidJavadocTag(line, col,\n                                    tagName));\n                        }\n                    }\n                    // else Error: Unexpected match count for inline Javadoc\n                    // tag!\n                }\n            }\n            blockTagPattern \u003d\n                    Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java",
      "extendedDetails": {}
    },
    "89a51ba032fd9126651fa9efad31baf10c006ddf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, javadoc, #512\n",
      "commitDate": "19/01/15 6:21 AM",
      "commitName": "89a51ba032fd9126651fa9efad31baf10c006ddf",
      "commitAuthor": "alexkravin",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Prefixes, javadoc, #512\n",
          "commitDate": "19/01/15 6:21 AM",
          "commitName": "89a51ba032fd9126651fa9efad31baf10c006ddf",
          "commitAuthor": "alexkravin",
          "commitDateOld": "11/11/14 7:05 AM",
          "commitNameOld": "7b6785343e306845f432154a1a5026ad25306226",
          "commitAuthorOld": "Baratali Izmailov",
          "daysBetweenCommits": 68.97,
          "commitsBetweenForRepo": 222,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,80 +1,80 @@\n-    public static JavadocTags getJavadocTags(TextBlock aCmt,\n-            JavadocTagType aTagType)\n+    public static JavadocTags getJavadocTags(TextBlock cmt,\n+            JavadocTagType tagType)\n     {\n-        final String[] text \u003d aCmt.getText();\n+        final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d\n                 Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n-            if ((aTagType.equals(JavadocTagType.ALL) || aTagType\n+            if ((tagType.equals(JavadocTagType.ALL) || tagType\n                     .equals(JavadocTagType.BLOCK)) \u0026\u0026 blockTagMatcher.find())\n             {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n-                final int line \u003d aCmt.getStartLineNo() + i;\n+                final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n-                    col +\u003d aCmt.getStartColNo();\n+                    col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n-            else if (aTagType.equals(JavadocTagType.ALL)\n-                    || aTagType.equals(JavadocTagType.INLINE))\n+            else if (tagType.equals(JavadocTagType.ALL)\n+                    || tagType.equals(JavadocTagType.INLINE))\n             {\n-                // Match JavaDoc text after comment characters\n+                // Match Javadoc text after comment characters\n                 final Pattern commentPattern \u003d\n                         Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                 final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n                 if (!commentMatcher.find()) {\n                     commentContents \u003d s; // No leading asterisks, still valid\n                     commentOffset \u003d 0;\n                 }\n                 else {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n                 final Pattern tagPattern \u003d\n                         Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                 final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n                     if (tagMatcher.groupCount() \u003d\u003d 2) {\n                         final String tagName \u003d tagMatcher.group(1);\n                         final String tagValue \u003d tagMatcher.group(2).trim();\n-                        final int line \u003d aCmt.getStartLineNo() + i;\n+                        final int line \u003d cmt.getStartLineNo() + i;\n                         int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                         if (i \u003d\u003d 0) {\n-                            col +\u003d aCmt.getStartColNo();\n+                            col +\u003d cmt.getStartColNo();\n                         }\n                         if (JavadocTagInfo.isValidName(tagName)) {\n                             tags.add(new JavadocTag(line, col, tagName,\n                                     tagValue));\n                         }\n                         else {\n                             invalidTags.add(new InvalidJavadocTag(line, col,\n                                     tagName));\n                         }\n                     }\n-                    // else Error: Unexpected match count for inline JavaDoc\n+                    // else Error: Unexpected match count for inline Javadoc\n                     // tag!\n                 }\n             }\n             blockTagPattern \u003d\n                     Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public static JavadocTags getJavadocTags(TextBlock cmt,\n            JavadocTagType tagType)\n    {\n        final String[] text \u003d cmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d\n                Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((tagType.equals(JavadocTagType.ALL) || tagType\n                    .equals(JavadocTagType.BLOCK)) \u0026\u0026 blockTagMatcher.find())\n            {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d cmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d cmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType.equals(JavadocTagType.ALL)\n                    || tagType.equals(JavadocTagType.INLINE))\n            {\n                // Match Javadoc text after comment characters\n                final Pattern commentPattern \u003d\n                        Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                final String commentContents;\n                final int commentOffset; // offset including comment characters\n                if (!commentMatcher.find()) {\n                    commentContents \u003d s; // No leading asterisks, still valid\n                    commentOffset \u003d 0;\n                }\n                else {\n                    commentContents \u003d commentMatcher.group(1);\n                    commentOffset \u003d commentMatcher.start(1) - 1;\n                }\n                final Pattern tagPattern \u003d\n                        Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                while (tagMatcher.find()) {\n                    if (tagMatcher.groupCount() \u003d\u003d 2) {\n                        final String tagName \u003d tagMatcher.group(1);\n                        final String tagValue \u003d tagMatcher.group(2).trim();\n                        final int line \u003d cmt.getStartLineNo() + i;\n                        int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                        if (i \u003d\u003d 0) {\n                            col +\u003d cmt.getStartColNo();\n                        }\n                        if (JavadocTagInfo.isValidName(tagName)) {\n                            tags.add(new JavadocTag(line, col, tagName,\n                                    tagValue));\n                        }\n                        else {\n                            invalidTags.add(new InvalidJavadocTag(line, col,\n                                    tagName));\n                        }\n                    }\n                    // else Error: Unexpected match count for inline Javadoc\n                    // tag!\n                }\n            }\n            blockTagPattern \u003d\n                    Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java",
          "extendedDetails": {
            "oldValue": "[aCmt-TextBlock, aTagType-JavadocTagType]",
            "newValue": "[cmt-TextBlock, tagType-JavadocTagType]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Prefixes, javadoc, #512\n",
          "commitDate": "19/01/15 6:21 AM",
          "commitName": "89a51ba032fd9126651fa9efad31baf10c006ddf",
          "commitAuthor": "alexkravin",
          "commitDateOld": "11/11/14 7:05 AM",
          "commitNameOld": "7b6785343e306845f432154a1a5026ad25306226",
          "commitAuthorOld": "Baratali Izmailov",
          "daysBetweenCommits": 68.97,
          "commitsBetweenForRepo": 222,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,80 +1,80 @@\n-    public static JavadocTags getJavadocTags(TextBlock aCmt,\n-            JavadocTagType aTagType)\n+    public static JavadocTags getJavadocTags(TextBlock cmt,\n+            JavadocTagType tagType)\n     {\n-        final String[] text \u003d aCmt.getText();\n+        final String[] text \u003d cmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n         Pattern blockTagPattern \u003d\n                 Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n-            if ((aTagType.equals(JavadocTagType.ALL) || aTagType\n+            if ((tagType.equals(JavadocTagType.ALL) || tagType\n                     .equals(JavadocTagType.BLOCK)) \u0026\u0026 blockTagMatcher.find())\n             {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n-                final int line \u003d aCmt.getStartLineNo() + i;\n+                final int line \u003d cmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n-                    col +\u003d aCmt.getStartColNo();\n+                    col +\u003d cmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n                     tags.add(\n                             new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n-            else if (aTagType.equals(JavadocTagType.ALL)\n-                    || aTagType.equals(JavadocTagType.INLINE))\n+            else if (tagType.equals(JavadocTagType.ALL)\n+                    || tagType.equals(JavadocTagType.INLINE))\n             {\n-                // Match JavaDoc text after comment characters\n+                // Match Javadoc text after comment characters\n                 final Pattern commentPattern \u003d\n                         Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                 final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n                 if (!commentMatcher.find()) {\n                     commentContents \u003d s; // No leading asterisks, still valid\n                     commentOffset \u003d 0;\n                 }\n                 else {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n                 final Pattern tagPattern \u003d\n                         Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                 final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n                     if (tagMatcher.groupCount() \u003d\u003d 2) {\n                         final String tagName \u003d tagMatcher.group(1);\n                         final String tagValue \u003d tagMatcher.group(2).trim();\n-                        final int line \u003d aCmt.getStartLineNo() + i;\n+                        final int line \u003d cmt.getStartLineNo() + i;\n                         int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                         if (i \u003d\u003d 0) {\n-                            col +\u003d aCmt.getStartColNo();\n+                            col +\u003d cmt.getStartColNo();\n                         }\n                         if (JavadocTagInfo.isValidName(tagName)) {\n                             tags.add(new JavadocTag(line, col, tagName,\n                                     tagValue));\n                         }\n                         else {\n                             invalidTags.add(new InvalidJavadocTag(line, col,\n                                     tagName));\n                         }\n                     }\n-                    // else Error: Unexpected match count for inline JavaDoc\n+                    // else Error: Unexpected match count for inline Javadoc\n                     // tag!\n                 }\n             }\n             blockTagPattern \u003d\n                     Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public static JavadocTags getJavadocTags(TextBlock cmt,\n            JavadocTagType tagType)\n    {\n        final String[] text \u003d cmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d\n                Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((tagType.equals(JavadocTagType.ALL) || tagType\n                    .equals(JavadocTagType.BLOCK)) \u0026\u0026 blockTagMatcher.find())\n            {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d cmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d cmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                            new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType.equals(JavadocTagType.ALL)\n                    || tagType.equals(JavadocTagType.INLINE))\n            {\n                // Match Javadoc text after comment characters\n                final Pattern commentPattern \u003d\n                        Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                final String commentContents;\n                final int commentOffset; // offset including comment characters\n                if (!commentMatcher.find()) {\n                    commentContents \u003d s; // No leading asterisks, still valid\n                    commentOffset \u003d 0;\n                }\n                else {\n                    commentContents \u003d commentMatcher.group(1);\n                    commentOffset \u003d commentMatcher.start(1) - 1;\n                }\n                final Pattern tagPattern \u003d\n                        Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                while (tagMatcher.find()) {\n                    if (tagMatcher.groupCount() \u003d\u003d 2) {\n                        final String tagName \u003d tagMatcher.group(1);\n                        final String tagValue \u003d tagMatcher.group(2).trim();\n                        final int line \u003d cmt.getStartLineNo() + i;\n                        int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                        if (i \u003d\u003d 0) {\n                            col +\u003d cmt.getStartColNo();\n                        }\n                        if (JavadocTagInfo.isValidName(tagName)) {\n                            tags.add(new JavadocTag(line, col, tagName,\n                                    tagValue));\n                        }\n                        else {\n                            invalidTags.add(new InvalidJavadocTag(line, col,\n                                    tagName));\n                        }\n                    }\n                    // else Error: Unexpected match count for inline Javadoc\n                    // tag!\n                }\n            }\n            blockTagPattern \u003d\n                    Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java",
          "extendedDetails": {}
        }
      ]
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": "04/03/14 9:18 AM",
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": "26/02/14 10:35 PM",
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock aCmt,\n                                             JavadocTagType aTagType)\n    {\n        final String[] text \u003d aCmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d\n            Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((aTagType.equals(JavadocTagType.ALL) || aTagType\n                    .equals(JavadocTagType.BLOCK)) \u0026\u0026 blockTagMatcher.find())\n            {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d aCmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d aCmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                        new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (aTagType.equals(JavadocTagType.ALL)\n                    || aTagType.equals(JavadocTagType.INLINE))\n            {\n                // Match JavaDoc text after comment characters\n                final Pattern commentPattern \u003d\n                    Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                final String commentContents;\n                final int commentOffset; // offset including comment characters\n                if (!commentMatcher.find()) {\n                    commentContents \u003d s; // No leading asterisks, still valid\n                    commentOffset \u003d 0;\n                }\n                else {\n                    commentContents \u003d commentMatcher.group(1);\n                    commentOffset \u003d commentMatcher.start(1) - 1;\n                }\n                final Pattern tagPattern \u003d\n                    Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                while (tagMatcher.find()) {\n                    if (tagMatcher.groupCount() \u003d\u003d 2) {\n                        final String tagName \u003d tagMatcher.group(1);\n                        final String tagValue \u003d tagMatcher.group(2).trim();\n                        final int line \u003d aCmt.getStartLineNo() + i;\n                        int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                        if (i \u003d\u003d 0) {\n                            col +\u003d aCmt.getStartColNo();\n                        }\n                        if (JavadocTagInfo.isValidName(tagName)) {\n                            tags.add(new JavadocTag(line, col, tagName,\n                                    tagValue));\n                        }\n                        else {\n                            invalidTags.add(new InvalidJavadocTag(line, col,\n                                    tagName));\n                        }\n                    }\n                    // else Error: Unexpected match count for inline JavaDoc\n                    // tag!\n                }\n            }\n            blockTagPattern \u003d\n                Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java",
      "extendedDetails": {
        "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java"
      }
    },
    "d8286130e83dc672d30cd00eddbf6b5f77112521": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Make the code \"checkstyle compliant\"\n",
      "commitDate": "11/07/11 6:47 PM",
      "commitName": "d8286130e83dc672d30cd00eddbf6b5f77112521",
      "commitAuthor": "Oliver Burn",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Make the code \"checkstyle compliant\"\n",
          "commitDate": "11/07/11 6:47 PM",
          "commitName": "d8286130e83dc672d30cd00eddbf6b5f77112521",
          "commitAuthor": "Oliver Burn",
          "commitDateOld": "11/07/11 5:58 PM",
          "commitNameOld": "7d097b6fa682f8dcfedd95da2db8fed980c51705",
          "commitAuthorOld": "Oliver Burn",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,80 @@\n     public static JavadocTags getJavadocTags(TextBlock aCmt,\n-                                             JavadocTagType tagType)\n+                                             JavadocTagType aTagType)\n     {\n         final String[] text \u003d aCmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n-        Pattern blockTagPattern \u003d Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n+        Pattern blockTagPattern \u003d\n+            Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n-            if ((tagType.equals(JavadocTagType.ALL) ||\n-                  tagType.equals(JavadocTagType.BLOCK))\n-                \u0026\u0026 blockTagMatcher.find()) {\n+            if ((aTagType.equals(JavadocTagType.ALL) || aTagType\n+                    .equals(JavadocTagType.BLOCK)) \u0026\u0026 blockTagMatcher.find())\n+            {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n-                int line \u003d aCmt.getStartLineNo() + i;\n+                final int line \u003d aCmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aCmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n-                    tags.add(new JavadocTag(line, col, tagName, content.trim()));\n+                    tags.add(\n+                        new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n-            else if (tagType.equals(JavadocTagType.ALL) ||\n-                     tagType.equals(JavadocTagType.INLINE)) {\n+            else if (aTagType.equals(JavadocTagType.ALL)\n+                    || aTagType.equals(JavadocTagType.INLINE))\n+            {\n                 // Match JavaDoc text after comment characters\n-                Pattern commentPattern \u003d Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n-                Matcher commentMatcher \u003d commentPattern.matcher(s);\n+                final Pattern commentPattern \u003d\n+                    Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n+                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n                 if (!commentMatcher.find()) {\n                     commentContents \u003d s; // No leading asterisks, still valid\n                     commentOffset \u003d 0;\n                 }\n                 else {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n-                Pattern tagPattern \u003d Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n-                Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n+                final Pattern tagPattern \u003d\n+                    Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n+                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n                     if (tagMatcher.groupCount() \u003d\u003d 2) {\n-                        String tagName \u003d tagMatcher.group(1);\n-                        String tagValue \u003d tagMatcher.group(2).trim();\n-                        int line \u003d aCmt.getStartLineNo() + i;\n+                        final String tagName \u003d tagMatcher.group(1);\n+                        final String tagValue \u003d tagMatcher.group(2).trim();\n+                        final int line \u003d aCmt.getStartLineNo() + i;\n                         int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                         if (i \u003d\u003d 0) {\n                             col +\u003d aCmt.getStartColNo();\n                         }\n                         if (JavadocTagInfo.isValidName(tagName)) {\n-                            tags.add(new JavadocTag(\n-                                line, col, tagName, tagValue));\n+                            tags.add(new JavadocTag(line, col, tagName,\n+                                    tagValue));\n                         }\n                         else {\n-                            invalidTags.add(new InvalidJavadocTag(\n-                                line, col, tagName));\n+                            invalidTags.add(new InvalidJavadocTag(line, col,\n+                                    tagName));\n                         }\n                     }\n-                    //else Error: Unexpected match count for inline JavaDoc tag!\n+                    // else Error: Unexpected match count for inline JavaDoc\n+                    // tag!\n                 }\n             }\n-            blockTagPattern \u003d Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n+            blockTagPattern \u003d\n+                Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public static JavadocTags getJavadocTags(TextBlock aCmt,\n                                             JavadocTagType aTagType)\n    {\n        final String[] text \u003d aCmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d\n            Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((aTagType.equals(JavadocTagType.ALL) || aTagType\n                    .equals(JavadocTagType.BLOCK)) \u0026\u0026 blockTagMatcher.find())\n            {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d aCmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d aCmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                        new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (aTagType.equals(JavadocTagType.ALL)\n                    || aTagType.equals(JavadocTagType.INLINE))\n            {\n                // Match JavaDoc text after comment characters\n                final Pattern commentPattern \u003d\n                    Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                final String commentContents;\n                final int commentOffset; // offset including comment characters\n                if (!commentMatcher.find()) {\n                    commentContents \u003d s; // No leading asterisks, still valid\n                    commentOffset \u003d 0;\n                }\n                else {\n                    commentContents \u003d commentMatcher.group(1);\n                    commentOffset \u003d commentMatcher.start(1) - 1;\n                }\n                final Pattern tagPattern \u003d\n                    Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                while (tagMatcher.find()) {\n                    if (tagMatcher.groupCount() \u003d\u003d 2) {\n                        final String tagName \u003d tagMatcher.group(1);\n                        final String tagValue \u003d tagMatcher.group(2).trim();\n                        final int line \u003d aCmt.getStartLineNo() + i;\n                        int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                        if (i \u003d\u003d 0) {\n                            col +\u003d aCmt.getStartColNo();\n                        }\n                        if (JavadocTagInfo.isValidName(tagName)) {\n                            tags.add(new JavadocTag(line, col, tagName,\n                                    tagValue));\n                        }\n                        else {\n                            invalidTags.add(new InvalidJavadocTag(line, col,\n                                    tagName));\n                        }\n                    }\n                    // else Error: Unexpected match count for inline JavaDoc\n                    // tag!\n                }\n            }\n            blockTagPattern \u003d\n                Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java",
          "extendedDetails": {
            "oldValue": "[aCmt-TextBlock, tagType-JavadocTagType]",
            "newValue": "[aCmt-TextBlock, aTagType-JavadocTagType]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Make the code \"checkstyle compliant\"\n",
          "commitDate": "11/07/11 6:47 PM",
          "commitName": "d8286130e83dc672d30cd00eddbf6b5f77112521",
          "commitAuthor": "Oliver Burn",
          "commitDateOld": "11/07/11 5:58 PM",
          "commitNameOld": "7d097b6fa682f8dcfedd95da2db8fed980c51705",
          "commitAuthorOld": "Oliver Burn",
          "daysBetweenCommits": 0.03,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,80 @@\n     public static JavadocTags getJavadocTags(TextBlock aCmt,\n-                                             JavadocTagType tagType)\n+                                             JavadocTagType aTagType)\n     {\n         final String[] text \u003d aCmt.getText();\n         final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n         final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n-        Pattern blockTagPattern \u003d Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n+        Pattern blockTagPattern \u003d\n+            Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         for (int i \u003d 0; i \u003c text.length; i++) {\n             final String s \u003d text[i];\n             final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n-            if ((tagType.equals(JavadocTagType.ALL) ||\n-                  tagType.equals(JavadocTagType.BLOCK))\n-                \u0026\u0026 blockTagMatcher.find()) {\n+            if ((aTagType.equals(JavadocTagType.ALL) || aTagType\n+                    .equals(JavadocTagType.BLOCK)) \u0026\u0026 blockTagMatcher.find())\n+            {\n                 final String tagName \u003d blockTagMatcher.group(1);\n                 String content \u003d s.substring(blockTagMatcher.end(1));\n                 if (content.endsWith(\"*/\")) {\n                     content \u003d content.substring(0, content.length() - 2);\n                 }\n-                int line \u003d aCmt.getStartLineNo() + i;\n+                final int line \u003d aCmt.getStartLineNo() + i;\n                 int col \u003d blockTagMatcher.start(1) - 1;\n                 if (i \u003d\u003d 0) {\n                     col +\u003d aCmt.getStartColNo();\n                 }\n                 if (JavadocTagInfo.isValidName(tagName)) {\n-                    tags.add(new JavadocTag(line, col, tagName, content.trim()));\n+                    tags.add(\n+                        new JavadocTag(line, col, tagName, content.trim()));\n                 }\n                 else {\n                     invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                 }\n             }\n             // No block tag, so look for inline validTags\n-            else if (tagType.equals(JavadocTagType.ALL) ||\n-                     tagType.equals(JavadocTagType.INLINE)) {\n+            else if (aTagType.equals(JavadocTagType.ALL)\n+                    || aTagType.equals(JavadocTagType.INLINE))\n+            {\n                 // Match JavaDoc text after comment characters\n-                Pattern commentPattern \u003d Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n-                Matcher commentMatcher \u003d commentPattern.matcher(s);\n+                final Pattern commentPattern \u003d\n+                    Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n+                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                 final String commentContents;\n                 final int commentOffset; // offset including comment characters\n                 if (!commentMatcher.find()) {\n                     commentContents \u003d s; // No leading asterisks, still valid\n                     commentOffset \u003d 0;\n                 }\n                 else {\n                     commentContents \u003d commentMatcher.group(1);\n                     commentOffset \u003d commentMatcher.start(1) - 1;\n                 }\n-                Pattern tagPattern \u003d Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n-                Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n+                final Pattern tagPattern \u003d\n+                    Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n+                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                 while (tagMatcher.find()) {\n                     if (tagMatcher.groupCount() \u003d\u003d 2) {\n-                        String tagName \u003d tagMatcher.group(1);\n-                        String tagValue \u003d tagMatcher.group(2).trim();\n-                        int line \u003d aCmt.getStartLineNo() + i;\n+                        final String tagName \u003d tagMatcher.group(1);\n+                        final String tagValue \u003d tagMatcher.group(2).trim();\n+                        final int line \u003d aCmt.getStartLineNo() + i;\n                         int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                         if (i \u003d\u003d 0) {\n                             col +\u003d aCmt.getStartColNo();\n                         }\n                         if (JavadocTagInfo.isValidName(tagName)) {\n-                            tags.add(new JavadocTag(\n-                                line, col, tagName, tagValue));\n+                            tags.add(new JavadocTag(line, col, tagName,\n+                                    tagValue));\n                         }\n                         else {\n-                            invalidTags.add(new InvalidJavadocTag(\n-                                line, col, tagName));\n+                            invalidTags.add(new InvalidJavadocTag(line, col,\n+                                    tagName));\n                         }\n                     }\n-                    //else Error: Unexpected match count for inline JavaDoc tag!\n+                    // else Error: Unexpected match count for inline JavaDoc\n+                    // tag!\n                 }\n             }\n-            blockTagPattern \u003d Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n+            blockTagPattern \u003d\n+                Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n         }\n         return new JavadocTags(tags, invalidTags);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public static JavadocTags getJavadocTags(TextBlock aCmt,\n                                             JavadocTagType aTagType)\n    {\n        final String[] text \u003d aCmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d\n            Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((aTagType.equals(JavadocTagType.ALL) || aTagType\n                    .equals(JavadocTagType.BLOCK)) \u0026\u0026 blockTagMatcher.find())\n            {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                final int line \u003d aCmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d aCmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(\n                        new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (aTagType.equals(JavadocTagType.ALL)\n                    || aTagType.equals(JavadocTagType.INLINE))\n            {\n                // Match JavaDoc text after comment characters\n                final Pattern commentPattern \u003d\n                    Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                final Matcher commentMatcher \u003d commentPattern.matcher(s);\n                final String commentContents;\n                final int commentOffset; // offset including comment characters\n                if (!commentMatcher.find()) {\n                    commentContents \u003d s; // No leading asterisks, still valid\n                    commentOffset \u003d 0;\n                }\n                else {\n                    commentContents \u003d commentMatcher.group(1);\n                    commentOffset \u003d commentMatcher.start(1) - 1;\n                }\n                final Pattern tagPattern \u003d\n                    Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                final Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                while (tagMatcher.find()) {\n                    if (tagMatcher.groupCount() \u003d\u003d 2) {\n                        final String tagName \u003d tagMatcher.group(1);\n                        final String tagValue \u003d tagMatcher.group(2).trim();\n                        final int line \u003d aCmt.getStartLineNo() + i;\n                        int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                        if (i \u003d\u003d 0) {\n                            col +\u003d aCmt.getStartColNo();\n                        }\n                        if (JavadocTagInfo.isValidName(tagName)) {\n                            tags.add(new JavadocTag(line, col, tagName,\n                                    tagValue));\n                        }\n                        else {\n                            invalidTags.add(new InvalidJavadocTag(line, col,\n                                    tagName));\n                        }\n                    }\n                    // else Error: Unexpected match count for inline JavaDoc\n                    // tag!\n                }\n            }\n            blockTagPattern \u003d\n                Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
          "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java",
          "extendedDetails": {}
        }
      ]
    },
    "7d097b6fa682f8dcfedd95da2db8fed980c51705": {
      "type": "Yintroduced",
      "commitMessage": "Initial import of patch #3267984.\nStill work to be done\n",
      "commitDate": "11/07/11 5:58 PM",
      "commitName": "7d097b6fa682f8dcfedd95da2db8fed980c51705",
      "commitAuthor": "Oliver Burn",
      "diff": "@@ -0,0 +1,73 @@\n+    public static JavadocTags getJavadocTags(TextBlock aCmt,\n+                                             JavadocTagType tagType)\n+    {\n+        final String[] text \u003d aCmt.getText();\n+        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n+        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n+        Pattern blockTagPattern \u003d Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n+        for (int i \u003d 0; i \u003c text.length; i++) {\n+            final String s \u003d text[i];\n+            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n+            if ((tagType.equals(JavadocTagType.ALL) ||\n+                  tagType.equals(JavadocTagType.BLOCK))\n+                \u0026\u0026 blockTagMatcher.find()) {\n+                final String tagName \u003d blockTagMatcher.group(1);\n+                String content \u003d s.substring(blockTagMatcher.end(1));\n+                if (content.endsWith(\"*/\")) {\n+                    content \u003d content.substring(0, content.length() - 2);\n+                }\n+                int line \u003d aCmt.getStartLineNo() + i;\n+                int col \u003d blockTagMatcher.start(1) - 1;\n+                if (i \u003d\u003d 0) {\n+                    col +\u003d aCmt.getStartColNo();\n+                }\n+                if (JavadocTagInfo.isValidName(tagName)) {\n+                    tags.add(new JavadocTag(line, col, tagName, content.trim()));\n+                }\n+                else {\n+                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n+                }\n+            }\n+            // No block tag, so look for inline validTags\n+            else if (tagType.equals(JavadocTagType.ALL) ||\n+                     tagType.equals(JavadocTagType.INLINE)) {\n+                // Match JavaDoc text after comment characters\n+                Pattern commentPattern \u003d Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n+                Matcher commentMatcher \u003d commentPattern.matcher(s);\n+                final String commentContents;\n+                final int commentOffset; // offset including comment characters\n+                if (!commentMatcher.find()) {\n+                    commentContents \u003d s; // No leading asterisks, still valid\n+                    commentOffset \u003d 0;\n+                }\n+                else {\n+                    commentContents \u003d commentMatcher.group(1);\n+                    commentOffset \u003d commentMatcher.start(1) - 1;\n+                }\n+                Pattern tagPattern \u003d Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n+                Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n+                while (tagMatcher.find()) {\n+                    if (tagMatcher.groupCount() \u003d\u003d 2) {\n+                        String tagName \u003d tagMatcher.group(1);\n+                        String tagValue \u003d tagMatcher.group(2).trim();\n+                        int line \u003d aCmt.getStartLineNo() + i;\n+                        int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n+                        if (i \u003d\u003d 0) {\n+                            col +\u003d aCmt.getStartColNo();\n+                        }\n+                        if (JavadocTagInfo.isValidName(tagName)) {\n+                            tags.add(new JavadocTag(\n+                                line, col, tagName, tagValue));\n+                        }\n+                        else {\n+                            invalidTags.add(new InvalidJavadocTag(\n+                                line, col, tagName));\n+                        }\n+                    }\n+                    //else Error: Unexpected match count for inline JavaDoc tag!\n+                }\n+            }\n+            blockTagPattern \u003d Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n+        }\n+        return new JavadocTags(tags, invalidTags);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public static JavadocTags getJavadocTags(TextBlock aCmt,\n                                             JavadocTagType tagType)\n    {\n        final String[] text \u003d aCmt.getText();\n        final List\u003cJavadocTag\u003e tags \u003d Lists.newArrayList();\n        final List\u003cInvalidJavadocTag\u003e invalidTags \u003d Lists.newArrayList();\n        Pattern blockTagPattern \u003d Utils.getPattern(\"/\\\\*{2,}\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        for (int i \u003d 0; i \u003c text.length; i++) {\n            final String s \u003d text[i];\n            final Matcher blockTagMatcher \u003d blockTagPattern.matcher(s);\n            if ((tagType.equals(JavadocTagType.ALL) ||\n                  tagType.equals(JavadocTagType.BLOCK))\n                \u0026\u0026 blockTagMatcher.find()) {\n                final String tagName \u003d blockTagMatcher.group(1);\n                String content \u003d s.substring(blockTagMatcher.end(1));\n                if (content.endsWith(\"*/\")) {\n                    content \u003d content.substring(0, content.length() - 2);\n                }\n                int line \u003d aCmt.getStartLineNo() + i;\n                int col \u003d blockTagMatcher.start(1) - 1;\n                if (i \u003d\u003d 0) {\n                    col +\u003d aCmt.getStartColNo();\n                }\n                if (JavadocTagInfo.isValidName(tagName)) {\n                    tags.add(new JavadocTag(line, col, tagName, content.trim()));\n                }\n                else {\n                    invalidTags.add(new InvalidJavadocTag(line, col, tagName));\n                }\n            }\n            // No block tag, so look for inline validTags\n            else if (tagType.equals(JavadocTagType.ALL) ||\n                     tagType.equals(JavadocTagType.INLINE)) {\n                // Match JavaDoc text after comment characters\n                Pattern commentPattern \u003d Utils.getPattern(\"^\\\\s*(?:/\\\\*{2,}|\\\\*+)\\\\s*(.*)\");\n                Matcher commentMatcher \u003d commentPattern.matcher(s);\n                final String commentContents;\n                final int commentOffset; // offset including comment characters\n                if (!commentMatcher.find()) {\n                    commentContents \u003d s; // No leading asterisks, still valid\n                    commentOffset \u003d 0;\n                }\n                else {\n                    commentContents \u003d commentMatcher.group(1);\n                    commentOffset \u003d commentMatcher.start(1) - 1;\n                }\n                Pattern tagPattern \u003d Utils.getPattern(\".*?\\\\{@(\\\\p{Alpha}+)\\\\s+(.*?)\\\\}\");\n                Matcher tagMatcher \u003d tagPattern.matcher(commentContents);\n                while (tagMatcher.find()) {\n                    if (tagMatcher.groupCount() \u003d\u003d 2) {\n                        String tagName \u003d tagMatcher.group(1);\n                        String tagValue \u003d tagMatcher.group(2).trim();\n                        int line \u003d aCmt.getStartLineNo() + i;\n                        int col \u003d commentOffset + (tagMatcher.start(1) - 1);\n                        if (i \u003d\u003d 0) {\n                            col +\u003d aCmt.getStartColNo();\n                        }\n                        if (JavadocTagInfo.isValidName(tagName)) {\n                            tags.add(new JavadocTag(\n                                line, col, tagName, tagValue));\n                        }\n                        else {\n                            invalidTags.add(new InvalidJavadocTag(\n                                line, col, tagName));\n                        }\n                    }\n                    //else Error: Unexpected match count for inline JavaDoc tag!\n                }\n            }\n            blockTagPattern \u003d Utils.getPattern(\"^\\\\s*\\\\**\\\\s*@(\\\\p{Alpha}+)\\\\s\");\n        }\n        return new JavadocTags(tags, invalidTags);\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocUtils.java"
    }
  }
}