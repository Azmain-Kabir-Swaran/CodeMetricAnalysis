{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PkgImportRule.java",
  "functionName": "verifyImport",
  "functionId": "verifyImport___forImport-String(modifiers-final)",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportRule.java",
  "functionStartLine": 57,
  "functionEndLine": 82,
  "numCommitsSeen": 37,
  "timeTaken": 2311,
  "changeHistory": [
    "e9b3b9cdede98c359157dd8ccb501901ebe4ca88",
    "3b970321aa2fa100376cd7a19a12e408664030e9",
    "23c8774d2e2fd245de1e5df02758fd23702c565e",
    "eb70f7062f2517a2f7a511090b31789a92c15a2e",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "16dac636b246c658cad31ee9b2e45c53b851d4f2",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "e292d5fa53a78828d45565e27d305eb3f7cb9d6a",
    "c38185458ab824874b8465c46b4dc42646440aaa",
    "a5d30bf353dde01376d45fb031d9236b11a835d1"
  ],
  "changeHistoryShort": {
    "e9b3b9cdede98c359157dd8ccb501901ebe4ca88": "Ymultichange(Ymovefromfile,Ybodychange)",
    "3b970321aa2fa100376cd7a19a12e408664030e9": "Ymodifierchange",
    "23c8774d2e2fd245de1e5df02758fd23702c565e": "Ybodychange",
    "eb70f7062f2517a2f7a511090b31789a92c15a2e": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "16dac636b246c658cad31ee9b2e45c53b851d4f2": "Ymultichange(Yparameterchange,Ybodychange)",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "e292d5fa53a78828d45565e27d305eb3f7cb9d6a": "Ybodychange",
    "c38185458ab824874b8465c46b4dc42646440aaa": "Yparameterchange",
    "a5d30bf353dde01376d45fb031d9236b11a835d1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e9b3b9cdede98c359157dd8ccb501901ebe4ca88": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "Issue #3497: Split Guard class in two\n",
      "commitDate": "23/10/16 12:12 PM",
      "commitName": "e9b3b9cdede98c359157dd8ccb501901ebe4ca88",
      "commitAuthor": "Jochen Van de Velde",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "Issue #3497: Split Guard class in two\n",
          "commitDate": "23/10/16 12:12 PM",
          "commitName": "e9b3b9cdede98c359157dd8ccb501901ebe4ca88",
          "commitAuthor": "Jochen Van de Velde",
          "commitDateOld": "23/10/16 10:48 AM",
          "commitNameOld": "27b03291ce489297527b536a855a9b8f8c3d2482",
          "commitAuthorOld": "Roman Ivanov",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,26 @@\n     public AccessResult verifyImport(final String forImport) {\n-        if (className !\u003d null) {\n-            final boolean classMatch;\n-\n-            if (regExp) {\n-                classMatch \u003d forImport.matches(className);\n-            }\n-            else {\n-                classMatch \u003d forImport.equals(className);\n-            }\n-            return calculateResult(classMatch);\n-        }\n-\n-        // Must be checking a package. First check that we actually match\n-        // the package. Then check if matched and we must be an exact match.\n+        // First check that we actually match the package.\n+        // Then check if matched and f we must be an exact match.\n         // In this case, the text after the first \".\" must not contain\n         // another \".\" as this indicates that it is not an exact match.\n+\n         boolean pkgMatch;\n-        if (regExp) {\n+\n+        if (isRegExp()) {\n             pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n+\n             if (pkgMatch \u0026\u0026 exactMatch) {\n                 pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n             }\n         }\n         else {\n             pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n+\n             if (pkgMatch \u0026\u0026 exactMatch) {\n                 pkgMatch \u003d forImport.indexOf(\u0027.\u0027,\n                         pkgName.length() + 1) \u003d\u003d -1;\n             }\n         }\n+\n         return calculateResult(pkgMatch);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public AccessResult verifyImport(final String forImport) {\n        // First check that we actually match the package.\n        // Then check if matched and f we must be an exact match.\n        // In this case, the text after the first \".\" must not contain\n        // another \".\" as this indicates that it is not an exact match.\n\n        boolean pkgMatch;\n\n        if (isRegExp()) {\n            pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n            }\n        }\n        else {\n            pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d forImport.indexOf(\u0027.\u0027,\n                        pkgName.length() + 1) \u003d\u003d -1;\n            }\n        }\n\n        return calculateResult(pkgMatch);\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportRule.java",
          "extendedDetails": {
            "oldPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java",
            "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportRule.java",
            "oldMethodName": "verifyImport",
            "newMethodName": "verifyImport"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Issue #3497: Split Guard class in two\n",
          "commitDate": "23/10/16 12:12 PM",
          "commitName": "e9b3b9cdede98c359157dd8ccb501901ebe4ca88",
          "commitAuthor": "Jochen Van de Velde",
          "commitDateOld": "23/10/16 10:48 AM",
          "commitNameOld": "27b03291ce489297527b536a855a9b8f8c3d2482",
          "commitAuthorOld": "Roman Ivanov",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,26 @@\n     public AccessResult verifyImport(final String forImport) {\n-        if (className !\u003d null) {\n-            final boolean classMatch;\n-\n-            if (regExp) {\n-                classMatch \u003d forImport.matches(className);\n-            }\n-            else {\n-                classMatch \u003d forImport.equals(className);\n-            }\n-            return calculateResult(classMatch);\n-        }\n-\n-        // Must be checking a package. First check that we actually match\n-        // the package. Then check if matched and we must be an exact match.\n+        // First check that we actually match the package.\n+        // Then check if matched and f we must be an exact match.\n         // In this case, the text after the first \".\" must not contain\n         // another \".\" as this indicates that it is not an exact match.\n+\n         boolean pkgMatch;\n-        if (regExp) {\n+\n+        if (isRegExp()) {\n             pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n+\n             if (pkgMatch \u0026\u0026 exactMatch) {\n                 pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n             }\n         }\n         else {\n             pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n+\n             if (pkgMatch \u0026\u0026 exactMatch) {\n                 pkgMatch \u003d forImport.indexOf(\u0027.\u0027,\n                         pkgName.length() + 1) \u003d\u003d -1;\n             }\n         }\n+\n         return calculateResult(pkgMatch);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public AccessResult verifyImport(final String forImport) {\n        // First check that we actually match the package.\n        // Then check if matched and f we must be an exact match.\n        // In this case, the text after the first \".\" must not contain\n        // another \".\" as this indicates that it is not an exact match.\n\n        boolean pkgMatch;\n\n        if (isRegExp()) {\n            pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n            }\n        }\n        else {\n            pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d forImport.indexOf(\u0027.\u0027,\n                        pkgName.length() + 1) \u003d\u003d -1;\n            }\n        }\n\n        return calculateResult(pkgMatch);\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportRule.java",
          "extendedDetails": {}
        }
      ]
    },
    "3b970321aa2fa100376cd7a19a12e408664030e9": {
      "type": "Ymodifierchange",
      "commitMessage": "Issue #957: Resolve PMD DefaultPackage rule problems in imports package\n",
      "commitDate": "18/02/16 6:54 AM",
      "commitName": "3b970321aa2fa100376cd7a19a12e408664030e9",
      "commitAuthor": "Vladislav Lisetskiy",
      "commitDateOld": "04/01/16 4:25 PM",
      "commitNameOld": "617ebf2bf27d284dcc7b866f85439fcf6dab3402",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 44.6,
      "commitsBetweenForRepo": 117,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n-    AccessResult verifyImport(final String forImport) {\n+    public AccessResult verifyImport(final String forImport) {\n         if (className !\u003d null) {\n             final boolean classMatch;\n \n             if (regExp) {\n                 classMatch \u003d forImport.matches(className);\n             }\n             else {\n                 classMatch \u003d forImport.equals(className);\n             }\n             return calculateResult(classMatch);\n         }\n \n         // Must be checking a package. First check that we actually match\n         // the package. Then check if matched and we must be an exact match.\n         // In this case, the text after the first \".\" must not contain\n         // another \".\" as this indicates that it is not an exact match.\n         boolean pkgMatch;\n         if (regExp) {\n             pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n             if (pkgMatch \u0026\u0026 exactMatch) {\n                 pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n             }\n         }\n         else {\n             pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n             if (pkgMatch \u0026\u0026 exactMatch) {\n                 pkgMatch \u003d forImport.indexOf(\u0027.\u0027,\n                         pkgName.length() + 1) \u003d\u003d -1;\n             }\n         }\n         return calculateResult(pkgMatch);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public AccessResult verifyImport(final String forImport) {\n        if (className !\u003d null) {\n            final boolean classMatch;\n\n            if (regExp) {\n                classMatch \u003d forImport.matches(className);\n            }\n            else {\n                classMatch \u003d forImport.equals(className);\n            }\n            return calculateResult(classMatch);\n        }\n\n        // Must be checking a package. First check that we actually match\n        // the package. Then check if matched and we must be an exact match.\n        // In this case, the text after the first \".\" must not contain\n        // another \".\" as this indicates that it is not an exact match.\n        boolean pkgMatch;\n        if (regExp) {\n            pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n            }\n        }\n        else {\n            pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d forImport.indexOf(\u0027.\u0027,\n                        pkgName.length() + 1) \u003d\u003d -1;\n            }\n        }\n        return calculateResult(pkgMatch);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java",
      "extendedDetails": {
        "oldValue": "[]",
        "newValue": "[public]"
      }
    },
    "23c8774d2e2fd245de1e5df02758fd23702c565e": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: AvoidInlineConditional violations fixed\n",
      "commitDate": "16/08/15 9:01 PM",
      "commitName": "23c8774d2e2fd245de1e5df02758fd23702c565e",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": "06/07/15 7:02 AM",
      "commitNameOld": "eb70f7062f2517a2f7a511090b31789a92c15a2e",
      "commitAuthorOld": "Aleksandr Ivanov",
      "daysBetweenCommits": 41.58,
      "commitsBetweenForRepo": 502,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,33 @@\n     AccessResult verifyImport(final String forImport) {\n         if (className !\u003d null) {\n-            final boolean classMatch \u003d regExp\n-                ? forImport.matches(className)\n-                : forImport.equals(className);\n+            final boolean classMatch;\n+\n+            if (regExp) {\n+                classMatch \u003d forImport.matches(className);\n+            }\n+            else {\n+                classMatch \u003d forImport.equals(className);\n+            }\n             return calculateResult(classMatch);\n         }\n \n         // Must be checking a package. First check that we actually match\n         // the package. Then check if matched and we must be an exact match.\n         // In this case, the text after the first \".\" must not contain\n         // another \".\" as this indicates that it is not an exact match.\n         boolean pkgMatch;\n         if (regExp) {\n             pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n             if (pkgMatch \u0026\u0026 exactMatch) {\n                 pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n             }\n         }\n         else {\n             pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n             if (pkgMatch \u0026\u0026 exactMatch) {\n                 pkgMatch \u003d forImport.indexOf(\u0027.\u0027,\n                         pkgName.length() + 1) \u003d\u003d -1;\n             }\n         }\n         return calculateResult(pkgMatch);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    AccessResult verifyImport(final String forImport) {\n        if (className !\u003d null) {\n            final boolean classMatch;\n\n            if (regExp) {\n                classMatch \u003d forImport.matches(className);\n            }\n            else {\n                classMatch \u003d forImport.equals(className);\n            }\n            return calculateResult(classMatch);\n        }\n\n        // Must be checking a package. First check that we actually match\n        // the package. Then check if matched and we must be an exact match.\n        // In this case, the text after the first \".\" must not contain\n        // another \".\" as this indicates that it is not an exact match.\n        boolean pkgMatch;\n        if (regExp) {\n            pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n            }\n        }\n        else {\n            pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d forImport.indexOf(\u0027.\u0027,\n                        pkgName.length() + 1) \u003d\u003d -1;\n            }\n        }\n        return calculateResult(pkgMatch);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java",
      "extendedDetails": {}
    },
    "eb70f7062f2517a2f7a511090b31789a92c15a2e": {
      "type": "Ybodychange",
      "commitMessage": "Removed all assert statements #1298\n",
      "commitDate": "06/07/15 7:02 AM",
      "commitName": "eb70f7062f2517a2f7a511090b31789a92c15a2e",
      "commitAuthor": "Aleksandr Ivanov",
      "commitDateOld": "17/05/15 4:47 AM",
      "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 50.09,
      "commitsBetweenForRepo": 269,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,28 @@\n     AccessResult verifyImport(final String forImport) {\n-        assert forImport !\u003d null;\n         if (className !\u003d null) {\n             final boolean classMatch \u003d regExp\n                 ? forImport.matches(className)\n                 : forImport.equals(className);\n             return calculateResult(classMatch);\n         }\n \n         // Must be checking a package. First check that we actually match\n         // the package. Then check if matched and we must be an exact match.\n         // In this case, the text after the first \".\" must not contain\n         // another \".\" as this indicates that it is not an exact match.\n-        assert pkgName !\u003d null;\n         boolean pkgMatch;\n         if (regExp) {\n             pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n             if (pkgMatch \u0026\u0026 exactMatch) {\n                 pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n             }\n         }\n         else {\n             pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n             if (pkgMatch \u0026\u0026 exactMatch) {\n                 pkgMatch \u003d forImport.indexOf(\u0027.\u0027,\n                         pkgName.length() + 1) \u003d\u003d -1;\n             }\n         }\n         return calculateResult(pkgMatch);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    AccessResult verifyImport(final String forImport) {\n        if (className !\u003d null) {\n            final boolean classMatch \u003d regExp\n                ? forImport.matches(className)\n                : forImport.equals(className);\n            return calculateResult(classMatch);\n        }\n\n        // Must be checking a package. First check that we actually match\n        // the package. Then check if matched and we must be an exact match.\n        // In this case, the text after the first \".\" must not contain\n        // another \".\" as this indicates that it is not an exact match.\n        boolean pkgMatch;\n        if (regExp) {\n            pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n            }\n        }\n        else {\n            pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d forImport.indexOf(\u0027.\u0027,\n                        pkgName.length() + 1) \u003d\u003d -1;\n            }\n        }\n        return calculateResult(pkgMatch);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java",
      "extendedDetails": {}
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": "10/03/15 2:36 PM",
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "18/02/15 1:14 PM",
      "commitNameOld": "c9a9e6508c15e00cf6820b213d79d5ebf41c6343",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 20.02,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n     AccessResult verifyImport(final String forImport)\n     {\n         assert forImport !\u003d null;\n         if (className !\u003d null) {\n             final boolean classMatch \u003d regExp\n                 ? forImport.matches(className)\n                 : forImport.equals(className);\n             return calculateResult(classMatch);\n         }\n \n         // Must be checking a package. First check that we actually match\n         // the package. Then check if matched and we must be an exact match.\n         // In this case, the text after the first \".\" must not contain\n         // another \".\" as this indicates that it is not an exact match.\n         assert pkgName !\u003d null;\n         boolean pkgMatch;\n         if (regExp) {\n             pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n             if (pkgMatch \u0026\u0026 exactMatch) {\n                 pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n             }\n         }\n         else {\n             pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n             if (pkgMatch \u0026\u0026 exactMatch) {\n-                pkgMatch \u003d (forImport.indexOf(\u0027.\u0027,\n-                    (pkgName.length() + 1)) \u003d\u003d -1);\n+                pkgMatch \u003d forImport.indexOf(\u0027.\u0027,\n+                        pkgName.length() + 1) \u003d\u003d -1;\n             }\n         }\n         return calculateResult(pkgMatch);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    AccessResult verifyImport(final String forImport)\n    {\n        assert forImport !\u003d null;\n        if (className !\u003d null) {\n            final boolean classMatch \u003d regExp\n                ? forImport.matches(className)\n                : forImport.equals(className);\n            return calculateResult(classMatch);\n        }\n\n        // Must be checking a package. First check that we actually match\n        // the package. Then check if matched and we must be an exact match.\n        // In this case, the text after the first \".\" must not contain\n        // another \".\" as this indicates that it is not an exact match.\n        assert pkgName !\u003d null;\n        boolean pkgMatch;\n        if (regExp) {\n            pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n            }\n        }\n        else {\n            pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d forImport.indexOf(\u0027.\u0027,\n                        pkgName.length() + 1) \u003d\u003d -1;\n            }\n        }\n        return calculateResult(pkgMatch);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java",
      "extendedDetails": {}
    },
    "16dac636b246c658cad31ee9b2e45c53b851d4f2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, imports, #512\n",
      "commitDate": "19/01/15 6:35 AM",
      "commitName": "16dac636b246c658cad31ee9b2e45c53b851d4f2",
      "commitAuthor": "alexkravin",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Prefixes, imports, #512\n",
          "commitDate": "19/01/15 6:35 AM",
          "commitName": "16dac636b246c658cad31ee9b2e45c53b851d4f2",
          "commitAuthor": "alexkravin",
          "commitDateOld": "04/03/14 9:18 AM",
          "commitNameOld": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
          "commitAuthorOld": "Ivan Sopov",
          "daysBetweenCommits": 320.89,
          "commitsBetweenForRepo": 471,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,31 @@\n-    AccessResult verifyImport(final String aForImport)\n+    AccessResult verifyImport(final String forImport)\n     {\n-        assert aForImport !\u003d null;\n-        if (mClassName !\u003d null) {\n-            final boolean classMatch \u003d mRegExp\n-                ? aForImport.matches(mClassName)\n-                : aForImport.equals(mClassName);\n+        assert forImport !\u003d null;\n+        if (className !\u003d null) {\n+            final boolean classMatch \u003d regExp\n+                ? forImport.matches(className)\n+                : forImport.equals(className);\n             return calculateResult(classMatch);\n         }\n \n         // Must be checking a package. First check that we actually match\n         // the package. Then check if matched and we must be an exact match.\n         // In this case, the text after the first \".\" must not contain\n         // another \".\" as this indicates that it is not an exact match.\n-        assert mPkgName !\u003d null;\n+        assert pkgName !\u003d null;\n         boolean pkgMatch;\n-        if (mRegExp) {\n-            pkgMatch \u003d aForImport.matches(mPkgName + \"\\\\..*\");\n-            if (pkgMatch \u0026\u0026 mExactMatch) {\n-                pkgMatch \u003d !aForImport.matches(mPkgName + \"\\\\..*\\\\..*\");\n+        if (regExp) {\n+            pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n+            if (pkgMatch \u0026\u0026 exactMatch) {\n+                pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n             }\n         }\n         else {\n-            pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n-            if (pkgMatch \u0026\u0026 mExactMatch) {\n-                pkgMatch \u003d (aForImport.indexOf(\u0027.\u0027,\n-                    (mPkgName.length() + 1)) \u003d\u003d -1);\n+            pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n+            if (pkgMatch \u0026\u0026 exactMatch) {\n+                pkgMatch \u003d (forImport.indexOf(\u0027.\u0027,\n+                    (pkgName.length() + 1)) \u003d\u003d -1);\n             }\n         }\n         return calculateResult(pkgMatch);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    AccessResult verifyImport(final String forImport)\n    {\n        assert forImport !\u003d null;\n        if (className !\u003d null) {\n            final boolean classMatch \u003d regExp\n                ? forImport.matches(className)\n                : forImport.equals(className);\n            return calculateResult(classMatch);\n        }\n\n        // Must be checking a package. First check that we actually match\n        // the package. Then check if matched and we must be an exact match.\n        // In this case, the text after the first \".\" must not contain\n        // another \".\" as this indicates that it is not an exact match.\n        assert pkgName !\u003d null;\n        boolean pkgMatch;\n        if (regExp) {\n            pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n            }\n        }\n        else {\n            pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d (forImport.indexOf(\u0027.\u0027,\n                    (pkgName.length() + 1)) \u003d\u003d -1);\n            }\n        }\n        return calculateResult(pkgMatch);\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java",
          "extendedDetails": {
            "oldValue": "[aForImport-String(modifiers-final)]",
            "newValue": "[forImport-String(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Prefixes, imports, #512\n",
          "commitDate": "19/01/15 6:35 AM",
          "commitName": "16dac636b246c658cad31ee9b2e45c53b851d4f2",
          "commitAuthor": "alexkravin",
          "commitDateOld": "04/03/14 9:18 AM",
          "commitNameOld": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
          "commitAuthorOld": "Ivan Sopov",
          "daysBetweenCommits": 320.89,
          "commitsBetweenForRepo": 471,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,31 @@\n-    AccessResult verifyImport(final String aForImport)\n+    AccessResult verifyImport(final String forImport)\n     {\n-        assert aForImport !\u003d null;\n-        if (mClassName !\u003d null) {\n-            final boolean classMatch \u003d mRegExp\n-                ? aForImport.matches(mClassName)\n-                : aForImport.equals(mClassName);\n+        assert forImport !\u003d null;\n+        if (className !\u003d null) {\n+            final boolean classMatch \u003d regExp\n+                ? forImport.matches(className)\n+                : forImport.equals(className);\n             return calculateResult(classMatch);\n         }\n \n         // Must be checking a package. First check that we actually match\n         // the package. Then check if matched and we must be an exact match.\n         // In this case, the text after the first \".\" must not contain\n         // another \".\" as this indicates that it is not an exact match.\n-        assert mPkgName !\u003d null;\n+        assert pkgName !\u003d null;\n         boolean pkgMatch;\n-        if (mRegExp) {\n-            pkgMatch \u003d aForImport.matches(mPkgName + \"\\\\..*\");\n-            if (pkgMatch \u0026\u0026 mExactMatch) {\n-                pkgMatch \u003d !aForImport.matches(mPkgName + \"\\\\..*\\\\..*\");\n+        if (regExp) {\n+            pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n+            if (pkgMatch \u0026\u0026 exactMatch) {\n+                pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n             }\n         }\n         else {\n-            pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n-            if (pkgMatch \u0026\u0026 mExactMatch) {\n-                pkgMatch \u003d (aForImport.indexOf(\u0027.\u0027,\n-                    (mPkgName.length() + 1)) \u003d\u003d -1);\n+            pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n+            if (pkgMatch \u0026\u0026 exactMatch) {\n+                pkgMatch \u003d (forImport.indexOf(\u0027.\u0027,\n+                    (pkgName.length() + 1)) \u003d\u003d -1);\n             }\n         }\n         return calculateResult(pkgMatch);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    AccessResult verifyImport(final String forImport)\n    {\n        assert forImport !\u003d null;\n        if (className !\u003d null) {\n            final boolean classMatch \u003d regExp\n                ? forImport.matches(className)\n                : forImport.equals(className);\n            return calculateResult(classMatch);\n        }\n\n        // Must be checking a package. First check that we actually match\n        // the package. Then check if matched and we must be an exact match.\n        // In this case, the text after the first \".\" must not contain\n        // another \".\" as this indicates that it is not an exact match.\n        assert pkgName !\u003d null;\n        boolean pkgMatch;\n        if (regExp) {\n            pkgMatch \u003d forImport.matches(pkgName + \"\\\\..*\");\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d !forImport.matches(pkgName + \"\\\\..*\\\\..*\");\n            }\n        }\n        else {\n            pkgMatch \u003d forImport.startsWith(pkgName + \".\");\n            if (pkgMatch \u0026\u0026 exactMatch) {\n                pkgMatch \u003d (forImport.indexOf(\u0027.\u0027,\n                    (pkgName.length() + 1)) \u003d\u003d -1);\n            }\n        }\n        return calculateResult(pkgMatch);\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java",
          "extendedDetails": {}
        }
      ]
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": "04/03/14 9:18 AM",
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": "26/02/14 10:35 PM",
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    AccessResult verifyImport(final String aForImport)\n    {\n        assert aForImport !\u003d null;\n        if (mClassName !\u003d null) {\n            final boolean classMatch \u003d mRegExp\n                ? aForImport.matches(mClassName)\n                : aForImport.equals(mClassName);\n            return calculateResult(classMatch);\n        }\n\n        // Must be checking a package. First check that we actually match\n        // the package. Then check if matched and we must be an exact match.\n        // In this case, the text after the first \".\" must not contain\n        // another \".\" as this indicates that it is not an exact match.\n        assert mPkgName !\u003d null;\n        boolean pkgMatch;\n        if (mRegExp) {\n            pkgMatch \u003d aForImport.matches(mPkgName + \"\\\\..*\");\n            if (pkgMatch \u0026\u0026 mExactMatch) {\n                pkgMatch \u003d !aForImport.matches(mPkgName + \"\\\\..*\\\\..*\");\n            }\n        }\n        else {\n            pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n            if (pkgMatch \u0026\u0026 mExactMatch) {\n                pkgMatch \u003d (aForImport.indexOf(\u0027.\u0027,\n                    (mPkgName.length() + 1)) \u003d\u003d -1);\n            }\n        }\n        return calculateResult(pkgMatch);\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java",
      "extendedDetails": {
        "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java"
      }
    },
    "e292d5fa53a78828d45565e27d305eb3f7cb9d6a": {
      "type": "Ybodychange",
      "commitMessage": "Enhanced the ImportContro check to support regular expressions. Thanks to lbaeumer for patch #2937442.\n",
      "commitDate": "14/02/10 2:24 AM",
      "commitName": "e292d5fa53a78828d45565e27d305eb3f7cb9d6a",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "12/02/10 6:57 PM",
      "commitNameOld": "523080bbf2be11354b94b851ac85d06e7e8a2c14",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 1.31,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,31 @@\n     AccessResult verifyImport(final String aForImport)\n     {\n         assert aForImport !\u003d null;\n         if (mClassName !\u003d null) {\n-            final boolean classMatch \u003d mClassName.equals(aForImport);\n+            final boolean classMatch \u003d mRegExp\n+                ? aForImport.matches(mClassName)\n+                : aForImport.equals(mClassName);\n             return calculateResult(classMatch);\n         }\n \n         // Must be checking a package. First check that we actually match\n         // the package. Then check if matched and we must be an exact match.\n         // In this case, the text after the first \".\" must not contain\n         // another \".\" as this indicates that it is not an exact match.\n         assert mPkgName !\u003d null;\n-        //boolean pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n-        boolean pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n-        if (pkgMatch \u0026\u0026 mExactMatch) {\n-            pkgMatch \u003d (aForImport.indexOf(\u0027.\u0027, (mPkgName.length() + 1)) \u003d\u003d -1);\n+        boolean pkgMatch;\n+        if (mRegExp) {\n+            pkgMatch \u003d aForImport.matches(mPkgName + \"\\\\..*\");\n+            if (pkgMatch \u0026\u0026 mExactMatch) {\n+                pkgMatch \u003d !aForImport.matches(mPkgName + \"\\\\..*\\\\..*\");\n+            }\n+        }\n+        else {\n+            pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n+            if (pkgMatch \u0026\u0026 mExactMatch) {\n+                pkgMatch \u003d (aForImport.indexOf(\u0027.\u0027,\n+                    (mPkgName.length() + 1)) \u003d\u003d -1);\n+            }\n         }\n         return calculateResult(pkgMatch);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    AccessResult verifyImport(final String aForImport)\n    {\n        assert aForImport !\u003d null;\n        if (mClassName !\u003d null) {\n            final boolean classMatch \u003d mRegExp\n                ? aForImport.matches(mClassName)\n                : aForImport.equals(mClassName);\n            return calculateResult(classMatch);\n        }\n\n        // Must be checking a package. First check that we actually match\n        // the package. Then check if matched and we must be an exact match.\n        // In this case, the text after the first \".\" must not contain\n        // another \".\" as this indicates that it is not an exact match.\n        assert mPkgName !\u003d null;\n        boolean pkgMatch;\n        if (mRegExp) {\n            pkgMatch \u003d aForImport.matches(mPkgName + \"\\\\..*\");\n            if (pkgMatch \u0026\u0026 mExactMatch) {\n                pkgMatch \u003d !aForImport.matches(mPkgName + \"\\\\..*\\\\..*\");\n            }\n        }\n        else {\n            pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n            if (pkgMatch \u0026\u0026 mExactMatch) {\n                pkgMatch \u003d (aForImport.indexOf(\u0027.\u0027,\n                    (mPkgName.length() + 1)) \u003d\u003d -1);\n            }\n        }\n        return calculateResult(pkgMatch);\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java",
      "extendedDetails": {}
    },
    "c38185458ab824874b8465c46b4dc42646440aaa": {
      "type": "Yparameterchange",
      "commitMessage": "Code cleanup\n",
      "commitDate": "21/01/06 4:43 AM",
      "commitName": "c38185458ab824874b8465c46b4dc42646440aaa",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "31/07/05 5:27 AM",
      "commitNameOld": "a5d30bf353dde01376d45fb031d9236b11a835d1",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 174.01,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,20 @@\n-    AccessResult verifyImport(final String aForImport, final String aInPkg)\n+    AccessResult verifyImport(final String aForImport)\n     {\n         assert aForImport !\u003d null;\n         if (mClassName !\u003d null) {\n             final boolean classMatch \u003d mClassName.equals(aForImport);\n             return calculateResult(classMatch);\n         }\n \n         // Must be checking a package. First check that we actually match\n         // the package. Then check if matched and we must be an exact match.\n         // In this case, the text after the first \".\" must not contain\n         // another \".\" as this indicates that it is not an exact match.\n         assert mPkgName !\u003d null;\n         //boolean pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n         boolean pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n         if (pkgMatch \u0026\u0026 mExactMatch) {\n             pkgMatch \u003d (aForImport.indexOf(\u0027.\u0027, (mPkgName.length() + 1)) \u003d\u003d -1);\n         }\n         return calculateResult(pkgMatch);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    AccessResult verifyImport(final String aForImport)\n    {\n        assert aForImport !\u003d null;\n        if (mClassName !\u003d null) {\n            final boolean classMatch \u003d mClassName.equals(aForImport);\n            return calculateResult(classMatch);\n        }\n\n        // Must be checking a package. First check that we actually match\n        // the package. Then check if matched and we must be an exact match.\n        // In this case, the text after the first \".\" must not contain\n        // another \".\" as this indicates that it is not an exact match.\n        assert mPkgName !\u003d null;\n        //boolean pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n        boolean pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n        if (pkgMatch \u0026\u0026 mExactMatch) {\n            pkgMatch \u003d (aForImport.indexOf(\u0027.\u0027, (mPkgName.length() + 1)) \u003d\u003d -1);\n        }\n        return calculateResult(pkgMatch);\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java",
      "extendedDetails": {
        "oldValue": "[aForImport-String(modifiers-final), aInPkg-String(modifiers-final)]",
        "newValue": "[aForImport-String(modifiers-final)]"
      }
    },
    "a5d30bf353dde01376d45fb031d9236b11a835d1": {
      "type": "Yintroduced",
      "commitMessage": "Added a lot more configuration options for the ImportControlCheck that\ncame out of using at work. I still need to improve the unit tests and\nproperly document the support options. Wanted to check in now for\nbackup.\n",
      "commitDate": "31/07/05 5:27 AM",
      "commitName": "a5d30bf353dde01376d45fb031d9236b11a835d1",
      "commitAuthor": "Oliver Burn",
      "diff": "@@ -0,0 +1,20 @@\n+    AccessResult verifyImport(final String aForImport, final String aInPkg)\n+    {\n+        assert aForImport !\u003d null;\n+        if (mClassName !\u003d null) {\n+            final boolean classMatch \u003d mClassName.equals(aForImport);\n+            return calculateResult(classMatch);\n+        }\n+\n+        // Must be checking a package. First check that we actually match\n+        // the package. Then check if matched and we must be an exact match.\n+        // In this case, the text after the first \".\" must not contain\n+        // another \".\" as this indicates that it is not an exact match.\n+        assert mPkgName !\u003d null;\n+        //boolean pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n+        boolean pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n+        if (pkgMatch \u0026\u0026 mExactMatch) {\n+            pkgMatch \u003d (aForImport.indexOf(\u0027.\u0027, (mPkgName.length() + 1)) \u003d\u003d -1);\n+        }\n+        return calculateResult(pkgMatch);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    AccessResult verifyImport(final String aForImport, final String aInPkg)\n    {\n        assert aForImport !\u003d null;\n        if (mClassName !\u003d null) {\n            final boolean classMatch \u003d mClassName.equals(aForImport);\n            return calculateResult(classMatch);\n        }\n\n        // Must be checking a package. First check that we actually match\n        // the package. Then check if matched and we must be an exact match.\n        // In this case, the text after the first \".\" must not contain\n        // another \".\" as this indicates that it is not an exact match.\n        assert mPkgName !\u003d null;\n        //boolean pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n        boolean pkgMatch \u003d aForImport.startsWith(mPkgName + \".\");\n        if (pkgMatch \u0026\u0026 mExactMatch) {\n            pkgMatch \u003d (aForImport.indexOf(\u0027.\u0027, (mPkgName.length() + 1)) \u003d\u003d -1);\n        }\n        return calculateResult(pkgMatch);\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/Guard.java"
    }
  }
}