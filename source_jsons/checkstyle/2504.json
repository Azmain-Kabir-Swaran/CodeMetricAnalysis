{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CustomImportOrderCheck.java",
  "functionName": "finishImportList",
  "functionId": "finishImportList",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java",
  "functionStartLine": 562,
  "functionEndLine": 607,
  "numCommitsSeen": 100,
  "timeTaken": 2899,
  "changeHistory": [
    "9835f7fc36f4e9589704d982762e547c60036562",
    "9a7a8e15ed9820f3b325ef2fd2f7e3295c17d6b3",
    "018b52126dd3ddf58a47dadbe5f1b7ca5c7ffd3d",
    "4ba514bf6e685f3fedf58c27276793249284a9ae",
    "69f5ff0d9dabc50ca2ca08826acff810c9df453e",
    "5615664ca5d775db468c81e61f19bd6b818a14ed",
    "914dd9994c9f108f54849a96bc35bbdd85de1053",
    "39b343a32a4f1ce18ee98a34618fda0a5404d6a0"
  ],
  "changeHistoryShort": {
    "9835f7fc36f4e9589704d982762e547c60036562": "Ybodychange",
    "9a7a8e15ed9820f3b325ef2fd2f7e3295c17d6b3": "Ybodychange",
    "018b52126dd3ddf58a47dadbe5f1b7ca5c7ffd3d": "Ybodychange",
    "4ba514bf6e685f3fedf58c27276793249284a9ae": "Ybodychange",
    "69f5ff0d9dabc50ca2ca08826acff810c9df453e": "Ybodychange",
    "5615664ca5d775db468c81e61f19bd6b818a14ed": "Ybodychange",
    "914dd9994c9f108f54849a96bc35bbdd85de1053": "Ybodychange",
    "39b343a32a4f1ce18ee98a34618fda0a5404d6a0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9835f7fc36f4e9589704d982762e547c60036562": {
      "type": "Ybodychange",
      "commitMessage": "Issue #7128: CustomImportOrderCheck.customImportOrderRules does not support the default value\n",
      "commitDate": "13/04/20 7:50 AM",
      "commitName": "9835f7fc36f4e9589704d982762e547c60036562",
      "commitAuthor": "wltan",
      "commitDateOld": "20/03/20 4:49 AM",
      "commitNameOld": "2705595ee9925dfd2bfe691aa119658206557240",
      "commitAuthorOld": "malintha1996",
      "daysBetweenCommits": 24.13,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n     private void finishImportList() {\n         String currentGroup \u003d getFirstGroup();\n-        int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n+        int currentGroupNumber \u003d customOrderRules.indexOf(currentGroup);\n         ImportDetails previousImportObjectFromCurrentGroup \u003d null;\n         String previousImportFromCurrentGroup \u003d null;\n \n         for (ImportDetails importObject : importToGroupList) {\n             final String importGroup \u003d importObject.getImportGroup();\n             final String fullImportIdent \u003d importObject.getImportFullPath();\n \n             if (importGroup.equals(currentGroup)) {\n                 validateExtraEmptyLine(previousImportObjectFromCurrentGroup,\n                         importObject, fullImportIdent);\n                 if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {\n                     log(importObject.getStartLineNumber(), MSG_LEX,\n                             fullImportIdent, previousImportFromCurrentGroup);\n                 }\n                 else {\n                     previousImportFromCurrentGroup \u003d fullImportIdent;\n                 }\n                 previousImportObjectFromCurrentGroup \u003d importObject;\n             }\n             else {\n                 // not the last group, last one is always NON_GROUP\n-                if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n+                if (customOrderRules.size() \u003e currentGroupNumber + 1) {\n                     final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                     if (importGroup.equals(nextGroup)) {\n                         validateMissedEmptyLine(previousImportObjectFromCurrentGroup,\n                                 importObject, fullImportIdent);\n                         currentGroup \u003d nextGroup;\n-                        currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n+                        currentGroupNumber \u003d customOrderRules.indexOf(nextGroup);\n                         previousImportFromCurrentGroup \u003d fullImportIdent;\n                     }\n                     else {\n                         logWrongImportGroupOrder(importObject.getStartLineNumber(),\n                                 importGroup, nextGroup, fullImportIdent);\n                     }\n                     previousImportObjectFromCurrentGroup \u003d importObject;\n                 }\n                 else {\n                     logWrongImportGroupOrder(importObject.getStartLineNumber(),\n                             importGroup, currentGroup, fullImportIdent);\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishImportList() {\n        String currentGroup \u003d getFirstGroup();\n        int currentGroupNumber \u003d customOrderRules.indexOf(currentGroup);\n        ImportDetails previousImportObjectFromCurrentGroup \u003d null;\n        String previousImportFromCurrentGroup \u003d null;\n\n        for (ImportDetails importObject : importToGroupList) {\n            final String importGroup \u003d importObject.getImportGroup();\n            final String fullImportIdent \u003d importObject.getImportFullPath();\n\n            if (importGroup.equals(currentGroup)) {\n                validateExtraEmptyLine(previousImportObjectFromCurrentGroup,\n                        importObject, fullImportIdent);\n                if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {\n                    log(importObject.getStartLineNumber(), MSG_LEX,\n                            fullImportIdent, previousImportFromCurrentGroup);\n                }\n                else {\n                    previousImportFromCurrentGroup \u003d fullImportIdent;\n                }\n                previousImportObjectFromCurrentGroup \u003d importObject;\n            }\n            else {\n                // not the last group, last one is always NON_GROUP\n                if (customOrderRules.size() \u003e currentGroupNumber + 1) {\n                    final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                    if (importGroup.equals(nextGroup)) {\n                        validateMissedEmptyLine(previousImportObjectFromCurrentGroup,\n                                importObject, fullImportIdent);\n                        currentGroup \u003d nextGroup;\n                        currentGroupNumber \u003d customOrderRules.indexOf(nextGroup);\n                        previousImportFromCurrentGroup \u003d fullImportIdent;\n                    }\n                    else {\n                        logWrongImportGroupOrder(importObject.getStartLineNumber(),\n                                importGroup, nextGroup, fullImportIdent);\n                    }\n                    previousImportObjectFromCurrentGroup \u003d importObject;\n                }\n                else {\n                    logWrongImportGroupOrder(importObject.getStartLineNumber(),\n                            importGroup, currentGroup, fullImportIdent);\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java",
      "extendedDetails": {}
    },
    "9a7a8e15ed9820f3b325ef2fd2f7e3295c17d6b3": {
      "type": "Ybodychange",
      "commitMessage": "Issue #7475: resolve Cognitive Complexity cases above 20\n",
      "commitDate": "18/01/20 2:10 PM",
      "commitName": "9a7a8e15ed9820f3b325ef2fd2f7e3295c17d6b3",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "01/01/20 4:38 PM",
      "commitNameOld": "ae9edbd4a8645c8cc1a99ad6890dd0006700d1cb",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 16.9,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,46 @@\n     private void finishImportList() {\n         String currentGroup \u003d getFirstGroup();\n         int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n         ImportDetails previousImportObjectFromCurrentGroup \u003d null;\n         String previousImportFromCurrentGroup \u003d null;\n \n         for (ImportDetails importObject : importToGroupList) {\n             final String importGroup \u003d importObject.getImportGroup();\n             final String fullImportIdent \u003d importObject.getImportFullPath();\n \n             if (importGroup.equals(currentGroup)) {\n-                if (isSeparatedByExtraEmptyLine(previousImportObjectFromCurrentGroup,\n-                                                importObject)) {\n-                    log(importObject.getStartLineNumber(), MSG_SEPARATED_IN_GROUP,\n-                            fullImportIdent);\n-                }\n+                validateExtraEmptyLine(previousImportObjectFromCurrentGroup,\n+                        importObject, fullImportIdent);\n                 if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {\n                     log(importObject.getStartLineNumber(), MSG_LEX,\n                             fullImportIdent, previousImportFromCurrentGroup);\n                 }\n                 else {\n                     previousImportFromCurrentGroup \u003d fullImportIdent;\n                 }\n                 previousImportObjectFromCurrentGroup \u003d importObject;\n             }\n             else {\n                 //not the last group, last one is always NON_GROUP\n                 if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                     final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                     if (importGroup.equals(nextGroup)) {\n-                        if (isEmptyLineMissed(previousImportObjectFromCurrentGroup, importObject)) {\n-                            log(importObject.getStartLineNumber(), MSG_LINE_SEPARATOR,\n-                                    fullImportIdent);\n-                        }\n+                        validateMissedEmptyLine(previousImportObjectFromCurrentGroup,\n+                                importObject, fullImportIdent);\n                         currentGroup \u003d nextGroup;\n                         currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                         previousImportFromCurrentGroup \u003d fullImportIdent;\n                     }\n                     else {\n                         logWrongImportGroupOrder(importObject.getStartLineNumber(),\n                                 importGroup, nextGroup, fullImportIdent);\n                     }\n                     previousImportObjectFromCurrentGroup \u003d importObject;\n                 }\n                 else {\n                     logWrongImportGroupOrder(importObject.getStartLineNumber(),\n                             importGroup, currentGroup, fullImportIdent);\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishImportList() {\n        String currentGroup \u003d getFirstGroup();\n        int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n        ImportDetails previousImportObjectFromCurrentGroup \u003d null;\n        String previousImportFromCurrentGroup \u003d null;\n\n        for (ImportDetails importObject : importToGroupList) {\n            final String importGroup \u003d importObject.getImportGroup();\n            final String fullImportIdent \u003d importObject.getImportFullPath();\n\n            if (importGroup.equals(currentGroup)) {\n                validateExtraEmptyLine(previousImportObjectFromCurrentGroup,\n                        importObject, fullImportIdent);\n                if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {\n                    log(importObject.getStartLineNumber(), MSG_LEX,\n                            fullImportIdent, previousImportFromCurrentGroup);\n                }\n                else {\n                    previousImportFromCurrentGroup \u003d fullImportIdent;\n                }\n                previousImportObjectFromCurrentGroup \u003d importObject;\n            }\n            else {\n                //not the last group, last one is always NON_GROUP\n                if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                    final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                    if (importGroup.equals(nextGroup)) {\n                        validateMissedEmptyLine(previousImportObjectFromCurrentGroup,\n                                importObject, fullImportIdent);\n                        currentGroup \u003d nextGroup;\n                        currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                        previousImportFromCurrentGroup \u003d fullImportIdent;\n                    }\n                    else {\n                        logWrongImportGroupOrder(importObject.getStartLineNumber(),\n                                importGroup, nextGroup, fullImportIdent);\n                    }\n                    previousImportObjectFromCurrentGroup \u003d importObject;\n                }\n                else {\n                    logWrongImportGroupOrder(importObject.getStartLineNumber(),\n                            importGroup, currentGroup, fullImportIdent);\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java",
      "extendedDetails": {}
    },
    "018b52126dd3ddf58a47dadbe5f1b7ca5c7ffd3d": {
      "type": "Ybodychange",
      "commitMessage": "Issue #7314: check empty line separator between import statements\n",
      "commitDate": "21/12/19 10:55 AM",
      "commitName": "018b52126dd3ddf58a47dadbe5f1b7ca5c7ffd3d",
      "commitAuthor": "Zhenlei Huang",
      "commitDateOld": "14/12/19 3:23 PM",
      "commitNameOld": "baa250c454de5845151b64ae940173744f4d0435",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 6.81,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,51 @@\n     private void finishImportList() {\n         String currentGroup \u003d getFirstGroup();\n         int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n         ImportDetails previousImportObjectFromCurrentGroup \u003d null;\n         String previousImportFromCurrentGroup \u003d null;\n \n         for (ImportDetails importObject : importToGroupList) {\n             final String importGroup \u003d importObject.getImportGroup();\n             final String fullImportIdent \u003d importObject.getImportFullPath();\n \n             if (importGroup.equals(currentGroup)) {\n                 if (isSeparatedByExtraEmptyLine(previousImportObjectFromCurrentGroup,\n                                                 importObject)) {\n-                    log(importObject.getLineNumber(), MSG_SEPARATED_IN_GROUP, fullImportIdent);\n+                    log(importObject.getStartLineNumber(), MSG_SEPARATED_IN_GROUP,\n+                            fullImportIdent);\n                 }\n                 if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {\n-                    log(importObject.getLineNumber(), MSG_LEX,\n+                    log(importObject.getStartLineNumber(), MSG_LEX,\n                             fullImportIdent, previousImportFromCurrentGroup);\n                 }\n                 else {\n                     previousImportFromCurrentGroup \u003d fullImportIdent;\n                 }\n                 previousImportObjectFromCurrentGroup \u003d importObject;\n             }\n             else {\n                 //not the last group, last one is always NON_GROUP\n                 if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                     final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                     if (importGroup.equals(nextGroup)) {\n                         if (isEmptyLineMissed(previousImportObjectFromCurrentGroup, importObject)) {\n-                            log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n+                            log(importObject.getStartLineNumber(), MSG_LINE_SEPARATOR,\n+                                    fullImportIdent);\n                         }\n                         currentGroup \u003d nextGroup;\n                         currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                         previousImportFromCurrentGroup \u003d fullImportIdent;\n                     }\n                     else {\n-                        logWrongImportGroupOrder(importObject.getLineNumber(),\n+                        logWrongImportGroupOrder(importObject.getStartLineNumber(),\n                                 importGroup, nextGroup, fullImportIdent);\n                     }\n                     previousImportObjectFromCurrentGroup \u003d importObject;\n                 }\n                 else {\n-                    logWrongImportGroupOrder(importObject.getLineNumber(),\n+                    logWrongImportGroupOrder(importObject.getStartLineNumber(),\n                             importGroup, currentGroup, fullImportIdent);\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishImportList() {\n        String currentGroup \u003d getFirstGroup();\n        int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n        ImportDetails previousImportObjectFromCurrentGroup \u003d null;\n        String previousImportFromCurrentGroup \u003d null;\n\n        for (ImportDetails importObject : importToGroupList) {\n            final String importGroup \u003d importObject.getImportGroup();\n            final String fullImportIdent \u003d importObject.getImportFullPath();\n\n            if (importGroup.equals(currentGroup)) {\n                if (isSeparatedByExtraEmptyLine(previousImportObjectFromCurrentGroup,\n                                                importObject)) {\n                    log(importObject.getStartLineNumber(), MSG_SEPARATED_IN_GROUP,\n                            fullImportIdent);\n                }\n                if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {\n                    log(importObject.getStartLineNumber(), MSG_LEX,\n                            fullImportIdent, previousImportFromCurrentGroup);\n                }\n                else {\n                    previousImportFromCurrentGroup \u003d fullImportIdent;\n                }\n                previousImportObjectFromCurrentGroup \u003d importObject;\n            }\n            else {\n                //not the last group, last one is always NON_GROUP\n                if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                    final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                    if (importGroup.equals(nextGroup)) {\n                        if (isEmptyLineMissed(previousImportObjectFromCurrentGroup, importObject)) {\n                            log(importObject.getStartLineNumber(), MSG_LINE_SEPARATOR,\n                                    fullImportIdent);\n                        }\n                        currentGroup \u003d nextGroup;\n                        currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                        previousImportFromCurrentGroup \u003d fullImportIdent;\n                    }\n                    else {\n                        logWrongImportGroupOrder(importObject.getStartLineNumber(),\n                                importGroup, nextGroup, fullImportIdent);\n                    }\n                    previousImportObjectFromCurrentGroup \u003d importObject;\n                }\n                else {\n                    logWrongImportGroupOrder(importObject.getStartLineNumber(),\n                            importGroup, currentGroup, fullImportIdent);\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java",
      "extendedDetails": {}
    },
    "4ba514bf6e685f3fedf58c27276793249284a9ae": {
      "type": "Ybodychange",
      "commitMessage": "Issue #7278: introduce a new message for the violation within import group\n",
      "commitDate": "13/12/19 11:47 AM",
      "commitName": "4ba514bf6e685f3fedf58c27276793249284a9ae",
      "commitAuthor": "Zhenlei Huang",
      "commitDateOld": "10/12/19 1:34 PM",
      "commitNameOld": "69f5ff0d9dabc50ca2ca08826acff810c9df453e",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 2.93,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n     private void finishImportList() {\n         String currentGroup \u003d getFirstGroup();\n         int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n         ImportDetails previousImportObjectFromCurrentGroup \u003d null;\n         String previousImportFromCurrentGroup \u003d null;\n \n         for (ImportDetails importObject : importToGroupList) {\n             final String importGroup \u003d importObject.getImportGroup();\n             final String fullImportIdent \u003d importObject.getImportFullPath();\n \n             if (importGroup.equals(currentGroup)) {\n                 if (isSeparatedByExtraEmptyLine(previousImportObjectFromCurrentGroup,\n                                                 importObject)) {\n-                    log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n+                    log(importObject.getLineNumber(), MSG_SEPARATED_IN_GROUP, fullImportIdent);\n                 }\n                 if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {\n                     log(importObject.getLineNumber(), MSG_LEX,\n                             fullImportIdent, previousImportFromCurrentGroup);\n                 }\n                 else {\n                     previousImportFromCurrentGroup \u003d fullImportIdent;\n                 }\n                 previousImportObjectFromCurrentGroup \u003d importObject;\n             }\n             else {\n                 //not the last group, last one is always NON_GROUP\n                 if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                     final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                     if (importGroup.equals(nextGroup)) {\n                         if (isEmptyLineMissed(previousImportObjectFromCurrentGroup, importObject)) {\n                             log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n                         }\n                         currentGroup \u003d nextGroup;\n                         currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                         previousImportFromCurrentGroup \u003d fullImportIdent;\n                     }\n                     else {\n                         logWrongImportGroupOrder(importObject.getLineNumber(),\n                                 importGroup, nextGroup, fullImportIdent);\n                     }\n                     previousImportObjectFromCurrentGroup \u003d importObject;\n                 }\n                 else {\n                     logWrongImportGroupOrder(importObject.getLineNumber(),\n                             importGroup, currentGroup, fullImportIdent);\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishImportList() {\n        String currentGroup \u003d getFirstGroup();\n        int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n        ImportDetails previousImportObjectFromCurrentGroup \u003d null;\n        String previousImportFromCurrentGroup \u003d null;\n\n        for (ImportDetails importObject : importToGroupList) {\n            final String importGroup \u003d importObject.getImportGroup();\n            final String fullImportIdent \u003d importObject.getImportFullPath();\n\n            if (importGroup.equals(currentGroup)) {\n                if (isSeparatedByExtraEmptyLine(previousImportObjectFromCurrentGroup,\n                                                importObject)) {\n                    log(importObject.getLineNumber(), MSG_SEPARATED_IN_GROUP, fullImportIdent);\n                }\n                if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {\n                    log(importObject.getLineNumber(), MSG_LEX,\n                            fullImportIdent, previousImportFromCurrentGroup);\n                }\n                else {\n                    previousImportFromCurrentGroup \u003d fullImportIdent;\n                }\n                previousImportObjectFromCurrentGroup \u003d importObject;\n            }\n            else {\n                //not the last group, last one is always NON_GROUP\n                if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                    final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                    if (importGroup.equals(nextGroup)) {\n                        if (isEmptyLineMissed(previousImportObjectFromCurrentGroup, importObject)) {\n                            log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n                        }\n                        currentGroup \u003d nextGroup;\n                        currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                        previousImportFromCurrentGroup \u003d fullImportIdent;\n                    }\n                    else {\n                        logWrongImportGroupOrder(importObject.getLineNumber(),\n                                importGroup, nextGroup, fullImportIdent);\n                    }\n                    previousImportObjectFromCurrentGroup \u003d importObject;\n                }\n                else {\n                    logWrongImportGroupOrder(importObject.getLineNumber(),\n                            importGroup, currentGroup, fullImportIdent);\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java",
      "extendedDetails": {}
    },
    "69f5ff0d9dabc50ca2ca08826acff810c9df453e": {
      "type": "Ybodychange",
      "commitMessage": "minor: extracting code from CustomImportOrderCheck.finishImportList to separate methods to reduce size of method\n",
      "commitDate": "10/12/19 1:34 PM",
      "commitName": "69f5ff0d9dabc50ca2ca08826acff810c9df453e",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "10/12/19 1:34 PM",
      "commitNameOld": "5615664ca5d775db468c81e61f19bd6b818a14ed",
      "commitAuthorOld": "Zhenlei Huang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,49 @@\n     private void finishImportList() {\n-        final ImportDetails firstImport \u003d importToGroupList.get(0);\n-        String currentGroup \u003d getImportGroup(firstImport.isStaticImport(),\n-                firstImport.getImportFullPath());\n+        String currentGroup \u003d getFirstGroup();\n         int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n         ImportDetails previousImportObjectFromCurrentGroup \u003d null;\n         String previousImportFromCurrentGroup \u003d null;\n \n         for (ImportDetails importObject : importToGroupList) {\n             final String importGroup \u003d importObject.getImportGroup();\n             final String fullImportIdent \u003d importObject.getImportFullPath();\n \n             if (importGroup.equals(currentGroup)) {\n-                if (previousImportObjectFromCurrentGroup !\u003d null\n-                        \u0026\u0026 getCountOfEmptyLinesBetween(\n-                            previousImportObjectFromCurrentGroup.getLineNumber(),\n-                            // https://github.com/checkstyle/checkstyle/issues/7119\n-                            importObject.getLineNumber()) \u003e 1) {\n+                if (isSeparatedByExtraEmptyLine(previousImportObjectFromCurrentGroup,\n+                                                importObject)) {\n                     log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n                 }\n-                if (sortImportsInGroupAlphabetically\n-                        \u0026\u0026 previousImportFromCurrentGroup !\u003d null\n-                        \u0026\u0026 compareImports(fullImportIdent, previousImportFromCurrentGroup) \u003c 0) {\n+                if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {\n                     log(importObject.getLineNumber(), MSG_LEX,\n                             fullImportIdent, previousImportFromCurrentGroup);\n                 }\n                 else {\n                     previousImportFromCurrentGroup \u003d fullImportIdent;\n                 }\n                 previousImportObjectFromCurrentGroup \u003d importObject;\n             }\n             else {\n                 //not the last group, last one is always NON_GROUP\n                 if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                     final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                     if (importGroup.equals(nextGroup)) {\n-                        if (separateLineBetweenGroups\n-                                \u0026\u0026 getCountOfEmptyLinesBetween(\n-                                    previousImportObjectFromCurrentGroup.getLineNumber(),\n-                                    importObject.getLineNumber()) !\u003d 1) {\n+                        if (isEmptyLineMissed(previousImportObjectFromCurrentGroup, importObject)) {\n                             log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n                         }\n                         currentGroup \u003d nextGroup;\n                         currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                         previousImportFromCurrentGroup \u003d fullImportIdent;\n                     }\n                     else {\n                         logWrongImportGroupOrder(importObject.getLineNumber(),\n                                 importGroup, nextGroup, fullImportIdent);\n                     }\n                     previousImportObjectFromCurrentGroup \u003d importObject;\n                 }\n                 else {\n                     logWrongImportGroupOrder(importObject.getLineNumber(),\n                             importGroup, currentGroup, fullImportIdent);\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishImportList() {\n        String currentGroup \u003d getFirstGroup();\n        int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n        ImportDetails previousImportObjectFromCurrentGroup \u003d null;\n        String previousImportFromCurrentGroup \u003d null;\n\n        for (ImportDetails importObject : importToGroupList) {\n            final String importGroup \u003d importObject.getImportGroup();\n            final String fullImportIdent \u003d importObject.getImportFullPath();\n\n            if (importGroup.equals(currentGroup)) {\n                if (isSeparatedByExtraEmptyLine(previousImportObjectFromCurrentGroup,\n                                                importObject)) {\n                    log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n                }\n                if (isAlphabeticalOrderBroken(previousImportFromCurrentGroup, fullImportIdent)) {\n                    log(importObject.getLineNumber(), MSG_LEX,\n                            fullImportIdent, previousImportFromCurrentGroup);\n                }\n                else {\n                    previousImportFromCurrentGroup \u003d fullImportIdent;\n                }\n                previousImportObjectFromCurrentGroup \u003d importObject;\n            }\n            else {\n                //not the last group, last one is always NON_GROUP\n                if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                    final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                    if (importGroup.equals(nextGroup)) {\n                        if (isEmptyLineMissed(previousImportObjectFromCurrentGroup, importObject)) {\n                            log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n                        }\n                        currentGroup \u003d nextGroup;\n                        currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                        previousImportFromCurrentGroup \u003d fullImportIdent;\n                    }\n                    else {\n                        logWrongImportGroupOrder(importObject.getLineNumber(),\n                                importGroup, nextGroup, fullImportIdent);\n                    }\n                    previousImportObjectFromCurrentGroup \u003d importObject;\n                }\n                else {\n                    logWrongImportGroupOrder(importObject.getLineNumber(),\n                            importGroup, currentGroup, fullImportIdent);\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java",
      "extendedDetails": {}
    },
    "5615664ca5d775db468c81e61f19bd6b818a14ed": {
      "type": "Ybodychange",
      "commitMessage": "Issue #6680: fix unexpected violation for extra empty line between package and import\n",
      "commitDate": "10/12/19 1:34 PM",
      "commitName": "5615664ca5d775db468c81e61f19bd6b818a14ed",
      "commitAuthor": "Zhenlei Huang",
      "commitDateOld": "20/09/19 2:34 PM",
      "commitNameOld": "922182037aff1b92f4a1aadbfb8ff2d2a98db874",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 81.0,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,59 @@\n     private void finishImportList() {\n         final ImportDetails firstImport \u003d importToGroupList.get(0);\n         String currentGroup \u003d getImportGroup(firstImport.isStaticImport(),\n                 firstImport.getImportFullPath());\n         int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n+        ImportDetails previousImportObjectFromCurrentGroup \u003d null;\n         String previousImportFromCurrentGroup \u003d null;\n \n         for (ImportDetails importObject : importToGroupList) {\n             final String importGroup \u003d importObject.getImportGroup();\n             final String fullImportIdent \u003d importObject.getImportFullPath();\n \n-            if (getCountOfEmptyLinesBefore(importObject.getLineNumber()) \u003e 1) {\n-                log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n-            }\n             if (importGroup.equals(currentGroup)) {\n+                if (previousImportObjectFromCurrentGroup !\u003d null\n+                        \u0026\u0026 getCountOfEmptyLinesBetween(\n+                            previousImportObjectFromCurrentGroup.getLineNumber(),\n+                            // https://github.com/checkstyle/checkstyle/issues/7119\n+                            importObject.getLineNumber()) \u003e 1) {\n+                    log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n+                }\n                 if (sortImportsInGroupAlphabetically\n                         \u0026\u0026 previousImportFromCurrentGroup !\u003d null\n                         \u0026\u0026 compareImports(fullImportIdent, previousImportFromCurrentGroup) \u003c 0) {\n                     log(importObject.getLineNumber(), MSG_LEX,\n                             fullImportIdent, previousImportFromCurrentGroup);\n                 }\n                 else {\n                     previousImportFromCurrentGroup \u003d fullImportIdent;\n                 }\n+                previousImportObjectFromCurrentGroup \u003d importObject;\n             }\n             else {\n                 //not the last group, last one is always NON_GROUP\n                 if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                     final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                     if (importGroup.equals(nextGroup)) {\n                         if (separateLineBetweenGroups\n-                                \u0026\u0026 getCountOfEmptyLinesBefore(importObject.getLineNumber()) \u003d\u003d 0) {\n+                                \u0026\u0026 getCountOfEmptyLinesBetween(\n+                                    previousImportObjectFromCurrentGroup.getLineNumber(),\n+                                    importObject.getLineNumber()) !\u003d 1) {\n                             log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n                         }\n                         currentGroup \u003d nextGroup;\n                         currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                         previousImportFromCurrentGroup \u003d fullImportIdent;\n                     }\n                     else {\n                         logWrongImportGroupOrder(importObject.getLineNumber(),\n                                 importGroup, nextGroup, fullImportIdent);\n                     }\n+                    previousImportObjectFromCurrentGroup \u003d importObject;\n                 }\n                 else {\n                     logWrongImportGroupOrder(importObject.getLineNumber(),\n                             importGroup, currentGroup, fullImportIdent);\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishImportList() {\n        final ImportDetails firstImport \u003d importToGroupList.get(0);\n        String currentGroup \u003d getImportGroup(firstImport.isStaticImport(),\n                firstImport.getImportFullPath());\n        int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n        ImportDetails previousImportObjectFromCurrentGroup \u003d null;\n        String previousImportFromCurrentGroup \u003d null;\n\n        for (ImportDetails importObject : importToGroupList) {\n            final String importGroup \u003d importObject.getImportGroup();\n            final String fullImportIdent \u003d importObject.getImportFullPath();\n\n            if (importGroup.equals(currentGroup)) {\n                if (previousImportObjectFromCurrentGroup !\u003d null\n                        \u0026\u0026 getCountOfEmptyLinesBetween(\n                            previousImportObjectFromCurrentGroup.getLineNumber(),\n                            // https://github.com/checkstyle/checkstyle/issues/7119\n                            importObject.getLineNumber()) \u003e 1) {\n                    log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n                }\n                if (sortImportsInGroupAlphabetically\n                        \u0026\u0026 previousImportFromCurrentGroup !\u003d null\n                        \u0026\u0026 compareImports(fullImportIdent, previousImportFromCurrentGroup) \u003c 0) {\n                    log(importObject.getLineNumber(), MSG_LEX,\n                            fullImportIdent, previousImportFromCurrentGroup);\n                }\n                else {\n                    previousImportFromCurrentGroup \u003d fullImportIdent;\n                }\n                previousImportObjectFromCurrentGroup \u003d importObject;\n            }\n            else {\n                //not the last group, last one is always NON_GROUP\n                if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                    final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                    if (importGroup.equals(nextGroup)) {\n                        if (separateLineBetweenGroups\n                                \u0026\u0026 getCountOfEmptyLinesBetween(\n                                    previousImportObjectFromCurrentGroup.getLineNumber(),\n                                    importObject.getLineNumber()) !\u003d 1) {\n                            log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n                        }\n                        currentGroup \u003d nextGroup;\n                        currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                        previousImportFromCurrentGroup \u003d fullImportIdent;\n                    }\n                    else {\n                        logWrongImportGroupOrder(importObject.getLineNumber(),\n                                importGroup, nextGroup, fullImportIdent);\n                    }\n                    previousImportObjectFromCurrentGroup \u003d importObject;\n                }\n                else {\n                    logWrongImportGroupOrder(importObject.getLineNumber(),\n                            importGroup, currentGroup, fullImportIdent);\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java",
      "extendedDetails": {}
    },
    "914dd9994c9f108f54849a96bc35bbdd85de1053": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3551: CustomImportOrder shows violation on multiple line separation\n",
      "commitDate": "30/12/16 10:14 AM",
      "commitName": "914dd9994c9f108f54849a96bc35bbdd85de1053",
      "commitAuthor": "kazachka",
      "commitDateOld": "09/11/16 4:34 AM",
      "commitNameOld": "8888fa5919dc31c6abe07ddc2f5fe0e29f66ef37",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 51.24,
      "commitsBetweenForRepo": 120,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,50 @@\n     private void finishImportList() {\n         final ImportDetails firstImport \u003d importToGroupList.get(0);\n         String currentGroup \u003d getImportGroup(firstImport.isStaticImport(),\n                 firstImport.getImportFullPath());\n         int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n         String previousImportFromCurrentGroup \u003d null;\n \n         for (ImportDetails importObject : importToGroupList) {\n             final String importGroup \u003d importObject.getImportGroup();\n             final String fullImportIdent \u003d importObject.getImportFullPath();\n \n+            if (getCountOfEmptyLinesBefore(importObject.getLineNumber()) \u003e 1) {\n+                log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n+            }\n             if (importGroup.equals(currentGroup)) {\n                 if (sortImportsInGroupAlphabetically\n                         \u0026\u0026 previousImportFromCurrentGroup !\u003d null\n                         \u0026\u0026 compareImports(fullImportIdent, previousImportFromCurrentGroup) \u003c 0) {\n                     log(importObject.getLineNumber(), MSG_LEX,\n                             fullImportIdent, previousImportFromCurrentGroup);\n                 }\n                 else {\n                     previousImportFromCurrentGroup \u003d fullImportIdent;\n                 }\n             }\n             else {\n                 //not the last group, last one is always NON_GROUP\n                 if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                     final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                     if (importGroup.equals(nextGroup)) {\n                         if (separateLineBetweenGroups\n-                                \u0026\u0026 !hasEmptyLineBefore(importObject.getLineNumber())) {\n+                                \u0026\u0026 getCountOfEmptyLinesBefore(importObject.getLineNumber()) \u003d\u003d 0) {\n                             log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n                         }\n                         currentGroup \u003d nextGroup;\n                         currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                         previousImportFromCurrentGroup \u003d fullImportIdent;\n                     }\n                     else {\n                         logWrongImportGroupOrder(importObject.getLineNumber(),\n                                 importGroup, nextGroup, fullImportIdent);\n                     }\n                 }\n                 else {\n                     logWrongImportGroupOrder(importObject.getLineNumber(),\n                             importGroup, currentGroup, fullImportIdent);\n                 }\n             }\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishImportList() {\n        final ImportDetails firstImport \u003d importToGroupList.get(0);\n        String currentGroup \u003d getImportGroup(firstImport.isStaticImport(),\n                firstImport.getImportFullPath());\n        int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n        String previousImportFromCurrentGroup \u003d null;\n\n        for (ImportDetails importObject : importToGroupList) {\n            final String importGroup \u003d importObject.getImportGroup();\n            final String fullImportIdent \u003d importObject.getImportFullPath();\n\n            if (getCountOfEmptyLinesBefore(importObject.getLineNumber()) \u003e 1) {\n                log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n            }\n            if (importGroup.equals(currentGroup)) {\n                if (sortImportsInGroupAlphabetically\n                        \u0026\u0026 previousImportFromCurrentGroup !\u003d null\n                        \u0026\u0026 compareImports(fullImportIdent, previousImportFromCurrentGroup) \u003c 0) {\n                    log(importObject.getLineNumber(), MSG_LEX,\n                            fullImportIdent, previousImportFromCurrentGroup);\n                }\n                else {\n                    previousImportFromCurrentGroup \u003d fullImportIdent;\n                }\n            }\n            else {\n                //not the last group, last one is always NON_GROUP\n                if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                    final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                    if (importGroup.equals(nextGroup)) {\n                        if (separateLineBetweenGroups\n                                \u0026\u0026 getCountOfEmptyLinesBefore(importObject.getLineNumber()) \u003d\u003d 0) {\n                            log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n                        }\n                        currentGroup \u003d nextGroup;\n                        currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                        previousImportFromCurrentGroup \u003d fullImportIdent;\n                    }\n                    else {\n                        logWrongImportGroupOrder(importObject.getLineNumber(),\n                                importGroup, nextGroup, fullImportIdent);\n                    }\n                }\n                else {\n                    logWrongImportGroupOrder(importObject.getLineNumber(),\n                            importGroup, currentGroup, fullImportIdent);\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java",
      "extendedDetails": {}
    },
    "39b343a32a4f1ce18ee98a34618fda0a5404d6a0": {
      "type": "Yintroduced",
      "commitMessage": "Issue #3143: forbid empty return statements and fixed violations",
      "commitDate": "27/05/16 6:42 AM",
      "commitName": "39b343a32a4f1ce18ee98a34618fda0a5404d6a0",
      "commitAuthor": "rnveach",
      "diff": "@@ -0,0 +1,47 @@\n+    private void finishImportList() {\n+        final ImportDetails firstImport \u003d importToGroupList.get(0);\n+        String currentGroup \u003d getImportGroup(firstImport.isStaticImport(),\n+                firstImport.getImportFullPath());\n+        int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n+        String previousImportFromCurrentGroup \u003d null;\n+\n+        for (ImportDetails importObject : importToGroupList) {\n+            final String importGroup \u003d importObject.getImportGroup();\n+            final String fullImportIdent \u003d importObject.getImportFullPath();\n+\n+            if (importGroup.equals(currentGroup)) {\n+                if (sortImportsInGroupAlphabetically\n+                        \u0026\u0026 previousImportFromCurrentGroup !\u003d null\n+                        \u0026\u0026 compareImports(fullImportIdent, previousImportFromCurrentGroup) \u003c 0) {\n+                    log(importObject.getLineNumber(), MSG_LEX,\n+                            fullImportIdent, previousImportFromCurrentGroup);\n+                }\n+                else {\n+                    previousImportFromCurrentGroup \u003d fullImportIdent;\n+                }\n+            }\n+            else {\n+                //not the last group, last one is always NON_GROUP\n+                if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n+                    final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n+                    if (importGroup.equals(nextGroup)) {\n+                        if (separateLineBetweenGroups\n+                                \u0026\u0026 !hasEmptyLineBefore(importObject.getLineNumber())) {\n+                            log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n+                        }\n+                        currentGroup \u003d nextGroup;\n+                        currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n+                        previousImportFromCurrentGroup \u003d fullImportIdent;\n+                    }\n+                    else {\n+                        logWrongImportGroupOrder(importObject.getLineNumber(),\n+                                importGroup, nextGroup, fullImportIdent);\n+                    }\n+                }\n+                else {\n+                    logWrongImportGroupOrder(importObject.getLineNumber(),\n+                            importGroup, currentGroup, fullImportIdent);\n+                }\n+            }\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void finishImportList() {\n        final ImportDetails firstImport \u003d importToGroupList.get(0);\n        String currentGroup \u003d getImportGroup(firstImport.isStaticImport(),\n                firstImport.getImportFullPath());\n        int currentGroupNumber \u003d customImportOrderRules.indexOf(currentGroup);\n        String previousImportFromCurrentGroup \u003d null;\n\n        for (ImportDetails importObject : importToGroupList) {\n            final String importGroup \u003d importObject.getImportGroup();\n            final String fullImportIdent \u003d importObject.getImportFullPath();\n\n            if (importGroup.equals(currentGroup)) {\n                if (sortImportsInGroupAlphabetically\n                        \u0026\u0026 previousImportFromCurrentGroup !\u003d null\n                        \u0026\u0026 compareImports(fullImportIdent, previousImportFromCurrentGroup) \u003c 0) {\n                    log(importObject.getLineNumber(), MSG_LEX,\n                            fullImportIdent, previousImportFromCurrentGroup);\n                }\n                else {\n                    previousImportFromCurrentGroup \u003d fullImportIdent;\n                }\n            }\n            else {\n                //not the last group, last one is always NON_GROUP\n                if (customImportOrderRules.size() \u003e currentGroupNumber + 1) {\n                    final String nextGroup \u003d getNextImportGroup(currentGroupNumber + 1);\n                    if (importGroup.equals(nextGroup)) {\n                        if (separateLineBetweenGroups\n                                \u0026\u0026 !hasEmptyLineBefore(importObject.getLineNumber())) {\n                            log(importObject.getLineNumber(), MSG_LINE_SEPARATOR, fullImportIdent);\n                        }\n                        currentGroup \u003d nextGroup;\n                        currentGroupNumber \u003d customImportOrderRules.indexOf(nextGroup);\n                        previousImportFromCurrentGroup \u003d fullImportIdent;\n                    }\n                    else {\n                        logWrongImportGroupOrder(importObject.getLineNumber(),\n                                importGroup, nextGroup, fullImportIdent);\n                    }\n                }\n                else {\n                    logWrongImportGroupOrder(importObject.getLineNumber(),\n                            importGroup, currentGroup, fullImportIdent);\n                }\n            }\n        }\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java"
    }
  }
}