{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ImportOrderCheck.java",
  "functionName": "visitToken",
  "functionId": "visitToken___ast-DetailAST",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
  "functionStartLine": 616,
  "functionEndLine": 652,
  "numCommitsSeen": 115,
  "timeTaken": 3940,
  "changeHistory": [
    "57c244fcf81bf0ed6658e7cabb82d5091075e591",
    "4e07bd654bddb2f1063a5aae956a0b81826c34f8",
    "1a6dafadd522b48c59289afd780a1df007f72819",
    "f4e6424cd5892b72c96d35d7625560959583ea0d",
    "6e74c7d42d90264899ef5ab78712755a3ef1811f",
    "2c23e07558b15944638601a2620fa6aefd12ec2a",
    "35de50c9405825eeb68357df2625b693d2748ed9",
    "ee1b845b7936df396543bc11dced4676d5af86b6",
    "f6cb72258856fdae0b89c66a0ba750712674cdee",
    "90e104688f270a13f42f65e7b7d263e7a9612734",
    "ad42ed29799a13b9426a05cc94b4a4aaba709c2c",
    "3ba66c7d22f0d75412a851717d976f875ef9c4d0",
    "cce20fc3c7bc07775d2bf9ca4a6ce9ac002ab288",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "16dac636b246c658cad31ee9b2e45c53b851d4f2",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
    "22136c67e9c83494e7aa977ffe7a79beee1b4175",
    "35d1673788bbbac8263fdb69275dc6a63b095a24",
    "6125beffc437f970eae276b4a6542265c6547784",
    "2f70947ed74ab968324fdcf83f808ff1d88df1fb",
    "c6bbd6774988073dfeea8e6f9bea0689f0de19bb",
    "2a1705e70d334700734b3df3ebefea0be878127a"
  ],
  "changeHistoryShort": {
    "57c244fcf81bf0ed6658e7cabb82d5091075e591": "Ybodychange",
    "4e07bd654bddb2f1063a5aae956a0b81826c34f8": "Ybodychange",
    "1a6dafadd522b48c59289afd780a1df007f72819": "Ybodychange",
    "f4e6424cd5892b72c96d35d7625560959583ea0d": "Ybodychange",
    "6e74c7d42d90264899ef5ab78712755a3ef1811f": "Ybodychange",
    "2c23e07558b15944638601a2620fa6aefd12ec2a": "Ybodychange",
    "35de50c9405825eeb68357df2625b693d2748ed9": "Ybodychange",
    "ee1b845b7936df396543bc11dced4676d5af86b6": "Ybodychange",
    "f6cb72258856fdae0b89c66a0ba750712674cdee": "Ybodychange",
    "90e104688f270a13f42f65e7b7d263e7a9612734": "Ybodychange",
    "ad42ed29799a13b9426a05cc94b4a4aaba709c2c": "Ybodychange",
    "3ba66c7d22f0d75412a851717d976f875ef9c4d0": "Ybodychange",
    "cce20fc3c7bc07775d2bf9ca4a6ce9ac002ab288": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "16dac636b246c658cad31ee9b2e45c53b851d4f2": "Ymultichange(Yparameterchange,Ybodychange)",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "d62a2cc02092cb6c1a1666630a51a6ec7c50a878": "Ybodychange",
    "22136c67e9c83494e7aa977ffe7a79beee1b4175": "Ybodychange",
    "35d1673788bbbac8263fdb69275dc6a63b095a24": "Ybodychange",
    "6125beffc437f970eae276b4a6542265c6547784": "Ybodychange",
    "2f70947ed74ab968324fdcf83f808ff1d88df1fb": "Ybodychange",
    "c6bbd6774988073dfeea8e6f9bea0689f0de19bb": "Ybodychange",
    "2a1705e70d334700734b3df3ebefea0be878127a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "57c244fcf81bf0ed6658e7cabb82d5091075e591": {
      "type": "Ybodychange",
      "commitMessage": "Issue #7733: Update AbstractChecks to log DetailAST - ImportOrder\n",
      "commitDate": "19/03/20 10:54 AM",
      "commitName": "57c244fcf81bf0ed6658e7cabb82d5091075e591",
      "commitAuthor": "kaustubh",
      "commitDateOld": "01/01/20 4:38 PM",
      "commitNameOld": "ae9edbd4a8645c8cc1a99ad6890dd0006700d1cb",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 77.72,
      "commitsBetweenForRepo": 180,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,37 @@\n     public void visitToken(DetailAST ast) {\n-        final int line \u003d ast.getLineNo();\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n         // https://github.com/checkstyle/checkstyle/issues/1387\n         if (option \u003d\u003d ImportOrderOption.TOP || option \u003d\u003d ImportOrderOption.ABOVE) {\n             final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n-            doVisitToken(ident, isStatic, isStaticAndNotLastImport, line);\n+            doVisitToken(ident, isStatic, isStaticAndNotLastImport, ast);\n         }\n         else if (option \u003d\u003d ImportOrderOption.BOTTOM || option \u003d\u003d ImportOrderOption.UNDER) {\n             final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n-            doVisitToken(ident, isStatic, isLastImportAndNonStatic, line);\n+            doVisitToken(ident, isStatic, isLastImportAndNonStatic, ast);\n         }\n         else if (option \u003d\u003d ImportOrderOption.INFLOW) {\n             // \"previous\" argument is useless here\n-            doVisitToken(ident, isStatic, true, line);\n+            doVisitToken(ident, isStatic, true, ast);\n         }\n         else {\n             throw new IllegalStateException(\n                     \"Unexpected option for static imports: \" + option);\n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n        // https://github.com/checkstyle/checkstyle/issues/1387\n        if (option \u003d\u003d ImportOrderOption.TOP || option \u003d\u003d ImportOrderOption.ABOVE) {\n            final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport, ast);\n        }\n        else if (option \u003d\u003d ImportOrderOption.BOTTOM || option \u003d\u003d ImportOrderOption.UNDER) {\n            final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n            doVisitToken(ident, isStatic, isLastImportAndNonStatic, ast);\n        }\n        else if (option \u003d\u003d ImportOrderOption.INFLOW) {\n            // \"previous\" argument is useless here\n            doVisitToken(ident, isStatic, true, ast);\n        }\n        else {\n            throw new IllegalStateException(\n                    \"Unexpected option for static imports: \" + option);\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "4e07bd654bddb2f1063a5aae956a0b81826c34f8": {
      "type": "Ybodychange",
      "commitMessage": "Issue #5279: static imports can be separated by local groups when they are at the top/bottom\n",
      "commitDate": "11/07/18 8:17 PM",
      "commitName": "4e07bd654bddb2f1063a5aae956a0b81826c34f8",
      "commitAuthor": "Pavel Bludov",
      "commitDateOld": "01/07/18 7:45 AM",
      "commitNameOld": "1a6dafadd522b48c59289afd780a1df007f72819",
      "commitAuthorOld": "Pavel Bludov",
      "daysBetweenCommits": 10.52,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,38 @@\n     public void visitToken(DetailAST ast) {\n         final int line \u003d ast.getLineNo();\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n-        final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n-        final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n-\n         // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n         // https://github.com/checkstyle/checkstyle/issues/1387\n-        if (option \u003d\u003d ImportOrderOption.TOP) {\n-            if (isLastImportAndNonStatic) {\n-                lastGroup \u003d Integer.MIN_VALUE;\n-                lastImport \u003d \"\";\n-            }\n+        if (option \u003d\u003d ImportOrderOption.TOP || option \u003d\u003d ImportOrderOption.ABOVE) {\n+            final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n             doVisitToken(ident, isStatic, isStaticAndNotLastImport, line);\n         }\n-        else if (option \u003d\u003d ImportOrderOption.BOTTOM) {\n-            if (isStaticAndNotLastImport) {\n-                lastGroup \u003d Integer.MIN_VALUE;\n-                lastImport \u003d \"\";\n-            }\n-            doVisitToken(ident, isStatic, isLastImportAndNonStatic, line);\n-        }\n-        else if (option \u003d\u003d ImportOrderOption.ABOVE) {\n-            // previous non-static but current is static\n-            doVisitToken(ident, isStatic, isStaticAndNotLastImport, line);\n-        }\n-        else if (option \u003d\u003d ImportOrderOption.UNDER) {\n+        else if (option \u003d\u003d ImportOrderOption.BOTTOM || option \u003d\u003d ImportOrderOption.UNDER) {\n+            final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n             doVisitToken(ident, isStatic, isLastImportAndNonStatic, line);\n         }\n         else if (option \u003d\u003d ImportOrderOption.INFLOW) {\n             // \"previous\" argument is useless here\n             doVisitToken(ident, isStatic, true, line);\n         }\n         else {\n             throw new IllegalStateException(\n                     \"Unexpected option for static imports: \" + option);\n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final int line \u003d ast.getLineNo();\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n        // https://github.com/checkstyle/checkstyle/issues/1387\n        if (option \u003d\u003d ImportOrderOption.TOP || option \u003d\u003d ImportOrderOption.ABOVE) {\n            final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport, line);\n        }\n        else if (option \u003d\u003d ImportOrderOption.BOTTOM || option \u003d\u003d ImportOrderOption.UNDER) {\n            final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n            doVisitToken(ident, isStatic, isLastImportAndNonStatic, line);\n        }\n        else if (option \u003d\u003d ImportOrderOption.INFLOW) {\n            // \"previous\" argument is useless here\n            doVisitToken(ident, isStatic, true, line);\n        }\n        else {\n            throw new IllegalStateException(\n                    \"Unexpected option for static imports: \" + option);\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "1a6dafadd522b48c59289afd780a1df007f72819": {
      "type": "Ybodychange",
      "commitMessage": "Issue #5724: Groups for static imports\n",
      "commitDate": "01/07/18 7:45 AM",
      "commitName": "1a6dafadd522b48c59289afd780a1df007f72819",
      "commitAuthor": "Pavel Bludov",
      "commitDateOld": "04/06/18 9:52 PM",
      "commitNameOld": "f4e6424cd5892b72c96d35d7625560959583ea0d",
      "commitAuthorOld": "Pavel Bludov",
      "daysBetweenCommits": 26.41,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,54 @@\n     public void visitToken(DetailAST ast) {\n         final int line \u003d ast.getLineNo();\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n         final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n \n         // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n         // https://github.com/checkstyle/checkstyle/issues/1387\n         if (option \u003d\u003d ImportOrderOption.TOP) {\n             if (isLastImportAndNonStatic) {\n                 lastGroup \u003d Integer.MIN_VALUE;\n                 lastImport \u003d \"\";\n             }\n             doVisitToken(ident, isStatic, isStaticAndNotLastImport, line);\n-\n-            if (isStaticAndNotLastImport \u0026\u0026 !beforeFirstImport) {\n-                log(ident.getLineNo(), MSG_ORDERING, ident.getText());\n-            }\n         }\n         else if (option \u003d\u003d ImportOrderOption.BOTTOM) {\n             if (isStaticAndNotLastImport) {\n                 lastGroup \u003d Integer.MIN_VALUE;\n                 lastImport \u003d \"\";\n             }\n             doVisitToken(ident, isStatic, isLastImportAndNonStatic, line);\n-\n-            if (isLastImportAndNonStatic) {\n-                log(ident.getLineNo(), MSG_ORDERING, ident.getText());\n-            }\n         }\n         else if (option \u003d\u003d ImportOrderOption.ABOVE) {\n             // previous non-static but current is static\n             doVisitToken(ident, isStatic, isStaticAndNotLastImport, line);\n         }\n         else if (option \u003d\u003d ImportOrderOption.UNDER) {\n             doVisitToken(ident, isStatic, isLastImportAndNonStatic, line);\n         }\n         else if (option \u003d\u003d ImportOrderOption.INFLOW) {\n             // \"previous\" argument is useless here\n             doVisitToken(ident, isStatic, true, line);\n         }\n         else {\n             throw new IllegalStateException(\n                     \"Unexpected option for static imports: \" + option);\n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final int line \u003d ast.getLineNo();\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n        final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n\n        // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n        // https://github.com/checkstyle/checkstyle/issues/1387\n        if (option \u003d\u003d ImportOrderOption.TOP) {\n            if (isLastImportAndNonStatic) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport, line);\n        }\n        else if (option \u003d\u003d ImportOrderOption.BOTTOM) {\n            if (isStaticAndNotLastImport) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isLastImportAndNonStatic, line);\n        }\n        else if (option \u003d\u003d ImportOrderOption.ABOVE) {\n            // previous non-static but current is static\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport, line);\n        }\n        else if (option \u003d\u003d ImportOrderOption.UNDER) {\n            doVisitToken(ident, isStatic, isLastImportAndNonStatic, line);\n        }\n        else if (option \u003d\u003d ImportOrderOption.INFLOW) {\n            // \"previous\" argument is useless here\n            doVisitToken(ident, isStatic, true, line);\n        }\n        else {\n            throw new IllegalStateException(\n                    \"Unexpected option for static imports: \" + option);\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "f4e6424cd5892b72c96d35d7625560959583ea0d": {
      "type": "Ybodychange",
      "commitMessage": "Issue #5881: False positive for multiline imports\n",
      "commitDate": "04/06/18 9:52 PM",
      "commitName": "f4e6424cd5892b72c96d35d7625560959583ea0d",
      "commitAuthor": "Pavel Bludov",
      "commitDateOld": "03/06/18 9:40 PM",
      "commitNameOld": "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8",
      "commitAuthorOld": "Pavel Bludov",
      "daysBetweenCommits": 1.01,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,62 @@\n     public void visitToken(DetailAST ast) {\n+        final int line \u003d ast.getLineNo();\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n         final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n \n         // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n         // https://github.com/checkstyle/checkstyle/issues/1387\n         if (option \u003d\u003d ImportOrderOption.TOP) {\n             if (isLastImportAndNonStatic) {\n                 lastGroup \u003d Integer.MIN_VALUE;\n                 lastImport \u003d \"\";\n             }\n-            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n+            doVisitToken(ident, isStatic, isStaticAndNotLastImport, line);\n \n             if (isStaticAndNotLastImport \u0026\u0026 !beforeFirstImport) {\n                 log(ident.getLineNo(), MSG_ORDERING, ident.getText());\n             }\n         }\n         else if (option \u003d\u003d ImportOrderOption.BOTTOM) {\n             if (isStaticAndNotLastImport) {\n                 lastGroup \u003d Integer.MIN_VALUE;\n                 lastImport \u003d \"\";\n             }\n-            doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n+            doVisitToken(ident, isStatic, isLastImportAndNonStatic, line);\n \n             if (isLastImportAndNonStatic) {\n                 log(ident.getLineNo(), MSG_ORDERING, ident.getText());\n             }\n         }\n         else if (option \u003d\u003d ImportOrderOption.ABOVE) {\n             // previous non-static but current is static\n-            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n+            doVisitToken(ident, isStatic, isStaticAndNotLastImport, line);\n         }\n         else if (option \u003d\u003d ImportOrderOption.UNDER) {\n-            doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n+            doVisitToken(ident, isStatic, isLastImportAndNonStatic, line);\n         }\n         else if (option \u003d\u003d ImportOrderOption.INFLOW) {\n             // \"previous\" argument is useless here\n-            doVisitToken(ident, isStatic, true);\n+            doVisitToken(ident, isStatic, true, line);\n         }\n         else {\n             throw new IllegalStateException(\n                     \"Unexpected option for static imports: \" + option);\n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final int line \u003d ast.getLineNo();\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n        final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n\n        // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n        // https://github.com/checkstyle/checkstyle/issues/1387\n        if (option \u003d\u003d ImportOrderOption.TOP) {\n            if (isLastImportAndNonStatic) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport, line);\n\n            if (isStaticAndNotLastImport \u0026\u0026 !beforeFirstImport) {\n                log(ident.getLineNo(), MSG_ORDERING, ident.getText());\n            }\n        }\n        else if (option \u003d\u003d ImportOrderOption.BOTTOM) {\n            if (isStaticAndNotLastImport) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isLastImportAndNonStatic, line);\n\n            if (isLastImportAndNonStatic) {\n                log(ident.getLineNo(), MSG_ORDERING, ident.getText());\n            }\n        }\n        else if (option \u003d\u003d ImportOrderOption.ABOVE) {\n            // previous non-static but current is static\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport, line);\n        }\n        else if (option \u003d\u003d ImportOrderOption.UNDER) {\n            doVisitToken(ident, isStatic, isLastImportAndNonStatic, line);\n        }\n        else if (option \u003d\u003d ImportOrderOption.INFLOW) {\n            // \"previous\" argument is useless here\n            doVisitToken(ident, isStatic, true, line);\n        }\n        else {\n            throw new IllegalStateException(\n                    \"Unexpected option for static imports: \" + option);\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "6e74c7d42d90264899ef5ab78712755a3ef1811f": {
      "type": "Ybodychange",
      "commitMessage": "Issue #4981: ImportOrder with order\u003dbottom should disallow non-static import after a static import\n",
      "commitDate": "25/12/17 12:49 PM",
      "commitName": "6e74c7d42d90264899ef5ab78712755a3ef1811f",
      "commitAuthor": "Julian Hyde",
      "commitDateOld": "23/11/17 7:47 PM",
      "commitNameOld": "7faa54908ee013e10a04676f91218ffb0d2d827a",
      "commitAuthorOld": "BBG",
      "daysBetweenCommits": 31.71,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,68 @@\n     public void visitToken(DetailAST ast) {\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n         final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n \n         // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n         // https://github.com/checkstyle/checkstyle/issues/1387\n         if (option \u003d\u003d ImportOrderOption.TOP) {\n \n             if (isLastImportAndNonStatic) {\n                 lastGroup \u003d Integer.MIN_VALUE;\n                 lastImport \u003d \"\";\n             }\n             doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n \n+            if (isStaticAndNotLastImport \u0026\u0026 !beforeFirstImport) {\n+                log(ident.getLineNo(), MSG_ORDERING, ident.getText());\n+            }\n+\n         }\n         else if (option \u003d\u003d ImportOrderOption.BOTTOM) {\n \n             if (isStaticAndNotLastImport) {\n                 lastGroup \u003d Integer.MIN_VALUE;\n                 lastImport \u003d \"\";\n             }\n             doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n \n+            if (isLastImportAndNonStatic) {\n+                log(ident.getLineNo(), MSG_ORDERING, ident.getText());\n+            }\n+\n         }\n         else if (option \u003d\u003d ImportOrderOption.ABOVE) {\n             // previous non-static but current is static\n             doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n \n         }\n         else if (option \u003d\u003d ImportOrderOption.UNDER) {\n             doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n \n         }\n         else if (option \u003d\u003d ImportOrderOption.INFLOW) {\n             // \"previous\" argument is useless here\n             doVisitToken(ident, isStatic, true);\n \n         }\n         else {\n             throw new IllegalStateException(\n                     \"Unexpected option for static imports: \" + option);\n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n        final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n\n        // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n        // https://github.com/checkstyle/checkstyle/issues/1387\n        if (option \u003d\u003d ImportOrderOption.TOP) {\n\n            if (isLastImportAndNonStatic) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n\n            if (isStaticAndNotLastImport \u0026\u0026 !beforeFirstImport) {\n                log(ident.getLineNo(), MSG_ORDERING, ident.getText());\n            }\n\n        }\n        else if (option \u003d\u003d ImportOrderOption.BOTTOM) {\n\n            if (isStaticAndNotLastImport) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n\n            if (isLastImportAndNonStatic) {\n                log(ident.getLineNo(), MSG_ORDERING, ident.getText());\n            }\n\n        }\n        else if (option \u003d\u003d ImportOrderOption.ABOVE) {\n            // previous non-static but current is static\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n\n        }\n        else if (option \u003d\u003d ImportOrderOption.UNDER) {\n            doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n\n        }\n        else if (option \u003d\u003d ImportOrderOption.INFLOW) {\n            // \"previous\" argument is useless here\n            doVisitToken(ident, isStatic, true);\n\n        }\n        else {\n            throw new IllegalStateException(\n                    \"Unexpected option for static imports: \" + option);\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "2c23e07558b15944638601a2620fa6aefd12ec2a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2661: Enforce SimpleAccessorNameNotation of sevntu-checkstyle over Checkstyle source code\n",
      "commitDate": "22/12/15 8:55 AM",
      "commitName": "2c23e07558b15944638601a2620fa6aefd12ec2a",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": "12/12/15 4:03 PM",
      "commitNameOld": "f8e11359b806f6ad49855500708a622daf214c1e",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 9.7,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,60 @@\n     public void visitToken(DetailAST ast) {\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n         final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n-        final ImportOrderOption abstractOption \u003d getAbstractOption();\n \n         // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n         // https://github.com/checkstyle/checkstyle/issues/1387\n-        if (abstractOption \u003d\u003d ImportOrderOption.TOP) {\n+        if (option \u003d\u003d ImportOrderOption.TOP) {\n \n             if (isLastImportAndNonStatic) {\n                 lastGroup \u003d Integer.MIN_VALUE;\n                 lastImport \u003d \"\";\n             }\n             doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n \n         }\n-        else if (abstractOption \u003d\u003d ImportOrderOption.BOTTOM) {\n+        else if (option \u003d\u003d ImportOrderOption.BOTTOM) {\n \n             if (isStaticAndNotLastImport) {\n                 lastGroup \u003d Integer.MIN_VALUE;\n                 lastImport \u003d \"\";\n             }\n             doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n \n         }\n-        else if (abstractOption \u003d\u003d ImportOrderOption.ABOVE) {\n+        else if (option \u003d\u003d ImportOrderOption.ABOVE) {\n             // previous non-static but current is static\n             doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n \n         }\n-        else if (abstractOption \u003d\u003d ImportOrderOption.UNDER) {\n+        else if (option \u003d\u003d ImportOrderOption.UNDER) {\n             doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n \n         }\n-        else if (abstractOption \u003d\u003d ImportOrderOption.INFLOW) {\n+        else if (option \u003d\u003d ImportOrderOption.INFLOW) {\n             // \"previous\" argument is useless here\n             doVisitToken(ident, isStatic, true);\n \n         }\n         else {\n             throw new IllegalStateException(\n-                    \"Unexpected option for static imports: \" + abstractOption);\n+                    \"Unexpected option for static imports: \" + option);\n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n        final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n\n        // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n        // https://github.com/checkstyle/checkstyle/issues/1387\n        if (option \u003d\u003d ImportOrderOption.TOP) {\n\n            if (isLastImportAndNonStatic) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n\n        }\n        else if (option \u003d\u003d ImportOrderOption.BOTTOM) {\n\n            if (isStaticAndNotLastImport) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n\n        }\n        else if (option \u003d\u003d ImportOrderOption.ABOVE) {\n            // previous non-static but current is static\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n\n        }\n        else if (option \u003d\u003d ImportOrderOption.UNDER) {\n            doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n\n        }\n        else if (option \u003d\u003d ImportOrderOption.INFLOW) {\n            // \"previous\" argument is useless here\n            doVisitToken(ident, isStatic, true);\n\n        }\n        else {\n            throw new IllegalStateException(\n                    \"Unexpected option for static imports: \" + option);\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "35de50c9405825eeb68357df2625b693d2748ed9": {
      "type": "Ybodychange",
      "commitMessage": "Rename negatively named boolean variable. #1555\n\nFixes `NegativelyNamedBooleanVariable` inspection violation.\n\nDescription:\n\u003eReports negatively named variables, for example \u0027disabled\u0027, \u0027hidden\u0027, \u0027isNotChanged\u0027. It is usually more clear to invert the boolean value and remove the negation from the name.\n",
      "commitDate": "19/08/15 8:41 PM",
      "commitName": "35de50c9405825eeb68357df2625b693d2748ed9",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "18/08/15 1:25 AM",
      "commitNameOld": "54ccca18635a4aeea90da86d30590df498f76b08",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 1.8,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n     public void visitToken(DetailAST ast) {\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n-        final boolean isNotStaticAndLastImport \u003d !isStatic \u0026\u0026 lastImportStatic;\n+        final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n         final ImportOrderOption abstractOption \u003d getAbstractOption();\n \n         // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n         // https://github.com/checkstyle/checkstyle/issues/1387\n         if (abstractOption \u003d\u003d ImportOrderOption.TOP) {\n \n-            if (isNotStaticAndLastImport) {\n+            if (isLastImportAndNonStatic) {\n                 lastGroup \u003d Integer.MIN_VALUE;\n                 lastImport \u003d \"\";\n             }\n             doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n \n         }\n         else if (abstractOption \u003d\u003d ImportOrderOption.BOTTOM) {\n \n             if (isStaticAndNotLastImport) {\n                 lastGroup \u003d Integer.MIN_VALUE;\n                 lastImport \u003d \"\";\n             }\n-            doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n+            doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n \n         }\n         else if (abstractOption \u003d\u003d ImportOrderOption.ABOVE) {\n             // previous non-static but current is static\n             doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n \n         }\n         else if (abstractOption \u003d\u003d ImportOrderOption.UNDER) {\n-            doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n+            doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n \n         }\n         else if (abstractOption \u003d\u003d ImportOrderOption.INFLOW) {\n             // \"previous\" argument is useless here\n             doVisitToken(ident, isStatic, true);\n \n         }\n         else {\n             throw new IllegalStateException(\n                     \"Unexpected option for static imports: \" + abstractOption);\n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n        final boolean isLastImportAndNonStatic \u003d lastImportStatic \u0026\u0026 !isStatic;\n        final ImportOrderOption abstractOption \u003d getAbstractOption();\n\n        // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n        // https://github.com/checkstyle/checkstyle/issues/1387\n        if (abstractOption \u003d\u003d ImportOrderOption.TOP) {\n\n            if (isLastImportAndNonStatic) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n\n        }\n        else if (abstractOption \u003d\u003d ImportOrderOption.BOTTOM) {\n\n            if (isStaticAndNotLastImport) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n\n        }\n        else if (abstractOption \u003d\u003d ImportOrderOption.ABOVE) {\n            // previous non-static but current is static\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n\n        }\n        else if (abstractOption \u003d\u003d ImportOrderOption.UNDER) {\n            doVisitToken(ident, isStatic, isLastImportAndNonStatic);\n\n        }\n        else if (abstractOption \u003d\u003d ImportOrderOption.INFLOW) {\n            // \"previous\" argument is useless here\n            doVisitToken(ident, isStatic, true);\n\n        }\n        else {\n            throw new IllegalStateException(\n                    \"Unexpected option for static imports: \" + abstractOption);\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "ee1b845b7936df396543bc11dced4676d5af86b6": {
      "type": "Ybodychange",
      "commitMessage": "Remove redundant toString() calls. #1555\n\nFixes `UnnecessaryToStringCall` inspection violations.\n\nDescription:\n\u003eReports on any calls to toString() used in string concatenations and as arguments to the print() and println() methods of java.io.PrintWriter and java.io.PrintStream, the append() method of java.lang.StringBuilder and java.lang.StringBuffer or the trace(), debug(), info(), warn() and error() methods of org.slf4j.Logger. In these cases the conversion to string will be handled by the underlying library methods and an explicit call to toString() is no needed.\n Note that without the toString() call the expression will have slightly different semantics (the string null will be used instead of throwing a NullPointerException).\n",
      "commitDate": "08/08/15 7:24 PM",
      "commitName": "ee1b845b7936df396543bc11dced4676d5af86b6",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "08/08/15 1:54 AM",
      "commitNameOld": "2da168644500c915660b7cfac9668b44317d81fc",
      "commitAuthorOld": "Andrei Selkin",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n     public void visitToken(DetailAST ast) {\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n         final boolean isNotStaticAndLastImport \u003d !isStatic \u0026\u0026 lastImportStatic;\n         final ImportOrderOption abstractOption \u003d getAbstractOption();\n \n         // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n         // https://github.com/checkstyle/checkstyle/issues/1387\n         if (abstractOption \u003d\u003d ImportOrderOption.TOP) {\n \n             if (isNotStaticAndLastImport) {\n                 lastGroup \u003d Integer.MIN_VALUE;\n                 lastImport \u003d \"\";\n             }\n             doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n \n         }\n         else if (abstractOption \u003d\u003d ImportOrderOption.BOTTOM) {\n \n             if (isStaticAndNotLastImport) {\n                 lastGroup \u003d Integer.MIN_VALUE;\n                 lastImport \u003d \"\";\n             }\n             doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n \n         }\n         else if (abstractOption \u003d\u003d ImportOrderOption.ABOVE) {\n             // previous non-static but current is static\n             doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n \n         }\n         else if (abstractOption \u003d\u003d ImportOrderOption.UNDER) {\n             doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n \n         }\n         else if (abstractOption \u003d\u003d ImportOrderOption.INFLOW) {\n             // \"previous\" argument is useless here\n             doVisitToken(ident, isStatic, true);\n \n         }\n         else {\n             throw new IllegalStateException(\n-                    \"Unexpected option for static imports: \" + abstractOption.toString());\n+                    \"Unexpected option for static imports: \" + abstractOption);\n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n        final boolean isNotStaticAndLastImport \u003d !isStatic \u0026\u0026 lastImportStatic;\n        final ImportOrderOption abstractOption \u003d getAbstractOption();\n\n        // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n        // https://github.com/checkstyle/checkstyle/issues/1387\n        if (abstractOption \u003d\u003d ImportOrderOption.TOP) {\n\n            if (isNotStaticAndLastImport) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n\n        }\n        else if (abstractOption \u003d\u003d ImportOrderOption.BOTTOM) {\n\n            if (isStaticAndNotLastImport) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n\n        }\n        else if (abstractOption \u003d\u003d ImportOrderOption.ABOVE) {\n            // previous non-static but current is static\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n\n        }\n        else if (abstractOption \u003d\u003d ImportOrderOption.UNDER) {\n            doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n\n        }\n        else if (abstractOption \u003d\u003d ImportOrderOption.INFLOW) {\n            // \"previous\" argument is useless here\n            doVisitToken(ident, isStatic, true);\n\n        }\n        else {\n            throw new IllegalStateException(\n                    \"Unexpected option for static imports: \" + abstractOption);\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "f6cb72258856fdae0b89c66a0ba750712674cdee": {
      "type": "Ybodychange",
      "commitMessage": "Changing SWITCH to IF to improve coverage #1387 #1128\n",
      "commitDate": "16/07/15 5:23 PM",
      "commitName": "f6cb72258856fdae0b89c66a0ba750712674cdee",
      "commitAuthor": "Aleksandr Ivanov",
      "commitDateOld": "14/07/15 4:54 PM",
      "commitNameOld": "90e104688f270a13f42f65e7b7d263e7a9612734",
      "commitAuthorOld": "Aleksandr Ivanov",
      "daysBetweenCommits": 2.02,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,61 @@\n     public void visitToken(DetailAST ast) {\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n         final boolean isNotStaticAndLastImport \u003d !isStatic \u0026\u0026 lastImportStatic;\n         final ImportOrderOption abstractOption \u003d getAbstractOption();\n-        switch (abstractOption) {\n-            case TOP:\n-                if (isNotStaticAndLastImport) {\n-                    lastGroup \u003d Integer.MIN_VALUE;\n-                    lastImport \u003d \"\";\n-                }\n-                doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n-                break;\n \n-            case BOTTOM:\n-                if (isStaticAndNotLastImport) {\n-                    lastGroup \u003d Integer.MIN_VALUE;\n-                    lastImport \u003d \"\";\n-                }\n-                doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n-                break;\n+        // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n+        // https://github.com/checkstyle/checkstyle/issues/1387\n+        if (abstractOption \u003d\u003d ImportOrderOption.TOP) {\n \n-            case ABOVE:\n-                // previous non-static but current is static\n-                doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n-                break;\n+            if (isNotStaticAndLastImport) {\n+                lastGroup \u003d Integer.MIN_VALUE;\n+                lastImport \u003d \"\";\n+            }\n+            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n \n-            case UNDER:\n-                doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n-                break;\n+        }\n+        else if (abstractOption \u003d\u003d ImportOrderOption.BOTTOM) {\n \n-            case INFLOW:\n-                // previous argument is useless here\n-                doVisitToken(ident, isStatic, true);\n-                break;\n+            if (isStaticAndNotLastImport) {\n+                lastGroup \u003d Integer.MIN_VALUE;\n+                lastImport \u003d \"\";\n+            }\n+            doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n \n-            default:\n-                throw new IllegalStateException(\n-                        \"Unexpected option for static imports: \" + abstractOption.toString());\n+        }\n+        else if (abstractOption \u003d\u003d ImportOrderOption.ABOVE) {\n+            // previous non-static but current is static\n+            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n \n         }\n+        else if (abstractOption \u003d\u003d ImportOrderOption.UNDER) {\n+            doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n+\n+        }\n+        else if (abstractOption \u003d\u003d ImportOrderOption.INFLOW) {\n+            // \"previous\" argument is useless here\n+            doVisitToken(ident, isStatic, true);\n+\n+        }\n+        else {\n+            throw new IllegalStateException(\n+                    \"Unexpected option for static imports: \" + abstractOption.toString());\n+        }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n        final boolean isNotStaticAndLastImport \u003d !isStatic \u0026\u0026 lastImportStatic;\n        final ImportOrderOption abstractOption \u003d getAbstractOption();\n\n        // using set of IF instead of SWITCH to analyze Enum options to satisfy coverage.\n        // https://github.com/checkstyle/checkstyle/issues/1387\n        if (abstractOption \u003d\u003d ImportOrderOption.TOP) {\n\n            if (isNotStaticAndLastImport) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n\n        }\n        else if (abstractOption \u003d\u003d ImportOrderOption.BOTTOM) {\n\n            if (isStaticAndNotLastImport) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n\n        }\n        else if (abstractOption \u003d\u003d ImportOrderOption.ABOVE) {\n            // previous non-static but current is static\n            doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n\n        }\n        else if (abstractOption \u003d\u003d ImportOrderOption.UNDER) {\n            doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n\n        }\n        else if (abstractOption \u003d\u003d ImportOrderOption.INFLOW) {\n            // \"previous\" argument is useless here\n            doVisitToken(ident, isStatic, true);\n\n        }\n        else {\n            throw new IllegalStateException(\n                    \"Unexpected option for static imports: \" + abstractOption.toString());\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "90e104688f270a13f42f65e7b7d263e7a9612734": {
      "type": "Ybodychange",
      "commitMessage": "Switch options reoganized for easier reading #1376\n",
      "commitDate": "14/07/15 4:54 PM",
      "commitName": "90e104688f270a13f42f65e7b7d263e7a9612734",
      "commitAuthor": "Aleksandr Ivanov",
      "commitDateOld": "11/07/15 10:10 PM",
      "commitNameOld": "ad42ed29799a13b9426a05cc94b4a4aaba709c2c",
      "commitAuthorOld": "Aleksandr Ivanov",
      "daysBetweenCommits": 2.78,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n     public void visitToken(DetailAST ast) {\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n         final boolean isNotStaticAndLastImport \u003d !isStatic \u0026\u0026 lastImportStatic;\n         final ImportOrderOption abstractOption \u003d getAbstractOption();\n         switch (abstractOption) {\n             case TOP:\n                 if (isNotStaticAndLastImport) {\n                     lastGroup \u003d Integer.MIN_VALUE;\n                     lastImport \u003d \"\";\n                 }\n                 doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n                 break;\n \n-            case ABOVE:\n-                // previous non-static but current is static\n-                doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n-                break;\n-\n-            case INFLOW:\n-                // previous argument is useless here\n-                doVisitToken(ident, isStatic, true);\n-                break;\n-\n             case BOTTOM:\n                 if (isStaticAndNotLastImport) {\n                     lastGroup \u003d Integer.MIN_VALUE;\n                     lastImport \u003d \"\";\n                 }\n                 doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n                 break;\n \n+            case ABOVE:\n+                // previous non-static but current is static\n+                doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n+                break;\n+\n             case UNDER:\n                 doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n                 break;\n \n+            case INFLOW:\n+                // previous argument is useless here\n+                doVisitToken(ident, isStatic, true);\n+                break;\n+\n             default:\n                 throw new IllegalStateException(\n                         \"Unexpected option for static imports: \" + abstractOption.toString());\n \n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n        final boolean isNotStaticAndLastImport \u003d !isStatic \u0026\u0026 lastImportStatic;\n        final ImportOrderOption abstractOption \u003d getAbstractOption();\n        switch (abstractOption) {\n            case TOP:\n                if (isNotStaticAndLastImport) {\n                    lastGroup \u003d Integer.MIN_VALUE;\n                    lastImport \u003d \"\";\n                }\n                doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n                break;\n\n            case BOTTOM:\n                if (isStaticAndNotLastImport) {\n                    lastGroup \u003d Integer.MIN_VALUE;\n                    lastImport \u003d \"\";\n                }\n                doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n                break;\n\n            case ABOVE:\n                // previous non-static but current is static\n                doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n                break;\n\n            case UNDER:\n                doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n                break;\n\n            case INFLOW:\n                // previous argument is useless here\n                doVisitToken(ident, isStatic, true);\n                break;\n\n            default:\n                throw new IllegalStateException(\n                        \"Unexpected option for static imports: \" + abstractOption.toString());\n\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "ad42ed29799a13b9426a05cc94b4a4aaba709c2c": {
      "type": "Ybodychange",
      "commitMessage": "UT coverage improved for ImportOrderCheck #1128\n",
      "commitDate": "11/07/15 10:10 PM",
      "commitName": "ad42ed29799a13b9426a05cc94b4a4aaba709c2c",
      "commitAuthor": "Aleksandr Ivanov",
      "commitDateOld": "15/06/15 8:51 PM",
      "commitNameOld": "3ba66c7d22f0d75412a851717d976f875ef9c4d0",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 26.05,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,58 @@\n     public void visitToken(DetailAST ast) {\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n         final boolean isNotStaticAndLastImport \u003d !isStatic \u0026\u0026 lastImportStatic;\n-        switch (getAbstractOption()) {\n+        final ImportOrderOption abstractOption \u003d getAbstractOption();\n+        switch (abstractOption) {\n             case TOP:\n                 if (isNotStaticAndLastImport) {\n                     lastGroup \u003d Integer.MIN_VALUE;\n                     lastImport \u003d \"\";\n                 }\n                 doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n                 break;\n \n             case ABOVE:\n                 // previous non-static but current is static\n                 doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n                 break;\n \n             case INFLOW:\n                 // previous argument is useless here\n                 doVisitToken(ident, isStatic, true);\n                 break;\n \n             case BOTTOM:\n                 if (isStaticAndNotLastImport) {\n                     lastGroup \u003d Integer.MIN_VALUE;\n                     lastImport \u003d \"\";\n                 }\n                 doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n                 break;\n \n             case UNDER:\n-                // previous static but current is non-static\n                 doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n                 break;\n \n             default:\n-                break;\n+                throw new IllegalStateException(\n+                        \"Unexpected option for static imports: \" + abstractOption.toString());\n+\n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n        final boolean isNotStaticAndLastImport \u003d !isStatic \u0026\u0026 lastImportStatic;\n        final ImportOrderOption abstractOption \u003d getAbstractOption();\n        switch (abstractOption) {\n            case TOP:\n                if (isNotStaticAndLastImport) {\n                    lastGroup \u003d Integer.MIN_VALUE;\n                    lastImport \u003d \"\";\n                }\n                doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n                break;\n\n            case ABOVE:\n                // previous non-static but current is static\n                doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n                break;\n\n            case INFLOW:\n                // previous argument is useless here\n                doVisitToken(ident, isStatic, true);\n                break;\n\n            case BOTTOM:\n                if (isStaticAndNotLastImport) {\n                    lastGroup \u003d Integer.MIN_VALUE;\n                    lastImport \u003d \"\";\n                }\n                doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n                break;\n\n            case UNDER:\n                doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n                break;\n\n            default:\n                throw new IllegalStateException(\n                        \"Unexpected option for static imports: \" + abstractOption.toString());\n\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "3ba66c7d22f0d75412a851717d976f875ef9c4d0": {
      "type": "Ybodychange",
      "commitMessage": "ImportOrderCheck updated to follow Cyclomatic Complexity rule. #954\n",
      "commitDate": "15/06/15 8:51 PM",
      "commitName": "3ba66c7d22f0d75412a851717d976f875ef9c4d0",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "17/05/15 4:47 AM",
      "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 29.67,
      "commitsBetweenForRepo": 168,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,56 @@\n     public void visitToken(DetailAST ast) {\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n+        final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n+        final boolean isNotStaticAndLastImport \u003d !isStatic \u0026\u0026 lastImportStatic;\n         switch (getAbstractOption()) {\n             case TOP:\n-                if (!isStatic \u0026\u0026 lastImportStatic) {\n+                if (isNotStaticAndLastImport) {\n                     lastGroup \u003d Integer.MIN_VALUE;\n                     lastImport \u003d \"\";\n                 }\n-                doVisitToken(ident, isStatic, !lastImportStatic \u0026\u0026 isStatic);\n+                doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n                 break;\n \n             case ABOVE:\n                 // previous non-static but current is static\n-                doVisitToken(ident, isStatic, !lastImportStatic \u0026\u0026 isStatic);\n+                doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n                 break;\n \n             case INFLOW:\n                 // previous argument is useless here\n                 doVisitToken(ident, isStatic, true);\n                 break;\n \n             case BOTTOM:\n-                if (isStatic \u0026\u0026 !lastImportStatic) {\n+                if (isStaticAndNotLastImport) {\n                     lastGroup \u003d Integer.MIN_VALUE;\n                     lastImport \u003d \"\";\n                 }\n-                doVisitToken(ident, isStatic, lastImportStatic \u0026\u0026 !isStatic);\n+                doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n                 break;\n \n             case UNDER:\n                 // previous static but current is non-static\n-                doVisitToken(ident, isStatic, lastImportStatic \u0026\u0026 !isStatic);\n+                doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n                 break;\n \n             default:\n                 break;\n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast) {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        final boolean isStaticAndNotLastImport \u003d isStatic \u0026\u0026 !lastImportStatic;\n        final boolean isNotStaticAndLastImport \u003d !isStatic \u0026\u0026 lastImportStatic;\n        switch (getAbstractOption()) {\n            case TOP:\n                if (isNotStaticAndLastImport) {\n                    lastGroup \u003d Integer.MIN_VALUE;\n                    lastImport \u003d \"\";\n                }\n                doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n                break;\n\n            case ABOVE:\n                // previous non-static but current is static\n                doVisitToken(ident, isStatic, isStaticAndNotLastImport);\n                break;\n\n            case INFLOW:\n                // previous argument is useless here\n                doVisitToken(ident, isStatic, true);\n                break;\n\n            case BOTTOM:\n                if (isStaticAndNotLastImport) {\n                    lastGroup \u003d Integer.MIN_VALUE;\n                    lastImport \u003d \"\";\n                }\n                doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n                break;\n\n            case UNDER:\n                // previous static but current is non-static\n                doVisitToken(ident, isStatic, isNotStaticAndLastImport);\n                break;\n\n            default:\n                break;\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "cce20fc3c7bc07775d2bf9ca4a6ce9ac002ab288": {
      "type": "Ybodychange",
      "commitMessage": "fix for SF_SWITCH_FALLTHROUGH. Issue #778\n",
      "commitDate": "06/04/15 11:16 PM",
      "commitName": "cce20fc3c7bc07775d2bf9ca4a6ce9ac002ab288",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "24/03/15 12:58 PM",
      "commitNameOld": "290ae38a14021785018fbfa7c2651200534a88ca",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 13.43,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,55 @@\n     public void visitToken(DetailAST ast)\n     {\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         switch (getAbstractOption()) {\n             case TOP:\n                 if (!isStatic \u0026\u0026 lastImportStatic) {\n                     lastGroup \u003d Integer.MIN_VALUE;\n                     lastImport \u003d \"\";\n                 }\n-                // no break;\n+                doVisitToken(ident, isStatic, !lastImportStatic \u0026\u0026 isStatic);\n+                break;\n \n             case ABOVE:\n                 // previous non-static but current is static\n                 doVisitToken(ident, isStatic, !lastImportStatic \u0026\u0026 isStatic);\n                 break;\n \n             case INFLOW:\n                 // previous argument is useless here\n                 doVisitToken(ident, isStatic, true);\n                 break;\n \n             case BOTTOM:\n                 if (isStatic \u0026\u0026 !lastImportStatic) {\n                     lastGroup \u003d Integer.MIN_VALUE;\n                     lastImport \u003d \"\";\n                 }\n-                // no break;\n+                doVisitToken(ident, isStatic, lastImportStatic \u0026\u0026 !isStatic);\n+                break;\n \n             case UNDER:\n                 // previous static but current is non-static\n                 doVisitToken(ident, isStatic, lastImportStatic \u0026\u0026 !isStatic);\n                 break;\n \n             default:\n                 break;\n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        switch (getAbstractOption()) {\n            case TOP:\n                if (!isStatic \u0026\u0026 lastImportStatic) {\n                    lastGroup \u003d Integer.MIN_VALUE;\n                    lastImport \u003d \"\";\n                }\n                doVisitToken(ident, isStatic, !lastImportStatic \u0026\u0026 isStatic);\n                break;\n\n            case ABOVE:\n                // previous non-static but current is static\n                doVisitToken(ident, isStatic, !lastImportStatic \u0026\u0026 isStatic);\n                break;\n\n            case INFLOW:\n                // previous argument is useless here\n                doVisitToken(ident, isStatic, true);\n                break;\n\n            case BOTTOM:\n                if (isStatic \u0026\u0026 !lastImportStatic) {\n                    lastGroup \u003d Integer.MIN_VALUE;\n                    lastImport \u003d \"\";\n                }\n                doVisitToken(ident, isStatic, lastImportStatic \u0026\u0026 !isStatic);\n                break;\n\n            case UNDER:\n                // previous static but current is non-static\n                doVisitToken(ident, isStatic, lastImportStatic \u0026\u0026 !isStatic);\n                break;\n\n            default:\n                break;\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": "10/03/15 2:36 PM",
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "10/03/15 7:46 AM",
      "commitNameOld": "89005ddf6d5d8b494e4451d16df9fd8996c735a9",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     public void visitToken(DetailAST ast)\n     {\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         switch (getAbstractOption()) {\n             case TOP:\n                 if (!isStatic \u0026\u0026 lastImportStatic) {\n                     lastGroup \u003d Integer.MIN_VALUE;\n                     lastImport \u003d \"\";\n                 }\n                 // no break;\n \n             case ABOVE:\n                 // previous non-static but current is static\n-                doVisitToken(ident, isStatic, (!lastImportStatic \u0026\u0026 isStatic));\n+                doVisitToken(ident, isStatic, !lastImportStatic \u0026\u0026 isStatic);\n                 break;\n \n             case INFLOW:\n                 // previous argument is useless here\n                 doVisitToken(ident, isStatic, true);\n                 break;\n \n             case BOTTOM:\n                 if (isStatic \u0026\u0026 !lastImportStatic) {\n                     lastGroup \u003d Integer.MIN_VALUE;\n                     lastImport \u003d \"\";\n                 }\n                 // no break;\n \n             case UNDER:\n                 // previous static but current is non-static\n-                doVisitToken(ident, isStatic, (lastImportStatic \u0026\u0026 !isStatic));\n+                doVisitToken(ident, isStatic, lastImportStatic \u0026\u0026 !isStatic);\n                 break;\n \n             default:\n                 break;\n         }\n \n         lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n         lastImportStatic \u003d isStatic;\n         beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        switch (getAbstractOption()) {\n            case TOP:\n                if (!isStatic \u0026\u0026 lastImportStatic) {\n                    lastGroup \u003d Integer.MIN_VALUE;\n                    lastImport \u003d \"\";\n                }\n                // no break;\n\n            case ABOVE:\n                // previous non-static but current is static\n                doVisitToken(ident, isStatic, !lastImportStatic \u0026\u0026 isStatic);\n                break;\n\n            case INFLOW:\n                // previous argument is useless here\n                doVisitToken(ident, isStatic, true);\n                break;\n\n            case BOTTOM:\n                if (isStatic \u0026\u0026 !lastImportStatic) {\n                    lastGroup \u003d Integer.MIN_VALUE;\n                    lastImport \u003d \"\";\n                }\n                // no break;\n\n            case UNDER:\n                // previous static but current is non-static\n                doVisitToken(ident, isStatic, lastImportStatic \u0026\u0026 !isStatic);\n                break;\n\n            default:\n                break;\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "16dac636b246c658cad31ee9b2e45c53b851d4f2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, imports, #512\n",
      "commitDate": "19/01/15 6:35 AM",
      "commitName": "16dac636b246c658cad31ee9b2e45c53b851d4f2",
      "commitAuthor": "alexkravin",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Prefixes, imports, #512\n",
          "commitDate": "19/01/15 6:35 AM",
          "commitName": "16dac636b246c658cad31ee9b2e45c53b851d4f2",
          "commitAuthor": "alexkravin",
          "commitDateOld": "04/03/14 9:18 AM",
          "commitNameOld": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
          "commitAuthorOld": "Ivan Sopov",
          "daysBetweenCommits": 320.89,
          "commitsBetweenForRepo": 471,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,53 @@\n-    public void visitToken(DetailAST aAST)\n+    public void visitToken(DetailAST ast)\n     {\n         final FullIdent ident;\n         final boolean isStatic;\n \n-        if (aAST.getType() \u003d\u003d TokenTypes.IMPORT) {\n-            ident \u003d FullIdent.createFullIdentBelow(aAST);\n+        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n+            ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n-            ident \u003d FullIdent.createFullIdent(aAST.getFirstChild()\n+            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         switch (getAbstractOption()) {\n         case TOP:\n-            if (!isStatic \u0026\u0026 mLastImportStatic) {\n-                mLastGroup \u003d Integer.MIN_VALUE;\n-                mLastImport \u003d \"\";\n+            if (!isStatic \u0026\u0026 lastImportStatic) {\n+                lastGroup \u003d Integer.MIN_VALUE;\n+                lastImport \u003d \"\";\n             }\n             // no break;\n \n         case ABOVE:\n             // previous non-static but current is static\n-            doVisitToken(ident, isStatic, (!mLastImportStatic \u0026\u0026 isStatic));\n+            doVisitToken(ident, isStatic, (!lastImportStatic \u0026\u0026 isStatic));\n             break;\n \n         case INFLOW:\n             // previous argument is useless here\n             doVisitToken(ident, isStatic, true);\n             break;\n \n         case BOTTOM:\n-            if (isStatic \u0026\u0026 !mLastImportStatic) {\n-                mLastGroup \u003d Integer.MIN_VALUE;\n-                mLastImport \u003d \"\";\n+            if (isStatic \u0026\u0026 !lastImportStatic) {\n+                lastGroup \u003d Integer.MIN_VALUE;\n+                lastImport \u003d \"\";\n             }\n             // no break;\n \n         case UNDER:\n             // previous static but current is non-static\n-            doVisitToken(ident, isStatic, (mLastImportStatic \u0026\u0026 !isStatic));\n+            doVisitToken(ident, isStatic, (lastImportStatic \u0026\u0026 !isStatic));\n             break;\n \n         default:\n             break;\n         }\n \n-        mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n-        mLastImportStatic \u003d isStatic;\n-        mBeforeFirstImport \u003d false;\n+        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n+        lastImportStatic \u003d isStatic;\n+        beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        switch (getAbstractOption()) {\n        case TOP:\n            if (!isStatic \u0026\u0026 lastImportStatic) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            // no break;\n\n        case ABOVE:\n            // previous non-static but current is static\n            doVisitToken(ident, isStatic, (!lastImportStatic \u0026\u0026 isStatic));\n            break;\n\n        case INFLOW:\n            // previous argument is useless here\n            doVisitToken(ident, isStatic, true);\n            break;\n\n        case BOTTOM:\n            if (isStatic \u0026\u0026 !lastImportStatic) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            // no break;\n\n        case UNDER:\n            // previous static but current is non-static\n            doVisitToken(ident, isStatic, (lastImportStatic \u0026\u0026 !isStatic));\n            break;\n\n        default:\n            break;\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
          "extendedDetails": {
            "oldValue": "[aAST-DetailAST]",
            "newValue": "[ast-DetailAST]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Prefixes, imports, #512\n",
          "commitDate": "19/01/15 6:35 AM",
          "commitName": "16dac636b246c658cad31ee9b2e45c53b851d4f2",
          "commitAuthor": "alexkravin",
          "commitDateOld": "04/03/14 9:18 AM",
          "commitNameOld": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
          "commitAuthorOld": "Ivan Sopov",
          "daysBetweenCommits": 320.89,
          "commitsBetweenForRepo": 471,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,53 @@\n-    public void visitToken(DetailAST aAST)\n+    public void visitToken(DetailAST ast)\n     {\n         final FullIdent ident;\n         final boolean isStatic;\n \n-        if (aAST.getType() \u003d\u003d TokenTypes.IMPORT) {\n-            ident \u003d FullIdent.createFullIdentBelow(aAST);\n+        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n+            ident \u003d FullIdent.createFullIdentBelow(ast);\n             isStatic \u003d false;\n         }\n         else {\n-            ident \u003d FullIdent.createFullIdent(aAST.getFirstChild()\n+            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         switch (getAbstractOption()) {\n         case TOP:\n-            if (!isStatic \u0026\u0026 mLastImportStatic) {\n-                mLastGroup \u003d Integer.MIN_VALUE;\n-                mLastImport \u003d \"\";\n+            if (!isStatic \u0026\u0026 lastImportStatic) {\n+                lastGroup \u003d Integer.MIN_VALUE;\n+                lastImport \u003d \"\";\n             }\n             // no break;\n \n         case ABOVE:\n             // previous non-static but current is static\n-            doVisitToken(ident, isStatic, (!mLastImportStatic \u0026\u0026 isStatic));\n+            doVisitToken(ident, isStatic, (!lastImportStatic \u0026\u0026 isStatic));\n             break;\n \n         case INFLOW:\n             // previous argument is useless here\n             doVisitToken(ident, isStatic, true);\n             break;\n \n         case BOTTOM:\n-            if (isStatic \u0026\u0026 !mLastImportStatic) {\n-                mLastGroup \u003d Integer.MIN_VALUE;\n-                mLastImport \u003d \"\";\n+            if (isStatic \u0026\u0026 !lastImportStatic) {\n+                lastGroup \u003d Integer.MIN_VALUE;\n+                lastImport \u003d \"\";\n             }\n             // no break;\n \n         case UNDER:\n             // previous static but current is non-static\n-            doVisitToken(ident, isStatic, (mLastImportStatic \u0026\u0026 !isStatic));\n+            doVisitToken(ident, isStatic, (lastImportStatic \u0026\u0026 !isStatic));\n             break;\n \n         default:\n             break;\n         }\n \n-        mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n-        mLastImportStatic \u003d isStatic;\n-        mBeforeFirstImport \u003d false;\n+        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n+        lastImportStatic \u003d isStatic;\n+        beforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void visitToken(DetailAST ast)\n    {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (ast.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(ast);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(ast.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        switch (getAbstractOption()) {\n        case TOP:\n            if (!isStatic \u0026\u0026 lastImportStatic) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            // no break;\n\n        case ABOVE:\n            // previous non-static but current is static\n            doVisitToken(ident, isStatic, (!lastImportStatic \u0026\u0026 isStatic));\n            break;\n\n        case INFLOW:\n            // previous argument is useless here\n            doVisitToken(ident, isStatic, true);\n            break;\n\n        case BOTTOM:\n            if (isStatic \u0026\u0026 !lastImportStatic) {\n                lastGroup \u003d Integer.MIN_VALUE;\n                lastImport \u003d \"\";\n            }\n            // no break;\n\n        case UNDER:\n            // previous static but current is non-static\n            doVisitToken(ident, isStatic, (lastImportStatic \u0026\u0026 !isStatic));\n            break;\n\n        default:\n            break;\n        }\n\n        lastImportLine \u003d ast.findFirstToken(TokenTypes.SEMI).getLineNo();\n        lastImportStatic \u003d isStatic;\n        beforeFirstImport \u003d false;\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
          "extendedDetails": {}
        }
      ]
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": "04/03/14 9:18 AM",
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": "26/02/14 10:35 PM",
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void visitToken(DetailAST aAST)\n    {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (aAST.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(aAST);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(aAST.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        switch (getAbstractOption()) {\n        case TOP:\n            if (!isStatic \u0026\u0026 mLastImportStatic) {\n                mLastGroup \u003d Integer.MIN_VALUE;\n                mLastImport \u003d \"\";\n            }\n            // no break;\n\n        case ABOVE:\n            // previous non-static but current is static\n            doVisitToken(ident, isStatic, (!mLastImportStatic \u0026\u0026 isStatic));\n            break;\n\n        case INFLOW:\n            // previous argument is useless here\n            doVisitToken(ident, isStatic, true);\n            break;\n\n        case BOTTOM:\n            if (isStatic \u0026\u0026 !mLastImportStatic) {\n                mLastGroup \u003d Integer.MIN_VALUE;\n                mLastImport \u003d \"\";\n            }\n            // no break;\n\n        case UNDER:\n            // previous static but current is non-static\n            doVisitToken(ident, isStatic, (mLastImportStatic \u0026\u0026 !isStatic));\n            break;\n\n        default:\n            break;\n        }\n\n        mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n        mLastImportStatic \u003d isStatic;\n        mBeforeFirstImport \u003d false;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {
        "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java"
      }
    },
    "d62a2cc02092cb6c1a1666630a51a6ec7c50a878": {
      "type": "Ybodychange",
      "commitMessage": "Inspired by patch# 2111354 - changes to remove casting. Neat trick\n",
      "commitDate": "18/09/08 4:34 AM",
      "commitName": "d62a2cc02092cb6c1a1666630a51a6ec7c50a878",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "07/09/08 4:28 AM",
      "commitNameOld": "22136c67e9c83494e7aa977ffe7a79beee1b4175",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 11.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final FullIdent ident;\n         final boolean isStatic;\n \n         if (aAST.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(aAST);\n             isStatic \u003d false;\n         }\n         else {\n-            ident \u003d FullIdent.createFullIdent((DetailAST) aAST.getFirstChild()\n+            ident \u003d FullIdent.createFullIdent(aAST.getFirstChild()\n                     .getNextSibling());\n             isStatic \u003d true;\n         }\n \n         switch (getAbstractOption()) {\n         case TOP:\n             if (!isStatic \u0026\u0026 mLastImportStatic) {\n                 mLastGroup \u003d Integer.MIN_VALUE;\n                 mLastImport \u003d \"\";\n             }\n             // no break;\n \n         case ABOVE:\n             // previous non-static but current is static\n             doVisitToken(ident, isStatic, (!mLastImportStatic \u0026\u0026 isStatic));\n             break;\n \n         case INFLOW:\n             // previous argument is useless here\n             doVisitToken(ident, isStatic, true);\n             break;\n \n         case BOTTOM:\n             if (isStatic \u0026\u0026 !mLastImportStatic) {\n                 mLastGroup \u003d Integer.MIN_VALUE;\n                 mLastImport \u003d \"\";\n             }\n             // no break;\n \n         case UNDER:\n             // previous static but current is non-static\n             doVisitToken(ident, isStatic, (mLastImportStatic \u0026\u0026 !isStatic));\n             break;\n \n         default:\n             break;\n         }\n \n         mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n         mLastImportStatic \u003d isStatic;\n         mBeforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST aAST)\n    {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (aAST.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(aAST);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(aAST.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        switch (getAbstractOption()) {\n        case TOP:\n            if (!isStatic \u0026\u0026 mLastImportStatic) {\n                mLastGroup \u003d Integer.MIN_VALUE;\n                mLastImport \u003d \"\";\n            }\n            // no break;\n\n        case ABOVE:\n            // previous non-static but current is static\n            doVisitToken(ident, isStatic, (!mLastImportStatic \u0026\u0026 isStatic));\n            break;\n\n        case INFLOW:\n            // previous argument is useless here\n            doVisitToken(ident, isStatic, true);\n            break;\n\n        case BOTTOM:\n            if (isStatic \u0026\u0026 !mLastImportStatic) {\n                mLastGroup \u003d Integer.MIN_VALUE;\n                mLastImport \u003d \"\";\n            }\n            // no break;\n\n        case UNDER:\n            // previous static but current is non-static\n            doVisitToken(ident, isStatic, (mLastImportStatic \u0026\u0026 !isStatic));\n            break;\n\n        default:\n            break;\n        }\n\n        mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n        mLastImportStatic \u003d isStatic;\n        mBeforeFirstImport \u003d false;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "22136c67e9c83494e7aa977ffe7a79beee1b4175": {
      "type": "Ybodychange",
      "commitMessage": "Add new options to the ImportOrderCheck to make it more flexible. Thanks to David Didier for providing patch #1854213.\n",
      "commitDate": "07/09/08 4:28 AM",
      "commitName": "22136c67e9c83494e7aa977ffe7a79beee1b4175",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "13/01/08 11:42 PM",
      "commitNameOld": "fd90bd5aa5cd623b08a2e44ef05e8fac8045d333",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 237.16,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,53 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final FullIdent ident;\n-        boolean isStatic;\n+        final boolean isStatic;\n+\n         if (aAST.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(aAST);\n             isStatic \u003d false;\n         }\n         else {\n-            ident \u003d FullIdent.createFullIdent(\n-                (DetailAST) aAST.getFirstChild().getNextSibling());\n+            ident \u003d FullIdent.createFullIdent((DetailAST) aAST.getFirstChild()\n+                    .getNextSibling());\n             isStatic \u003d true;\n         }\n \n-        if (ident !\u003d null) {\n-            final String name \u003d ident.getText();\n-            final int groupIdx \u003d getGroupNumber(name);\n-            final int line \u003d ident.getLineNo();\n+        switch (getAbstractOption()) {\n+        case TOP:\n+            if (!isStatic \u0026\u0026 mLastImportStatic) {\n+                mLastGroup \u003d Integer.MIN_VALUE;\n+                mLastImport \u003d \"\";\n+            }\n+            // no break;\n \n-            if (groupIdx \u003e mLastGroup) {\n-                if (!mBeforeFirstImport \u0026\u0026 mSeparated) {\n-                    // This check should be made more robust to handle\n-                    // comments and imports that span more than one line.\n-                    if (line - mLastImportLine \u003c 2) {\n-                        log(line, \"import.separation\", name);\n-                    }\n-                }\n-            }\n-            else if (groupIdx \u003d\u003d mLastGroup) {\n-                if (mOrdered) {\n-                    boolean shouldFireError \u003d false;\n-                    if (mCaseSensitive) {\n-                        shouldFireError \u003d\n-                            //current and previous static or current and\n-                            //previous non-static\n-                            (!(mLastImportStatic ^ isStatic)\n-                            \u0026\u0026\n-                            //and out of lexicographic order\n-                            (mLastImport.compareTo(name) \u003e\u003d 0))\n-                            ||\n-                            //previous static but current is non-static\n-                            (mLastImportStatic \u0026\u0026 !isStatic);\n-                    }\n-                    else {\n-                        shouldFireError \u003d\n-                                //current and previous static or current and\n-                                //previous non-static\n-                                (!(mLastImportStatic ^ isStatic)\n-                                \u0026\u0026\n-                                //and out of lexicographic order\n-                                (mLastImport.compareToIgnoreCase(name) \u003e\u003d 0))\n-                                ||\n-                                //previous static but current is non-static\n-                                (mLastImportStatic \u0026\u0026 !isStatic);\n-                    }\n-                    if (shouldFireError) {\n-                        log(line, \"import.ordering\", name);\n-                    }\n-                }\n-            }\n-            else {\n-                log(line, \"import.ordering\", name);\n-            }\n+        case ABOVE:\n+            // previous non-static but current is static\n+            doVisitToken(ident, isStatic, (!mLastImportStatic \u0026\u0026 isStatic));\n+            break;\n \n-            mLastGroup \u003d groupIdx;\n-            mLastImport \u003d name;\n-            mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n-            mLastImportStatic \u003d isStatic;\n-            mBeforeFirstImport \u003d false;\n+        case INFLOW:\n+            // previous argument is useless here\n+            doVisitToken(ident, isStatic, true);\n+            break;\n+\n+        case BOTTOM:\n+            if (isStatic \u0026\u0026 !mLastImportStatic) {\n+                mLastGroup \u003d Integer.MIN_VALUE;\n+                mLastImport \u003d \"\";\n+            }\n+            // no break;\n+\n+        case UNDER:\n+            // previous static but current is non-static\n+            doVisitToken(ident, isStatic, (mLastImportStatic \u0026\u0026 !isStatic));\n+            break;\n+\n+        default:\n+            break;\n         }\n+\n+        mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n+        mLastImportStatic \u003d isStatic;\n+        mBeforeFirstImport \u003d false;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST aAST)\n    {\n        final FullIdent ident;\n        final boolean isStatic;\n\n        if (aAST.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(aAST);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent((DetailAST) aAST.getFirstChild()\n                    .getNextSibling());\n            isStatic \u003d true;\n        }\n\n        switch (getAbstractOption()) {\n        case TOP:\n            if (!isStatic \u0026\u0026 mLastImportStatic) {\n                mLastGroup \u003d Integer.MIN_VALUE;\n                mLastImport \u003d \"\";\n            }\n            // no break;\n\n        case ABOVE:\n            // previous non-static but current is static\n            doVisitToken(ident, isStatic, (!mLastImportStatic \u0026\u0026 isStatic));\n            break;\n\n        case INFLOW:\n            // previous argument is useless here\n            doVisitToken(ident, isStatic, true);\n            break;\n\n        case BOTTOM:\n            if (isStatic \u0026\u0026 !mLastImportStatic) {\n                mLastGroup \u003d Integer.MIN_VALUE;\n                mLastImport \u003d \"\";\n            }\n            // no break;\n\n        case UNDER:\n            // previous static but current is non-static\n            doVisitToken(ident, isStatic, (mLastImportStatic \u0026\u0026 !isStatic));\n            break;\n\n        default:\n            break;\n        }\n\n        mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n        mLastImportStatic \u003d isStatic;\n        mBeforeFirstImport \u003d false;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "35d1673788bbbac8263fdb69275dc6a63b095a24": {
      "type": "Ybodychange",
      "commitMessage": "Making local variables final where possible.\n",
      "commitDate": "06/07/06 8:44 PM",
      "commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "09/01/05 2:50 AM",
      "commitNameOld": "0d887cde58e54d920644ee543dab346b93e8aae9",
      "commitAuthorOld": "Lars Khne",
      "daysBetweenCommits": 543.7,
      "commitsBetweenForRepo": 275,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final FullIdent ident;\n         boolean isStatic;\n         if (aAST.getType() \u003d\u003d TokenTypes.IMPORT) {\n             ident \u003d FullIdent.createFullIdentBelow(aAST);\n             isStatic \u003d false;\n         }\n         else {\n             ident \u003d FullIdent.createFullIdent(\n                 (DetailAST) aAST.getFirstChild().getNextSibling());\n             isStatic \u003d true;\n         }\n \n         if (ident !\u003d null) {\n-            String name \u003d ident.getText();\n-            int groupIdx \u003d getGroupNumber(name);\n+            final String name \u003d ident.getText();\n+            final int groupIdx \u003d getGroupNumber(name);\n             final int line \u003d ident.getLineNo();\n \n             if (groupIdx \u003e mLastGroup) {\n                 if (!mBeforeFirstImport \u0026\u0026 mSeparated) {\n                     // This check should be made more robust to handle\n                     // comments and imports that span more than one line.\n                     if (line - mLastImportLine \u003c 2) {\n                         log(line, \"import.separation\", name);\n                     }\n                 }\n             }\n             else if (groupIdx \u003d\u003d mLastGroup) {\n                 if (mOrdered) {\n                     boolean shouldFireError \u003d false;\n                     if (mCaseSensitive) {\n                         shouldFireError \u003d\n                             //current and previous static or current and\n                             //previous non-static\n                             (!(mLastImportStatic ^ isStatic)\n                             \u0026\u0026\n                             //and out of lexicographic order\n                             (mLastImport.compareTo(name) \u003e\u003d 0))\n                             ||\n                             //previous static but current is non-static\n                             (mLastImportStatic \u0026\u0026 !isStatic);\n                     }\n                     else {\n                         shouldFireError \u003d\n                                 //current and previous static or current and\n                                 //previous non-static\n                                 (!(mLastImportStatic ^ isStatic)\n                                 \u0026\u0026\n                                 //and out of lexicographic order\n                                 (mLastImport.compareToIgnoreCase(name) \u003e\u003d 0))\n                                 ||\n                                 //previous static but current is non-static\n                                 (mLastImportStatic \u0026\u0026 !isStatic);\n                     }\n                     if (shouldFireError) {\n                         log(line, \"import.ordering\", name);\n                     }\n                 }\n             }\n             else {\n                 log(line, \"import.ordering\", name);\n             }\n \n             mLastGroup \u003d groupIdx;\n             mLastImport \u003d name;\n             mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n             mLastImportStatic \u003d isStatic;\n             mBeforeFirstImport \u003d false;\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST aAST)\n    {\n        final FullIdent ident;\n        boolean isStatic;\n        if (aAST.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(aAST);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(\n                (DetailAST) aAST.getFirstChild().getNextSibling());\n            isStatic \u003d true;\n        }\n\n        if (ident !\u003d null) {\n            final String name \u003d ident.getText();\n            final int groupIdx \u003d getGroupNumber(name);\n            final int line \u003d ident.getLineNo();\n\n            if (groupIdx \u003e mLastGroup) {\n                if (!mBeforeFirstImport \u0026\u0026 mSeparated) {\n                    // This check should be made more robust to handle\n                    // comments and imports that span more than one line.\n                    if (line - mLastImportLine \u003c 2) {\n                        log(line, \"import.separation\", name);\n                    }\n                }\n            }\n            else if (groupIdx \u003d\u003d mLastGroup) {\n                if (mOrdered) {\n                    boolean shouldFireError \u003d false;\n                    if (mCaseSensitive) {\n                        shouldFireError \u003d\n                            //current and previous static or current and\n                            //previous non-static\n                            (!(mLastImportStatic ^ isStatic)\n                            \u0026\u0026\n                            //and out of lexicographic order\n                            (mLastImport.compareTo(name) \u003e\u003d 0))\n                            ||\n                            //previous static but current is non-static\n                            (mLastImportStatic \u0026\u0026 !isStatic);\n                    }\n                    else {\n                        shouldFireError \u003d\n                                //current and previous static or current and\n                                //previous non-static\n                                (!(mLastImportStatic ^ isStatic)\n                                \u0026\u0026\n                                //and out of lexicographic order\n                                (mLastImport.compareToIgnoreCase(name) \u003e\u003d 0))\n                                ||\n                                //previous static but current is non-static\n                                (mLastImportStatic \u0026\u0026 !isStatic);\n                    }\n                    if (shouldFireError) {\n                        log(line, \"import.ordering\", name);\n                    }\n                }\n            }\n            else {\n                log(line, \"import.ordering\", name);\n            }\n\n            mLastGroup \u003d groupIdx;\n            mLastImport \u003d name;\n            mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n            mLastImportStatic \u003d isStatic;\n            mBeforeFirstImport \u003d false;\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "6125beffc437f970eae276b4a6542265c6547784": {
      "type": "Ybodychange",
      "commitMessage": "Initial Java 1.5 support\n",
      "commitDate": "27/09/04 11:55 AM",
      "commitName": "6125beffc437f970eae276b4a6542265c6547784",
      "commitAuthor": "Michael Studman",
      "commitDateOld": "26/08/04 6:47 AM",
      "commitNameOld": "2f70947ed74ab968324fdcf83f808ff1d88df1fb",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 32.21,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,71 @@\n     public void visitToken(DetailAST aAST)\n     {\n-        final FullIdent ident \u003d FullIdent.createFullIdentBelow(aAST);\n+        final FullIdent ident;\n+        boolean isStatic;\n+        if (aAST.getType() \u003d\u003d TokenTypes.IMPORT) {\n+            ident \u003d FullIdent.createFullIdentBelow(aAST);\n+            isStatic \u003d false;\n+        }\n+        else {\n+            ident \u003d FullIdent.createFullIdent(\n+                (DetailAST) aAST.getFirstChild().getNextSibling());\n+            isStatic \u003d true;\n+        }\n \n         if (ident !\u003d null) {\n             String name \u003d ident.getText();\n             int groupIdx \u003d getGroupNumber(name);\n             final int line \u003d ident.getLineNo();\n \n             if (groupIdx \u003e mLastGroup) {\n                 if (!mBeforeFirstImport \u0026\u0026 mSeparated) {\n                     // This check should be made more robust to handle\n                     // comments and imports that span more than one line.\n                     if (line - mLastImportLine \u003c 2) {\n                         log(line, \"import.separation\", name);\n                     }\n                 }\n             }\n             else if (groupIdx \u003d\u003d mLastGroup) {\n                 if (mOrdered) {\n                     boolean shouldFireError \u003d false;\n                     if (mCaseSensitive) {\n-                        shouldFireError \u003d (mLastImport.compareTo(name) \u003e\u003d 0);\n+                        shouldFireError \u003d\n+                            //current and previous static or current and\n+                            //previous non-static\n+                            (!(mLastImportStatic ^ isStatic)\n+                            \u0026\u0026\n+                            //and out of lexicographic order\n+                            (mLastImport.compareTo(name) \u003e\u003d 0))\n+                            ||\n+                            //previous static but current is non-static\n+                            (mLastImportStatic \u0026\u0026 !isStatic);\n                     }\n                     else {\n                         shouldFireError \u003d\n-                            (mLastImport.compareToIgnoreCase(name) \u003e\u003d 0);\n+                                //current and previous static or current and\n+                                //previous non-static\n+                                (!(mLastImportStatic ^ isStatic)\n+                                \u0026\u0026\n+                                //and out of lexicographic order\n+                                (mLastImport.compareToIgnoreCase(name) \u003e\u003d 0))\n+                                ||\n+                                //previous static but current is non-static\n+                                (mLastImportStatic \u0026\u0026 !isStatic);\n                     }\n                     if (shouldFireError) {\n                         log(line, \"import.ordering\", name);\n                     }\n                 }\n             }\n             else {\n                 log(line, \"import.ordering\", name);\n             }\n \n             mLastGroup \u003d groupIdx;\n             mLastImport \u003d name;\n             mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n+            mLastImportStatic \u003d isStatic;\n             mBeforeFirstImport \u003d false;\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST aAST)\n    {\n        final FullIdent ident;\n        boolean isStatic;\n        if (aAST.getType() \u003d\u003d TokenTypes.IMPORT) {\n            ident \u003d FullIdent.createFullIdentBelow(aAST);\n            isStatic \u003d false;\n        }\n        else {\n            ident \u003d FullIdent.createFullIdent(\n                (DetailAST) aAST.getFirstChild().getNextSibling());\n            isStatic \u003d true;\n        }\n\n        if (ident !\u003d null) {\n            String name \u003d ident.getText();\n            int groupIdx \u003d getGroupNumber(name);\n            final int line \u003d ident.getLineNo();\n\n            if (groupIdx \u003e mLastGroup) {\n                if (!mBeforeFirstImport \u0026\u0026 mSeparated) {\n                    // This check should be made more robust to handle\n                    // comments and imports that span more than one line.\n                    if (line - mLastImportLine \u003c 2) {\n                        log(line, \"import.separation\", name);\n                    }\n                }\n            }\n            else if (groupIdx \u003d\u003d mLastGroup) {\n                if (mOrdered) {\n                    boolean shouldFireError \u003d false;\n                    if (mCaseSensitive) {\n                        shouldFireError \u003d\n                            //current and previous static or current and\n                            //previous non-static\n                            (!(mLastImportStatic ^ isStatic)\n                            \u0026\u0026\n                            //and out of lexicographic order\n                            (mLastImport.compareTo(name) \u003e\u003d 0))\n                            ||\n                            //previous static but current is non-static\n                            (mLastImportStatic \u0026\u0026 !isStatic);\n                    }\n                    else {\n                        shouldFireError \u003d\n                                //current and previous static or current and\n                                //previous non-static\n                                (!(mLastImportStatic ^ isStatic)\n                                \u0026\u0026\n                                //and out of lexicographic order\n                                (mLastImport.compareToIgnoreCase(name) \u003e\u003d 0))\n                                ||\n                                //previous static but current is non-static\n                                (mLastImportStatic \u0026\u0026 !isStatic);\n                    }\n                    if (shouldFireError) {\n                        log(line, \"import.ordering\", name);\n                    }\n                }\n            }\n            else {\n                log(line, \"import.ordering\", name);\n            }\n\n            mLastGroup \u003d groupIdx;\n            mLastImport \u003d name;\n            mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n            mLastImportStatic \u003d isStatic;\n            mBeforeFirstImport \u003d false;\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "2f70947ed74ab968324fdcf83f808ff1d88df1fb": {
      "type": "Ybodychange",
      "commitMessage": "Tighten up code\n",
      "commitDate": "26/08/04 6:47 AM",
      "commitName": "2f70947ed74ab968324fdcf83f808ff1d88df1fb",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "14/01/04 1:10 PM",
      "commitNameOld": "5670252b46f4915b276e647fa000361915eb4ff4",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 224.69,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final FullIdent ident \u003d FullIdent.createFullIdentBelow(aAST);\n \n         if (ident !\u003d null) {\n             String name \u003d ident.getText();\n             int groupIdx \u003d getGroupNumber(name);\n-            int line \u003d ident.getLineNo();\n+            final int line \u003d ident.getLineNo();\n \n             if (groupIdx \u003e mLastGroup) {\n                 if (!mBeforeFirstImport \u0026\u0026 mSeparated) {\n                     // This check should be made more robust to handle\n                     // comments and imports that span more than one line.\n                     if (line - mLastImportLine \u003c 2) {\n                         log(line, \"import.separation\", name);\n                     }\n                 }\n             }\n             else if (groupIdx \u003d\u003d mLastGroup) {\n                 if (mOrdered) {\n                     boolean shouldFireError \u003d false;\n                     if (mCaseSensitive) {\n                         shouldFireError \u003d (mLastImport.compareTo(name) \u003e\u003d 0);\n                     }\n                     else {\n                         shouldFireError \u003d\n                             (mLastImport.compareToIgnoreCase(name) \u003e\u003d 0);\n                     }\n                     if (shouldFireError) {\n                         log(line, \"import.ordering\", name);\n                     }\n                 }\n             }\n             else {\n                 log(line, \"import.ordering\", name);\n             }\n \n             mLastGroup \u003d groupIdx;\n             mLastImport \u003d name;\n             mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n             mBeforeFirstImport \u003d false;\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST aAST)\n    {\n        final FullIdent ident \u003d FullIdent.createFullIdentBelow(aAST);\n\n        if (ident !\u003d null) {\n            String name \u003d ident.getText();\n            int groupIdx \u003d getGroupNumber(name);\n            final int line \u003d ident.getLineNo();\n\n            if (groupIdx \u003e mLastGroup) {\n                if (!mBeforeFirstImport \u0026\u0026 mSeparated) {\n                    // This check should be made more robust to handle\n                    // comments and imports that span more than one line.\n                    if (line - mLastImportLine \u003c 2) {\n                        log(line, \"import.separation\", name);\n                    }\n                }\n            }\n            else if (groupIdx \u003d\u003d mLastGroup) {\n                if (mOrdered) {\n                    boolean shouldFireError \u003d false;\n                    if (mCaseSensitive) {\n                        shouldFireError \u003d (mLastImport.compareTo(name) \u003e\u003d 0);\n                    }\n                    else {\n                        shouldFireError \u003d\n                            (mLastImport.compareToIgnoreCase(name) \u003e\u003d 0);\n                    }\n                    if (shouldFireError) {\n                        log(line, \"import.ordering\", name);\n                    }\n                }\n            }\n            else {\n                log(line, \"import.ordering\", name);\n            }\n\n            mLastGroup \u003d groupIdx;\n            mLastImport \u003d name;\n            mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n            mBeforeFirstImport \u003d false;\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "c6bbd6774988073dfeea8e6f9bea0689f0de19bb": {
      "type": "Ybodychange",
      "commitMessage": "Added caseSensitive property to ImportOrder check (bug 842604).\n",
      "commitDate": "16/11/03 12:40 AM",
      "commitName": "c6bbd6774988073dfeea8e6f9bea0689f0de19bb",
      "commitAuthor": "Oleg Sukhodolsky",
      "commitDateOld": "16/09/03 11:37 AM",
      "commitNameOld": "2a1705e70d334700734b3df3ebefea0be878127a",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 60.59,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,43 @@\n     public void visitToken(DetailAST aAST)\n     {\n         final FullIdent ident \u003d FullIdent.createFullIdentBelow(aAST);\n \n         if (ident !\u003d null) {\n             String name \u003d ident.getText();\n             int groupIdx \u003d getGroupNumber(name);\n             int line \u003d ident.getLineNo();\n \n             if (groupIdx \u003e mLastGroup) {\n                 if (!mBeforeFirstImport \u0026\u0026 mSeparated) {\n                     // This check should be made more robust to handle\n                     // comments and imports that span more than one line.\n                     if (line - mLastImportLine \u003c 2) {\n                         log(line, \"import.separation\", name);\n                     }\n                 }\n             }\n             else if (groupIdx \u003d\u003d mLastGroup) {\n                 if (mOrdered) {\n-                    if (mLastImport.compareTo(name) \u003e\u003d 0) {\n+                    boolean shouldFireError \u003d false;\n+                    if (mCaseSensitive) {\n+                        shouldFireError \u003d (mLastImport.compareTo(name) \u003e\u003d 0);\n+                    }\n+                    else {\n+                        shouldFireError \u003d\n+                            (mLastImport.compareToIgnoreCase(name) \u003e\u003d 0);\n+                    }\n+                    if (shouldFireError) {\n                         log(line, \"import.ordering\", name);\n                     }\n                 }\n             }\n             else {\n                 log(line, \"import.ordering\", name);\n             }\n \n             mLastGroup \u003d groupIdx;\n             mLastImport \u003d name;\n             mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n             mBeforeFirstImport \u003d false;\n         }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST aAST)\n    {\n        final FullIdent ident \u003d FullIdent.createFullIdentBelow(aAST);\n\n        if (ident !\u003d null) {\n            String name \u003d ident.getText();\n            int groupIdx \u003d getGroupNumber(name);\n            int line \u003d ident.getLineNo();\n\n            if (groupIdx \u003e mLastGroup) {\n                if (!mBeforeFirstImport \u0026\u0026 mSeparated) {\n                    // This check should be made more robust to handle\n                    // comments and imports that span more than one line.\n                    if (line - mLastImportLine \u003c 2) {\n                        log(line, \"import.separation\", name);\n                    }\n                }\n            }\n            else if (groupIdx \u003d\u003d mLastGroup) {\n                if (mOrdered) {\n                    boolean shouldFireError \u003d false;\n                    if (mCaseSensitive) {\n                        shouldFireError \u003d (mLastImport.compareTo(name) \u003e\u003d 0);\n                    }\n                    else {\n                        shouldFireError \u003d\n                            (mLastImport.compareToIgnoreCase(name) \u003e\u003d 0);\n                    }\n                    if (shouldFireError) {\n                        log(line, \"import.ordering\", name);\n                    }\n                }\n            }\n            else {\n                log(line, \"import.ordering\", name);\n            }\n\n            mLastGroup \u003d groupIdx;\n            mLastImport \u003d name;\n            mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n            mBeforeFirstImport \u003d false;\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java",
      "extendedDetails": {}
    },
    "2a1705e70d334700734b3df3ebefea0be878127a": {
      "type": "Yintroduced",
      "commitMessage": "ImportOrder check from Bill Schneider (request 745548)docs/releasenotes.html\n",
      "commitDate": "16/09/03 11:37 AM",
      "commitName": "2a1705e70d334700734b3df3ebefea0be878127a",
      "commitAuthor": "Oleg Sukhodolsky",
      "diff": "@@ -0,0 +1,35 @@\n+    public void visitToken(DetailAST aAST)\n+    {\n+        final FullIdent ident \u003d FullIdent.createFullIdentBelow(aAST);\n+\n+        if (ident !\u003d null) {\n+            String name \u003d ident.getText();\n+            int groupIdx \u003d getGroupNumber(name);\n+            int line \u003d ident.getLineNo();\n+\n+            if (groupIdx \u003e mLastGroup) {\n+                if (!mBeforeFirstImport \u0026\u0026 mSeparated) {\n+                    // This check should be made more robust to handle\n+                    // comments and imports that span more than one line.\n+                    if (line - mLastImportLine \u003c 2) {\n+                        log(line, \"import.separation\", name);\n+                    }\n+                }\n+            }\n+            else if (groupIdx \u003d\u003d mLastGroup) {\n+                if (mOrdered) {\n+                    if (mLastImport.compareTo(name) \u003e\u003d 0) {\n+                        log(line, \"import.ordering\", name);\n+                    }\n+                }\n+            }\n+            else {\n+                log(line, \"import.ordering\", name);\n+            }\n+\n+            mLastGroup \u003d groupIdx;\n+            mLastImport \u003d name;\n+            mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n+            mBeforeFirstImport \u003d false;\n+        }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void visitToken(DetailAST aAST)\n    {\n        final FullIdent ident \u003d FullIdent.createFullIdentBelow(aAST);\n\n        if (ident !\u003d null) {\n            String name \u003d ident.getText();\n            int groupIdx \u003d getGroupNumber(name);\n            int line \u003d ident.getLineNo();\n\n            if (groupIdx \u003e mLastGroup) {\n                if (!mBeforeFirstImport \u0026\u0026 mSeparated) {\n                    // This check should be made more robust to handle\n                    // comments and imports that span more than one line.\n                    if (line - mLastImportLine \u003c 2) {\n                        log(line, \"import.separation\", name);\n                    }\n                }\n            }\n            else if (groupIdx \u003d\u003d mLastGroup) {\n                if (mOrdered) {\n                    if (mLastImport.compareTo(name) \u003e\u003d 0) {\n                        log(line, \"import.ordering\", name);\n                    }\n                }\n            }\n            else {\n                log(line, \"import.ordering\", name);\n            }\n\n            mLastGroup \u003d groupIdx;\n            mLastImport \u003d name;\n            mLastImportLine \u003d aAST.findFirstToken(TokenTypes.SEMI).getLineNo();\n            mBeforeFirstImport \u003d false;\n        }\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java"
    }
  }
}