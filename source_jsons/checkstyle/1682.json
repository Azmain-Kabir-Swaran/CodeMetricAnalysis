{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "IllegalInstantiationCheck.java",
  "functionName": "getIllegalInstantiation",
  "functionId": "getIllegalInstantiation___className-String",
  "sourceFilePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
  "functionStartLine": 240,
  "functionEndLine": 271,
  "numCommitsSeen": 113,
  "timeTaken": 2967,
  "changeHistory": [
    "8d4a40d677afebb91dd094a529b30896a5e3f9b8",
    "327c0bc843612486ab4ded32a2f01038e1271fd0",
    "46378dadb508320f14737a44c75a832dc5c8120c",
    "23c8774d2e2fd245de1e5df02758fd23702c565e",
    "16ae5032c5e25ad35475c9a0f2de578ea6e640e5",
    "d64bdf0caa867be3913f2665ef4fcc654524937e",
    "dba746ba9387bee04ed362254abb5d9ed35169cd",
    "1bd30555eac039d0486dffb3fc43b7a34117909b",
    "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d",
    "08638b5f739d9929698860048c052da2d5f80209",
    "35d1673788bbbac8263fdb69275dc6a63b095a24",
    "c2d3932843e70e4bb5df7161800aca248f9af778",
    "5d7063c660b241bce251f1a8c89394619f2791fb",
    "bb1db4938ccae0f7149461ea372398fb8a53f2a8",
    "9920857810ecc9efdbca19e2749b75abc0cbbf14",
    "8dd44cbead07361f2b924a5a4d5d85ace71e4866",
    "ce175a83d8ab99fe75df384ee9e6faa65e2bb3f3"
  ],
  "changeHistoryShort": {
    "8d4a40d677afebb91dd094a529b30896a5e3f9b8": "Ybodychange",
    "327c0bc843612486ab4ded32a2f01038e1271fd0": "Ybodychange",
    "46378dadb508320f14737a44c75a832dc5c8120c": "Ybodychange",
    "23c8774d2e2fd245de1e5df02758fd23702c565e": "Ybodychange",
    "16ae5032c5e25ad35475c9a0f2de578ea6e640e5": "Ybodychange",
    "d64bdf0caa867be3913f2665ef4fcc654524937e": "Ybodychange",
    "dba746ba9387bee04ed362254abb5d9ed35169cd": "Ybodychange",
    "1bd30555eac039d0486dffb3fc43b7a34117909b": "Ybodychange",
    "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000": "Ymultichange(Yparameterchange,Ybodychange)",
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": "Yfilerename",
    "08638b5f739d9929698860048c052da2d5f80209": "Ybodychange",
    "35d1673788bbbac8263fdb69275dc6a63b095a24": "Ybodychange",
    "c2d3932843e70e4bb5df7161800aca248f9af778": "Ybodychange",
    "5d7063c660b241bce251f1a8c89394619f2791fb": "Ybodychange",
    "bb1db4938ccae0f7149461ea372398fb8a53f2a8": "Ybodychange",
    "9920857810ecc9efdbca19e2749b75abc0cbbf14": "Yfilerename",
    "8dd44cbead07361f2b924a5a4d5d85ace71e4866": "Ybodychange",
    "ce175a83d8ab99fe75df384ee9e6faa65e2bb3f3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8d4a40d677afebb91dd094a529b30896a5e3f9b8": {
      "type": "Ybodychange",
      "commitMessage": "Issue #6272: added FALSE_RETURNS pitest mutator",
      "commitDate": "19/12/18 10:42 PM",
      "commitName": "8d4a40d677afebb91dd094a529b30896a5e3f9b8",
      "commitAuthor": "rnveach",
      "commitDateOld": "03/06/18 9:40 PM",
      "commitNameOld": "641b6b2c0689fc35d6a3d77a7215fd1d9ce2a2b8",
      "commitAuthorOld": "Pavel Bludov",
      "daysBetweenCommits": 199.09,
      "commitsBetweenForRepo": 272,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n     private String getIllegalInstantiation(String className) {\n         String fullClassName \u003d null;\n \n         if (classes.contains(className)) {\n             fullClassName \u003d className;\n         }\n         else {\n             final int pkgNameLen;\n \n             if (pkgName \u003d\u003d null) {\n                 pkgNameLen \u003d 0;\n             }\n             else {\n                 pkgNameLen \u003d pkgName.length();\n             }\n \n             for (String illegal : classes) {\n-                if (isStandardClass(className, illegal)\n-                        || isSamePackage(className, pkgNameLen, illegal)) {\n+                if (isSamePackage(className, pkgNameLen, illegal)\n+                        || isStandardClass(className, illegal)) {\n                     fullClassName \u003d illegal;\n                 }\n                 else {\n                     fullClassName \u003d checkImportStatements(className);\n                 }\n \n                 if (fullClassName !\u003d null) {\n                     break;\n                 }\n             }\n         }\n         return fullClassName;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String className) {\n        String fullClassName \u003d null;\n\n        if (classes.contains(className)) {\n            fullClassName \u003d className;\n        }\n        else {\n            final int pkgNameLen;\n\n            if (pkgName \u003d\u003d null) {\n                pkgNameLen \u003d 0;\n            }\n            else {\n                pkgNameLen \u003d pkgName.length();\n            }\n\n            for (String illegal : classes) {\n                if (isSamePackage(className, pkgNameLen, illegal)\n                        || isStandardClass(className, illegal)) {\n                    fullClassName \u003d illegal;\n                }\n                else {\n                    fullClassName \u003d checkImportStatements(className);\n                }\n\n                if (fullClassName !\u003d null) {\n                    break;\n                }\n            }\n        }\n        return fullClassName;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "327c0bc843612486ab4ded32a2f01038e1271fd0": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3254: UT to verify all property types and values in XDocs",
      "commitDate": "03/01/18 5:30 PM",
      "commitName": "327c0bc843612486ab4ded32a2f01038e1271fd0",
      "commitAuthor": "rnveach",
      "commitDateOld": "02/01/18 1:24 PM",
      "commitNameOld": "dabb75d43c7e02317565dde4c5e60f380d3b16b8",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n     private String getIllegalInstantiation(String className) {\n         String fullClassName \u003d null;\n \n-        if (illegalClasses.contains(className)) {\n+        if (classes.contains(className)) {\n             fullClassName \u003d className;\n         }\n         else {\n             final int pkgNameLen;\n \n             if (pkgName \u003d\u003d null) {\n                 pkgNameLen \u003d 0;\n             }\n             else {\n                 pkgNameLen \u003d pkgName.length();\n             }\n \n-            for (String illegal : illegalClasses) {\n+            for (String illegal : classes) {\n                 if (isStandardClass(className, illegal)\n                         || isSamePackage(className, pkgNameLen, illegal)) {\n                     fullClassName \u003d illegal;\n                 }\n                 else {\n                     fullClassName \u003d checkImportStatements(className);\n                 }\n \n                 if (fullClassName !\u003d null) {\n                     break;\n                 }\n             }\n         }\n         return fullClassName;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String className) {\n        String fullClassName \u003d null;\n\n        if (classes.contains(className)) {\n            fullClassName \u003d className;\n        }\n        else {\n            final int pkgNameLen;\n\n            if (pkgName \u003d\u003d null) {\n                pkgNameLen \u003d 0;\n            }\n            else {\n                pkgNameLen \u003d pkgName.length();\n            }\n\n            for (String illegal : classes) {\n                if (isStandardClass(className, illegal)\n                        || isSamePackage(className, pkgNameLen, illegal)) {\n                    fullClassName \u003d illegal;\n                }\n                else {\n                    fullClassName \u003d checkImportStatements(className);\n                }\n\n                if (fullClassName !\u003d null) {\n                    break;\n                }\n            }\n        }\n        return fullClassName;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "46378dadb508320f14737a44c75a832dc5c8120c": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: ReturnCount violation fixed for IllegalInstantiationCheck\n",
      "commitDate": "27/08/15 10:37 PM",
      "commitName": "46378dadb508320f14737a44c75a832dc5c8120c",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": "27/08/15 10:29 PM",
      "commitNameOld": "cc7aeaec906dc3c864477e3050510009b2a946ee",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,32 @@\n     private String getIllegalInstantiation(String className) {\n-        if (illegalClasses.contains(className)) {\n-            return className;\n-        }\n-        final int pkgNameLen;\n+        String fullClassName \u003d null;\n \n-        if (pkgName \u003d\u003d null) {\n-            pkgNameLen \u003d 0;\n+        if (illegalClasses.contains(className)) {\n+            fullClassName \u003d className;\n         }\n         else {\n-            pkgNameLen \u003d pkgName.length();\n-        }\n+            final int pkgNameLen;\n \n-        for (String illegal : illegalClasses) {\n+            if (pkgName \u003d\u003d null) {\n+                pkgNameLen \u003d 0;\n+            }\n+            else {\n+                pkgNameLen \u003d pkgName.length();\n+            }\n \n-            if (isStandardClass(className, illegal)) {\n-                return illegal;\n-            }\n-            if (isSamePackage(className, pkgNameLen, illegal)) {\n-                return illegal;\n-            }\n-            final String importArg \u003d checkImportStatements(className);\n-            if (importArg !\u003d null) {\n-                return importArg;\n+            for (String illegal : illegalClasses) {\n+                if (isStandardClass(className, illegal)\n+                        || isSamePackage(className, pkgNameLen, illegal)) {\n+                    fullClassName \u003d illegal;\n+                }\n+                else {\n+                    fullClassName \u003d checkImportStatements(className);\n+                }\n+\n+                if (fullClassName !\u003d null) {\n+                    break;\n+                }\n             }\n         }\n-        return null;\n+        return fullClassName;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String className) {\n        String fullClassName \u003d null;\n\n        if (illegalClasses.contains(className)) {\n            fullClassName \u003d className;\n        }\n        else {\n            final int pkgNameLen;\n\n            if (pkgName \u003d\u003d null) {\n                pkgNameLen \u003d 0;\n            }\n            else {\n                pkgNameLen \u003d pkgName.length();\n            }\n\n            for (String illegal : illegalClasses) {\n                if (isStandardClass(className, illegal)\n                        || isSamePackage(className, pkgNameLen, illegal)) {\n                    fullClassName \u003d illegal;\n                }\n                else {\n                    fullClassName \u003d checkImportStatements(className);\n                }\n\n                if (fullClassName !\u003d null) {\n                    break;\n                }\n            }\n        }\n        return fullClassName;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "23c8774d2e2fd245de1e5df02758fd23702c565e": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1566: AvoidInlineConditional violations fixed\n",
      "commitDate": "16/08/15 9:01 PM",
      "commitName": "23c8774d2e2fd245de1e5df02758fd23702c565e",
      "commitAuthor": "Ruslan Diachenko",
      "commitDateOld": "11/08/15 10:19 PM",
      "commitNameOld": "3bd699bd593414d63c7139aa410f13ec8341a027",
      "commitAuthorOld": "Ruslan Diachenko",
      "daysBetweenCommits": 4.95,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,28 @@\n     private String getIllegalInstantiation(String className) {\n         if (illegalClasses.contains(className)) {\n             return className;\n         }\n+        final int pkgNameLen;\n \n-        final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n+        if (pkgName \u003d\u003d null) {\n+            pkgNameLen \u003d 0;\n+        }\n+        else {\n+            pkgNameLen \u003d pkgName.length();\n+        }\n \n         for (String illegal : illegalClasses) {\n \n             if (isStandardClass(className, illegal)) {\n                 return illegal;\n             }\n             if (isSamePackage(className, pkgNameLen, illegal)) {\n                 return illegal;\n             }\n             final String importArg \u003d checkImportStatements(className);\n             if (importArg !\u003d null) {\n                 return importArg;\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String className) {\n        if (illegalClasses.contains(className)) {\n            return className;\n        }\n        final int pkgNameLen;\n\n        if (pkgName \u003d\u003d null) {\n            pkgNameLen \u003d 0;\n        }\n        else {\n            pkgNameLen \u003d pkgName.length();\n        }\n\n        for (String illegal : illegalClasses) {\n\n            if (isStandardClass(className, illegal)) {\n                return illegal;\n            }\n            if (isSamePackage(className, pkgNameLen, illegal)) {\n                return illegal;\n            }\n            final String importArg \u003d checkImportStatements(className);\n            if (importArg !\u003d null) {\n                return importArg;\n            }\n        }\n        return null;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "16ae5032c5e25ad35475c9a0f2de578ea6e640e5": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1293: Improved coverage for IllegalInstantiationCheck\n",
      "commitDate": "08/08/15 7:32 PM",
      "commitName": "16ae5032c5e25ad35475c9a0f2de578ea6e640e5",
      "commitAuthor": "Baratali Izmailov",
      "commitDateOld": "07/08/15 10:17 PM",
      "commitNameOld": "4fd298b00126d60147dce7631c6e0d3e0921f82f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.89,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,22 @@\n     private String getIllegalInstantiation(String className) {\n         if (illegalClasses.contains(className)) {\n             return className;\n         }\n \n-        final int clsNameLen \u003d className.length();\n         final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n \n         for (String illegal : illegalClasses) {\n \n-            final int illegalLen \u003d illegal.length();\n-            if (isStandardClass(className, clsNameLen, illegal, illegalLen)) {\n+            if (isStandardClass(className, illegal)) {\n                 return illegal;\n             }\n-            if (isSamePackage(className, clsNameLen, pkgNameLen, illegal, illegalLen)) {\n+            if (isSamePackage(className, pkgNameLen, illegal)) {\n                 return illegal;\n             }\n             final String importArg \u003d checkImportStatements(className);\n             if (importArg !\u003d null) {\n                 return importArg;\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String className) {\n        if (illegalClasses.contains(className)) {\n            return className;\n        }\n\n        final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n\n        for (String illegal : illegalClasses) {\n\n            if (isStandardClass(className, illegal)) {\n                return illegal;\n            }\n            if (isSamePackage(className, pkgNameLen, illegal)) {\n                return illegal;\n            }\n            final String importArg \u003d checkImportStatements(className);\n            if (importArg !\u003d null) {\n                return importArg;\n            }\n        }\n        return null;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "d64bdf0caa867be3913f2665ef4fcc654524937e": {
      "type": "Ybodychange",
      "commitMessage": "IllegalInstantiationCheck updated to follow Cyclomatic Complexity rule. #954\n",
      "commitDate": "13/06/15 11:01 PM",
      "commitName": "d64bdf0caa867be3913f2665ef4fcc654524937e",
      "commitAuthor": "Roman Ivanov",
      "commitDateOld": "17/05/15 4:47 AM",
      "commitNameOld": "0f58857d73933c7b6b7e62f0c7c16ad7af51556f",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 27.76,
      "commitsBetweenForRepo": 143,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,24 @@\n     private String getIllegalInstantiation(String className) {\n         if (illegalClasses.contains(className)) {\n             return className;\n         }\n \n         final int clsNameLen \u003d className.length();\n         final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n \n         for (String illegal : illegalClasses) {\n+\n             final int illegalLen \u003d illegal.length();\n-\n-            // class from java.lang\n-            if (illegalLen - JAVA_LANG.length() \u003d\u003d clsNameLen\n-                \u0026\u0026 illegal.endsWith(className)\n-                \u0026\u0026 illegal.startsWith(JAVA_LANG)) {\n-                // java.lang needs no import, but a class without import might\n-                // also come from the same file or be in the same package.\n-                // E.g. if a class defines an inner class \"Boolean\",\n-                // the expression \"new Boolean()\" refers to that class,\n-                // not to java.lang.Boolean\n-\n-                final boolean isSameFile \u003d classNames.contains(className);\n-\n-                boolean isSamePackage \u003d false;\n-                try {\n-                    final ClassLoader classLoader \u003d getClassLoader();\n-                    if (classLoader !\u003d null) {\n-                        final String fqName \u003d pkgName + \".\" + className;\n-                        classLoader.loadClass(fqName);\n-                        // no ClassNotFoundException, fqName is a known class\n-                        isSamePackage \u003d true;\n-                    }\n-                }\n-                catch (final ClassNotFoundException ex) {\n-                    // not a class from the same package\n-                    isSamePackage \u003d false;\n-                }\n-\n-                if (!(isSameFile || isSamePackage)) {\n-                    return illegal;\n-                }\n-            }\n-\n-            // class from same package\n-\n-            // the toplevel package (pkgName \u003d\u003d null) is covered by the\n-            // \"illegalInsts.contains(className)\" check above\n-\n-            // the test is the \"no garbage\" version of\n-            // illegal.equals(pkgName + \".\" + className)\n-            if (pkgName !\u003d null\n-                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n-                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n-                \u0026\u0026 illegal.endsWith(className)\n-                \u0026\u0026 illegal.startsWith(pkgName)) {\n+            if (isStandardClass(className, clsNameLen, illegal, illegalLen)) {\n                 return illegal;\n             }\n-            // import statements\n-            for (FullIdent importLineText : imports) {\n-                final String importArg \u003d importLineText.getText();\n-                if (importArg.endsWith(\".*\")) {\n-                    final String fqClass \u003d\n-                        importArg.substring(0, importArg.length() - 1)\n-                        + className;\n-                    // assume that illegalInsts only contain existing classes\n-                    // or else we might create a false alarm here\n-                    if (illegalClasses.contains(fqClass)) {\n-                        return fqClass;\n-                    }\n-                }\n-                else {\n-                    if (Utils.baseClassname(importArg).equals(className)\n-                        \u0026\u0026 illegalClasses.contains(importArg)) {\n-                        return importArg;\n-                    }\n-                }\n+            if (isSamePackage(className, clsNameLen, pkgNameLen, illegal, illegalLen)) {\n+                return illegal;\n+            }\n+            final String importArg \u003d checkImportStatements(className);\n+            if (importArg !\u003d null) {\n+                return importArg;\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String className) {\n        if (illegalClasses.contains(className)) {\n            return className;\n        }\n\n        final int clsNameLen \u003d className.length();\n        final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n\n        for (String illegal : illegalClasses) {\n\n            final int illegalLen \u003d illegal.length();\n            if (isStandardClass(className, clsNameLen, illegal, illegalLen)) {\n                return illegal;\n            }\n            if (isSamePackage(className, clsNameLen, pkgNameLen, illegal, illegalLen)) {\n                return illegal;\n            }\n            final String importArg \u003d checkImportStatements(className);\n            if (importArg !\u003d null) {\n                return importArg;\n            }\n        }\n        return null;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "dba746ba9387bee04ed362254abb5d9ed35169cd": {
      "type": "Ybodychange",
      "commitMessage": "Fix PMD violations from PrematureDeclaration rule. #948\n",
      "commitDate": "13/05/15 9:58 AM",
      "commitName": "dba746ba9387bee04ed362254abb5d9ed35169cd",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "01/05/15 4:32 PM",
      "commitNameOld": "31421dcdda3b3534f2fcc5c6e88a8fdbc5d15311",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 11.73,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,84 @@\n     private String getIllegalInstantiation(String className)\n     {\n-        final String javlang \u003d \"java.lang.\";\n-\n         if (illegalClasses.contains(className)) {\n             return className;\n         }\n \n         final int clsNameLen \u003d className.length();\n         final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n \n         for (String illegal : illegalClasses) {\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n-            if (illegalLen - javlang.length() \u003d\u003d clsNameLen\n+            if (illegalLen - JAVA_LANG.length() \u003d\u003d clsNameLen\n                 \u0026\u0026 illegal.endsWith(className)\n-                \u0026\u0026 illegal.startsWith(javlang))\n+                \u0026\u0026 illegal.startsWith(JAVA_LANG))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n                 final boolean isSameFile \u003d classNames.contains(className);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n                         final String fqName \u003d pkgName + \".\" + className;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n                 catch (final ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n             // the toplevel package (pkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(className)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(pkgName + \".\" + className)\n             if (pkgName !\u003d null\n                 \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                 \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                 \u0026\u0026 illegal.endsWith(className)\n                 \u0026\u0026 illegal.startsWith(pkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             for (FullIdent importLineText : imports) {\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + className;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (illegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(className)\n                         \u0026\u0026 illegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String className)\n    {\n        if (illegalClasses.contains(className)) {\n            return className;\n        }\n\n        final int clsNameLen \u003d className.length();\n        final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n\n        for (String illegal : illegalClasses) {\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (illegalLen - JAVA_LANG.length() \u003d\u003d clsNameLen\n                \u0026\u0026 illegal.endsWith(className)\n                \u0026\u0026 illegal.startsWith(JAVA_LANG))\n            {\n                // java.lang needs no import, but a class without import might\n                // also come from the same file or be in the same package.\n                // E.g. if a class defines an inner class \"Boolean\",\n                // the expression \"new Boolean()\" refers to that class,\n                // not to java.lang.Boolean\n\n                final boolean isSameFile \u003d classNames.contains(className);\n\n                boolean isSamePackage \u003d false;\n                try {\n                    final ClassLoader classLoader \u003d getClassLoader();\n                    if (classLoader !\u003d null) {\n                        final String fqName \u003d pkgName + \".\" + className;\n                        classLoader.loadClass(fqName);\n                        // no ClassNotFoundException, fqName is a known class\n                        isSamePackage \u003d true;\n                    }\n                }\n                catch (final ClassNotFoundException ex) {\n                    // not a class from the same package\n                    isSamePackage \u003d false;\n                }\n\n                if (!(isSameFile || isSamePackage)) {\n                    return illegal;\n                }\n            }\n\n            // class from same package\n\n            // the toplevel package (pkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(className)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(pkgName + \".\" + className)\n            if (pkgName !\u003d null\n                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                \u0026\u0026 illegal.endsWith(className)\n                \u0026\u0026 illegal.startsWith(pkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            for (FullIdent importLineText : imports) {\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + className;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (illegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (Utils.baseClassname(importArg).equals(className)\n                        \u0026\u0026 illegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "1bd30555eac039d0486dffb3fc43b7a34117909b": {
      "type": "Ybodychange",
      "commitMessage": "Remove useless parentheses to fix PMD violations, issue #744\n\nParentheses are considered unnecessary if the evaluation order of an expression remains unchanged if the parentheses are removed.\n",
      "commitDate": "10/03/15 2:36 PM",
      "commitName": "1bd30555eac039d0486dffb3fc43b7a34117909b",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "20/02/15 5:02 AM",
      "commitNameOld": "27149f3504a2f350b74f456a9bffbae76a460060",
      "commitAuthorOld": "alexkravin",
      "daysBetweenCommits": 18.36,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,86 @@\n     private String getIllegalInstantiation(String className)\n     {\n         final String javlang \u003d \"java.lang.\";\n \n         if (illegalClasses.contains(className)) {\n             return className;\n         }\n \n         final int clsNameLen \u003d className.length();\n-        final int pkgNameLen \u003d (pkgName \u003d\u003d null) ? 0 : pkgName.length();\n+        final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n \n         for (String illegal : illegalClasses) {\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n-            if (((illegalLen - javlang.length()) \u003d\u003d clsNameLen)\n+            if (illegalLen - javlang.length() \u003d\u003d clsNameLen\n                 \u0026\u0026 illegal.endsWith(className)\n                 \u0026\u0026 illegal.startsWith(javlang))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n                 final boolean isSameFile \u003d classNames.contains(className);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n                         final String fqName \u003d pkgName + \".\" + className;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n                 catch (final ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n             // the toplevel package (pkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(className)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(pkgName + \".\" + className)\n-            if ((pkgName !\u003d null)\n-                \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n-                \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n+            if (pkgName !\u003d null\n+                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n+                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                 \u0026\u0026 illegal.endsWith(className)\n                 \u0026\u0026 illegal.startsWith(pkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             for (FullIdent importLineText : imports) {\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + className;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (illegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(className)\n                         \u0026\u0026 illegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String className)\n    {\n        final String javlang \u003d \"java.lang.\";\n\n        if (illegalClasses.contains(className)) {\n            return className;\n        }\n\n        final int clsNameLen \u003d className.length();\n        final int pkgNameLen \u003d pkgName \u003d\u003d null ? 0 : pkgName.length();\n\n        for (String illegal : illegalClasses) {\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (illegalLen - javlang.length() \u003d\u003d clsNameLen\n                \u0026\u0026 illegal.endsWith(className)\n                \u0026\u0026 illegal.startsWith(javlang))\n            {\n                // java.lang needs no import, but a class without import might\n                // also come from the same file or be in the same package.\n                // E.g. if a class defines an inner class \"Boolean\",\n                // the expression \"new Boolean()\" refers to that class,\n                // not to java.lang.Boolean\n\n                final boolean isSameFile \u003d classNames.contains(className);\n\n                boolean isSamePackage \u003d false;\n                try {\n                    final ClassLoader classLoader \u003d getClassLoader();\n                    if (classLoader !\u003d null) {\n                        final String fqName \u003d pkgName + \".\" + className;\n                        classLoader.loadClass(fqName);\n                        // no ClassNotFoundException, fqName is a known class\n                        isSamePackage \u003d true;\n                    }\n                }\n                catch (final ClassNotFoundException ex) {\n                    // not a class from the same package\n                    isSamePackage \u003d false;\n                }\n\n                if (!(isSameFile || isSamePackage)) {\n                    return illegal;\n                }\n            }\n\n            // class from same package\n\n            // the toplevel package (pkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(className)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(pkgName + \".\" + className)\n            if (pkgName !\u003d null\n                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                \u0026\u0026 illegal.endsWith(className)\n                \u0026\u0026 illegal.startsWith(pkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            for (FullIdent importLineText : imports) {\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + className;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (illegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (Utils.baseClassname(importArg).equals(className)\n                        \u0026\u0026 illegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Prefixes, coding, #512\n",
      "commitDate": "19/01/15 6:20 AM",
      "commitName": "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000",
      "commitAuthor": "alexkravin",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Prefixes, coding, #512\n",
          "commitDate": "19/01/15 6:20 AM",
          "commitName": "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000",
          "commitAuthor": "alexkravin",
          "commitDateOld": "10/10/14 11:15 AM",
          "commitNameOld": "839cd1b10edb01feb771832a69cf351a6c1c91ef",
          "commitAuthorOld": "Ryszard Wiśniewski",
          "daysBetweenCommits": 100.84,
          "commitsBetweenForRepo": 299,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,86 +1,86 @@\n-    private String getIllegalInstantiation(String aClassName)\n+    private String getIllegalInstantiation(String className)\n     {\n-        final String javaLang \u003d \"java.lang.\";\n+        final String javlang \u003d \"java.lang.\";\n \n-        if (mIllegalClasses.contains(aClassName)) {\n-            return aClassName;\n+        if (illegalClasses.contains(className)) {\n+            return className;\n         }\n \n-        final int clsNameLen \u003d aClassName.length();\n-        final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n+        final int clsNameLen \u003d className.length();\n+        final int pkgNameLen \u003d (pkgName \u003d\u003d null) ? 0 : pkgName.length();\n \n-        for (String illegal : mIllegalClasses) {\n+        for (String illegal : illegalClasses) {\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n-            if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n-                \u0026\u0026 illegal.endsWith(aClassName)\n-                \u0026\u0026 illegal.startsWith(javaLang))\n+            if (((illegalLen - javlang.length()) \u003d\u003d clsNameLen)\n+                \u0026\u0026 illegal.endsWith(className)\n+                \u0026\u0026 illegal.startsWith(javlang))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n-                final boolean isSameFile \u003d mClassNames.contains(aClassName);\n+                final boolean isSameFile \u003d classNames.contains(className);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n-                        final String fqName \u003d mPkgName + \".\" + aClassName;\n+                        final String fqName \u003d pkgName + \".\" + className;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n                 catch (final ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n-            // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n-            // \"illegalInsts.contains(aClassName)\" check above\n+            // the toplevel package (pkgName \u003d\u003d null) is covered by the\n+            // \"illegalInsts.contains(className)\" check above\n \n             // the test is the \"no garbage\" version of\n-            // illegal.equals(mPkgName + \".\" + aClassName)\n-            if ((mPkgName !\u003d null)\n+            // illegal.equals(pkgName + \".\" + className)\n+            if ((pkgName !\u003d null)\n                 \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n                 \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n-                \u0026\u0026 illegal.endsWith(aClassName)\n-                \u0026\u0026 illegal.startsWith(mPkgName))\n+                \u0026\u0026 illegal.endsWith(className)\n+                \u0026\u0026 illegal.startsWith(pkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n-            for (FullIdent importLineText : mImports) {\n+            for (FullIdent importLineText : imports) {\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n-                        + aClassName;\n+                        + className;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n-                    if (mIllegalClasses.contains(fqClass)) {\n+                    if (illegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n-                    if (Utils.baseClassname(importArg).equals(aClassName)\n-                        \u0026\u0026 mIllegalClasses.contains(importArg))\n+                    if (Utils.baseClassname(importArg).equals(className)\n+                        \u0026\u0026 illegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private String getIllegalInstantiation(String className)\n    {\n        final String javlang \u003d \"java.lang.\";\n\n        if (illegalClasses.contains(className)) {\n            return className;\n        }\n\n        final int clsNameLen \u003d className.length();\n        final int pkgNameLen \u003d (pkgName \u003d\u003d null) ? 0 : pkgName.length();\n\n        for (String illegal : illegalClasses) {\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (((illegalLen - javlang.length()) \u003d\u003d clsNameLen)\n                \u0026\u0026 illegal.endsWith(className)\n                \u0026\u0026 illegal.startsWith(javlang))\n            {\n                // java.lang needs no import, but a class without import might\n                // also come from the same file or be in the same package.\n                // E.g. if a class defines an inner class \"Boolean\",\n                // the expression \"new Boolean()\" refers to that class,\n                // not to java.lang.Boolean\n\n                final boolean isSameFile \u003d classNames.contains(className);\n\n                boolean isSamePackage \u003d false;\n                try {\n                    final ClassLoader classLoader \u003d getClassLoader();\n                    if (classLoader !\u003d null) {\n                        final String fqName \u003d pkgName + \".\" + className;\n                        classLoader.loadClass(fqName);\n                        // no ClassNotFoundException, fqName is a known class\n                        isSamePackage \u003d true;\n                    }\n                }\n                catch (final ClassNotFoundException ex) {\n                    // not a class from the same package\n                    isSamePackage \u003d false;\n                }\n\n                if (!(isSameFile || isSamePackage)) {\n                    return illegal;\n                }\n            }\n\n            // class from same package\n\n            // the toplevel package (pkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(className)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(pkgName + \".\" + className)\n            if ((pkgName !\u003d null)\n                \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n                \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n                \u0026\u0026 illegal.endsWith(className)\n                \u0026\u0026 illegal.startsWith(pkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            for (FullIdent importLineText : imports) {\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + className;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (illegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (Utils.baseClassname(importArg).equals(className)\n                        \u0026\u0026 illegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
          "extendedDetails": {
            "oldValue": "[aClassName-String]",
            "newValue": "[className-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Prefixes, coding, #512\n",
          "commitDate": "19/01/15 6:20 AM",
          "commitName": "bb1b29851f14bf7eaf5656e01c285c0f5f3b9000",
          "commitAuthor": "alexkravin",
          "commitDateOld": "10/10/14 11:15 AM",
          "commitNameOld": "839cd1b10edb01feb771832a69cf351a6c1c91ef",
          "commitAuthorOld": "Ryszard Wiśniewski",
          "daysBetweenCommits": 100.84,
          "commitsBetweenForRepo": 299,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,86 +1,86 @@\n-    private String getIllegalInstantiation(String aClassName)\n+    private String getIllegalInstantiation(String className)\n     {\n-        final String javaLang \u003d \"java.lang.\";\n+        final String javlang \u003d \"java.lang.\";\n \n-        if (mIllegalClasses.contains(aClassName)) {\n-            return aClassName;\n+        if (illegalClasses.contains(className)) {\n+            return className;\n         }\n \n-        final int clsNameLen \u003d aClassName.length();\n-        final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n+        final int clsNameLen \u003d className.length();\n+        final int pkgNameLen \u003d (pkgName \u003d\u003d null) ? 0 : pkgName.length();\n \n-        for (String illegal : mIllegalClasses) {\n+        for (String illegal : illegalClasses) {\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n-            if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n-                \u0026\u0026 illegal.endsWith(aClassName)\n-                \u0026\u0026 illegal.startsWith(javaLang))\n+            if (((illegalLen - javlang.length()) \u003d\u003d clsNameLen)\n+                \u0026\u0026 illegal.endsWith(className)\n+                \u0026\u0026 illegal.startsWith(javlang))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n-                final boolean isSameFile \u003d mClassNames.contains(aClassName);\n+                final boolean isSameFile \u003d classNames.contains(className);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n-                        final String fqName \u003d mPkgName + \".\" + aClassName;\n+                        final String fqName \u003d pkgName + \".\" + className;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n                 catch (final ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n-            // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n-            // \"illegalInsts.contains(aClassName)\" check above\n+            // the toplevel package (pkgName \u003d\u003d null) is covered by the\n+            // \"illegalInsts.contains(className)\" check above\n \n             // the test is the \"no garbage\" version of\n-            // illegal.equals(mPkgName + \".\" + aClassName)\n-            if ((mPkgName !\u003d null)\n+            // illegal.equals(pkgName + \".\" + className)\n+            if ((pkgName !\u003d null)\n                 \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n                 \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n-                \u0026\u0026 illegal.endsWith(aClassName)\n-                \u0026\u0026 illegal.startsWith(mPkgName))\n+                \u0026\u0026 illegal.endsWith(className)\n+                \u0026\u0026 illegal.startsWith(pkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n-            for (FullIdent importLineText : mImports) {\n+            for (FullIdent importLineText : imports) {\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n-                        + aClassName;\n+                        + className;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n-                    if (mIllegalClasses.contains(fqClass)) {\n+                    if (illegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n-                    if (Utils.baseClassname(importArg).equals(aClassName)\n-                        \u0026\u0026 mIllegalClasses.contains(importArg))\n+                    if (Utils.baseClassname(importArg).equals(className)\n+                        \u0026\u0026 illegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private String getIllegalInstantiation(String className)\n    {\n        final String javlang \u003d \"java.lang.\";\n\n        if (illegalClasses.contains(className)) {\n            return className;\n        }\n\n        final int clsNameLen \u003d className.length();\n        final int pkgNameLen \u003d (pkgName \u003d\u003d null) ? 0 : pkgName.length();\n\n        for (String illegal : illegalClasses) {\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (((illegalLen - javlang.length()) \u003d\u003d clsNameLen)\n                \u0026\u0026 illegal.endsWith(className)\n                \u0026\u0026 illegal.startsWith(javlang))\n            {\n                // java.lang needs no import, but a class without import might\n                // also come from the same file or be in the same package.\n                // E.g. if a class defines an inner class \"Boolean\",\n                // the expression \"new Boolean()\" refers to that class,\n                // not to java.lang.Boolean\n\n                final boolean isSameFile \u003d classNames.contains(className);\n\n                boolean isSamePackage \u003d false;\n                try {\n                    final ClassLoader classLoader \u003d getClassLoader();\n                    if (classLoader !\u003d null) {\n                        final String fqName \u003d pkgName + \".\" + className;\n                        classLoader.loadClass(fqName);\n                        // no ClassNotFoundException, fqName is a known class\n                        isSamePackage \u003d true;\n                    }\n                }\n                catch (final ClassNotFoundException ex) {\n                    // not a class from the same package\n                    isSamePackage \u003d false;\n                }\n\n                if (!(isSameFile || isSamePackage)) {\n                    return illegal;\n                }\n            }\n\n            // class from same package\n\n            // the toplevel package (pkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(className)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(pkgName + \".\" + className)\n            if ((pkgName !\u003d null)\n                \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n                \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n                \u0026\u0026 illegal.endsWith(className)\n                \u0026\u0026 illegal.startsWith(pkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            for (FullIdent importLineText : imports) {\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + className;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (illegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (Utils.baseClassname(importArg).equals(className)\n                        \u0026\u0026 illegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
          "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
          "extendedDetails": {}
        }
      ]
    },
    "f1efb27670a93690577f1bae17fc9dcbd88a795d": {
      "type": "Yfilerename",
      "commitMessage": "moving to standard directory layout\n",
      "commitDate": "04/03/14 9:18 AM",
      "commitName": "f1efb27670a93690577f1bae17fc9dcbd88a795d",
      "commitAuthor": "Ivan Sopov",
      "commitDateOld": "26/02/14 10:35 PM",
      "commitNameOld": "1cdaeaaa4fbf02a7388f1fcbea1c86ef0ea32fed",
      "commitAuthorOld": "Andrew Gaul",
      "daysBetweenCommits": 5.45,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private String getIllegalInstantiation(String aClassName)\n    {\n        final String javaLang \u003d \"java.lang.\";\n\n        if (mIllegalClasses.contains(aClassName)) {\n            return aClassName;\n        }\n\n        final int clsNameLen \u003d aClassName.length();\n        final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n\n        for (String illegal : mIllegalClasses) {\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(javaLang))\n            {\n                // java.lang needs no import, but a class without import might\n                // also come from the same file or be in the same package.\n                // E.g. if a class defines an inner class \"Boolean\",\n                // the expression \"new Boolean()\" refers to that class,\n                // not to java.lang.Boolean\n\n                final boolean isSameFile \u003d mClassNames.contains(aClassName);\n\n                boolean isSamePackage \u003d false;\n                try {\n                    final ClassLoader classLoader \u003d getClassLoader();\n                    if (classLoader !\u003d null) {\n                        final String fqName \u003d mPkgName + \".\" + aClassName;\n                        classLoader.loadClass(fqName);\n                        // no ClassNotFoundException, fqName is a known class\n                        isSamePackage \u003d true;\n                    }\n                }\n                catch (final ClassNotFoundException ex) {\n                    // not a class from the same package\n                    isSamePackage \u003d false;\n                }\n\n                if (!(isSameFile || isSamePackage)) {\n                    return illegal;\n                }\n            }\n\n            // class from same package\n\n            // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(aClassName)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(mPkgName + \".\" + aClassName)\n            if ((mPkgName !\u003d null)\n                \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n                \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(mPkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            for (FullIdent importLineText : mImports) {\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + aClassName;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (mIllegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (Utils.baseClassname(importArg).equals(aClassName)\n                        \u0026\u0026 mIllegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {
        "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
        "newPath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java"
      }
    },
    "08638b5f739d9929698860048c052da2d5f80209": {
      "type": "Ybodychange",
      "commitMessage": "Start of adding generics.\n",
      "commitDate": "14/12/07 10:36 PM",
      "commitName": "08638b5f739d9929698860048c052da2d5f80209",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "27/01/07 6:51 AM",
      "commitNameOld": "1efc394250b8f1c79bd7f8344b738a7d13396ed3",
      "commitAuthorOld": "Lars Kühne",
      "daysBetweenCommits": 321.66,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,86 @@\n     private String getIllegalInstantiation(String aClassName)\n     {\n         final String javaLang \u003d \"java.lang.\";\n \n         if (mIllegalClasses.contains(aClassName)) {\n             return aClassName;\n         }\n \n         final int clsNameLen \u003d aClassName.length();\n         final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n \n-        final Iterator illIter \u003d mIllegalClasses.iterator();\n-        while (illIter.hasNext()) {\n-            final String illegal \u003d (String) illIter.next();\n+        for (String illegal : mIllegalClasses) {\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n             if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(javaLang))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n                 final boolean isSameFile \u003d mClassNames.contains(aClassName);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n                         final String fqName \u003d mPkgName + \".\" + aClassName;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n                 catch (final ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n             // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(aClassName)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(mPkgName + \".\" + aClassName)\n             if ((mPkgName !\u003d null)\n                 \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n                 \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(mPkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n-            final Iterator importIter \u003d mImports.iterator();\n-            while (importIter.hasNext()) {\n-                final FullIdent importLineText \u003d (FullIdent) importIter.next();\n+            for (FullIdent importLineText : mImports) {\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + aClassName;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (mIllegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(aClassName)\n                         \u0026\u0026 mIllegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String aClassName)\n    {\n        final String javaLang \u003d \"java.lang.\";\n\n        if (mIllegalClasses.contains(aClassName)) {\n            return aClassName;\n        }\n\n        final int clsNameLen \u003d aClassName.length();\n        final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n\n        for (String illegal : mIllegalClasses) {\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(javaLang))\n            {\n                // java.lang needs no import, but a class without import might\n                // also come from the same file or be in the same package.\n                // E.g. if a class defines an inner class \"Boolean\",\n                // the expression \"new Boolean()\" refers to that class,\n                // not to java.lang.Boolean\n\n                final boolean isSameFile \u003d mClassNames.contains(aClassName);\n\n                boolean isSamePackage \u003d false;\n                try {\n                    final ClassLoader classLoader \u003d getClassLoader();\n                    if (classLoader !\u003d null) {\n                        final String fqName \u003d mPkgName + \".\" + aClassName;\n                        classLoader.loadClass(fqName);\n                        // no ClassNotFoundException, fqName is a known class\n                        isSamePackage \u003d true;\n                    }\n                }\n                catch (final ClassNotFoundException ex) {\n                    // not a class from the same package\n                    isSamePackage \u003d false;\n                }\n\n                if (!(isSameFile || isSamePackage)) {\n                    return illegal;\n                }\n            }\n\n            // class from same package\n\n            // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(aClassName)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(mPkgName + \".\" + aClassName)\n            if ((mPkgName !\u003d null)\n                \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n                \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(mPkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            for (FullIdent importLineText : mImports) {\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + aClassName;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (mIllegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (Utils.baseClassname(importArg).equals(aClassName)\n                        \u0026\u0026 mIllegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "35d1673788bbbac8263fdb69275dc6a63b095a24": {
      "type": "Ybodychange",
      "commitMessage": "Making local variables final where possible.\n",
      "commitDate": "06/07/06 8:44 PM",
      "commitName": "35d1673788bbbac8263fdb69275dc6a63b095a24",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "06/07/06 8:26 PM",
      "commitNameOld": "c2d3932843e70e4bb5df7161800aca248f9af778",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n     private String getIllegalInstantiation(String aClassName)\n     {\n         final String javaLang \u003d \"java.lang.\";\n \n         if (mIllegalClasses.contains(aClassName)) {\n             return aClassName;\n         }\n \n         final int clsNameLen \u003d aClassName.length();\n         final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n \n         final Iterator illIter \u003d mIllegalClasses.iterator();\n         while (illIter.hasNext()) {\n             final String illegal \u003d (String) illIter.next();\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n             if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(javaLang))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n                 final boolean isSameFile \u003d mClassNames.contains(aClassName);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n                         final String fqName \u003d mPkgName + \".\" + aClassName;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n-                catch (ClassNotFoundException ex) {\n+                catch (final ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n             // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(aClassName)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(mPkgName + \".\" + aClassName)\n             if ((mPkgName !\u003d null)\n                 \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n                 \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(mPkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             final Iterator importIter \u003d mImports.iterator();\n             while (importIter.hasNext()) {\n                 final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + aClassName;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (mIllegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(aClassName)\n                         \u0026\u0026 mIllegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String aClassName)\n    {\n        final String javaLang \u003d \"java.lang.\";\n\n        if (mIllegalClasses.contains(aClassName)) {\n            return aClassName;\n        }\n\n        final int clsNameLen \u003d aClassName.length();\n        final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n\n        final Iterator illIter \u003d mIllegalClasses.iterator();\n        while (illIter.hasNext()) {\n            final String illegal \u003d (String) illIter.next();\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(javaLang))\n            {\n                // java.lang needs no import, but a class without import might\n                // also come from the same file or be in the same package.\n                // E.g. if a class defines an inner class \"Boolean\",\n                // the expression \"new Boolean()\" refers to that class,\n                // not to java.lang.Boolean\n\n                final boolean isSameFile \u003d mClassNames.contains(aClassName);\n\n                boolean isSamePackage \u003d false;\n                try {\n                    final ClassLoader classLoader \u003d getClassLoader();\n                    if (classLoader !\u003d null) {\n                        final String fqName \u003d mPkgName + \".\" + aClassName;\n                        classLoader.loadClass(fqName);\n                        // no ClassNotFoundException, fqName is a known class\n                        isSamePackage \u003d true;\n                    }\n                }\n                catch (final ClassNotFoundException ex) {\n                    // not a class from the same package\n                    isSamePackage \u003d false;\n                }\n\n                if (!(isSameFile || isSamePackage)) {\n                    return illegal;\n                }\n            }\n\n            // class from same package\n\n            // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(aClassName)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(mPkgName + \".\" + aClassName)\n            if ((mPkgName !\u003d null)\n                \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n                \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(mPkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            final Iterator importIter \u003d mImports.iterator();\n            while (importIter.hasNext()) {\n                final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + aClassName;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (mIllegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (Utils.baseClassname(importArg).equals(aClassName)\n                        \u0026\u0026 mIllegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "c2d3932843e70e4bb5df7161800aca248f9af778": {
      "type": "Ybodychange",
      "commitMessage": "Clean up the use of ()\u0027s\n",
      "commitDate": "06/07/06 8:26 PM",
      "commitName": "c2d3932843e70e4bb5df7161800aca248f9af778",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "31/10/05 11:23 AM",
      "commitNameOld": "1aee9d55cc5bd8cca011e17369f6e370efcc85bb",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 248.34,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n     private String getIllegalInstantiation(String aClassName)\n     {\n         final String javaLang \u003d \"java.lang.\";\n \n         if (mIllegalClasses.contains(aClassName)) {\n             return aClassName;\n         }\n \n         final int clsNameLen \u003d aClassName.length();\n         final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n \n         final Iterator illIter \u003d mIllegalClasses.iterator();\n         while (illIter.hasNext()) {\n             final String illegal \u003d (String) illIter.next();\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n             if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(javaLang))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n                 final boolean isSameFile \u003d mClassNames.contains(aClassName);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n                         final String fqName \u003d mPkgName + \".\" + aClassName;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n                 catch (ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n             // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(aClassName)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(mPkgName + \".\" + aClassName)\n-            if (mPkgName !\u003d null\n-                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n-                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n+            if ((mPkgName !\u003d null)\n+                \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n+                \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(mPkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             final Iterator importIter \u003d mImports.iterator();\n             while (importIter.hasNext()) {\n                 final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + aClassName;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (mIllegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(aClassName)\n                         \u0026\u0026 mIllegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String aClassName)\n    {\n        final String javaLang \u003d \"java.lang.\";\n\n        if (mIllegalClasses.contains(aClassName)) {\n            return aClassName;\n        }\n\n        final int clsNameLen \u003d aClassName.length();\n        final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n\n        final Iterator illIter \u003d mIllegalClasses.iterator();\n        while (illIter.hasNext()) {\n            final String illegal \u003d (String) illIter.next();\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(javaLang))\n            {\n                // java.lang needs no import, but a class without import might\n                // also come from the same file or be in the same package.\n                // E.g. if a class defines an inner class \"Boolean\",\n                // the expression \"new Boolean()\" refers to that class,\n                // not to java.lang.Boolean\n\n                final boolean isSameFile \u003d mClassNames.contains(aClassName);\n\n                boolean isSamePackage \u003d false;\n                try {\n                    final ClassLoader classLoader \u003d getClassLoader();\n                    if (classLoader !\u003d null) {\n                        final String fqName \u003d mPkgName + \".\" + aClassName;\n                        classLoader.loadClass(fqName);\n                        // no ClassNotFoundException, fqName is a known class\n                        isSamePackage \u003d true;\n                    }\n                }\n                catch (ClassNotFoundException ex) {\n                    // not a class from the same package\n                    isSamePackage \u003d false;\n                }\n\n                if (!(isSameFile || isSamePackage)) {\n                    return illegal;\n                }\n            }\n\n            // class from same package\n\n            // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(aClassName)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(mPkgName + \".\" + aClassName)\n            if ((mPkgName !\u003d null)\n                \u0026\u0026 (clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1)\n                \u0026\u0026 (illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(mPkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            final Iterator importIter \u003d mImports.iterator();\n            while (importIter.hasNext()) {\n                final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + aClassName;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (mIllegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (Utils.baseClassname(importArg).equals(aClassName)\n                        \u0026\u0026 mIllegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "5d7063c660b241bce251f1a8c89394619f2791fb": {
      "type": "Ybodychange",
      "commitMessage": "Tighten up code\n",
      "commitDate": "26/08/04 6:34 AM",
      "commitName": "5d7063c660b241bce251f1a8c89394619f2791fb",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "14/01/04 1:10 PM",
      "commitNameOld": "5670252b46f4915b276e647fa000361915eb4ff4",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 224.68,
      "commitsBetweenForRepo": 137,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n     private String getIllegalInstantiation(String aClassName)\n     {\n         final String javaLang \u003d \"java.lang.\";\n \n         if (mIllegalClasses.contains(aClassName)) {\n             return aClassName;\n         }\n \n         final int clsNameLen \u003d aClassName.length();\n         final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n \n         final Iterator illIter \u003d mIllegalClasses.iterator();\n         while (illIter.hasNext()) {\n             final String illegal \u003d (String) illIter.next();\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n             if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(javaLang))\n             {\n                 // java.lang needs no import, but a class without import might\n                 // also come from the same file or be in the same package.\n                 // E.g. if a class defines an inner class \"Boolean\",\n                 // the expression \"new Boolean()\" refers to that class,\n                 // not to java.lang.Boolean\n \n-                boolean isSameFile \u003d mClassNames.contains(aClassName);\n+                final boolean isSameFile \u003d mClassNames.contains(aClassName);\n \n                 boolean isSamePackage \u003d false;\n                 try {\n                     final ClassLoader classLoader \u003d getClassLoader();\n                     if (classLoader !\u003d null) {\n                         final String fqName \u003d mPkgName + \".\" + aClassName;\n                         classLoader.loadClass(fqName);\n                         // no ClassNotFoundException, fqName is a known class\n                         isSamePackage \u003d true;\n                     }\n                 }\n                 catch (ClassNotFoundException ex) {\n                     // not a class from the same package\n                     isSamePackage \u003d false;\n                 }\n \n                 if (!(isSameFile || isSamePackage)) {\n                     return illegal;\n                 }\n             }\n \n             // class from same package\n \n             // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(aClassName)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(mPkgName + \".\" + aClassName)\n             if (mPkgName !\u003d null\n                 \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                 \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(mPkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             final Iterator importIter \u003d mImports.iterator();\n             while (importIter.hasNext()) {\n                 final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + aClassName;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (mIllegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(aClassName)\n                         \u0026\u0026 mIllegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String aClassName)\n    {\n        final String javaLang \u003d \"java.lang.\";\n\n        if (mIllegalClasses.contains(aClassName)) {\n            return aClassName;\n        }\n\n        final int clsNameLen \u003d aClassName.length();\n        final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n\n        final Iterator illIter \u003d mIllegalClasses.iterator();\n        while (illIter.hasNext()) {\n            final String illegal \u003d (String) illIter.next();\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(javaLang))\n            {\n                // java.lang needs no import, but a class without import might\n                // also come from the same file or be in the same package.\n                // E.g. if a class defines an inner class \"Boolean\",\n                // the expression \"new Boolean()\" refers to that class,\n                // not to java.lang.Boolean\n\n                final boolean isSameFile \u003d mClassNames.contains(aClassName);\n\n                boolean isSamePackage \u003d false;\n                try {\n                    final ClassLoader classLoader \u003d getClassLoader();\n                    if (classLoader !\u003d null) {\n                        final String fqName \u003d mPkgName + \".\" + aClassName;\n                        classLoader.loadClass(fqName);\n                        // no ClassNotFoundException, fqName is a known class\n                        isSamePackage \u003d true;\n                    }\n                }\n                catch (ClassNotFoundException ex) {\n                    // not a class from the same package\n                    isSamePackage \u003d false;\n                }\n\n                if (!(isSameFile || isSamePackage)) {\n                    return illegal;\n                }\n            }\n\n            // class from same package\n\n            // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(aClassName)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(mPkgName + \".\" + aClassName)\n            if (mPkgName !\u003d null\n                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(mPkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            final Iterator importIter \u003d mImports.iterator();\n            while (importIter.hasNext()) {\n                final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + aClassName;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (mIllegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (Utils.baseClassname(importArg).equals(aClassName)\n                        \u0026\u0026 mIllegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "bb1db4938ccae0f7149461ea372398fb8a53f2a8": {
      "type": "Ybodychange",
      "commitMessage": "fixed bug #772832, Confusion about class named \u0027Boolean\u0027\n",
      "commitDate": "03/08/03 6:22 AM",
      "commitName": "bb1db4938ccae0f7149461ea372398fb8a53f2a8",
      "commitAuthor": "Lars Kühne",
      "commitDateOld": "23/06/03 6:31 AM",
      "commitNameOld": "32f5f97181f9049af5411a5b8f151b51f1c5f165",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 40.99,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,90 @@\n     private String getIllegalInstantiation(String aClassName)\n     {\n         final String javaLang \u003d \"java.lang.\";\n \n         if (mIllegalClasses.contains(aClassName)) {\n             return aClassName;\n         }\n \n         final int clsNameLen \u003d aClassName.length();\n         final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n \n         final Iterator illIter \u003d mIllegalClasses.iterator();\n         while (illIter.hasNext()) {\n             final String illegal \u003d (String) illIter.next();\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n             if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(javaLang))\n             {\n-                return illegal;\n+                // java.lang needs no import, but a class without import might\n+                // also come from the same file or be in the same package.\n+                // E.g. if a class defines an inner class \"Boolean\",\n+                // the expression \"new Boolean()\" refers to that class,\n+                // not to java.lang.Boolean\n+\n+                boolean isSameFile \u003d mClassNames.contains(aClassName);\n+\n+                boolean isSamePackage \u003d false;\n+                try {\n+                    final ClassLoader classLoader \u003d getClassLoader();\n+                    if (classLoader !\u003d null) {\n+                        final String fqName \u003d mPkgName + \".\" + aClassName;\n+                        classLoader.loadClass(fqName);\n+                        // no ClassNotFoundException, fqName is a known class\n+                        isSamePackage \u003d true;\n+                    }\n+                }\n+                catch (ClassNotFoundException ex) {\n+                    // not a class from the same package\n+                    isSamePackage \u003d false;\n+                }\n+\n+                if (!(isSameFile || isSamePackage)) {\n+                    return illegal;\n+                }\n             }\n \n             // class from same package\n \n             // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(aClassName)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(mPkgName + \".\" + aClassName)\n             if (mPkgName !\u003d null\n                 \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                 \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(mPkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             final Iterator importIter \u003d mImports.iterator();\n             while (importIter.hasNext()) {\n                 final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + aClassName;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (mIllegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n                     if (Utils.baseClassname(importArg).equals(aClassName)\n                         \u0026\u0026 mIllegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String aClassName)\n    {\n        final String javaLang \u003d \"java.lang.\";\n\n        if (mIllegalClasses.contains(aClassName)) {\n            return aClassName;\n        }\n\n        final int clsNameLen \u003d aClassName.length();\n        final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n\n        final Iterator illIter \u003d mIllegalClasses.iterator();\n        while (illIter.hasNext()) {\n            final String illegal \u003d (String) illIter.next();\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(javaLang))\n            {\n                // java.lang needs no import, but a class without import might\n                // also come from the same file or be in the same package.\n                // E.g. if a class defines an inner class \"Boolean\",\n                // the expression \"new Boolean()\" refers to that class,\n                // not to java.lang.Boolean\n\n                boolean isSameFile \u003d mClassNames.contains(aClassName);\n\n                boolean isSamePackage \u003d false;\n                try {\n                    final ClassLoader classLoader \u003d getClassLoader();\n                    if (classLoader !\u003d null) {\n                        final String fqName \u003d mPkgName + \".\" + aClassName;\n                        classLoader.loadClass(fqName);\n                        // no ClassNotFoundException, fqName is a known class\n                        isSamePackage \u003d true;\n                    }\n                }\n                catch (ClassNotFoundException ex) {\n                    // not a class from the same package\n                    isSamePackage \u003d false;\n                }\n\n                if (!(isSameFile || isSamePackage)) {\n                    return illegal;\n                }\n            }\n\n            // class from same package\n\n            // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(aClassName)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(mPkgName + \".\" + aClassName)\n            if (mPkgName !\u003d null\n                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(mPkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            final Iterator importIter \u003d mImports.iterator();\n            while (importIter.hasNext()) {\n                final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + aClassName;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (mIllegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (Utils.baseClassname(importArg).equals(aClassName)\n                        \u0026\u0026 mIllegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "9920857810ecc9efdbca19e2749b75abc0cbbf14": {
      "type": "Yfilerename",
      "commitMessage": "Refactored the Coding checks\n",
      "commitDate": "15/06/03 5:39 AM",
      "commitName": "9920857810ecc9efdbca19e2749b75abc0cbbf14",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "14/06/03 10:47 AM",
      "commitNameOld": "e464c231eccec72f964131d9aeb5e49982c4b3bb",
      "commitAuthorOld": "Oleg Sukhodolsky",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private String getIllegalInstantiation(String aClassName)\n    {\n        final String javaLang \u003d \"java.lang.\";\n\n        if (mIllegalClasses.contains(aClassName)) {\n            return aClassName;\n        }\n\n        final int clsNameLen \u003d aClassName.length();\n        final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n\n        final Iterator illIter \u003d mIllegalClasses.iterator();\n        while (illIter.hasNext()) {\n            final String illegal \u003d (String) illIter.next();\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(javaLang))\n            {\n                return illegal;\n            }\n\n            // class from same package\n\n            // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(aClassName)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(mPkgName + \".\" + aClassName)\n            if (mPkgName !\u003d null\n                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(mPkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            final Iterator importIter \u003d mImports.iterator();\n            while (importIter.hasNext()) {\n                final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + aClassName;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (mIllegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (Utils.baseClassname(importArg).equals(aClassName)\n                        \u0026\u0026 mIllegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java",
      "extendedDetails": {
        "oldPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/IllegalInstantiationCheck.java",
        "newPath": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java"
      }
    },
    "8dd44cbead07361f2b924a5a4d5d85ace71e4866": {
      "type": "Ybodychange",
      "commitMessage": "Refactored out ugly copy/paste code.\n",
      "commitDate": "13/03/03 7:22 PM",
      "commitName": "8dd44cbead07361f2b924a5a4d5d85ace71e4866",
      "commitAuthor": "Oliver Burn",
      "commitDateOld": "15/02/03 6:50 PM",
      "commitNameOld": "04b0bd64047e8eee752405a01de145b67f5fb845",
      "commitAuthorOld": "Oliver Burn",
      "daysBetweenCommits": 26.02,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n     private String getIllegalInstantiation(String aClassName)\n     {\n         final String javaLang \u003d \"java.lang.\";\n \n         if (mIllegalClasses.contains(aClassName)) {\n             return aClassName;\n         }\n \n         final int clsNameLen \u003d aClassName.length();\n         final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n \n         final Iterator illIter \u003d mIllegalClasses.iterator();\n         while (illIter.hasNext()) {\n             final String illegal \u003d (String) illIter.next();\n             final int illegalLen \u003d illegal.length();\n \n             // class from java.lang\n             if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(javaLang))\n             {\n                 return illegal;\n             }\n \n             // class from same package\n \n             // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n             // \"illegalInsts.contains(aClassName)\" check above\n \n             // the test is the \"no garbage\" version of\n             // illegal.equals(mPkgName + \".\" + aClassName)\n             if (mPkgName !\u003d null\n                 \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                 \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                 \u0026\u0026 illegal.endsWith(aClassName)\n                 \u0026\u0026 illegal.startsWith(mPkgName))\n             {\n                 return illegal;\n             }\n             // import statements\n             final Iterator importIter \u003d mImports.iterator();\n             while (importIter.hasNext()) {\n                 final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                 final String importArg \u003d importLineText.getText();\n                 if (importArg.endsWith(\".*\")) {\n                     final String fqClass \u003d\n                         importArg.substring(0, importArg.length() - 1)\n                         + aClassName;\n                     // assume that illegalInsts only contain existing classes\n                     // or else we might create a false alarm here\n                     if (mIllegalClasses.contains(fqClass)) {\n                         return fqClass;\n                     }\n                 }\n                 else {\n-                    if (basename(importArg).equals(aClassName)\n+                    if (Utils.baseClassname(importArg).equals(aClassName)\n                         \u0026\u0026 mIllegalClasses.contains(importArg))\n                     {\n                         return importArg;\n                     }\n                 }\n             }\n         }\n         return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String aClassName)\n    {\n        final String javaLang \u003d \"java.lang.\";\n\n        if (mIllegalClasses.contains(aClassName)) {\n            return aClassName;\n        }\n\n        final int clsNameLen \u003d aClassName.length();\n        final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n\n        final Iterator illIter \u003d mIllegalClasses.iterator();\n        while (illIter.hasNext()) {\n            final String illegal \u003d (String) illIter.next();\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(javaLang))\n            {\n                return illegal;\n            }\n\n            // class from same package\n\n            // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(aClassName)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(mPkgName + \".\" + aClassName)\n            if (mPkgName !\u003d null\n                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(mPkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            final Iterator importIter \u003d mImports.iterator();\n            while (importIter.hasNext()) {\n                final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + aClassName;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (mIllegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (Utils.baseClassname(importArg).equals(aClassName)\n                        \u0026\u0026 mIllegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/IllegalInstantiationCheck.java",
      "extendedDetails": {}
    },
    "ce175a83d8ab99fe75df384ee9e6faa65e2bb3f3": {
      "type": "Yintroduced",
      "commitMessage": "ported the illegal instantiations check\nstill need to remove the old code\n",
      "commitDate": "29/09/02 12:43 PM",
      "commitName": "ce175a83d8ab99fe75df384ee9e6faa65e2bb3f3",
      "commitAuthor": "Lars Kühne",
      "diff": "@@ -0,0 +1,65 @@\n+    private String getIllegalInstantiation(String aClassName)\n+    {\n+        final String javaLang \u003d \"java.lang.\";\n+\n+        if (mIllegalClasses.contains(aClassName)) {\n+            return aClassName;\n+        }\n+\n+        final int clsNameLen \u003d aClassName.length();\n+        final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n+\n+        final Iterator illIter \u003d mIllegalClasses.iterator();\n+        while (illIter.hasNext()) {\n+            final String illegal \u003d (String) illIter.next();\n+            final int illegalLen \u003d illegal.length();\n+\n+            // class from java.lang\n+            if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n+                \u0026\u0026 illegal.endsWith(aClassName)\n+                \u0026\u0026 illegal.startsWith(javaLang))\n+            {\n+                return illegal;\n+            }\n+\n+            // class from same package\n+\n+            // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n+            // \"illegalInsts.contains(aClassName)\" check above\n+\n+            // the test is the \"no garbage\" version of\n+            // illegal.equals(mPkgName + \".\" + aClassName)\n+            if (mPkgName !\u003d null\n+                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n+                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n+                \u0026\u0026 illegal.endsWith(aClassName)\n+                \u0026\u0026 illegal.startsWith(mPkgName))\n+            {\n+                return illegal;\n+            }\n+            // import statements\n+            final Iterator importIter \u003d mImports.iterator();\n+            while (importIter.hasNext()) {\n+                final FullIdent importLineText \u003d (FullIdent) importIter.next();\n+                final String importArg \u003d importLineText.getText();\n+                if (importArg.endsWith(\".*\")) {\n+                    final String fqClass \u003d\n+                        importArg.substring(0, importArg.length() - 1)\n+                        + aClassName;\n+                    // assume that illegalInsts only contain existing classes\n+                    // or else we might create a false alarm here\n+                    if (mIllegalClasses.contains(fqClass)) {\n+                        return fqClass;\n+                    }\n+                }\n+                else {\n+                    if (basename(importArg).equals(aClassName)\n+                        \u0026\u0026 mIllegalClasses.contains(importArg))\n+                    {\n+                        return importArg;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private String getIllegalInstantiation(String aClassName)\n    {\n        final String javaLang \u003d \"java.lang.\";\n\n        if (mIllegalClasses.contains(aClassName)) {\n            return aClassName;\n        }\n\n        final int clsNameLen \u003d aClassName.length();\n        final int pkgNameLen \u003d (mPkgName \u003d\u003d null) ? 0 : mPkgName.length();\n\n        final Iterator illIter \u003d mIllegalClasses.iterator();\n        while (illIter.hasNext()) {\n            final String illegal \u003d (String) illIter.next();\n            final int illegalLen \u003d illegal.length();\n\n            // class from java.lang\n            if (((illegalLen - javaLang.length()) \u003d\u003d clsNameLen)\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(javaLang))\n            {\n                return illegal;\n            }\n\n            // class from same package\n\n            // the toplevel package (mPkgName \u003d\u003d null) is covered by the\n            // \"illegalInsts.contains(aClassName)\" check above\n\n            // the test is the \"no garbage\" version of\n            // illegal.equals(mPkgName + \".\" + aClassName)\n            if (mPkgName !\u003d null\n                \u0026\u0026 clsNameLen \u003d\u003d illegalLen - pkgNameLen - 1\n                \u0026\u0026 illegal.charAt(pkgNameLen) \u003d\u003d \u0027.\u0027\n                \u0026\u0026 illegal.endsWith(aClassName)\n                \u0026\u0026 illegal.startsWith(mPkgName))\n            {\n                return illegal;\n            }\n            // import statements\n            final Iterator importIter \u003d mImports.iterator();\n            while (importIter.hasNext()) {\n                final FullIdent importLineText \u003d (FullIdent) importIter.next();\n                final String importArg \u003d importLineText.getText();\n                if (importArg.endsWith(\".*\")) {\n                    final String fqClass \u003d\n                        importArg.substring(0, importArg.length() - 1)\n                        + aClassName;\n                    // assume that illegalInsts only contain existing classes\n                    // or else we might create a false alarm here\n                    if (mIllegalClasses.contains(fqClass)) {\n                        return fqClass;\n                    }\n                }\n                else {\n                    if (basename(importArg).equals(aClassName)\n                        \u0026\u0026 mIllegalClasses.contains(importArg))\n                    {\n                        return importArg;\n                    }\n                }\n            }\n        }\n        return null;\n    }",
      "path": "src/checkstyle/com/puppycrawl/tools/checkstyle/checks/IllegalInstantiationCheck.java"
    }
  }
}