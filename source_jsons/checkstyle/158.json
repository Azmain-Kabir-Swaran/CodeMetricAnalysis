{
  "origin": "codeshovel",
  "repositoryName": "checkstyle",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/checkstyle/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractItModuleTestSupport.java",
  "functionName": "verify",
  "functionId": "verify___checker-Checker__processedFiles-File[]__messageFileName-String__expected-String[]__warnsExpected-Integer",
  "sourceFilePath": "src/it/java/org/checkstyle/base/AbstractItModuleTestSupport.java",
  "functionStartLine": 231,
  "functionEndLine": 273,
  "numCommitsSeen": 119,
  "timeTaken": 3934,
  "changeHistory": [
    "8ed2ebf91585e0320f4d6584abac1ad5de73105e",
    "c7ffe16d7e090cb5832aac65b874cf869de38d49",
    "c8f8c5ac20ad8d58a75e4c4ab1cd4eef533a18d7",
    "c28b535e91cb73f7630230695ef52fdf655e46e4",
    "5c6cdde35d65d19661f8f7fb59f130e646fa567d",
    "6d290adcd7efb8e9f07d2730e9960c6dc3e713ba",
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
    "28be7d283951dd39e7f58384232c1a5baa582685",
    "5e82f8c44b29f7f46c132a275e878ce838326e0d",
    "5e0f360e7b7745a362bd7a655e98654a2ad36443",
    "fdd5ed77fd1ea61768683ee8cfacf78190a2d3aa",
    "7a4ec11d123dc0bbf7db943af715d19814d2e332",
    "344ea5c012d1814441b5758013a2b035c6e1613a",
    "f7e41edb947dad22e10eeaa2e68e6f44b4bfa747",
    "f5e4d9b42a3ebda0adc7f7616f1b00c189f20733",
    "7b8a3aa5bba1323a7bbb85b6dbd86835215a48fc",
    "9cc86b38df9a086713d1fcdf01b451b41c0d6f65",
    "8142c804e90f6d24a3a5db736f3f1f576766a9a5",
    "a992ca414f212fa4cdc52d8c510e6cfae27cc67c",
    "5f46a3b3faad9d8eedc3b0924c44d0352be3a219",
    "4f6d7e415dc3253c5bde537f2a8d262de9b6aba2",
    "bc0bf95daedb6f0e658187d6e44410a60f46dbe2",
    "88edaa84fdcd29fe5cce6c3497cb326244b14197",
    "943ace0dd67911db776be674e66a873df1442db0",
    "52ac2776d7f128ff812b73b54dcc12210661f98b"
  ],
  "changeHistoryShort": {
    "8ed2ebf91585e0320f4d6584abac1ad5de73105e": "Ybodychange",
    "c7ffe16d7e090cb5832aac65b874cf869de38d49": "Yfilerename",
    "c8f8c5ac20ad8d58a75e4c4ab1cd4eef533a18d7": "Ybodychange",
    "c28b535e91cb73f7630230695ef52fdf655e46e4": "Ybodychange",
    "5c6cdde35d65d19661f8f7fb59f130e646fa567d": "Ymodifierchange",
    "6d290adcd7efb8e9f07d2730e9960c6dc3e713ba": "Yfilerename",
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020": "Ybodychange",
    "28be7d283951dd39e7f58384232c1a5baa582685": "Ybodychange",
    "5e82f8c44b29f7f46c132a275e878ce838326e0d": "Ybodychange",
    "5e0f360e7b7745a362bd7a655e98654a2ad36443": "Ybodychange",
    "fdd5ed77fd1ea61768683ee8cfacf78190a2d3aa": "Ybodychange",
    "7a4ec11d123dc0bbf7db943af715d19814d2e332": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "344ea5c012d1814441b5758013a2b035c6e1613a": "Ybodychange",
    "f7e41edb947dad22e10eeaa2e68e6f44b4bfa747": "Ybodychange",
    "f5e4d9b42a3ebda0adc7f7616f1b00c189f20733": "Ybodychange",
    "7b8a3aa5bba1323a7bbb85b6dbd86835215a48fc": "Ybodychange",
    "9cc86b38df9a086713d1fcdf01b451b41c0d6f65": "Ybodychange",
    "8142c804e90f6d24a3a5db736f3f1f576766a9a5": "Ymodifierchange",
    "a992ca414f212fa4cdc52d8c510e6cfae27cc67c": "Ybodychange",
    "5f46a3b3faad9d8eedc3b0924c44d0352be3a219": "Yparameterchange",
    "4f6d7e415dc3253c5bde537f2a8d262de9b6aba2": "Ybodychange",
    "bc0bf95daedb6f0e658187d6e44410a60f46dbe2": "Ybodychange",
    "88edaa84fdcd29fe5cce6c3497cb326244b14197": "Ybodychange",
    "943ace0dd67911db776be674e66a873df1442db0": "Ybodychange",
    "52ac2776d7f128ff812b73b54dcc12210661f98b": "Ybodychange"
  },
  "changeHistoryDetails": {
    "8ed2ebf91585e0320f4d6584abac1ad5de73105e": {
      "type": "Ybodychange",
      "commitMessage": "Issue #6916: migrate integration tests to junit5\n",
      "commitDate": "03/12/19 8:55 AM",
      "commitName": "8ed2ebf91585e0320f4d6584abac1ad5de73105e",
      "commitAuthor": "Andrei Paikin",
      "commitDateOld": "26/06/19 9:13 PM",
      "commitNameOld": "6bab0788365ba9afb713e14d9f6263f1f60b7aa2",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 159.53,
      "commitsBetweenForRepo": 312,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,43 @@\n     protected final void verify(Checker checker,\n             File[] processedFiles,\n             String messageFileName,\n             String[] expected,\n             Integer... warnsExpected)\n             throws Exception {\n         stream.flush();\n         stream.reset();\n         final List\u003cFile\u003e theFiles \u003d new ArrayList\u003c\u003e();\n         Collections.addAll(theFiles, processedFiles);\n         final List\u003cInteger\u003e theWarnings \u003d new ArrayList\u003c\u003e();\n         Collections.addAll(theWarnings, warnsExpected);\n         final int errs \u003d checker.process(theFiles);\n \n         // process each of the lines\n         try (ByteArrayInputStream inputStream \u003d\n                 new ByteArrayInputStream(stream.toByteArray());\n             LineNumberReader lnr \u003d new LineNumberReader(\n                 new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n             int previousLineNumber \u003d 0;\n             for (int i \u003d 0; i \u003c expected.length; i++) {\n                 final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                 final String actual \u003d lnr.readLine();\n-                assertEquals(\"error message \" + i, expectedResult, actual);\n+                assertEquals(expectedResult, actual, \"error message \" + i);\n \n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 final int lineNumber \u003d Integer.parseInt(parseInt);\n-                assertTrue(\"input file is expected to have a warning comment on line number \"\n-                        + lineNumber, previousLineNumber \u003d\u003d lineNumber\n-                            || theWarnings.remove((Integer) lineNumber));\n+                assertTrue(previousLineNumber \u003d\u003d lineNumber\n+                                || theWarnings.remove((Integer) lineNumber),\n+                        \"input file is expected to have a warning comment on line number \"\n+                                        + lineNumber);\n                 previousLineNumber \u003d lineNumber;\n             }\n \n-            assertEquals(\"unexpected output: \" + lnr.readLine(),\n-                    expected.length, errs);\n-            assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n+            assertEquals(expected.length,\n+                    errs, \"unexpected output: \" + lnr.readLine());\n+            assertEquals(0, theWarnings.size(), \"unexpected warnings \" + theWarnings);\n         }\n \n         checker.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected final void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n            throws Exception {\n        stream.flush();\n        stream.reset();\n        final List\u003cFile\u003e theFiles \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        try (ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n            LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n            int previousLineNumber \u003d 0;\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(expectedResult, actual, \"error message \" + i);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertTrue(previousLineNumber \u003d\u003d lineNumber\n                                || theWarnings.remove((Integer) lineNumber),\n                        \"input file is expected to have a warning comment on line number \"\n                                        + lineNumber);\n                previousLineNumber \u003d lineNumber;\n            }\n\n            assertEquals(expected.length,\n                    errs, \"unexpected output: \" + lnr.readLine());\n            assertEquals(0, theWarnings.size(), \"unexpected warnings \" + theWarnings);\n        }\n\n        checker.destroy();\n    }",
      "path": "src/it/java/org/checkstyle/base/AbstractItModuleTestSupport.java",
      "extendedDetails": {}
    },
    "c7ffe16d7e090cb5832aac65b874cf869de38d49": {
      "type": "Yfilerename",
      "commitMessage": "Pull #6801: split it module test support between different\nconfigurations",
      "commitDate": "10/06/19 11:02 AM",
      "commitName": "c7ffe16d7e090cb5832aac65b874cf869de38d49",
      "commitAuthor": "rnveach",
      "commitDateOld": "06/06/19 6:08 PM",
      "commitNameOld": "9b8dea47d8a636905071e962675a644f8c5ba351",
      "commitAuthorOld": "Peter De Maeyer",
      "daysBetweenCommits": 3.7,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    protected final void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n            throws Exception {\n        stream.flush();\n        stream.reset();\n        final List\u003cFile\u003e theFiles \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        try (ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n            LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n            int previousLineNumber \u003d 0;\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertTrue(\"input file is expected to have a warning comment on line number \"\n                        + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                            || theWarnings.remove((Integer) lineNumber));\n                previousLineNumber \u003d lineNumber;\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n        }\n\n        checker.destroy();\n    }",
      "path": "src/it/java/org/checkstyle/base/AbstractItModuleTestSupport.java",
      "extendedDetails": {
        "oldPath": "src/it/java/com/google/checkstyle/test/base/AbstractModuleTestSupport.java",
        "newPath": "src/it/java/org/checkstyle/base/AbstractItModuleTestSupport.java"
      }
    },
    "c8f8c5ac20ad8d58a75e4c4ab1cd4eef533a18d7": {
      "type": "Ybodychange",
      "commitMessage": "Pull #6557: reset the test stream for each test\n",
      "commitDate": "16/03/19 6:15 AM",
      "commitName": "c8f8c5ac20ad8d58a75e4c4ab1cd4eef533a18d7",
      "commitAuthor": "Bj√∂rn Kautler",
      "commitDateOld": "15/01/19 5:46 AM",
      "commitNameOld": "a73ff0890c27cbe8affc1a55f2710a231687bd85",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 59.98,
      "commitsBetweenForRepo": 115,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,42 @@\n     protected final void verify(Checker checker,\n             File[] processedFiles,\n             String messageFileName,\n             String[] expected,\n             Integer... warnsExpected)\n             throws Exception {\n         stream.flush();\n+        stream.reset();\n         final List\u003cFile\u003e theFiles \u003d new ArrayList\u003c\u003e();\n         Collections.addAll(theFiles, processedFiles);\n         final List\u003cInteger\u003e theWarnings \u003d new ArrayList\u003c\u003e();\n         Collections.addAll(theWarnings, warnsExpected);\n         final int errs \u003d checker.process(theFiles);\n \n         // process each of the lines\n         try (ByteArrayInputStream inputStream \u003d\n                 new ByteArrayInputStream(stream.toByteArray());\n             LineNumberReader lnr \u003d new LineNumberReader(\n                 new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n             int previousLineNumber \u003d 0;\n             for (int i \u003d 0; i \u003c expected.length; i++) {\n                 final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                 final String actual \u003d lnr.readLine();\n                 assertEquals(\"error message \" + i, expectedResult, actual);\n \n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 final int lineNumber \u003d Integer.parseInt(parseInt);\n                 assertTrue(\"input file is expected to have a warning comment on line number \"\n                         + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                             || theWarnings.remove((Integer) lineNumber));\n                 previousLineNumber \u003d lineNumber;\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     expected.length, errs);\n             assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n         }\n \n         checker.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected final void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n            throws Exception {\n        stream.flush();\n        stream.reset();\n        final List\u003cFile\u003e theFiles \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        try (ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n            LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n            int previousLineNumber \u003d 0;\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertTrue(\"input file is expected to have a warning comment on line number \"\n                        + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                            || theWarnings.remove((Integer) lineNumber));\n                previousLineNumber \u003d lineNumber;\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n        }\n\n        checker.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/AbstractModuleTestSupport.java",
      "extendedDetails": {}
    },
    "c28b535e91cb73f7630230695ef52fdf655e46e4": {
      "type": "Ybodychange",
      "commitMessage": "Issue #5616: Remove remnants of cobertura usage\n",
      "commitDate": "20/04/18 11:55 AM",
      "commitName": "c28b535e91cb73f7630230695ef52fdf655e46e4",
      "commitAuthor": "Pavel Bludov",
      "commitDateOld": "14/04/18 5:52 AM",
      "commitNameOld": "042bf228c796f5fa7c5b4b96b94e0afd7b465538",
      "commitAuthorOld": "Pavel Bludov",
      "daysBetweenCommits": 6.25,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n     protected final void verify(Checker checker,\n             File[] processedFiles,\n             String messageFileName,\n             String[] expected,\n             Integer... warnsExpected)\n             throws Exception {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d new ArrayList\u003c\u003e();\n         Collections.addAll(theFiles, processedFiles);\n         final List\u003cInteger\u003e theWarnings \u003d new ArrayList\u003c\u003e();\n         Collections.addAll(theWarnings, warnsExpected);\n         final int errs \u003d checker.process(theFiles);\n \n         // process each of the lines\n-        final ByteArrayInputStream inputStream \u003d\n+        try (ByteArrayInputStream inputStream \u003d\n                 new ByteArrayInputStream(stream.toByteArray());\n-        try (LineNumberReader lnr \u003d new LineNumberReader(\n+            LineNumberReader lnr \u003d new LineNumberReader(\n                 new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n             int previousLineNumber \u003d 0;\n             for (int i \u003d 0; i \u003c expected.length; i++) {\n                 final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                 final String actual \u003d lnr.readLine();\n                 assertEquals(\"error message \" + i, expectedResult, actual);\n \n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 final int lineNumber \u003d Integer.parseInt(parseInt);\n                 assertTrue(\"input file is expected to have a warning comment on line number \"\n                         + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                             || theWarnings.remove((Integer) lineNumber));\n                 previousLineNumber \u003d lineNumber;\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     expected.length, errs);\n             assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n         }\n \n         checker.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected final void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n            throws Exception {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        try (ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n            LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n            int previousLineNumber \u003d 0;\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertTrue(\"input file is expected to have a warning comment on line number \"\n                        + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                            || theWarnings.remove((Integer) lineNumber));\n                previousLineNumber \u003d lineNumber;\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n        }\n\n        checker.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/AbstractModuleTestSupport.java",
      "extendedDetails": {}
    },
    "5c6cdde35d65d19661f8f7fb59f130e646fa567d": {
      "type": "Ymodifierchange",
      "commitMessage": "minor: locked down abstract test classes from overriding",
      "commitDate": "08/12/17 6:21 AM",
      "commitName": "5c6cdde35d65d19661f8f7fb59f130e646fa567d",
      "commitAuthor": "rnveach",
      "commitDateOld": "25/09/17 5:44 AM",
      "commitNameOld": "3c1ddf428d9ddecaff63986007b4f5ff0593c098",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 74.07,
      "commitsBetweenForRepo": 140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n-    protected void verify(Checker checker,\n+    protected final void verify(Checker checker,\n             File[] processedFiles,\n             String messageFileName,\n             String[] expected,\n             Integer... warnsExpected)\n             throws Exception {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d new ArrayList\u003c\u003e();\n         Collections.addAll(theFiles, processedFiles);\n         final List\u003cInteger\u003e theWarnings \u003d new ArrayList\u003c\u003e();\n         Collections.addAll(theWarnings, warnsExpected);\n         final int errs \u003d checker.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream inputStream \u003d\n                 new ByteArrayInputStream(stream.toByteArray());\n         try (LineNumberReader lnr \u003d new LineNumberReader(\n                 new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n \n             int previousLineNumber \u003d 0;\n             for (int i \u003d 0; i \u003c expected.length; i++) {\n                 final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                 final String actual \u003d lnr.readLine();\n                 assertEquals(\"error message \" + i, expectedResult, actual);\n \n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 final int lineNumber \u003d Integer.parseInt(parseInt);\n                 assertTrue(\"input file is expected to have a warning comment on line number \"\n                         + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                             || theWarnings.remove((Integer) lineNumber));\n                 previousLineNumber \u003d lineNumber;\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     expected.length, errs);\n             assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n         }\n \n         checker.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected final void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n            throws Exception {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n        try (LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n\n            int previousLineNumber \u003d 0;\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertTrue(\"input file is expected to have a warning comment on line number \"\n                        + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                            || theWarnings.remove((Integer) lineNumber));\n                previousLineNumber \u003d lineNumber;\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n        }\n\n        checker.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/AbstractModuleTestSupport.java",
      "extendedDetails": {
        "oldValue": "[protected]",
        "newValue": "[protected, final]"
      }
    },
    "6d290adcd7efb8e9f07d2730e9960c6dc3e713ba": {
      "type": "Yfilerename",
      "commitMessage": "Issue #4592: Added AbstractPathTestSupport, AbstractModuleTestSupport, AbstractIndentationTestSupport and all tests in ITs extend them\n",
      "commitDate": "01/08/17 10:56 AM",
      "commitName": "6d290adcd7efb8e9f07d2730e9960c6dc3e713ba",
      "commitAuthor": "Subbu Dantu",
      "commitDateOld": "01/08/17 6:06 AM",
      "commitNameOld": "29e131f949950d26e7880da5891d1754776fdeee",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    protected void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n            throws Exception {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n        try (LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n\n            int previousLineNumber \u003d 0;\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertTrue(\"input file is expected to have a warning comment on line number \"\n                        + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                            || theWarnings.remove((Integer) lineNumber));\n                previousLineNumber \u003d lineNumber;\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n        }\n\n        checker.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/AbstractModuleTestSupport.java",
      "extendedDetails": {
        "oldPath": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
        "newPath": "src/it/java/com/google/checkstyle/test/base/AbstractModuleTestSupport.java"
      }
    },
    "fbf3f95c2273be23b966cba6e6ef89390a6fb020": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3433: Cut down on Checkstyle\u0027s dependencies on Guava (part 2) (#3454)\n\n",
      "commitDate": "20/09/16 7:52 PM",
      "commitName": "fbf3f95c2273be23b966cba6e6ef89390a6fb020",
      "commitAuthor": "Andrei Selkin",
      "commitDateOld": "26/07/16 8:19 PM",
      "commitNameOld": "28be7d283951dd39e7f58384232c1a5baa582685",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 55.98,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n     protected void verify(Checker checker,\n             File[] processedFiles,\n             String messageFileName,\n             String[] expected,\n             Integer... warnsExpected)\n             throws Exception {\n         stream.flush();\n-        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n+        final List\u003cFile\u003e theFiles \u003d new ArrayList\u003c\u003e();\n         Collections.addAll(theFiles, processedFiles);\n-        final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n+        final List\u003cInteger\u003e theWarnings \u003d new ArrayList\u003c\u003e();\n         Collections.addAll(theWarnings, warnsExpected);\n         final int errs \u003d checker.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream inputStream \u003d\n                 new ByteArrayInputStream(stream.toByteArray());\n         try (LineNumberReader lnr \u003d new LineNumberReader(\n                 new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n \n             int previousLineNumber \u003d 0;\n             for (int i \u003d 0; i \u003c expected.length; i++) {\n                 final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                 final String actual \u003d lnr.readLine();\n                 assertEquals(\"error message \" + i, expectedResult, actual);\n \n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 final int lineNumber \u003d Integer.parseInt(parseInt);\n                 assertTrue(\"input file is expected to have a warning comment on line number \"\n                         + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                             || theWarnings.remove((Integer) lineNumber));\n                 previousLineNumber \u003d lineNumber;\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     expected.length, errs);\n             assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n         }\n \n         checker.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n            throws Exception {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d new ArrayList\u003c\u003e();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n        try (LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n\n            int previousLineNumber \u003d 0;\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertTrue(\"input file is expected to have a warning comment on line number \"\n                        + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                            || theWarnings.remove((Integer) lineNumber));\n                previousLineNumber \u003d lineNumber;\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n        }\n\n        checker.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "28be7d283951dd39e7f58384232c1a5baa582685": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3323: fixed redundant modifier violations on try-with-resources",
      "commitDate": "26/07/16 8:19 PM",
      "commitName": "28be7d283951dd39e7f58384232c1a5baa582685",
      "commitAuthor": "rnveach",
      "commitDateOld": "13/05/16 5:28 PM",
      "commitNameOld": "5e82f8c44b29f7f46c132a275e878ce838326e0d",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 74.12,
      "commitsBetweenForRepo": 179,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n     protected void verify(Checker checker,\n             File[] processedFiles,\n             String messageFileName,\n             String[] expected,\n             Integer... warnsExpected)\n             throws Exception {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, processedFiles);\n         final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n         Collections.addAll(theWarnings, warnsExpected);\n         final int errs \u003d checker.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream inputStream \u003d\n                 new ByteArrayInputStream(stream.toByteArray());\n-        try (final LineNumberReader lnr \u003d new LineNumberReader(\n+        try (LineNumberReader lnr \u003d new LineNumberReader(\n                 new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n \n             int previousLineNumber \u003d 0;\n             for (int i \u003d 0; i \u003c expected.length; i++) {\n                 final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                 final String actual \u003d lnr.readLine();\n                 assertEquals(\"error message \" + i, expectedResult, actual);\n \n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 final int lineNumber \u003d Integer.parseInt(parseInt);\n                 assertTrue(\"input file is expected to have a warning comment on line number \"\n                         + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                             || theWarnings.remove((Integer) lineNumber));\n                 previousLineNumber \u003d lineNumber;\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     expected.length, errs);\n             assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n         }\n \n         checker.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n            throws Exception {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n        try (LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n\n            int previousLineNumber \u003d 0;\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertTrue(\"input file is expected to have a warning comment on line number \"\n                        + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                            || theWarnings.remove((Integer) lineNumber));\n                previousLineNumber \u003d lineNumber;\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n        }\n\n        checker.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "5e82f8c44b29f7f46c132a275e878ce838326e0d": {
      "type": "Ybodychange",
      "commitMessage": "Issue #3175: fixed sevntu violations in test and it",
      "commitDate": "13/05/16 5:28 PM",
      "commitName": "5e82f8c44b29f7f46c132a275e878ce838326e0d",
      "commitAuthor": "rnveach",
      "commitDateOld": "07/05/16 9:41 AM",
      "commitNameOld": "871b20e88b5bfedb324f3e1996b37d0c68eb727b",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 6.32,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n     protected void verify(Checker checker,\n             File[] processedFiles,\n             String messageFileName,\n             String[] expected,\n             Integer... warnsExpected)\n             throws Exception {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, processedFiles);\n         final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n         Collections.addAll(theWarnings, warnsExpected);\n         final int errs \u003d checker.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream inputStream \u003d\n                 new ByteArrayInputStream(stream.toByteArray());\n         try (final LineNumberReader lnr \u003d new LineNumberReader(\n                 new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n \n             int previousLineNumber \u003d 0;\n             for (int i \u003d 0; i \u003c expected.length; i++) {\n                 final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                 final String actual \u003d lnr.readLine();\n                 assertEquals(\"error message \" + i, expectedResult, actual);\n \n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 final int lineNumber \u003d Integer.parseInt(parseInt);\n                 assertTrue(\"input file is expected to have a warning comment on line number \"\n-                        + lineNumber, theWarnings.remove((Integer) lineNumber)\n-                            || previousLineNumber \u003d\u003d lineNumber);\n+                        + lineNumber, previousLineNumber \u003d\u003d lineNumber\n+                            || theWarnings.remove((Integer) lineNumber));\n                 previousLineNumber \u003d lineNumber;\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     expected.length, errs);\n             assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n         }\n \n         checker.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n            throws Exception {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n        try (final LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n\n            int previousLineNumber \u003d 0;\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertTrue(\"input file is expected to have a warning comment on line number \"\n                        + lineNumber, previousLineNumber \u003d\u003d lineNumber\n                            || theWarnings.remove((Integer) lineNumber));\n                previousLineNumber \u003d lineNumber;\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n        }\n\n        checker.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "5e0f360e7b7745a362bd7a655e98654a2ad36443": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2658: Repair verification of expected warnings in ITs\n",
      "commitDate": "06/12/15 2:14 PM",
      "commitName": "5e0f360e7b7745a362bd7a655e98654a2ad36443",
      "commitAuthor": "Vladislav Lisetskiy",
      "commitDateOld": "03/12/15 3:16 PM",
      "commitNameOld": "f65b17cbc30795247fef3077cce16a8bb53e9ffc",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.96,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,42 @@\n     protected void verify(Checker checker,\n             File[] processedFiles,\n             String messageFileName,\n             String[] expected,\n             Integer... warnsExpected)\n         throws Exception {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, processedFiles);\n         final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n         Collections.addAll(theWarnings, warnsExpected);\n         final int errs \u003d checker.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream inputStream \u003d\n                 new ByteArrayInputStream(stream.toByteArray());\n         try (final LineNumberReader lnr \u003d new LineNumberReader(\n                 new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n \n+            int previousLineNumber \u003d 0;\n             for (int i \u003d 0; i \u003c expected.length; i++) {\n                 final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                 final String actual \u003d lnr.readLine();\n                 assertEquals(\"error message \" + i, expectedResult, actual);\n \n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 final int lineNumber \u003d Integer.parseInt(parseInt);\n-                assertNotNull(\"expected input file to have warning comment on line number \"\n-                        + lineNumber, theWarnings.remove((Integer) lineNumber));\n+                assertTrue(\"input file is expected to have a warning comment on line number \"\n+                        + lineNumber, theWarnings.remove((Integer) lineNumber)\n+                            || previousLineNumber \u003d\u003d lineNumber);\n+                previousLineNumber \u003d lineNumber;\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     expected.length, errs);\n             assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n         }\n \n         checker.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n        throws Exception {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n        try (final LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n\n            int previousLineNumber \u003d 0;\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertTrue(\"input file is expected to have a warning comment on line number \"\n                        + lineNumber, theWarnings.remove((Integer) lineNumber)\n                            || previousLineNumber \u003d\u003d lineNumber);\n                previousLineNumber \u003d lineNumber;\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n        }\n\n        checker.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "fdd5ed77fd1ea61768683ee8cfacf78190a2d3aa": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2080: Simplify JUnit assertion\n",
      "commitDate": "21/11/15 4:24 PM",
      "commitName": "fdd5ed77fd1ea61768683ee8cfacf78190a2d3aa",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "12/11/15 7:08 PM",
      "commitNameOld": "7a4ec11d123dc0bbf7db943af715d19814d2e332",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 8.89,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n     protected void verify(Checker checker,\n             File[] processedFiles,\n             String messageFileName,\n             String[] expected,\n             Integer... warnsExpected)\n         throws Exception {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, processedFiles);\n         final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n         Collections.addAll(theWarnings, warnsExpected);\n         final int errs \u003d checker.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream inputStream \u003d\n                 new ByteArrayInputStream(stream.toByteArray());\n         try (final LineNumberReader lnr \u003d new LineNumberReader(\n                 new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n \n             for (int i \u003d 0; i \u003c expected.length; i++) {\n                 final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                 final String actual \u003d lnr.readLine();\n                 assertEquals(\"error message \" + i, expectedResult, actual);\n \n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 final int lineNumber \u003d Integer.parseInt(parseInt);\n                 assertNotNull(\"expected input file to have warning comment on line number \"\n                         + lineNumber, theWarnings.remove((Integer) lineNumber));\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     expected.length, errs);\n-            assertTrue(\"unexpected warnings \" + theWarnings, theWarnings.size() \u003d\u003d 0);\n+            assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n         }\n \n         checker.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n        throws Exception {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n        try (final LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertNotNull(\"expected input file to have warning comment on line number \"\n                        + lineNumber, theWarnings.remove((Integer) lineNumber));\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertEquals(\"unexpected warnings \" + theWarnings, 0, theWarnings.size());\n        }\n\n        checker.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "7a4ec11d123dc0bbf7db943af715d19814d2e332": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "Issue #2589: Unify IT test code.",
      "commitDate": "12/11/15 7:08 PM",
      "commitName": "7a4ec11d123dc0bbf7db943af715d19814d2e332",
      "commitAuthor": "rnveach",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Issue #2589: Unify IT test code.",
          "commitDate": "12/11/15 7:08 PM",
          "commitName": "7a4ec11d123dc0bbf7db943af715d19814d2e332",
          "commitAuthor": "rnveach",
          "commitDateOld": "25/10/15 11:30 AM",
          "commitNameOld": "344ea5c012d1814441b5758013a2b035c6e1613a",
          "commitAuthorOld": "rnveach",
          "daysBetweenCommits": 18.36,
          "commitsBetweenForRepo": 137,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,39 @@\n-    void verify(Checker aC,\n-            File[] aProcessedFiles,\n-            String aMessageFileName,\n-            String[] aExpected,\n-            Integer... aWarnsExpected)\n+    protected void verify(Checker checker,\n+            File[] processedFiles,\n+            String messageFileName,\n+            String[] expected,\n+            Integer... warnsExpected)\n         throws Exception {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n-        Collections.addAll(theFiles, aProcessedFiles);\n-        final int errs \u003d aC.process(theFiles);\n+        Collections.addAll(theFiles, processedFiles);\n+        final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n+        Collections.addAll(theWarnings, warnsExpected);\n+        final int errs \u003d checker.process(theFiles);\n \n         // process each of the lines\n-        final ByteArrayInputStream localStream \u003d\n-            new ByteArrayInputStream(stream.toByteArray());\n+        final ByteArrayInputStream inputStream \u003d\n+                new ByteArrayInputStream(stream.toByteArray());\n         try (final LineNumberReader lnr \u003d new LineNumberReader(\n-                new InputStreamReader(localStream, StandardCharsets.UTF_8))) {\n+                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n \n-            for (int i \u003d 0; i \u003c aExpected.length; i++) {\n-                final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n+            for (int i \u003d 0; i \u003c expected.length; i++) {\n+                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                 final String actual \u003d lnr.readLine();\n-                assertEquals(\"error message \" + i, expected, actual);\n+                assertEquals(\"error message \" + i, expectedResult, actual);\n+\n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 final int lineNumber \u003d Integer.parseInt(parseInt);\n-                Integer integer \u003d 0;\n-                if (Arrays.asList(aWarnsExpected).contains(lineNumber)) {\n-                    integer \u003d lineNumber;\n-                }\n-                assertEquals(\"error message \" + i, (long) integer, lineNumber);\n+                assertNotNull(\"expected input file to have warning comment on line number \"\n+                        + lineNumber, theWarnings.remove((Integer) lineNumber));\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n-                    aExpected.length, errs);\n+                    expected.length, errs);\n+            assertTrue(\"unexpected warnings \" + theWarnings, theWarnings.size() \u003d\u003d 0);\n         }\n-        aC.destroy();\n+\n+        checker.destroy();\n     }\n\\ No newline at end of file\n",
          "actualSource": "    protected void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n        throws Exception {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n        try (final LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertNotNull(\"expected input file to have warning comment on line number \"\n                        + lineNumber, theWarnings.remove((Integer) lineNumber));\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertTrue(\"unexpected warnings \" + theWarnings, theWarnings.size() \u003d\u003d 0);\n        }\n\n        checker.destroy();\n    }",
          "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
          "extendedDetails": {
            "oldValue": "[aC-Checker, aProcessedFiles-File[], aMessageFileName-String, aExpected-String[], aWarnsExpected-Integer]",
            "newValue": "[checker-Checker, processedFiles-File[], messageFileName-String, expected-String[], warnsExpected-Integer]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "Issue #2589: Unify IT test code.",
          "commitDate": "12/11/15 7:08 PM",
          "commitName": "7a4ec11d123dc0bbf7db943af715d19814d2e332",
          "commitAuthor": "rnveach",
          "commitDateOld": "25/10/15 11:30 AM",
          "commitNameOld": "344ea5c012d1814441b5758013a2b035c6e1613a",
          "commitAuthorOld": "rnveach",
          "daysBetweenCommits": 18.36,
          "commitsBetweenForRepo": 137,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,39 @@\n-    void verify(Checker aC,\n-            File[] aProcessedFiles,\n-            String aMessageFileName,\n-            String[] aExpected,\n-            Integer... aWarnsExpected)\n+    protected void verify(Checker checker,\n+            File[] processedFiles,\n+            String messageFileName,\n+            String[] expected,\n+            Integer... warnsExpected)\n         throws Exception {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n-        Collections.addAll(theFiles, aProcessedFiles);\n-        final int errs \u003d aC.process(theFiles);\n+        Collections.addAll(theFiles, processedFiles);\n+        final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n+        Collections.addAll(theWarnings, warnsExpected);\n+        final int errs \u003d checker.process(theFiles);\n \n         // process each of the lines\n-        final ByteArrayInputStream localStream \u003d\n-            new ByteArrayInputStream(stream.toByteArray());\n+        final ByteArrayInputStream inputStream \u003d\n+                new ByteArrayInputStream(stream.toByteArray());\n         try (final LineNumberReader lnr \u003d new LineNumberReader(\n-                new InputStreamReader(localStream, StandardCharsets.UTF_8))) {\n+                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n \n-            for (int i \u003d 0; i \u003c aExpected.length; i++) {\n-                final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n+            for (int i \u003d 0; i \u003c expected.length; i++) {\n+                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                 final String actual \u003d lnr.readLine();\n-                assertEquals(\"error message \" + i, expected, actual);\n+                assertEquals(\"error message \" + i, expectedResult, actual);\n+\n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 final int lineNumber \u003d Integer.parseInt(parseInt);\n-                Integer integer \u003d 0;\n-                if (Arrays.asList(aWarnsExpected).contains(lineNumber)) {\n-                    integer \u003d lineNumber;\n-                }\n-                assertEquals(\"error message \" + i, (long) integer, lineNumber);\n+                assertNotNull(\"expected input file to have warning comment on line number \"\n+                        + lineNumber, theWarnings.remove((Integer) lineNumber));\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n-                    aExpected.length, errs);\n+                    expected.length, errs);\n+            assertTrue(\"unexpected warnings \" + theWarnings, theWarnings.size() \u003d\u003d 0);\n         }\n-        aC.destroy();\n+\n+        checker.destroy();\n     }\n\\ No newline at end of file\n",
          "actualSource": "    protected void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n        throws Exception {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n        try (final LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertNotNull(\"expected input file to have warning comment on line number \"\n                        + lineNumber, theWarnings.remove((Integer) lineNumber));\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertTrue(\"unexpected warnings \" + theWarnings, theWarnings.size() \u003d\u003d 0);\n        }\n\n        checker.destroy();\n    }",
          "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Issue #2589: Unify IT test code.",
          "commitDate": "12/11/15 7:08 PM",
          "commitName": "7a4ec11d123dc0bbf7db943af715d19814d2e332",
          "commitAuthor": "rnveach",
          "commitDateOld": "25/10/15 11:30 AM",
          "commitNameOld": "344ea5c012d1814441b5758013a2b035c6e1613a",
          "commitAuthorOld": "rnveach",
          "daysBetweenCommits": 18.36,
          "commitsBetweenForRepo": 137,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,39 @@\n-    void verify(Checker aC,\n-            File[] aProcessedFiles,\n-            String aMessageFileName,\n-            String[] aExpected,\n-            Integer... aWarnsExpected)\n+    protected void verify(Checker checker,\n+            File[] processedFiles,\n+            String messageFileName,\n+            String[] expected,\n+            Integer... warnsExpected)\n         throws Exception {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n-        Collections.addAll(theFiles, aProcessedFiles);\n-        final int errs \u003d aC.process(theFiles);\n+        Collections.addAll(theFiles, processedFiles);\n+        final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n+        Collections.addAll(theWarnings, warnsExpected);\n+        final int errs \u003d checker.process(theFiles);\n \n         // process each of the lines\n-        final ByteArrayInputStream localStream \u003d\n-            new ByteArrayInputStream(stream.toByteArray());\n+        final ByteArrayInputStream inputStream \u003d\n+                new ByteArrayInputStream(stream.toByteArray());\n         try (final LineNumberReader lnr \u003d new LineNumberReader(\n-                new InputStreamReader(localStream, StandardCharsets.UTF_8))) {\n+                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n \n-            for (int i \u003d 0; i \u003c aExpected.length; i++) {\n-                final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n+            for (int i \u003d 0; i \u003c expected.length; i++) {\n+                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                 final String actual \u003d lnr.readLine();\n-                assertEquals(\"error message \" + i, expected, actual);\n+                assertEquals(\"error message \" + i, expectedResult, actual);\n+\n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 final int lineNumber \u003d Integer.parseInt(parseInt);\n-                Integer integer \u003d 0;\n-                if (Arrays.asList(aWarnsExpected).contains(lineNumber)) {\n-                    integer \u003d lineNumber;\n-                }\n-                assertEquals(\"error message \" + i, (long) integer, lineNumber);\n+                assertNotNull(\"expected input file to have warning comment on line number \"\n+                        + lineNumber, theWarnings.remove((Integer) lineNumber));\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n-                    aExpected.length, errs);\n+                    expected.length, errs);\n+            assertTrue(\"unexpected warnings \" + theWarnings, theWarnings.size() \u003d\u003d 0);\n         }\n-        aC.destroy();\n+\n+        checker.destroy();\n     }\n\\ No newline at end of file\n",
          "actualSource": "    protected void verify(Checker checker,\n            File[] processedFiles,\n            String messageFileName,\n            String[] expected,\n            Integer... warnsExpected)\n        throws Exception {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, processedFiles);\n        final List\u003cInteger\u003e theWarnings \u003d Lists.newArrayList();\n        Collections.addAll(theWarnings, warnsExpected);\n        final int errs \u003d checker.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream inputStream \u003d\n                new ByteArrayInputStream(stream.toByteArray());\n        try (final LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(inputStream, StandardCharsets.UTF_8))) {\n\n            for (int i \u003d 0; i \u003c expected.length; i++) {\n                final String expectedResult \u003d messageFileName + \":\" + expected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expectedResult, actual);\n\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                assertNotNull(\"expected input file to have warning comment on line number \"\n                        + lineNumber, theWarnings.remove((Integer) lineNumber));\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    expected.length, errs);\n            assertTrue(\"unexpected warnings \" + theWarnings, theWarnings.size() \u003d\u003d 0);\n        }\n\n        checker.destroy();\n    }",
          "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
          "extendedDetails": {}
        }
      ]
    },
    "344ea5c012d1814441b5758013a2b035c6e1613a": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2421: enabling checking on it folder",
      "commitDate": "25/10/15 11:30 AM",
      "commitName": "344ea5c012d1814441b5758013a2b035c6e1613a",
      "commitAuthor": "rnveach",
      "commitDateOld": "25/10/15 7:21 AM",
      "commitNameOld": "a2ae6fa3a82abc0562772af74de80bee2f927cd8",
      "commitAuthorOld": "rnveach",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n     void verify(Checker aC,\n             File[] aProcessedFiles,\n             String aMessageFileName,\n             String[] aExpected,\n             Integer... aWarnsExpected)\n         throws Exception {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream localStream \u003d\n             new ByteArrayInputStream(stream.toByteArray());\n         try (final LineNumberReader lnr \u003d new LineNumberReader(\n                 new InputStreamReader(localStream, StandardCharsets.UTF_8))) {\n \n             for (int i \u003d 0; i \u003c aExpected.length; i++) {\n                 final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n-                String actual \u003d lnr.readLine();\n+                final String actual \u003d lnr.readLine();\n                 assertEquals(\"error message \" + i, expected, actual);\n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n-                int lineNumber \u003d Integer.parseInt(parseInt);\n+                final int lineNumber \u003d Integer.parseInt(parseInt);\n                 Integer integer \u003d 0;\n                 if (Arrays.asList(aWarnsExpected).contains(lineNumber)) {\n                     integer \u003d lineNumber;\n                 }\n                 assertEquals(\"error message \" + i, (long) integer, lineNumber);\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     aExpected.length, errs);\n         }\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void verify(Checker aC,\n            File[] aProcessedFiles,\n            String aMessageFileName,\n            String[] aExpected,\n            Integer... aWarnsExpected)\n        throws Exception {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream localStream \u003d\n            new ByteArrayInputStream(stream.toByteArray());\n        try (final LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(localStream, StandardCharsets.UTF_8))) {\n\n            for (int i \u003d 0; i \u003c aExpected.length; i++) {\n                final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n                final String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expected, actual);\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                final int lineNumber \u003d Integer.parseInt(parseInt);\n                Integer integer \u003d 0;\n                if (Arrays.asList(aWarnsExpected).contains(lineNumber)) {\n                    integer \u003d lineNumber;\n                }\n                assertEquals(\"error message \" + i, (long) integer, lineNumber);\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    aExpected.length, errs);\n        }\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "f7e41edb947dad22e10eeaa2e68e6f44b4bfa747": {
      "type": "Ybodychange",
      "commitMessage": "Issue #2080: Replace ternary condition operator with if\n\nFixes `ConditionalExpression` inspection violations.\n\nDescription:\n\u003eReports the ternary condition operator. Some coding standards prohibit the use of the condition operator, in favor of if-else statements.\n",
      "commitDate": "03/09/15 6:07 PM",
      "commitName": "f7e41edb947dad22e10eeaa2e68e6f44b4bfa747",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "31/08/15 9:08 PM",
      "commitNameOld": "4587090b83b6d83881b96faf4c87387c3d208f00",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.87,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,38 @@\n     void verify(Checker aC,\n             File[] aProcessedFiles,\n             String aMessageFileName,\n             String[] aExpected,\n             Integer... aWarnsExpected)\n         throws Exception\n     {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream localStream \u003d\n             new ByteArrayInputStream(stream.toByteArray());\n         try (final LineNumberReader lnr \u003d new LineNumberReader(\n                 new InputStreamReader(localStream, StandardCharsets.UTF_8))) {\n \n             for (int i \u003d 0; i \u003c aExpected.length; i++) {\n                 final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n                 String actual \u003d lnr.readLine();\n                 assertEquals(\"error message \" + i, expected, actual);\n                 String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                 parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                 parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                 int lineNumber \u003d Integer.parseInt(parseInt);\n-                Integer integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n+                Integer integer \u003d 0;\n+                if (Arrays.asList(aWarnsExpected).contains(lineNumber)) {\n+                    integer \u003d lineNumber;\n+                }\n                 assertEquals(\"error message \" + i, (long) integer, lineNumber);\n             }\n \n             assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     aExpected.length, errs);\n         }\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void verify(Checker aC,\n            File[] aProcessedFiles,\n            String aMessageFileName,\n            String[] aExpected,\n            Integer... aWarnsExpected)\n        throws Exception\n    {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream localStream \u003d\n            new ByteArrayInputStream(stream.toByteArray());\n        try (final LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(localStream, StandardCharsets.UTF_8))) {\n\n            for (int i \u003d 0; i \u003c aExpected.length; i++) {\n                final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n                String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expected, actual);\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                int lineNumber \u003d Integer.parseInt(parseInt);\n                Integer integer \u003d 0;\n                if (Arrays.asList(aWarnsExpected).contains(lineNumber)) {\n                    integer \u003d lineNumber;\n                }\n                assertEquals(\"error message \" + i, (long) integer, lineNumber);\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    aExpected.length, errs);\n        }\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "f5e4d9b42a3ebda0adc7f7616f1b00c189f20733": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1555: Use try-with-resources to close streams in test code\n\nThe issue was stream not being closed at all or closed, but not in finally block.\n\nFixes some `IOResource` inspection violations.\n\nDescription:\n\u003eReports any I/O resource which is not safely closed in a finally block. Such resources may be inadvertently leaked if an exception is thrown before the resource is closed. I/O resources checked by this inspection include java.io.InputStream, java.io.OutputStream, java.io.Reader, java.io.Writer and java.io.RandomAccessFile. I/O resources which are wrapped by other I/O resources are not reported, as the wrapped resource will be closed by the wrapping resource.\n",
      "commitDate": "30/08/15 1:21 AM",
      "commitName": "f5e4d9b42a3ebda0adc7f7616f1b00c189f20733",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "29/08/15 10:38 PM",
      "commitNameOld": "7b8a3aa5bba1323a7bbb85b6dbd86835215a48fc",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,35 @@\n     void verify(Checker aC,\n             File[] aProcessedFiles,\n             String aMessageFileName,\n             String[] aExpected,\n             Integer... aWarnsExpected)\n         throws Exception\n     {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream localStream \u003d\n             new ByteArrayInputStream(stream.toByteArray());\n-        final LineNumberReader lnr \u003d\n-            new LineNumberReader(new InputStreamReader(localStream, StandardCharsets.UTF_8));\n+        try (final LineNumberReader lnr \u003d new LineNumberReader(\n+                new InputStreamReader(localStream, StandardCharsets.UTF_8))) {\n \n-        for (int i \u003d 0; i \u003c aExpected.length; i++) {\n-            final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n-            String actual \u003d lnr.readLine();\n-            assertEquals(\"error message \" + i, expected, actual);\n-            String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n-            parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n-            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n-            int lineNumber \u003d Integer.parseInt(parseInt);\n-\t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n-            assertEquals(\"error message \" + i, (long) integer, lineNumber);\n+            for (int i \u003d 0; i \u003c aExpected.length; i++) {\n+                final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n+                String actual \u003d lnr.readLine();\n+                assertEquals(\"error message \" + i, expected, actual);\n+                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n+                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n+                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n+                int lineNumber \u003d Integer.parseInt(parseInt);\n+                Integer integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n+                assertEquals(\"error message \" + i, (long) integer, lineNumber);\n+            }\n+\n+            assertEquals(\"unexpected output: \" + lnr.readLine(),\n+                    aExpected.length, errs);\n         }\n-\n-        assertEquals(\"unexpected output: \" + lnr.readLine(),\n-                     aExpected.length, errs);\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void verify(Checker aC,\n            File[] aProcessedFiles,\n            String aMessageFileName,\n            String[] aExpected,\n            Integer... aWarnsExpected)\n        throws Exception\n    {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream localStream \u003d\n            new ByteArrayInputStream(stream.toByteArray());\n        try (final LineNumberReader lnr \u003d new LineNumberReader(\n                new InputStreamReader(localStream, StandardCharsets.UTF_8))) {\n\n            for (int i \u003d 0; i \u003c aExpected.length; i++) {\n                final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n                String actual \u003d lnr.readLine();\n                assertEquals(\"error message \" + i, expected, actual);\n                String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n                parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n                parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n                int lineNumber \u003d Integer.parseInt(parseInt);\n                Integer integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n                assertEquals(\"error message \" + i, (long) integer, lineNumber);\n            }\n\n            assertEquals(\"unexpected output: \" + lnr.readLine(),\n                    aExpected.length, errs);\n        }\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "7b8a3aa5bba1323a7bbb85b6dbd86835215a48fc": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1555: Fix various typos\n\nFixes `SpellCheckingInspection` inspection violation.\n\nDescription:\n\u003eSpellchecker inspection helps locate typos and misspelling in your code, comments and literals\n",
      "commitDate": "29/08/15 10:38 PM",
      "commitName": "7b8a3aa5bba1323a7bbb85b6dbd86835215a48fc",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "29/08/15 6:13 AM",
      "commitNameOld": "3d9f726c2d5fcc152fbfbcdeaade390b36b5fba0",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.68,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n     void verify(Checker aC,\n             File[] aProcessedFiles,\n             String aMessageFileName,\n             String[] aExpected,\n             Integer... aWarnsExpected)\n         throws Exception\n     {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n-        final ByteArrayInputStream bais \u003d\n+        final ByteArrayInputStream localStream \u003d\n             new ByteArrayInputStream(stream.toByteArray());\n         final LineNumberReader lnr \u003d\n-            new LineNumberReader(new InputStreamReader(bais, StandardCharsets.UTF_8));\n+            new LineNumberReader(new InputStreamReader(localStream, StandardCharsets.UTF_8));\n \n         for (int i \u003d 0; i \u003c aExpected.length; i++) {\n             final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n             String actual \u003d lnr.readLine();\n             assertEquals(\"error message \" + i, expected, actual);\n             String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n             parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n             parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n             int lineNumber \u003d Integer.parseInt(parseInt);\n \t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n             assertEquals(\"error message \" + i, (long) integer, lineNumber);\n         }\n \n         assertEquals(\"unexpected output: \" + lnr.readLine(),\n                      aExpected.length, errs);\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void verify(Checker aC,\n            File[] aProcessedFiles,\n            String aMessageFileName,\n            String[] aExpected,\n            Integer... aWarnsExpected)\n        throws Exception\n    {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream localStream \u003d\n            new ByteArrayInputStream(stream.toByteArray());\n        final LineNumberReader lnr \u003d\n            new LineNumberReader(new InputStreamReader(localStream, StandardCharsets.UTF_8));\n\n        for (int i \u003d 0; i \u003c aExpected.length; i++) {\n            final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n            String actual \u003d lnr.readLine();\n            assertEquals(\"error message \" + i, expected, actual);\n            String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n            parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n            int lineNumber \u003d Integer.parseInt(parseInt);\n\t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n            assertEquals(\"error message \" + i, (long) integer, lineNumber);\n        }\n\n        assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     aExpected.length, errs);\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "9cc86b38df9a086713d1fcdf01b451b41c0d6f65": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1555: Specify encoding explicitly\n\nFixes `ImplicitDefaultCharsetUsage` inspection violations.\n\nDescription:\n\u003eReports method and constructor calls which implicitly use the platform\u0027s default charset. These can produce different results on (e.g. foreign language) systems that use a different default charset, resulting in unexpected behaviour.\n",
      "commitDate": "28/08/15 10:48 PM",
      "commitName": "9cc86b38df9a086713d1fcdf01b451b41c0d6f65",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "28/08/15 10:37 PM",
      "commitNameOld": "94f9754acb5cc92a32bf36d2a789325fed384325",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n     void verify(Checker aC,\n             File[] aProcessedFiles,\n             String aMessageFileName,\n             String[] aExpected,\n             Integer... aWarnsExpected)\n         throws Exception\n     {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream bais \u003d\n-            new ByteArrayInputStream(baos.toByteArray());\n+            new ByteArrayInputStream(stream.toByteArray());\n         final LineNumberReader lnr \u003d\n             new LineNumberReader(new InputStreamReader(bais, StandardCharsets.UTF_8));\n \n         for (int i \u003d 0; i \u003c aExpected.length; i++) {\n             final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n             String actual \u003d lnr.readLine();\n             assertEquals(\"error message \" + i, expected, actual);\n             String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n             parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n             parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n             int lineNumber \u003d Integer.parseInt(parseInt);\n \t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n             assertEquals(\"error message \" + i, (long) integer, lineNumber);\n         }\n \n         assertEquals(\"unexpected output: \" + lnr.readLine(),\n                      aExpected.length, errs);\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void verify(Checker aC,\n            File[] aProcessedFiles,\n            String aMessageFileName,\n            String[] aExpected,\n            Integer... aWarnsExpected)\n        throws Exception\n    {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream bais \u003d\n            new ByteArrayInputStream(stream.toByteArray());\n        final LineNumberReader lnr \u003d\n            new LineNumberReader(new InputStreamReader(bais, StandardCharsets.UTF_8));\n\n        for (int i \u003d 0; i \u003c aExpected.length; i++) {\n            final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n            String actual \u003d lnr.readLine();\n            assertEquals(\"error message \" + i, expected, actual);\n            String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n            parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n            int lineNumber \u003d Integer.parseInt(parseInt);\n\t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n            assertEquals(\"error message \" + i, (long) integer, lineNumber);\n        }\n\n        assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     aExpected.length, errs);\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "8142c804e90f6d24a3a5db736f3f1f576766a9a5": {
      "type": "Ymodifierchange",
      "commitMessage": "Decrease visibility of fields and methods where applicable. #1555\n\nFixes some `WeakerAccess` inspection violations.\n\nDescription:\n\u003eThis inspection reports all fields, methods or classes, found in the specified inspection scope, that may have their access modifier narrowed down.\n",
      "commitDate": "27/08/15 12:52 PM",
      "commitName": "8142c804e90f6d24a3a5db736f3f1f576766a9a5",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "25/08/15 3:28 AM",
      "commitNameOld": "a992ca414f212fa4cdc52d8c510e6cfae27cc67c",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.39,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n-    protected void verify(Checker aC,\n-                          File[] aProcessedFiles,\n-                          String aMessageFileName,\n-                          String[] aExpected,\n-                          Integer... aWarnsExpected)\n+    void verify(Checker aC,\n+            File[] aProcessedFiles,\n+            String aMessageFileName,\n+            String[] aExpected,\n+            Integer... aWarnsExpected)\n         throws Exception\n     {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream bais \u003d\n             new ByteArrayInputStream(baos.toByteArray());\n         final LineNumberReader lnr \u003d\n             new LineNumberReader(new InputStreamReader(bais, StandardCharsets.UTF_8));\n \n         for (int i \u003d 0; i \u003c aExpected.length; i++) {\n             final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n             String actual \u003d lnr.readLine();\n             assertEquals(\"error message \" + i, expected, actual);\n             String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n             parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n             parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n             int lineNumber \u003d Integer.parseInt(parseInt);\n \t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n             assertEquals(\"error message \" + i, (long) integer, lineNumber);\n         }\n \n         assertEquals(\"unexpected output: \" + lnr.readLine(),\n                      aExpected.length, errs);\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void verify(Checker aC,\n            File[] aProcessedFiles,\n            String aMessageFileName,\n            String[] aExpected,\n            Integer... aWarnsExpected)\n        throws Exception\n    {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream bais \u003d\n            new ByteArrayInputStream(baos.toByteArray());\n        final LineNumberReader lnr \u003d\n            new LineNumberReader(new InputStreamReader(bais, StandardCharsets.UTF_8));\n\n        for (int i \u003d 0; i \u003c aExpected.length; i++) {\n            final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n            String actual \u003d lnr.readLine();\n            assertEquals(\"error message \" + i, expected, actual);\n            String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n            parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n            int lineNumber \u003d Integer.parseInt(parseInt);\n\t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n            assertEquals(\"error message \" + i, (long) integer, lineNumber);\n        }\n\n        assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     aExpected.length, errs);\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {
        "oldValue": "[protected]",
        "newValue": "[]"
      }
    },
    "a992ca414f212fa4cdc52d8c510e6cfae27cc67c": {
      "type": "Ybodychange",
      "commitMessage": "Specify charset used in test code. #1555\n\nFixes `ImplicitDefaultCharsetUsage` inspection violations.\n\nDescription:\n\u003eReports method and constructor calls which implicitly use the platform\u0027s default charset. These can produce different results on (e.g. foreign language) systems that use a different default charset, resulting in unexpected behaviour.\n",
      "commitDate": "25/08/15 3:28 AM",
      "commitName": "a992ca414f212fa4cdc52d8c510e6cfae27cc67c",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "22/08/15 4:36 AM",
      "commitNameOld": "d5129db907a1a405a49bcabeb275ed2e25cb26db",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 2.95,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n     protected void verify(Checker aC,\n                           File[] aProcessedFiles,\n                           String aMessageFileName,\n                           String[] aExpected,\n                           Integer... aWarnsExpected)\n         throws Exception\n     {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream bais \u003d\n             new ByteArrayInputStream(baos.toByteArray());\n         final LineNumberReader lnr \u003d\n-            new LineNumberReader(new InputStreamReader(bais));\n+            new LineNumberReader(new InputStreamReader(bais, StandardCharsets.UTF_8));\n \n         for (int i \u003d 0; i \u003c aExpected.length; i++) {\n             final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n             String actual \u003d lnr.readLine();\n             assertEquals(\"error message \" + i, expected, actual);\n             String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n             parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n             parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n             int lineNumber \u003d Integer.parseInt(parseInt);\n \t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n             assertEquals(\"error message \" + i, (long) integer, lineNumber);\n         }\n \n         assertEquals(\"unexpected output: \" + lnr.readLine(),\n                      aExpected.length, errs);\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void verify(Checker aC,\n                          File[] aProcessedFiles,\n                          String aMessageFileName,\n                          String[] aExpected,\n                          Integer... aWarnsExpected)\n        throws Exception\n    {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream bais \u003d\n            new ByteArrayInputStream(baos.toByteArray());\n        final LineNumberReader lnr \u003d\n            new LineNumberReader(new InputStreamReader(bais, StandardCharsets.UTF_8));\n\n        for (int i \u003d 0; i \u003c aExpected.length; i++) {\n            final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n            String actual \u003d lnr.readLine();\n            assertEquals(\"error message \" + i, expected, actual);\n            String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n            parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n            int lineNumber \u003d Integer.parseInt(parseInt);\n\t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n            assertEquals(\"error message \" + i, (long) integer, lineNumber);\n        }\n\n        assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     aExpected.length, errs);\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "5f46a3b3faad9d8eedc3b0924c44d0352be3a219": {
      "type": "Yparameterchange",
      "commitMessage": "Use varargs. #1555\n\nFixes `MethodCanBeVariableArityMethod` inspection violations in test code.\n\nDescription:\n\u003eReports methods with which can be converted to be a variable arity/varargs method, available in Java 5 and newer.\nThis inspection only reports if the project or module is configured to use a language level of 5.0 or higher.\n",
      "commitDate": "20/08/15 1:41 PM",
      "commitName": "5f46a3b3faad9d8eedc3b0924c44d0352be3a219",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "19/08/15 8:24 PM",
      "commitNameOld": "4f6d7e415dc3253c5bde537f2a8d262de9b6aba2",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.72,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n     protected void verify(Checker aC,\n                           File[] aProcessedFiles,\n                           String aMessageFileName,\n                           String[] aExpected,\n-                          Integer[] aWarnsExpected)\n+                          Integer... aWarnsExpected)\n         throws Exception\n     {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream bais \u003d\n             new ByteArrayInputStream(baos.toByteArray());\n         final LineNumberReader lnr \u003d\n             new LineNumberReader(new InputStreamReader(bais));\n \n         for (int i \u003d 0; i \u003c aExpected.length; i++) {\n             final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n             String actual \u003d lnr.readLine();\n             assertEquals(\"error message \" + i, expected, actual);\n             String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n             parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n             parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n             int lineNumber \u003d Integer.parseInt(parseInt);\n \t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n             assertEquals(\"error message \" + i, (long) integer, lineNumber);\n         }\n \n         assertEquals(\"unexpected output: \" + lnr.readLine(),\n                      aExpected.length, errs);\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void verify(Checker aC,\n                          File[] aProcessedFiles,\n                          String aMessageFileName,\n                          String[] aExpected,\n                          Integer... aWarnsExpected)\n        throws Exception\n    {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream bais \u003d\n            new ByteArrayInputStream(baos.toByteArray());\n        final LineNumberReader lnr \u003d\n            new LineNumberReader(new InputStreamReader(bais));\n\n        for (int i \u003d 0; i \u003c aExpected.length; i++) {\n            final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n            String actual \u003d lnr.readLine();\n            assertEquals(\"error message \" + i, expected, actual);\n            String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n            parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n            int lineNumber \u003d Integer.parseInt(parseInt);\n\t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n            assertEquals(\"error message \" + i, (long) integer, lineNumber);\n        }\n\n        assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     aExpected.length, errs);\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {
        "oldValue": "[aC-Checker, aProcessedFiles-File[], aMessageFileName-String, aExpected-String[], aWarnsExpected-Integer[]]",
        "newValue": "[aC-Checker, aProcessedFiles-File[], aMessageFileName-String, aExpected-String[], aWarnsExpected-Integer]"
      }
    },
    "4f6d7e415dc3253c5bde537f2a8d262de9b6aba2": {
      "type": "Ybodychange",
      "commitMessage": "Use character literals in String.indexOf(). #1555\n\nFixes `LengthOneStringInIndexOf` inspection violations in test code.\n\nDescription:\n\u003eReports String literals of length one being used as a parameter in String.indexOf() or String.lastIndexOf() calls. These String literals may be replaced by equivalent character literals, gaining some performance enhancement.\n",
      "commitDate": "19/08/15 8:24 PM",
      "commitName": "4f6d7e415dc3253c5bde537f2a8d262de9b6aba2",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "18/08/15 8:31 PM",
      "commitNameOld": "bc0bf95daedb6f0e658187d6e44410a60f46dbe2",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 1.0,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 0,
      "diff": "@@ -1,34 +1,34 @@\n     protected void verify(Checker aC,\n                           File[] aProcessedFiles,\n                           String aMessageFileName,\n                           String[] aExpected,\n                           Integer[] aWarnsExpected)\n         throws Exception\n     {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream bais \u003d\n             new ByteArrayInputStream(baos.toByteArray());\n         final LineNumberReader lnr \u003d\n             new LineNumberReader(new InputStreamReader(bais));\n \n         for (int i \u003d 0; i \u003c aExpected.length; i++) {\n             final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n             String actual \u003d lnr.readLine();\n             assertEquals(\"error message \" + i, expected, actual);\n             String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n-            parseInt \u003d parseInt.substring(parseInt.indexOf(\":\") + 1);\n-            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\":\"));\n+            parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n+            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n             int lineNumber \u003d Integer.parseInt(parseInt);\n \t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n             assertEquals(\"error message \" + i, (long) integer, lineNumber);\n         }\n \n         assertEquals(\"unexpected output: \" + lnr.readLine(),\n                      aExpected.length, errs);\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void verify(Checker aC,\n                          File[] aProcessedFiles,\n                          String aMessageFileName,\n                          String[] aExpected,\n                          Integer[] aWarnsExpected)\n        throws Exception\n    {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream bais \u003d\n            new ByteArrayInputStream(baos.toByteArray());\n        final LineNumberReader lnr \u003d\n            new LineNumberReader(new InputStreamReader(bais));\n\n        for (int i \u003d 0; i \u003c aExpected.length; i++) {\n            final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n            String actual \u003d lnr.readLine();\n            assertEquals(\"error message \" + i, expected, actual);\n            String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n            parseInt \u003d parseInt.substring(parseInt.indexOf(\u0027:\u0027) + 1);\n            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\u0027:\u0027));\n            int lineNumber \u003d Integer.parseInt(parseInt);\n\t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n            assertEquals(\"error message \" + i, (long) integer, lineNumber);\n        }\n\n        assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     aExpected.length, errs);\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "bc0bf95daedb6f0e658187d6e44410a60f46dbe2": {
      "type": "Ybodychange",
      "commitMessage": "Fix non-static non-final all upper-case names in test code. #1555\n\nFixes `UpperCaseFieldNameNotConstant` inspection violations in test code.\n\nDescription:\n\u003eReports non-static non-final fields whose names are all upper-case. Such fields may cause confusion by breaking a common naming convention, and are often the result of developer error.\n",
      "commitDate": "18/08/15 8:31 PM",
      "commitName": "bc0bf95daedb6f0e658187d6e44410a60f46dbe2",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "18/08/15 8:30 PM",
      "commitNameOld": "067896807847df81ba6e65195e4f39069dc3aea7",
      "commitAuthorOld": "Michal Kordas",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 0,
      "commitsBetweenForFile": 0,
      "diff": "@@ -1,34 +1,34 @@\n     protected void verify(Checker aC,\n                           File[] aProcessedFiles,\n                           String aMessageFileName,\n                           String[] aExpected,\n                           Integer[] aWarnsExpected)\n         throws Exception\n     {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream bais \u003d\n-            new ByteArrayInputStream(BAOS.toByteArray());\n+            new ByteArrayInputStream(baos.toByteArray());\n         final LineNumberReader lnr \u003d\n             new LineNumberReader(new InputStreamReader(bais));\n \n         for (int i \u003d 0; i \u003c aExpected.length; i++) {\n             final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n             String actual \u003d lnr.readLine();\n             assertEquals(\"error message \" + i, expected, actual);\n             String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n             parseInt \u003d parseInt.substring(parseInt.indexOf(\":\") + 1);\n             parseInt \u003d parseInt.substring(0, parseInt.indexOf(\":\"));\n             int lineNumber \u003d Integer.parseInt(parseInt);\n \t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n             assertEquals(\"error message \" + i, (long) integer, lineNumber);\n         }\n \n         assertEquals(\"unexpected output: \" + lnr.readLine(),\n                      aExpected.length, errs);\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void verify(Checker aC,\n                          File[] aProcessedFiles,\n                          String aMessageFileName,\n                          String[] aExpected,\n                          Integer[] aWarnsExpected)\n        throws Exception\n    {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream bais \u003d\n            new ByteArrayInputStream(baos.toByteArray());\n        final LineNumberReader lnr \u003d\n            new LineNumberReader(new InputStreamReader(bais));\n\n        for (int i \u003d 0; i \u003c aExpected.length; i++) {\n            final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n            String actual \u003d lnr.readLine();\n            assertEquals(\"error message \" + i, expected, actual);\n            String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n            parseInt \u003d parseInt.substring(parseInt.indexOf(\":\") + 1);\n            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\":\"));\n            int lineNumber \u003d Integer.parseInt(parseInt);\n\t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n            assertEquals(\"error message \" + i, (long) integer, lineNumber);\n        }\n\n        assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     aExpected.length, errs);\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "88edaa84fdcd29fe5cce6c3497cb326244b14197": {
      "type": "Ybodychange",
      "commitMessage": "Remove unnecessary explicit numeric cast. #1555\n\nFixes `UnnecessaryExplicitNumericCast` inspection violations in test code.\n\nDescription:\n\u003eReports any primitive numeric casts which would otherwise be inserted implicitly by the compiler.\n",
      "commitDate": "18/08/15 8:29 PM",
      "commitName": "88edaa84fdcd29fe5cce6c3497cb326244b14197",
      "commitAuthor": "Michal Kordas",
      "commitDateOld": "18/08/15 1:25 AM",
      "commitNameOld": "54ccca18635a4aeea90da86d30590df498f76b08",
      "commitAuthorOld": "Baratali Izmailov",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 0,
      "commitsBetweenForFile": 0,
      "diff": "@@ -1,34 +1,34 @@\n     protected void verify(Checker aC,\n                           File[] aProcessedFiles,\n                           String aMessageFileName,\n                           String[] aExpected,\n                           Integer[] aWarnsExpected)\n         throws Exception\n     {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream bais \u003d\n             new ByteArrayInputStream(BAOS.toByteArray());\n         final LineNumberReader lnr \u003d\n             new LineNumberReader(new InputStreamReader(bais));\n \n         for (int i \u003d 0; i \u003c aExpected.length; i++) {\n             final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n             String actual \u003d lnr.readLine();\n             assertEquals(\"error message \" + i, expected, actual);\n             String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n             parseInt \u003d parseInt.substring(parseInt.indexOf(\":\") + 1);\n             parseInt \u003d parseInt.substring(0, parseInt.indexOf(\":\"));\n             int lineNumber \u003d Integer.parseInt(parseInt);\n \t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n-            assertEquals(\"error message \" + i, (long) integer, (long) lineNumber);\n+            assertEquals(\"error message \" + i, (long) integer, lineNumber);\n         }\n \n         assertEquals(\"unexpected output: \" + lnr.readLine(),\n                      aExpected.length, errs);\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void verify(Checker aC,\n                          File[] aProcessedFiles,\n                          String aMessageFileName,\n                          String[] aExpected,\n                          Integer[] aWarnsExpected)\n        throws Exception\n    {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream bais \u003d\n            new ByteArrayInputStream(BAOS.toByteArray());\n        final LineNumberReader lnr \u003d\n            new LineNumberReader(new InputStreamReader(bais));\n\n        for (int i \u003d 0; i \u003c aExpected.length; i++) {\n            final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n            String actual \u003d lnr.readLine();\n            assertEquals(\"error message \" + i, expected, actual);\n            String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n            parseInt \u003d parseInt.substring(parseInt.indexOf(\":\") + 1);\n            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\":\"));\n            int lineNumber \u003d Integer.parseInt(parseInt);\n\t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n            assertEquals(\"error message \" + i, (long) integer, lineNumber);\n        }\n\n        assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     aExpected.length, errs);\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "943ace0dd67911db776be674e66a873df1442db0": {
      "type": "Ybodychange",
      "commitMessage": "Issue #1388: BaseCheckTestSupport.verify fails on Windows\n",
      "commitDate": "16/07/15 11:33 PM",
      "commitName": "943ace0dd67911db776be674e66a873df1442db0",
      "commitAuthor": "WonderCsabo",
      "commitDateOld": "11/07/15 6:33 AM",
      "commitNameOld": "52ac2776d7f128ff812b73b54dcc12210661f98b",
      "commitAuthorOld": "Vladislav Lisetskiy",
      "daysBetweenCommits": 5.71,
      "commitsBetweenForRepo": 0,
      "commitsBetweenForFile": 0,
      "diff": "@@ -1,33 +1,34 @@\n     protected void verify(Checker aC,\n                           File[] aProcessedFiles,\n                           String aMessageFileName,\n                           String[] aExpected,\n                           Integer[] aWarnsExpected)\n         throws Exception\n     {\n         stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream bais \u003d\n             new ByteArrayInputStream(BAOS.toByteArray());\n         final LineNumberReader lnr \u003d\n             new LineNumberReader(new InputStreamReader(bais));\n        \n         for (int i \u003d 0; i \u003c aExpected.length; i++) {\n             final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n             String actual \u003d lnr.readLine();\n             assertEquals(\"error message \" + i, expected, actual);\n-            String parseInt \u003d actual.substring(actual.indexOf(\":\") + 1);\n+            String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n+            parseInt \u003d parseInt.substring(parseInt.indexOf(\":\") + 1);\n             parseInt \u003d parseInt.substring(0, parseInt.indexOf(\":\"));\n             int lineNumber \u003d Integer.parseInt(parseInt);\n \t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n             assertEquals(\"error message \" + i, (long) integer, (long) lineNumber);\n         }\n \n         assertEquals(\"unexpected output: \" + lnr.readLine(),\n                      aExpected.length, errs);\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void verify(Checker aC,\n                          File[] aProcessedFiles,\n                          String aMessageFileName,\n                          String[] aExpected,\n                          Integer[] aWarnsExpected)\n        throws Exception\n    {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream bais \u003d\n            new ByteArrayInputStream(BAOS.toByteArray());\n        final LineNumberReader lnr \u003d\n            new LineNumberReader(new InputStreamReader(bais));\n       \n        for (int i \u003d 0; i \u003c aExpected.length; i++) {\n            final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n            String actual \u003d lnr.readLine();\n            assertEquals(\"error message \" + i, expected, actual);\n            String parseInt \u003d removeDeviceFromPathOnWindows(actual);\n            parseInt \u003d parseInt.substring(parseInt.indexOf(\":\") + 1);\n            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\":\"));\n            int lineNumber \u003d Integer.parseInt(parseInt);\n\t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n            assertEquals(\"error message \" + i, (long) integer, (long) lineNumber);\n        }\n\n        assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     aExpected.length, errs);\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    },
    "52ac2776d7f128ff812b73b54dcc12210661f98b": {
      "type": "Ybodychange",
      "commitMessage": "rename fields in ConfigurationBuilder and BaseCheckTestSupport",
      "commitDate": "11/07/15 6:33 AM",
      "commitName": "52ac2776d7f128ff812b73b54dcc12210661f98b",
      "commitAuthor": "Vladislav Lisetskiy",
      "commitDateOld": "07/06/15 7:37 PM",
      "commitNameOld": "437986510709d7abc64b59c72779343ac5e77599",
      "commitAuthorOld": "Roman Ivanov",
      "daysBetweenCommits": 33.46,
      "commitsBetweenForRepo": 0,
      "commitsBetweenForFile": 0,
      "diff": "@@ -1,33 +1,33 @@\n     protected void verify(Checker aC,\n                           File[] aProcessedFiles,\n                           String aMessageFileName,\n                           String[] aExpected,\n                           Integer[] aWarnsExpected)\n         throws Exception\n     {\n-        mStream.flush();\n+        stream.flush();\n         final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n         Collections.addAll(theFiles, aProcessedFiles);\n         final int errs \u003d aC.process(theFiles);\n \n         // process each of the lines\n         final ByteArrayInputStream bais \u003d\n-            new ByteArrayInputStream(mBAOS.toByteArray());\n+            new ByteArrayInputStream(BAOS.toByteArray());\n         final LineNumberReader lnr \u003d\n             new LineNumberReader(new InputStreamReader(bais));\n        \n         for (int i \u003d 0; i \u003c aExpected.length; i++) {\n             final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n             String actual \u003d lnr.readLine();\n             assertEquals(\"error message \" + i, expected, actual);\n             String parseInt \u003d actual.substring(actual.indexOf(\":\") + 1);\n             parseInt \u003d parseInt.substring(0, parseInt.indexOf(\":\"));\n             int lineNumber \u003d Integer.parseInt(parseInt);\n \t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n             assertEquals(\"error message \" + i, (long) integer, (long) lineNumber);\n         }\n \n         assertEquals(\"unexpected output: \" + lnr.readLine(),\n                      aExpected.length, errs);\n         aC.destroy();\n     }\n\\ No newline at end of file\n",
      "actualSource": "    protected void verify(Checker aC,\n                          File[] aProcessedFiles,\n                          String aMessageFileName,\n                          String[] aExpected,\n                          Integer[] aWarnsExpected)\n        throws Exception\n    {\n        stream.flush();\n        final List\u003cFile\u003e theFiles \u003d Lists.newArrayList();\n        Collections.addAll(theFiles, aProcessedFiles);\n        final int errs \u003d aC.process(theFiles);\n\n        // process each of the lines\n        final ByteArrayInputStream bais \u003d\n            new ByteArrayInputStream(BAOS.toByteArray());\n        final LineNumberReader lnr \u003d\n            new LineNumberReader(new InputStreamReader(bais));\n       \n        for (int i \u003d 0; i \u003c aExpected.length; i++) {\n            final String expected \u003d aMessageFileName + \":\" + aExpected[i];\n            String actual \u003d lnr.readLine();\n            assertEquals(\"error message \" + i, expected, actual);\n            String parseInt \u003d actual.substring(actual.indexOf(\":\") + 1);\n            parseInt \u003d parseInt.substring(0, parseInt.indexOf(\":\"));\n            int lineNumber \u003d Integer.parseInt(parseInt);\n\t\t\tInteger integer \u003d Arrays.asList(aWarnsExpected).contains(lineNumber) ? lineNumber : 0;\n            assertEquals(\"error message \" + i, (long) integer, (long) lineNumber);\n        }\n\n        assertEquals(\"unexpected output: \" + lnr.readLine(),\n                     aExpected.length, errs);\n        aC.destroy();\n    }",
      "path": "src/it/java/com/google/checkstyle/test/base/BaseCheckTestSupport.java",
      "extendedDetails": {}
    }
  }
}