{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ImageLoaderCurrent.java",
  "functionName": "processINode",
  "functionId": "processINode___in-DataInputStream__v-ImageVisitor__skipBlocks-boolean__parentName-String__isSnapshotCopy-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/ImageLoaderCurrent.java",
  "functionStartLine": 678,
  "functionEndLine": 770,
  "numCommitsSeen": 35,
  "timeTaken": 3636,
  "changeHistory": [
    "2e43c28e01fe006210e71aab179527669f6412ed",
    "441378e7e4609d89b7181dacc8ba92b253a962df",
    "89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "76e7264e8d6407f527bd877009aca11f7bb63bd7",
    "97f58955a6045b373ab73653bf26ab5922b00cf3"
  ],
  "changeHistoryShort": {
    "2e43c28e01fe006210e71aab179527669f6412ed": "Ybodychange",
    "441378e7e4609d89b7181dacc8ba92b253a962df": "Ybodychange",
    "89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a": "Ybodychange",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "76e7264e8d6407f527bd877009aca11f7bb63bd7": "Ybodychange",
    "97f58955a6045b373ab73653bf26ab5922b00cf3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2e43c28e01fe006210e71aab179527669f6412ed": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11696. Fix warnings from Spotbugs in hadoop-hdfs. Contributed by Yiqun Lin.\n",
      "commitDate": "15/08/17 1:48 AM",
      "commitName": "2e43c28e01fe006210e71aab179527669f6412ed",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "29/06/17 1:54 PM",
      "commitNameOld": "441378e7e4609d89b7181dacc8ba92b253a962df",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 46.5,
      "commitsBetweenForRepo": 302,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,93 @@\n   private void processINode(DataInputStream in, ImageVisitor v,\n       boolean skipBlocks, String parentName, boolean isSnapshotCopy)\n       throws IOException {\n     boolean supportSnapshot \u003d \n         NameNodeLayoutVersion.supports(Feature.SNAPSHOT, imageVersion);\n     boolean supportInodeId \u003d \n         NameNodeLayoutVersion.supports(Feature.ADD_INODE_ID, imageVersion);\n     \n     v.visitEnclosingElement(ImageElement.INODE);\n     final String pathName \u003d readINodePath(in, parentName);\n     v.visit(ImageElement.INODE_PATH, pathName);\n \n     long inodeId \u003d HdfsConstants.GRANDFATHER_INODE_ID;\n     if (supportInodeId) {\n       inodeId \u003d in.readLong();\n       v.visit(ImageElement.INODE_ID, inodeId);\n     }\n     v.visit(ImageElement.REPLICATION, in.readShort());\n     v.visit(ImageElement.MODIFICATION_TIME, formatDate(in.readLong()));\n     if(NameNodeLayoutVersion.supports(Feature.FILE_ACCESS_TIME, imageVersion))\n       v.visit(ImageElement.ACCESS_TIME, formatDate(in.readLong()));\n     v.visit(ImageElement.BLOCK_SIZE, in.readLong());\n     int numBlocks \u003d in.readInt();\n \n     processBlocks(in, v, numBlocks, skipBlocks);\n     \n     if (numBlocks \u003e\u003d 0) { // File\n       if (supportSnapshot) {\n         // make sure subtreeMap only contains entry for directory\n         subtreeMap.remove(inodeId);\n         // process file diffs\n         processFileDiffList(in, v, parentName);\n         if (isSnapshotCopy) {\n           boolean underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             v.visit(ImageElement.CLIENT_NAME,\n                 FSImageSerialization.readString(in));\n             v.visit(ImageElement.CLIENT_MACHINE,\n                 FSImageSerialization.readString(in));\n           }\n         }\n       }\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -1) { // Directory\n       if (supportSnapshot \u0026\u0026 supportInodeId) {\n         dirNodeMap.put(inodeId, pathName);\n       }\n-      v.visit(ImageElement.NS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n-      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA, imageVersion))\n-        v.visit(ImageElement.DS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n+\n+      v.visit(ImageElement.NS_QUOTA, in.readLong());\n+      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA,\n+          imageVersion)) {\n+        v.visit(ImageElement.DS_QUOTA, in.readLong());\n+      }\n+\n       if (supportSnapshot) {\n         boolean snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           boolean withSnapshot \u003d in.readBoolean();\n           v.visit(ImageElement.IS_WITHSNAPSHOT_DIR, Boolean.toString(withSnapshot));\n         } else {\n           v.visit(ImageElement.IS_SNAPSHOTTABLE_DIR, Boolean.toString(snapshottable));\n         }\n       }\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -2) {\n       v.visit(ImageElement.SYMLINK, Text.readString(in));\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -3) { // reference node\n       final boolean isWithName \u003d in.readBoolean();\n       int snapshotId \u003d in.readInt();\n       if (isWithName) {\n         v.visit(ImageElement.SNAPSHOT_LAST_SNAPSHOT_ID, snapshotId);\n       } else {\n         v.visit(ImageElement.SNAPSHOT_DST_SNAPSHOT_ID, snapshotId);\n       }\n       \n       final boolean firstReferred \u003d in.readBoolean();\n       if (firstReferred) {\n         // if a subtree is linked by multiple \"parents\", the corresponding dir\n         // must be referred by a reference node. we put the reference node into\n         // the subtreeMap here and let its value be false. when we later visit\n         // the subtree for the first time, we change the value to true.\n         subtreeMap.put(inodeId, false);\n         v.visitEnclosingElement(ImageElement.SNAPSHOT_REF_INODE);\n         processINode(in, v, skipBlocks, parentName, isSnapshotCopy);\n         v.leaveEnclosingElement();  // referred inode    \n       } else {\n         v.visit(ImageElement.SNAPSHOT_REF_INODE_ID, in.readLong());\n       }\n     }\n \n     v.leaveEnclosingElement(); // INode\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processINode(DataInputStream in, ImageVisitor v,\n      boolean skipBlocks, String parentName, boolean isSnapshotCopy)\n      throws IOException {\n    boolean supportSnapshot \u003d \n        NameNodeLayoutVersion.supports(Feature.SNAPSHOT, imageVersion);\n    boolean supportInodeId \u003d \n        NameNodeLayoutVersion.supports(Feature.ADD_INODE_ID, imageVersion);\n    \n    v.visitEnclosingElement(ImageElement.INODE);\n    final String pathName \u003d readINodePath(in, parentName);\n    v.visit(ImageElement.INODE_PATH, pathName);\n\n    long inodeId \u003d HdfsConstants.GRANDFATHER_INODE_ID;\n    if (supportInodeId) {\n      inodeId \u003d in.readLong();\n      v.visit(ImageElement.INODE_ID, inodeId);\n    }\n    v.visit(ImageElement.REPLICATION, in.readShort());\n    v.visit(ImageElement.MODIFICATION_TIME, formatDate(in.readLong()));\n    if(NameNodeLayoutVersion.supports(Feature.FILE_ACCESS_TIME, imageVersion))\n      v.visit(ImageElement.ACCESS_TIME, formatDate(in.readLong()));\n    v.visit(ImageElement.BLOCK_SIZE, in.readLong());\n    int numBlocks \u003d in.readInt();\n\n    processBlocks(in, v, numBlocks, skipBlocks);\n    \n    if (numBlocks \u003e\u003d 0) { // File\n      if (supportSnapshot) {\n        // make sure subtreeMap only contains entry for directory\n        subtreeMap.remove(inodeId);\n        // process file diffs\n        processFileDiffList(in, v, parentName);\n        if (isSnapshotCopy) {\n          boolean underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            v.visit(ImageElement.CLIENT_NAME,\n                FSImageSerialization.readString(in));\n            v.visit(ImageElement.CLIENT_MACHINE,\n                FSImageSerialization.readString(in));\n          }\n        }\n      }\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -1) { // Directory\n      if (supportSnapshot \u0026\u0026 supportInodeId) {\n        dirNodeMap.put(inodeId, pathName);\n      }\n\n      v.visit(ImageElement.NS_QUOTA, in.readLong());\n      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA,\n          imageVersion)) {\n        v.visit(ImageElement.DS_QUOTA, in.readLong());\n      }\n\n      if (supportSnapshot) {\n        boolean snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          boolean withSnapshot \u003d in.readBoolean();\n          v.visit(ImageElement.IS_WITHSNAPSHOT_DIR, Boolean.toString(withSnapshot));\n        } else {\n          v.visit(ImageElement.IS_SNAPSHOTTABLE_DIR, Boolean.toString(snapshottable));\n        }\n      }\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -2) {\n      v.visit(ImageElement.SYMLINK, Text.readString(in));\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -3) { // reference node\n      final boolean isWithName \u003d in.readBoolean();\n      int snapshotId \u003d in.readInt();\n      if (isWithName) {\n        v.visit(ImageElement.SNAPSHOT_LAST_SNAPSHOT_ID, snapshotId);\n      } else {\n        v.visit(ImageElement.SNAPSHOT_DST_SNAPSHOT_ID, snapshotId);\n      }\n      \n      final boolean firstReferred \u003d in.readBoolean();\n      if (firstReferred) {\n        // if a subtree is linked by multiple \"parents\", the corresponding dir\n        // must be referred by a reference node. we put the reference node into\n        // the subtreeMap here and let its value be false. when we later visit\n        // the subtree for the first time, we change the value to true.\n        subtreeMap.put(inodeId, false);\n        v.visitEnclosingElement(ImageElement.SNAPSHOT_REF_INODE);\n        processINode(in, v, skipBlocks, parentName, isSnapshotCopy);\n        v.leaveEnclosingElement();  // referred inode    \n      } else {\n        v.visit(ImageElement.SNAPSHOT_REF_INODE_ID, in.readLong());\n      }\n    }\n\n    v.leaveEnclosingElement(); // INode\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/ImageLoaderCurrent.java",
      "extendedDetails": {}
    },
    "441378e7e4609d89b7181dacc8ba92b253a962df": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-11696. Fix warnings from Spotbugs in hadoop-hdfs. Contributed by Yiqun Lin.\"\n\nThis reverts commit 89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a.\n\n Conflicts:\n\thadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java\n",
      "commitDate": "29/06/17 1:54 PM",
      "commitName": "441378e7e4609d89b7181dacc8ba92b253a962df",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "16/05/17 9:41 AM",
      "commitNameOld": "89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 44.18,
      "commitsBetweenForRepo": 226,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,89 @@\n   private void processINode(DataInputStream in, ImageVisitor v,\n       boolean skipBlocks, String parentName, boolean isSnapshotCopy)\n       throws IOException {\n     boolean supportSnapshot \u003d \n         NameNodeLayoutVersion.supports(Feature.SNAPSHOT, imageVersion);\n     boolean supportInodeId \u003d \n         NameNodeLayoutVersion.supports(Feature.ADD_INODE_ID, imageVersion);\n     \n     v.visitEnclosingElement(ImageElement.INODE);\n     final String pathName \u003d readINodePath(in, parentName);\n     v.visit(ImageElement.INODE_PATH, pathName);\n \n     long inodeId \u003d HdfsConstants.GRANDFATHER_INODE_ID;\n     if (supportInodeId) {\n       inodeId \u003d in.readLong();\n       v.visit(ImageElement.INODE_ID, inodeId);\n     }\n     v.visit(ImageElement.REPLICATION, in.readShort());\n     v.visit(ImageElement.MODIFICATION_TIME, formatDate(in.readLong()));\n     if(NameNodeLayoutVersion.supports(Feature.FILE_ACCESS_TIME, imageVersion))\n       v.visit(ImageElement.ACCESS_TIME, formatDate(in.readLong()));\n     v.visit(ImageElement.BLOCK_SIZE, in.readLong());\n     int numBlocks \u003d in.readInt();\n \n     processBlocks(in, v, numBlocks, skipBlocks);\n     \n     if (numBlocks \u003e\u003d 0) { // File\n       if (supportSnapshot) {\n         // make sure subtreeMap only contains entry for directory\n         subtreeMap.remove(inodeId);\n         // process file diffs\n         processFileDiffList(in, v, parentName);\n         if (isSnapshotCopy) {\n           boolean underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             v.visit(ImageElement.CLIENT_NAME,\n                 FSImageSerialization.readString(in));\n             v.visit(ImageElement.CLIENT_MACHINE,\n                 FSImageSerialization.readString(in));\n           }\n         }\n       }\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -1) { // Directory\n       if (supportSnapshot \u0026\u0026 supportInodeId) {\n         dirNodeMap.put(inodeId, pathName);\n       }\n-\n-      v.visit(ImageElement.NS_QUOTA, in.readLong());\n-      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA,\n-          imageVersion)) {\n-        v.visit(ImageElement.DS_QUOTA, in.readLong());\n-      }\n-\n+      v.visit(ImageElement.NS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n+      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA, imageVersion))\n+        v.visit(ImageElement.DS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n       if (supportSnapshot) {\n         boolean snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           boolean withSnapshot \u003d in.readBoolean();\n           v.visit(ImageElement.IS_WITHSNAPSHOT_DIR, Boolean.toString(withSnapshot));\n         } else {\n           v.visit(ImageElement.IS_SNAPSHOTTABLE_DIR, Boolean.toString(snapshottable));\n         }\n       }\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -2) {\n       v.visit(ImageElement.SYMLINK, Text.readString(in));\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -3) { // reference node\n       final boolean isWithName \u003d in.readBoolean();\n       int snapshotId \u003d in.readInt();\n       if (isWithName) {\n         v.visit(ImageElement.SNAPSHOT_LAST_SNAPSHOT_ID, snapshotId);\n       } else {\n         v.visit(ImageElement.SNAPSHOT_DST_SNAPSHOT_ID, snapshotId);\n       }\n       \n       final boolean firstReferred \u003d in.readBoolean();\n       if (firstReferred) {\n         // if a subtree is linked by multiple \"parents\", the corresponding dir\n         // must be referred by a reference node. we put the reference node into\n         // the subtreeMap here and let its value be false. when we later visit\n         // the subtree for the first time, we change the value to true.\n         subtreeMap.put(inodeId, false);\n         v.visitEnclosingElement(ImageElement.SNAPSHOT_REF_INODE);\n         processINode(in, v, skipBlocks, parentName, isSnapshotCopy);\n         v.leaveEnclosingElement();  // referred inode    \n       } else {\n         v.visit(ImageElement.SNAPSHOT_REF_INODE_ID, in.readLong());\n       }\n     }\n \n     v.leaveEnclosingElement(); // INode\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processINode(DataInputStream in, ImageVisitor v,\n      boolean skipBlocks, String parentName, boolean isSnapshotCopy)\n      throws IOException {\n    boolean supportSnapshot \u003d \n        NameNodeLayoutVersion.supports(Feature.SNAPSHOT, imageVersion);\n    boolean supportInodeId \u003d \n        NameNodeLayoutVersion.supports(Feature.ADD_INODE_ID, imageVersion);\n    \n    v.visitEnclosingElement(ImageElement.INODE);\n    final String pathName \u003d readINodePath(in, parentName);\n    v.visit(ImageElement.INODE_PATH, pathName);\n\n    long inodeId \u003d HdfsConstants.GRANDFATHER_INODE_ID;\n    if (supportInodeId) {\n      inodeId \u003d in.readLong();\n      v.visit(ImageElement.INODE_ID, inodeId);\n    }\n    v.visit(ImageElement.REPLICATION, in.readShort());\n    v.visit(ImageElement.MODIFICATION_TIME, formatDate(in.readLong()));\n    if(NameNodeLayoutVersion.supports(Feature.FILE_ACCESS_TIME, imageVersion))\n      v.visit(ImageElement.ACCESS_TIME, formatDate(in.readLong()));\n    v.visit(ImageElement.BLOCK_SIZE, in.readLong());\n    int numBlocks \u003d in.readInt();\n\n    processBlocks(in, v, numBlocks, skipBlocks);\n    \n    if (numBlocks \u003e\u003d 0) { // File\n      if (supportSnapshot) {\n        // make sure subtreeMap only contains entry for directory\n        subtreeMap.remove(inodeId);\n        // process file diffs\n        processFileDiffList(in, v, parentName);\n        if (isSnapshotCopy) {\n          boolean underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            v.visit(ImageElement.CLIENT_NAME,\n                FSImageSerialization.readString(in));\n            v.visit(ImageElement.CLIENT_MACHINE,\n                FSImageSerialization.readString(in));\n          }\n        }\n      }\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -1) { // Directory\n      if (supportSnapshot \u0026\u0026 supportInodeId) {\n        dirNodeMap.put(inodeId, pathName);\n      }\n      v.visit(ImageElement.NS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA, imageVersion))\n        v.visit(ImageElement.DS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n      if (supportSnapshot) {\n        boolean snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          boolean withSnapshot \u003d in.readBoolean();\n          v.visit(ImageElement.IS_WITHSNAPSHOT_DIR, Boolean.toString(withSnapshot));\n        } else {\n          v.visit(ImageElement.IS_SNAPSHOTTABLE_DIR, Boolean.toString(snapshottable));\n        }\n      }\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -2) {\n      v.visit(ImageElement.SYMLINK, Text.readString(in));\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -3) { // reference node\n      final boolean isWithName \u003d in.readBoolean();\n      int snapshotId \u003d in.readInt();\n      if (isWithName) {\n        v.visit(ImageElement.SNAPSHOT_LAST_SNAPSHOT_ID, snapshotId);\n      } else {\n        v.visit(ImageElement.SNAPSHOT_DST_SNAPSHOT_ID, snapshotId);\n      }\n      \n      final boolean firstReferred \u003d in.readBoolean();\n      if (firstReferred) {\n        // if a subtree is linked by multiple \"parents\", the corresponding dir\n        // must be referred by a reference node. we put the reference node into\n        // the subtreeMap here and let its value be false. when we later visit\n        // the subtree for the first time, we change the value to true.\n        subtreeMap.put(inodeId, false);\n        v.visitEnclosingElement(ImageElement.SNAPSHOT_REF_INODE);\n        processINode(in, v, skipBlocks, parentName, isSnapshotCopy);\n        v.leaveEnclosingElement();  // referred inode    \n      } else {\n        v.visit(ImageElement.SNAPSHOT_REF_INODE_ID, in.readLong());\n      }\n    }\n\n    v.leaveEnclosingElement(); // INode\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/ImageLoaderCurrent.java",
      "extendedDetails": {}
    },
    "89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11696. Fix warnings from Spotbugs in hadoop-hdfs. Contributed by Yiqun Lin.\n",
      "commitDate": "16/05/17 9:41 AM",
      "commitName": "89a8edc0149e3f31a5ade9a0927c4b6332cf6b1a",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "02/05/15 10:03 AM",
      "commitNameOld": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 744.99,
      "commitsBetweenForRepo": 5207,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,93 @@\n   private void processINode(DataInputStream in, ImageVisitor v,\n       boolean skipBlocks, String parentName, boolean isSnapshotCopy)\n       throws IOException {\n     boolean supportSnapshot \u003d \n         NameNodeLayoutVersion.supports(Feature.SNAPSHOT, imageVersion);\n     boolean supportInodeId \u003d \n         NameNodeLayoutVersion.supports(Feature.ADD_INODE_ID, imageVersion);\n     \n     v.visitEnclosingElement(ImageElement.INODE);\n     final String pathName \u003d readINodePath(in, parentName);\n     v.visit(ImageElement.INODE_PATH, pathName);\n \n     long inodeId \u003d HdfsConstants.GRANDFATHER_INODE_ID;\n     if (supportInodeId) {\n       inodeId \u003d in.readLong();\n       v.visit(ImageElement.INODE_ID, inodeId);\n     }\n     v.visit(ImageElement.REPLICATION, in.readShort());\n     v.visit(ImageElement.MODIFICATION_TIME, formatDate(in.readLong()));\n     if(NameNodeLayoutVersion.supports(Feature.FILE_ACCESS_TIME, imageVersion))\n       v.visit(ImageElement.ACCESS_TIME, formatDate(in.readLong()));\n     v.visit(ImageElement.BLOCK_SIZE, in.readLong());\n     int numBlocks \u003d in.readInt();\n \n     processBlocks(in, v, numBlocks, skipBlocks);\n     \n     if (numBlocks \u003e\u003d 0) { // File\n       if (supportSnapshot) {\n         // make sure subtreeMap only contains entry for directory\n         subtreeMap.remove(inodeId);\n         // process file diffs\n         processFileDiffList(in, v, parentName);\n         if (isSnapshotCopy) {\n           boolean underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             v.visit(ImageElement.CLIENT_NAME,\n                 FSImageSerialization.readString(in));\n             v.visit(ImageElement.CLIENT_MACHINE,\n                 FSImageSerialization.readString(in));\n           }\n         }\n       }\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -1) { // Directory\n       if (supportSnapshot \u0026\u0026 supportInodeId) {\n         dirNodeMap.put(inodeId, pathName);\n       }\n-      v.visit(ImageElement.NS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n-      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA, imageVersion))\n-        v.visit(ImageElement.DS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n+\n+      v.visit(ImageElement.NS_QUOTA, in.readLong());\n+      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA,\n+          imageVersion)) {\n+        v.visit(ImageElement.DS_QUOTA, in.readLong());\n+      }\n+\n       if (supportSnapshot) {\n         boolean snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           boolean withSnapshot \u003d in.readBoolean();\n           v.visit(ImageElement.IS_WITHSNAPSHOT_DIR, Boolean.toString(withSnapshot));\n         } else {\n           v.visit(ImageElement.IS_SNAPSHOTTABLE_DIR, Boolean.toString(snapshottable));\n         }\n       }\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -2) {\n       v.visit(ImageElement.SYMLINK, Text.readString(in));\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -3) { // reference node\n       final boolean isWithName \u003d in.readBoolean();\n       int snapshotId \u003d in.readInt();\n       if (isWithName) {\n         v.visit(ImageElement.SNAPSHOT_LAST_SNAPSHOT_ID, snapshotId);\n       } else {\n         v.visit(ImageElement.SNAPSHOT_DST_SNAPSHOT_ID, snapshotId);\n       }\n       \n       final boolean firstReferred \u003d in.readBoolean();\n       if (firstReferred) {\n         // if a subtree is linked by multiple \"parents\", the corresponding dir\n         // must be referred by a reference node. we put the reference node into\n         // the subtreeMap here and let its value be false. when we later visit\n         // the subtree for the first time, we change the value to true.\n         subtreeMap.put(inodeId, false);\n         v.visitEnclosingElement(ImageElement.SNAPSHOT_REF_INODE);\n         processINode(in, v, skipBlocks, parentName, isSnapshotCopy);\n         v.leaveEnclosingElement();  // referred inode    \n       } else {\n         v.visit(ImageElement.SNAPSHOT_REF_INODE_ID, in.readLong());\n       }\n     }\n \n     v.leaveEnclosingElement(); // INode\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processINode(DataInputStream in, ImageVisitor v,\n      boolean skipBlocks, String parentName, boolean isSnapshotCopy)\n      throws IOException {\n    boolean supportSnapshot \u003d \n        NameNodeLayoutVersion.supports(Feature.SNAPSHOT, imageVersion);\n    boolean supportInodeId \u003d \n        NameNodeLayoutVersion.supports(Feature.ADD_INODE_ID, imageVersion);\n    \n    v.visitEnclosingElement(ImageElement.INODE);\n    final String pathName \u003d readINodePath(in, parentName);\n    v.visit(ImageElement.INODE_PATH, pathName);\n\n    long inodeId \u003d HdfsConstants.GRANDFATHER_INODE_ID;\n    if (supportInodeId) {\n      inodeId \u003d in.readLong();\n      v.visit(ImageElement.INODE_ID, inodeId);\n    }\n    v.visit(ImageElement.REPLICATION, in.readShort());\n    v.visit(ImageElement.MODIFICATION_TIME, formatDate(in.readLong()));\n    if(NameNodeLayoutVersion.supports(Feature.FILE_ACCESS_TIME, imageVersion))\n      v.visit(ImageElement.ACCESS_TIME, formatDate(in.readLong()));\n    v.visit(ImageElement.BLOCK_SIZE, in.readLong());\n    int numBlocks \u003d in.readInt();\n\n    processBlocks(in, v, numBlocks, skipBlocks);\n    \n    if (numBlocks \u003e\u003d 0) { // File\n      if (supportSnapshot) {\n        // make sure subtreeMap only contains entry for directory\n        subtreeMap.remove(inodeId);\n        // process file diffs\n        processFileDiffList(in, v, parentName);\n        if (isSnapshotCopy) {\n          boolean underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            v.visit(ImageElement.CLIENT_NAME,\n                FSImageSerialization.readString(in));\n            v.visit(ImageElement.CLIENT_MACHINE,\n                FSImageSerialization.readString(in));\n          }\n        }\n      }\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -1) { // Directory\n      if (supportSnapshot \u0026\u0026 supportInodeId) {\n        dirNodeMap.put(inodeId, pathName);\n      }\n\n      v.visit(ImageElement.NS_QUOTA, in.readLong());\n      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA,\n          imageVersion)) {\n        v.visit(ImageElement.DS_QUOTA, in.readLong());\n      }\n\n      if (supportSnapshot) {\n        boolean snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          boolean withSnapshot \u003d in.readBoolean();\n          v.visit(ImageElement.IS_WITHSNAPSHOT_DIR, Boolean.toString(withSnapshot));\n        } else {\n          v.visit(ImageElement.IS_SNAPSHOTTABLE_DIR, Boolean.toString(snapshottable));\n        }\n      }\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -2) {\n      v.visit(ImageElement.SYMLINK, Text.readString(in));\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -3) { // reference node\n      final boolean isWithName \u003d in.readBoolean();\n      int snapshotId \u003d in.readInt();\n      if (isWithName) {\n        v.visit(ImageElement.SNAPSHOT_LAST_SNAPSHOT_ID, snapshotId);\n      } else {\n        v.visit(ImageElement.SNAPSHOT_DST_SNAPSHOT_ID, snapshotId);\n      }\n      \n      final boolean firstReferred \u003d in.readBoolean();\n      if (firstReferred) {\n        // if a subtree is linked by multiple \"parents\", the corresponding dir\n        // must be referred by a reference node. we put the reference node into\n        // the subtreeMap here and let its value be false. when we later visit\n        // the subtree for the first time, we change the value to true.\n        subtreeMap.put(inodeId, false);\n        v.visitEnclosingElement(ImageElement.SNAPSHOT_REF_INODE);\n        processINode(in, v, skipBlocks, parentName, isSnapshotCopy);\n        v.leaveEnclosingElement();  // referred inode    \n      } else {\n        v.visit(ImageElement.SNAPSHOT_REF_INODE_ID, in.readLong());\n      }\n    }\n\n    v.leaveEnclosingElement(); // INode\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/ImageLoaderCurrent.java",
      "extendedDetails": {}
    },
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "16/04/15 10:49 PM",
      "commitNameOld": "76e7264e8d6407f527bd877009aca11f7bb63bd7",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 15.47,
      "commitsBetweenForRepo": 137,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,89 @@\n   private void processINode(DataInputStream in, ImageVisitor v,\n       boolean skipBlocks, String parentName, boolean isSnapshotCopy)\n       throws IOException {\n     boolean supportSnapshot \u003d \n         NameNodeLayoutVersion.supports(Feature.SNAPSHOT, imageVersion);\n     boolean supportInodeId \u003d \n         NameNodeLayoutVersion.supports(Feature.ADD_INODE_ID, imageVersion);\n     \n     v.visitEnclosingElement(ImageElement.INODE);\n     final String pathName \u003d readINodePath(in, parentName);\n     v.visit(ImageElement.INODE_PATH, pathName);\n \n-    long inodeId \u003d HdfsConstantsClient.GRANDFATHER_INODE_ID;\n+    long inodeId \u003d HdfsConstants.GRANDFATHER_INODE_ID;\n     if (supportInodeId) {\n       inodeId \u003d in.readLong();\n       v.visit(ImageElement.INODE_ID, inodeId);\n     }\n     v.visit(ImageElement.REPLICATION, in.readShort());\n     v.visit(ImageElement.MODIFICATION_TIME, formatDate(in.readLong()));\n     if(NameNodeLayoutVersion.supports(Feature.FILE_ACCESS_TIME, imageVersion))\n       v.visit(ImageElement.ACCESS_TIME, formatDate(in.readLong()));\n     v.visit(ImageElement.BLOCK_SIZE, in.readLong());\n     int numBlocks \u003d in.readInt();\n \n     processBlocks(in, v, numBlocks, skipBlocks);\n     \n     if (numBlocks \u003e\u003d 0) { // File\n       if (supportSnapshot) {\n         // make sure subtreeMap only contains entry for directory\n         subtreeMap.remove(inodeId);\n         // process file diffs\n         processFileDiffList(in, v, parentName);\n         if (isSnapshotCopy) {\n           boolean underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             v.visit(ImageElement.CLIENT_NAME,\n                 FSImageSerialization.readString(in));\n             v.visit(ImageElement.CLIENT_MACHINE,\n                 FSImageSerialization.readString(in));\n           }\n         }\n       }\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -1) { // Directory\n       if (supportSnapshot \u0026\u0026 supportInodeId) {\n         dirNodeMap.put(inodeId, pathName);\n       }\n       v.visit(ImageElement.NS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n       if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA, imageVersion))\n         v.visit(ImageElement.DS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n       if (supportSnapshot) {\n         boolean snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           boolean withSnapshot \u003d in.readBoolean();\n           v.visit(ImageElement.IS_WITHSNAPSHOT_DIR, Boolean.toString(withSnapshot));\n         } else {\n           v.visit(ImageElement.IS_SNAPSHOTTABLE_DIR, Boolean.toString(snapshottable));\n         }\n       }\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -2) {\n       v.visit(ImageElement.SYMLINK, Text.readString(in));\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -3) { // reference node\n       final boolean isWithName \u003d in.readBoolean();\n       int snapshotId \u003d in.readInt();\n       if (isWithName) {\n         v.visit(ImageElement.SNAPSHOT_LAST_SNAPSHOT_ID, snapshotId);\n       } else {\n         v.visit(ImageElement.SNAPSHOT_DST_SNAPSHOT_ID, snapshotId);\n       }\n       \n       final boolean firstReferred \u003d in.readBoolean();\n       if (firstReferred) {\n         // if a subtree is linked by multiple \"parents\", the corresponding dir\n         // must be referred by a reference node. we put the reference node into\n         // the subtreeMap here and let its value be false. when we later visit\n         // the subtree for the first time, we change the value to true.\n         subtreeMap.put(inodeId, false);\n         v.visitEnclosingElement(ImageElement.SNAPSHOT_REF_INODE);\n         processINode(in, v, skipBlocks, parentName, isSnapshotCopy);\n         v.leaveEnclosingElement();  // referred inode    \n       } else {\n         v.visit(ImageElement.SNAPSHOT_REF_INODE_ID, in.readLong());\n       }\n     }\n \n     v.leaveEnclosingElement(); // INode\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processINode(DataInputStream in, ImageVisitor v,\n      boolean skipBlocks, String parentName, boolean isSnapshotCopy)\n      throws IOException {\n    boolean supportSnapshot \u003d \n        NameNodeLayoutVersion.supports(Feature.SNAPSHOT, imageVersion);\n    boolean supportInodeId \u003d \n        NameNodeLayoutVersion.supports(Feature.ADD_INODE_ID, imageVersion);\n    \n    v.visitEnclosingElement(ImageElement.INODE);\n    final String pathName \u003d readINodePath(in, parentName);\n    v.visit(ImageElement.INODE_PATH, pathName);\n\n    long inodeId \u003d HdfsConstants.GRANDFATHER_INODE_ID;\n    if (supportInodeId) {\n      inodeId \u003d in.readLong();\n      v.visit(ImageElement.INODE_ID, inodeId);\n    }\n    v.visit(ImageElement.REPLICATION, in.readShort());\n    v.visit(ImageElement.MODIFICATION_TIME, formatDate(in.readLong()));\n    if(NameNodeLayoutVersion.supports(Feature.FILE_ACCESS_TIME, imageVersion))\n      v.visit(ImageElement.ACCESS_TIME, formatDate(in.readLong()));\n    v.visit(ImageElement.BLOCK_SIZE, in.readLong());\n    int numBlocks \u003d in.readInt();\n\n    processBlocks(in, v, numBlocks, skipBlocks);\n    \n    if (numBlocks \u003e\u003d 0) { // File\n      if (supportSnapshot) {\n        // make sure subtreeMap only contains entry for directory\n        subtreeMap.remove(inodeId);\n        // process file diffs\n        processFileDiffList(in, v, parentName);\n        if (isSnapshotCopy) {\n          boolean underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            v.visit(ImageElement.CLIENT_NAME,\n                FSImageSerialization.readString(in));\n            v.visit(ImageElement.CLIENT_MACHINE,\n                FSImageSerialization.readString(in));\n          }\n        }\n      }\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -1) { // Directory\n      if (supportSnapshot \u0026\u0026 supportInodeId) {\n        dirNodeMap.put(inodeId, pathName);\n      }\n      v.visit(ImageElement.NS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA, imageVersion))\n        v.visit(ImageElement.DS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n      if (supportSnapshot) {\n        boolean snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          boolean withSnapshot \u003d in.readBoolean();\n          v.visit(ImageElement.IS_WITHSNAPSHOT_DIR, Boolean.toString(withSnapshot));\n        } else {\n          v.visit(ImageElement.IS_SNAPSHOTTABLE_DIR, Boolean.toString(snapshottable));\n        }\n      }\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -2) {\n      v.visit(ImageElement.SYMLINK, Text.readString(in));\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -3) { // reference node\n      final boolean isWithName \u003d in.readBoolean();\n      int snapshotId \u003d in.readInt();\n      if (isWithName) {\n        v.visit(ImageElement.SNAPSHOT_LAST_SNAPSHOT_ID, snapshotId);\n      } else {\n        v.visit(ImageElement.SNAPSHOT_DST_SNAPSHOT_ID, snapshotId);\n      }\n      \n      final boolean firstReferred \u003d in.readBoolean();\n      if (firstReferred) {\n        // if a subtree is linked by multiple \"parents\", the corresponding dir\n        // must be referred by a reference node. we put the reference node into\n        // the subtreeMap here and let its value be false. when we later visit\n        // the subtree for the first time, we change the value to true.\n        subtreeMap.put(inodeId, false);\n        v.visitEnclosingElement(ImageElement.SNAPSHOT_REF_INODE);\n        processINode(in, v, skipBlocks, parentName, isSnapshotCopy);\n        v.leaveEnclosingElement();  // referred inode    \n      } else {\n        v.visit(ImageElement.SNAPSHOT_REF_INODE_ID, in.readLong());\n      }\n    }\n\n    v.leaveEnclosingElement(); // INode\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/ImageLoaderCurrent.java",
      "extendedDetails": {}
    },
    "76e7264e8d6407f527bd877009aca11f7bb63bd7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8165. Move GRANDFATHER_GENERATION_STAMP and GRANDFATER_INODE_ID to hdfs-client. Contributed by Haohui Mai.\n",
      "commitDate": "16/04/15 10:49 PM",
      "commitName": "76e7264e8d6407f527bd877009aca11f7bb63bd7",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "13/05/14 6:15 PM",
      "commitNameOld": "97f58955a6045b373ab73653bf26ab5922b00cf3",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 338.19,
      "commitsBetweenForRepo": 2817,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,89 @@\n   private void processINode(DataInputStream in, ImageVisitor v,\n       boolean skipBlocks, String parentName, boolean isSnapshotCopy)\n       throws IOException {\n     boolean supportSnapshot \u003d \n         NameNodeLayoutVersion.supports(Feature.SNAPSHOT, imageVersion);\n     boolean supportInodeId \u003d \n         NameNodeLayoutVersion.supports(Feature.ADD_INODE_ID, imageVersion);\n     \n     v.visitEnclosingElement(ImageElement.INODE);\n     final String pathName \u003d readINodePath(in, parentName);\n     v.visit(ImageElement.INODE_PATH, pathName);\n \n-    long inodeId \u003d INodeId.GRANDFATHER_INODE_ID;\n+    long inodeId \u003d HdfsConstantsClient.GRANDFATHER_INODE_ID;\n     if (supportInodeId) {\n       inodeId \u003d in.readLong();\n       v.visit(ImageElement.INODE_ID, inodeId);\n     }\n     v.visit(ImageElement.REPLICATION, in.readShort());\n     v.visit(ImageElement.MODIFICATION_TIME, formatDate(in.readLong()));\n     if(NameNodeLayoutVersion.supports(Feature.FILE_ACCESS_TIME, imageVersion))\n       v.visit(ImageElement.ACCESS_TIME, formatDate(in.readLong()));\n     v.visit(ImageElement.BLOCK_SIZE, in.readLong());\n     int numBlocks \u003d in.readInt();\n \n     processBlocks(in, v, numBlocks, skipBlocks);\n     \n     if (numBlocks \u003e\u003d 0) { // File\n       if (supportSnapshot) {\n         // make sure subtreeMap only contains entry for directory\n         subtreeMap.remove(inodeId);\n         // process file diffs\n         processFileDiffList(in, v, parentName);\n         if (isSnapshotCopy) {\n           boolean underConstruction \u003d in.readBoolean();\n           if (underConstruction) {\n             v.visit(ImageElement.CLIENT_NAME,\n                 FSImageSerialization.readString(in));\n             v.visit(ImageElement.CLIENT_MACHINE,\n                 FSImageSerialization.readString(in));\n           }\n         }\n       }\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -1) { // Directory\n       if (supportSnapshot \u0026\u0026 supportInodeId) {\n         dirNodeMap.put(inodeId, pathName);\n       }\n       v.visit(ImageElement.NS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n       if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA, imageVersion))\n         v.visit(ImageElement.DS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n       if (supportSnapshot) {\n         boolean snapshottable \u003d in.readBoolean();\n         if (!snapshottable) {\n           boolean withSnapshot \u003d in.readBoolean();\n           v.visit(ImageElement.IS_WITHSNAPSHOT_DIR, Boolean.toString(withSnapshot));\n         } else {\n           v.visit(ImageElement.IS_SNAPSHOTTABLE_DIR, Boolean.toString(snapshottable));\n         }\n       }\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -2) {\n       v.visit(ImageElement.SYMLINK, Text.readString(in));\n       processPermission(in, v);\n     } else if (numBlocks \u003d\u003d -3) { // reference node\n       final boolean isWithName \u003d in.readBoolean();\n       int snapshotId \u003d in.readInt();\n       if (isWithName) {\n         v.visit(ImageElement.SNAPSHOT_LAST_SNAPSHOT_ID, snapshotId);\n       } else {\n         v.visit(ImageElement.SNAPSHOT_DST_SNAPSHOT_ID, snapshotId);\n       }\n       \n       final boolean firstReferred \u003d in.readBoolean();\n       if (firstReferred) {\n         // if a subtree is linked by multiple \"parents\", the corresponding dir\n         // must be referred by a reference node. we put the reference node into\n         // the subtreeMap here and let its value be false. when we later visit\n         // the subtree for the first time, we change the value to true.\n         subtreeMap.put(inodeId, false);\n         v.visitEnclosingElement(ImageElement.SNAPSHOT_REF_INODE);\n         processINode(in, v, skipBlocks, parentName, isSnapshotCopy);\n         v.leaveEnclosingElement();  // referred inode    \n       } else {\n         v.visit(ImageElement.SNAPSHOT_REF_INODE_ID, in.readLong());\n       }\n     }\n \n     v.leaveEnclosingElement(); // INode\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processINode(DataInputStream in, ImageVisitor v,\n      boolean skipBlocks, String parentName, boolean isSnapshotCopy)\n      throws IOException {\n    boolean supportSnapshot \u003d \n        NameNodeLayoutVersion.supports(Feature.SNAPSHOT, imageVersion);\n    boolean supportInodeId \u003d \n        NameNodeLayoutVersion.supports(Feature.ADD_INODE_ID, imageVersion);\n    \n    v.visitEnclosingElement(ImageElement.INODE);\n    final String pathName \u003d readINodePath(in, parentName);\n    v.visit(ImageElement.INODE_PATH, pathName);\n\n    long inodeId \u003d HdfsConstantsClient.GRANDFATHER_INODE_ID;\n    if (supportInodeId) {\n      inodeId \u003d in.readLong();\n      v.visit(ImageElement.INODE_ID, inodeId);\n    }\n    v.visit(ImageElement.REPLICATION, in.readShort());\n    v.visit(ImageElement.MODIFICATION_TIME, formatDate(in.readLong()));\n    if(NameNodeLayoutVersion.supports(Feature.FILE_ACCESS_TIME, imageVersion))\n      v.visit(ImageElement.ACCESS_TIME, formatDate(in.readLong()));\n    v.visit(ImageElement.BLOCK_SIZE, in.readLong());\n    int numBlocks \u003d in.readInt();\n\n    processBlocks(in, v, numBlocks, skipBlocks);\n    \n    if (numBlocks \u003e\u003d 0) { // File\n      if (supportSnapshot) {\n        // make sure subtreeMap only contains entry for directory\n        subtreeMap.remove(inodeId);\n        // process file diffs\n        processFileDiffList(in, v, parentName);\n        if (isSnapshotCopy) {\n          boolean underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            v.visit(ImageElement.CLIENT_NAME,\n                FSImageSerialization.readString(in));\n            v.visit(ImageElement.CLIENT_MACHINE,\n                FSImageSerialization.readString(in));\n          }\n        }\n      }\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -1) { // Directory\n      if (supportSnapshot \u0026\u0026 supportInodeId) {\n        dirNodeMap.put(inodeId, pathName);\n      }\n      v.visit(ImageElement.NS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA, imageVersion))\n        v.visit(ImageElement.DS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n      if (supportSnapshot) {\n        boolean snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          boolean withSnapshot \u003d in.readBoolean();\n          v.visit(ImageElement.IS_WITHSNAPSHOT_DIR, Boolean.toString(withSnapshot));\n        } else {\n          v.visit(ImageElement.IS_SNAPSHOTTABLE_DIR, Boolean.toString(snapshottable));\n        }\n      }\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -2) {\n      v.visit(ImageElement.SYMLINK, Text.readString(in));\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -3) { // reference node\n      final boolean isWithName \u003d in.readBoolean();\n      int snapshotId \u003d in.readInt();\n      if (isWithName) {\n        v.visit(ImageElement.SNAPSHOT_LAST_SNAPSHOT_ID, snapshotId);\n      } else {\n        v.visit(ImageElement.SNAPSHOT_DST_SNAPSHOT_ID, snapshotId);\n      }\n      \n      final boolean firstReferred \u003d in.readBoolean();\n      if (firstReferred) {\n        // if a subtree is linked by multiple \"parents\", the corresponding dir\n        // must be referred by a reference node. we put the reference node into\n        // the subtreeMap here and let its value be false. when we later visit\n        // the subtree for the first time, we change the value to true.\n        subtreeMap.put(inodeId, false);\n        v.visitEnclosingElement(ImageElement.SNAPSHOT_REF_INODE);\n        processINode(in, v, skipBlocks, parentName, isSnapshotCopy);\n        v.leaveEnclosingElement();  // referred inode    \n      } else {\n        v.visit(ImageElement.SNAPSHOT_REF_INODE_ID, in.readLong());\n      }\n    }\n\n    v.leaveEnclosingElement(); // INode\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/ImageLoaderCurrent.java",
      "extendedDetails": {}
    },
    "97f58955a6045b373ab73653bf26ab5922b00cf3": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-6293. Issues with OIV processing PB-based fsimages. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594439 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/14 6:15 PM",
      "commitName": "97f58955a6045b373ab73653bf26ab5922b00cf3",
      "commitAuthor": "Kihwal Lee",
      "diff": "@@ -0,0 +1,89 @@\n+  private void processINode(DataInputStream in, ImageVisitor v,\n+      boolean skipBlocks, String parentName, boolean isSnapshotCopy)\n+      throws IOException {\n+    boolean supportSnapshot \u003d \n+        NameNodeLayoutVersion.supports(Feature.SNAPSHOT, imageVersion);\n+    boolean supportInodeId \u003d \n+        NameNodeLayoutVersion.supports(Feature.ADD_INODE_ID, imageVersion);\n+    \n+    v.visitEnclosingElement(ImageElement.INODE);\n+    final String pathName \u003d readINodePath(in, parentName);\n+    v.visit(ImageElement.INODE_PATH, pathName);\n+\n+    long inodeId \u003d INodeId.GRANDFATHER_INODE_ID;\n+    if (supportInodeId) {\n+      inodeId \u003d in.readLong();\n+      v.visit(ImageElement.INODE_ID, inodeId);\n+    }\n+    v.visit(ImageElement.REPLICATION, in.readShort());\n+    v.visit(ImageElement.MODIFICATION_TIME, formatDate(in.readLong()));\n+    if(NameNodeLayoutVersion.supports(Feature.FILE_ACCESS_TIME, imageVersion))\n+      v.visit(ImageElement.ACCESS_TIME, formatDate(in.readLong()));\n+    v.visit(ImageElement.BLOCK_SIZE, in.readLong());\n+    int numBlocks \u003d in.readInt();\n+\n+    processBlocks(in, v, numBlocks, skipBlocks);\n+    \n+    if (numBlocks \u003e\u003d 0) { // File\n+      if (supportSnapshot) {\n+        // make sure subtreeMap only contains entry for directory\n+        subtreeMap.remove(inodeId);\n+        // process file diffs\n+        processFileDiffList(in, v, parentName);\n+        if (isSnapshotCopy) {\n+          boolean underConstruction \u003d in.readBoolean();\n+          if (underConstruction) {\n+            v.visit(ImageElement.CLIENT_NAME,\n+                FSImageSerialization.readString(in));\n+            v.visit(ImageElement.CLIENT_MACHINE,\n+                FSImageSerialization.readString(in));\n+          }\n+        }\n+      }\n+      processPermission(in, v);\n+    } else if (numBlocks \u003d\u003d -1) { // Directory\n+      if (supportSnapshot \u0026\u0026 supportInodeId) {\n+        dirNodeMap.put(inodeId, pathName);\n+      }\n+      v.visit(ImageElement.NS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n+      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA, imageVersion))\n+        v.visit(ImageElement.DS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n+      if (supportSnapshot) {\n+        boolean snapshottable \u003d in.readBoolean();\n+        if (!snapshottable) {\n+          boolean withSnapshot \u003d in.readBoolean();\n+          v.visit(ImageElement.IS_WITHSNAPSHOT_DIR, Boolean.toString(withSnapshot));\n+        } else {\n+          v.visit(ImageElement.IS_SNAPSHOTTABLE_DIR, Boolean.toString(snapshottable));\n+        }\n+      }\n+      processPermission(in, v);\n+    } else if (numBlocks \u003d\u003d -2) {\n+      v.visit(ImageElement.SYMLINK, Text.readString(in));\n+      processPermission(in, v);\n+    } else if (numBlocks \u003d\u003d -3) { // reference node\n+      final boolean isWithName \u003d in.readBoolean();\n+      int snapshotId \u003d in.readInt();\n+      if (isWithName) {\n+        v.visit(ImageElement.SNAPSHOT_LAST_SNAPSHOT_ID, snapshotId);\n+      } else {\n+        v.visit(ImageElement.SNAPSHOT_DST_SNAPSHOT_ID, snapshotId);\n+      }\n+      \n+      final boolean firstReferred \u003d in.readBoolean();\n+      if (firstReferred) {\n+        // if a subtree is linked by multiple \"parents\", the corresponding dir\n+        // must be referred by a reference node. we put the reference node into\n+        // the subtreeMap here and let its value be false. when we later visit\n+        // the subtree for the first time, we change the value to true.\n+        subtreeMap.put(inodeId, false);\n+        v.visitEnclosingElement(ImageElement.SNAPSHOT_REF_INODE);\n+        processINode(in, v, skipBlocks, parentName, isSnapshotCopy);\n+        v.leaveEnclosingElement();  // referred inode    \n+      } else {\n+        v.visit(ImageElement.SNAPSHOT_REF_INODE_ID, in.readLong());\n+      }\n+    }\n+\n+    v.leaveEnclosingElement(); // INode\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void processINode(DataInputStream in, ImageVisitor v,\n      boolean skipBlocks, String parentName, boolean isSnapshotCopy)\n      throws IOException {\n    boolean supportSnapshot \u003d \n        NameNodeLayoutVersion.supports(Feature.SNAPSHOT, imageVersion);\n    boolean supportInodeId \u003d \n        NameNodeLayoutVersion.supports(Feature.ADD_INODE_ID, imageVersion);\n    \n    v.visitEnclosingElement(ImageElement.INODE);\n    final String pathName \u003d readINodePath(in, parentName);\n    v.visit(ImageElement.INODE_PATH, pathName);\n\n    long inodeId \u003d INodeId.GRANDFATHER_INODE_ID;\n    if (supportInodeId) {\n      inodeId \u003d in.readLong();\n      v.visit(ImageElement.INODE_ID, inodeId);\n    }\n    v.visit(ImageElement.REPLICATION, in.readShort());\n    v.visit(ImageElement.MODIFICATION_TIME, formatDate(in.readLong()));\n    if(NameNodeLayoutVersion.supports(Feature.FILE_ACCESS_TIME, imageVersion))\n      v.visit(ImageElement.ACCESS_TIME, formatDate(in.readLong()));\n    v.visit(ImageElement.BLOCK_SIZE, in.readLong());\n    int numBlocks \u003d in.readInt();\n\n    processBlocks(in, v, numBlocks, skipBlocks);\n    \n    if (numBlocks \u003e\u003d 0) { // File\n      if (supportSnapshot) {\n        // make sure subtreeMap only contains entry for directory\n        subtreeMap.remove(inodeId);\n        // process file diffs\n        processFileDiffList(in, v, parentName);\n        if (isSnapshotCopy) {\n          boolean underConstruction \u003d in.readBoolean();\n          if (underConstruction) {\n            v.visit(ImageElement.CLIENT_NAME,\n                FSImageSerialization.readString(in));\n            v.visit(ImageElement.CLIENT_MACHINE,\n                FSImageSerialization.readString(in));\n          }\n        }\n      }\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -1) { // Directory\n      if (supportSnapshot \u0026\u0026 supportInodeId) {\n        dirNodeMap.put(inodeId, pathName);\n      }\n      v.visit(ImageElement.NS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n      if (NameNodeLayoutVersion.supports(Feature.DISKSPACE_QUOTA, imageVersion))\n        v.visit(ImageElement.DS_QUOTA, numBlocks \u003d\u003d -1 ? in.readLong() : -1);\n      if (supportSnapshot) {\n        boolean snapshottable \u003d in.readBoolean();\n        if (!snapshottable) {\n          boolean withSnapshot \u003d in.readBoolean();\n          v.visit(ImageElement.IS_WITHSNAPSHOT_DIR, Boolean.toString(withSnapshot));\n        } else {\n          v.visit(ImageElement.IS_SNAPSHOTTABLE_DIR, Boolean.toString(snapshottable));\n        }\n      }\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -2) {\n      v.visit(ImageElement.SYMLINK, Text.readString(in));\n      processPermission(in, v);\n    } else if (numBlocks \u003d\u003d -3) { // reference node\n      final boolean isWithName \u003d in.readBoolean();\n      int snapshotId \u003d in.readInt();\n      if (isWithName) {\n        v.visit(ImageElement.SNAPSHOT_LAST_SNAPSHOT_ID, snapshotId);\n      } else {\n        v.visit(ImageElement.SNAPSHOT_DST_SNAPSHOT_ID, snapshotId);\n      }\n      \n      final boolean firstReferred \u003d in.readBoolean();\n      if (firstReferred) {\n        // if a subtree is linked by multiple \"parents\", the corresponding dir\n        // must be referred by a reference node. we put the reference node into\n        // the subtreeMap here and let its value be false. when we later visit\n        // the subtree for the first time, we change the value to true.\n        subtreeMap.put(inodeId, false);\n        v.visitEnclosingElement(ImageElement.SNAPSHOT_REF_INODE);\n        processINode(in, v, skipBlocks, parentName, isSnapshotCopy);\n        v.leaveEnclosingElement();  // referred inode    \n      } else {\n        v.visit(ImageElement.SNAPSHOT_REF_INODE_ID, in.readLong());\n      }\n    }\n\n    v.leaveEnclosingElement(); // INode\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/ImageLoaderCurrent.java"
    }
  }
}