{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ResourceTrackerService.java",
  "functionName": "nodeHeartbeat",
  "functionId": "nodeHeartbeat___request-NodeHeartbeatRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
  "functionStartLine": 549,
  "functionEndLine": 713,
  "numCommitsSeen": 115,
  "timeTaken": 19574,
  "changeHistory": [
    "cfec455c452d85229ef2f9d83e6f7fc827946b59",
    "ed13cf84068ad50a78e66211132c1f08238fb65b",
    "6a923464afa6b635f505be5d5b2414d47d570f99",
    "f659485ee83f3f34e3717631983adfc8fa1e53dc",
    "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1",
    "8cf6a9a2bde9d4ccad95a514885634792889ec7f",
    "89b3ebd11ea93bf9d3521677f0fb9ab3c373a6ca",
    "3b3b6efe2103244febfe6b4f61989e92bd7bb08a",
    "ff8378eb1b960c72d18a984c7e5d145b407ca11a",
    "092fead5d9875fb3760206bcdd76cdafec5e9481",
    "78b7e070d8009c78665a2baa64fe888788f53e69",
    "8410d862d3a72740f461ef91dddb5325955e1ca5",
    "0da69c324dee9baab0f0b9700db1cc5b623f8421",
    "06f0b50a284455ffd5857cb42f386e92d121d0e6",
    "829cceebc0b4bcde2ee0d45c8366aa9fd5cb39e4",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "2188a07e5bea1da26bf679ca0ece26ab596d3438",
    "9b5636408005676ae580f8d929f8e912c27828e7",
    "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc",
    "f0ac18d001d97914a9ee810b1fab56c5cebff830",
    "2a5da97f81d69b481e4d1324a47e64bb55b9407c",
    "1cbcd4a491e6a57d466c2897335614dc6770b475",
    "52948bb20bd1446164df1d3920c46c96dad750ae",
    "db9304788187c700647c4d84caeb3b5ad6d868d8",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434",
    "9bc913a35c46e65d373c3ae3f01a377e16e8d0ca",
    "57f1a01eda80f44d3ffcbcb93c4ee290e274946a",
    "b37da52a1c4fb3da2bd21bfadc5ec61c5f953a59",
    "db1b674b50ddecf2774f4092d677c412722bdcb1",
    "92431c961741747b5d6442f4025016d48d9a6863",
    "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52",
    "a16d022ca4313a41425c8e97841c841a2d6f2f54",
    "da709a2eac7110026169ed3fc4d0eaf85488d3ef",
    "db1e0c1eefc1f6ad8fd317088d548c7814ea7aff",
    "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "ca8024673178fa1c80224b390dfba932921693d9",
    "68148989bfb8b893529eb9920d849bce0dd575ec",
    "a35c7fd80bcb19a7c6a7b9234d782adaf2d51529",
    "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963",
    "7ca9fe73a0f5047ff0279f3e29a29c8447cbb81a",
    "18e08a8f511652ed9f4ba386bb4f0cf8339e2729",
    "83d80658673b286efc534d96463e4c93fb818858",
    "45a8e8c5a46535287de97fd6609c0743eef888ee",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "3cdc100369ce920701fdddae12d7f7247332b3f3",
    "78ff0b720e0418785d53802a1b4e72085c1a3556",
    "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b",
    "cbdb07f4ca358b9507296868a913977ad82ed716",
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "cfec455c452d85229ef2f9d83e6f7fc827946b59": "Ybodychange",
    "ed13cf84068ad50a78e66211132c1f08238fb65b": "Ybodychange",
    "6a923464afa6b635f505be5d5b2414d47d570f99": "Ybodychange",
    "f659485ee83f3f34e3717631983adfc8fa1e53dc": "Ybodychange",
    "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1": "Ybodychange",
    "8cf6a9a2bde9d4ccad95a514885634792889ec7f": "Ybodychange",
    "89b3ebd11ea93bf9d3521677f0fb9ab3c373a6ca": "Ybodychange",
    "3b3b6efe2103244febfe6b4f61989e92bd7bb08a": "Ybodychange",
    "ff8378eb1b960c72d18a984c7e5d145b407ca11a": "Ybodychange",
    "092fead5d9875fb3760206bcdd76cdafec5e9481": "Ybodychange",
    "78b7e070d8009c78665a2baa64fe888788f53e69": "Ybodychange",
    "8410d862d3a72740f461ef91dddb5325955e1ca5": "Ybodychange",
    "0da69c324dee9baab0f0b9700db1cc5b623f8421": "Ybodychange",
    "06f0b50a284455ffd5857cb42f386e92d121d0e6": "Ybodychange",
    "829cceebc0b4bcde2ee0d45c8366aa9fd5cb39e4": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "2188a07e5bea1da26bf679ca0ece26ab596d3438": "Ybodychange",
    "9b5636408005676ae580f8d929f8e912c27828e7": "Ybodychange",
    "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc": "Ybodychange",
    "f0ac18d001d97914a9ee810b1fab56c5cebff830": "Ybodychange",
    "2a5da97f81d69b481e4d1324a47e64bb55b9407c": "Ybodychange",
    "1cbcd4a491e6a57d466c2897335614dc6770b475": "Ybodychange",
    "52948bb20bd1446164df1d3920c46c96dad750ae": "Ybodychange",
    "db9304788187c700647c4d84caeb3b5ad6d868d8": "Ybodychange",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": "Ybodychange",
    "9bc913a35c46e65d373c3ae3f01a377e16e8d0ca": "Ybodychange",
    "57f1a01eda80f44d3ffcbcb93c4ee290e274946a": "Ybodychange",
    "b37da52a1c4fb3da2bd21bfadc5ec61c5f953a59": "Ybodychange",
    "db1b674b50ddecf2774f4092d677c412722bdcb1": "Ybodychange",
    "92431c961741747b5d6442f4025016d48d9a6863": "Ybodychange",
    "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52": "Ybodychange",
    "a16d022ca4313a41425c8e97841c841a2d6f2f54": "Ybodychange",
    "da709a2eac7110026169ed3fc4d0eaf85488d3ef": "Ybodychange",
    "db1e0c1eefc1f6ad8fd317088d548c7814ea7aff": "Ybodychange",
    "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Yexceptionschange",
    "ca8024673178fa1c80224b390dfba932921693d9": "Ybodychange",
    "68148989bfb8b893529eb9920d849bce0dd575ec": "Ybodychange",
    "a35c7fd80bcb19a7c6a7b9234d782adaf2d51529": "Yexceptionschange",
    "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963": "Ybodychange",
    "7ca9fe73a0f5047ff0279f3e29a29c8447cbb81a": "Ybodychange",
    "18e08a8f511652ed9f4ba386bb4f0cf8339e2729": "Ybodychange",
    "83d80658673b286efc534d96463e4c93fb818858": "Ybodychange",
    "45a8e8c5a46535287de97fd6609c0743eef888ee": "Ybodychange",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "3cdc100369ce920701fdddae12d7f7247332b3f3": "Ybodychange",
    "78ff0b720e0418785d53802a1b4e72085c1a3556": "Ybodychange",
    "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b": "Ybodychange",
    "cbdb07f4ca358b9507296868a913977ad82ed716": "Ybodychange",
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cfec455c452d85229ef2f9d83e6f7fc827946b59": {
      "type": "Ybodychange",
      "commitMessage": "YARN-999. In case of long running tasks, reduce node resource should balloon out resource quickly by calling preemption API and suspending running task. Contributed by Inigo Goiri.\n",
      "commitDate": "09/04/19 10:59 AM",
      "commitName": "cfec455c452d85229ef2f9d83e6f7fc827946b59",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 24.78,
      "commitsBetweenForRepo": 170,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,160 +1,165 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n     this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (getNextResponseId(\n         remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n             .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n     if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n         decommissioningWatcher.checkReadyToBeDecommissioned(\n             rmNode.getNodeID())) {\n       String message \u003d \"DECOMMISSIONING \" + nodeId +\n           \" is ready to be decommissioned\";\n       LOG.info(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       this.nmLivelinessMonitor.unregister(nodeId);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     if (timelineServiceV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       updateAppCollectorsMap(request);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n         YarnServerBuilderUtils.newNodeHeartbeatResponse(\n             getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n             NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n     rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     populateTokenSequenceNo(request, nodeHeartBeatResponse);\n \n     if (timelineServiceV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n+    // Check if we got an event (AdminService) that updated the resources\n+    if (rmNode.isUpdatedCapability()) {\n+      nodeHeartBeatResponse.setResource(rmNode.getTotalCapability());\n+      rmNode.resetUpdatedCapability();\n+    }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n \n     // 8. Get node\u0027s attributes and update node-to-attributes mapping\n     // in RMNodeAttributeManager.\n     if (request.getNodeAttributes() !\u003d null) {\n       try {\n         // update node attributes if necessary then update heartbeat response\n         updateNodeAttributesIfNecessary(nodeId, request.getNodeAttributes());\n         nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         String errorMsg \u003d\n             nodeHeartBeatResponse.getDiagnosticsMessage() \u003d\u003d null ?\n                 ex.getMessage() :\n                 nodeHeartBeatResponse.getDiagnosticsMessage() + \"\\n\" + ex\n                     .getMessage();\n         nodeHeartBeatResponse.setDiagnosticsMessage(errorMsg);\n         nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (getNextResponseId(\n        remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n            .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    if (timelineServiceV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n        YarnServerBuilderUtils.newNodeHeartbeatResponse(\n            getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n            NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n    rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    populateTokenSequenceNo(request, nodeHeartBeatResponse);\n\n    if (timelineServiceV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n    // Check if we got an event (AdminService) that updated the resources\n    if (rmNode.isUpdatedCapability()) {\n      nodeHeartBeatResponse.setResource(rmNode.getTotalCapability());\n      rmNode.resetUpdatedCapability();\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n\n    // 8. Get node\u0027s attributes and update node-to-attributes mapping\n    // in RMNodeAttributeManager.\n    if (request.getNodeAttributes() !\u003d null) {\n      try {\n        // update node attributes if necessary then update heartbeat response\n        updateNodeAttributesIfNecessary(nodeId, request.getNodeAttributes());\n        nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        String errorMsg \u003d\n            nodeHeartBeatResponse.getDiagnosticsMessage() \u003d\u003d null ?\n                ex.getMessage() :\n                nodeHeartBeatResponse.getDiagnosticsMessage() + \"\\n\" + ex\n                    .getMessage();\n        nodeHeartBeatResponse.setDiagnosticsMessage(errorMsg);\n        nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "ed13cf84068ad50a78e66211132c1f08238fb65b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9317. Avoid repeated YarnConfiguration#timelineServiceV2Enabled check. Contributed by Prabhu Joseph\n",
      "commitDate": "22/02/19 7:31 AM",
      "commitName": "ed13cf84068ad50a78e66211132c1f08238fb65b",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "08/01/19 2:54 PM",
      "commitNameOld": "6a923464afa6b635f505be5d5b2414d47d570f99",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 44.69,
      "commitsBetweenForRepo": 332,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,162 +1,160 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n     this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (getNextResponseId(\n         remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n             .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n     if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n         decommissioningWatcher.checkReadyToBeDecommissioned(\n             rmNode.getNodeID())) {\n       String message \u003d \"DECOMMISSIONING \" + nodeId +\n           \" is ready to be decommissioned\";\n       LOG.info(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       this.nmLivelinessMonitor.unregister(nodeId);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n-    boolean timelineV2Enabled \u003d\n-        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n-    if (timelineV2Enabled) {\n+    if (timelineServiceV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       updateAppCollectorsMap(request);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n         YarnServerBuilderUtils.newNodeHeartbeatResponse(\n             getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n             NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n     rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     populateTokenSequenceNo(request, nodeHeartBeatResponse);\n \n-    if (timelineV2Enabled) {\n+    if (timelineServiceV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n \n     // 8. Get node\u0027s attributes and update node-to-attributes mapping\n     // in RMNodeAttributeManager.\n     if (request.getNodeAttributes() !\u003d null) {\n       try {\n         // update node attributes if necessary then update heartbeat response\n         updateNodeAttributesIfNecessary(nodeId, request.getNodeAttributes());\n         nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         String errorMsg \u003d\n             nodeHeartBeatResponse.getDiagnosticsMessage() \u003d\u003d null ?\n                 ex.getMessage() :\n                 nodeHeartBeatResponse.getDiagnosticsMessage() + \"\\n\" + ex\n                     .getMessage();\n         nodeHeartBeatResponse.setDiagnosticsMessage(errorMsg);\n         nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (getNextResponseId(\n        remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n            .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    if (timelineServiceV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n        YarnServerBuilderUtils.newNodeHeartbeatResponse(\n            getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n            NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n    rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    populateTokenSequenceNo(request, nodeHeartBeatResponse);\n\n    if (timelineServiceV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n\n    // 8. Get node\u0027s attributes and update node-to-attributes mapping\n    // in RMNodeAttributeManager.\n    if (request.getNodeAttributes() !\u003d null) {\n      try {\n        // update node attributes if necessary then update heartbeat response\n        updateNodeAttributesIfNecessary(nodeId, request.getNodeAttributes());\n        nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        String errorMsg \u003d\n            nodeHeartBeatResponse.getDiagnosticsMessage() \u003d\u003d null ?\n                ex.getMessage() :\n                nodeHeartBeatResponse.getDiagnosticsMessage() + \"\\n\" + ex\n                    .getMessage();\n        nodeHeartBeatResponse.setDiagnosticsMessage(errorMsg);\n        nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "6a923464afa6b635f505be5d5b2414d47d570f99": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6523. Optimize system credentials sent in node heartbeat responses. Contributed by Manikandan R\n",
      "commitDate": "08/01/19 2:54 PM",
      "commitName": "6a923464afa6b635f505be5d5b2414d47d570f99",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "20/12/18 6:56 PM",
      "commitNameOld": "f659485ee83f3f34e3717631983adfc8fa1e53dc",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 18.83,
      "commitsBetweenForRepo": 114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,166 +1,162 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n     this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (getNextResponseId(\n         remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n             .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n     if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n         decommissioningWatcher.checkReadyToBeDecommissioned(\n             rmNode.getNodeID())) {\n       String message \u003d \"DECOMMISSIONING \" + nodeId +\n           \" is ready to be decommissioned\";\n       LOG.info(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       this.nmLivelinessMonitor.unregister(nodeId);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     boolean timelineV2Enabled \u003d\n         YarnConfiguration.timelineServiceV2Enabled(getConfig());\n     if (timelineV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       updateAppCollectorsMap(request);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n         YarnServerBuilderUtils.newNodeHeartbeatResponse(\n             getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n             NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n     rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n-    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n-        rmContext.getSystemCredentialsForApps();\n-    if (!systemCredentials.isEmpty()) {\n-      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n-    }\n+    populateTokenSequenceNo(request, nodeHeartBeatResponse);\n \n     if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n \n     // 8. Get node\u0027s attributes and update node-to-attributes mapping\n     // in RMNodeAttributeManager.\n     if (request.getNodeAttributes() !\u003d null) {\n       try {\n         // update node attributes if necessary then update heartbeat response\n         updateNodeAttributesIfNecessary(nodeId, request.getNodeAttributes());\n         nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         String errorMsg \u003d\n             nodeHeartBeatResponse.getDiagnosticsMessage() \u003d\u003d null ?\n                 ex.getMessage() :\n                 nodeHeartBeatResponse.getDiagnosticsMessage() + \"\\n\" + ex\n                     .getMessage();\n         nodeHeartBeatResponse.setDiagnosticsMessage(errorMsg);\n         nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (getNextResponseId(\n        remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n            .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n        YarnServerBuilderUtils.newNodeHeartbeatResponse(\n            getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n            NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n    rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    populateTokenSequenceNo(request, nodeHeartBeatResponse);\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n\n    // 8. Get node\u0027s attributes and update node-to-attributes mapping\n    // in RMNodeAttributeManager.\n    if (request.getNodeAttributes() !\u003d null) {\n      try {\n        // update node attributes if necessary then update heartbeat response\n        updateNodeAttributesIfNecessary(nodeId, request.getNodeAttributes());\n        nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        String errorMsg \u003d\n            nodeHeartBeatResponse.getDiagnosticsMessage() \u003d\u003d null ?\n                ex.getMessage() :\n                nodeHeartBeatResponse.getDiagnosticsMessage() + \"\\n\" + ex\n                    .getMessage();\n        nodeHeartBeatResponse.setDiagnosticsMessage(errorMsg);\n        nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "f659485ee83f3f34e3717631983adfc8fa1e53dc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8925. Updating distributed node attributes only when necessary. Contributed by Tao Yang.\n",
      "commitDate": "20/12/18 6:56 PM",
      "commitName": "f659485ee83f3f34e3717631983adfc8fa1e53dc",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "05/10/18 1:52 PM",
      "commitNameOld": "9bb2801e8ce1e6298241944a65f593f555ae10e2",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 76.25,
      "commitsBetweenForRepo": 600,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,174 +1,166 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n     this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (getNextResponseId(\n         remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n             .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n     if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n         decommissioningWatcher.checkReadyToBeDecommissioned(\n             rmNode.getNodeID())) {\n       String message \u003d \"DECOMMISSIONING \" + nodeId +\n           \" is ready to be decommissioned\";\n       LOG.info(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       this.nmLivelinessMonitor.unregister(nodeId);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     boolean timelineV2Enabled \u003d\n         YarnConfiguration.timelineServiceV2Enabled(getConfig());\n     if (timelineV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       updateAppCollectorsMap(request);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n         YarnServerBuilderUtils.newNodeHeartbeatResponse(\n             getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n             NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n     rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n \n     // 8. Get node\u0027s attributes and update node-to-attributes mapping\n     // in RMNodeAttributeManager.\n-    Set\u003cNodeAttribute\u003e nodeAttributes \u003d request.getNodeAttributes();\n-    if (nodeAttributes !\u003d null \u0026\u0026 !nodeAttributes.isEmpty()) {\n-      nodeAttributes.forEach(nodeAttribute -\u003e\n-          LOG.debug(nodeId.toString() + \" ATTRIBUTE : \"\n-              + nodeAttribute.toString()));\n-\n-      // Validate attributes\n-      if (!nodeAttributes.stream().allMatch(\n-          nodeAttribute -\u003e NodeAttribute.PREFIX_DISTRIBUTED\n-              .equals(nodeAttribute.getAttributeKey().getAttributePrefix()))) {\n-        // All attributes must be in same prefix: nm.yarn.io.\n-        // Since we have the checks in NM to make sure attributes reported\n-        // in HB are with correct prefix, so it should not reach here.\n-        LOG.warn(\"Reject invalid node attributes from host: \"\n-            + nodeId.toString() + \", attributes in HB must have prefix \"\n-            + NodeAttribute.PREFIX_DISTRIBUTED);\n-      } else {\n-        // Replace all distributed node attributes associated with this host\n-        // with the new reported attributes in node attribute manager.\n-        this.rmContext.getNodeAttributesManager()\n-            .replaceNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n-                ImmutableMap.of(nodeId.getHost(), nodeAttributes));\n+    if (request.getNodeAttributes() !\u003d null) {\n+      try {\n+        // update node attributes if necessary then update heartbeat response\n+        updateNodeAttributesIfNecessary(nodeId, request.getNodeAttributes());\n+        nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(true);\n+      } catch (IOException ex) {\n+        //ensure the error message is captured and sent across in response\n+        String errorMsg \u003d\n+            nodeHeartBeatResponse.getDiagnosticsMessage() \u003d\u003d null ?\n+                ex.getMessage() :\n+                nodeHeartBeatResponse.getDiagnosticsMessage() + \"\\n\" + ex\n+                    .getMessage();\n+        nodeHeartBeatResponse.setDiagnosticsMessage(errorMsg);\n+        nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (getNextResponseId(\n        remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n            .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n        YarnServerBuilderUtils.newNodeHeartbeatResponse(\n            getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n            NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n    rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n\n    // 8. Get node\u0027s attributes and update node-to-attributes mapping\n    // in RMNodeAttributeManager.\n    if (request.getNodeAttributes() !\u003d null) {\n      try {\n        // update node attributes if necessary then update heartbeat response\n        updateNodeAttributesIfNecessary(nodeId, request.getNodeAttributes());\n        nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        String errorMsg \u003d\n            nodeHeartBeatResponse.getDiagnosticsMessage() \u003d\u003d null ?\n                ex.getMessage() :\n                nodeHeartBeatResponse.getDiagnosticsMessage() + \"\\n\" + ex\n                    .getMessage();\n        nodeHeartBeatResponse.setDiagnosticsMessage(errorMsg);\n        nodeHeartBeatResponse.setAreNodeAttributesAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8103. Add CLI interface to query node attributes. Contributed by Bibin A Chundatt.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "8cf6a9a2bde9d4ccad95a514885634792889ec7f",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,179 +1,175 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n     this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (getNextResponseId(\n         remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n             .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n     if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n         decommissioningWatcher.checkReadyToBeDecommissioned(\n             rmNode.getNodeID())) {\n       String message \u003d \"DECOMMISSIONING \" + nodeId +\n           \" is ready to be decommissioned\";\n       LOG.info(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       this.nmLivelinessMonitor.unregister(nodeId);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     boolean timelineV2Enabled \u003d\n         YarnConfiguration.timelineServiceV2Enabled(getConfig());\n     if (timelineV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       updateAppCollectorsMap(request);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n         YarnServerBuilderUtils.newNodeHeartbeatResponse(\n             getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n             NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n     rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n \n     // 8. Get node\u0027s attributes and update node-to-attributes mapping\n     // in RMNodeAttributeManager.\n     Set\u003cNodeAttribute\u003e nodeAttributes \u003d request.getNodeAttributes();\n     if (nodeAttributes !\u003d null \u0026\u0026 !nodeAttributes.isEmpty()) {\n       nodeAttributes.forEach(nodeAttribute -\u003e\n           LOG.debug(nodeId.toString() + \" ATTRIBUTE : \"\n               + nodeAttribute.toString()));\n \n       // Validate attributes\n       if (!nodeAttributes.stream().allMatch(\n           nodeAttribute -\u003e NodeAttribute.PREFIX_DISTRIBUTED\n               .equals(nodeAttribute.getAttributeKey().getAttributePrefix()))) {\n         // All attributes must be in same prefix: nm.yarn.io.\n         // Since we have the checks in NM to make sure attributes reported\n         // in HB are with correct prefix, so it should not reach here.\n         LOG.warn(\"Reject invalid node attributes from host: \"\n             + nodeId.toString() + \", attributes in HB must have prefix \"\n             + NodeAttribute.PREFIX_DISTRIBUTED);\n       } else {\n         // Replace all distributed node attributes associated with this host\n         // with the new reported attributes in node attribute manager.\n         this.rmContext.getNodeAttributesManager()\n             .replaceNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n                 ImmutableMap.of(nodeId.getHost(), nodeAttributes));\n-\n-        // Update node attributes to RMNode\n-        rmNode.setNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n-            nodeAttributes);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (getNextResponseId(\n        remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n            .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n        YarnServerBuilderUtils.newNodeHeartbeatResponse(\n            getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n            NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n    rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n\n    // 8. Get node\u0027s attributes and update node-to-attributes mapping\n    // in RMNodeAttributeManager.\n    Set\u003cNodeAttribute\u003e nodeAttributes \u003d request.getNodeAttributes();\n    if (nodeAttributes !\u003d null \u0026\u0026 !nodeAttributes.isEmpty()) {\n      nodeAttributes.forEach(nodeAttribute -\u003e\n          LOG.debug(nodeId.toString() + \" ATTRIBUTE : \"\n              + nodeAttribute.toString()));\n\n      // Validate attributes\n      if (!nodeAttributes.stream().allMatch(\n          nodeAttribute -\u003e NodeAttribute.PREFIX_DISTRIBUTED\n              .equals(nodeAttribute.getAttributeKey().getAttributePrefix()))) {\n        // All attributes must be in same prefix: nm.yarn.io.\n        // Since we have the checks in NM to make sure attributes reported\n        // in HB are with correct prefix, so it should not reach here.\n        LOG.warn(\"Reject invalid node attributes from host: \"\n            + nodeId.toString() + \", attributes in HB must have prefix \"\n            + NodeAttribute.PREFIX_DISTRIBUTED);\n      } else {\n        // Replace all distributed node attributes associated with this host\n        // with the new reported attributes in node attribute manager.\n        this.rmContext.getNodeAttributesManager()\n            .replaceNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n                ImmutableMap.of(nodeId.getHost(), nodeAttributes));\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "8cf6a9a2bde9d4ccad95a514885634792889ec7f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7892. Revisit NodeAttribute class structure. Contributed by  Naganarasimha G R.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "8cf6a9a2bde9d4ccad95a514885634792889ec7f",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "89b3ebd11ea93bf9d3521677f0fb9ab3c373a6ca",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,179 +1,179 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n     this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (getNextResponseId(\n         remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n             .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n     if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n         decommissioningWatcher.checkReadyToBeDecommissioned(\n             rmNode.getNodeID())) {\n       String message \u003d \"DECOMMISSIONING \" + nodeId +\n           \" is ready to be decommissioned\";\n       LOG.info(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       this.nmLivelinessMonitor.unregister(nodeId);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     boolean timelineV2Enabled \u003d\n         YarnConfiguration.timelineServiceV2Enabled(getConfig());\n     if (timelineV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       updateAppCollectorsMap(request);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n         YarnServerBuilderUtils.newNodeHeartbeatResponse(\n             getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n             NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n     rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n \n     // 8. Get node\u0027s attributes and update node-to-attributes mapping\n     // in RMNodeAttributeManager.\n     Set\u003cNodeAttribute\u003e nodeAttributes \u003d request.getNodeAttributes();\n     if (nodeAttributes !\u003d null \u0026\u0026 !nodeAttributes.isEmpty()) {\n       nodeAttributes.forEach(nodeAttribute -\u003e\n           LOG.debug(nodeId.toString() + \" ATTRIBUTE : \"\n               + nodeAttribute.toString()));\n \n       // Validate attributes\n       if (!nodeAttributes.stream().allMatch(\n           nodeAttribute -\u003e NodeAttribute.PREFIX_DISTRIBUTED\n-              .equals(nodeAttribute.getAttributePrefix()))) {\n+              .equals(nodeAttribute.getAttributeKey().getAttributePrefix()))) {\n         // All attributes must be in same prefix: nm.yarn.io.\n         // Since we have the checks in NM to make sure attributes reported\n         // in HB are with correct prefix, so it should not reach here.\n         LOG.warn(\"Reject invalid node attributes from host: \"\n             + nodeId.toString() + \", attributes in HB must have prefix \"\n             + NodeAttribute.PREFIX_DISTRIBUTED);\n       } else {\n         // Replace all distributed node attributes associated with this host\n         // with the new reported attributes in node attribute manager.\n         this.rmContext.getNodeAttributesManager()\n             .replaceNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n                 ImmutableMap.of(nodeId.getHost(), nodeAttributes));\n \n         // Update node attributes to RMNode\n         rmNode.setNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n             nodeAttributes);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (getNextResponseId(\n        remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n            .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n        YarnServerBuilderUtils.newNodeHeartbeatResponse(\n            getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n            NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n    rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n\n    // 8. Get node\u0027s attributes and update node-to-attributes mapping\n    // in RMNodeAttributeManager.\n    Set\u003cNodeAttribute\u003e nodeAttributes \u003d request.getNodeAttributes();\n    if (nodeAttributes !\u003d null \u0026\u0026 !nodeAttributes.isEmpty()) {\n      nodeAttributes.forEach(nodeAttribute -\u003e\n          LOG.debug(nodeId.toString() + \" ATTRIBUTE : \"\n              + nodeAttribute.toString()));\n\n      // Validate attributes\n      if (!nodeAttributes.stream().allMatch(\n          nodeAttribute -\u003e NodeAttribute.PREFIX_DISTRIBUTED\n              .equals(nodeAttribute.getAttributeKey().getAttributePrefix()))) {\n        // All attributes must be in same prefix: nm.yarn.io.\n        // Since we have the checks in NM to make sure attributes reported\n        // in HB are with correct prefix, so it should not reach here.\n        LOG.warn(\"Reject invalid node attributes from host: \"\n            + nodeId.toString() + \", attributes in HB must have prefix \"\n            + NodeAttribute.PREFIX_DISTRIBUTED);\n      } else {\n        // Replace all distributed node attributes associated with this host\n        // with the new reported attributes in node attribute manager.\n        this.rmContext.getNodeAttributesManager()\n            .replaceNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n                ImmutableMap.of(nodeId.getHost(), nodeAttributes));\n\n        // Update node attributes to RMNode\n        rmNode.setNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n            nodeAttributes);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "89b3ebd11ea93bf9d3521677f0fb9ab3c373a6ca": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8092. Expose Node Attributes info via RM nodes REST API. Contributed by Weiwei Yang.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "89b3ebd11ea93bf9d3521677f0fb9ab3c373a6ca",
      "commitAuthor": "Sunil G",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "3b3b6efe2103244febfe6b4f61989e92bd7bb08a",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,175 +1,179 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n     this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (getNextResponseId(\n         remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n             .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n     if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n         decommissioningWatcher.checkReadyToBeDecommissioned(\n             rmNode.getNodeID())) {\n       String message \u003d \"DECOMMISSIONING \" + nodeId +\n           \" is ready to be decommissioned\";\n       LOG.info(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       this.nmLivelinessMonitor.unregister(nodeId);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     boolean timelineV2Enabled \u003d\n         YarnConfiguration.timelineServiceV2Enabled(getConfig());\n     if (timelineV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       updateAppCollectorsMap(request);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n         YarnServerBuilderUtils.newNodeHeartbeatResponse(\n             getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n             NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n     rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n \n     // 8. Get node\u0027s attributes and update node-to-attributes mapping\n     // in RMNodeAttributeManager.\n     Set\u003cNodeAttribute\u003e nodeAttributes \u003d request.getNodeAttributes();\n     if (nodeAttributes !\u003d null \u0026\u0026 !nodeAttributes.isEmpty()) {\n       nodeAttributes.forEach(nodeAttribute -\u003e\n           LOG.debug(nodeId.toString() + \" ATTRIBUTE : \"\n               + nodeAttribute.toString()));\n \n       // Validate attributes\n       if (!nodeAttributes.stream().allMatch(\n           nodeAttribute -\u003e NodeAttribute.PREFIX_DISTRIBUTED\n               .equals(nodeAttribute.getAttributePrefix()))) {\n         // All attributes must be in same prefix: nm.yarn.io.\n         // Since we have the checks in NM to make sure attributes reported\n         // in HB are with correct prefix, so it should not reach here.\n         LOG.warn(\"Reject invalid node attributes from host: \"\n             + nodeId.toString() + \", attributes in HB must have prefix \"\n             + NodeAttribute.PREFIX_DISTRIBUTED);\n       } else {\n         // Replace all distributed node attributes associated with this host\n         // with the new reported attributes in node attribute manager.\n         this.rmContext.getNodeAttributesManager()\n             .replaceNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n                 ImmutableMap.of(nodeId.getHost(), nodeAttributes));\n+\n+        // Update node attributes to RMNode\n+        rmNode.setNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n+            nodeAttributes);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (getNextResponseId(\n        remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n            .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n        YarnServerBuilderUtils.newNodeHeartbeatResponse(\n            getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n            NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n    rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n\n    // 8. Get node\u0027s attributes and update node-to-attributes mapping\n    // in RMNodeAttributeManager.\n    Set\u003cNodeAttribute\u003e nodeAttributes \u003d request.getNodeAttributes();\n    if (nodeAttributes !\u003d null \u0026\u0026 !nodeAttributes.isEmpty()) {\n      nodeAttributes.forEach(nodeAttribute -\u003e\n          LOG.debug(nodeId.toString() + \" ATTRIBUTE : \"\n              + nodeAttribute.toString()));\n\n      // Validate attributes\n      if (!nodeAttributes.stream().allMatch(\n          nodeAttribute -\u003e NodeAttribute.PREFIX_DISTRIBUTED\n              .equals(nodeAttribute.getAttributePrefix()))) {\n        // All attributes must be in same prefix: nm.yarn.io.\n        // Since we have the checks in NM to make sure attributes reported\n        // in HB are with correct prefix, so it should not reach here.\n        LOG.warn(\"Reject invalid node attributes from host: \"\n            + nodeId.toString() + \", attributes in HB must have prefix \"\n            + NodeAttribute.PREFIX_DISTRIBUTED);\n      } else {\n        // Replace all distributed node attributes associated with this host\n        // with the new reported attributes in node attribute manager.\n        this.rmContext.getNodeAttributesManager()\n            .replaceNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n                ImmutableMap.of(nodeId.getHost(), nodeAttributes));\n\n        // Update node attributes to RMNode\n        rmNode.setNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n            nodeAttributes);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "3b3b6efe2103244febfe6b4f61989e92bd7bb08a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7871. Node attributes reporting from NM to RM. Contributed by Weiwei Yang.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "3b3b6efe2103244febfe6b4f61989e92bd7bb08a",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "15/03/18 1:26 PM",
      "commitNameOld": "4bf622043f034835d65ff2a4785b9b06d0ef1fd2",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 180.59,
      "commitsBetweenForRepo": 1915,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,175 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n     this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (getNextResponseId(\n         remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n             .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n     if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n         decommissioningWatcher.checkReadyToBeDecommissioned(\n             rmNode.getNodeID())) {\n       String message \u003d \"DECOMMISSIONING \" + nodeId +\n           \" is ready to be decommissioned\";\n       LOG.info(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       this.nmLivelinessMonitor.unregister(nodeId);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     boolean timelineV2Enabled \u003d\n         YarnConfiguration.timelineServiceV2Enabled(getConfig());\n     if (timelineV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       updateAppCollectorsMap(request);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n         YarnServerBuilderUtils.newNodeHeartbeatResponse(\n             getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n             NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n     rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n+\n+    // 8. Get node\u0027s attributes and update node-to-attributes mapping\n+    // in RMNodeAttributeManager.\n+    Set\u003cNodeAttribute\u003e nodeAttributes \u003d request.getNodeAttributes();\n+    if (nodeAttributes !\u003d null \u0026\u0026 !nodeAttributes.isEmpty()) {\n+      nodeAttributes.forEach(nodeAttribute -\u003e\n+          LOG.debug(nodeId.toString() + \" ATTRIBUTE : \"\n+              + nodeAttribute.toString()));\n+\n+      // Validate attributes\n+      if (!nodeAttributes.stream().allMatch(\n+          nodeAttribute -\u003e NodeAttribute.PREFIX_DISTRIBUTED\n+              .equals(nodeAttribute.getAttributePrefix()))) {\n+        // All attributes must be in same prefix: nm.yarn.io.\n+        // Since we have the checks in NM to make sure attributes reported\n+        // in HB are with correct prefix, so it should not reach here.\n+        LOG.warn(\"Reject invalid node attributes from host: \"\n+            + nodeId.toString() + \", attributes in HB must have prefix \"\n+            + NodeAttribute.PREFIX_DISTRIBUTED);\n+      } else {\n+        // Replace all distributed node attributes associated with this host\n+        // with the new reported attributes in node attribute manager.\n+        this.rmContext.getNodeAttributesManager()\n+            .replaceNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n+                ImmutableMap.of(nodeId.getHost(), nodeAttributes));\n+      }\n+    }\n+\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (getNextResponseId(\n        remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n            .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n        YarnServerBuilderUtils.newNodeHeartbeatResponse(\n            getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n            NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n    rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n\n    // 8. Get node\u0027s attributes and update node-to-attributes mapping\n    // in RMNodeAttributeManager.\n    Set\u003cNodeAttribute\u003e nodeAttributes \u003d request.getNodeAttributes();\n    if (nodeAttributes !\u003d null \u0026\u0026 !nodeAttributes.isEmpty()) {\n      nodeAttributes.forEach(nodeAttribute -\u003e\n          LOG.debug(nodeId.toString() + \" ATTRIBUTE : \"\n              + nodeAttribute.toString()));\n\n      // Validate attributes\n      if (!nodeAttributes.stream().allMatch(\n          nodeAttribute -\u003e NodeAttribute.PREFIX_DISTRIBUTED\n              .equals(nodeAttribute.getAttributePrefix()))) {\n        // All attributes must be in same prefix: nm.yarn.io.\n        // Since we have the checks in NM to make sure attributes reported\n        // in HB are with correct prefix, so it should not reach here.\n        LOG.warn(\"Reject invalid node attributes from host: \"\n            + nodeId.toString() + \", attributes in HB must have prefix \"\n            + NodeAttribute.PREFIX_DISTRIBUTED);\n      } else {\n        // Replace all distributed node attributes associated with this host\n        // with the new reported attributes in node attribute manager.\n        this.rmContext.getNodeAttributesManager()\n            .replaceNodeAttributes(NodeAttribute.PREFIX_DISTRIBUTED,\n                ImmutableMap.of(nodeId.getHost(), nodeAttributes));\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "ff8378eb1b960c72d18a984c7e5d145b407ca11a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7102. NM heartbeat stuck when responseId overflows MAX_INT. Contributed by Botong Huang\n",
      "commitDate": "25/01/18 3:47 PM",
      "commitName": "ff8378eb1b960c72d18a984c7e5d145b407ca11a",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "759114b0063907d4c07ea6ee261e861bf5cc3a9a",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 135.31,
      "commitsBetweenForRepo": 980,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,147 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n     this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n-    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n-        .getResponseId()) {\n+    if (getNextResponseId(\n+        remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n+            .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n-    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n+    } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n     if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n         decommissioningWatcher.checkReadyToBeDecommissioned(\n             rmNode.getNodeID())) {\n       String message \u003d \"DECOMMISSIONING \" + nodeId +\n           \" is ready to be decommissioned\";\n       LOG.info(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       this.nmLivelinessMonitor.unregister(nodeId);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     boolean timelineV2Enabled \u003d\n         YarnConfiguration.timelineServiceV2Enabled(getConfig());\n     if (timelineV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       updateAppCollectorsMap(request);\n     }\n \n     // Heartbeat response\n-    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n-        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n-            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n-            nextHeartBeatInterval);\n-    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n-    rmNode.updateNodeHeartbeatResponseForUpdatedContainers(\n-        nodeHeartBeatResponse);\n+    NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n+        YarnServerBuilderUtils.newNodeHeartbeatResponse(\n+            getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n+            NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n+    rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n-        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n+        new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (getNextResponseId(\n        remoteNodeStatus.getResponseId()) \u003d\u003d lastNodeHeartbeatResponse\n            .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() !\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d\n        YarnServerBuilderUtils.newNodeHeartbeatResponse(\n            getNextResponseId(lastNodeHeartbeatResponse.getResponseId()),\n            NodeAction.NORMAL, null, null, null, null, nextHeartBeatInterval);\n    rmNode.setAndUpdateNodeHeartbeatResponse(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "092fead5d9875fb3760206bcdd76cdafec5e9481": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5792. Adopt the id prefix for YARN, MR, and DS entities. Contributed by Varun Saxena.\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "092fead5d9875fb3760206bcdd76cdafec5e9481",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "91d3443806555d336d27cf8cc9250a0fb85b03a9",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,148 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n     this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n-    boolean timelineV2Enabled \u003d\n-        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n-    if (timelineV2Enabled) {\n-      // Check \u0026 update collectors info from request.\n-      updateAppCollectorsMap(request);\n-    }\n-\n     // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n     if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n         decommissioningWatcher.checkReadyToBeDecommissioned(\n             rmNode.getNodeID())) {\n       String message \u003d \"DECOMMISSIONING \" + nodeId +\n           \" is ready to be decommissioned\";\n       LOG.info(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       this.nmLivelinessMonitor.unregister(nodeId);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n+    boolean timelineV2Enabled \u003d\n+        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n+    if (timelineV2Enabled) {\n+      // Check \u0026 update collectors info from request.\n+      updateAppCollectorsMap(request);\n+    }\n+\n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForUpdatedContainers(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForUpdatedContainers(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "78b7e070d8009c78665a2baa64fe888788f53e69": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5638. Introduce a collector timestamp to uniquely identify collectors creation order in collector discovery. Contributed by Li Lu.\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "78b7e070d8009c78665a2baa64fe888788f53e69",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "20/08/17 7:54 AM",
      "commitNameOld": "8410d862d3a72740f461ef91dddb5325955e1ca5",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 9.63,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,148 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n     this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     boolean timelineV2Enabled \u003d\n         YarnConfiguration.timelineServiceV2Enabled(getConfig());\n     if (timelineV2Enabled) {\n       // Check \u0026 update collectors info from request.\n-      // TODO make sure it won\u0027t have race condition issue for AM failed over\n-      // case that the older registration could possible override the newer\n-      // one.\n       updateAppCollectorsMap(request);\n     }\n \n     // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n     if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n         decommissioningWatcher.checkReadyToBeDecommissioned(\n             rmNode.getNodeID())) {\n       String message \u003d \"DECOMMISSIONING \" + nodeId +\n           \" is ready to be decommissioned\";\n       LOG.info(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       this.nmLivelinessMonitor.unregister(nodeId);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForUpdatedContainers(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      updateAppCollectorsMap(request);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForUpdatedContainers(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "8410d862d3a72740f461ef91dddb5325955e1ca5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6979. Add flag to notify all types of container updates to NM via NodeHeartbeatResponse. (Kartheek Muthyala via asuresh)\n",
      "commitDate": "20/08/17 7:54 AM",
      "commitName": "8410d862d3a72740f461ef91dddb5325955e1ca5",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "05/06/17 1:16 PM",
      "commitNameOld": "7311015ace498e03aad88bcbe1581916803ceaba",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 75.78,
      "commitsBetweenForRepo": 454,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,151 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n     this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     boolean timelineV2Enabled \u003d\n         YarnConfiguration.timelineServiceV2Enabled(getConfig());\n     if (timelineV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       // TODO make sure it won\u0027t have race condition issue for AM failed over\n       // case that the older registration could possible override the newer\n       // one.\n       updateAppCollectorsMap(request);\n     }\n \n     // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n     if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n         decommissioningWatcher.checkReadyToBeDecommissioned(\n             rmNode.getNodeID())) {\n       String message \u003d \"DECOMMISSIONING \" + nodeId +\n           \" is ready to be decommissioned\";\n       LOG.info(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       this.nmLivelinessMonitor.unregister(nodeId);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n-    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n+    rmNode.updateNodeHeartbeatResponseForUpdatedContainers(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      // TODO make sure it won\u0027t have race condition issue for AM failed over\n      // case that the older registration could possible override the newer\n      // one.\n      updateAppCollectorsMap(request);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForUpdatedContainers(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "0da69c324dee9baab0f0b9700db1cc5b623f8421": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4676. Automatic and Asynchronous Decommissioning Nodes Status Tracking. Contributed by Diniel Zhi.\n(cherry picked from commit d464483bf7f0b3e3be3ba32cd6c3eee546747ab5)\n\nConflicts:\n\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNode.java\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmnode/RMNodeImpl.java\n",
      "commitDate": "18/08/16 7:27 AM",
      "commitName": "0da69c324dee9baab0f0b9700db1cc5b623f8421",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "06f0b50a284455ffd5857cb42f386e92d121d0e6",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 38.95,
      "commitsBetweenForRepo": 318,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,151 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n+    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     boolean timelineV2Enabled \u003d\n         YarnConfiguration.timelineServiceV2Enabled(getConfig());\n     if (timelineV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       // TODO make sure it won\u0027t have race condition issue for AM failed over\n       // case that the older registration could possible override the newer\n       // one.\n       updateAppCollectorsMap(request);\n     }\n \n+    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n+    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n+        decommissioningWatcher.checkReadyToBeDecommissioned(\n+            rmNode.getNodeID())) {\n+      String message \u003d \"DECOMMISSIONING \" + nodeId +\n+          \" is ready to be decommissioned\";\n+      LOG.info(message);\n+      this.rmContext.getDispatcher().getEventHandler().handle(\n+          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n+      this.nmLivelinessMonitor.unregister(nodeId);\n+      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n+          NodeAction.SHUTDOWN, message);\n+    }\n+\n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n    this.decommissioningWatcher.update(rmNode, remoteNodeStatus);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      // TODO make sure it won\u0027t have race condition issue for AM failed over\n      // case that the older registration could possible override the newer\n      // one.\n      updateAppCollectorsMap(request);\n    }\n\n    // Evaluate whether a DECOMMISSIONING node is ready to be DECOMMISSIONED.\n    if (rmNode.getState() \u003d\u003d NodeState.DECOMMISSIONING \u0026\u0026\n        decommissioningWatcher.checkReadyToBeDecommissioned(\n            rmNode.getNodeID())) {\n      String message \u003d \"DECOMMISSIONING \" + nodeId +\n          \" is ready to be decommissioned\";\n      LOG.info(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      this.nmLivelinessMonitor.unregister(nodeId);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "06f0b50a284455ffd5857cb42f386e92d121d0e6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4644. TestRMRestart fails and findbugs issue in YARN-2928 branch (Varun Saxena via Naganarasimha G R)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "06f0b50a284455ffd5857cb42f386e92d121d0e6",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "829cceebc0b4bcde2ee0d45c8366aa9fd5cb39e4",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,138 +1,136 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     boolean timelineV2Enabled \u003d\n         YarnConfiguration.timelineServiceV2Enabled(getConfig());\n     if (timelineV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       // TODO make sure it won\u0027t have race condition issue for AM failed over\n       // case that the older registration could possible override the newer\n       // one.\n       updateAppCollectorsMap(request);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n       setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n           nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n-    List\u003cApplicationId\u003e keepAliveApps \u003d\n-        remoteNodeStatus.getKeepAliveApplications();\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      // TODO make sure it won\u0027t have race condition issue for AM failed over\n      // case that the older registration could possible override the newer\n      // one.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "829cceebc0b4bcde2ee0d45c8366aa9fd5cb39e4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3586. RM to only get back addresses of Collectors that NM needs to know.\n(Junping Du via Varun Saxena).\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "829cceebc0b4bcde2ee0d45c8366aa9fd5cb39e4",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,139 +1,138 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     boolean timelineV2Enabled \u003d\n         YarnConfiguration.timelineServiceV2Enabled(getConfig());\n     if (timelineV2Enabled) {\n       // Check \u0026 update collectors info from request.\n       // TODO make sure it won\u0027t have race condition issue for AM failed over\n       // case that the older registration could possible override the newer\n       // one.\n       updateAppCollectorsMap(request);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n-    List\u003cApplicationId\u003e keepAliveApps \u003d\n-        remoteNodeStatus.getKeepAliveApplications();\n-    if (timelineV2Enabled \u0026\u0026 keepAliveApps !\u003d null) {\n+    if (timelineV2Enabled) {\n       // Return collectors\u0027 map that NM needs to know\n-      // TODO we should optimize this to only include collector info that NM\n-      // doesn\u0027t know yet.\n-      setAppCollectorsMapToResponse(keepAliveApps, nodeHeartBeatResponse);\n+      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n+          nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n+    List\u003cApplicationId\u003e keepAliveApps \u003d\n+        remoteNodeStatus.getKeepAliveApplications();\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      // TODO make sure it won\u0027t have race condition issue for AM failed over\n      // case that the older registration could possible override the newer\n      // one.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    if (timelineV2Enabled) {\n      // Return collectors\u0027 map that NM needs to know\n      setAppCollectorsMapToResponse(rmNode.getRunningApps(),\n          nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    List\u003cApplicationId\u003e keepAliveApps \u003d\n        remoteNodeStatus.getKeepAliveApplications();\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "dc1f306fdc83749f9675b89326e26c73b9ff8f86",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,139 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n-    // Check \u0026 update collectors info from request.\n-    // TODO make sure it won\u0027t have race condition issue for AM failed over case\n-    // that the older registration could possible override the newer one.\n-    updateAppCollectorsMap(request);\n+    boolean timelineV2Enabled \u003d\n+        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n+    if (timelineV2Enabled) {\n+      // Check \u0026 update collectors info from request.\n+      // TODO make sure it won\u0027t have race condition issue for AM failed over\n+      // case that the older registration could possible override the newer\n+      // one.\n+      updateAppCollectorsMap(request);\n+    }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n-    // Return collectors\u0027 map that NM needs to know\n-    // TODO we should optimize this to only include collector info that NM\n-    // doesn\u0027t know yet.\n     List\u003cApplicationId\u003e keepAliveApps \u003d\n         remoteNodeStatus.getKeepAliveApplications();\n-    if (keepAliveApps !\u003d null) {\n+    if (timelineV2Enabled \u0026\u0026 keepAliveApps !\u003d null) {\n+      // Return collectors\u0027 map that NM needs to know\n+      // TODO we should optimize this to only include collector info that NM\n+      // doesn\u0027t know yet.\n       setAppCollectorsMapToResponse(keepAliveApps, nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    boolean timelineV2Enabled \u003d\n        YarnConfiguration.timelineServiceV2Enabled(getConfig());\n    if (timelineV2Enabled) {\n      // Check \u0026 update collectors info from request.\n      // TODO make sure it won\u0027t have race condition issue for AM failed over\n      // case that the older registration could possible override the newer\n      // one.\n      updateAppCollectorsMap(request);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    List\u003cApplicationId\u003e keepAliveApps \u003d\n        remoteNodeStatus.getKeepAliveApplications();\n    if (timelineV2Enabled \u0026\u0026 keepAliveApps !\u003d null) {\n      // Return collectors\u0027 map that NM needs to know\n      // TODO we should optimize this to only include collector info that NM\n      // doesn\u0027t know yet.\n      setAppCollectorsMapToResponse(keepAliveApps, nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "2188a07e5bea1da26bf679ca0ece26ab596d3438": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3333. Rename TimelineAggregator etc. to TimelineCollector. Contributed by Sangjin Lee\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "9b5636408005676ae580f8d929f8e912c27828e7",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,134 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n-    \n-    // Check \u0026 update aggregators info from request.\n+\n+    // Check \u0026 update collectors info from request.\n     // TODO make sure it won\u0027t have race condition issue for AM failed over case\n     // that the older registration could possible override the newer one.\n-    updateAppAggregatorsMap(request);\n+    updateAppCollectorsMap(request);\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n-    \n-    // Return aggregators\u0027 map that NM needs to know\n-    // TODO we should optimize this to only include aggreator info that NM \n+\n+    // Return collectors\u0027 map that NM needs to know\n+    // TODO we should optimize this to only include collector info that NM\n     // doesn\u0027t know yet.\n-    List\u003cApplicationId\u003e keepAliveApps \u003d remoteNodeStatus.getKeepAliveApplications();\n+    List\u003cApplicationId\u003e keepAliveApps \u003d\n+        remoteNodeStatus.getKeepAliveApplications();\n     if (keepAliveApps !\u003d null) {\n-      setAppAggregatorsMapToResponse(keepAliveApps, nodeHeartBeatResponse);\n+      setAppCollectorsMapToResponse(keepAliveApps, nodeHeartBeatResponse);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Check \u0026 update collectors info from request.\n    // TODO make sure it won\u0027t have race condition issue for AM failed over case\n    // that the older registration could possible override the newer one.\n    updateAppCollectorsMap(request);\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // Return collectors\u0027 map that NM needs to know\n    // TODO we should optimize this to only include collector info that NM\n    // doesn\u0027t know yet.\n    List\u003cApplicationId\u003e keepAliveApps \u003d\n        remoteNodeStatus.getKeepAliveApplications();\n    if (keepAliveApps !\u003d null) {\n      setAppCollectorsMapToResponse(keepAliveApps, nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "9b5636408005676ae580f8d929f8e912c27828e7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3039. Implemented the app-level timeline aggregator discovery service. Contributed by Junping Du.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "9b5636408005676ae580f8d929f8e912c27828e7",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "08/07/16 4:14 AM",
      "commitNameOld": "30ee57ceb1e80c30ea3adfe7736d4d4c7d5c8386",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 2.19,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,133 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n+    \n+    // Check \u0026 update aggregators info from request.\n+    // TODO make sure it won\u0027t have race condition issue for AM failed over case\n+    // that the older registration could possible override the newer one.\n+    updateAppAggregatorsMap(request);\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n+    \n+    // Return aggregators\u0027 map that NM needs to know\n+    // TODO we should optimize this to only include aggreator info that NM \n+    // doesn\u0027t know yet.\n+    List\u003cApplicationId\u003e keepAliveApps \u003d remoteNodeStatus.getKeepAliveApplications();\n+    if (keepAliveApps !\u003d null) {\n+      setAppAggregatorsMapToResponse(keepAliveApps, nodeHeartBeatResponse);\n+    }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n     // if so, send updated resource back to NM.\n     String nid \u003d nodeId.toString();\n     Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n     // sync back with new resource if not null.\n     if (capability !\u003d null) {\n       nodeHeartBeatResponse.setResource(capability);\n     }\n \n     // 7. Send Container Queuing Limits back to the Node. This will be used by\n     // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n    \n    // Check \u0026 update aggregators info from request.\n    // TODO make sure it won\u0027t have race condition issue for AM failed over case\n    // that the older registration could possible override the newer one.\n    updateAppAggregatorsMap(request);\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n    \n    // Return aggregators\u0027 map that NM needs to know\n    // TODO we should optimize this to only include aggreator info that NM \n    // doesn\u0027t know yet.\n    List\u003cApplicationId\u003e keepAliveApps \u003d remoteNodeStatus.getKeepAliveApplications();\n    if (keepAliveApps !\u003d null) {\n      setAppAggregatorsMapToResponse(keepAliveApps, nodeHeartBeatResponse);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4832. NM side resource value should get updated if change applied in RM side. Contributed by Junping Du\n",
      "commitDate": "17/05/16 12:52 PM",
      "commitName": "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc",
      "commitAuthor": "Jian He",
      "commitDateOld": "13/05/16 1:38 PM",
      "commitNameOld": "f0ac18d001d97914a9ee810b1fab56c5cebff830",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 3.97,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,120 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n-    // 6. Send Container Queuing Limits back to the Node. This will be used by\n-    //    the node to truncate the number of Containers queued for execution.\n+    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n+    // if so, send updated resource back to NM.\n+    String nid \u003d nodeId.toString();\n+    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n+    // sync back with new resource if not null.\n+    if (capability !\u003d null) {\n+      nodeHeartBeatResponse.setResource(capability);\n+    }\n+\n+    // 7. Send Container Queuing Limits back to the Node. This will be used by\n+    // the node to truncate the number of Containers queued for execution.\n     if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n       nodeHeartBeatResponse.setContainerQueuingLimit(\n           this.rmContext.getNodeManagerQueueLimitCalculator()\n               .createContainerQueuingLimit());\n     }\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. check if node\u0027s capacity is load from dynamic-resources.xml\n    // if so, send updated resource back to NM.\n    String nid \u003d nodeId.toString();\n    Resource capability \u003d loadNodeResourceFromDRConfiguration(nid);\n    // sync back with new resource if not null.\n    if (capability !\u003d null) {\n      nodeHeartBeatResponse.setResource(capability);\n    }\n\n    // 7. Send Container Queuing Limits back to the Node. This will be used by\n    // the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "f0ac18d001d97914a9ee810b1fab56c5cebff830": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2888. Corrective mechanisms for rebalancing NM container queues. (asuresh)\n",
      "commitDate": "13/05/16 1:38 PM",
      "commitName": "f0ac18d001d97914a9ee810b1fab56c5cebff830",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "11/04/16 8:51 AM",
      "commitNameOld": "2a5da97f81d69b481e4d1324a47e64bb55b9407c",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 32.2,
      "commitsBetweenForRepo": 207,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,111 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n+    // 6. Send Container Queuing Limits back to the Node. This will be used by\n+    //    the node to truncate the number of Containers queued for execution.\n+    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n+      nodeHeartBeatResponse.setContainerQueuingLimit(\n+          this.rmContext.getNodeManagerQueueLimitCalculator()\n+              .createContainerQueuingLimit());\n+    }\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    // 6. Send Container Queuing Limits back to the Node. This will be used by\n    //    the node to truncate the number of Containers queued for execution.\n    if (this.rmContext.getNodeManagerQueueLimitCalculator() !\u003d null) {\n      nodeHeartBeatResponse.setContainerQueuingLimit(\n          this.rmContext.getNodeManagerQueueLimitCalculator()\n              .createContainerQueuingLimit());\n    }\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "2a5da97f81d69b481e4d1324a47e64bb55b9407c": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4311. Removing nodes from include and exclude lists will not remove them from decommissioned nodes list. Contributed by Kuhu Shukla\"\n\nThis reverts commit 1cbcd4a491e6a57d466c2897335614dc6770b475.\n",
      "commitDate": "11/04/16 8:51 AM",
      "commitName": "2a5da97f81d69b481e4d1324a47e64bb55b9407c",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "05/04/16 6:40 AM",
      "commitNameOld": "1cbcd4a491e6a57d466c2897335614dc6770b475",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 6.09,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,104 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n-    if ((!this.nodesListManager.isValidNode(nodeId.getHost()) \u0026\u0026\n-        !isNodeInDecommissioning(nodeId)) ||\n-        this.nodesListManager.isUntrackedNode(nodeId.getHost())) {\n+    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n+        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "1cbcd4a491e6a57d466c2897335614dc6770b475": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4311. Removing nodes from include and exclude lists will not remove them from decommissioned nodes list. Contributed by Kuhu Shukla\n",
      "commitDate": "05/04/16 6:40 AM",
      "commitName": "1cbcd4a491e6a57d466c2897335614dc6770b475",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "28/03/16 11:12 AM",
      "commitNameOld": "524bc3c33aff301c1a8d60ed8e6a3b240e305045",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 7.81,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,105 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n-    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n-        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n+    if ((!this.nodesListManager.isValidNode(nodeId.getHost()) \u0026\u0026\n+        !isNodeInDecommissioning(nodeId)) ||\n+        this.nodesListManager.isUntrackedNode(nodeId.getHost())) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if ((!this.nodesListManager.isValidNode(nodeId.getHost()) \u0026\u0026\n        !isNodeInDecommissioning(nodeId)) ||\n        this.nodesListManager.isUntrackedNode(nodeId.getHost())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "52948bb20bd1446164df1d3920c46c96dad750ae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3980. Plumb resource-utilization info in node heartbeat through to the scheduler. (Inigo Goiri via kasha)\n",
      "commitDate": "24/11/15 12:17 AM",
      "commitName": "52948bb20bd1446164df1d3920c46c96dad750ae",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "26/10/15 3:12 AM",
      "commitNameOld": "5acdde4744c131e05db7b4b5f7d684fed7608b99",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 28.92,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,104 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n-        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n-            remoteNodeStatus.getContainersStatuses(),\n-            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse,\n-            remoteNodeStatus.getIncreasedContainers());\n+        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n             nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus, nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "db9304788187c700647c4d84caeb3b5ad6d868d8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3964. Support NodeLabelsProvider at Resource Manager side.\nContributed by Dian Fu.\n",
      "commitDate": "10/10/15 10:51 PM",
      "commitName": "db9304788187c700647c4d84caeb3b5ad6d868d8",
      "commitAuthor": "Devaraj K",
      "commitDateOld": "23/09/15 1:29 PM",
      "commitNameOld": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 17.39,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,107 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n         nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(),\n             remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse,\n             remoteNodeStatus.getIncreasedContainers());\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n-            convertToStringSet(request.getNodeLabels()), nodeId);\n+            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n+            nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(),\n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse,\n            remoteNodeStatus.getIncreasedContainers());\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            NodeLabelsUtils.convertToStringSet(request.getNodeLabels()),\n            nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
      "commitDate": "23/09/15 1:29 PM",
      "commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthor": "Jian He",
      "commitDateOld": "18/09/15 10:04 AM",
      "commitNameOld": "9bc913a35c46e65d373c3ae3f01a377e16e8d0ca",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 5.14,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,106 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n     // in decommissioning.\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())\n         \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n+    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n+        nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n-          remoteNodeStatus.getContainersStatuses(),\n-          remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse);\n+            remoteNodeStatus.getContainersStatuses(),\n+            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse,\n+            remoteNodeStatus.getIncreasedContainers());\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             convertToStringSet(request.getNodeLabels()), nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    rmNode.updateNodeHeartbeatResponseForContainersDecreasing(\n        nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(),\n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse,\n            remoteNodeStatus.getIncreasedContainers());\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            convertToStringSet(request.getNodeLabels()), nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "9bc913a35c46e65d373c3ae3f01a377e16e8d0ca": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3212. RMNode State Transition Update with DECOMMISSIONING state. (Junping Du via wangda)\n",
      "commitDate": "18/09/15 10:04 AM",
      "commitName": "9bc913a35c46e65d373c3ae3f01a377e16e8d0ca",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "23/08/15 10:55 PM",
      "commitNameOld": "feaf0349949e831ce3f25814c1bbff52f17bfe8f",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 25.46,
      "commitsBetweenForRepo": 158,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,103 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n-    // 1. Check if it\u0027s a valid (i.e. not excluded) node\n-    if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n+    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n+    // in decommissioning.\n+    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n+        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n           NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n           message);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n           remoteNodeStatus.getContainersStatuses(),\n           remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             convertToStringSet(request.getNodeLabels()), nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node, if not, see if it is\n    // in decommissioning.\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())\n        \u0026\u0026 !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n          remoteNodeStatus.getContainersStatuses(),\n          remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            convertToStringSet(request.getNodeLabels()), nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "57f1a01eda80f44d3ffcbcb93c4ee290e274946a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3826. Race condition in ResourceTrackerService leads to wrong\ndiagnostics messages. Contributed by Chengbing Liu.\n",
      "commitDate": "25/06/15 3:43 AM",
      "commitName": "57f1a01eda80f44d3ffcbcb93c4ee290e274946a",
      "commitAuthor": "Devaraj K",
      "commitDateOld": "04/06/15 4:59 AM",
      "commitNameOld": "d7e7f6aa03c67b6a6ccf664adcb06d90bc963e58",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 20.95,
      "commitsBetweenForRepo": 136,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,101 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n-      shutDown.setDiagnosticsMessage(message);\n-      return shutDown;\n+      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n+          NodeAction.SHUTDOWN, message);\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n-      resync.setDiagnosticsMessage(message);\n-      return resync;\n+      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n+          message);\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n-      resync.setDiagnosticsMessage(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n-      return resync;\n+      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n+          message);\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n           remoteNodeStatus.getContainersStatuses(),\n           remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(\n             convertToStringSet(request.getNodeLabels()), nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(\n          NodeAction.SHUTDOWN, message);\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return YarnServerBuilderUtils.newNodeHeartbeatResponse(NodeAction.RESYNC,\n          message);\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n          remoteNodeStatus.getContainersStatuses(),\n          remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            convertToStringSet(request.getNodeLabels()), nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "b37da52a1c4fb3da2bd21bfadc5ec61c5f953a59": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3565. NodeHeartbeatRequest/RegisterNodeManagerRequest should use NodeLabel object instead of String. (Naganarasimha G R via wangda)\n",
      "commitDate": "19/05/15 4:34 PM",
      "commitName": "b37da52a1c4fb3da2bd21bfadc5ec61c5f953a59",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/04/15 4:24 PM",
      "commitNameOld": "db1b674b50ddecf2774f4092d677c412722bdcb1",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 22.01,
      "commitsBetweenForRepo": 270,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,101 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       shutDown.setDiagnosticsMessage(message);\n       return shutDown;\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n           remoteNodeStatus.getContainersStatuses(),\n           remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n-        updateNodeLabelsFromNMReport(request.getNodeLabels(), nodeId);\n+        updateNodeLabelsFromNMReport(\n+            convertToStringSet(request.getNodeLabels()), nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      shutDown.setDiagnosticsMessage(message);\n      return shutDown;\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n          remoteNodeStatus.getContainersStatuses(),\n          remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(\n            convertToStringSet(request.getNodeLabels()), nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "db1b674b50ddecf2774f4092d677c412722bdcb1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2740. Fix NodeLabelsManager to properly handle node label modifications when distributed node label configuration enabled. (Naganarasimha G R via wangda)\n",
      "commitDate": "27/04/15 4:24 PM",
      "commitName": "db1b674b50ddecf2774f4092d677c412722bdcb1",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "10/04/15 8:56 AM",
      "commitNameOld": "92431c961741747b5d6442f4025016d48d9a6863",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 17.31,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,100 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       shutDown.setDiagnosticsMessage(message);\n       return shutDown;\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n           remoteNodeStatus.getContainersStatuses(),\n           remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse);\n     if (request.getLogAggregationReportsForApps() !\u003d null\n         \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n       nodeStatusEvent.setLogAggregationReportsForApps(request\n         .getLogAggregationReportsForApps());\n     }\n     this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n-    if (isDistributesNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n+    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(request.getNodeLabels(), nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      shutDown.setDiagnosticsMessage(message);\n      return shutDown;\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n          remoteNodeStatus.getContainersStatuses(),\n          remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributedNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(request.getNodeLabels(), nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "92431c961741747b5d6442f4025016d48d9a6863": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1376. NM need to notify the log aggregation status to RM through Node heartbeat. Contributed by Xuan Gong.\n",
      "commitDate": "10/04/15 8:56 AM",
      "commitName": "92431c961741747b5d6442f4025016d48d9a6863",
      "commitAuthor": "Junping Du",
      "commitDateOld": "30/03/15 12:05 PM",
      "commitNameOld": "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 10.87,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,100 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       shutDown.setDiagnosticsMessage(message);\n       return shutDown;\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n-    this.rmContext.getDispatcher().getEventHandler().handle(\n+    RMNodeStatusEvent nodeStatusEvent \u003d\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n-            remoteNodeStatus.getContainersStatuses(), \n-            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n+          remoteNodeStatus.getContainersStatuses(),\n+          remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse);\n+    if (request.getLogAggregationReportsForApps() !\u003d null\n+        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n+      nodeStatusEvent.setLogAggregationReportsForApps(request\n+        .getLogAggregationReportsForApps());\n+    }\n+    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n \n     // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     if (isDistributesNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(request.getNodeLabels(), nodeId);\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n         nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      shutDown.setDiagnosticsMessage(message);\n      return shutDown;\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    RMNodeStatusEvent nodeStatusEvent \u003d\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n          remoteNodeStatus.getContainersStatuses(),\n          remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse);\n    if (request.getLogAggregationReportsForApps() !\u003d null\n        \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n      nodeStatusEvent.setLogAggregationReportsForApps(request\n        .getLogAggregationReportsForApps());\n    }\n    this.rmContext.getDispatcher().getEventHandler().handle(nodeStatusEvent);\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributesNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(request.getNodeLabels(), nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2495. Allow admin specify labels from each NM (Distributed configuration for node label). (Naganarasimha G R via wangda)\n",
      "commitDate": "30/03/15 12:05 PM",
      "commitName": "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "20/02/15 7:10 AM",
      "commitNameOld": "a64dd3d24bfcb9af21eb63869924f6482b147fd3",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 38.16,
      "commitsBetweenForRepo": 326,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,94 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n+     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       shutDown.setDiagnosticsMessage(message);\n       return shutDown;\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n         rmContext.getSystemCredentialsForApps();\n     if (!systemCredentials.isEmpty()) {\n       nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n \n+    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n+    if (isDistributesNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n+      try {\n+        updateNodeLabelsFromNMReport(request.getNodeLabels(), nodeId);\n+        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n+      } catch (IOException ex) {\n+        //ensure the error message is captured and sent across in response\n+        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n+        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n+      }\n+    }\n+\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     * 5. Update node\u0027s labels if distributed Node Labels configuration is enabled\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      shutDown.setDiagnosticsMessage(message);\n      return shutDown;\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n\n    // 5. Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    if (isDistributesNodeLabelsConf \u0026\u0026 request.getNodeLabels() !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(request.getNodeLabels(), nodeId);\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        nodeHeartBeatResponse.setDiagnosticsMessage(ex.getMessage());\n        nodeHeartBeatResponse.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "a16d022ca4313a41425c8e97841c841a2d6f2f54": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2704. Changed ResourceManager to optionally obtain tokens itself for the sake of localization and log-aggregation for long-running services. Contributed by Jian He.\n",
      "commitDate": "27/10/14 3:49 PM",
      "commitName": "a16d022ca4313a41425c8e97841c841a2d6f2f54",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/10/14 4:23 PM",
      "commitNameOld": "da709a2eac7110026169ed3fc4d0eaf85488d3ef",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 13.98,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,81 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a valid (i.e. not excluded) node\n      * 2. Check if it\u0027s a registered node\n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + nodeId.getHost();\n       LOG.info(message);\n       shutDown.setDiagnosticsMessage(message);\n       return shutDown;\n     }\n \n     // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n-          + rmNode.getNodeAddress());\n+          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n+    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n+        rmContext.getSystemCredentialsForApps();\n+    if (!systemCredentials.isEmpty()) {\n+      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n+    }\n+\n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      shutDown.setDiagnosticsMessage(message);\n      return shutDown;\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress()+ \" responseId\u003d\" + remoteNodeStatus.getResponseId());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    ConcurrentMap\u003cApplicationId, ByteBuffer\u003e systemCredentials \u003d\n        rmContext.getSystemCredentialsForApps();\n    if (!systemCredentials.isEmpty()) {\n      nodeHeartBeatResponse.setSystemCredentialsForApps(systemCredentials);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "da709a2eac7110026169ed3fc4d0eaf85488d3ef": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2641. Decommission nodes on -refreshNodes instead of next NM-RM heartbeat. (Zhihai Xu via kasha)\n",
      "commitDate": "13/10/14 4:23 PM",
      "commitName": "da709a2eac7110026169ed3fc4d0eaf85488d3ef",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "22/09/14 10:30 AM",
      "commitNameOld": "0a641496c706fc175e7bf66d69ebf71c7d078e84",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 21.24,
      "commitsBetweenForRepo": 218,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,75 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n-     * 1. Check if it\u0027s a registered node\n-     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n-     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n+     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n+     * 2. Check if it\u0027s a registered node\n+     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n-    // 1. Check if it\u0027s a registered node\n+    // 1. Check if it\u0027s a valid (i.e. not excluded) node\n+    if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n+      String message \u003d\n+          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n+              + nodeId.getHost();\n+      LOG.info(message);\n+      shutDown.setDiagnosticsMessage(message);\n+      return shutDown;\n+    }\n+\n+    // 2. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n-    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n-    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n-      String message \u003d\n-          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n-              + rmNode.getNodeAddress();\n-      LOG.info(message);\n-      shutDown.setDiagnosticsMessage(message);\n-      this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n-      return shutDown;\n-    }\n-    \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a valid (i.e. not excluded) node\n     * 2. Check if it\u0027s a registered node\n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(nodeId.getHost())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + nodeId.getHost();\n      LOG.info(message);\n      shutDown.setDiagnosticsMessage(message);\n      return shutDown;\n    }\n\n    // 2. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "db1e0c1eefc1f6ad8fd317088d548c7814ea7aff": {
      "type": "Ybodychange",
      "commitMessage": "YARN-688. Fixed NodeManager to properly cleanup containers when it is shut down. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506814 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/07/13 9:14 PM",
      "commitName": "db1e0c1eefc1f6ad8fd317088d548c7814ea7aff",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/06/13 11:39 PM",
      "commitNameOld": "b9efe6bd4a1277b4067ecde715a7713a85968886",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 37.9,
      "commitsBetweenForRepo": 216,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n-      String message \u003d \"Node not found rebooting \" + remoteNodeStatus.getNodeId();\n+      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + rmNode.getNodeAddress();\n       LOG.info(message);\n       shutDown.setDiagnosticsMessage(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n     \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n \n     populateKeys(request, nodeHeartBeatResponse);\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found resyncing \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + rmNode.getNodeAddress();\n      LOG.info(message);\n      shutDown.setDiagnosticsMessage(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n    \n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-692. Creating NMToken master key on RM and sharing it with NM as a part of RM-NM heartbeat. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492907 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/06/13 5:06 PM",
      "commitName": "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/06/13 4:25 PM",
      "commitNameOld": "c0cd68d8fbf5c8cafa6d563c7d0401e7a87a2d9e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,77 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found rebooting \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + rmNode.getNodeAddress();\n       LOG.info(message);\n       shutDown.setDiagnosticsMessage(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n     \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n-            getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n+            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n \n-    // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n-    // roller over, send it across\n-    boolean shouldSendMasterKey \u003d false;\n-\n-    MasterKey nextMasterKeyForNode \u003d\n-        this.containerTokenSecretManager.getNextKey();\n-    if (nextMasterKeyForNode !\u003d null) {\n-      // nextMasterKeyForNode can be null if there is no outstanding key that\n-      // is in the activation period.\n-      MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n-      if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n-        shouldSendMasterKey \u003d true;\n-      }\n-    }\n-    if (shouldSendMasterKey) {\n-      nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n-    }\n+    populateKeys(request, nodeHeartBeatResponse);\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found rebooting \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + rmNode.getNodeAddress();\n      LOG.info(message);\n      shutDown.setDiagnosticsMessage(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n    \n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n\n    populateKeys(request, nodeHeartBeatResponse);\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/05/13 11:36 PM",
      "commitNameOld": "ca8024673178fa1c80224b390dfba932921693d9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 17.9,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,93 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n-      throws YarnRemoteException, IOException {\n+      throws YarnException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found rebooting \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + rmNode.getNodeAddress();\n       LOG.info(message);\n       shutDown.setDiagnosticsMessage(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n     \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n \n     // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n     // roller over, send it across\n     boolean shouldSendMasterKey \u003d false;\n \n     MasterKey nextMasterKeyForNode \u003d\n         this.containerTokenSecretManager.getNextKey();\n     if (nextMasterKeyForNode !\u003d null) {\n       // nextMasterKeyForNode can be null if there is no outstanding key that\n       // is in the activation period.\n       MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n       if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n         shouldSendMasterKey \u003d true;\n       }\n     }\n     if (shouldSendMasterKey) {\n       nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found rebooting \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + rmNode.getNodeAddress();\n      LOG.info(message);\n      shutDown.setDiagnosticsMessage(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n    \n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n\n    // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n    // roller over, send it across\n    boolean shouldSendMasterKey \u003d false;\n\n    MasterKey nextMasterKeyForNode \u003d\n        this.containerTokenSecretManager.getNextKey();\n    if (nextMasterKeyForNode !\u003d null) {\n      // nextMasterKeyForNode can be null if there is no outstanding key that\n      // is in the activation period.\n      MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n      if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n        shouldSendMasterKey \u003d true;\n      }\n    }\n    if (shouldSendMasterKey) {\n      nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException, IOException]",
        "newValue": "[YarnException, IOException]"
      }
    },
    "ca8024673178fa1c80224b390dfba932921693d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-617. Made ContainerTokens to be used for validation at NodeManager also in unsecure mode to prevent AMs from faking resource requirements in unsecure mode. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483667 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/05/13 11:36 PM",
      "commitName": "ca8024673178fa1c80224b390dfba932921693d9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/05/13 4:37 PM",
      "commitNameOld": "68148989bfb8b893529eb9920d849bce0dd575ec",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.29,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,93 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       String message \u003d \"Node not found rebooting \" + remoteNodeStatus.getNodeId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       String message \u003d\n           \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n               + rmNode.getNodeAddress();\n       LOG.info(message);\n       shutDown.setDiagnosticsMessage(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n     \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       String message \u003d\n           \"Too far behind rm response id:\"\n               + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n               + remoteNodeStatus.getResponseId();\n       LOG.info(message);\n       resync.setDiagnosticsMessage(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n+\n     // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n     // roller over, send it across\n-    if (isSecurityEnabled()) {\n+    boolean shouldSendMasterKey \u003d false;\n \n-      boolean shouldSendMasterKey \u003d false;\n-\n-      MasterKey nextMasterKeyForNode \u003d\n-          this.containerTokenSecretManager.getNextKey();\n-      if (nextMasterKeyForNode !\u003d null) {\n-        // nextMasterKeyForNode can be null if there is no outstanding key that\n-        // is in the activation period.\n-        MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n-        if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n-          shouldSendMasterKey \u003d true;\n-        }\n+    MasterKey nextMasterKeyForNode \u003d\n+        this.containerTokenSecretManager.getNextKey();\n+    if (nextMasterKeyForNode !\u003d null) {\n+      // nextMasterKeyForNode can be null if there is no outstanding key that\n+      // is in the activation period.\n+      MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n+      if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n+        shouldSendMasterKey \u003d true;\n       }\n-      if (shouldSendMasterKey) {\n-        nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n-      }\n+    }\n+    if (shouldSendMasterKey) {\n+      nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found rebooting \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + rmNode.getNodeAddress();\n      LOG.info(message);\n      shutDown.setDiagnosticsMessage(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n    \n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n\n    // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n    // roller over, send it across\n    boolean shouldSendMasterKey \u003d false;\n\n    MasterKey nextMasterKeyForNode \u003d\n        this.containerTokenSecretManager.getNextKey();\n    if (nextMasterKeyForNode !\u003d null) {\n      // nextMasterKeyForNode can be null if there is no outstanding key that\n      // is in the activation period.\n      MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n      if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n        shouldSendMasterKey \u003d true;\n      }\n    }\n    if (shouldSendMasterKey) {\n      nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "68148989bfb8b893529eb9920d849bce0dd575ec": {
      "type": "Ybodychange",
      "commitMessage": "YARN-590. Added an optional mesage to be returned by ResourceMaanger when RM asks an RM to shutdown/resync etc so that NMs can log this message locally for better debuggability. Contributed by Mayank Bansal.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1481234 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/13 4:37 PM",
      "commitName": "68148989bfb8b893529eb9920d849bce0dd575ec",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/05/13 2:58 PM",
      "commitNameOld": "a35c7fd80bcb19a7c6a7b9234d782adaf2d51529",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,95 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n-      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n+      String message \u003d \"Node not found rebooting \" + remoteNodeStatus.getNodeId();\n+      LOG.info(message);\n+      resync.setDiagnosticsMessage(message);\n       return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n-      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n-          + rmNode.getNodeAddress());\n+      String message \u003d\n+          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n+              + rmNode.getNodeAddress();\n+      LOG.info(message);\n+      shutDown.setDiagnosticsMessage(message);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n     \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n-      LOG.info(\"Too far behind rm response id:\"\n-          + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n-          + remoteNodeStatus.getResponseId());\n+      String message \u003d\n+          \"Too far behind rm response id:\"\n+              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n+              + remoteNodeStatus.getResponseId();\n+      LOG.info(message);\n+      resync.setDiagnosticsMessage(message);\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n     // roller over, send it across\n     if (isSecurityEnabled()) {\n \n       boolean shouldSendMasterKey \u003d false;\n \n       MasterKey nextMasterKeyForNode \u003d\n           this.containerTokenSecretManager.getNextKey();\n       if (nextMasterKeyForNode !\u003d null) {\n         // nextMasterKeyForNode can be null if there is no outstanding key that\n         // is in the activation period.\n         MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n         if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n           shouldSendMasterKey \u003d true;\n         }\n       }\n       if (shouldSendMasterKey) {\n         nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n       }\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      String message \u003d \"Node not found rebooting \" + remoteNodeStatus.getNodeId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      String message \u003d\n          \"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n              + rmNode.getNodeAddress();\n      LOG.info(message);\n      shutDown.setDiagnosticsMessage(message);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n    \n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      String message \u003d\n          \"Too far behind rm response id:\"\n              + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n              + remoteNodeStatus.getResponseId();\n      LOG.info(message);\n      resync.setDiagnosticsMessage(message);\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n    // roller over, send it across\n    if (isSecurityEnabled()) {\n\n      boolean shouldSendMasterKey \u003d false;\n\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getNextKey();\n      if (nextMasterKeyForNode !\u003d null) {\n        // nextMasterKeyForNode can be null if there is no outstanding key that\n        // is in the activation period.\n        MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n        if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n          shouldSendMasterKey \u003d true;\n        }\n      }\n      if (shouldSendMasterKey) {\n        nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n      }\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "a35c7fd80bcb19a7c6a7b9234d782adaf2d51529": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-663. Changed ResourceTracker API and LocalizationProtocol API to throw YarnRemoteException and IOException. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1481215 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/13 2:58 PM",
      "commitName": "a35c7fd80bcb19a7c6a7b9234d782adaf2d51529",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "28/04/13 1:03 PM",
      "commitNameOld": "d9ce42479e5b2cbbf54dd2861680f9d37bdf31f3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 12.08,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,87 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n-      throws YarnRemoteException {\n+      throws YarnRemoteException, IOException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n       return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n           + rmNode.getNodeAddress());\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n     \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Too far behind rm response id:\"\n           + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n           + remoteNodeStatus.getResponseId());\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n     // roller over, send it across\n     if (isSecurityEnabled()) {\n \n       boolean shouldSendMasterKey \u003d false;\n \n       MasterKey nextMasterKeyForNode \u003d\n           this.containerTokenSecretManager.getNextKey();\n       if (nextMasterKeyForNode !\u003d null) {\n         // nextMasterKeyForNode can be null if there is no outstanding key that\n         // is in the activation period.\n         MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n         if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n           shouldSendMasterKey \u003d true;\n         }\n       }\n       if (shouldSendMasterKey) {\n         nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n       }\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException, IOException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n          + rmNode.getNodeAddress());\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n    \n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Too far behind rm response id:\"\n          + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n          + remoteNodeStatus.getResponseId());\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n    // roller over, send it across\n    if (isSecurityEnabled()) {\n\n      boolean shouldSendMasterKey \u003d false;\n\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getNextKey();\n      if (nextMasterKeyForNode !\u003d null) {\n        // nextMasterKeyForNode can be null if there is no outstanding key that\n        // is in the activation period.\n        MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n        if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n          shouldSendMasterKey \u003d true;\n        }\n      }\n      if (shouldSendMasterKey) {\n        nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n      }\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException]",
        "newValue": "[YarnRemoteException, IOException]"
      }
    },
    "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963": {
      "type": "Ybodychange",
      "commitMessage": "YARN-495. Changed NM reboot behaviour to be a simple resync - kill all containers  and re-register with RM. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1466752 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/04/13 7:00 PM",
      "commitName": "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "01/04/13 6:04 PM",
      "commitNameOld": "7ca9fe73a0f5047ff0279f3e29a29c8447cbb81a",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 9.04,
      "commitsBetweenForRepo": 54,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,87 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n-      return reboot;\n+      return resync;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n           + rmNode.getNodeAddress());\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n     \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Too far behind rm response id:\"\n           + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n           + remoteNodeStatus.getResponseId());\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n-      return reboot;\n+      return resync;\n     }\n \n     // Heartbeat response\n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n         .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n             getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n             nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n     // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n     // roller over, send it across\n     if (isSecurityEnabled()) {\n \n       boolean shouldSendMasterKey \u003d false;\n \n       MasterKey nextMasterKeyForNode \u003d\n           this.containerTokenSecretManager.getNextKey();\n       if (nextMasterKeyForNode !\u003d null) {\n         // nextMasterKeyForNode can be null if there is no outstanding key that\n         // is in the activation period.\n         MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n         if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n           shouldSendMasterKey \u003d true;\n         }\n       }\n       if (shouldSendMasterKey) {\n         nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n       }\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n      return resync;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n          + rmNode.getNodeAddress());\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n    \n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Too far behind rm response id:\"\n          + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n          + remoteNodeStatus.getResponseId());\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return resync;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n    // roller over, send it across\n    if (isSecurityEnabled()) {\n\n      boolean shouldSendMasterKey \u003d false;\n\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getNextKey();\n      if (nextMasterKeyForNode !\u003d null) {\n        // nextMasterKeyForNode can be null if there is no outstanding key that\n        // is in the activation period.\n        MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n        if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n          shouldSendMasterKey \u003d true;\n        }\n      }\n      if (shouldSendMasterKey) {\n        nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n      }\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "7ca9fe73a0f5047ff0279f3e29a29c8447cbb81a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-309. Changed NodeManager to obtain heart-beat interval from the ResourceManager. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1463346 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/04/13 6:04 PM",
      "commitName": "7ca9fe73a0f5047ff0279f3e29a29c8447cbb81a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "26/03/13 11:20 AM",
      "commitNameOld": "66e90b205a079c7056bd85e6c5e3dbb2a96e7461",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 6.28,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,87 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n       return reboot;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n           + rmNode.getNodeAddress());\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n-\n-    NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n-        .newRecordInstance(NodeHeartbeatResponse.class);\n     \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       return lastNodeHeartbeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Too far behind rm response id:\"\n           + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n           + remoteNodeStatus.getResponseId());\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return reboot;\n     }\n \n     // Heartbeat response\n-    nodeHeartBeatResponse.setResponseId(lastNodeHeartbeatResponse.getResponseId() + 1);\n+    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n+        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n+            getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n+            nextHeartBeatInterval);\n     rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n-    nodeHeartBeatResponse.setNodeAction(NodeAction.NORMAL);\n-\n     // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n     // roller over, send it across\n     if (isSecurityEnabled()) {\n \n       boolean shouldSendMasterKey \u003d false;\n \n       MasterKey nextMasterKeyForNode \u003d\n           this.containerTokenSecretManager.getNextKey();\n       if (nextMasterKeyForNode !\u003d null) {\n         // nextMasterKeyForNode can be null if there is no outstanding key that\n         // is in the activation period.\n         MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n         if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n           shouldSendMasterKey \u003d true;\n         }\n       }\n       if (shouldSendMasterKey) {\n         nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n       }\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n \n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n      return reboot;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n          + rmNode.getNodeAddress());\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n    \n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Too far behind rm response id:\"\n          + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n          + remoteNodeStatus.getResponseId());\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return reboot;\n    }\n\n    // Heartbeat response\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d YarnServerBuilderUtils\n        .newNodeHeartbeatResponse(lastNodeHeartbeatResponse.\n            getResponseId() + 1, NodeAction.NORMAL, null, null, null,\n            nextHeartBeatInterval);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n    // roller over, send it across\n    if (isSecurityEnabled()) {\n\n      boolean shouldSendMasterKey \u003d false;\n\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getNextKey();\n      if (nextMasterKeyForNode !\u003d null) {\n        // nextMasterKeyForNode can be null if there is no outstanding key that\n        // is in the activation period.\n        MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n        if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n          shouldSendMasterKey \u003d true;\n        }\n      }\n      if (shouldSendMasterKey) {\n        nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n      }\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "18e08a8f511652ed9f4ba386bb4f0cf8339e2729": {
      "type": "Ybodychange",
      "commitMessage": "YARN-439. Flatten NodeHeartbeatResponse. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460811 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/13 11:28 AM",
      "commitName": "18e08a8f511652ed9f4ba386bb4f0cf8339e2729",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "28/02/13 9:59 PM",
      "commitNameOld": "83d80658673b286efc534d96463e4c93fb818858",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 24.52,
      "commitsBetweenForRepo": 130,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,89 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n       return reboot;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n           + rmNode.getNodeAddress());\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n \n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n         .newRecordInstance(NodeHeartbeatResponse.class);\n     \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n-    HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n-    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n+    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n+    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n-      nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n-      return nodeHeartBeatResponse;\n-    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n+      return lastNodeHeartbeatResponse;\n+    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Too far behind rm response id:\"\n-          + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n+          + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n           + remoteNodeStatus.getResponseId());\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return reboot;\n     }\n \n     // Heartbeat response\n-    HeartbeatResponse latestResponse \u003d recordFactory\n-        .newRecordInstance(HeartbeatResponse.class);\n-    latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n-    rmNode.updateHeartbeatResponseForCleanup(latestResponse);\n-    latestResponse.setNodeAction(NodeAction.NORMAL);\n+    nodeHeartBeatResponse.setResponseId(lastNodeHeartbeatResponse.getResponseId() + 1);\n+    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n+    nodeHeartBeatResponse.setNodeAction(NodeAction.NORMAL);\n \n     // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n     // roller over, send it across\n     if (isSecurityEnabled()) {\n \n       boolean shouldSendMasterKey \u003d false;\n \n       MasterKey nextMasterKeyForNode \u003d\n           this.containerTokenSecretManager.getNextKey();\n       if (nextMasterKeyForNode !\u003d null) {\n         // nextMasterKeyForNode can be null if there is no outstanding key that\n         // is in the activation period.\n         MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n         if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n           shouldSendMasterKey \u003d true;\n         }\n       }\n       if (shouldSendMasterKey) {\n-        latestResponse.setMasterKey(nextMasterKeyForNode);\n+        nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n       }\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n-            remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n+            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n \n-    nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n      return reboot;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n          + rmNode.getNodeAddress());\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n        .newRecordInstance(NodeHeartbeatResponse.class);\n    \n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    NodeHeartbeatResponse lastNodeHeartbeatResponse \u003d rmNode.getLastNodeHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      return lastNodeHeartbeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastNodeHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Too far behind rm response id:\"\n          + lastNodeHeartbeatResponse.getResponseId() + \" nm response id:\"\n          + remoteNodeStatus.getResponseId());\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return reboot;\n    }\n\n    // Heartbeat response\n    nodeHeartBeatResponse.setResponseId(lastNodeHeartbeatResponse.getResponseId() + 1);\n    rmNode.updateNodeHeartbeatResponseForCleanup(nodeHeartBeatResponse);\n    nodeHeartBeatResponse.setNodeAction(NodeAction.NORMAL);\n\n    // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n    // roller over, send it across\n    if (isSecurityEnabled()) {\n\n      boolean shouldSendMasterKey \u003d false;\n\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getNextKey();\n      if (nextMasterKeyForNode !\u003d null) {\n        // nextMasterKeyForNode can be null if there is no outstanding key that\n        // is in the activation period.\n        MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n        if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n          shouldSendMasterKey \u003d true;\n        }\n      }\n      if (shouldSendMasterKey) {\n        nodeHeartBeatResponse.setMasterKey(nextMasterKeyForNode);\n      }\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), nodeHeartBeatResponse));\n\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "83d80658673b286efc534d96463e4c93fb818858": {
      "type": "Ybodychange",
      "commitMessage": "YARN-376. Fixes a bug which would prevent the NM knowing about completed containers and applications. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1451473 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/02/13 9:59 PM",
      "commitName": "83d80658673b286efc534d96463e4c93fb818858",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "08/01/13 9:08 PM",
      "commitNameOld": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 51.04,
      "commitsBetweenForRepo": 228,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,93 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n       return reboot;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n           + rmNode.getNodeAddress());\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n \n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n         .newRecordInstance(NodeHeartbeatResponse.class);\n     \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n       return nodeHeartBeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Too far behind rm response id:\"\n           + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n           + remoteNodeStatus.getResponseId());\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return reboot;\n     }\n \n     // Heartbeat response\n     HeartbeatResponse latestResponse \u003d recordFactory\n         .newRecordInstance(HeartbeatResponse.class);\n     latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n-    latestResponse.addAllContainersToCleanup(rmNode.getContainersToCleanUp());\n-    latestResponse.addAllApplicationsToCleanup(rmNode.getAppsToCleanup());\n+    rmNode.updateHeartbeatResponseForCleanup(latestResponse);\n     latestResponse.setNodeAction(NodeAction.NORMAL);\n \n     // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n     // roller over, send it across\n     if (isSecurityEnabled()) {\n \n       boolean shouldSendMasterKey \u003d false;\n \n       MasterKey nextMasterKeyForNode \u003d\n           this.containerTokenSecretManager.getNextKey();\n       if (nextMasterKeyForNode !\u003d null) {\n         // nextMasterKeyForNode can be null if there is no outstanding key that\n         // is in the activation period.\n         MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n         if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n           shouldSendMasterKey \u003d true;\n         }\n       }\n       if (shouldSendMasterKey) {\n         latestResponse.setMasterKey(nextMasterKeyForNode);\n       }\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n \n     nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n      return reboot;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n          + rmNode.getNodeAddress());\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n        .newRecordInstance(NodeHeartbeatResponse.class);\n    \n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n      return nodeHeartBeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Too far behind rm response id:\"\n          + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n          + remoteNodeStatus.getResponseId());\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return reboot;\n    }\n\n    // Heartbeat response\n    HeartbeatResponse latestResponse \u003d recordFactory\n        .newRecordInstance(HeartbeatResponse.class);\n    latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n    rmNode.updateHeartbeatResponseForCleanup(latestResponse);\n    latestResponse.setNodeAction(NodeAction.NORMAL);\n\n    // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n    // roller over, send it across\n    if (isSecurityEnabled()) {\n\n      boolean shouldSendMasterKey \u003d false;\n\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getNextKey();\n      if (nextMasterKeyForNode !\u003d null) {\n        // nextMasterKeyForNode can be null if there is no outstanding key that\n        // is in the activation period.\n        MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n        if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n          shouldSendMasterKey \u003d true;\n        }\n      }\n      if (shouldSendMasterKey) {\n        latestResponse.setMasterKey(nextMasterKeyForNode);\n      }\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n\n    nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "45a8e8c5a46535287de97fd6609c0743eef888ee": {
      "type": "Ybodychange",
      "commitMessage": "YARN-60. Fixed a bug in ResourceManager which causes all NMs to get NPEs and thus causes all containers to be rejected. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1379550 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/08/12 12:11 PM",
      "commitName": "45a8e8c5a46535287de97fd6609c0743eef888ee",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/12 7:18 PM",
      "commitNameOld": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 6.7,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,94 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n       return reboot;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n           + rmNode.getNodeAddress());\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n \n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n         .newRecordInstance(NodeHeartbeatResponse.class);\n     \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n       return nodeHeartBeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Too far behind rm response id:\"\n           + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n           + remoteNodeStatus.getResponseId());\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return reboot;\n     }\n \n     // Heartbeat response\n     HeartbeatResponse latestResponse \u003d recordFactory\n         .newRecordInstance(HeartbeatResponse.class);\n     latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n     latestResponse.addAllContainersToCleanup(rmNode.getContainersToCleanUp());\n     latestResponse.addAllApplicationsToCleanup(rmNode.getAppsToCleanup());\n     latestResponse.setNodeAction(NodeAction.NORMAL);\n \n-    MasterKey nextMasterKeyForNode \u003d null;\n-\n     // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n     // roller over, send it across\n     if (isSecurityEnabled()) {\n+\n       boolean shouldSendMasterKey \u003d false;\n-      MasterKey nodeKnownMasterKey \u003d rmNode.getCurrentMasterKey();\n-      nextMasterKeyForNode \u003d this.containerTokenSecretManager.getNextKey();\n+\n+      MasterKey nextMasterKeyForNode \u003d\n+          this.containerTokenSecretManager.getNextKey();\n       if (nextMasterKeyForNode !\u003d null) {\n         // nextMasterKeyForNode can be null if there is no outstanding key that\n         // is in the activation period.\n+        MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n         if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n           shouldSendMasterKey \u003d true;\n         }\n       }\n       if (shouldSendMasterKey) {\n         latestResponse.setMasterKey(nextMasterKeyForNode);\n       }\n     }\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n-            remoteNodeStatus.getKeepAliveApplications(), latestResponse,\n-            nextMasterKeyForNode));\n+            remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n \n     nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n      return reboot;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n          + rmNode.getNodeAddress());\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n        .newRecordInstance(NodeHeartbeatResponse.class);\n    \n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n      return nodeHeartBeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Too far behind rm response id:\"\n          + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n          + remoteNodeStatus.getResponseId());\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return reboot;\n    }\n\n    // Heartbeat response\n    HeartbeatResponse latestResponse \u003d recordFactory\n        .newRecordInstance(HeartbeatResponse.class);\n    latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n    latestResponse.addAllContainersToCleanup(rmNode.getContainersToCleanUp());\n    latestResponse.addAllApplicationsToCleanup(rmNode.getAppsToCleanup());\n    latestResponse.setNodeAction(NodeAction.NORMAL);\n\n    // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n    // roller over, send it across\n    if (isSecurityEnabled()) {\n\n      boolean shouldSendMasterKey \u003d false;\n\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getNextKey();\n      if (nextMasterKeyForNode !\u003d null) {\n        // nextMasterKeyForNode can be null if there is no outstanding key that\n        // is in the activation period.\n        MasterKey nodeKnownMasterKey \u003d request.getLastKnownMasterKey();\n        if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n          shouldSendMasterKey \u003d true;\n        }\n      }\n      if (shouldSendMasterKey) {\n        latestResponse.setMasterKey(nextMasterKeyForNode);\n      }\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n\n    nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-39. RM-NM secret-keys should be randomly generated and rolled every so often. (Contributed by Vinod Kumar Vavilapalli and Siddharth Seth)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1377180 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/12 7:18 PM",
      "commitName": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 16.87,
      "commitsBetweenForRepo": 114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,94 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n       return reboot;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n           + rmNode.getNodeAddress());\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n \n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n         .newRecordInstance(NodeHeartbeatResponse.class);\n-\n+    \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n       return nodeHeartBeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Too far behind rm response id:\"\n           + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n           + remoteNodeStatus.getResponseId());\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return reboot;\n     }\n \n     // Heartbeat response\n     HeartbeatResponse latestResponse \u003d recordFactory\n         .newRecordInstance(HeartbeatResponse.class);\n     latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n     latestResponse.addAllContainersToCleanup(rmNode.getContainersToCleanUp());\n     latestResponse.addAllApplicationsToCleanup(rmNode.getAppsToCleanup());\n     latestResponse.setNodeAction(NodeAction.NORMAL);\n \n+    MasterKey nextMasterKeyForNode \u003d null;\n+\n+    // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n+    // roller over, send it across\n+    if (isSecurityEnabled()) {\n+      boolean shouldSendMasterKey \u003d false;\n+      MasterKey nodeKnownMasterKey \u003d rmNode.getCurrentMasterKey();\n+      nextMasterKeyForNode \u003d this.containerTokenSecretManager.getNextKey();\n+      if (nextMasterKeyForNode !\u003d null) {\n+        // nextMasterKeyForNode can be null if there is no outstanding key that\n+        // is in the activation period.\n+        if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n+          shouldSendMasterKey \u003d true;\n+        }\n+      }\n+      if (shouldSendMasterKey) {\n+        latestResponse.setMasterKey(nextMasterKeyForNode);\n+      }\n+    }\n+\n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n-            remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n+            remoteNodeStatus.getKeepAliveApplications(), latestResponse,\n+            nextMasterKeyForNode));\n \n     nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n      return reboot;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n          + rmNode.getNodeAddress());\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n        .newRecordInstance(NodeHeartbeatResponse.class);\n    \n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n      return nodeHeartBeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Too far behind rm response id:\"\n          + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n          + remoteNodeStatus.getResponseId());\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return reboot;\n    }\n\n    // Heartbeat response\n    HeartbeatResponse latestResponse \u003d recordFactory\n        .newRecordInstance(HeartbeatResponse.class);\n    latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n    latestResponse.addAllContainersToCleanup(rmNode.getContainersToCleanUp());\n    latestResponse.addAllApplicationsToCleanup(rmNode.getAppsToCleanup());\n    latestResponse.setNodeAction(NodeAction.NORMAL);\n\n    MasterKey nextMasterKeyForNode \u003d null;\n\n    // Check if node\u0027s masterKey needs to be updated and if the currentKey has\n    // roller over, send it across\n    if (isSecurityEnabled()) {\n      boolean shouldSendMasterKey \u003d false;\n      MasterKey nodeKnownMasterKey \u003d rmNode.getCurrentMasterKey();\n      nextMasterKeyForNode \u003d this.containerTokenSecretManager.getNextKey();\n      if (nextMasterKeyForNode !\u003d null) {\n        // nextMasterKeyForNode can be null if there is no outstanding key that\n        // is in the activation period.\n        if (nodeKnownMasterKey.getKeyId() !\u003d nextMasterKeyForNode.getKeyId()) {\n          shouldSendMasterKey \u003d true;\n        }\n      }\n      if (shouldSendMasterKey) {\n        latestResponse.setMasterKey(nextMasterKeyForNode);\n      }\n    }\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), latestResponse,\n            nextMasterKeyForNode));\n\n    nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n      return reboot;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n          + rmNode.getNodeAddress());\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n        .newRecordInstance(NodeHeartbeatResponse.class);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n      return nodeHeartBeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Too far behind rm response id:\"\n          + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n          + remoteNodeStatus.getResponseId());\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return reboot;\n    }\n\n    // Heartbeat response\n    HeartbeatResponse latestResponse \u003d recordFactory\n        .newRecordInstance(HeartbeatResponse.class);\n    latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n    latestResponse.addAllContainersToCleanup(rmNode.getContainersToCleanUp());\n    latestResponse.addAllApplicationsToCleanup(rmNode.getAppsToCleanup());\n    latestResponse.setNodeAction(NodeAction.NORMAL);\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n\n    nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java"
      }
    },
    "3cdc100369ce920701fdddae12d7f7247332b3f3": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3360. Added information about lost/rebooted/decommissioned nodes on the webapps. Contributed by Bhallamudi Venkata Siva Kamesh and Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1236433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/01/12 2:56 PM",
      "commitName": "3cdc100369ce920701fdddae12d7f7247332b3f3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/01/12 1:15 PM",
      "commitNameOld": "78ff0b720e0418785d53802a1b4e72085c1a3556",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 13.07,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,73 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n-      \n-      // Updating the metrics directly as reboot event cannot be \n-      // triggered on a null rmNode\n-      ClusterMetrics.getMetrics().incrNumRebootedNMs();\n       return reboot;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n           + rmNode.getNodeAddress());\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n \n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n         .newRecordInstance(NodeHeartbeatResponse.class);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n       return nodeHeartBeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Too far behind rm response id:\"\n           + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n           + remoteNodeStatus.getResponseId());\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return reboot;\n     }\n \n     // Heartbeat response\n     HeartbeatResponse latestResponse \u003d recordFactory\n         .newRecordInstance(HeartbeatResponse.class);\n     latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n     latestResponse.addAllContainersToCleanup(rmNode.getContainersToCleanUp());\n     latestResponse.addAllApplicationsToCleanup(rmNode.getAppsToCleanup());\n     latestResponse.setNodeAction(NodeAction.NORMAL);\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n \n     nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n      return reboot;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n          + rmNode.getNodeAddress());\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n        .newRecordInstance(NodeHeartbeatResponse.class);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n      return nodeHeartBeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Too far behind rm response id:\"\n          + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n          + remoteNodeStatus.getResponseId());\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return reboot;\n    }\n\n    // Heartbeat response\n    HeartbeatResponse latestResponse \u003d recordFactory\n        .newRecordInstance(HeartbeatResponse.class);\n    latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n    latestResponse.addAllContainersToCleanup(rmNode.getContainersToCleanUp());\n    latestResponse.addAllApplicationsToCleanup(rmNode.getAppsToCleanup());\n    latestResponse.setNodeAction(NodeAction.NORMAL);\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n\n    nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "78ff0b720e0418785d53802a1b4e72085c1a3556": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3596. Fix scheduler to handle cleaned up containers, which NMs may subsequently report as running. (Contributed by Vinod Kumar Vavilapalli)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1231297 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/01/12 1:15 PM",
      "commitName": "78ff0b720e0418785d53802a1b4e72085c1a3556",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "14/12/11 11:55 AM",
      "commitNameOld": "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 30.06,
      "commitsBetweenForRepo": 117,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n       \n       // Updating the metrics directly as reboot event cannot be \n       // triggered on a null rmNode\n       ClusterMetrics.getMetrics().incrNumRebootedNMs();\n       return reboot;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n           + rmNode.getNodeAddress());\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n \n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n         .newRecordInstance(NodeHeartbeatResponse.class);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n       return nodeHeartBeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Too far behind rm response id:\"\n           + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n           + remoteNodeStatus.getResponseId());\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return reboot;\n     }\n \n     // Heartbeat response\n     HeartbeatResponse latestResponse \u003d recordFactory\n         .newRecordInstance(HeartbeatResponse.class);\n     latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n-    latestResponse.addAllContainersToCleanup(rmNode.pullContainersToCleanUp());\n-    latestResponse.addAllApplicationsToCleanup(rmNode.pullAppsToCleanup());\n+    latestResponse.addAllContainersToCleanup(rmNode.getContainersToCleanUp());\n+    latestResponse.addAllApplicationsToCleanup(rmNode.getAppsToCleanup());\n     latestResponse.setNodeAction(NodeAction.NORMAL);\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n             remoteNodeStatus.getContainersStatuses(), \n             remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n \n     nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n      \n      // Updating the metrics directly as reboot event cannot be \n      // triggered on a null rmNode\n      ClusterMetrics.getMetrics().incrNumRebootedNMs();\n      return reboot;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n          + rmNode.getNodeAddress());\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n        .newRecordInstance(NodeHeartbeatResponse.class);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n      return nodeHeartBeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Too far behind rm response id:\"\n          + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n          + remoteNodeStatus.getResponseId());\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return reboot;\n    }\n\n    // Heartbeat response\n    HeartbeatResponse latestResponse \u003d recordFactory\n        .newRecordInstance(HeartbeatResponse.class);\n    latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n    latestResponse.addAllContainersToCleanup(rmNode.getContainersToCleanUp());\n    latestResponse.addAllApplicationsToCleanup(rmNode.getAppsToCleanup());\n    latestResponse.setNodeAction(NodeAction.NORMAL);\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n\n    nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3398. Fixed log aggregation to work correctly in secure mode. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1214429 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/12/11 11:55 AM",
      "commitName": "50fa9b89f42bd3fe6aad5086b0df14a00dadb24b",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "28/10/11 10:31 AM",
      "commitNameOld": "cbdb07f4ca358b9507296868a913977ad82ed716",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 47.1,
      "commitsBetweenForRepo": 290,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,77 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     /**\n      * Here is the node heartbeat sequence...\n      * 1. Check if it\u0027s a registered node\n      * 2. Check if it\u0027s a valid (i.e. not excluded) node \n      * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n      * 4. Send healthStatus to RMNode\n      */\n \n     NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n \n     // 1. Check if it\u0027s a registered node\n     RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n     if (rmNode \u003d\u003d null) {\n       /* node does not exist */\n       LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n       \n       // Updating the metrics directly as reboot event cannot be \n       // triggered on a null rmNode\n       ClusterMetrics.getMetrics().incrNumRebootedNMs();\n       return reboot;\n     }\n \n     // Send ping\n     this.nmLivelinessMonitor.receivedPing(nodeId);\n \n     // 2. Check if it\u0027s a valid (i.e. not excluded) node\n     if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n       LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n           + rmNode.getNodeAddress());\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n       return shutDown;\n     }\n \n     NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n         .newRecordInstance(NodeHeartbeatResponse.class);\n \n     // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n     HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n     if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Received duplicate heartbeat from node \"\n           + rmNode.getNodeAddress());\n       nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n       return nodeHeartBeatResponse;\n     } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n         .getResponseId()) {\n       LOG.info(\"Too far behind rm response id:\"\n           + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n           + remoteNodeStatus.getResponseId());\n       // TODO: Just sending reboot is not enough. Think more.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n       return reboot;\n     }\n \n     // Heartbeat response\n     HeartbeatResponse latestResponse \u003d recordFactory\n         .newRecordInstance(HeartbeatResponse.class);\n     latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n     latestResponse.addAllContainersToCleanup(rmNode.pullContainersToCleanUp());\n     latestResponse.addAllApplicationsToCleanup(rmNode.pullAppsToCleanup());\n     latestResponse.setNodeAction(NodeAction.NORMAL);\n \n     // 4. Send status to RMNode, saving the latest response.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n-            remoteNodeStatus.getContainersStatuses(), latestResponse));\n+            remoteNodeStatus.getContainersStatuses(), \n+            remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n \n     nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n     return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n      \n      // Updating the metrics directly as reboot event cannot be \n      // triggered on a null rmNode\n      ClusterMetrics.getMetrics().incrNumRebootedNMs();\n      return reboot;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n          + rmNode.getNodeAddress());\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n        .newRecordInstance(NodeHeartbeatResponse.class);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n      return nodeHeartBeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Too far behind rm response id:\"\n          + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n          + remoteNodeStatus.getResponseId());\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return reboot;\n    }\n\n    // Heartbeat response\n    HeartbeatResponse latestResponse \u003d recordFactory\n        .newRecordInstance(HeartbeatResponse.class);\n    latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n    latestResponse.addAllContainersToCleanup(rmNode.pullContainersToCleanUp());\n    latestResponse.addAllApplicationsToCleanup(rmNode.pullAppsToCleanup());\n    latestResponse.setNodeAction(NodeAction.NORMAL);\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), \n            remoteNodeStatus.getKeepAliveApplications(), latestResponse));\n\n    nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "cbdb07f4ca358b9507296868a913977ad82ed716": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2775. Fixed ResourceManager and NodeManager to force a decommissioned node to shutdown. Contributed by Devaraj K.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190467 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/11 10:31 AM",
      "commitName": "cbdb07f4ca358b9507296868a913977ad82ed716",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "25/10/11 7:53 PM",
      "commitNameOld": "29c6c3ed328965a73fe7b68eb29cb30794beef38",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 2.61,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,76 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n-    try {\n-      /**\n-       * Here is the node heartbeat sequence...\n-       * 1. Check if it\u0027s a registered node\n-       * 2. Check if it\u0027s a valid (i.e. not excluded) node\n-       * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n-       * 4. Send healthStatus to RMNode\n-       */\n+    /**\n+     * Here is the node heartbeat sequence...\n+     * 1. Check if it\u0027s a registered node\n+     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n+     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n+     * 4. Send healthStatus to RMNode\n+     */\n+\n+    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n+\n+    // 1. Check if it\u0027s a registered node\n+    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n+    if (rmNode \u003d\u003d null) {\n+      /* node does not exist */\n+      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n       \n-      NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n-      \n-      // 1. Check if it\u0027s a registered node\n-      RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n-      if (rmNode \u003d\u003d null) {\n-        /* node does not exist */\n-        LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n-        return reboot;\n-      }\n-\n-      // Send ping\n-      this.nmLivelinessMonitor.receivedPing(nodeId);\n-\n-      // 2. Check if it\u0027s a valid (i.e. not excluded) node\n-      if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n-        LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId +  \n-            \" hostname: \" + rmNode.getNodeAddress());\n-        throw new IOException(\"Disallowed NodeManager nodeId: \" + \n-            remoteNodeStatus.getNodeId());\n-      }\n-\n-      NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n-          .newRecordInstance(NodeHeartbeatResponse.class);\n-\n-      // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n-      HeartbeatResponse lastHeartbeatResponse \u003d rmNode\n-          .getLastHeartBeatResponse();\n-      if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n-           .getResponseId()) {\n-        LOG.info(\"Received duplicate heartbeat from node \" + \n-            rmNode.getNodeAddress());\n-        nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n-        return nodeHeartBeatResponse;\n-      } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n-          .getResponseId()) {\n-        LOG.info(\"Too far behind rm response id:\" +\n-            lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n-            + remoteNodeStatus.getResponseId());\n-        // TODO: Just sending reboot is not enough. Think more.\n-        this.rmContext.getDispatcher().getEventHandler().handle(\n-            new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n-        return reboot;\n-      }\n-\n-      // Heartbeat response\n-      HeartbeatResponse latestResponse \u003d recordFactory\n-          .newRecordInstance(HeartbeatResponse.class);\n-      latestResponse\n-          .setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n-      latestResponse.addAllContainersToCleanup(rmNode.pullContainersToCleanUp());\n-      latestResponse.addAllApplicationsToCleanup(rmNode.pullAppsToCleanup());\n-\n-      // 4. Send status to RMNode, saving the latest response.\n-      this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n-              remoteNodeStatus.getContainersStatuses(), latestResponse));\n-\n-      nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n-      return nodeHeartBeatResponse;\n-    } catch (IOException ioe) {\n-      LOG.info(\"Exception in heartbeat from node \" + \n-          request.getNodeStatus().getNodeId(), ioe);\n-      throw RPCUtil.getRemoteException(ioe);\n+      // Updating the metrics directly as reboot event cannot be \n+      // triggered on a null rmNode\n+      ClusterMetrics.getMetrics().incrNumRebootedNMs();\n+      return reboot;\n     }\n+\n+    // Send ping\n+    this.nmLivelinessMonitor.receivedPing(nodeId);\n+\n+    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n+    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n+      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n+          + rmNode.getNodeAddress());\n+      this.rmContext.getDispatcher().getEventHandler().handle(\n+          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n+      return shutDown;\n+    }\n+\n+    NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n+        .newRecordInstance(NodeHeartbeatResponse.class);\n+\n+    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n+    HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n+    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n+        .getResponseId()) {\n+      LOG.info(\"Received duplicate heartbeat from node \"\n+          + rmNode.getNodeAddress());\n+      nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n+      return nodeHeartBeatResponse;\n+    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n+        .getResponseId()) {\n+      LOG.info(\"Too far behind rm response id:\"\n+          + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n+          + remoteNodeStatus.getResponseId());\n+      // TODO: Just sending reboot is not enough. Think more.\n+      this.rmContext.getDispatcher().getEventHandler().handle(\n+          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n+      return reboot;\n+    }\n+\n+    // Heartbeat response\n+    HeartbeatResponse latestResponse \u003d recordFactory\n+        .newRecordInstance(HeartbeatResponse.class);\n+    latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n+    latestResponse.addAllContainersToCleanup(rmNode.pullContainersToCleanUp());\n+    latestResponse.addAllApplicationsToCleanup(rmNode.pullAppsToCleanup());\n+    latestResponse.setNodeAction(NodeAction.NORMAL);\n+\n+    // 4. Send status to RMNode, saving the latest response.\n+    this.rmContext.getDispatcher().getEventHandler().handle(\n+        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n+            remoteNodeStatus.getContainersStatuses(), latestResponse));\n+\n+    nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n+    return nodeHeartBeatResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    /**\n     * Here is the node heartbeat sequence...\n     * 1. Check if it\u0027s a registered node\n     * 2. Check if it\u0027s a valid (i.e. not excluded) node \n     * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat \n     * 4. Send healthStatus to RMNode\n     */\n\n    NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n\n    // 1. Check if it\u0027s a registered node\n    RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n    if (rmNode \u003d\u003d null) {\n      /* node does not exist */\n      LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n      \n      // Updating the metrics directly as reboot event cannot be \n      // triggered on a null rmNode\n      ClusterMetrics.getMetrics().incrNumRebootedNMs();\n      return reboot;\n    }\n\n    // Send ping\n    this.nmLivelinessMonitor.receivedPing(nodeId);\n\n    // 2. Check if it\u0027s a valid (i.e. not excluded) node\n    if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n      LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId + \" hostname: \"\n          + rmNode.getNodeAddress());\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.DECOMMISSION));\n      return shutDown;\n    }\n\n    NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n        .newRecordInstance(NodeHeartbeatResponse.class);\n\n    // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n    HeartbeatResponse lastHeartbeatResponse \u003d rmNode.getLastHeartBeatResponse();\n    if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Received duplicate heartbeat from node \"\n          + rmNode.getNodeAddress());\n      nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n      return nodeHeartBeatResponse;\n    } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n        .getResponseId()) {\n      LOG.info(\"Too far behind rm response id:\"\n          + lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n          + remoteNodeStatus.getResponseId());\n      // TODO: Just sending reboot is not enough. Think more.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n      return reboot;\n    }\n\n    // Heartbeat response\n    HeartbeatResponse latestResponse \u003d recordFactory\n        .newRecordInstance(HeartbeatResponse.class);\n    latestResponse.setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n    latestResponse.addAllContainersToCleanup(rmNode.pullContainersToCleanUp());\n    latestResponse.addAllApplicationsToCleanup(rmNode.pullAppsToCleanup());\n    latestResponse.setNodeAction(NodeAction.NORMAL);\n\n    // 4. Send status to RMNode, saving the latest response.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n            remoteNodeStatus.getContainersStatuses(), latestResponse));\n\n    nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n    return nodeHeartBeatResponse;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2933. Change allocate call to return ContainerStatus for completed containers rather than Container.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169484 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/09/11 10:26 AM",
      "commitName": "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "08/09/11 6:44 PM",
      "commitNameOld": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 2.65,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,78 @@\n   public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n       throws YarnRemoteException {\n \n     NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n     try {\n       /**\n        * Here is the node heartbeat sequence...\n        * 1. Check if it\u0027s a registered node\n        * 2. Check if it\u0027s a valid (i.e. not excluded) node\n        * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n        * 4. Send healthStatus to RMNode\n        */\n       \n       NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n       \n       // 1. Check if it\u0027s a registered node\n       RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n       if (rmNode \u003d\u003d null) {\n         /* node does not exist */\n         LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n         return reboot;\n       }\n \n       // Send ping\n       this.nmLivelinessMonitor.receivedPing(nodeId);\n \n       // 2. Check if it\u0027s a valid (i.e. not excluded) node\n       if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n         LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId +  \n             \" hostname: \" + rmNode.getNodeAddress());\n         throw new IOException(\"Disallowed NodeManager nodeId: \" + \n             remoteNodeStatus.getNodeId());\n       }\n \n       NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n           .newRecordInstance(NodeHeartbeatResponse.class);\n \n       // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n       HeartbeatResponse lastHeartbeatResponse \u003d rmNode\n           .getLastHeartBeatResponse();\n       if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n            .getResponseId()) {\n         LOG.info(\"Received duplicate heartbeat from node \" + \n             rmNode.getNodeAddress());\n         nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n         return nodeHeartBeatResponse;\n       } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n           .getResponseId()) {\n         LOG.info(\"Too far behind rm response id:\" +\n             lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n             + remoteNodeStatus.getResponseId());\n         // TODO: Just sending reboot is not enough. Think more.\n         this.rmContext.getDispatcher().getEventHandler().handle(\n             new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n         return reboot;\n       }\n \n       // Heartbeat response\n       HeartbeatResponse latestResponse \u003d recordFactory\n           .newRecordInstance(HeartbeatResponse.class);\n       latestResponse\n           .setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n       latestResponse.addAllContainersToCleanup(rmNode.pullContainersToCleanUp());\n       latestResponse.addAllApplicationsToCleanup(rmNode.pullAppsToCleanup());\n \n       // 4. Send status to RMNode, saving the latest response.\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n-              remoteNodeStatus.getAllContainers(), latestResponse));\n+              remoteNodeStatus.getContainersStatuses(), latestResponse));\n \n       nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n       return nodeHeartBeatResponse;\n     } catch (IOException ioe) {\n       LOG.info(\"Exception in heartbeat from node \" + \n           request.getNodeStatus().getNodeId(), ioe);\n       throw RPCUtil.getRemoteException(ioe);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    try {\n      /**\n       * Here is the node heartbeat sequence...\n       * 1. Check if it\u0027s a registered node\n       * 2. Check if it\u0027s a valid (i.e. not excluded) node\n       * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n       * 4. Send healthStatus to RMNode\n       */\n      \n      NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n      \n      // 1. Check if it\u0027s a registered node\n      RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n      if (rmNode \u003d\u003d null) {\n        /* node does not exist */\n        LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n        return reboot;\n      }\n\n      // Send ping\n      this.nmLivelinessMonitor.receivedPing(nodeId);\n\n      // 2. Check if it\u0027s a valid (i.e. not excluded) node\n      if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n        LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId +  \n            \" hostname: \" + rmNode.getNodeAddress());\n        throw new IOException(\"Disallowed NodeManager nodeId: \" + \n            remoteNodeStatus.getNodeId());\n      }\n\n      NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n          .newRecordInstance(NodeHeartbeatResponse.class);\n\n      // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      HeartbeatResponse lastHeartbeatResponse \u003d rmNode\n          .getLastHeartBeatResponse();\n      if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n           .getResponseId()) {\n        LOG.info(\"Received duplicate heartbeat from node \" + \n            rmNode.getNodeAddress());\n        nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n        return nodeHeartBeatResponse;\n      } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n          .getResponseId()) {\n        LOG.info(\"Too far behind rm response id:\" +\n            lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n            + remoteNodeStatus.getResponseId());\n        // TODO: Just sending reboot is not enough. Think more.\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n        return reboot;\n      }\n\n      // Heartbeat response\n      HeartbeatResponse latestResponse \u003d recordFactory\n          .newRecordInstance(HeartbeatResponse.class);\n      latestResponse\n          .setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n      latestResponse.addAllContainersToCleanup(rmNode.pullContainersToCleanUp());\n      latestResponse.addAllApplicationsToCleanup(rmNode.pullAppsToCleanup());\n\n      // 4. Send status to RMNode, saving the latest response.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n              remoteNodeStatus.getContainersStatuses(), latestResponse));\n\n      nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n      return nodeHeartBeatResponse;\n    } catch (IOException ioe) {\n      LOG.info(\"Exception in heartbeat from node \" + \n          request.getNodeStatus().getNodeId(), ioe);\n      throw RPCUtil.getRemoteException(ioe);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    try {\n      /**\n       * Here is the node heartbeat sequence...\n       * 1. Check if it\u0027s a registered node\n       * 2. Check if it\u0027s a valid (i.e. not excluded) node\n       * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n       * 4. Send healthStatus to RMNode\n       */\n      \n      NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n      \n      // 1. Check if it\u0027s a registered node\n      RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n      if (rmNode \u003d\u003d null) {\n        /* node does not exist */\n        LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n        return reboot;\n      }\n\n      // Send ping\n      this.nmLivelinessMonitor.receivedPing(nodeId);\n\n      // 2. Check if it\u0027s a valid (i.e. not excluded) node\n      if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n        LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId +  \n            \" hostname: \" + rmNode.getNodeAddress());\n        throw new IOException(\"Disallowed NodeManager nodeId: \" + \n            remoteNodeStatus.getNodeId());\n      }\n\n      NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n          .newRecordInstance(NodeHeartbeatResponse.class);\n\n      // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      HeartbeatResponse lastHeartbeatResponse \u003d rmNode\n          .getLastHeartBeatResponse();\n      if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n           .getResponseId()) {\n        LOG.info(\"Received duplicate heartbeat from node \" + \n            rmNode.getNodeAddress());\n        nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n        return nodeHeartBeatResponse;\n      } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n          .getResponseId()) {\n        LOG.info(\"Too far behind rm response id:\" +\n            lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n            + remoteNodeStatus.getResponseId());\n        // TODO: Just sending reboot is not enough. Think more.\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n        return reboot;\n      }\n\n      // Heartbeat response\n      HeartbeatResponse latestResponse \u003d recordFactory\n          .newRecordInstance(HeartbeatResponse.class);\n      latestResponse\n          .setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n      latestResponse.addAllContainersToCleanup(rmNode.pullContainersToCleanUp());\n      latestResponse.addAllApplicationsToCleanup(rmNode.pullAppsToCleanup());\n\n      // 4. Send status to RMNode, saving the latest response.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n              remoteNodeStatus.getAllContainers(), latestResponse));\n\n      nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n      return nodeHeartBeatResponse;\n    } catch (IOException ioe) {\n      LOG.info(\"Exception in heartbeat from node \" + \n          request.getNodeStatus().getNodeId(), ioe);\n      throw RPCUtil.getRemoteException(ioe);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,78 @@\n+  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n+      throws YarnRemoteException {\n+\n+    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n+    try {\n+      /**\n+       * Here is the node heartbeat sequence...\n+       * 1. Check if it\u0027s a registered node\n+       * 2. Check if it\u0027s a valid (i.e. not excluded) node\n+       * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n+       * 4. Send healthStatus to RMNode\n+       */\n+      \n+      NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n+      \n+      // 1. Check if it\u0027s a registered node\n+      RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n+      if (rmNode \u003d\u003d null) {\n+        /* node does not exist */\n+        LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n+        return reboot;\n+      }\n+\n+      // Send ping\n+      this.nmLivelinessMonitor.receivedPing(nodeId);\n+\n+      // 2. Check if it\u0027s a valid (i.e. not excluded) node\n+      if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n+        LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId +  \n+            \" hostname: \" + rmNode.getNodeAddress());\n+        throw new IOException(\"Disallowed NodeManager nodeId: \" + \n+            remoteNodeStatus.getNodeId());\n+      }\n+\n+      NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n+          .newRecordInstance(NodeHeartbeatResponse.class);\n+\n+      // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n+      HeartbeatResponse lastHeartbeatResponse \u003d rmNode\n+          .getLastHeartBeatResponse();\n+      if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n+           .getResponseId()) {\n+        LOG.info(\"Received duplicate heartbeat from node \" + \n+            rmNode.getNodeAddress());\n+        nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n+        return nodeHeartBeatResponse;\n+      } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n+          .getResponseId()) {\n+        LOG.info(\"Too far behind rm response id:\" +\n+            lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n+            + remoteNodeStatus.getResponseId());\n+        // TODO: Just sending reboot is not enough. Think more.\n+        this.rmContext.getDispatcher().getEventHandler().handle(\n+            new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n+        return reboot;\n+      }\n+\n+      // Heartbeat response\n+      HeartbeatResponse latestResponse \u003d recordFactory\n+          .newRecordInstance(HeartbeatResponse.class);\n+      latestResponse\n+          .setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n+      latestResponse.addAllContainersToCleanup(rmNode.pullContainersToCleanUp());\n+      latestResponse.addAllApplicationsToCleanup(rmNode.pullAppsToCleanup());\n+\n+      // 4. Send status to RMNode, saving the latest response.\n+      this.rmContext.getDispatcher().getEventHandler().handle(\n+          new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n+              remoteNodeStatus.getAllContainers(), latestResponse));\n+\n+      nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n+      return nodeHeartBeatResponse;\n+    } catch (IOException ioe) {\n+      LOG.info(\"Exception in heartbeat from node \" + \n+          request.getNodeStatus().getNodeId(), ioe);\n+      throw RPCUtil.getRemoteException(ioe);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public NodeHeartbeatResponse nodeHeartbeat(NodeHeartbeatRequest request)\n      throws YarnRemoteException {\n\n    NodeStatus remoteNodeStatus \u003d request.getNodeStatus();\n    try {\n      /**\n       * Here is the node heartbeat sequence...\n       * 1. Check if it\u0027s a registered node\n       * 2. Check if it\u0027s a valid (i.e. not excluded) node\n       * 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n       * 4. Send healthStatus to RMNode\n       */\n      \n      NodeId nodeId \u003d remoteNodeStatus.getNodeId();\n      \n      // 1. Check if it\u0027s a registered node\n      RMNode rmNode \u003d this.rmContext.getRMNodes().get(nodeId);\n      if (rmNode \u003d\u003d null) {\n        /* node does not exist */\n        LOG.info(\"Node not found rebooting \" + remoteNodeStatus.getNodeId());\n        return reboot;\n      }\n\n      // Send ping\n      this.nmLivelinessMonitor.receivedPing(nodeId);\n\n      // 2. Check if it\u0027s a valid (i.e. not excluded) node\n      if (!this.nodesListManager.isValidNode(rmNode.getHostName())) {\n        LOG.info(\"Disallowed NodeManager nodeId: \" + nodeId +  \n            \" hostname: \" + rmNode.getNodeAddress());\n        throw new IOException(\"Disallowed NodeManager nodeId: \" + \n            remoteNodeStatus.getNodeId());\n      }\n\n      NodeHeartbeatResponse nodeHeartBeatResponse \u003d recordFactory\n          .newRecordInstance(NodeHeartbeatResponse.class);\n\n      // 3. Check if it\u0027s a \u0027fresh\u0027 heartbeat i.e. not duplicate heartbeat\n      HeartbeatResponse lastHeartbeatResponse \u003d rmNode\n          .getLastHeartBeatResponse();\n      if (remoteNodeStatus.getResponseId() + 1 \u003d\u003d lastHeartbeatResponse\n           .getResponseId()) {\n        LOG.info(\"Received duplicate heartbeat from node \" + \n            rmNode.getNodeAddress());\n        nodeHeartBeatResponse.setHeartbeatResponse(lastHeartbeatResponse);\n        return nodeHeartBeatResponse;\n      } else if (remoteNodeStatus.getResponseId() + 1 \u003c lastHeartbeatResponse\n          .getResponseId()) {\n        LOG.info(\"Too far behind rm response id:\" +\n            lastHeartbeatResponse.getResponseId() + \" nm response id:\"\n            + remoteNodeStatus.getResponseId());\n        // TODO: Just sending reboot is not enough. Think more.\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMNodeEvent(nodeId, RMNodeEventType.REBOOTING));\n        return reboot;\n      }\n\n      // Heartbeat response\n      HeartbeatResponse latestResponse \u003d recordFactory\n          .newRecordInstance(HeartbeatResponse.class);\n      latestResponse\n          .setResponseId(lastHeartbeatResponse.getResponseId() + 1);\n      latestResponse.addAllContainersToCleanup(rmNode.pullContainersToCleanUp());\n      latestResponse.addAllApplicationsToCleanup(rmNode.pullAppsToCleanup());\n\n      // 4. Send status to RMNode, saving the latest response.\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeStatusEvent(nodeId, remoteNodeStatus.getNodeHealthStatus(),\n              remoteNodeStatus.getAllContainers(), latestResponse));\n\n      nodeHeartBeatResponse.setHeartbeatResponse(latestResponse);\n      return nodeHeartBeatResponse;\n    } catch (IOException ioe) {\n      LOG.info(\"Exception in heartbeat from node \" + \n          request.getNodeStatus().getNodeId(), ioe);\n      throw RPCUtil.getRemoteException(ioe);\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java"
    }
  }
}