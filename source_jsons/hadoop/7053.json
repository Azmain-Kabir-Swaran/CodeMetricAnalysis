{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSPermissionChecker.java",
  "functionName": "hasAclPermission",
  "functionId": "hasAclPermission___inode-INodeAttributes__access-FsAction__mode-FsPermission__aclFeature-AclFeature",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
  "functionStartLine": 550,
  "functionEndLine": 603,
  "numCommitsSeen": 51,
  "timeTaken": 1805,
  "changeHistory": [
    "2550371f66c49fe0e40aadaa68744311270084ce",
    "438a9f047eb6af2a4b916a4f6ef6f68adeab8068"
  ],
  "changeHistoryShort": {
    "2550371f66c49fe0e40aadaa68744311270084ce": "Ybodychange",
    "438a9f047eb6af2a4b916a4f6ef6f68adeab8068": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2550371f66c49fe0e40aadaa68744311270084ce": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10711. Optimize FSPermissionChecker group membership check. Contributed by Daryn Sharp.\n",
      "commitDate": "19/08/16 7:12 AM",
      "commitName": "2550371f66c49fe0e40aadaa68744311270084ce",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/08/16 2:14 PM",
      "commitNameOld": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 14.71,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   private boolean hasAclPermission(INodeAttributes inode,\n       FsAction access, FsPermission mode, AclFeature aclFeature) {\n     boolean foundMatch \u003d false;\n \n     // Use owner entry from permission bits if user is owner.\n     if (getUser().equals(inode.getUserName())) {\n       if (mode.getUserAction().implies(access)) {\n         return true;\n       }\n       foundMatch \u003d true;\n     }\n \n     // Check named user and group entries if user was not denied by owner entry.\n     if (!foundMatch) {\n       for (int pos \u003d 0, entry; pos \u003c aclFeature.getEntriesSize(); pos++) {\n         entry \u003d aclFeature.getEntryAt(pos);\n         if (AclEntryStatusFormat.getScope(entry) \u003d\u003d AclEntryScope.DEFAULT) {\n           break;\n         }\n         AclEntryType type \u003d AclEntryStatusFormat.getType(entry);\n         String name \u003d AclEntryStatusFormat.getName(entry);\n         if (type \u003d\u003d AclEntryType.USER) {\n           // Use named user entry with mask from permission bits applied if user\n           // matches name.\n           if (getUser().equals(name)) {\n             FsAction masked \u003d AclEntryStatusFormat.getPermission(entry).and(\n                 mode.getGroupAction());\n             if (masked.implies(access)) {\n               return true;\n             }\n             foundMatch \u003d true;\n             break;\n           }\n         } else if (type \u003d\u003d AclEntryType.GROUP) {\n           // Use group entry (unnamed or named) with mask from permission bits\n           // applied if user is a member and entry grants access.  If user is a\n           // member of multiple groups that have entries that grant access, then\n           // it doesn\u0027t matter which is chosen, so exit early after first match.\n           String group \u003d name \u003d\u003d null ? inode.getGroupName() : name;\n-          if (getGroups().contains(group)) {\n+          if (isMemberOfGroup(group)) {\n             FsAction masked \u003d AclEntryStatusFormat.getPermission(entry).and(\n                 mode.getGroupAction());\n             if (masked.implies(access)) {\n               return true;\n             }\n             foundMatch \u003d true;\n           }\n         }\n       }\n     }\n \n     // Use other entry if user was not denied by an earlier match.\n     return !foundMatch \u0026\u0026 mode.getOtherAction().implies(access);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean hasAclPermission(INodeAttributes inode,\n      FsAction access, FsPermission mode, AclFeature aclFeature) {\n    boolean foundMatch \u003d false;\n\n    // Use owner entry from permission bits if user is owner.\n    if (getUser().equals(inode.getUserName())) {\n      if (mode.getUserAction().implies(access)) {\n        return true;\n      }\n      foundMatch \u003d true;\n    }\n\n    // Check named user and group entries if user was not denied by owner entry.\n    if (!foundMatch) {\n      for (int pos \u003d 0, entry; pos \u003c aclFeature.getEntriesSize(); pos++) {\n        entry \u003d aclFeature.getEntryAt(pos);\n        if (AclEntryStatusFormat.getScope(entry) \u003d\u003d AclEntryScope.DEFAULT) {\n          break;\n        }\n        AclEntryType type \u003d AclEntryStatusFormat.getType(entry);\n        String name \u003d AclEntryStatusFormat.getName(entry);\n        if (type \u003d\u003d AclEntryType.USER) {\n          // Use named user entry with mask from permission bits applied if user\n          // matches name.\n          if (getUser().equals(name)) {\n            FsAction masked \u003d AclEntryStatusFormat.getPermission(entry).and(\n                mode.getGroupAction());\n            if (masked.implies(access)) {\n              return true;\n            }\n            foundMatch \u003d true;\n            break;\n          }\n        } else if (type \u003d\u003d AclEntryType.GROUP) {\n          // Use group entry (unnamed or named) with mask from permission bits\n          // applied if user is a member and entry grants access.  If user is a\n          // member of multiple groups that have entries that grant access, then\n          // it doesn\u0027t matter which is chosen, so exit early after first match.\n          String group \u003d name \u003d\u003d null ? inode.getGroupName() : name;\n          if (isMemberOfGroup(group)) {\n            FsAction masked \u003d AclEntryStatusFormat.getPermission(entry).and(\n                mode.getGroupAction());\n            if (masked.implies(access)) {\n              return true;\n            }\n            foundMatch \u003d true;\n          }\n        }\n      }\n    }\n\n    // Use other entry if user was not denied by an earlier match.\n    return !foundMatch \u0026\u0026 mode.getOtherAction().implies(access);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java",
      "extendedDetails": {}
    },
    "438a9f047eb6af2a4b916a4f6ef6f68adeab8068": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10673. Optimize FSPermissionChecker\u0027s internal path usage. Contributed by Daryn Sharp.\n",
      "commitDate": "04/08/16 2:14 PM",
      "commitName": "438a9f047eb6af2a4b916a4f6ef6f68adeab8068",
      "commitAuthor": "Kihwal Lee",
      "diff": "@@ -0,0 +1,54 @@\n+  private boolean hasAclPermission(INodeAttributes inode,\n+      FsAction access, FsPermission mode, AclFeature aclFeature) {\n+    boolean foundMatch \u003d false;\n+\n+    // Use owner entry from permission bits if user is owner.\n+    if (getUser().equals(inode.getUserName())) {\n+      if (mode.getUserAction().implies(access)) {\n+        return true;\n+      }\n+      foundMatch \u003d true;\n+    }\n+\n+    // Check named user and group entries if user was not denied by owner entry.\n+    if (!foundMatch) {\n+      for (int pos \u003d 0, entry; pos \u003c aclFeature.getEntriesSize(); pos++) {\n+        entry \u003d aclFeature.getEntryAt(pos);\n+        if (AclEntryStatusFormat.getScope(entry) \u003d\u003d AclEntryScope.DEFAULT) {\n+          break;\n+        }\n+        AclEntryType type \u003d AclEntryStatusFormat.getType(entry);\n+        String name \u003d AclEntryStatusFormat.getName(entry);\n+        if (type \u003d\u003d AclEntryType.USER) {\n+          // Use named user entry with mask from permission bits applied if user\n+          // matches name.\n+          if (getUser().equals(name)) {\n+            FsAction masked \u003d AclEntryStatusFormat.getPermission(entry).and(\n+                mode.getGroupAction());\n+            if (masked.implies(access)) {\n+              return true;\n+            }\n+            foundMatch \u003d true;\n+            break;\n+          }\n+        } else if (type \u003d\u003d AclEntryType.GROUP) {\n+          // Use group entry (unnamed or named) with mask from permission bits\n+          // applied if user is a member and entry grants access.  If user is a\n+          // member of multiple groups that have entries that grant access, then\n+          // it doesn\u0027t matter which is chosen, so exit early after first match.\n+          String group \u003d name \u003d\u003d null ? inode.getGroupName() : name;\n+          if (getGroups().contains(group)) {\n+            FsAction masked \u003d AclEntryStatusFormat.getPermission(entry).and(\n+                mode.getGroupAction());\n+            if (masked.implies(access)) {\n+              return true;\n+            }\n+            foundMatch \u003d true;\n+          }\n+        }\n+      }\n+    }\n+\n+    // Use other entry if user was not denied by an earlier match.\n+    return !foundMatch \u0026\u0026 mode.getOtherAction().implies(access);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean hasAclPermission(INodeAttributes inode,\n      FsAction access, FsPermission mode, AclFeature aclFeature) {\n    boolean foundMatch \u003d false;\n\n    // Use owner entry from permission bits if user is owner.\n    if (getUser().equals(inode.getUserName())) {\n      if (mode.getUserAction().implies(access)) {\n        return true;\n      }\n      foundMatch \u003d true;\n    }\n\n    // Check named user and group entries if user was not denied by owner entry.\n    if (!foundMatch) {\n      for (int pos \u003d 0, entry; pos \u003c aclFeature.getEntriesSize(); pos++) {\n        entry \u003d aclFeature.getEntryAt(pos);\n        if (AclEntryStatusFormat.getScope(entry) \u003d\u003d AclEntryScope.DEFAULT) {\n          break;\n        }\n        AclEntryType type \u003d AclEntryStatusFormat.getType(entry);\n        String name \u003d AclEntryStatusFormat.getName(entry);\n        if (type \u003d\u003d AclEntryType.USER) {\n          // Use named user entry with mask from permission bits applied if user\n          // matches name.\n          if (getUser().equals(name)) {\n            FsAction masked \u003d AclEntryStatusFormat.getPermission(entry).and(\n                mode.getGroupAction());\n            if (masked.implies(access)) {\n              return true;\n            }\n            foundMatch \u003d true;\n            break;\n          }\n        } else if (type \u003d\u003d AclEntryType.GROUP) {\n          // Use group entry (unnamed or named) with mask from permission bits\n          // applied if user is a member and entry grants access.  If user is a\n          // member of multiple groups that have entries that grant access, then\n          // it doesn\u0027t matter which is chosen, so exit early after first match.\n          String group \u003d name \u003d\u003d null ? inode.getGroupName() : name;\n          if (getGroups().contains(group)) {\n            FsAction masked \u003d AclEntryStatusFormat.getPermission(entry).and(\n                mode.getGroupAction());\n            if (masked.implies(access)) {\n              return true;\n            }\n            foundMatch \u003d true;\n          }\n        }\n      }\n    }\n\n    // Use other entry if user was not denied by an earlier match.\n    return !foundMatch \u0026\u0026 mode.getOtherAction().implies(access);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSPermissionChecker.java"
    }
  }
}