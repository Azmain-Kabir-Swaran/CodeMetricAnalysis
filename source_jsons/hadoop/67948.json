{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DistCpUtils.java",
  "functionName": "preserve",
  "functionId": "preserve___targetFS-FileSystem__path-Path__srcFileStatus-CopyListingFileStatus__attributes-EnumSet__FileAttribute____preserveRawXattrs-boolean",
  "sourceFilePath": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
  "functionStartLine": 197,
  "functionEndLine": 278,
  "numCommitsSeen": 35,
  "timeTaken": 4579,
  "changeHistory": [
    "20eec958674a9c343a80c9fccd1383ef7c1b57f5",
    "546c5d70efebb828389f609a89b123c4ee51f867",
    "0e6f8e4bc6642f90dc7b33848bfb1129ec20ee49",
    "c918286b17e7f2a64735d0c972a8dd749e0bf6c4",
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
    "9cedad11d8d2197a54732667a15344983de5c437",
    "946456c6d88780abe0251b098dd771e9e1e93ab3",
    "3cde37c991b18370cc1b383f920a9d5bd2d91adb",
    "041b8326a1511b721958792a6b94ecfe27d7a1fb",
    "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9",
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67"
  ],
  "changeHistoryShort": {
    "20eec958674a9c343a80c9fccd1383ef7c1b57f5": "Ybodychange",
    "546c5d70efebb828389f609a89b123c4ee51f867": "Ybodychange",
    "0e6f8e4bc6642f90dc7b33848bfb1129ec20ee49": "Ybodychange",
    "c918286b17e7f2a64735d0c972a8dd749e0bf6c4": "Ybodychange",
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": "Ybodychange",
    "9cedad11d8d2197a54732667a15344983de5c437": "Ybodychange",
    "946456c6d88780abe0251b098dd771e9e1e93ab3": "Ybodychange",
    "3cde37c991b18370cc1b383f920a9d5bd2d91adb": "Ybodychange",
    "041b8326a1511b721958792a6b94ecfe27d7a1fb": "Ymultichange(Yparameterchange,Ybodychange)",
    "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9": "Ybodychange",
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05": "Ymultichange(Yparameterchange,Ybodychange)",
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67": "Yintroduced"
  },
  "changeHistoryDetails": {
    "20eec958674a9c343a80c9fccd1383ef7c1b57f5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16932. distcp copy calls getFileStatus() needlessly and can fail against S3 (#1936)\n\n\r\nContributed by Steve Loughran.\r\n\r\nThis strips out all the -p preservation options which have already been\r\nprocessed when uploading a file before deciding whether or not to query\r\nthe far end for the status of the (existing/uploaded) file to see if any\r\nother attributes need changing.\r\n\r\nThis will avoid 404 caching-related issues in S3, wherein a newly created\r\nfile can have a 404 entry in the S3 load balancer\u0027s cache from the\r\nprobes for the file\u0027s existence prior to the upload.\r\n\r\nIt partially addresses a regression caused by HADOOP-8143,\r\n\"Change distcp to have -pb on by default\" that causes a resurfacing\r\nof HADOOP-13145, \"In DistCp, prevent unnecessary getFileStatus call when\r\nnot preserving metadata\"\r\n",
      "commitDate": "07/04/20 9:55 AM",
      "commitName": "20eec958674a9c343a80c9fccd1383ef7c1b57f5",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "24/09/19 3:23 AM",
      "commitNameOld": "51c64b357d4bd1a0038e61df3d4b8ea0a3ad7449",
      "commitAuthorOld": "Mukund Thakur",
      "daysBetweenCommits": 196.27,
      "commitsBetweenForRepo": 766,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,82 @@\n   public static void preserve(FileSystem targetFS, Path path,\n                               CopyListingFileStatus srcFileStatus,\n                               EnumSet\u003cFileAttribute\u003e attributes,\n                               boolean preserveRawXattrs) throws IOException {\n \n+    // strip out those attributes we don\u0027t need any more\n+    attributes.remove(FileAttribute.BLOCKSIZE);\n+    attributes.remove(FileAttribute.CHECKSUMTYPE);\n     // If not preserving anything from FileStatus, don\u0027t bother fetching it.\n     FileStatus targetFileStatus \u003d attributes.isEmpty() ? null :\n         targetFS.getFileStatus(path);\n     String group \u003d targetFileStatus \u003d\u003d null ? null :\n         targetFileStatus.getGroup();\n     String user \u003d targetFileStatus \u003d\u003d null ? null :\n         targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n     if (attributes.contains(FileAttribute.ACL)) {\n       List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n       List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n       if (!srcAcl.equals(targetAcl)) {\n         targetFS.removeAcl(path);\n         targetFS.setAcl(path, srcAcl);\n       }\n       // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n       if (srcFileStatus.getPermission().getStickyBit() !\u003d\n           targetFileStatus.getPermission().getStickyBit()) {\n         targetFS.setPermission(path, srcFileStatus.getPermission());\n       }\n     } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n \n     final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n     if (preserveXAttrs || preserveRawXattrs) {\n       final String rawNS \u003d\n           StringUtils.toLowerCase(XAttr.NameSpace.RAW.name());\n       Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n       Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n       if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n         for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n           String xattrName \u003d entry.getKey();\n           if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n             targetFS.setXAttr(path, xattrName, entry.getValue());\n           }\n         }\n       }\n     }\n \n     // The replication factor can only be preserved for replicated files.\n     // It is ignored when either the source or target file are erasure coded.\n     if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026\n         !targetFileStatus.isDirectory() \u0026\u0026\n         !targetFileStatus.isErasureCoded() \u0026\u0026\n         !srcFileStatus.isErasureCoded() \u0026\u0026\n         srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n         !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n         !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n     \n     if (attributes.contains(FileAttribute.TIMES)) {\n       targetFS.setTimes(path, \n           srcFileStatus.getModificationTime(), \n           srcFileStatus.getAccessTime());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes,\n                              boolean preserveRawXattrs) throws IOException {\n\n    // strip out those attributes we don\u0027t need any more\n    attributes.remove(FileAttribute.BLOCKSIZE);\n    attributes.remove(FileAttribute.CHECKSUMTYPE);\n    // If not preserving anything from FileStatus, don\u0027t bother fetching it.\n    FileStatus targetFileStatus \u003d attributes.isEmpty() ? null :\n        targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus \u003d\u003d null ? null :\n        targetFileStatus.getGroup();\n    String user \u003d targetFileStatus \u003d\u003d null ? null :\n        targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.removeAcl(path);\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n    if (preserveXAttrs || preserveRawXattrs) {\n      final String rawNS \u003d\n          StringUtils.toLowerCase(XAttr.NameSpace.RAW.name());\n      Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n      Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n      if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n        for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n          String xattrName \u003d entry.getKey();\n          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n            targetFS.setXAttr(path, xattrName, entry.getValue());\n          }\n        }\n      }\n    }\n\n    // The replication factor can only be preserved for replicated files.\n    // It is ignored when either the source or target file are erasure coded.\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026\n        !targetFileStatus.isDirectory() \u0026\u0026\n        !targetFileStatus.isErasureCoded() \u0026\u0026\n        !srcFileStatus.isErasureCoded() \u0026\u0026\n        srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n        !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n        !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n    \n    if (attributes.contains(FileAttribute.TIMES)) {\n      targetFS.setTimes(path, \n          srcFileStatus.getModificationTime(), \n          srcFileStatus.getAccessTime());\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
      "extendedDetails": {}
    },
    "546c5d70efebb828389f609a89b123c4ee51f867": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16032. Distcp It should clear sub directory ACL before applying new ACL on.\n",
      "commitDate": "07/02/19 1:48 PM",
      "commitName": "546c5d70efebb828389f609a89b123c4ee51f867",
      "commitAuthor": "Ranith Sardar",
      "commitDateOld": "15/08/18 8:31 AM",
      "commitNameOld": "3e3963b035911703c61e6d9a2939eb894da5644c",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 176.26,
      "commitsBetweenForRepo": 1367,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,79 @@\n   public static void preserve(FileSystem targetFS, Path path,\n                               CopyListingFileStatus srcFileStatus,\n                               EnumSet\u003cFileAttribute\u003e attributes,\n                               boolean preserveRawXattrs) throws IOException {\n \n     // If not preserving anything from FileStatus, don\u0027t bother fetching it.\n     FileStatus targetFileStatus \u003d attributes.isEmpty() ? null :\n         targetFS.getFileStatus(path);\n     String group \u003d targetFileStatus \u003d\u003d null ? null :\n         targetFileStatus.getGroup();\n     String user \u003d targetFileStatus \u003d\u003d null ? null :\n         targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n     if (attributes.contains(FileAttribute.ACL)) {\n       List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n       List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n       if (!srcAcl.equals(targetAcl)) {\n+        targetFS.removeAcl(path);\n         targetFS.setAcl(path, srcAcl);\n       }\n       // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n       if (srcFileStatus.getPermission().getStickyBit() !\u003d\n           targetFileStatus.getPermission().getStickyBit()) {\n         targetFS.setPermission(path, srcFileStatus.getPermission());\n       }\n     } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n \n     final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n     if (preserveXAttrs || preserveRawXattrs) {\n       final String rawNS \u003d\n           StringUtils.toLowerCase(XAttr.NameSpace.RAW.name());\n       Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n       Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n       if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n         for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n           String xattrName \u003d entry.getKey();\n           if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n             targetFS.setXAttr(path, xattrName, entry.getValue());\n           }\n         }\n       }\n     }\n \n     // The replication factor can only be preserved for replicated files.\n     // It is ignored when either the source or target file are erasure coded.\n     if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026\n         !targetFileStatus.isDirectory() \u0026\u0026\n         !targetFileStatus.isErasureCoded() \u0026\u0026\n         !srcFileStatus.isErasureCoded() \u0026\u0026\n         srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n         !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n         !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n     \n     if (attributes.contains(FileAttribute.TIMES)) {\n       targetFS.setTimes(path, \n           srcFileStatus.getModificationTime(), \n           srcFileStatus.getAccessTime());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes,\n                              boolean preserveRawXattrs) throws IOException {\n\n    // If not preserving anything from FileStatus, don\u0027t bother fetching it.\n    FileStatus targetFileStatus \u003d attributes.isEmpty() ? null :\n        targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus \u003d\u003d null ? null :\n        targetFileStatus.getGroup();\n    String user \u003d targetFileStatus \u003d\u003d null ? null :\n        targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.removeAcl(path);\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n    if (preserveXAttrs || preserveRawXattrs) {\n      final String rawNS \u003d\n          StringUtils.toLowerCase(XAttr.NameSpace.RAW.name());\n      Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n      Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n      if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n        for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n          String xattrName \u003d entry.getKey();\n          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n            targetFS.setXAttr(path, xattrName, entry.getValue());\n          }\n        }\n      }\n    }\n\n    // The replication factor can only be preserved for replicated files.\n    // It is ignored when either the source or target file are erasure coded.\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026\n        !targetFileStatus.isDirectory() \u0026\u0026\n        !targetFileStatus.isErasureCoded() \u0026\u0026\n        !srcFileStatus.isErasureCoded() \u0026\u0026\n        srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n        !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n        !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n    \n    if (attributes.contains(FileAttribute.TIMES)) {\n      targetFS.setTimes(path, \n          srcFileStatus.getModificationTime(), \n          srcFileStatus.getAccessTime());\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
      "extendedDetails": {}
    },
    "0e6f8e4bc6642f90dc7b33848bfb1129ec20ee49": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10971. Distcp should not copy replication factor if source file is erasure coded. Contributed by Manoj Govindassamy.\n",
      "commitDate": "28/03/17 10:14 PM",
      "commitName": "0e6f8e4bc6642f90dc7b33848bfb1129ec20ee49",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "15/11/16 10:57 AM",
      "commitNameOld": "5af572b6443715b7a741296c1bd520a1840f9a7c",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 133.43,
      "commitsBetweenForRepo": 713,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,78 @@\n   public static void preserve(FileSystem targetFS, Path path,\n                               CopyListingFileStatus srcFileStatus,\n                               EnumSet\u003cFileAttribute\u003e attributes,\n                               boolean preserveRawXattrs) throws IOException {\n \n     // If not preserving anything from FileStatus, don\u0027t bother fetching it.\n     FileStatus targetFileStatus \u003d attributes.isEmpty() ? null :\n         targetFS.getFileStatus(path);\n     String group \u003d targetFileStatus \u003d\u003d null ? null :\n         targetFileStatus.getGroup();\n     String user \u003d targetFileStatus \u003d\u003d null ? null :\n         targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n     if (attributes.contains(FileAttribute.ACL)) {\n       List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n       List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n       if (!srcAcl.equals(targetAcl)) {\n         targetFS.setAcl(path, srcAcl);\n       }\n       // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n       if (srcFileStatus.getPermission().getStickyBit() !\u003d\n           targetFileStatus.getPermission().getStickyBit()) {\n         targetFS.setPermission(path, srcFileStatus.getPermission());\n       }\n     } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n \n     final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n     if (preserveXAttrs || preserveRawXattrs) {\n       final String rawNS \u003d\n           StringUtils.toLowerCase(XAttr.NameSpace.RAW.name());\n       Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n       Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n       if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n         for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n           String xattrName \u003d entry.getKey();\n           if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n             targetFS.setXAttr(path, xattrName, entry.getValue());\n           }\n         }\n       }\n     }\n \n-    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 !targetFileStatus.isDirectory() \u0026\u0026\n-        (srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication())) {\n+    // The replication factor can only be preserved for replicated files.\n+    // It is ignored when either the source or target file are erasure coded.\n+    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026\n+        !targetFileStatus.isDirectory() \u0026\u0026\n+        !targetFileStatus.isErasureCoded() \u0026\u0026\n+        !srcFileStatus.isErasureCoded() \u0026\u0026\n+        srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n         !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n         !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n     \n     if (attributes.contains(FileAttribute.TIMES)) {\n       targetFS.setTimes(path, \n           srcFileStatus.getModificationTime(), \n           srcFileStatus.getAccessTime());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes,\n                              boolean preserveRawXattrs) throws IOException {\n\n    // If not preserving anything from FileStatus, don\u0027t bother fetching it.\n    FileStatus targetFileStatus \u003d attributes.isEmpty() ? null :\n        targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus \u003d\u003d null ? null :\n        targetFileStatus.getGroup();\n    String user \u003d targetFileStatus \u003d\u003d null ? null :\n        targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n    if (preserveXAttrs || preserveRawXattrs) {\n      final String rawNS \u003d\n          StringUtils.toLowerCase(XAttr.NameSpace.RAW.name());\n      Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n      Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n      if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n        for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n          String xattrName \u003d entry.getKey();\n          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n            targetFS.setXAttr(path, xattrName, entry.getValue());\n          }\n        }\n      }\n    }\n\n    // The replication factor can only be preserved for replicated files.\n    // It is ignored when either the source or target file are erasure coded.\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026\n        !targetFileStatus.isDirectory() \u0026\u0026\n        !targetFileStatus.isErasureCoded() \u0026\u0026\n        !srcFileStatus.isErasureCoded() \u0026\u0026\n        srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n        !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n        !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n    \n    if (attributes.contains(FileAttribute.TIMES)) {\n      targetFS.setTimes(path, \n          srcFileStatus.getModificationTime(), \n          srcFileStatus.getAccessTime());\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
      "extendedDetails": {}
    },
    "c918286b17e7f2a64735d0c972a8dd749e0bf6c4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13145 In DistCp, prevent unnecessary getFileStatus call when not preserving metadata. Contributed by Chris Nauroth.\n",
      "commitDate": "20/05/16 4:21 AM",
      "commitName": "c918286b17e7f2a64735d0c972a8dd749e0bf6c4",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "11/01/16 9:46 AM",
      "commitNameOld": "95f32015ad9273420299130a9f10acdbafe63556",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 129.73,
      "commitsBetweenForRepo": 868,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,73 @@\n   public static void preserve(FileSystem targetFS, Path path,\n                               CopyListingFileStatus srcFileStatus,\n                               EnumSet\u003cFileAttribute\u003e attributes,\n                               boolean preserveRawXattrs) throws IOException {\n \n-    FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n-    String group \u003d targetFileStatus.getGroup();\n-    String user \u003d targetFileStatus.getOwner();\n+    // If not preserving anything from FileStatus, don\u0027t bother fetching it.\n+    FileStatus targetFileStatus \u003d attributes.isEmpty() ? null :\n+        targetFS.getFileStatus(path);\n+    String group \u003d targetFileStatus \u003d\u003d null ? null :\n+        targetFileStatus.getGroup();\n+    String user \u003d targetFileStatus \u003d\u003d null ? null :\n+        targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n     if (attributes.contains(FileAttribute.ACL)) {\n       List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n       List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n       if (!srcAcl.equals(targetAcl)) {\n         targetFS.setAcl(path, srcAcl);\n       }\n       // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n       if (srcFileStatus.getPermission().getStickyBit() !\u003d\n           targetFileStatus.getPermission().getStickyBit()) {\n         targetFS.setPermission(path, srcFileStatus.getPermission());\n       }\n     } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n \n     final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n     if (preserveXAttrs || preserveRawXattrs) {\n       final String rawNS \u003d\n           StringUtils.toLowerCase(XAttr.NameSpace.RAW.name());\n       Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n       Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n       if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n         for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n           String xattrName \u003d entry.getKey();\n           if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n             targetFS.setXAttr(path, xattrName, entry.getValue());\n           }\n         }\n       }\n     }\n \n     if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 !targetFileStatus.isDirectory() \u0026\u0026\n         (srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication())) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n         !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n         !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n     \n     if (attributes.contains(FileAttribute.TIMES)) {\n       targetFS.setTimes(path, \n           srcFileStatus.getModificationTime(), \n           srcFileStatus.getAccessTime());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes,\n                              boolean preserveRawXattrs) throws IOException {\n\n    // If not preserving anything from FileStatus, don\u0027t bother fetching it.\n    FileStatus targetFileStatus \u003d attributes.isEmpty() ? null :\n        targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus \u003d\u003d null ? null :\n        targetFileStatus.getGroup();\n    String user \u003d targetFileStatus \u003d\u003d null ? null :\n        targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n    if (preserveXAttrs || preserveRawXattrs) {\n      final String rawNS \u003d\n          StringUtils.toLowerCase(XAttr.NameSpace.RAW.name());\n      Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n      Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n      if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n        for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n          String xattrName \u003d entry.getKey();\n          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n            targetFS.setXAttr(path, xattrName, entry.getValue());\n          }\n        }\n      }\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 !targetFileStatus.isDirectory() \u0026\u0026\n        (srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication())) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n        !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n        !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n    \n    if (attributes.contains(FileAttribute.TIMES)) {\n      targetFS.setTimes(path, \n          srcFileStatus.getModificationTime(), \n          srcFileStatus.getAccessTime());\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
      "extendedDetails": {}
    },
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "02/03/15 9:17 PM",
      "commitName": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "24/02/15 7:32 AM",
      "commitNameOld": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,69 @@\n   public static void preserve(FileSystem targetFS, Path path,\n                               CopyListingFileStatus srcFileStatus,\n                               EnumSet\u003cFileAttribute\u003e attributes,\n                               boolean preserveRawXattrs) throws IOException {\n \n     FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n     String group \u003d targetFileStatus.getGroup();\n     String user \u003d targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n     if (attributes.contains(FileAttribute.ACL)) {\n       List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n       List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n       if (!srcAcl.equals(targetAcl)) {\n         targetFS.setAcl(path, srcAcl);\n       }\n       // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n       if (srcFileStatus.getPermission().getStickyBit() !\u003d\n           targetFileStatus.getPermission().getStickyBit()) {\n         targetFS.setPermission(path, srcFileStatus.getPermission());\n       }\n     } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n \n     final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n     if (preserveXAttrs || preserveRawXattrs) {\n-      final String rawNS \u003d XAttr.NameSpace.RAW.name().toLowerCase();\n+      final String rawNS \u003d\n+          StringUtils.toLowerCase(XAttr.NameSpace.RAW.name());\n       Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n       Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n       if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n         for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n           String xattrName \u003d entry.getKey();\n           if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n             targetFS.setXAttr(path, xattrName, entry.getValue());\n           }\n         }\n       }\n     }\n \n     if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 !targetFileStatus.isDirectory() \u0026\u0026\n         (srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication())) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n         !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n         !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n     \n     if (attributes.contains(FileAttribute.TIMES)) {\n       targetFS.setTimes(path, \n           srcFileStatus.getModificationTime(), \n           srcFileStatus.getAccessTime());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes,\n                              boolean preserveRawXattrs) throws IOException {\n\n    FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus.getGroup();\n    String user \u003d targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n    if (preserveXAttrs || preserveRawXattrs) {\n      final String rawNS \u003d\n          StringUtils.toLowerCase(XAttr.NameSpace.RAW.name());\n      Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n      Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n      if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n        for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n          String xattrName \u003d entry.getKey();\n          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n            targetFS.setXAttr(path, xattrName, entry.getValue());\n          }\n        }\n      }\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 !targetFileStatus.isDirectory() \u0026\u0026\n        (srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication())) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n        !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n        !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n    \n    if (attributes.contains(FileAttribute.TIMES)) {\n      targetFS.setTimes(path, \n          srcFileStatus.getModificationTime(), \n          srcFileStatus.getAccessTime());\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
      "extendedDetails": {}
    },
    "9cedad11d8d2197a54732667a15344983de5c437": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\"\n\nThis reverts commit 946456c6d88780abe0251b098dd771e9e1e93ab3.\n\nConflicts:\n\thadoop-common-project/hadoop-common/CHANGES.txt\n\thadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/QuotaByStorageTypeEntry.java\n",
      "commitDate": "24/02/15 7:32 AM",
      "commitName": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "18/02/15 8:06 PM",
      "commitNameOld": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 5.48,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,68 @@\n   public static void preserve(FileSystem targetFS, Path path,\n                               CopyListingFileStatus srcFileStatus,\n                               EnumSet\u003cFileAttribute\u003e attributes,\n                               boolean preserveRawXattrs) throws IOException {\n \n     FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n     String group \u003d targetFileStatus.getGroup();\n     String user \u003d targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n     if (attributes.contains(FileAttribute.ACL)) {\n       List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n       List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n       if (!srcAcl.equals(targetAcl)) {\n         targetFS.setAcl(path, srcAcl);\n       }\n       // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n       if (srcFileStatus.getPermission().getStickyBit() !\u003d\n           targetFileStatus.getPermission().getStickyBit()) {\n         targetFS.setPermission(path, srcFileStatus.getPermission());\n       }\n     } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n \n     final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n     if (preserveXAttrs || preserveRawXattrs) {\n-      final String rawNS \u003d\n-          XAttr.NameSpace.RAW.name().toLowerCase(Locale.ENGLISH);\n+      final String rawNS \u003d XAttr.NameSpace.RAW.name().toLowerCase();\n       Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n       Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n       if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n         for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n           String xattrName \u003d entry.getKey();\n           if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n             targetFS.setXAttr(path, xattrName, entry.getValue());\n           }\n         }\n       }\n     }\n \n     if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 !targetFileStatus.isDirectory() \u0026\u0026\n         (srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication())) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n         !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n         !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n     \n     if (attributes.contains(FileAttribute.TIMES)) {\n       targetFS.setTimes(path, \n           srcFileStatus.getModificationTime(), \n           srcFileStatus.getAccessTime());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes,\n                              boolean preserveRawXattrs) throws IOException {\n\n    FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus.getGroup();\n    String user \u003d targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n    if (preserveXAttrs || preserveRawXattrs) {\n      final String rawNS \u003d XAttr.NameSpace.RAW.name().toLowerCase();\n      Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n      Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n      if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n        for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n          String xattrName \u003d entry.getKey();\n          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n            targetFS.setXAttr(path, xattrName, entry.getValue());\n          }\n        }\n      }\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 !targetFileStatus.isDirectory() \u0026\u0026\n        (srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication())) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n        !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n        !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n    \n    if (attributes.contains(FileAttribute.TIMES)) {\n      targetFS.setTimes(path, \n          srcFileStatus.getModificationTime(), \n          srcFileStatus.getAccessTime());\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
      "extendedDetails": {}
    },
    "946456c6d88780abe0251b098dd771e9e1e93ab3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "18/02/15 8:06 PM",
      "commitName": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "24/09/14 3:38 PM",
      "commitNameOld": "3cde37c991b18370cc1b383f920a9d5bd2d91adb",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 147.23,
      "commitsBetweenForRepo": 1208,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,69 @@\n   public static void preserve(FileSystem targetFS, Path path,\n                               CopyListingFileStatus srcFileStatus,\n                               EnumSet\u003cFileAttribute\u003e attributes,\n                               boolean preserveRawXattrs) throws IOException {\n \n     FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n     String group \u003d targetFileStatus.getGroup();\n     String user \u003d targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n     if (attributes.contains(FileAttribute.ACL)) {\n       List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n       List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n       if (!srcAcl.equals(targetAcl)) {\n         targetFS.setAcl(path, srcAcl);\n       }\n       // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n       if (srcFileStatus.getPermission().getStickyBit() !\u003d\n           targetFileStatus.getPermission().getStickyBit()) {\n         targetFS.setPermission(path, srcFileStatus.getPermission());\n       }\n     } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n \n     final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n     if (preserveXAttrs || preserveRawXattrs) {\n-      final String rawNS \u003d XAttr.NameSpace.RAW.name().toLowerCase();\n+      final String rawNS \u003d\n+          XAttr.NameSpace.RAW.name().toLowerCase(Locale.ENGLISH);\n       Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n       Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n       if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n         for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n           String xattrName \u003d entry.getKey();\n           if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n             targetFS.setXAttr(path, xattrName, entry.getValue());\n           }\n         }\n       }\n     }\n \n     if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 !targetFileStatus.isDirectory() \u0026\u0026\n         (srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication())) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n         !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n         !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n     \n     if (attributes.contains(FileAttribute.TIMES)) {\n       targetFS.setTimes(path, \n           srcFileStatus.getModificationTime(), \n           srcFileStatus.getAccessTime());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes,\n                              boolean preserveRawXattrs) throws IOException {\n\n    FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus.getGroup();\n    String user \u003d targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n    if (preserveXAttrs || preserveRawXattrs) {\n      final String rawNS \u003d\n          XAttr.NameSpace.RAW.name().toLowerCase(Locale.ENGLISH);\n      Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n      Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n      if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n        for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n          String xattrName \u003d entry.getKey();\n          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n            targetFS.setXAttr(path, xattrName, entry.getValue());\n          }\n        }\n      }\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 !targetFileStatus.isDirectory() \u0026\u0026\n        (srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication())) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n        !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n        !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n    \n    if (attributes.contains(FileAttribute.TIMES)) {\n      targetFS.setTimes(path, \n          srcFileStatus.getModificationTime(), \n          srcFileStatus.getAccessTime());\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
      "extendedDetails": {}
    },
    "3cde37c991b18370cc1b383f920a9d5bd2d91adb": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11009. Add Timestamp Preservation to DistCp (Gary Steelman via aw)\n",
      "commitDate": "24/09/14 3:38 PM",
      "commitName": "3cde37c991b18370cc1b383f920a9d5bd2d91adb",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "07/08/14 6:32 PM",
      "commitNameOld": "041b8326a1511b721958792a6b94ecfe27d7a1fb",
      "commitAuthorOld": "Charles Lamb",
      "daysBetweenCommits": 47.88,
      "commitsBetweenForRepo": 455,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,68 @@\n   public static void preserve(FileSystem targetFS, Path path,\n                               CopyListingFileStatus srcFileStatus,\n                               EnumSet\u003cFileAttribute\u003e attributes,\n                               boolean preserveRawXattrs) throws IOException {\n \n     FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n     String group \u003d targetFileStatus.getGroup();\n     String user \u003d targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n     if (attributes.contains(FileAttribute.ACL)) {\n       List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n       List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n       if (!srcAcl.equals(targetAcl)) {\n         targetFS.setAcl(path, srcAcl);\n       }\n-      // setAcl can\u0027t preserve sticky bit, so also call setPermission if needed.\n+      // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n       if (srcFileStatus.getPermission().getStickyBit() !\u003d\n           targetFileStatus.getPermission().getStickyBit()) {\n         targetFS.setPermission(path, srcFileStatus.getPermission());\n       }\n     } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n \n     final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n     if (preserveXAttrs || preserveRawXattrs) {\n       final String rawNS \u003d XAttr.NameSpace.RAW.name().toLowerCase();\n       Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n       Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n       if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n-        Iterator\u003cEntry\u003cString, byte[]\u003e\u003e iter \u003d srcXAttrs.entrySet().iterator();\n-        while (iter.hasNext()) {\n-          Entry\u003cString, byte[]\u003e entry \u003d iter.next();\n-          final String xattrName \u003d entry.getKey();\n+        for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n+          String xattrName \u003d entry.getKey();\n           if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n-            targetFS.setXAttr(path, entry.getKey(), entry.getValue());\n+            targetFS.setXAttr(path, xattrName, entry.getValue());\n           }\n         }\n       }\n     }\n \n-    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n-        srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n+    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 !targetFileStatus.isDirectory() \u0026\u0026\n+        (srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication())) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n-            !group.equals(srcFileStatus.getGroup())) {\n+        !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n-            !user.equals(srcFileStatus.getOwner())) {\n+        !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n+    \n+    if (attributes.contains(FileAttribute.TIMES)) {\n+      targetFS.setTimes(path, \n+          srcFileStatus.getModificationTime(), \n+          srcFileStatus.getAccessTime());\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes,\n                              boolean preserveRawXattrs) throws IOException {\n\n    FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus.getGroup();\n    String user \u003d targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl doesn\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n    if (preserveXAttrs || preserveRawXattrs) {\n      final String rawNS \u003d XAttr.NameSpace.RAW.name().toLowerCase();\n      Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n      Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n      if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n        for (Entry\u003cString, byte[]\u003e entry : srcXAttrs.entrySet()) {\n          String xattrName \u003d entry.getKey();\n          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n            targetFS.setXAttr(path, xattrName, entry.getValue());\n          }\n        }\n      }\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 !targetFileStatus.isDirectory() \u0026\u0026\n        (srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication())) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n        !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n        !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n    \n    if (attributes.contains(FileAttribute.TIMES)) {\n      targetFS.setTimes(path, \n          srcFileStatus.getModificationTime(), \n          srcFileStatus.getAccessTime());\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
      "extendedDetails": {}
    },
    "041b8326a1511b721958792a6b94ecfe27d7a1fb": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-6007. Add support to distcp to preserve raw.* namespace extended attributes. (clamb)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1616657 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/14 6:32 PM",
      "commitName": "041b8326a1511b721958792a6b94ecfe27d7a1fb",
      "commitAuthor": "Charles Lamb",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-6007. Add support to distcp to preserve raw.* namespace extended attributes. (clamb)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1616657 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/08/14 6:32 PM",
          "commitName": "041b8326a1511b721958792a6b94ecfe27d7a1fb",
          "commitAuthor": "Charles Lamb",
          "commitDateOld": "06/06/14 7:45 AM",
          "commitNameOld": "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 62.45,
          "commitsBetweenForRepo": 482,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,64 @@\n   public static void preserve(FileSystem targetFS, Path path,\n                               CopyListingFileStatus srcFileStatus,\n-                              EnumSet\u003cFileAttribute\u003e attributes) throws IOException {\n+                              EnumSet\u003cFileAttribute\u003e attributes,\n+                              boolean preserveRawXattrs) throws IOException {\n \n     FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n     String group \u003d targetFileStatus.getGroup();\n     String user \u003d targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n     if (attributes.contains(FileAttribute.ACL)) {\n       List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n       List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n       if (!srcAcl.equals(targetAcl)) {\n         targetFS.setAcl(path, srcAcl);\n       }\n       // setAcl can\u0027t preserve sticky bit, so also call setPermission if needed.\n       if (srcFileStatus.getPermission().getStickyBit() !\u003d\n           targetFileStatus.getPermission().getStickyBit()) {\n         targetFS.setPermission(path, srcFileStatus.getPermission());\n       }\n     } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n-    \n-    if (attributes.contains(FileAttribute.XATTR)) {\n+\n+    final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n+    if (preserveXAttrs || preserveRawXattrs) {\n+      final String rawNS \u003d XAttr.NameSpace.RAW.name().toLowerCase();\n       Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n       Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n-      if (!srcXAttrs.equals(targetXAttrs)) {\n+      if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n         Iterator\u003cEntry\u003cString, byte[]\u003e\u003e iter \u003d srcXAttrs.entrySet().iterator();\n         while (iter.hasNext()) {\n           Entry\u003cString, byte[]\u003e entry \u003d iter.next();\n-          targetFS.setXAttr(path, entry.getKey(), entry.getValue());\n+          final String xattrName \u003d entry.getKey();\n+          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n+            targetFS.setXAttr(path, entry.getKey(), entry.getValue());\n+          }\n         }\n       }\n     }\n \n     if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n         srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n             !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n             !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes,\n                              boolean preserveRawXattrs) throws IOException {\n\n    FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus.getGroup();\n    String user \u003d targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl can\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n    if (preserveXAttrs || preserveRawXattrs) {\n      final String rawNS \u003d XAttr.NameSpace.RAW.name().toLowerCase();\n      Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n      Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n      if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n        Iterator\u003cEntry\u003cString, byte[]\u003e\u003e iter \u003d srcXAttrs.entrySet().iterator();\n        while (iter.hasNext()) {\n          Entry\u003cString, byte[]\u003e entry \u003d iter.next();\n          final String xattrName \u003d entry.getKey();\n          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n            targetFS.setXAttr(path, entry.getKey(), entry.getValue());\n          }\n        }\n      }\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n        srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n            !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n            !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
          "extendedDetails": {
            "oldValue": "[targetFS-FileSystem, path-Path, srcFileStatus-CopyListingFileStatus, attributes-EnumSet\u003cFileAttribute\u003e]",
            "newValue": "[targetFS-FileSystem, path-Path, srcFileStatus-CopyListingFileStatus, attributes-EnumSet\u003cFileAttribute\u003e, preserveRawXattrs-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-6007. Add support to distcp to preserve raw.* namespace extended attributes. (clamb)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1616657 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/08/14 6:32 PM",
          "commitName": "041b8326a1511b721958792a6b94ecfe27d7a1fb",
          "commitAuthor": "Charles Lamb",
          "commitDateOld": "06/06/14 7:45 AM",
          "commitNameOld": "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 62.45,
          "commitsBetweenForRepo": 482,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,64 @@\n   public static void preserve(FileSystem targetFS, Path path,\n                               CopyListingFileStatus srcFileStatus,\n-                              EnumSet\u003cFileAttribute\u003e attributes) throws IOException {\n+                              EnumSet\u003cFileAttribute\u003e attributes,\n+                              boolean preserveRawXattrs) throws IOException {\n \n     FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n     String group \u003d targetFileStatus.getGroup();\n     String user \u003d targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n     if (attributes.contains(FileAttribute.ACL)) {\n       List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n       List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n       if (!srcAcl.equals(targetAcl)) {\n         targetFS.setAcl(path, srcAcl);\n       }\n       // setAcl can\u0027t preserve sticky bit, so also call setPermission if needed.\n       if (srcFileStatus.getPermission().getStickyBit() !\u003d\n           targetFileStatus.getPermission().getStickyBit()) {\n         targetFS.setPermission(path, srcFileStatus.getPermission());\n       }\n     } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n-    \n-    if (attributes.contains(FileAttribute.XATTR)) {\n+\n+    final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n+    if (preserveXAttrs || preserveRawXattrs) {\n+      final String rawNS \u003d XAttr.NameSpace.RAW.name().toLowerCase();\n       Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n       Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n-      if (!srcXAttrs.equals(targetXAttrs)) {\n+      if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n         Iterator\u003cEntry\u003cString, byte[]\u003e\u003e iter \u003d srcXAttrs.entrySet().iterator();\n         while (iter.hasNext()) {\n           Entry\u003cString, byte[]\u003e entry \u003d iter.next();\n-          targetFS.setXAttr(path, entry.getKey(), entry.getValue());\n+          final String xattrName \u003d entry.getKey();\n+          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n+            targetFS.setXAttr(path, entry.getKey(), entry.getValue());\n+          }\n         }\n       }\n     }\n \n     if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n         srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n             !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n             !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes,\n                              boolean preserveRawXattrs) throws IOException {\n\n    FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus.getGroup();\n    String user \u003d targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl can\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    final boolean preserveXAttrs \u003d attributes.contains(FileAttribute.XATTR);\n    if (preserveXAttrs || preserveRawXattrs) {\n      final String rawNS \u003d XAttr.NameSpace.RAW.name().toLowerCase();\n      Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n      Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n      if (srcXAttrs !\u003d null \u0026\u0026 !srcXAttrs.equals(targetXAttrs)) {\n        Iterator\u003cEntry\u003cString, byte[]\u003e\u003e iter \u003d srcXAttrs.entrySet().iterator();\n        while (iter.hasNext()) {\n          Entry\u003cString, byte[]\u003e entry \u003d iter.next();\n          final String xattrName \u003d entry.getKey();\n          if (xattrName.startsWith(rawNS) || preserveXAttrs) {\n            targetFS.setXAttr(path, entry.getKey(), entry.getValue());\n          }\n        }\n      }\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n        srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n            !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n            !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
          "extendedDetails": {}
        }
      ]
    },
    "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5898. distcp to support preserving HDFS extended attributes(XAttrs). Contributed by Yi Liu.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1600900 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/14 7:45 AM",
      "commitName": "f81c7b0252839ae0dcd92fe2dc626ff9f87cd2c9",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "16/05/14 11:25 AM",
      "commitNameOld": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 20.85,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,58 @@\n   public static void preserve(FileSystem targetFS, Path path,\n                               CopyListingFileStatus srcFileStatus,\n                               EnumSet\u003cFileAttribute\u003e attributes) throws IOException {\n \n     FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n     String group \u003d targetFileStatus.getGroup();\n     String user \u003d targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n     if (attributes.contains(FileAttribute.ACL)) {\n       List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n       List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n       if (!srcAcl.equals(targetAcl)) {\n         targetFS.setAcl(path, srcAcl);\n       }\n       // setAcl can\u0027t preserve sticky bit, so also call setPermission if needed.\n       if (srcFileStatus.getPermission().getStickyBit() !\u003d\n           targetFileStatus.getPermission().getStickyBit()) {\n         targetFS.setPermission(path, srcFileStatus.getPermission());\n       }\n     } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n+    \n+    if (attributes.contains(FileAttribute.XATTR)) {\n+      Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n+      Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n+      if (!srcXAttrs.equals(targetXAttrs)) {\n+        Iterator\u003cEntry\u003cString, byte[]\u003e\u003e iter \u003d srcXAttrs.entrySet().iterator();\n+        while (iter.hasNext()) {\n+          Entry\u003cString, byte[]\u003e entry \u003d iter.next();\n+          targetFS.setXAttr(path, entry.getKey(), entry.getValue());\n+        }\n+      }\n+    }\n \n     if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n         srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n             !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n             !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes) throws IOException {\n\n    FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus.getGroup();\n    String user \u003d targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl can\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n    \n    if (attributes.contains(FileAttribute.XATTR)) {\n      Map\u003cString, byte[]\u003e srcXAttrs \u003d srcFileStatus.getXAttrs();\n      Map\u003cString, byte[]\u003e targetXAttrs \u003d getXAttrs(targetFS, path);\n      if (!srcXAttrs.equals(targetXAttrs)) {\n        Iterator\u003cEntry\u003cString, byte[]\u003e\u003e iter \u003d srcXAttrs.entrySet().iterator();\n        while (iter.hasNext()) {\n          Entry\u003cString, byte[]\u003e entry \u003d iter.next();\n          targetFS.setXAttr(path, entry.getKey(), entry.getValue());\n        }\n      }\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n        srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n            !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n            !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
      "extendedDetails": {}
    },
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-5809. Enhance distcp to support preserving HDFS ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/05/14 11:25 AM",
      "commitName": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
      "commitAuthor": "Chris Nauroth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-5809. Enhance distcp to support preserving HDFS ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595283 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/05/14 11:25 AM",
          "commitName": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "30/01/14 3:53 PM",
          "commitNameOld": "067d52b98c1d17a73b142bb53acc8aaa9c041f38",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 105.77,
          "commitsBetweenForRepo": 805,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,46 @@\n   public static void preserve(FileSystem targetFS, Path path,\n-                              FileStatus srcFileStatus,\n+                              CopyListingFileStatus srcFileStatus,\n                               EnumSet\u003cFileAttribute\u003e attributes) throws IOException {\n \n     FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n     String group \u003d targetFileStatus.getGroup();\n     String user \u003d targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n-    if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n+    if (attributes.contains(FileAttribute.ACL)) {\n+      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n+      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n+      if (!srcAcl.equals(targetAcl)) {\n+        targetFS.setAcl(path, srcAcl);\n+      }\n+      // setAcl can\u0027t preserve sticky bit, so also call setPermission if needed.\n+      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n+          targetFileStatus.getPermission().getStickyBit()) {\n+        targetFS.setPermission(path, srcFileStatus.getPermission());\n+      }\n+    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n \n     if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n         srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n             !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n             !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes) throws IOException {\n\n    FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus.getGroup();\n    String user \u003d targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl can\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n        srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n            !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n            !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
          "extendedDetails": {
            "oldValue": "[targetFS-FileSystem, path-Path, srcFileStatus-FileStatus, attributes-EnumSet\u003cFileAttribute\u003e]",
            "newValue": "[targetFS-FileSystem, path-Path, srcFileStatus-CopyListingFileStatus, attributes-EnumSet\u003cFileAttribute\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-5809. Enhance distcp to support preserving HDFS ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595283 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/05/14 11:25 AM",
          "commitName": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "30/01/14 3:53 PM",
          "commitNameOld": "067d52b98c1d17a73b142bb53acc8aaa9c041f38",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 105.77,
          "commitsBetweenForRepo": 805,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,46 @@\n   public static void preserve(FileSystem targetFS, Path path,\n-                              FileStatus srcFileStatus,\n+                              CopyListingFileStatus srcFileStatus,\n                               EnumSet\u003cFileAttribute\u003e attributes) throws IOException {\n \n     FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n     String group \u003d targetFileStatus.getGroup();\n     String user \u003d targetFileStatus.getOwner();\n     boolean chown \u003d false;\n \n-    if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n+    if (attributes.contains(FileAttribute.ACL)) {\n+      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n+      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n+      if (!srcAcl.equals(targetAcl)) {\n+        targetFS.setAcl(path, srcAcl);\n+      }\n+      // setAcl can\u0027t preserve sticky bit, so also call setPermission if needed.\n+      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n+          targetFileStatus.getPermission().getStickyBit()) {\n+        targetFS.setPermission(path, srcFileStatus.getPermission());\n+      }\n+    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n       !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n       targetFS.setPermission(path, srcFileStatus.getPermission());\n     }\n \n     if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n         srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n       targetFS.setReplication(path, srcFileStatus.getReplication());\n     }\n \n     if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n             !group.equals(srcFileStatus.getGroup())) {\n       group \u003d srcFileStatus.getGroup();\n       chown \u003d true;\n     }\n \n     if (attributes.contains(FileAttribute.USER) \u0026\u0026\n             !user.equals(srcFileStatus.getOwner())) {\n       user \u003d srcFileStatus.getOwner();\n       chown \u003d true;\n     }\n \n     if (chown) {\n       targetFS.setOwner(path, user, group);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              CopyListingFileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes) throws IOException {\n\n    FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus.getGroup();\n    String user \u003d targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.ACL)) {\n      List\u003cAclEntry\u003e srcAcl \u003d srcFileStatus.getAclEntries();\n      List\u003cAclEntry\u003e targetAcl \u003d getAcl(targetFS, targetFileStatus);\n      if (!srcAcl.equals(targetAcl)) {\n        targetFS.setAcl(path, srcAcl);\n      }\n      // setAcl can\u0027t preserve sticky bit, so also call setPermission if needed.\n      if (srcFileStatus.getPermission().getStickyBit() !\u003d\n          targetFileStatus.getPermission().getStickyBit()) {\n        targetFS.setPermission(path, srcFileStatus.getPermission());\n      }\n    } else if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n        srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n            !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n            !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n  }",
          "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java",
          "extendedDetails": {}
        }
      ]
    },
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2765. DistCp Rewrite. (Mithun Radhakrishnan via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1236045 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/12 10:36 PM",
      "commitName": "d06948002fb0cabf72cc0d46bf2fa67d45370f67",
      "commitAuthor": "Mahadev Konar",
      "diff": "@@ -0,0 +1,35 @@\n+  public static void preserve(FileSystem targetFS, Path path,\n+                              FileStatus srcFileStatus,\n+                              EnumSet\u003cFileAttribute\u003e attributes) throws IOException {\n+\n+    FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n+    String group \u003d targetFileStatus.getGroup();\n+    String user \u003d targetFileStatus.getOwner();\n+    boolean chown \u003d false;\n+\n+    if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n+      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n+      targetFS.setPermission(path, srcFileStatus.getPermission());\n+    }\n+\n+    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n+        srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n+      targetFS.setReplication(path, srcFileStatus.getReplication());\n+    }\n+\n+    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n+            !group.equals(srcFileStatus.getGroup())) {\n+      group \u003d srcFileStatus.getGroup();\n+      chown \u003d true;\n+    }\n+\n+    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n+            !user.equals(srcFileStatus.getOwner())) {\n+      user \u003d srcFileStatus.getOwner();\n+      chown \u003d true;\n+    }\n+\n+    if (chown) {\n+      targetFS.setOwner(path, user, group);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static void preserve(FileSystem targetFS, Path path,\n                              FileStatus srcFileStatus,\n                              EnumSet\u003cFileAttribute\u003e attributes) throws IOException {\n\n    FileStatus targetFileStatus \u003d targetFS.getFileStatus(path);\n    String group \u003d targetFileStatus.getGroup();\n    String user \u003d targetFileStatus.getOwner();\n    boolean chown \u003d false;\n\n    if (attributes.contains(FileAttribute.PERMISSION) \u0026\u0026\n      !srcFileStatus.getPermission().equals(targetFileStatus.getPermission())) {\n      targetFS.setPermission(path, srcFileStatus.getPermission());\n    }\n\n    if (attributes.contains(FileAttribute.REPLICATION) \u0026\u0026 ! targetFileStatus.isDirectory() \u0026\u0026\n        srcFileStatus.getReplication() !\u003d targetFileStatus.getReplication()) {\n      targetFS.setReplication(path, srcFileStatus.getReplication());\n    }\n\n    if (attributes.contains(FileAttribute.GROUP) \u0026\u0026\n            !group.equals(srcFileStatus.getGroup())) {\n      group \u003d srcFileStatus.getGroup();\n      chown \u003d true;\n    }\n\n    if (attributes.contains(FileAttribute.USER) \u0026\u0026\n            !user.equals(srcFileStatus.getOwner())) {\n      user \u003d srcFileStatus.getOwner();\n      chown \u003d true;\n    }\n\n    if (chown) {\n      targetFS.setOwner(path, user, group);\n    }\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/util/DistCpUtils.java"
    }
  }
}