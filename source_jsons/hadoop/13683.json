{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockPlacementPolicyDefault.java",
  "functionName": "chooseLocalOrFavoredStorage",
  "functionId": "chooseLocalOrFavoredStorage___localOrFavoredNode-Node__isFavoredNode-boolean__excludedNodes-Set__Node____blocksize-long__maxNodesPerRack-int__results-List__DatanodeStorageInfo____avoidStaleNodes-boolean__storageTypes-EnumMap__StorageType,Integer__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
  "functionStartLine": 589,
  "functionEndLine": 628,
  "numCommitsSeen": 99,
  "timeTaken": 1218,
  "changeHistory": [
    "7d7acb004af5095983e99c86deedfc60a0355ff7"
  ],
  "changeHistoryShort": {
    "7d7acb004af5095983e99c86deedfc60a0355ff7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7d7acb004af5095983e99c86deedfc60a0355ff7": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-13736. BlockPlacementPolicyDefault can not choose favored nodes when \u0027dfs.namenode.block-placement-policy.default.prefer-local-node\u0027 set to false. Contributed by hu xiaodong.\n",
      "commitDate": "01/11/19 10:20 AM",
      "commitName": "7d7acb004af5095983e99c86deedfc60a0355ff7",
      "commitAuthor": "Ayush Saxena",
      "diff": "@@ -0,0 +1,40 @@\n+  protected DatanodeStorageInfo chooseLocalOrFavoredStorage(\n+      Node localOrFavoredNode, boolean isFavoredNode, Set\u003cNode\u003e excludedNodes,\n+      long blocksize, int maxNodesPerRack, List\u003cDatanodeStorageInfo\u003e results,\n+      boolean avoidStaleNodes, EnumMap\u003cStorageType, Integer\u003e storageTypes)\n+      throws NotEnoughReplicasException {\n+    // if no local machine, randomly choose one node\n+    if (localOrFavoredNode \u003d\u003d null) {\n+      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n+          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n+    }\n+    if ((preferLocalNode || isFavoredNode)\n+        \u0026\u0026 localOrFavoredNode instanceof DatanodeDescriptor\n+        \u0026\u0026 clusterMap.contains(localOrFavoredNode)) {\n+      DatanodeDescriptor localDatanode \u003d\n+          (DatanodeDescriptor) localOrFavoredNode;\n+      // otherwise try local machine first\n+      if (excludedNodes.add(localOrFavoredNode) // was not in the excluded list\n+          \u0026\u0026 isGoodDatanode(localDatanode, maxNodesPerRack, false,\n+              results, avoidStaleNodes)) {\n+        for (Iterator\u003cMap.Entry\u003cStorageType, Integer\u003e\u003e iter \u003d storageTypes\n+            .entrySet().iterator(); iter.hasNext(); ) {\n+          Map.Entry\u003cStorageType, Integer\u003e entry \u003d iter.next();\n+          DatanodeStorageInfo localStorage \u003d chooseStorage4Block(\n+              localDatanode, blocksize, results, entry.getKey());\n+          if (localStorage !\u003d null) {\n+            // add node and related nodes to excludedNode\n+            addToExcludedNodes(localDatanode, excludedNodes);\n+            int num \u003d entry.getValue();\n+            if (num \u003d\u003d 1) {\n+              iter.remove();\n+            } else {\n+              entry.setValue(num - 1);\n+            }\n+            return localStorage;\n+          }\n+        }\n+      }\n+    }\n+    return null;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected DatanodeStorageInfo chooseLocalOrFavoredStorage(\n      Node localOrFavoredNode, boolean isFavoredNode, Set\u003cNode\u003e excludedNodes,\n      long blocksize, int maxNodesPerRack, List\u003cDatanodeStorageInfo\u003e results,\n      boolean avoidStaleNodes, EnumMap\u003cStorageType, Integer\u003e storageTypes)\n      throws NotEnoughReplicasException {\n    // if no local machine, randomly choose one node\n    if (localOrFavoredNode \u003d\u003d null) {\n      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    }\n    if ((preferLocalNode || isFavoredNode)\n        \u0026\u0026 localOrFavoredNode instanceof DatanodeDescriptor\n        \u0026\u0026 clusterMap.contains(localOrFavoredNode)) {\n      DatanodeDescriptor localDatanode \u003d\n          (DatanodeDescriptor) localOrFavoredNode;\n      // otherwise try local machine first\n      if (excludedNodes.add(localOrFavoredNode) // was not in the excluded list\n          \u0026\u0026 isGoodDatanode(localDatanode, maxNodesPerRack, false,\n              results, avoidStaleNodes)) {\n        for (Iterator\u003cMap.Entry\u003cStorageType, Integer\u003e\u003e iter \u003d storageTypes\n            .entrySet().iterator(); iter.hasNext(); ) {\n          Map.Entry\u003cStorageType, Integer\u003e entry \u003d iter.next();\n          DatanodeStorageInfo localStorage \u003d chooseStorage4Block(\n              localDatanode, blocksize, results, entry.getKey());\n          if (localStorage !\u003d null) {\n            // add node and related nodes to excludedNode\n            addToExcludedNodes(localDatanode, excludedNodes);\n            int num \u003d entry.getValue();\n            if (num \u003d\u003d 1) {\n              iter.remove();\n            } else {\n              entry.setValue(num - 1);\n            }\n            return localStorage;\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java"
    }
  }
}