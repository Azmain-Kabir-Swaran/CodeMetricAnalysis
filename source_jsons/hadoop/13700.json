{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockPlacementPolicyDefault.java",
  "functionName": "chooseReplicaToDelete",
  "functionId": "chooseReplicaToDelete___moreThanOne-Collection__DatanodeStorageInfo____exactlyOne-Collection__DatanodeStorageInfo____excessTypes-List__StorageType__(modifiers-final)__rackMap-Map__String,List__DatanodeStorageInfo____",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
  "functionStartLine": 1119,
  "functionEndLine": 1161,
  "numCommitsSeen": 292,
  "timeTaken": 4953,
  "changeHistory": [
    "d2b3ba9b8fb76753fa1b51661dacbde74aa5c6df",
    "0e54b164a8d8acf09aca8712116bf7a554cb4846",
    "ec414600ede8e305c584818565b50e055ea5d2b5",
    "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498",
    "b7ded466b00db0fe273058b844d56d810e0f8cc2"
  ],
  "changeHistoryShort": {
    "d2b3ba9b8fb76753fa1b51661dacbde74aa5c6df": "Ybodychange",
    "0e54b164a8d8acf09aca8712116bf7a554cb4846": "Ymultichange(Yparameterchange,Ybodychange)",
    "ec414600ede8e305c584818565b50e055ea5d2b5": "Ymultichange(Yparameterchange,Ybodychange)",
    "e27c2ae8bafc94f18eb38f5d839dcef5652d424e": "Ymultichange(Yparameterchange,Ybodychange)",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": "Ybodychange",
    "b7ded466b00db0fe273058b844d56d810e0f8cc2": "Ybodychange"
  },
  "changeHistoryDetails": {
    "d2b3ba9b8fb76753fa1b51661dacbde74aa5c6df": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11295. Check storage remaining instead of node remaining in BlockPlacementPolicyDefault.chooseReplicaToDelete(). Contributed by Marton Elek.\n",
      "commitDate": "24/02/17 3:44 PM",
      "commitName": "d2b3ba9b8fb76753fa1b51661dacbde74aa5c6df",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "23/11/16 4:42 PM",
      "commitNameOld": "de4894936a5b581572f35fa5b8979d9f23da0891",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 92.96,
      "commitsBetweenForRepo": 471,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   public DatanodeStorageInfo chooseReplicaToDelete(\n       Collection\u003cDatanodeStorageInfo\u003e moreThanOne,\n       Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n       final List\u003cStorageType\u003e excessTypes,\n       Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap) {\n     long oldestHeartbeat \u003d\n       monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n     DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n     long minSpace \u003d Long.MAX_VALUE;\n     DatanodeStorageInfo minSpaceStorage \u003d null;\n \n     // Pick the node with the oldest heartbeat or with the least free space,\n     // if all hearbeats are within the tolerable heartbeat interval\n     for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanOne,\n         exactlyOne, rackMap)) {\n       if (!excessTypes.contains(storage.getStorageType())) {\n         continue;\n       }\n \n       final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n-      long free \u003d node.getRemaining();\n+      long free \u003d storage.getRemaining();\n       long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n       if (lastHeartbeat \u003c oldestHeartbeat) {\n         oldestHeartbeat \u003d lastHeartbeat;\n         oldestHeartbeatStorage \u003d storage;\n       }\n       if (minSpace \u003e free) {\n         minSpace \u003d free;\n         minSpaceStorage \u003d storage;\n       }\n     }\n \n     final DatanodeStorageInfo storage;\n     if (oldestHeartbeatStorage !\u003d null) {\n       storage \u003d oldestHeartbeatStorage;\n     } else if (minSpaceStorage !\u003d null) {\n       storage \u003d minSpaceStorage;\n     } else {\n       return null;\n     }\n     excessTypes.remove(storage.getStorageType());\n     return storage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeStorageInfo chooseReplicaToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e moreThanOne,\n      Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n      final List\u003cStorageType\u003e excessTypes,\n      Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap) {\n    long oldestHeartbeat \u003d\n      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n    long minSpace \u003d Long.MAX_VALUE;\n    DatanodeStorageInfo minSpaceStorage \u003d null;\n\n    // Pick the node with the oldest heartbeat or with the least free space,\n    // if all hearbeats are within the tolerable heartbeat interval\n    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanOne,\n        exactlyOne, rackMap)) {\n      if (!excessTypes.contains(storage.getStorageType())) {\n        continue;\n      }\n\n      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n      long free \u003d storage.getRemaining();\n      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n      if (lastHeartbeat \u003c oldestHeartbeat) {\n        oldestHeartbeat \u003d lastHeartbeat;\n        oldestHeartbeatStorage \u003d storage;\n      }\n      if (minSpace \u003e free) {\n        minSpace \u003d free;\n        minSpaceStorage \u003d storage;\n      }\n    }\n\n    final DatanodeStorageInfo storage;\n    if (oldestHeartbeatStorage !\u003d null) {\n      storage \u003d oldestHeartbeatStorage;\n    } else if (minSpaceStorage !\u003d null) {\n      storage \u003d minSpaceStorage;\n    } else {\n      return null;\n    }\n    excessTypes.remove(storage.getStorageType());\n    return storage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "0e54b164a8d8acf09aca8712116bf7a554cb4846": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9314. Improve BlockPlacementPolicyDefault\u0027s picking of excess replicas. (Xiao Chen via mingma)\n",
      "commitDate": "24/11/15 10:30 AM",
      "commitName": "0e54b164a8d8acf09aca8712116bf7a554cb4846",
      "commitAuthor": "Ming Ma",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9314. Improve BlockPlacementPolicyDefault\u0027s picking of excess replicas. (Xiao Chen via mingma)\n",
          "commitDate": "24/11/15 10:30 AM",
          "commitName": "0e54b164a8d8acf09aca8712116bf7a554cb4846",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "06/11/15 11:30 AM",
          "commitNameOld": "bf6aa30a156b3c5cac5469014a5989e0dfdc7256",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 17.96,
          "commitsBetweenForRepo": 113,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,43 @@\n   public DatanodeStorageInfo chooseReplicaToDelete(\n       Collection\u003cDatanodeStorageInfo\u003e moreThanOne,\n       Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n-      final List\u003cStorageType\u003e excessTypes) {\n+      final List\u003cStorageType\u003e excessTypes,\n+      Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap) {\n     long oldestHeartbeat \u003d\n       monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n     DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n     long minSpace \u003d Long.MAX_VALUE;\n     DatanodeStorageInfo minSpaceStorage \u003d null;\n \n     // Pick the node with the oldest heartbeat or with the least free space,\n     // if all hearbeats are within the tolerable heartbeat interval\n     for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanOne,\n-        exactlyOne)) {\n+        exactlyOne, rackMap)) {\n       if (!excessTypes.contains(storage.getStorageType())) {\n         continue;\n       }\n \n       final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n       long free \u003d node.getRemaining();\n       long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n       if (lastHeartbeat \u003c oldestHeartbeat) {\n         oldestHeartbeat \u003d lastHeartbeat;\n         oldestHeartbeatStorage \u003d storage;\n       }\n       if (minSpace \u003e free) {\n         minSpace \u003d free;\n         minSpaceStorage \u003d storage;\n       }\n     }\n \n     final DatanodeStorageInfo storage;\n     if (oldestHeartbeatStorage !\u003d null) {\n       storage \u003d oldestHeartbeatStorage;\n     } else if (minSpaceStorage !\u003d null) {\n       storage \u003d minSpaceStorage;\n     } else {\n       return null;\n     }\n     excessTypes.remove(storage.getStorageType());\n     return storage;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DatanodeStorageInfo chooseReplicaToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e moreThanOne,\n      Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n      final List\u003cStorageType\u003e excessTypes,\n      Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap) {\n    long oldestHeartbeat \u003d\n      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n    long minSpace \u003d Long.MAX_VALUE;\n    DatanodeStorageInfo minSpaceStorage \u003d null;\n\n    // Pick the node with the oldest heartbeat or with the least free space,\n    // if all hearbeats are within the tolerable heartbeat interval\n    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanOne,\n        exactlyOne, rackMap)) {\n      if (!excessTypes.contains(storage.getStorageType())) {\n        continue;\n      }\n\n      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n      long free \u003d node.getRemaining();\n      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n      if (lastHeartbeat \u003c oldestHeartbeat) {\n        oldestHeartbeat \u003d lastHeartbeat;\n        oldestHeartbeatStorage \u003d storage;\n      }\n      if (minSpace \u003e free) {\n        minSpace \u003d free;\n        minSpaceStorage \u003d storage;\n      }\n    }\n\n    final DatanodeStorageInfo storage;\n    if (oldestHeartbeatStorage !\u003d null) {\n      storage \u003d oldestHeartbeatStorage;\n    } else if (minSpaceStorage !\u003d null) {\n      storage \u003d minSpaceStorage;\n    } else {\n      return null;\n    }\n    excessTypes.remove(storage.getStorageType());\n    return storage;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "[moreThanOne-Collection\u003cDatanodeStorageInfo\u003e, exactlyOne-Collection\u003cDatanodeStorageInfo\u003e, excessTypes-List\u003cStorageType\u003e(modifiers-final)]",
            "newValue": "[moreThanOne-Collection\u003cDatanodeStorageInfo\u003e, exactlyOne-Collection\u003cDatanodeStorageInfo\u003e, excessTypes-List\u003cStorageType\u003e(modifiers-final), rackMap-Map\u003cString,List\u003cDatanodeStorageInfo\u003e\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9314. Improve BlockPlacementPolicyDefault\u0027s picking of excess replicas. (Xiao Chen via mingma)\n",
          "commitDate": "24/11/15 10:30 AM",
          "commitName": "0e54b164a8d8acf09aca8712116bf7a554cb4846",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "06/11/15 11:30 AM",
          "commitNameOld": "bf6aa30a156b3c5cac5469014a5989e0dfdc7256",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 17.96,
          "commitsBetweenForRepo": 113,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,43 @@\n   public DatanodeStorageInfo chooseReplicaToDelete(\n       Collection\u003cDatanodeStorageInfo\u003e moreThanOne,\n       Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n-      final List\u003cStorageType\u003e excessTypes) {\n+      final List\u003cStorageType\u003e excessTypes,\n+      Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap) {\n     long oldestHeartbeat \u003d\n       monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n     DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n     long minSpace \u003d Long.MAX_VALUE;\n     DatanodeStorageInfo minSpaceStorage \u003d null;\n \n     // Pick the node with the oldest heartbeat or with the least free space,\n     // if all hearbeats are within the tolerable heartbeat interval\n     for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanOne,\n-        exactlyOne)) {\n+        exactlyOne, rackMap)) {\n       if (!excessTypes.contains(storage.getStorageType())) {\n         continue;\n       }\n \n       final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n       long free \u003d node.getRemaining();\n       long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n       if (lastHeartbeat \u003c oldestHeartbeat) {\n         oldestHeartbeat \u003d lastHeartbeat;\n         oldestHeartbeatStorage \u003d storage;\n       }\n       if (minSpace \u003e free) {\n         minSpace \u003d free;\n         minSpaceStorage \u003d storage;\n       }\n     }\n \n     final DatanodeStorageInfo storage;\n     if (oldestHeartbeatStorage !\u003d null) {\n       storage \u003d oldestHeartbeatStorage;\n     } else if (minSpaceStorage !\u003d null) {\n       storage \u003d minSpaceStorage;\n     } else {\n       return null;\n     }\n     excessTypes.remove(storage.getStorageType());\n     return storage;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DatanodeStorageInfo chooseReplicaToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e moreThanOne,\n      Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n      final List\u003cStorageType\u003e excessTypes,\n      Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap) {\n    long oldestHeartbeat \u003d\n      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n    long minSpace \u003d Long.MAX_VALUE;\n    DatanodeStorageInfo minSpaceStorage \u003d null;\n\n    // Pick the node with the oldest heartbeat or with the least free space,\n    // if all hearbeats are within the tolerable heartbeat interval\n    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanOne,\n        exactlyOne, rackMap)) {\n      if (!excessTypes.contains(storage.getStorageType())) {\n        continue;\n      }\n\n      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n      long free \u003d node.getRemaining();\n      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n      if (lastHeartbeat \u003c oldestHeartbeat) {\n        oldestHeartbeat \u003d lastHeartbeat;\n        oldestHeartbeatStorage \u003d storage;\n      }\n      if (minSpace \u003e free) {\n        minSpace \u003d free;\n        minSpaceStorage \u003d storage;\n      }\n    }\n\n    final DatanodeStorageInfo storage;\n    if (oldestHeartbeatStorage !\u003d null) {\n      storage \u003d oldestHeartbeatStorage;\n    } else if (minSpaceStorage !\u003d null) {\n      storage \u003d minSpaceStorage;\n    } else {\n      return null;\n    }\n    excessTypes.remove(storage.getStorageType());\n    return storage;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {}
        }
      ]
    },
    "ec414600ede8e305c584818565b50e055ea5d2b5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9007. Fix HDFS Balancer to honor upgrade domain policy. (Ming Ma via lei)\n",
      "commitDate": "04/11/15 10:22 AM",
      "commitName": "ec414600ede8e305c584818565b50e055ea5d2b5",
      "commitAuthor": "Lei Xu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9007. Fix HDFS Balancer to honor upgrade domain policy. (Ming Ma via lei)\n",
          "commitDate": "04/11/15 10:22 AM",
          "commitName": "ec414600ede8e305c584818565b50e055ea5d2b5",
          "commitAuthor": "Lei Xu",
          "commitDateOld": "02/11/15 7:36 PM",
          "commitNameOld": "d565480da2f646b40c3180e1ccb2935c9863dfef",
          "commitAuthorOld": "Ming Ma",
          "daysBetweenCommits": 1.62,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,42 @@\n-  public DatanodeStorageInfo chooseReplicaToDelete(short replicationFactor,\n-      Collection\u003cDatanodeStorageInfo\u003e moreThanone, Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n+  public DatanodeStorageInfo chooseReplicaToDelete(\n+      Collection\u003cDatanodeStorageInfo\u003e moreThanOne,\n+      Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n       final List\u003cStorageType\u003e excessTypes) {\n     long oldestHeartbeat \u003d\n       monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n     DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n     long minSpace \u003d Long.MAX_VALUE;\n     DatanodeStorageInfo minSpaceStorage \u003d null;\n \n     // Pick the node with the oldest heartbeat or with the least free space,\n     // if all hearbeats are within the tolerable heartbeat interval\n-    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanone, exactlyOne)) {\n+    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanOne,\n+        exactlyOne)) {\n       if (!excessTypes.contains(storage.getStorageType())) {\n         continue;\n       }\n \n       final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n       long free \u003d node.getRemaining();\n       long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n       if (lastHeartbeat \u003c oldestHeartbeat) {\n         oldestHeartbeat \u003d lastHeartbeat;\n         oldestHeartbeatStorage \u003d storage;\n       }\n       if (minSpace \u003e free) {\n         minSpace \u003d free;\n         minSpaceStorage \u003d storage;\n       }\n     }\n \n     final DatanodeStorageInfo storage;\n     if (oldestHeartbeatStorage !\u003d null) {\n       storage \u003d oldestHeartbeatStorage;\n     } else if (minSpaceStorage !\u003d null) {\n       storage \u003d minSpaceStorage;\n     } else {\n       return null;\n     }\n     excessTypes.remove(storage.getStorageType());\n     return storage;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DatanodeStorageInfo chooseReplicaToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e moreThanOne,\n      Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n      final List\u003cStorageType\u003e excessTypes) {\n    long oldestHeartbeat \u003d\n      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n    long minSpace \u003d Long.MAX_VALUE;\n    DatanodeStorageInfo minSpaceStorage \u003d null;\n\n    // Pick the node with the oldest heartbeat or with the least free space,\n    // if all hearbeats are within the tolerable heartbeat interval\n    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanOne,\n        exactlyOne)) {\n      if (!excessTypes.contains(storage.getStorageType())) {\n        continue;\n      }\n\n      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n      long free \u003d node.getRemaining();\n      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n      if (lastHeartbeat \u003c oldestHeartbeat) {\n        oldestHeartbeat \u003d lastHeartbeat;\n        oldestHeartbeatStorage \u003d storage;\n      }\n      if (minSpace \u003e free) {\n        minSpace \u003d free;\n        minSpaceStorage \u003d storage;\n      }\n    }\n\n    final DatanodeStorageInfo storage;\n    if (oldestHeartbeatStorage !\u003d null) {\n      storage \u003d oldestHeartbeatStorage;\n    } else if (minSpaceStorage !\u003d null) {\n      storage \u003d minSpaceStorage;\n    } else {\n      return null;\n    }\n    excessTypes.remove(storage.getStorageType());\n    return storage;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "[replicationFactor-short, moreThanone-Collection\u003cDatanodeStorageInfo\u003e, exactlyOne-Collection\u003cDatanodeStorageInfo\u003e, excessTypes-List\u003cStorageType\u003e(modifiers-final)]",
            "newValue": "[moreThanOne-Collection\u003cDatanodeStorageInfo\u003e, exactlyOne-Collection\u003cDatanodeStorageInfo\u003e, excessTypes-List\u003cStorageType\u003e(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9007. Fix HDFS Balancer to honor upgrade domain policy. (Ming Ma via lei)\n",
          "commitDate": "04/11/15 10:22 AM",
          "commitName": "ec414600ede8e305c584818565b50e055ea5d2b5",
          "commitAuthor": "Lei Xu",
          "commitDateOld": "02/11/15 7:36 PM",
          "commitNameOld": "d565480da2f646b40c3180e1ccb2935c9863dfef",
          "commitAuthorOld": "Ming Ma",
          "daysBetweenCommits": 1.62,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,42 @@\n-  public DatanodeStorageInfo chooseReplicaToDelete(short replicationFactor,\n-      Collection\u003cDatanodeStorageInfo\u003e moreThanone, Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n+  public DatanodeStorageInfo chooseReplicaToDelete(\n+      Collection\u003cDatanodeStorageInfo\u003e moreThanOne,\n+      Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n       final List\u003cStorageType\u003e excessTypes) {\n     long oldestHeartbeat \u003d\n       monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n     DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n     long minSpace \u003d Long.MAX_VALUE;\n     DatanodeStorageInfo minSpaceStorage \u003d null;\n \n     // Pick the node with the oldest heartbeat or with the least free space,\n     // if all hearbeats are within the tolerable heartbeat interval\n-    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanone, exactlyOne)) {\n+    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanOne,\n+        exactlyOne)) {\n       if (!excessTypes.contains(storage.getStorageType())) {\n         continue;\n       }\n \n       final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n       long free \u003d node.getRemaining();\n       long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n       if (lastHeartbeat \u003c oldestHeartbeat) {\n         oldestHeartbeat \u003d lastHeartbeat;\n         oldestHeartbeatStorage \u003d storage;\n       }\n       if (minSpace \u003e free) {\n         minSpace \u003d free;\n         minSpaceStorage \u003d storage;\n       }\n     }\n \n     final DatanodeStorageInfo storage;\n     if (oldestHeartbeatStorage !\u003d null) {\n       storage \u003d oldestHeartbeatStorage;\n     } else if (minSpaceStorage !\u003d null) {\n       storage \u003d minSpaceStorage;\n     } else {\n       return null;\n     }\n     excessTypes.remove(storage.getStorageType());\n     return storage;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DatanodeStorageInfo chooseReplicaToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e moreThanOne,\n      Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n      final List\u003cStorageType\u003e excessTypes) {\n    long oldestHeartbeat \u003d\n      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n    long minSpace \u003d Long.MAX_VALUE;\n    DatanodeStorageInfo minSpaceStorage \u003d null;\n\n    // Pick the node with the oldest heartbeat or with the least free space,\n    // if all hearbeats are within the tolerable heartbeat interval\n    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanOne,\n        exactlyOne)) {\n      if (!excessTypes.contains(storage.getStorageType())) {\n        continue;\n      }\n\n      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n      long free \u003d node.getRemaining();\n      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n      if (lastHeartbeat \u003c oldestHeartbeat) {\n        oldestHeartbeat \u003d lastHeartbeat;\n        oldestHeartbeatStorage \u003d storage;\n      }\n      if (minSpace \u003e free) {\n        minSpace \u003d free;\n        minSpaceStorage \u003d storage;\n      }\n    }\n\n    final DatanodeStorageInfo storage;\n    if (oldestHeartbeatStorage !\u003d null) {\n      storage \u003d oldestHeartbeatStorage;\n    } else if (minSpaceStorage !\u003d null) {\n      storage \u003d minSpaceStorage;\n    } else {\n      return null;\n    }\n    excessTypes.remove(storage.getStorageType());\n    return storage;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {}
        }
      ]
    },
    "e27c2ae8bafc94f18eb38f5d839dcef5652d424e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-8647. Abstract BlockManager\u0027s rack policy into BlockPlacementPolicy. (Brahma Reddy Battula via mingma)\n",
      "commitDate": "21/10/15 8:06 AM",
      "commitName": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
      "commitAuthor": "Ming Ma",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8647. Abstract BlockManager\u0027s rack policy into BlockPlacementPolicy. (Brahma Reddy Battula via mingma)\n",
          "commitDate": "21/10/15 8:06 AM",
          "commitName": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "12/10/15 4:24 PM",
          "commitNameOld": "0f5f9846edab3ea7e80f35000072136f998bcd46",
          "commitAuthorOld": "Lei Xu",
          "daysBetweenCommits": 8.65,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,40 @@\n-  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n-      Block block, short replicationFactor,\n-      Collection\u003cDatanodeStorageInfo\u003e first,\n-      Collection\u003cDatanodeStorageInfo\u003e second,\n+  public DatanodeStorageInfo chooseReplicaToDelete(short replicationFactor,\n+      Collection\u003cDatanodeStorageInfo\u003e moreThanone, Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n       final List\u003cStorageType\u003e excessTypes) {\n     long oldestHeartbeat \u003d\n       monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n     DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n     long minSpace \u003d Long.MAX_VALUE;\n     DatanodeStorageInfo minSpaceStorage \u003d null;\n \n     // Pick the node with the oldest heartbeat or with the least free space,\n     // if all hearbeats are within the tolerable heartbeat interval\n-    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n+    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanone, exactlyOne)) {\n       if (!excessTypes.contains(storage.getStorageType())) {\n         continue;\n       }\n \n       final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n       long free \u003d node.getRemaining();\n       long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n       if (lastHeartbeat \u003c oldestHeartbeat) {\n         oldestHeartbeat \u003d lastHeartbeat;\n         oldestHeartbeatStorage \u003d storage;\n       }\n       if (minSpace \u003e free) {\n         minSpace \u003d free;\n         minSpaceStorage \u003d storage;\n       }\n     }\n \n     final DatanodeStorageInfo storage;\n     if (oldestHeartbeatStorage !\u003d null) {\n       storage \u003d oldestHeartbeatStorage;\n     } else if (minSpaceStorage !\u003d null) {\n       storage \u003d minSpaceStorage;\n     } else {\n       return null;\n     }\n     excessTypes.remove(storage.getStorageType());\n     return storage;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DatanodeStorageInfo chooseReplicaToDelete(short replicationFactor,\n      Collection\u003cDatanodeStorageInfo\u003e moreThanone, Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n      final List\u003cStorageType\u003e excessTypes) {\n    long oldestHeartbeat \u003d\n      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n    long minSpace \u003d Long.MAX_VALUE;\n    DatanodeStorageInfo minSpaceStorage \u003d null;\n\n    // Pick the node with the oldest heartbeat or with the least free space,\n    // if all hearbeats are within the tolerable heartbeat interval\n    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanone, exactlyOne)) {\n      if (!excessTypes.contains(storage.getStorageType())) {\n        continue;\n      }\n\n      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n      long free \u003d node.getRemaining();\n      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n      if (lastHeartbeat \u003c oldestHeartbeat) {\n        oldestHeartbeat \u003d lastHeartbeat;\n        oldestHeartbeatStorage \u003d storage;\n      }\n      if (minSpace \u003e free) {\n        minSpace \u003d free;\n        minSpaceStorage \u003d storage;\n      }\n    }\n\n    final DatanodeStorageInfo storage;\n    if (oldestHeartbeatStorage !\u003d null) {\n      storage \u003d oldestHeartbeatStorage;\n    } else if (minSpaceStorage !\u003d null) {\n      storage \u003d minSpaceStorage;\n    } else {\n      return null;\n    }\n    excessTypes.remove(storage.getStorageType());\n    return storage;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "[bc-BlockCollection, block-Block, replicationFactor-short, first-Collection\u003cDatanodeStorageInfo\u003e, second-Collection\u003cDatanodeStorageInfo\u003e, excessTypes-List\u003cStorageType\u003e(modifiers-final)]",
            "newValue": "[replicationFactor-short, moreThanone-Collection\u003cDatanodeStorageInfo\u003e, exactlyOne-Collection\u003cDatanodeStorageInfo\u003e, excessTypes-List\u003cStorageType\u003e(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8647. Abstract BlockManager\u0027s rack policy into BlockPlacementPolicy. (Brahma Reddy Battula via mingma)\n",
          "commitDate": "21/10/15 8:06 AM",
          "commitName": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "12/10/15 4:24 PM",
          "commitNameOld": "0f5f9846edab3ea7e80f35000072136f998bcd46",
          "commitAuthorOld": "Lei Xu",
          "daysBetweenCommits": 8.65,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,40 @@\n-  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n-      Block block, short replicationFactor,\n-      Collection\u003cDatanodeStorageInfo\u003e first,\n-      Collection\u003cDatanodeStorageInfo\u003e second,\n+  public DatanodeStorageInfo chooseReplicaToDelete(short replicationFactor,\n+      Collection\u003cDatanodeStorageInfo\u003e moreThanone, Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n       final List\u003cStorageType\u003e excessTypes) {\n     long oldestHeartbeat \u003d\n       monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n     DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n     long minSpace \u003d Long.MAX_VALUE;\n     DatanodeStorageInfo minSpaceStorage \u003d null;\n \n     // Pick the node with the oldest heartbeat or with the least free space,\n     // if all hearbeats are within the tolerable heartbeat interval\n-    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n+    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanone, exactlyOne)) {\n       if (!excessTypes.contains(storage.getStorageType())) {\n         continue;\n       }\n \n       final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n       long free \u003d node.getRemaining();\n       long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n       if (lastHeartbeat \u003c oldestHeartbeat) {\n         oldestHeartbeat \u003d lastHeartbeat;\n         oldestHeartbeatStorage \u003d storage;\n       }\n       if (minSpace \u003e free) {\n         minSpace \u003d free;\n         minSpaceStorage \u003d storage;\n       }\n     }\n \n     final DatanodeStorageInfo storage;\n     if (oldestHeartbeatStorage !\u003d null) {\n       storage \u003d oldestHeartbeatStorage;\n     } else if (minSpaceStorage !\u003d null) {\n       storage \u003d minSpaceStorage;\n     } else {\n       return null;\n     }\n     excessTypes.remove(storage.getStorageType());\n     return storage;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public DatanodeStorageInfo chooseReplicaToDelete(short replicationFactor,\n      Collection\u003cDatanodeStorageInfo\u003e moreThanone, Collection\u003cDatanodeStorageInfo\u003e exactlyOne,\n      final List\u003cStorageType\u003e excessTypes) {\n    long oldestHeartbeat \u003d\n      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n    long minSpace \u003d Long.MAX_VALUE;\n    DatanodeStorageInfo minSpaceStorage \u003d null;\n\n    // Pick the node with the oldest heartbeat or with the least free space,\n    // if all hearbeats are within the tolerable heartbeat interval\n    for(DatanodeStorageInfo storage : pickupReplicaSet(moreThanone, exactlyOne)) {\n      if (!excessTypes.contains(storage.getStorageType())) {\n        continue;\n      }\n\n      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n      long free \u003d node.getRemaining();\n      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n      if (lastHeartbeat \u003c oldestHeartbeat) {\n        oldestHeartbeat \u003d lastHeartbeat;\n        oldestHeartbeatStorage \u003d storage;\n      }\n      if (minSpace \u003e free) {\n        minSpace \u003d free;\n        minSpaceStorage \u003d storage;\n      }\n    }\n\n    final DatanodeStorageInfo storage;\n    if (oldestHeartbeatStorage !\u003d null) {\n      storage \u003d oldestHeartbeatStorage;\n    } else if (minSpaceStorage !\u003d null) {\n      storage \u003d minSpaceStorage;\n    } else {\n      return null;\n    }\n    excessTypes.remove(storage.getStorageType());\n    return storage;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {}
        }
      ]
    },
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6841. Use Time.monotonicNow() wherever applicable instead of Time.now(). Contributed by Vinayakumar B\n",
      "commitDate": "20/03/15 12:02 PM",
      "commitName": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "21/02/15 3:38 PM",
      "commitNameOld": "8b465b4b8caed31ca9daeaae108f9a868a30a455",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 26.81,
      "commitsBetweenForRepo": 229,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n       Block block, short replicationFactor,\n       Collection\u003cDatanodeStorageInfo\u003e first,\n       Collection\u003cDatanodeStorageInfo\u003e second,\n       final List\u003cStorageType\u003e excessTypes) {\n     long oldestHeartbeat \u003d\n-      now() - heartbeatInterval * tolerateHeartbeatMultiplier;\n+      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n     DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n     long minSpace \u003d Long.MAX_VALUE;\n     DatanodeStorageInfo minSpaceStorage \u003d null;\n \n     // Pick the node with the oldest heartbeat or with the least free space,\n     // if all hearbeats are within the tolerable heartbeat interval\n     for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n       if (!excessTypes.contains(storage.getStorageType())) {\n         continue;\n       }\n \n       final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n       long free \u003d node.getRemaining();\n-      long lastHeartbeat \u003d node.getLastUpdate();\n-      if(lastHeartbeat \u003c oldestHeartbeat) {\n+      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n+      if (lastHeartbeat \u003c oldestHeartbeat) {\n         oldestHeartbeat \u003d lastHeartbeat;\n         oldestHeartbeatStorage \u003d storage;\n       }\n       if (minSpace \u003e free) {\n         minSpace \u003d free;\n         minSpaceStorage \u003d storage;\n       }\n     }\n \n     final DatanodeStorageInfo storage;\n     if (oldestHeartbeatStorage !\u003d null) {\n       storage \u003d oldestHeartbeatStorage;\n     } else if (minSpaceStorage !\u003d null) {\n       storage \u003d minSpaceStorage;\n     } else {\n       return null;\n     }\n     excessTypes.remove(storage.getStorageType());\n     return storage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n      Block block, short replicationFactor,\n      Collection\u003cDatanodeStorageInfo\u003e first,\n      Collection\u003cDatanodeStorageInfo\u003e second,\n      final List\u003cStorageType\u003e excessTypes) {\n    long oldestHeartbeat \u003d\n      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n    long minSpace \u003d Long.MAX_VALUE;\n    DatanodeStorageInfo minSpaceStorage \u003d null;\n\n    // Pick the node with the oldest heartbeat or with the least free space,\n    // if all hearbeats are within the tolerable heartbeat interval\n    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n      if (!excessTypes.contains(storage.getStorageType())) {\n        continue;\n      }\n\n      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n      long free \u003d node.getRemaining();\n      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n      if (lastHeartbeat \u003c oldestHeartbeat) {\n        oldestHeartbeat \u003d lastHeartbeat;\n        oldestHeartbeatStorage \u003d storage;\n      }\n      if (minSpace \u003e free) {\n        minSpace \u003d free;\n        minSpaceStorage \u003d storage;\n      }\n    }\n\n    final DatanodeStorageInfo storage;\n    if (oldestHeartbeatStorage !\u003d null) {\n      storage \u003d oldestHeartbeatStorage;\n    } else if (minSpaceStorage !\u003d null) {\n      storage \u003d minSpaceStorage;\n    } else {\n      return null;\n    }\n    excessTypes.remove(storage.getStorageType());\n    return storage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "b7ded466b00db0fe273058b844d56d810e0f8cc2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6920. Archival Storage: check the storage type of delNodeHintStorage when deleting a replica. Contributed by Tsz Wo Nicholas Sze.\n",
      "commitDate": "27/08/14 2:08 PM",
      "commitName": "b7ded466b00db0fe273058b844d56d810e0f8cc2",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "21/08/14 4:42 PM",
      "commitNameOld": "e69954d22cc97eb3818c8ee7c3f623a5d0497b54",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.89,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,42 @@\n   public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n       Block block, short replicationFactor,\n       Collection\u003cDatanodeStorageInfo\u003e first,\n       Collection\u003cDatanodeStorageInfo\u003e second,\n       final List\u003cStorageType\u003e excessTypes) {\n     long oldestHeartbeat \u003d\n       now() - heartbeatInterval * tolerateHeartbeatMultiplier;\n     DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n     long minSpace \u003d Long.MAX_VALUE;\n     DatanodeStorageInfo minSpaceStorage \u003d null;\n \n     // Pick the node with the oldest heartbeat or with the least free space,\n     // if all hearbeats are within the tolerable heartbeat interval\n     for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n       if (!excessTypes.contains(storage.getStorageType())) {\n         continue;\n       }\n \n       final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n       long free \u003d node.getRemaining();\n       long lastHeartbeat \u003d node.getLastUpdate();\n       if(lastHeartbeat \u003c oldestHeartbeat) {\n         oldestHeartbeat \u003d lastHeartbeat;\n         oldestHeartbeatStorage \u003d storage;\n       }\n       if (minSpace \u003e free) {\n         minSpace \u003d free;\n         minSpaceStorage \u003d storage;\n       }\n     }\n-    final DatanodeStorageInfo storage \u003d oldestHeartbeatStorage !\u003d null?\n-        oldestHeartbeatStorage : minSpaceStorage;\n+\n+    final DatanodeStorageInfo storage;\n+    if (oldestHeartbeatStorage !\u003d null) {\n+      storage \u003d oldestHeartbeatStorage;\n+    } else if (minSpaceStorage !\u003d null) {\n+      storage \u003d minSpaceStorage;\n+    } else {\n+      return null;\n+    }\n     excessTypes.remove(storage.getStorageType());\n     return storage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n      Block block, short replicationFactor,\n      Collection\u003cDatanodeStorageInfo\u003e first,\n      Collection\u003cDatanodeStorageInfo\u003e second,\n      final List\u003cStorageType\u003e excessTypes) {\n    long oldestHeartbeat \u003d\n      now() - heartbeatInterval * tolerateHeartbeatMultiplier;\n    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n    long minSpace \u003d Long.MAX_VALUE;\n    DatanodeStorageInfo minSpaceStorage \u003d null;\n\n    // Pick the node with the oldest heartbeat or with the least free space,\n    // if all hearbeats are within the tolerable heartbeat interval\n    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n      if (!excessTypes.contains(storage.getStorageType())) {\n        continue;\n      }\n\n      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n      long free \u003d node.getRemaining();\n      long lastHeartbeat \u003d node.getLastUpdate();\n      if(lastHeartbeat \u003c oldestHeartbeat) {\n        oldestHeartbeat \u003d lastHeartbeat;\n        oldestHeartbeatStorage \u003d storage;\n      }\n      if (minSpace \u003e free) {\n        minSpace \u003d free;\n        minSpaceStorage \u003d storage;\n      }\n    }\n\n    final DatanodeStorageInfo storage;\n    if (oldestHeartbeatStorage !\u003d null) {\n      storage \u003d oldestHeartbeatStorage;\n    } else if (minSpaceStorage !\u003d null) {\n      storage \u003d minSpaceStorage;\n    } else {\n      return null;\n    }\n    excessTypes.remove(storage.getStorageType());\n    return storage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    }
  }
}