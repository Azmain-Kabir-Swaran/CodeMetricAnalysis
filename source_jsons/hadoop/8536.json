{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSImage.java",
  "functionName": "startCheckpoint",
  "functionId": "startCheckpoint___bnReg-NamenodeRegistration__nnReg-NamenodeRegistration__layoutVersion-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
  "functionStartLine": 1392,
  "functionEndLine": 1425,
  "numCommitsSeen": 228,
  "timeTaken": 7052,
  "changeHistory": [
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
    "573c41c2666e084f3988a288bb40d2305fc23d8f",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
    "6c0cb4d15179103d4f83fe5b2f8d8f6a05f3a789",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5": "Ymultichange(Yparameterchange,Ybodychange)",
    "573c41c2666e084f3988a288bb40d2305fc23d8f": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": "Ybodychange",
    "6c0cb4d15179103d4f83fe5b2f8d8f6a05f3a789": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-8432. Introduce a minimum compatible layout version to allow downgrade in more rolling upgrade use cases. Contributed by Chris Nauroth.\n",
      "commitDate": "06/06/15 9:43 AM",
      "commitName": "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
      "commitAuthor": "cnauroth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8432. Introduce a minimum compatible layout version to allow downgrade in more rolling upgrade use cases. Contributed by Chris Nauroth.\n",
          "commitDate": "06/06/15 9:43 AM",
          "commitName": "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
          "commitAuthor": "cnauroth",
          "commitDateOld": "03/06/15 3:00 AM",
          "commitNameOld": "c59e7456304def867afe35d6ee009ab572f8fdeb",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 3.28,
          "commitsBetweenForRepo": 35,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,34 @@\n   NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n-                                  NamenodeRegistration nnReg) // active name-node\n+                                  NamenodeRegistration nnReg,\n+                                  int layoutVersion) // active name-node\n   throws IOException {\n     LOG.info(\"Start checkpoint at txid \" + getEditLog().getLastWrittenTxId());\n     String msg \u003d null;\n     // Verify that checkpoint is allowed\n     if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n             + \" expected: \" + storage.getNamespaceID();\n     else if(bnReg.isRole(NamenodeRole.NAMENODE))\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n     else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n         || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n             \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime()))\n       // remote node has newer image age\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n             + \" cTime \u003d \" + bnReg.getCTime()\n             + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n             + \" cTime \u003d \" + storage.getCTime();\n     if(msg !\u003d null) {\n       LOG.error(msg);\n       return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n     }\n     boolean needToReturnImg \u003d true;\n     if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n       // do not return image if there are no image directories\n       needToReturnImg \u003d false;\n-    CheckpointSignature sig \u003d rollEditLog();\n+    CheckpointSignature sig \u003d rollEditLog(layoutVersion);\n     return new CheckpointCommand(sig, needToReturnImg);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n                                  NamenodeRegistration nnReg,\n                                  int layoutVersion) // active name-node\n  throws IOException {\n    LOG.info(\"Start checkpoint at txid \" + getEditLog().getLastWrittenTxId());\n    String msg \u003d null;\n    // Verify that checkpoint is allowed\n    if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n            + \" expected: \" + storage.getNamespaceID();\n    else if(bnReg.isRole(NamenodeRole.NAMENODE))\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n    else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n            \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime()))\n      // remote node has newer image age\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n            + \" cTime \u003d \" + bnReg.getCTime()\n            + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n            + \" cTime \u003d \" + storage.getCTime();\n    if(msg !\u003d null) {\n      LOG.error(msg);\n      return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n    }\n    boolean needToReturnImg \u003d true;\n    if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n      // do not return image if there are no image directories\n      needToReturnImg \u003d false;\n    CheckpointSignature sig \u003d rollEditLog(layoutVersion);\n    return new CheckpointCommand(sig, needToReturnImg);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[bnReg-NamenodeRegistration, nnReg-NamenodeRegistration]",
            "newValue": "[bnReg-NamenodeRegistration, nnReg-NamenodeRegistration, layoutVersion-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8432. Introduce a minimum compatible layout version to allow downgrade in more rolling upgrade use cases. Contributed by Chris Nauroth.\n",
          "commitDate": "06/06/15 9:43 AM",
          "commitName": "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
          "commitAuthor": "cnauroth",
          "commitDateOld": "03/06/15 3:00 AM",
          "commitNameOld": "c59e7456304def867afe35d6ee009ab572f8fdeb",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 3.28,
          "commitsBetweenForRepo": 35,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,34 @@\n   NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n-                                  NamenodeRegistration nnReg) // active name-node\n+                                  NamenodeRegistration nnReg,\n+                                  int layoutVersion) // active name-node\n   throws IOException {\n     LOG.info(\"Start checkpoint at txid \" + getEditLog().getLastWrittenTxId());\n     String msg \u003d null;\n     // Verify that checkpoint is allowed\n     if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n             + \" expected: \" + storage.getNamespaceID();\n     else if(bnReg.isRole(NamenodeRole.NAMENODE))\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n     else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n         || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n             \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime()))\n       // remote node has newer image age\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n             + \" cTime \u003d \" + bnReg.getCTime()\n             + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n             + \" cTime \u003d \" + storage.getCTime();\n     if(msg !\u003d null) {\n       LOG.error(msg);\n       return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n     }\n     boolean needToReturnImg \u003d true;\n     if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n       // do not return image if there are no image directories\n       needToReturnImg \u003d false;\n-    CheckpointSignature sig \u003d rollEditLog();\n+    CheckpointSignature sig \u003d rollEditLog(layoutVersion);\n     return new CheckpointCommand(sig, needToReturnImg);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n                                  NamenodeRegistration nnReg,\n                                  int layoutVersion) // active name-node\n  throws IOException {\n    LOG.info(\"Start checkpoint at txid \" + getEditLog().getLastWrittenTxId());\n    String msg \u003d null;\n    // Verify that checkpoint is allowed\n    if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n            + \" expected: \" + storage.getNamespaceID();\n    else if(bnReg.isRole(NamenodeRole.NAMENODE))\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n    else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n            \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime()))\n      // remote node has newer image age\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n            + \" cTime \u003d \" + bnReg.getCTime()\n            + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n            + \" cTime \u003d \" + storage.getCTime();\n    if(msg !\u003d null) {\n      LOG.error(msg);\n      return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n    }\n    boolean needToReturnImg \u003d true;\n    if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n      // do not return image if there are no image directories\n      needToReturnImg \u003d false;\n    CheckpointSignature sig \u003d rollEditLog(layoutVersion);\n    return new CheckpointCommand(sig, needToReturnImg);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {}
        }
      ]
    },
    "573c41c2666e084f3988a288bb40d2305fc23d8f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4179. BackupNode: allow reads, fix checkpointing, safeMode. (shv)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1411508 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/11/12 6:00 PM",
      "commitName": "573c41c2666e084f3988a288bb40d2305fc23d8f",
      "commitAuthor": "Konstantin Shvachko",
      "commitDateOld": "28/08/12 3:09 PM",
      "commitNameOld": "d4d2bf73a9181a5bfdc0fd99328c7ee4ec998b4e",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 83.16,
      "commitsBetweenForRepo": 497,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,33 @@\n   NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n                                   NamenodeRegistration nnReg) // active name-node\n   throws IOException {\n+    LOG.info(\"Start checkpoint at txid \" + getEditLog().getLastWrittenTxId());\n     String msg \u003d null;\n     // Verify that checkpoint is allowed\n     if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n             + \" expected: \" + storage.getNamespaceID();\n     else if(bnReg.isRole(NamenodeRole.NAMENODE))\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n     else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n         || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n             \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime()))\n       // remote node has newer image age\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n             + \" cTime \u003d \" + bnReg.getCTime()\n             + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n             + \" cTime \u003d \" + storage.getCTime();\n     if(msg !\u003d null) {\n       LOG.error(msg);\n       return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n     }\n     boolean needToReturnImg \u003d true;\n     if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n       // do not return image if there are no image directories\n       needToReturnImg \u003d false;\n     CheckpointSignature sig \u003d rollEditLog();\n     return new CheckpointCommand(sig, needToReturnImg);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n                                  NamenodeRegistration nnReg) // active name-node\n  throws IOException {\n    LOG.info(\"Start checkpoint at txid \" + getEditLog().getLastWrittenTxId());\n    String msg \u003d null;\n    // Verify that checkpoint is allowed\n    if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n            + \" expected: \" + storage.getNamespaceID();\n    else if(bnReg.isRole(NamenodeRole.NAMENODE))\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n    else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n            \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime()))\n      // remote node has newer image age\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n            + \" cTime \u003d \" + bnReg.getCTime()\n            + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n            + \" cTime \u003d \" + storage.getCTime();\n    if(msg !\u003d null) {\n      LOG.error(msg);\n      return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n    }\n    boolean needToReturnImg \u003d true;\n    if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n      // do not return image if there are no image directories\n      needToReturnImg \u003d false;\n    CheckpointSignature sig \u003d rollEditLog();\n    return new CheckpointCommand(sig, needToReturnImg);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n                                  NamenodeRegistration nnReg) // active name-node\n  throws IOException {\n    String msg \u003d null;\n    // Verify that checkpoint is allowed\n    if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n            + \" expected: \" + storage.getNamespaceID();\n    else if(bnReg.isRole(NamenodeRole.NAMENODE))\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n    else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n            \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime()))\n      // remote node has newer image age\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n            + \" cTime \u003d \" + bnReg.getCTime()\n            + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n            + \" cTime \u003d \" + storage.getCTime();\n    if(msg !\u003d null) {\n      LOG.error(msg);\n      return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n    }\n    boolean needToReturnImg \u003d true;\n    if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n      // do not return image if there are no image directories\n      needToReturnImg \u003d false;\n    CheckpointSignature sig \u003d rollEditLog();\n    return new CheckpointCommand(sig, needToReturnImg);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n                                  NamenodeRegistration nnReg) // active name-node\n  throws IOException {\n    String msg \u003d null;\n    // Verify that checkpoint is allowed\n    if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n            + \" expected: \" + storage.getNamespaceID();\n    else if(bnReg.isRole(NamenodeRole.NAMENODE))\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n    else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n            \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime()))\n      // remote node has newer image age\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n            + \" cTime \u003d \" + bnReg.getCTime()\n            + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n            + \" cTime \u003d \" + storage.getCTime();\n    if(msg !\u003d null) {\n      LOG.error(msg);\n      return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n    }\n    boolean needToReturnImg \u003d true;\n    if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n      // do not return image if there are no image directories\n      needToReturnImg \u003d false;\n    CheckpointSignature sig \u003d rollEditLog();\n    return new CheckpointCommand(sig, needToReturnImg);\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
      }
    },
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/11 9:28 AM",
      "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "27/07/11 8:19 PM",
      "commitNameOld": "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 1.55,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,32 @@\n   NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n                                   NamenodeRegistration nnReg) // active name-node\n   throws IOException {\n     String msg \u003d null;\n     // Verify that checkpoint is allowed\n     if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n             + \" expected: \" + storage.getNamespaceID();\n     else if(bnReg.isRole(NamenodeRole.NAMENODE))\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n     else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n         || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n-            \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime())\n-        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n-            \u0026\u0026 bnReg.getCTime() \u003d\u003d storage.getCTime()\n-            \u0026\u0026 bnReg.getCheckpointTime() \u003e storage.getCheckpointTime()))\n+            \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime()))\n       // remote node has newer image age\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n             + \" cTime \u003d \" + bnReg.getCTime()\n-            + \" checkpointTime \u003d \" + bnReg.getCheckpointTime()\n             + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n-            + \" cTime \u003d \" + storage.getCTime()\n-            + \" checkpointTime \u003d \" + storage.getCheckpointTime();\n+            + \" cTime \u003d \" + storage.getCTime();\n     if(msg !\u003d null) {\n       LOG.error(msg);\n       return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n     }\n-    boolean isImgObsolete \u003d true;\n-    if(bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n-        \u0026\u0026 bnReg.getCTime() \u003d\u003d storage.getCTime()\n-        \u0026\u0026 bnReg.getCheckpointTime() \u003d\u003d storage.getCheckpointTime())\n-      isImgObsolete \u003d false;\n     boolean needToReturnImg \u003d true;\n     if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n       // do not return image if there are no image directories\n       needToReturnImg \u003d false;\n     CheckpointSignature sig \u003d rollEditLog();\n-    getEditLog().logJSpoolStart(bnReg, nnReg);\n-    return new CheckpointCommand(sig, isImgObsolete, needToReturnImg);\n+    return new CheckpointCommand(sig, needToReturnImg);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n                                  NamenodeRegistration nnReg) // active name-node\n  throws IOException {\n    String msg \u003d null;\n    // Verify that checkpoint is allowed\n    if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n            + \" expected: \" + storage.getNamespaceID();\n    else if(bnReg.isRole(NamenodeRole.NAMENODE))\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n    else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n            \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime()))\n      // remote node has newer image age\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n            + \" cTime \u003d \" + bnReg.getCTime()\n            + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n            + \" cTime \u003d \" + storage.getCTime();\n    if(msg !\u003d null) {\n      LOG.error(msg);\n      return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n    }\n    boolean needToReturnImg \u003d true;\n    if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n      // do not return image if there are no image directories\n      needToReturnImg \u003d false;\n    CheckpointSignature sig \u003d rollEditLog();\n    return new CheckpointCommand(sig, needToReturnImg);\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "6c0cb4d15179103d4f83fe5b2f8d8f6a05f3a789": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2141. Remove NameNode roles Active and Standby (they become states of the namenode). Contributed by Suresh Srinivas.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1148125 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/11 6:32 PM",
      "commitName": "6c0cb4d15179103d4f83fe5b2f8d8f6a05f3a789",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "30/06/11 11:38 AM",
      "commitNameOld": "5147e283ad9757ac2cabaf282ae5cbba76826ede",
      "commitAuthorOld": "Matthew Foley",
      "daysBetweenCommits": 18.29,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n                                   NamenodeRegistration nnReg) // active name-node\n   throws IOException {\n     String msg \u003d null;\n     // Verify that checkpoint is allowed\n     if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n             + \" expected: \" + storage.getNamespaceID();\n-    else if(bnReg.isRole(NamenodeRole.ACTIVE))\n+    else if(bnReg.isRole(NamenodeRole.NAMENODE))\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n     else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n         || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n             \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime())\n         || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n             \u0026\u0026 bnReg.getCTime() \u003d\u003d storage.getCTime()\n             \u0026\u0026 bnReg.getCheckpointTime() \u003e storage.getCheckpointTime()))\n       // remote node has newer image age\n       msg \u003d \"Name node \" + bnReg.getAddress()\n             + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n             + \" cTime \u003d \" + bnReg.getCTime()\n             + \" checkpointTime \u003d \" + bnReg.getCheckpointTime()\n             + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n             + \" cTime \u003d \" + storage.getCTime()\n             + \" checkpointTime \u003d \" + storage.getCheckpointTime();\n     if(msg !\u003d null) {\n       LOG.error(msg);\n       return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n     }\n     boolean isImgObsolete \u003d true;\n     if(bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n         \u0026\u0026 bnReg.getCTime() \u003d\u003d storage.getCTime()\n         \u0026\u0026 bnReg.getCheckpointTime() \u003d\u003d storage.getCheckpointTime())\n       isImgObsolete \u003d false;\n     boolean needToReturnImg \u003d true;\n     if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n       // do not return image if there are no image directories\n       needToReturnImg \u003d false;\n     CheckpointSignature sig \u003d rollEditLog();\n     getEditLog().logJSpoolStart(bnReg, nnReg);\n     return new CheckpointCommand(sig, isImgObsolete, needToReturnImg);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n                                  NamenodeRegistration nnReg) // active name-node\n  throws IOException {\n    String msg \u003d null;\n    // Verify that checkpoint is allowed\n    if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n            + \" expected: \" + storage.getNamespaceID();\n    else if(bnReg.isRole(NamenodeRole.NAMENODE))\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n    else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n            \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime())\n        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n            \u0026\u0026 bnReg.getCTime() \u003d\u003d storage.getCTime()\n            \u0026\u0026 bnReg.getCheckpointTime() \u003e storage.getCheckpointTime()))\n      // remote node has newer image age\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n            + \" cTime \u003d \" + bnReg.getCTime()\n            + \" checkpointTime \u003d \" + bnReg.getCheckpointTime()\n            + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n            + \" cTime \u003d \" + storage.getCTime()\n            + \" checkpointTime \u003d \" + storage.getCheckpointTime();\n    if(msg !\u003d null) {\n      LOG.error(msg);\n      return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n    }\n    boolean isImgObsolete \u003d true;\n    if(bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n        \u0026\u0026 bnReg.getCTime() \u003d\u003d storage.getCTime()\n        \u0026\u0026 bnReg.getCheckpointTime() \u003d\u003d storage.getCheckpointTime())\n      isImgObsolete \u003d false;\n    boolean needToReturnImg \u003d true;\n    if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n      // do not return image if there are no image directories\n      needToReturnImg \u003d false;\n    CheckpointSignature sig \u003d rollEditLog();\n    getEditLog().logJSpoolStart(bnReg, nnReg);\n    return new CheckpointCommand(sig, isImgObsolete, needToReturnImg);\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,43 @@\n+  NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n+                                  NamenodeRegistration nnReg) // active name-node\n+  throws IOException {\n+    String msg \u003d null;\n+    // Verify that checkpoint is allowed\n+    if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n+      msg \u003d \"Name node \" + bnReg.getAddress()\n+            + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n+            + \" expected: \" + storage.getNamespaceID();\n+    else if(bnReg.isRole(NamenodeRole.ACTIVE))\n+      msg \u003d \"Name node \" + bnReg.getAddress()\n+            + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n+    else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n+        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n+            \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime())\n+        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n+            \u0026\u0026 bnReg.getCTime() \u003d\u003d storage.getCTime()\n+            \u0026\u0026 bnReg.getCheckpointTime() \u003e storage.getCheckpointTime()))\n+      // remote node has newer image age\n+      msg \u003d \"Name node \" + bnReg.getAddress()\n+            + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n+            + \" cTime \u003d \" + bnReg.getCTime()\n+            + \" checkpointTime \u003d \" + bnReg.getCheckpointTime()\n+            + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n+            + \" cTime \u003d \" + storage.getCTime()\n+            + \" checkpointTime \u003d \" + storage.getCheckpointTime();\n+    if(msg !\u003d null) {\n+      LOG.error(msg);\n+      return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n+    }\n+    boolean isImgObsolete \u003d true;\n+    if(bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n+        \u0026\u0026 bnReg.getCTime() \u003d\u003d storage.getCTime()\n+        \u0026\u0026 bnReg.getCheckpointTime() \u003d\u003d storage.getCheckpointTime())\n+      isImgObsolete \u003d false;\n+    boolean needToReturnImg \u003d true;\n+    if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n+      // do not return image if there are no image directories\n+      needToReturnImg \u003d false;\n+    CheckpointSignature sig \u003d rollEditLog();\n+    getEditLog().logJSpoolStart(bnReg, nnReg);\n+    return new CheckpointCommand(sig, isImgObsolete, needToReturnImg);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  NamenodeCommand startCheckpoint(NamenodeRegistration bnReg, // backup node\n                                  NamenodeRegistration nnReg) // active name-node\n  throws IOException {\n    String msg \u003d null;\n    // Verify that checkpoint is allowed\n    if(bnReg.getNamespaceID() !\u003d storage.getNamespaceID())\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has incompatible namespace id: \" + bnReg.getNamespaceID()\n            + \" expected: \" + storage.getNamespaceID();\n    else if(bnReg.isRole(NamenodeRole.ACTIVE))\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" role \" + bnReg.getRole() + \": checkpoint is not allowed.\";\n    else if(bnReg.getLayoutVersion() \u003c storage.getLayoutVersion()\n        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n            \u0026\u0026 bnReg.getCTime() \u003e storage.getCTime())\n        || (bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n            \u0026\u0026 bnReg.getCTime() \u003d\u003d storage.getCTime()\n            \u0026\u0026 bnReg.getCheckpointTime() \u003e storage.getCheckpointTime()))\n      // remote node has newer image age\n      msg \u003d \"Name node \" + bnReg.getAddress()\n            + \" has newer image layout version: LV \u003d \" +bnReg.getLayoutVersion()\n            + \" cTime \u003d \" + bnReg.getCTime()\n            + \" checkpointTime \u003d \" + bnReg.getCheckpointTime()\n            + \". Current version: LV \u003d \" + storage.getLayoutVersion()\n            + \" cTime \u003d \" + storage.getCTime()\n            + \" checkpointTime \u003d \" + storage.getCheckpointTime();\n    if(msg !\u003d null) {\n      LOG.error(msg);\n      return new NamenodeCommand(NamenodeProtocol.ACT_SHUTDOWN);\n    }\n    boolean isImgObsolete \u003d true;\n    if(bnReg.getLayoutVersion() \u003d\u003d storage.getLayoutVersion()\n        \u0026\u0026 bnReg.getCTime() \u003d\u003d storage.getCTime()\n        \u0026\u0026 bnReg.getCheckpointTime() \u003d\u003d storage.getCheckpointTime())\n      isImgObsolete \u003d false;\n    boolean needToReturnImg \u003d true;\n    if(storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0)\n      // do not return image if there are no image directories\n      needToReturnImg \u003d false;\n    CheckpointSignature sig \u003d rollEditLog();\n    getEditLog().logJSpoolStart(bnReg, nnReg);\n    return new CheckpointCommand(sig, isImgObsolete, needToReturnImg);\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
    }
  }
}