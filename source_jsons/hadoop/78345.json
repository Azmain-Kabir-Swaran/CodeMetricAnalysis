{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InodeTree.java",
  "functionName": "createLink",
  "functionId": "createLink___src-String(modifiers-final)__target-String(modifiers-final)__linkType-LinkType(modifiers-final)__settings-String(modifiers-final)__aUgi-UserGroupInformation(modifiers-final)__config-Configuration(modifiers-final)",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
  "functionStartLine": 291,
  "functionEndLine": 366,
  "numCommitsSeen": 18,
  "timeTaken": 3099,
  "changeHistory": [
    "133d7ca76e3d4b60292d57429d4259e80bec650a",
    "1f3bc63e6772be81bc9a6a7d93ed81d2a9e066c0",
    "0f4afc81009129bbee89d5b6cf22c8dda612d223",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "f1c74df922058e88791ed6971bbb96b53f6770f1"
  ],
  "changeHistoryShort": {
    "133d7ca76e3d4b60292d57429d4259e80bec650a": "Ybodychange",
    "1f3bc63e6772be81bc9a6a7d93ed81d2a9e066c0": "Ymultichange(Yparameterchange,Ybodychange)",
    "0f4afc81009129bbee89d5b6cf22c8dda612d223": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "f1c74df922058e88791ed6971bbb96b53f6770f1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "133d7ca76e3d4b60292d57429d4259e80bec650a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13055. Implement linkMergeSlash and linkFallback for ViewFileSystem\n",
      "commitDate": "13/10/17 5:43 PM",
      "commitName": "133d7ca76e3d4b60292d57429d4259e80bec650a",
      "commitAuthor": "Manoj Govindassamy",
      "commitDateOld": "03/10/17 11:23 AM",
      "commitNameOld": "b91305119b434d23b99ae7e755aea6639f48b6ab",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 10.26,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,76 @@\n   private void createLink(final String src, final String target,\n       final LinkType linkType, final String settings,\n       final UserGroupInformation aUgi,\n       final Configuration config)\n       throws URISyntaxException, IOException,\n       FileAlreadyExistsException, UnsupportedFileSystemException {\n     // Validate that src is valid absolute path\n     final Path srcPath \u003d new Path(src);\n     if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n       throw new IOException(\"ViewFs: Non absolute mount name in config:\" + src);\n     }\n \n     final String[] srcPaths \u003d breakIntoPathComponents(src);\n-    INodeDir\u003cT\u003e curInode \u003d root;\n+    // Make sure root is of INodeDir type before\n+    // adding any regular links to it.\n+    Preconditions.checkState(root.isInternalDir());\n+    INodeDir\u003cT\u003e curInode \u003d getRootDir();\n     int i;\n     // Ignore first initial slash, process all except last component\n     for (i \u003d 1; i \u003c srcPaths.length - 1; i++) {\n       final String iPath \u003d srcPaths[i];\n       INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n       if (nextInode \u003d\u003d null) {\n         INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n-        newDir.InodeDirFs \u003d getTargetFileSystem(newDir);\n+        newDir.setInternalDirFs(getTargetFileSystem(newDir));\n         nextInode \u003d newDir;\n       }\n-      if (nextInode instanceof INodeLink) {\n+      if (nextInode.isLink()) {\n         // Error - expected a dir but got a link\n         throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n             \" already exists as link\");\n       } else {\n-        assert (nextInode instanceof INodeDir);\n+        assert(nextInode.isInternalDir());\n         curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n       }\n     }\n \n     // Now process the last component\n     // Add the link in 2 cases: does not exist or a link exists\n     String iPath \u003d srcPaths[i];// last component\n     if (curInode.resolveInternal(iPath) !\u003d null) {\n       //  directory/link already exists\n       StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n       for (int j \u003d 1; j \u003c\u003d i; ++j) {\n         strB.append(\u0027/\u0027).append(srcPaths[j]);\n       }\n       throw new FileAlreadyExistsException(\"Path \" + strB +\n           \" already exists as dir; cannot create link here\");\n     }\n \n     final INodeLink\u003cT\u003e newLink;\n     final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n         + iPath;\n     switch (linkType) {\n     case SINGLE:\n       newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n           getTargetFileSystem(new URI(target)), new URI(target));\n       break;\n+    case SINGLE_FALLBACK:\n+    case MERGE_SLASH:\n+      // Link fallback and link merge slash configuration\n+      // are handled specially at InodeTree.\n+      throw new IllegalArgumentException(\"Unexpected linkType: \" + linkType);\n     case MERGE:\n     case NFLY:\n       final URI[] targetUris \u003d StringUtils.stringToURI(\n           StringUtils.getStrings(target));\n       newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n             getTargetFileSystem(settings, targetUris), targetUris);\n       break;\n     default:\n       throw new IllegalArgumentException(linkType + \": Infeasible linkType\");\n     }\n     curInode.addLink(iPath, newLink);\n     mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void createLink(final String src, final String target,\n      final LinkType linkType, final String settings,\n      final UserGroupInformation aUgi,\n      final Configuration config)\n      throws URISyntaxException, IOException,\n      FileAlreadyExistsException, UnsupportedFileSystemException {\n    // Validate that src is valid absolute path\n    final Path srcPath \u003d new Path(src);\n    if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n      throw new IOException(\"ViewFs: Non absolute mount name in config:\" + src);\n    }\n\n    final String[] srcPaths \u003d breakIntoPathComponents(src);\n    // Make sure root is of INodeDir type before\n    // adding any regular links to it.\n    Preconditions.checkState(root.isInternalDir());\n    INodeDir\u003cT\u003e curInode \u003d getRootDir();\n    int i;\n    // Ignore first initial slash, process all except last component\n    for (i \u003d 1; i \u003c srcPaths.length - 1; i++) {\n      final String iPath \u003d srcPaths[i];\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n      if (nextInode \u003d\u003d null) {\n        INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n        newDir.setInternalDirFs(getTargetFileSystem(newDir));\n        nextInode \u003d newDir;\n      }\n      if (nextInode.isLink()) {\n        // Error - expected a dir but got a link\n        throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n            \" already exists as link\");\n      } else {\n        assert(nextInode.isInternalDir());\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n\n    // Now process the last component\n    // Add the link in 2 cases: does not exist or a link exists\n    String iPath \u003d srcPaths[i];// last component\n    if (curInode.resolveInternal(iPath) !\u003d null) {\n      //  directory/link already exists\n      StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n      for (int j \u003d 1; j \u003c\u003d i; ++j) {\n        strB.append(\u0027/\u0027).append(srcPaths[j]);\n      }\n      throw new FileAlreadyExistsException(\"Path \" + strB +\n          \" already exists as dir; cannot create link here\");\n    }\n\n    final INodeLink\u003cT\u003e newLink;\n    final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n        + iPath;\n    switch (linkType) {\n    case SINGLE:\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(new URI(target)), new URI(target));\n      break;\n    case SINGLE_FALLBACK:\n    case MERGE_SLASH:\n      // Link fallback and link merge slash configuration\n      // are handled specially at InodeTree.\n      throw new IllegalArgumentException(\"Unexpected linkType: \" + linkType);\n    case MERGE:\n    case NFLY:\n      final URI[] targetUris \u003d StringUtils.stringToURI(\n          StringUtils.getStrings(target));\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n            getTargetFileSystem(settings, targetUris), targetUris);\n      break;\n    default:\n      throw new IllegalArgumentException(linkType + \": Infeasible linkType\");\n    }\n    curInode.addLink(iPath, newLink);\n    mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
      "extendedDetails": {}
    },
    "1f3bc63e6772be81bc9a6a7d93ed81d2a9e066c0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-12077. Provide a multi-URI replication Inode for ViewFs. Contributed by Gera Shegalov\n",
      "commitDate": "05/09/17 11:51 PM",
      "commitName": "1f3bc63e6772be81bc9a6a7d93ed81d2a9e066c0",
      "commitAuthor": "Chris Douglas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-12077. Provide a multi-URI replication Inode for ViewFs. Contributed by Gera Shegalov\n",
          "commitDate": "05/09/17 11:51 PM",
          "commitName": "1f3bc63e6772be81bc9a6a7d93ed81d2a9e066c0",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "26/10/16 2:25 PM",
          "commitNameOld": "22ff0eff4d58ac0beda7a5a3ae0e5d108da14f7f",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 314.39,
          "commitsBetweenForRepo": 1897,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,64 +1,68 @@\n   private void createLink(final String src, final String target,\n-      final boolean isLinkMerge, final UserGroupInformation aUgi)\n+      final LinkType linkType, final String settings,\n+      final UserGroupInformation aUgi,\n+      final Configuration config)\n       throws URISyntaxException, IOException,\n       FileAlreadyExistsException, UnsupportedFileSystemException {\n     // Validate that src is valid absolute path\n     final Path srcPath \u003d new Path(src);\n     if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n       throw new IOException(\"ViewFs: Non absolute mount name in config:\" + src);\n     }\n \n     final String[] srcPaths \u003d breakIntoPathComponents(src);\n     INodeDir\u003cT\u003e curInode \u003d root;\n     int i;\n     // Ignore first initial slash, process all except last component\n     for (i \u003d 1; i \u003c srcPaths.length - 1; i++) {\n       final String iPath \u003d srcPaths[i];\n       INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n       if (nextInode \u003d\u003d null) {\n         INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n         newDir.InodeDirFs \u003d getTargetFileSystem(newDir);\n         nextInode \u003d newDir;\n       }\n       if (nextInode instanceof INodeLink) {\n         // Error - expected a dir but got a link\n         throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n             \" already exists as link\");\n       } else {\n         assert (nextInode instanceof INodeDir);\n         curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n       }\n     }\n \n     // Now process the last component\n     // Add the link in 2 cases: does not exist or a link exists\n     String iPath \u003d srcPaths[i];// last component\n     if (curInode.resolveInternal(iPath) !\u003d null) {\n       //  directory/link already exists\n       StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n       for (int j \u003d 1; j \u003c\u003d i; ++j) {\n         strB.append(\u0027/\u0027).append(srcPaths[j]);\n       }\n       throw new FileAlreadyExistsException(\"Path \" + strB +\n           \" already exists as dir; cannot create link here\");\n     }\n \n     final INodeLink\u003cT\u003e newLink;\n     final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n         + iPath;\n-    if (isLinkMerge) { // Target is list of URIs\n-      String[] targetsList \u003d StringUtils.getStrings(target);\n-      URI[] targetsListURI \u003d new URI[targetsList.length];\n-      int k \u003d 0;\n-      for (String itarget : targetsList) {\n-        targetsListURI[k++] \u003d new URI(itarget);\n-      }\n-      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n-          getTargetFileSystem(targetsListURI), targetsListURI);\n-    } else {\n+    switch (linkType) {\n+    case SINGLE:\n       newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n           getTargetFileSystem(new URI(target)), new URI(target));\n+      break;\n+    case MERGE:\n+    case NFLY:\n+      final URI[] targetUris \u003d StringUtils.stringToURI(\n+          StringUtils.getStrings(target));\n+      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n+            getTargetFileSystem(settings, targetUris), targetUris);\n+      break;\n+    default:\n+      throw new IllegalArgumentException(linkType + \": Infeasible linkType\");\n     }\n     curInode.addLink(iPath, newLink);\n     mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void createLink(final String src, final String target,\n      final LinkType linkType, final String settings,\n      final UserGroupInformation aUgi,\n      final Configuration config)\n      throws URISyntaxException, IOException,\n      FileAlreadyExistsException, UnsupportedFileSystemException {\n    // Validate that src is valid absolute path\n    final Path srcPath \u003d new Path(src);\n    if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n      throw new IOException(\"ViewFs: Non absolute mount name in config:\" + src);\n    }\n\n    final String[] srcPaths \u003d breakIntoPathComponents(src);\n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // Ignore first initial slash, process all except last component\n    for (i \u003d 1; i \u003c srcPaths.length - 1; i++) {\n      final String iPath \u003d srcPaths[i];\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n      if (nextInode \u003d\u003d null) {\n        INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n        newDir.InodeDirFs \u003d getTargetFileSystem(newDir);\n        nextInode \u003d newDir;\n      }\n      if (nextInode instanceof INodeLink) {\n        // Error - expected a dir but got a link\n        throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n            \" already exists as link\");\n      } else {\n        assert (nextInode instanceof INodeDir);\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n\n    // Now process the last component\n    // Add the link in 2 cases: does not exist or a link exists\n    String iPath \u003d srcPaths[i];// last component\n    if (curInode.resolveInternal(iPath) !\u003d null) {\n      //  directory/link already exists\n      StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n      for (int j \u003d 1; j \u003c\u003d i; ++j) {\n        strB.append(\u0027/\u0027).append(srcPaths[j]);\n      }\n      throw new FileAlreadyExistsException(\"Path \" + strB +\n          \" already exists as dir; cannot create link here\");\n    }\n\n    final INodeLink\u003cT\u003e newLink;\n    final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n        + iPath;\n    switch (linkType) {\n    case SINGLE:\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(new URI(target)), new URI(target));\n      break;\n    case MERGE:\n    case NFLY:\n      final URI[] targetUris \u003d StringUtils.stringToURI(\n          StringUtils.getStrings(target));\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n            getTargetFileSystem(settings, targetUris), targetUris);\n      break;\n    default:\n      throw new IllegalArgumentException(linkType + \": Infeasible linkType\");\n    }\n    curInode.addLink(iPath, newLink);\n    mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
          "extendedDetails": {
            "oldValue": "[src-String(modifiers-final), target-String(modifiers-final), isLinkMerge-boolean(modifiers-final), aUgi-UserGroupInformation(modifiers-final)]",
            "newValue": "[src-String(modifiers-final), target-String(modifiers-final), linkType-LinkType(modifiers-final), settings-String(modifiers-final), aUgi-UserGroupInformation(modifiers-final), config-Configuration(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-12077. Provide a multi-URI replication Inode for ViewFs. Contributed by Gera Shegalov\n",
          "commitDate": "05/09/17 11:51 PM",
          "commitName": "1f3bc63e6772be81bc9a6a7d93ed81d2a9e066c0",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "26/10/16 2:25 PM",
          "commitNameOld": "22ff0eff4d58ac0beda7a5a3ae0e5d108da14f7f",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 314.39,
          "commitsBetweenForRepo": 1897,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,64 +1,68 @@\n   private void createLink(final String src, final String target,\n-      final boolean isLinkMerge, final UserGroupInformation aUgi)\n+      final LinkType linkType, final String settings,\n+      final UserGroupInformation aUgi,\n+      final Configuration config)\n       throws URISyntaxException, IOException,\n       FileAlreadyExistsException, UnsupportedFileSystemException {\n     // Validate that src is valid absolute path\n     final Path srcPath \u003d new Path(src);\n     if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n       throw new IOException(\"ViewFs: Non absolute mount name in config:\" + src);\n     }\n \n     final String[] srcPaths \u003d breakIntoPathComponents(src);\n     INodeDir\u003cT\u003e curInode \u003d root;\n     int i;\n     // Ignore first initial slash, process all except last component\n     for (i \u003d 1; i \u003c srcPaths.length - 1; i++) {\n       final String iPath \u003d srcPaths[i];\n       INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n       if (nextInode \u003d\u003d null) {\n         INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n         newDir.InodeDirFs \u003d getTargetFileSystem(newDir);\n         nextInode \u003d newDir;\n       }\n       if (nextInode instanceof INodeLink) {\n         // Error - expected a dir but got a link\n         throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n             \" already exists as link\");\n       } else {\n         assert (nextInode instanceof INodeDir);\n         curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n       }\n     }\n \n     // Now process the last component\n     // Add the link in 2 cases: does not exist or a link exists\n     String iPath \u003d srcPaths[i];// last component\n     if (curInode.resolveInternal(iPath) !\u003d null) {\n       //  directory/link already exists\n       StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n       for (int j \u003d 1; j \u003c\u003d i; ++j) {\n         strB.append(\u0027/\u0027).append(srcPaths[j]);\n       }\n       throw new FileAlreadyExistsException(\"Path \" + strB +\n           \" already exists as dir; cannot create link here\");\n     }\n \n     final INodeLink\u003cT\u003e newLink;\n     final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n         + iPath;\n-    if (isLinkMerge) { // Target is list of URIs\n-      String[] targetsList \u003d StringUtils.getStrings(target);\n-      URI[] targetsListURI \u003d new URI[targetsList.length];\n-      int k \u003d 0;\n-      for (String itarget : targetsList) {\n-        targetsListURI[k++] \u003d new URI(itarget);\n-      }\n-      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n-          getTargetFileSystem(targetsListURI), targetsListURI);\n-    } else {\n+    switch (linkType) {\n+    case SINGLE:\n       newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n           getTargetFileSystem(new URI(target)), new URI(target));\n+      break;\n+    case MERGE:\n+    case NFLY:\n+      final URI[] targetUris \u003d StringUtils.stringToURI(\n+          StringUtils.getStrings(target));\n+      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n+            getTargetFileSystem(settings, targetUris), targetUris);\n+      break;\n+    default:\n+      throw new IllegalArgumentException(linkType + \": Infeasible linkType\");\n     }\n     curInode.addLink(iPath, newLink);\n     mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void createLink(final String src, final String target,\n      final LinkType linkType, final String settings,\n      final UserGroupInformation aUgi,\n      final Configuration config)\n      throws URISyntaxException, IOException,\n      FileAlreadyExistsException, UnsupportedFileSystemException {\n    // Validate that src is valid absolute path\n    final Path srcPath \u003d new Path(src);\n    if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n      throw new IOException(\"ViewFs: Non absolute mount name in config:\" + src);\n    }\n\n    final String[] srcPaths \u003d breakIntoPathComponents(src);\n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // Ignore first initial slash, process all except last component\n    for (i \u003d 1; i \u003c srcPaths.length - 1; i++) {\n      final String iPath \u003d srcPaths[i];\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n      if (nextInode \u003d\u003d null) {\n        INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n        newDir.InodeDirFs \u003d getTargetFileSystem(newDir);\n        nextInode \u003d newDir;\n      }\n      if (nextInode instanceof INodeLink) {\n        // Error - expected a dir but got a link\n        throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n            \" already exists as link\");\n      } else {\n        assert (nextInode instanceof INodeDir);\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n\n    // Now process the last component\n    // Add the link in 2 cases: does not exist or a link exists\n    String iPath \u003d srcPaths[i];// last component\n    if (curInode.resolveInternal(iPath) !\u003d null) {\n      //  directory/link already exists\n      StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n      for (int j \u003d 1; j \u003c\u003d i; ++j) {\n        strB.append(\u0027/\u0027).append(srcPaths[j]);\n      }\n      throw new FileAlreadyExistsException(\"Path \" + strB +\n          \" already exists as dir; cannot create link here\");\n    }\n\n    final INodeLink\u003cT\u003e newLink;\n    final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n        + iPath;\n    switch (linkType) {\n    case SINGLE:\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(new URI(target)), new URI(target));\n      break;\n    case MERGE:\n    case NFLY:\n      final URI[] targetUris \u003d StringUtils.stringToURI(\n          StringUtils.getStrings(target));\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n            getTargetFileSystem(settings, targetUris), targetUris);\n      break;\n    default:\n      throw new IllegalArgumentException(linkType + \": Infeasible linkType\");\n    }\n    curInode.addLink(iPath, newLink);\n    mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
          "extendedDetails": {}
        }
      ]
    },
    "0f4afc81009129bbee89d5b6cf22c8dda612d223": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13722. Code cleanup -- ViewFileSystem and InodeTree. Contributed by Manoj Govindassamy.\n",
      "commitDate": "17/10/16 1:15 PM",
      "commitName": "0f4afc81009129bbee89d5b6cf22c8dda612d223",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/04/15 1:57 PM",
      "commitNameOld": "6d2cf9fbbd02482315a091ab07af26e40cc5134f",
      "commitAuthorOld": "Gera Shegalov",
      "daysBetweenCommits": 544.97,
      "commitsBetweenForRepo": 4050,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private void createLink(final String src, final String target,\n       final boolean isLinkMerge, final UserGroupInformation aUgi)\n       throws URISyntaxException, IOException,\n-    FileAlreadyExistsException, UnsupportedFileSystemException {\n+      FileAlreadyExistsException, UnsupportedFileSystemException {\n     // Validate that src is valid absolute path\n-    final Path srcPath \u003d new Path(src); \n+    final Path srcPath \u003d new Path(src);\n     if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n-      throw new IOException(\"ViewFs:Non absolute mount name in config:\" + src);\n+      throw new IOException(\"ViewFs: Non absolute mount name in config:\" + src);\n     }\n- \n+\n     final String[] srcPaths \u003d breakIntoPathComponents(src);\n     INodeDir\u003cT\u003e curInode \u003d root;\n     int i;\n     // Ignore first initial slash, process all except last component\n-    for (i \u003d 1; i \u003c srcPaths.length-1; i++) {\n+    for (i \u003d 1; i \u003c srcPaths.length - 1; i++) {\n       final String iPath \u003d srcPaths[i];\n       INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n       if (nextInode \u003d\u003d null) {\n         INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n         newDir.InodeDirFs \u003d getTargetFileSystem(newDir);\n         nextInode \u003d newDir;\n       }\n       if (nextInode instanceof INodeLink) {\n         // Error - expected a dir but got a link\n         throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n             \" already exists as link\");\n       } else {\n-        assert(nextInode instanceof INodeDir);\n+        assert (nextInode instanceof INodeDir);\n         curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n       }\n     }\n-    \n+\n     // Now process the last component\n     // Add the link in 2 cases: does not exist or a link exists\n     String iPath \u003d srcPaths[i];// last component\n     if (curInode.resolveInternal(iPath) !\u003d null) {\n       //  directory/link already exists\n       StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n       for (int j \u003d 1; j \u003c\u003d i; ++j) {\n         strB.append(\u0027/\u0027).append(srcPaths[j]);\n       }\n       throw new FileAlreadyExistsException(\"Path \" + strB +\n-            \" already exists as dir; cannot create link here\");\n+          \" already exists as dir; cannot create link here\");\n     }\n-    \n+\n     final INodeLink\u003cT\u003e newLink;\n     final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n         + iPath;\n     if (isLinkMerge) { // Target is list of URIs\n       String[] targetsList \u003d StringUtils.getStrings(target);\n       URI[] targetsListURI \u003d new URI[targetsList.length];\n       int k \u003d 0;\n       for (String itarget : targetsList) {\n         targetsListURI[k++] \u003d new URI(itarget);\n       }\n       newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n           getTargetFileSystem(targetsListURI), targetsListURI);\n     } else {\n       newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n           getTargetFileSystem(new URI(target)), new URI(target));\n     }\n     curInode.addLink(iPath, newLink);\n     mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void createLink(final String src, final String target,\n      final boolean isLinkMerge, final UserGroupInformation aUgi)\n      throws URISyntaxException, IOException,\n      FileAlreadyExistsException, UnsupportedFileSystemException {\n    // Validate that src is valid absolute path\n    final Path srcPath \u003d new Path(src);\n    if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n      throw new IOException(\"ViewFs: Non absolute mount name in config:\" + src);\n    }\n\n    final String[] srcPaths \u003d breakIntoPathComponents(src);\n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // Ignore first initial slash, process all except last component\n    for (i \u003d 1; i \u003c srcPaths.length - 1; i++) {\n      final String iPath \u003d srcPaths[i];\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n      if (nextInode \u003d\u003d null) {\n        INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n        newDir.InodeDirFs \u003d getTargetFileSystem(newDir);\n        nextInode \u003d newDir;\n      }\n      if (nextInode instanceof INodeLink) {\n        // Error - expected a dir but got a link\n        throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n            \" already exists as link\");\n      } else {\n        assert (nextInode instanceof INodeDir);\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n\n    // Now process the last component\n    // Add the link in 2 cases: does not exist or a link exists\n    String iPath \u003d srcPaths[i];// last component\n    if (curInode.resolveInternal(iPath) !\u003d null) {\n      //  directory/link already exists\n      StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n      for (int j \u003d 1; j \u003c\u003d i; ++j) {\n        strB.append(\u0027/\u0027).append(srcPaths[j]);\n      }\n      throw new FileAlreadyExistsException(\"Path \" + strB +\n          \" already exists as dir; cannot create link here\");\n    }\n\n    final INodeLink\u003cT\u003e newLink;\n    final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n        + iPath;\n    if (isLinkMerge) { // Target is list of URIs\n      String[] targetsList \u003d StringUtils.getStrings(target);\n      URI[] targetsListURI \u003d new URI[targetsList.length];\n      int k \u003d 0;\n      for (String itarget : targetsList) {\n        targetsListURI[k++] \u003d new URI(itarget);\n      }\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(targetsListURI), targetsListURI);\n    } else {\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(new URI(target)), new URI(target));\n    }\n    curInode.addLink(iPath, newLink);\n    mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void createLink(final String src, final String target,\n      final boolean isLinkMerge, final UserGroupInformation aUgi)\n      throws URISyntaxException, IOException,\n    FileAlreadyExistsException, UnsupportedFileSystemException {\n    // Validate that src is valid absolute path\n    final Path srcPath \u003d new Path(src); \n    if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n      throw new IOException(\"ViewFs:Non absolute mount name in config:\" + src);\n    }\n \n    final String[] srcPaths \u003d breakIntoPathComponents(src);\n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // Ignore first initial slash, process all except last component\n    for (i \u003d 1; i \u003c srcPaths.length-1; i++) {\n      final String iPath \u003d srcPaths[i];\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n      if (nextInode \u003d\u003d null) {\n        INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n        newDir.InodeDirFs \u003d getTargetFileSystem(newDir);\n        nextInode \u003d newDir;\n      }\n      if (nextInode instanceof INodeLink) {\n        // Error - expected a dir but got a link\n        throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n            \" already exists as link\");\n      } else {\n        assert(nextInode instanceof INodeDir);\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n    \n    // Now process the last component\n    // Add the link in 2 cases: does not exist or a link exists\n    String iPath \u003d srcPaths[i];// last component\n    if (curInode.resolveInternal(iPath) !\u003d null) {\n      //  directory/link already exists\n      StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n      for (int j \u003d 1; j \u003c\u003d i; ++j) {\n        strB.append(\u0027/\u0027).append(srcPaths[j]);\n      }\n      throw new FileAlreadyExistsException(\"Path \" + strB +\n            \" already exists as dir; cannot create link here\");\n    }\n    \n    final INodeLink\u003cT\u003e newLink;\n    final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n        + iPath;\n    if (isLinkMerge) { // Target is list of URIs\n      String[] targetsList \u003d StringUtils.getStrings(target);\n      URI[] targetsListURI \u003d new URI[targetsList.length];\n      int k \u003d 0;\n      for (String itarget : targetsList) {\n        targetsListURI[k++] \u003d new URI(itarget);\n      }\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(targetsListURI), targetsListURI);\n    } else {\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(new URI(target)), new URI(target));\n    }\n    curInode.addLink(iPath, newLink);\n    mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void createLink(final String src, final String target,\n      final boolean isLinkMerge, final UserGroupInformation aUgi)\n      throws URISyntaxException, IOException,\n    FileAlreadyExistsException, UnsupportedFileSystemException {\n    // Validate that src is valid absolute path\n    final Path srcPath \u003d new Path(src); \n    if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n      throw new IOException(\"ViewFs:Non absolute mount name in config:\" + src);\n    }\n \n    final String[] srcPaths \u003d breakIntoPathComponents(src);\n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // Ignore first initial slash, process all except last component\n    for (i \u003d 1; i \u003c srcPaths.length-1; i++) {\n      final String iPath \u003d srcPaths[i];\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n      if (nextInode \u003d\u003d null) {\n        INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n        newDir.InodeDirFs \u003d getTargetFileSystem(newDir);\n        nextInode \u003d newDir;\n      }\n      if (nextInode instanceof INodeLink) {\n        // Error - expected a dir but got a link\n        throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n            \" already exists as link\");\n      } else {\n        assert(nextInode instanceof INodeDir);\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n    \n    // Now process the last component\n    // Add the link in 2 cases: does not exist or a link exists\n    String iPath \u003d srcPaths[i];// last component\n    if (curInode.resolveInternal(iPath) !\u003d null) {\n      //  directory/link already exists\n      StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n      for (int j \u003d 1; j \u003c\u003d i; ++j) {\n        strB.append(\u0027/\u0027).append(srcPaths[j]);\n      }\n      throw new FileAlreadyExistsException(\"Path \" + strB +\n            \" already exists as dir; cannot create link here\");\n    }\n    \n    final INodeLink\u003cT\u003e newLink;\n    final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n        + iPath;\n    if (isLinkMerge) { // Target is list of URIs\n      String[] targetsList \u003d StringUtils.getStrings(target);\n      URI[] targetsListURI \u003d new URI[targetsList.length];\n      int k \u003d 0;\n      for (String itarget : targetsList) {\n        targetsListURI[k++] \u003d new URI(itarget);\n      }\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(targetsListURI), targetsListURI);\n    } else {\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(new URI(target)), new URI(target));\n    }\n    curInode.addLink(iPath, newLink);\n    mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void createLink(final String src, final String target,\n      final boolean isLinkMerge, final UserGroupInformation aUgi)\n      throws URISyntaxException, IOException,\n    FileAlreadyExistsException, UnsupportedFileSystemException {\n    // Validate that src is valid absolute path\n    final Path srcPath \u003d new Path(src); \n    if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n      throw new IOException(\"ViewFs:Non absolute mount name in config:\" + src);\n    }\n \n    final String[] srcPaths \u003d breakIntoPathComponents(src);\n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // Ignore first initial slash, process all except last component\n    for (i \u003d 1; i \u003c srcPaths.length-1; i++) {\n      final String iPath \u003d srcPaths[i];\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n      if (nextInode \u003d\u003d null) {\n        INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n        newDir.InodeDirFs \u003d getTargetFileSystem(newDir);\n        nextInode \u003d newDir;\n      }\n      if (nextInode instanceof INodeLink) {\n        // Error - expected a dir but got a link\n        throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n            \" already exists as link\");\n      } else {\n        assert(nextInode instanceof INodeDir);\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n    \n    // Now process the last component\n    // Add the link in 2 cases: does not exist or a link exists\n    String iPath \u003d srcPaths[i];// last component\n    if (curInode.resolveInternal(iPath) !\u003d null) {\n      //  directory/link already exists\n      StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n      for (int j \u003d 1; j \u003c\u003d i; ++j) {\n        strB.append(\u0027/\u0027).append(srcPaths[j]);\n      }\n      throw new FileAlreadyExistsException(\"Path \" + strB +\n            \" already exists as dir; cannot create link here\");\n    }\n    \n    final INodeLink\u003cT\u003e newLink;\n    final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n        + iPath;\n    if (isLinkMerge) { // Target is list of URIs\n      String[] targetsList \u003d StringUtils.getStrings(target);\n      URI[] targetsListURI \u003d new URI[targetsList.length];\n      int k \u003d 0;\n      for (String itarget : targetsList) {\n        targetsListURI[k++] \u003d new URI(itarget);\n      }\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(targetsListURI), targetsListURI);\n    } else {\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(new URI(target)), new URI(target));\n    }\n    curInode.addLink(iPath, newLink);\n    mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n  }",
      "path": "common/src/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
        "newPath": "common/src/java/org/apache/hadoop/fs/viewfs/InodeTree.java"
      }
    },
    "f1c74df922058e88791ed6971bbb96b53f6770f1": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7257 Client side mount tables (sanjay)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1100026 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/05/11 7:11 PM",
      "commitName": "f1c74df922058e88791ed6971bbb96b53f6770f1",
      "commitAuthor": "Sanjay Radia",
      "diff": "@@ -0,0 +1,64 @@\n+  private void createLink(final String src, final String target,\n+      final boolean isLinkMerge, final UserGroupInformation aUgi)\n+      throws URISyntaxException, IOException,\n+    FileAlreadyExistsException, UnsupportedFileSystemException {\n+    // Validate that src is valid absolute path\n+    final Path srcPath \u003d new Path(src); \n+    if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n+      throw new IOException(\"ViewFs:Non absolute mount name in config:\" + src);\n+    }\n+ \n+    final String[] srcPaths \u003d breakIntoPathComponents(src);\n+    INodeDir\u003cT\u003e curInode \u003d root;\n+    int i;\n+    // Ignore first initial slash, process all except last component\n+    for (i \u003d 1; i \u003c srcPaths.length-1; i++) {\n+      final String iPath \u003d srcPaths[i];\n+      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n+      if (nextInode \u003d\u003d null) {\n+        INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n+        newDir.InodeDirFs \u003d getTargetFileSystem(newDir);\n+        nextInode \u003d newDir;\n+      }\n+      if (nextInode instanceof INodeLink) {\n+        // Error - expected a dir but got a link\n+        throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n+            \" already exists as link\");\n+      } else {\n+        assert(nextInode instanceof INodeDir);\n+        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n+      }\n+    }\n+    \n+    // Now process the last component\n+    // Add the link in 2 cases: does not exist or a link exists\n+    String iPath \u003d srcPaths[i];// last component\n+    if (curInode.resolveInternal(iPath) !\u003d null) {\n+      //  directory/link already exists\n+      StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n+      for (int j \u003d 1; j \u003c\u003d i; ++j) {\n+        strB.append(\u0027/\u0027).append(srcPaths[j]);\n+      }\n+      throw new FileAlreadyExistsException(\"Path \" + strB +\n+            \" already exists as dir; cannot create link here\");\n+    }\n+    \n+    final INodeLink\u003cT\u003e newLink;\n+    final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n+        + iPath;\n+    if (isLinkMerge) { // Target is list of URIs\n+      String[] targetsList \u003d StringUtils.getStrings(target);\n+      URI[] targetsListURI \u003d new URI[targetsList.length];\n+      int k \u003d 0;\n+      for (String itarget : targetsList) {\n+        targetsListURI[k++] \u003d new URI(itarget);\n+      }\n+      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n+          getTargetFileSystem(targetsListURI), targetsListURI);\n+    } else {\n+      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n+          getTargetFileSystem(new URI(target)), new URI(target));\n+    }\n+    curInode.addLink(iPath, newLink);\n+    mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void createLink(final String src, final String target,\n      final boolean isLinkMerge, final UserGroupInformation aUgi)\n      throws URISyntaxException, IOException,\n    FileAlreadyExistsException, UnsupportedFileSystemException {\n    // Validate that src is valid absolute path\n    final Path srcPath \u003d new Path(src); \n    if (!srcPath.isAbsoluteAndSchemeAuthorityNull()) {\n      throw new IOException(\"ViewFs:Non absolute mount name in config:\" + src);\n    }\n \n    final String[] srcPaths \u003d breakIntoPathComponents(src);\n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // Ignore first initial slash, process all except last component\n    for (i \u003d 1; i \u003c srcPaths.length-1; i++) {\n      final String iPath \u003d srcPaths[i];\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(iPath);\n      if (nextInode \u003d\u003d null) {\n        INodeDir\u003cT\u003e newDir \u003d curInode.addDir(iPath, aUgi);\n        newDir.InodeDirFs \u003d getTargetFileSystem(newDir);\n        nextInode \u003d newDir;\n      }\n      if (nextInode instanceof INodeLink) {\n        // Error - expected a dir but got a link\n        throw new FileAlreadyExistsException(\"Path \" + nextInode.fullPath +\n            \" already exists as link\");\n      } else {\n        assert(nextInode instanceof INodeDir);\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n    \n    // Now process the last component\n    // Add the link in 2 cases: does not exist or a link exists\n    String iPath \u003d srcPaths[i];// last component\n    if (curInode.resolveInternal(iPath) !\u003d null) {\n      //  directory/link already exists\n      StringBuilder strB \u003d new StringBuilder(srcPaths[0]);\n      for (int j \u003d 1; j \u003c\u003d i; ++j) {\n        strB.append(\u0027/\u0027).append(srcPaths[j]);\n      }\n      throw new FileAlreadyExistsException(\"Path \" + strB +\n            \" already exists as dir; cannot create link here\");\n    }\n    \n    final INodeLink\u003cT\u003e newLink;\n    final String fullPath \u003d curInode.fullPath + (curInode \u003d\u003d root ? \"\" : \"/\")\n        + iPath;\n    if (isLinkMerge) { // Target is list of URIs\n      String[] targetsList \u003d StringUtils.getStrings(target);\n      URI[] targetsListURI \u003d new URI[targetsList.length];\n      int k \u003d 0;\n      for (String itarget : targetsList) {\n        targetsListURI[k++] \u003d new URI(itarget);\n      }\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(targetsListURI), targetsListURI);\n    } else {\n      newLink \u003d new INodeLink\u003cT\u003e(fullPath, aUgi,\n          getTargetFileSystem(new URI(target)), new URI(target));\n    }\n    curInode.addLink(iPath, newLink);\n    mountPoints.add(new MountPoint\u003cT\u003e(src, newLink));\n  }",
      "path": "src/java/org/apache/hadoop/fs/viewfs/InodeTree.java"
    }
  }
}