{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Client.java",
  "functionName": "monitorInfraApplication",
  "functionId": "monitorInfraApplication",
  "sourceFilePath": "hadoop-tools/hadoop-dynamometer/hadoop-dynamometer-infra/src/main/java/org/apache/hadoop/tools/dynamometer/Client.java",
  "functionStartLine": 889,
  "functionEndLine": 1016,
  "numCommitsSeen": 7,
  "timeTaken": 1038,
  "changeHistory": [
    "9520b2ad790bd8527033a03e7ee50da71a85df1d",
    "ab0b180ddb5d0775a2452d5eeb7badd252aadb91"
  ],
  "changeHistoryShort": {
    "9520b2ad790bd8527033a03e7ee50da71a85df1d": "Ybodychange",
    "ab0b180ddb5d0775a2452d5eeb7badd252aadb91": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9520b2ad790bd8527033a03e7ee50da71a85df1d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10083. Provide utility to ask whether an application is in final status. Contributed by Adam Antal\n",
      "commitDate": "22/01/20 7:25 AM",
      "commitName": "9520b2ad790bd8527033a03e7ee50da71a85df1d",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "01/11/19 9:32 AM",
      "commitNameOld": "477505ccfc480f2605a7b65de95ea6f6ff5ce090",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 81.95,
      "commitsBetweenForRepo": 300,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,128 @@\n   private boolean monitorInfraApplication() throws YarnException, IOException {\n \n     boolean loggedApplicationInfo \u003d false;\n     boolean success \u003d false;\n \n     Thread namenodeMonitoringThread \u003d new Thread(() -\u003e {\n-      Supplier\u003cBoolean\u003e exitCritera \u003d () -\u003e isCompleted(infraAppState);\n+      Supplier\u003cBoolean\u003e exitCritera \u003d () -\u003e\n+          Apps.isApplicationFinalState(infraAppState);\n       Optional\u003cProperties\u003e namenodeProperties \u003d Optional.empty();\n       while (!exitCritera.get()) {\n         try {\n           if (!namenodeProperties.isPresent()) {\n             namenodeProperties \u003d DynoInfraUtils\n                 .waitForAndGetNameNodeProperties(exitCritera, getConf(),\n                     getNameNodeInfoPath(), LOG);\n             if (namenodeProperties.isPresent()) {\n               Properties props \u003d namenodeProperties.get();\n               LOG.info(\"NameNode can be reached via HDFS at: {}\",\n                   DynoInfraUtils.getNameNodeHdfsUri(props));\n               LOG.info(\"NameNode web UI available at: {}\",\n                   DynoInfraUtils.getNameNodeWebUri(props));\n               LOG.info(\"NameNode can be tracked at: {}\",\n                   DynoInfraUtils.getNameNodeTrackingUri(props));\n             } else {\n               // Only happens if we should be shutting down\n               break;\n             }\n           }\n           DynoInfraUtils.waitForNameNodeStartup(namenodeProperties.get(),\n               exitCritera, LOG);\n           DynoInfraUtils.waitForNameNodeReadiness(namenodeProperties.get(),\n               numTotalDataNodes, false, exitCritera, getConf(), LOG);\n           break;\n         } catch (IOException ioe) {\n           LOG.error(\n               \"Unexpected exception while waiting for NameNode readiness\",\n               ioe);\n         } catch (InterruptedException ie) {\n           return;\n         }\n       }\n-      if (!isCompleted(infraAppState) \u0026\u0026 launchWorkloadJob) {\n+      if (!Apps.isApplicationFinalState(infraAppState) \u0026\u0026 launchWorkloadJob) {\n         launchAndMonitorWorkloadDriver(namenodeProperties.get());\n       }\n     });\n     if (launchNameNode) {\n       namenodeMonitoringThread.start();\n     }\n \n     while (true) {\n \n       // Check app status every 1 second.\n       try {\n         Thread.sleep(1000);\n       } catch (InterruptedException e) {\n         LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n       }\n \n       // Get application report for the appId we are interested in\n       ApplicationReport report \u003d yarnClient.getApplicationReport(infraAppId);\n \n       if (report.getTrackingUrl() !\u003d null \u0026\u0026 !loggedApplicationInfo) {\n         loggedApplicationInfo \u003d true;\n         LOG.info(\"Track the application at: \" + report.getTrackingUrl());\n         LOG.info(\"Kill the application using: yarn application -kill \"\n             + report.getApplicationId());\n       }\n \n       LOG.debug(\"Got application report from ASM for: appId\u003d{}, \"\n           + \"clientToAMToken\u003d{}, appDiagnostics\u003d{}, appMasterHost\u003d{}, \"\n           + \"appQueue\u003d{}, appMasterRpcPort\u003d{}, appStartTime\u003d{}, \"\n           + \"yarnAppState\u003d{}, distributedFinalState\u003d{}, appTrackingUrl\u003d{}, \"\n           + \"appUser\u003d{}\",\n           infraAppId.getId(), report.getClientToAMToken(),\n           report.getDiagnostics(), report.getHost(), report.getQueue(),\n           report.getRpcPort(), report.getStartTime(),\n           report.getYarnApplicationState(), report.getFinalApplicationStatus(),\n           report.getTrackingUrl(), report.getUser());\n \n       infraAppState \u003d report.getYarnApplicationState();\n       if (infraAppState \u003d\u003d YarnApplicationState.KILLED) {\n         if (!launchWorkloadJob) {\n           success \u003d true;\n         } else if (workloadJob \u003d\u003d null) {\n           LOG.error(\"Infra app was killed before workload job was launched.\");\n         } else if (!workloadJob.isComplete()) {\n           LOG.error(\"Infra app was killed before workload job completed.\");\n         } else if (workloadJob.isSuccessful()) {\n           success \u003d true;\n         }\n         LOG.info(\"Infra app was killed; exiting from client.\");\n         break;\n       } else if (infraAppState \u003d\u003d YarnApplicationState.FINISHED\n           || infraAppState \u003d\u003d YarnApplicationState.FAILED) {\n         LOG.info(\"Infra app exited unexpectedly. YarnState\u003d\"\n             + infraAppState.toString() + \". Exiting from client.\");\n         break;\n       }\n \n       if ((clientTimeout !\u003d -1)\n           \u0026\u0026 (System.currentTimeMillis() \u003e (clientStartTime + clientTimeout))) {\n         LOG.info(\"Reached client specified timeout of {} ms for application. \"\n             + \"Killing application\", clientTimeout);\n         attemptCleanup();\n         break;\n       }\n \n       if (isCompleted(workloadAppState)) {\n         LOG.info(\"Killing infrastructure app\");\n         try {\n           forceKillApplication(infraAppId);\n         } catch (YarnException | IOException e) {\n           LOG.error(\"Exception encountered while killing infra app\", e);\n         }\n       }\n     }\n     if (launchNameNode) {\n       try {\n         namenodeMonitoringThread.interrupt();\n         namenodeMonitoringThread.join();\n       } catch (InterruptedException ie) {\n         LOG.warn(\"Interrupted while joining workload job thread; \"\n             + \"continuing to cleanup.\");\n       }\n     }\n     attemptCleanup();\n     return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean monitorInfraApplication() throws YarnException, IOException {\n\n    boolean loggedApplicationInfo \u003d false;\n    boolean success \u003d false;\n\n    Thread namenodeMonitoringThread \u003d new Thread(() -\u003e {\n      Supplier\u003cBoolean\u003e exitCritera \u003d () -\u003e\n          Apps.isApplicationFinalState(infraAppState);\n      Optional\u003cProperties\u003e namenodeProperties \u003d Optional.empty();\n      while (!exitCritera.get()) {\n        try {\n          if (!namenodeProperties.isPresent()) {\n            namenodeProperties \u003d DynoInfraUtils\n                .waitForAndGetNameNodeProperties(exitCritera, getConf(),\n                    getNameNodeInfoPath(), LOG);\n            if (namenodeProperties.isPresent()) {\n              Properties props \u003d namenodeProperties.get();\n              LOG.info(\"NameNode can be reached via HDFS at: {}\",\n                  DynoInfraUtils.getNameNodeHdfsUri(props));\n              LOG.info(\"NameNode web UI available at: {}\",\n                  DynoInfraUtils.getNameNodeWebUri(props));\n              LOG.info(\"NameNode can be tracked at: {}\",\n                  DynoInfraUtils.getNameNodeTrackingUri(props));\n            } else {\n              // Only happens if we should be shutting down\n              break;\n            }\n          }\n          DynoInfraUtils.waitForNameNodeStartup(namenodeProperties.get(),\n              exitCritera, LOG);\n          DynoInfraUtils.waitForNameNodeReadiness(namenodeProperties.get(),\n              numTotalDataNodes, false, exitCritera, getConf(), LOG);\n          break;\n        } catch (IOException ioe) {\n          LOG.error(\n              \"Unexpected exception while waiting for NameNode readiness\",\n              ioe);\n        } catch (InterruptedException ie) {\n          return;\n        }\n      }\n      if (!Apps.isApplicationFinalState(infraAppState) \u0026\u0026 launchWorkloadJob) {\n        launchAndMonitorWorkloadDriver(namenodeProperties.get());\n      }\n    });\n    if (launchNameNode) {\n      namenodeMonitoringThread.start();\n    }\n\n    while (true) {\n\n      // Check app status every 1 second.\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n      }\n\n      // Get application report for the appId we are interested in\n      ApplicationReport report \u003d yarnClient.getApplicationReport(infraAppId);\n\n      if (report.getTrackingUrl() !\u003d null \u0026\u0026 !loggedApplicationInfo) {\n        loggedApplicationInfo \u003d true;\n        LOG.info(\"Track the application at: \" + report.getTrackingUrl());\n        LOG.info(\"Kill the application using: yarn application -kill \"\n            + report.getApplicationId());\n      }\n\n      LOG.debug(\"Got application report from ASM for: appId\u003d{}, \"\n          + \"clientToAMToken\u003d{}, appDiagnostics\u003d{}, appMasterHost\u003d{}, \"\n          + \"appQueue\u003d{}, appMasterRpcPort\u003d{}, appStartTime\u003d{}, \"\n          + \"yarnAppState\u003d{}, distributedFinalState\u003d{}, appTrackingUrl\u003d{}, \"\n          + \"appUser\u003d{}\",\n          infraAppId.getId(), report.getClientToAMToken(),\n          report.getDiagnostics(), report.getHost(), report.getQueue(),\n          report.getRpcPort(), report.getStartTime(),\n          report.getYarnApplicationState(), report.getFinalApplicationStatus(),\n          report.getTrackingUrl(), report.getUser());\n\n      infraAppState \u003d report.getYarnApplicationState();\n      if (infraAppState \u003d\u003d YarnApplicationState.KILLED) {\n        if (!launchWorkloadJob) {\n          success \u003d true;\n        } else if (workloadJob \u003d\u003d null) {\n          LOG.error(\"Infra app was killed before workload job was launched.\");\n        } else if (!workloadJob.isComplete()) {\n          LOG.error(\"Infra app was killed before workload job completed.\");\n        } else if (workloadJob.isSuccessful()) {\n          success \u003d true;\n        }\n        LOG.info(\"Infra app was killed; exiting from client.\");\n        break;\n      } else if (infraAppState \u003d\u003d YarnApplicationState.FINISHED\n          || infraAppState \u003d\u003d YarnApplicationState.FAILED) {\n        LOG.info(\"Infra app exited unexpectedly. YarnState\u003d\"\n            + infraAppState.toString() + \". Exiting from client.\");\n        break;\n      }\n\n      if ((clientTimeout !\u003d -1)\n          \u0026\u0026 (System.currentTimeMillis() \u003e (clientStartTime + clientTimeout))) {\n        LOG.info(\"Reached client specified timeout of {} ms for application. \"\n            + \"Killing application\", clientTimeout);\n        attemptCleanup();\n        break;\n      }\n\n      if (isCompleted(workloadAppState)) {\n        LOG.info(\"Killing infrastructure app\");\n        try {\n          forceKillApplication(infraAppId);\n        } catch (YarnException | IOException e) {\n          LOG.error(\"Exception encountered while killing infra app\", e);\n        }\n      }\n    }\n    if (launchNameNode) {\n      try {\n        namenodeMonitoringThread.interrupt();\n        namenodeMonitoringThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while joining workload job thread; \"\n            + \"continuing to cleanup.\");\n      }\n    }\n    attemptCleanup();\n    return success;\n  }",
      "path": "hadoop-tools/hadoop-dynamometer/hadoop-dynamometer-infra/src/main/java/org/apache/hadoop/tools/dynamometer/Client.java",
      "extendedDetails": {}
    },
    "ab0b180ddb5d0775a2452d5eeb7badd252aadb91": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-12345 Add Dynamometer to hadoop-tools, a tool for scale testing the HDFS NameNode with real metadata and workloads. Contributed by Erik Krogen.\n",
      "commitDate": "25/06/19 8:07 AM",
      "commitName": "ab0b180ddb5d0775a2452d5eeb7badd252aadb91",
      "commitAuthor": "Erik Krogen",
      "diff": "@@ -0,0 +1,127 @@\n+  private boolean monitorInfraApplication() throws YarnException, IOException {\n+\n+    boolean loggedApplicationInfo \u003d false;\n+    boolean success \u003d false;\n+\n+    Thread namenodeMonitoringThread \u003d new Thread(() -\u003e {\n+      Supplier\u003cBoolean\u003e exitCritera \u003d () -\u003e isCompleted(infraAppState);\n+      Optional\u003cProperties\u003e namenodeProperties \u003d Optional.empty();\n+      while (!exitCritera.get()) {\n+        try {\n+          if (!namenodeProperties.isPresent()) {\n+            namenodeProperties \u003d DynoInfraUtils\n+                .waitForAndGetNameNodeProperties(exitCritera, getConf(),\n+                    getNameNodeInfoPath(), LOG);\n+            if (namenodeProperties.isPresent()) {\n+              Properties props \u003d namenodeProperties.get();\n+              LOG.info(\"NameNode can be reached via HDFS at: {}\",\n+                  DynoInfraUtils.getNameNodeHdfsUri(props));\n+              LOG.info(\"NameNode web UI available at: {}\",\n+                  DynoInfraUtils.getNameNodeWebUri(props));\n+              LOG.info(\"NameNode can be tracked at: {}\",\n+                  DynoInfraUtils.getNameNodeTrackingUri(props));\n+            } else {\n+              // Only happens if we should be shutting down\n+              break;\n+            }\n+          }\n+          DynoInfraUtils.waitForNameNodeStartup(namenodeProperties.get(),\n+              exitCritera, LOG);\n+          DynoInfraUtils.waitForNameNodeReadiness(namenodeProperties.get(),\n+              numTotalDataNodes, false, exitCritera, getConf(), LOG);\n+          break;\n+        } catch (IOException ioe) {\n+          LOG.error(\n+              \"Unexpected exception while waiting for NameNode readiness\",\n+              ioe);\n+        } catch (InterruptedException ie) {\n+          return;\n+        }\n+      }\n+      if (!isCompleted(infraAppState) \u0026\u0026 launchWorkloadJob) {\n+        launchAndMonitorWorkloadDriver(namenodeProperties.get());\n+      }\n+    });\n+    if (launchNameNode) {\n+      namenodeMonitoringThread.start();\n+    }\n+\n+    while (true) {\n+\n+      // Check app status every 1 second.\n+      try {\n+        Thread.sleep(1000);\n+      } catch (InterruptedException e) {\n+        LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n+      }\n+\n+      // Get application report for the appId we are interested in\n+      ApplicationReport report \u003d yarnClient.getApplicationReport(infraAppId);\n+\n+      if (report.getTrackingUrl() !\u003d null \u0026\u0026 !loggedApplicationInfo) {\n+        loggedApplicationInfo \u003d true;\n+        LOG.info(\"Track the application at: \" + report.getTrackingUrl());\n+        LOG.info(\"Kill the application using: yarn application -kill \"\n+            + report.getApplicationId());\n+      }\n+\n+      LOG.debug(\"Got application report from ASM for: appId\u003d{}, \"\n+          + \"clientToAMToken\u003d{}, appDiagnostics\u003d{}, appMasterHost\u003d{}, \"\n+          + \"appQueue\u003d{}, appMasterRpcPort\u003d{}, appStartTime\u003d{}, \"\n+          + \"yarnAppState\u003d{}, distributedFinalState\u003d{}, appTrackingUrl\u003d{}, \"\n+          + \"appUser\u003d{}\",\n+          infraAppId.getId(), report.getClientToAMToken(),\n+          report.getDiagnostics(), report.getHost(), report.getQueue(),\n+          report.getRpcPort(), report.getStartTime(),\n+          report.getYarnApplicationState(), report.getFinalApplicationStatus(),\n+          report.getTrackingUrl(), report.getUser());\n+\n+      infraAppState \u003d report.getYarnApplicationState();\n+      if (infraAppState \u003d\u003d YarnApplicationState.KILLED) {\n+        if (!launchWorkloadJob) {\n+          success \u003d true;\n+        } else if (workloadJob \u003d\u003d null) {\n+          LOG.error(\"Infra app was killed before workload job was launched.\");\n+        } else if (!workloadJob.isComplete()) {\n+          LOG.error(\"Infra app was killed before workload job completed.\");\n+        } else if (workloadJob.isSuccessful()) {\n+          success \u003d true;\n+        }\n+        LOG.info(\"Infra app was killed; exiting from client.\");\n+        break;\n+      } else if (infraAppState \u003d\u003d YarnApplicationState.FINISHED\n+          || infraAppState \u003d\u003d YarnApplicationState.FAILED) {\n+        LOG.info(\"Infra app exited unexpectedly. YarnState\u003d\"\n+            + infraAppState.toString() + \". Exiting from client.\");\n+        break;\n+      }\n+\n+      if ((clientTimeout !\u003d -1)\n+          \u0026\u0026 (System.currentTimeMillis() \u003e (clientStartTime + clientTimeout))) {\n+        LOG.info(\"Reached client specified timeout of {} ms for application. \"\n+            + \"Killing application\", clientTimeout);\n+        attemptCleanup();\n+        break;\n+      }\n+\n+      if (isCompleted(workloadAppState)) {\n+        LOG.info(\"Killing infrastructure app\");\n+        try {\n+          forceKillApplication(infraAppId);\n+        } catch (YarnException | IOException e) {\n+          LOG.error(\"Exception encountered while killing infra app\", e);\n+        }\n+      }\n+    }\n+    if (launchNameNode) {\n+      try {\n+        namenodeMonitoringThread.interrupt();\n+        namenodeMonitoringThread.join();\n+      } catch (InterruptedException ie) {\n+        LOG.warn(\"Interrupted while joining workload job thread; \"\n+            + \"continuing to cleanup.\");\n+      }\n+    }\n+    attemptCleanup();\n+    return success;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean monitorInfraApplication() throws YarnException, IOException {\n\n    boolean loggedApplicationInfo \u003d false;\n    boolean success \u003d false;\n\n    Thread namenodeMonitoringThread \u003d new Thread(() -\u003e {\n      Supplier\u003cBoolean\u003e exitCritera \u003d () -\u003e isCompleted(infraAppState);\n      Optional\u003cProperties\u003e namenodeProperties \u003d Optional.empty();\n      while (!exitCritera.get()) {\n        try {\n          if (!namenodeProperties.isPresent()) {\n            namenodeProperties \u003d DynoInfraUtils\n                .waitForAndGetNameNodeProperties(exitCritera, getConf(),\n                    getNameNodeInfoPath(), LOG);\n            if (namenodeProperties.isPresent()) {\n              Properties props \u003d namenodeProperties.get();\n              LOG.info(\"NameNode can be reached via HDFS at: {}\",\n                  DynoInfraUtils.getNameNodeHdfsUri(props));\n              LOG.info(\"NameNode web UI available at: {}\",\n                  DynoInfraUtils.getNameNodeWebUri(props));\n              LOG.info(\"NameNode can be tracked at: {}\",\n                  DynoInfraUtils.getNameNodeTrackingUri(props));\n            } else {\n              // Only happens if we should be shutting down\n              break;\n            }\n          }\n          DynoInfraUtils.waitForNameNodeStartup(namenodeProperties.get(),\n              exitCritera, LOG);\n          DynoInfraUtils.waitForNameNodeReadiness(namenodeProperties.get(),\n              numTotalDataNodes, false, exitCritera, getConf(), LOG);\n          break;\n        } catch (IOException ioe) {\n          LOG.error(\n              \"Unexpected exception while waiting for NameNode readiness\",\n              ioe);\n        } catch (InterruptedException ie) {\n          return;\n        }\n      }\n      if (!isCompleted(infraAppState) \u0026\u0026 launchWorkloadJob) {\n        launchAndMonitorWorkloadDriver(namenodeProperties.get());\n      }\n    });\n    if (launchNameNode) {\n      namenodeMonitoringThread.start();\n    }\n\n    while (true) {\n\n      // Check app status every 1 second.\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n      }\n\n      // Get application report for the appId we are interested in\n      ApplicationReport report \u003d yarnClient.getApplicationReport(infraAppId);\n\n      if (report.getTrackingUrl() !\u003d null \u0026\u0026 !loggedApplicationInfo) {\n        loggedApplicationInfo \u003d true;\n        LOG.info(\"Track the application at: \" + report.getTrackingUrl());\n        LOG.info(\"Kill the application using: yarn application -kill \"\n            + report.getApplicationId());\n      }\n\n      LOG.debug(\"Got application report from ASM for: appId\u003d{}, \"\n          + \"clientToAMToken\u003d{}, appDiagnostics\u003d{}, appMasterHost\u003d{}, \"\n          + \"appQueue\u003d{}, appMasterRpcPort\u003d{}, appStartTime\u003d{}, \"\n          + \"yarnAppState\u003d{}, distributedFinalState\u003d{}, appTrackingUrl\u003d{}, \"\n          + \"appUser\u003d{}\",\n          infraAppId.getId(), report.getClientToAMToken(),\n          report.getDiagnostics(), report.getHost(), report.getQueue(),\n          report.getRpcPort(), report.getStartTime(),\n          report.getYarnApplicationState(), report.getFinalApplicationStatus(),\n          report.getTrackingUrl(), report.getUser());\n\n      infraAppState \u003d report.getYarnApplicationState();\n      if (infraAppState \u003d\u003d YarnApplicationState.KILLED) {\n        if (!launchWorkloadJob) {\n          success \u003d true;\n        } else if (workloadJob \u003d\u003d null) {\n          LOG.error(\"Infra app was killed before workload job was launched.\");\n        } else if (!workloadJob.isComplete()) {\n          LOG.error(\"Infra app was killed before workload job completed.\");\n        } else if (workloadJob.isSuccessful()) {\n          success \u003d true;\n        }\n        LOG.info(\"Infra app was killed; exiting from client.\");\n        break;\n      } else if (infraAppState \u003d\u003d YarnApplicationState.FINISHED\n          || infraAppState \u003d\u003d YarnApplicationState.FAILED) {\n        LOG.info(\"Infra app exited unexpectedly. YarnState\u003d\"\n            + infraAppState.toString() + \". Exiting from client.\");\n        break;\n      }\n\n      if ((clientTimeout !\u003d -1)\n          \u0026\u0026 (System.currentTimeMillis() \u003e (clientStartTime + clientTimeout))) {\n        LOG.info(\"Reached client specified timeout of {} ms for application. \"\n            + \"Killing application\", clientTimeout);\n        attemptCleanup();\n        break;\n      }\n\n      if (isCompleted(workloadAppState)) {\n        LOG.info(\"Killing infrastructure app\");\n        try {\n          forceKillApplication(infraAppId);\n        } catch (YarnException | IOException e) {\n          LOG.error(\"Exception encountered while killing infra app\", e);\n        }\n      }\n    }\n    if (launchNameNode) {\n      try {\n        namenodeMonitoringThread.interrupt();\n        namenodeMonitoringThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while joining workload job thread; \"\n            + \"continuing to cleanup.\");\n      }\n    }\n    attemptCleanup();\n    return success;\n  }",
      "path": "hadoop-tools/hadoop-dynamometer/hadoop-dynamometer-infra/src/main/java/org/apache/hadoop/tools/dynamometer/Client.java"
    }
  }
}