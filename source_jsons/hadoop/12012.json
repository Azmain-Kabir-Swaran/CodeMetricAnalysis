{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FsDatasetImpl.java",
  "functionName": "cacheBlock",
  "functionId": "cacheBlock___bpid-String__blockId-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
  "functionStartLine": 2257,
  "functionEndLine": 2308,
  "numCommitsSeen": 197,
  "timeTaken": 7292,
  "changeHistory": [
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
    "86c9862bec0248d671e657aa56094a2919b8ac14",
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
    "a317bd7b02c37bd57743bfad59593ec12f53f4ed",
    "9673baa7e8b43fa6300080f72ebce0189ea775e5",
    "97199baea1c41a66bd2a88bda31742ef6ddcb5dc"
  ],
  "changeHistoryShort": {
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8": "Ybodychange",
    "86c9862bec0248d671e657aa56094a2919b8ac14": "Ybodychange",
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c": "Ybodychange",
    "a317bd7b02c37bd57743bfad59593ec12f53f4ed": "Ybodychange",
    "9673baa7e8b43fa6300080f72ebce0189ea775e5": "Ybodychange",
    "97199baea1c41a66bd2a88bda31742ef6ddcb5dc": "Ybodychange"
  },
  "changeHistoryDetails": {
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15150. Introduce read write lock to Datanode. Contributed Stephen O\u0027Donnell.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "11/02/20 8:00 AM",
      "commitName": "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
      "commitAuthor": "Stephen O\u0027Donnell",
      "commitDateOld": "28/01/20 10:10 AM",
      "commitNameOld": "1839c467f60cbb8592d446694ec3d7710cda5142",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 13.91,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   private void cacheBlock(String bpid, long blockId) {\n     FsVolumeImpl volume;\n     String blockFileName;\n     long length, genstamp;\n     Executor volumeExecutor;\n \n-    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n+    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n       ReplicaInfo info \u003d volumeMap.get(bpid, blockId);\n       boolean success \u003d false;\n       try {\n         if (info \u003d\u003d null) {\n           LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n               bpid + \": ReplicaInfo not found.\");\n           return;\n         }\n         if (info.getState() !\u003d ReplicaState.FINALIZED) {\n           LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n               bpid + \": replica is not finalized; it is in state \" +\n               info.getState());\n           return;\n         }\n         try {\n           volume \u003d (FsVolumeImpl)info.getVolume();\n           if (volume \u003d\u003d null) {\n             LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n                 bpid + \": volume not found.\");\n             return;\n           }\n         } catch (ClassCastException e) {\n           LOG.warn(\"Failed to cache block with id \" + blockId +\n               \": volume was not an instance of FsVolumeImpl.\");\n           return;\n         }\n         if (volume.isTransientStorage()) {\n           LOG.warn(\"Caching not supported on block with id \" + blockId +\n               \" since the volume is backed by RAM.\");\n           return;\n         }\n         success \u003d true;\n       } finally {\n         if (!success) {\n           cacheManager.numBlocksFailedToCache.incrementAndGet();\n         }\n       }\n       blockFileName \u003d info.getBlockURI().toString();\n       length \u003d info.getVisibleLength();\n       genstamp \u003d info.getGenerationStamp();\n       volumeExecutor \u003d volume.getCacheExecutor();\n     }\n     cacheManager.cacheBlock(blockId, bpid, \n         blockFileName, length, genstamp, volumeExecutor);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void cacheBlock(String bpid, long blockId) {\n    FsVolumeImpl volume;\n    String blockFileName;\n    long length, genstamp;\n    Executor volumeExecutor;\n\n    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n      ReplicaInfo info \u003d volumeMap.get(bpid, blockId);\n      boolean success \u003d false;\n      try {\n        if (info \u003d\u003d null) {\n          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n              bpid + \": ReplicaInfo not found.\");\n          return;\n        }\n        if (info.getState() !\u003d ReplicaState.FINALIZED) {\n          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n              bpid + \": replica is not finalized; it is in state \" +\n              info.getState());\n          return;\n        }\n        try {\n          volume \u003d (FsVolumeImpl)info.getVolume();\n          if (volume \u003d\u003d null) {\n            LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n                bpid + \": volume not found.\");\n            return;\n          }\n        } catch (ClassCastException e) {\n          LOG.warn(\"Failed to cache block with id \" + blockId +\n              \": volume was not an instance of FsVolumeImpl.\");\n          return;\n        }\n        if (volume.isTransientStorage()) {\n          LOG.warn(\"Caching not supported on block with id \" + blockId +\n              \" since the volume is backed by RAM.\");\n          return;\n        }\n        success \u003d true;\n      } finally {\n        if (!success) {\n          cacheManager.numBlocksFailedToCache.incrementAndGet();\n        }\n      }\n      blockFileName \u003d info.getBlockURI().toString();\n      length \u003d info.getVisibleLength();\n      genstamp \u003d info.getGenerationStamp();\n      volumeExecutor \u003d volume.getCacheExecutor();\n    }\n    cacheManager.cacheBlock(blockId, bpid, \n        blockFileName, length, genstamp, volumeExecutor);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "86c9862bec0248d671e657aa56094a2919b8ac14": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10636. Modify ReplicaInfo to remove the assumption that replica metadata and data are stored in java.io.File. (Virajith Jalaparti via lei)\n",
      "commitDate": "13/09/16 12:54 PM",
      "commitName": "86c9862bec0248d671e657aa56094a2919b8ac14",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "10/09/16 6:22 PM",
      "commitNameOld": "a99bf26a0899bcc4307c3a242c8414eaef555aa7",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 2.77,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   private void cacheBlock(String bpid, long blockId) {\n     FsVolumeImpl volume;\n     String blockFileName;\n     long length, genstamp;\n     Executor volumeExecutor;\n \n     try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       ReplicaInfo info \u003d volumeMap.get(bpid, blockId);\n       boolean success \u003d false;\n       try {\n         if (info \u003d\u003d null) {\n           LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n               bpid + \": ReplicaInfo not found.\");\n           return;\n         }\n         if (info.getState() !\u003d ReplicaState.FINALIZED) {\n           LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n               bpid + \": replica is not finalized; it is in state \" +\n               info.getState());\n           return;\n         }\n         try {\n           volume \u003d (FsVolumeImpl)info.getVolume();\n           if (volume \u003d\u003d null) {\n             LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n                 bpid + \": volume not found.\");\n             return;\n           }\n         } catch (ClassCastException e) {\n           LOG.warn(\"Failed to cache block with id \" + blockId +\n               \": volume was not an instance of FsVolumeImpl.\");\n           return;\n         }\n         if (volume.isTransientStorage()) {\n           LOG.warn(\"Caching not supported on block with id \" + blockId +\n               \" since the volume is backed by RAM.\");\n           return;\n         }\n         success \u003d true;\n       } finally {\n         if (!success) {\n           cacheManager.numBlocksFailedToCache.incrementAndGet();\n         }\n       }\n-      blockFileName \u003d info.getBlockFile().getAbsolutePath();\n+      blockFileName \u003d info.getBlockURI().toString();\n       length \u003d info.getVisibleLength();\n       genstamp \u003d info.getGenerationStamp();\n       volumeExecutor \u003d volume.getCacheExecutor();\n     }\n     cacheManager.cacheBlock(blockId, bpid, \n         blockFileName, length, genstamp, volumeExecutor);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void cacheBlock(String bpid, long blockId) {\n    FsVolumeImpl volume;\n    String blockFileName;\n    long length, genstamp;\n    Executor volumeExecutor;\n\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      ReplicaInfo info \u003d volumeMap.get(bpid, blockId);\n      boolean success \u003d false;\n      try {\n        if (info \u003d\u003d null) {\n          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n              bpid + \": ReplicaInfo not found.\");\n          return;\n        }\n        if (info.getState() !\u003d ReplicaState.FINALIZED) {\n          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n              bpid + \": replica is not finalized; it is in state \" +\n              info.getState());\n          return;\n        }\n        try {\n          volume \u003d (FsVolumeImpl)info.getVolume();\n          if (volume \u003d\u003d null) {\n            LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n                bpid + \": volume not found.\");\n            return;\n          }\n        } catch (ClassCastException e) {\n          LOG.warn(\"Failed to cache block with id \" + blockId +\n              \": volume was not an instance of FsVolumeImpl.\");\n          return;\n        }\n        if (volume.isTransientStorage()) {\n          LOG.warn(\"Caching not supported on block with id \" + blockId +\n              \" since the volume is backed by RAM.\");\n          return;\n        }\n        success \u003d true;\n      } finally {\n        if (!success) {\n          cacheManager.numBlocksFailedToCache.incrementAndGet();\n        }\n      }\n      blockFileName \u003d info.getBlockURI().toString();\n      length \u003d info.getVisibleLength();\n      genstamp \u003d info.getGenerationStamp();\n      volumeExecutor \u003d volume.getCacheExecutor();\n    }\n    cacheManager.cacheBlock(blockId, bpid, \n        blockFileName, length, genstamp, volumeExecutor);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10682. Replace FsDatasetImpl object lock with a separate lock object. (Chen Liang)\n",
      "commitDate": "08/08/16 12:02 PM",
      "commitName": "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "08/07/16 7:40 PM",
      "commitNameOld": "da6f1b88dd47e22b24d44f6fc8bbee73e85746f7",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 30.68,
      "commitsBetweenForRepo": 320,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   private void cacheBlock(String bpid, long blockId) {\n     FsVolumeImpl volume;\n     String blockFileName;\n     long length, genstamp;\n     Executor volumeExecutor;\n \n-    synchronized (this) {\n+    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       ReplicaInfo info \u003d volumeMap.get(bpid, blockId);\n       boolean success \u003d false;\n       try {\n         if (info \u003d\u003d null) {\n           LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n               bpid + \": ReplicaInfo not found.\");\n           return;\n         }\n         if (info.getState() !\u003d ReplicaState.FINALIZED) {\n           LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n               bpid + \": replica is not finalized; it is in state \" +\n               info.getState());\n           return;\n         }\n         try {\n           volume \u003d (FsVolumeImpl)info.getVolume();\n           if (volume \u003d\u003d null) {\n             LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n                 bpid + \": volume not found.\");\n             return;\n           }\n         } catch (ClassCastException e) {\n           LOG.warn(\"Failed to cache block with id \" + blockId +\n               \": volume was not an instance of FsVolumeImpl.\");\n           return;\n         }\n         if (volume.isTransientStorage()) {\n           LOG.warn(\"Caching not supported on block with id \" + blockId +\n               \" since the volume is backed by RAM.\");\n           return;\n         }\n         success \u003d true;\n       } finally {\n         if (!success) {\n           cacheManager.numBlocksFailedToCache.incrementAndGet();\n         }\n       }\n       blockFileName \u003d info.getBlockFile().getAbsolutePath();\n       length \u003d info.getVisibleLength();\n       genstamp \u003d info.getGenerationStamp();\n       volumeExecutor \u003d volume.getCacheExecutor();\n     }\n     cacheManager.cacheBlock(blockId, bpid, \n         blockFileName, length, genstamp, volumeExecutor);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void cacheBlock(String bpid, long blockId) {\n    FsVolumeImpl volume;\n    String blockFileName;\n    long length, genstamp;\n    Executor volumeExecutor;\n\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      ReplicaInfo info \u003d volumeMap.get(bpid, blockId);\n      boolean success \u003d false;\n      try {\n        if (info \u003d\u003d null) {\n          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n              bpid + \": ReplicaInfo not found.\");\n          return;\n        }\n        if (info.getState() !\u003d ReplicaState.FINALIZED) {\n          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n              bpid + \": replica is not finalized; it is in state \" +\n              info.getState());\n          return;\n        }\n        try {\n          volume \u003d (FsVolumeImpl)info.getVolume();\n          if (volume \u003d\u003d null) {\n            LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n                bpid + \": volume not found.\");\n            return;\n          }\n        } catch (ClassCastException e) {\n          LOG.warn(\"Failed to cache block with id \" + blockId +\n              \": volume was not an instance of FsVolumeImpl.\");\n          return;\n        }\n        if (volume.isTransientStorage()) {\n          LOG.warn(\"Caching not supported on block with id \" + blockId +\n              \" since the volume is backed by RAM.\");\n          return;\n        }\n        success \u003d true;\n      } finally {\n        if (!success) {\n          cacheManager.numBlocksFailedToCache.incrementAndGet();\n        }\n      }\n      blockFileName \u003d info.getBlockFile().getAbsolutePath();\n      length \u003d info.getVisibleLength();\n      genstamp \u003d info.getGenerationStamp();\n      volumeExecutor \u003d volume.getCacheExecutor();\n    }\n    cacheManager.cacheBlock(blockId, bpid, \n        blockFileName, length, genstamp, volumeExecutor);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "a317bd7b02c37bd57743bfad59593ec12f53f4ed": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6925. DataNode should attempt to place replicas on transient storage first if lazyPersist flag is received. (Arpit Agarwal)\n",
      "commitDate": "27/08/14 9:47 PM",
      "commitName": "a317bd7b02c37bd57743bfad59593ec12f53f4ed",
      "commitAuthor": "arp",
      "commitDateOld": "07/08/14 3:59 PM",
      "commitNameOld": "d758be1f35f6c1c7e9edd491af559721a3b8b8f8",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 20.24,
      "commitsBetweenForRepo": 166,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,52 @@\n   private void cacheBlock(String bpid, long blockId) {\n     FsVolumeImpl volume;\n     String blockFileName;\n     long length, genstamp;\n     Executor volumeExecutor;\n \n     synchronized (this) {\n       ReplicaInfo info \u003d volumeMap.get(bpid, blockId);\n       boolean success \u003d false;\n       try {\n         if (info \u003d\u003d null) {\n           LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n               bpid + \": ReplicaInfo not found.\");\n           return;\n         }\n         if (info.getState() !\u003d ReplicaState.FINALIZED) {\n           LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n               bpid + \": replica is not finalized; it is in state \" +\n               info.getState());\n           return;\n         }\n         try {\n           volume \u003d (FsVolumeImpl)info.getVolume();\n           if (volume \u003d\u003d null) {\n             LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n                 bpid + \": volume not found.\");\n             return;\n           }\n         } catch (ClassCastException e) {\n           LOG.warn(\"Failed to cache block with id \" + blockId +\n               \": volume was not an instance of FsVolumeImpl.\");\n           return;\n         }\n+        if (volume.isTransientStorage()) {\n+          LOG.warn(\"Caching not supported on block with id \" + blockId +\n+              \" since the volume is backed by RAM.\");\n+          return;\n+        }\n         success \u003d true;\n       } finally {\n         if (!success) {\n           cacheManager.numBlocksFailedToCache.incrementAndGet();\n         }\n       }\n       blockFileName \u003d info.getBlockFile().getAbsolutePath();\n       length \u003d info.getVisibleLength();\n       genstamp \u003d info.getGenerationStamp();\n       volumeExecutor \u003d volume.getCacheExecutor();\n     }\n     cacheManager.cacheBlock(blockId, bpid, \n         blockFileName, length, genstamp, volumeExecutor);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void cacheBlock(String bpid, long blockId) {\n    FsVolumeImpl volume;\n    String blockFileName;\n    long length, genstamp;\n    Executor volumeExecutor;\n\n    synchronized (this) {\n      ReplicaInfo info \u003d volumeMap.get(bpid, blockId);\n      boolean success \u003d false;\n      try {\n        if (info \u003d\u003d null) {\n          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n              bpid + \": ReplicaInfo not found.\");\n          return;\n        }\n        if (info.getState() !\u003d ReplicaState.FINALIZED) {\n          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n              bpid + \": replica is not finalized; it is in state \" +\n              info.getState());\n          return;\n        }\n        try {\n          volume \u003d (FsVolumeImpl)info.getVolume();\n          if (volume \u003d\u003d null) {\n            LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n                bpid + \": volume not found.\");\n            return;\n          }\n        } catch (ClassCastException e) {\n          LOG.warn(\"Failed to cache block with id \" + blockId +\n              \": volume was not an instance of FsVolumeImpl.\");\n          return;\n        }\n        if (volume.isTransientStorage()) {\n          LOG.warn(\"Caching not supported on block with id \" + blockId +\n              \" since the volume is backed by RAM.\");\n          return;\n        }\n        success \u003d true;\n      } finally {\n        if (!success) {\n          cacheManager.numBlocksFailedToCache.incrementAndGet();\n        }\n      }\n      blockFileName \u003d info.getBlockFile().getAbsolutePath();\n      length \u003d info.getVisibleLength();\n      genstamp \u003d info.getGenerationStamp();\n      volumeExecutor \u003d volume.getCacheExecutor();\n    }\n    cacheManager.cacheBlock(blockId, bpid, \n        blockFileName, length, genstamp, volumeExecutor);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "9673baa7e8b43fa6300080f72ebce0189ea775e5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5320. Add datanode caching metrics. Contributed by Andrew Wang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1540796 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/11/13 10:30 AM",
      "commitName": "9673baa7e8b43fa6300080f72ebce0189ea775e5",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "07/11/13 7:00 PM",
      "commitNameOld": "97199baea1c41a66bd2a88bda31742ef6ddcb5dc",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 3.65,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,47 @@\n   private void cacheBlock(String bpid, long blockId) {\n     FsVolumeImpl volume;\n     String blockFileName;\n     long length, genstamp;\n     Executor volumeExecutor;\n \n     synchronized (this) {\n       ReplicaInfo info \u003d volumeMap.get(bpid, blockId);\n-      if (info \u003d\u003d null) {\n-        LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n-            bpid + \": ReplicaInfo not found.\");\n-        return;\n-      }\n-      if (info.getState() !\u003d ReplicaState.FINALIZED) {\n-        LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n-            bpid + \": replica is not finalized; it is in state \" +\n-            info.getState());\n-        return;\n-      }\n+      boolean success \u003d false;\n       try {\n-        volume \u003d (FsVolumeImpl)info.getVolume();\n-        if (volume \u003d\u003d null) {\n+        if (info \u003d\u003d null) {\n           LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n-              bpid + \": volume not found.\");\n+              bpid + \": ReplicaInfo not found.\");\n           return;\n         }\n-      } catch (ClassCastException e) {\n-        LOG.warn(\"Failed to cache block with id \" + blockId +\n-            \": volume was not an instance of FsVolumeImpl.\");\n-        return;\n+        if (info.getState() !\u003d ReplicaState.FINALIZED) {\n+          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n+              bpid + \": replica is not finalized; it is in state \" +\n+              info.getState());\n+          return;\n+        }\n+        try {\n+          volume \u003d (FsVolumeImpl)info.getVolume();\n+          if (volume \u003d\u003d null) {\n+            LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n+                bpid + \": volume not found.\");\n+            return;\n+          }\n+        } catch (ClassCastException e) {\n+          LOG.warn(\"Failed to cache block with id \" + blockId +\n+              \": volume was not an instance of FsVolumeImpl.\");\n+          return;\n+        }\n+        success \u003d true;\n+      } finally {\n+        if (!success) {\n+          cacheManager.numBlocksFailedToCache.incrementAndGet();\n+        }\n       }\n       blockFileName \u003d info.getBlockFile().getAbsolutePath();\n       length \u003d info.getVisibleLength();\n       genstamp \u003d info.getGenerationStamp();\n       volumeExecutor \u003d volume.getCacheExecutor();\n     }\n     cacheManager.cacheBlock(blockId, bpid, \n         blockFileName, length, genstamp, volumeExecutor);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void cacheBlock(String bpid, long blockId) {\n    FsVolumeImpl volume;\n    String blockFileName;\n    long length, genstamp;\n    Executor volumeExecutor;\n\n    synchronized (this) {\n      ReplicaInfo info \u003d volumeMap.get(bpid, blockId);\n      boolean success \u003d false;\n      try {\n        if (info \u003d\u003d null) {\n          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n              bpid + \": ReplicaInfo not found.\");\n          return;\n        }\n        if (info.getState() !\u003d ReplicaState.FINALIZED) {\n          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n              bpid + \": replica is not finalized; it is in state \" +\n              info.getState());\n          return;\n        }\n        try {\n          volume \u003d (FsVolumeImpl)info.getVolume();\n          if (volume \u003d\u003d null) {\n            LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n                bpid + \": volume not found.\");\n            return;\n          }\n        } catch (ClassCastException e) {\n          LOG.warn(\"Failed to cache block with id \" + blockId +\n              \": volume was not an instance of FsVolumeImpl.\");\n          return;\n        }\n        success \u003d true;\n      } finally {\n        if (!success) {\n          cacheManager.numBlocksFailedToCache.incrementAndGet();\n        }\n      }\n      blockFileName \u003d info.getBlockFile().getAbsolutePath();\n      length \u003d info.getVisibleLength();\n      genstamp \u003d info.getGenerationStamp();\n      volumeExecutor \u003d volume.getCacheExecutor();\n    }\n    cacheManager.cacheBlock(blockId, bpid, \n        blockFileName, length, genstamp, volumeExecutor);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "97199baea1c41a66bd2a88bda31742ef6ddcb5dc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5394: Fix race conditions in DN caching and uncaching (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539909 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/11/13 7:00 PM",
      "commitName": "97199baea1c41a66bd2a88bda31742ef6ddcb5dc",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "21/10/13 12:29 PM",
      "commitNameOld": "f9c08d02ebe4a5477cf5d753f0d9d48fc6f9fa48",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 17.31,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,39 @@\n   private void cacheBlock(String bpid, long blockId) {\n-    ReplicaInfo info;\n     FsVolumeImpl volume;\n+    String blockFileName;\n+    long length, genstamp;\n+    Executor volumeExecutor;\n+\n     synchronized (this) {\n-      if (!validToCache(bpid, blockId)) {\n+      ReplicaInfo info \u003d volumeMap.get(bpid, blockId);\n+      if (info \u003d\u003d null) {\n+        LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n+            bpid + \": ReplicaInfo not found.\");\n         return;\n       }\n-      info \u003d volumeMap.get(bpid, blockId);\n-      volume \u003d (FsVolumeImpl)info.getVolume();\n+      if (info.getState() !\u003d ReplicaState.FINALIZED) {\n+        LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n+            bpid + \": replica is not finalized; it is in state \" +\n+            info.getState());\n+        return;\n+      }\n+      try {\n+        volume \u003d (FsVolumeImpl)info.getVolume();\n+        if (volume \u003d\u003d null) {\n+          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n+              bpid + \": volume not found.\");\n+          return;\n+        }\n+      } catch (ClassCastException e) {\n+        LOG.warn(\"Failed to cache block with id \" + blockId +\n+            \": volume was not an instance of FsVolumeImpl.\");\n+        return;\n+      }\n+      blockFileName \u003d info.getBlockFile().getAbsolutePath();\n+      length \u003d info.getVisibleLength();\n+      genstamp \u003d info.getGenerationStamp();\n+      volumeExecutor \u003d volume.getCacheExecutor();\n     }\n-    // Try to open block and meta streams\n-    FileInputStream blockIn \u003d null;\n-    FileInputStream metaIn \u003d null;\n-    boolean success \u003d false;\n-    ExtendedBlock extBlk \u003d\n-        new ExtendedBlock(bpid, blockId,\n-            info.getBytesOnDisk(), info.getGenerationStamp());\n-    try {\n-      blockIn \u003d (FileInputStream)getBlockInputStream(extBlk, 0);\n-      metaIn \u003d (FileInputStream)getMetaDataInputStream(extBlk)\n-          .getWrappedStream();\n-      success \u003d true;\n-    } catch (ClassCastException e) {\n-      LOG.warn(\"Failed to cache replica \" + extBlk + \": Underlying blocks\"\n-          + \" are not backed by files.\", e);\n-    } catch (IOException e) {\n-      LOG.warn(\"Failed to cache replica \" + extBlk + \": IOException while\"\n-          + \" trying to open block or meta files.\", e);\n-    }\n-    if (!success) {\n-      IOUtils.closeQuietly(blockIn);\n-      IOUtils.closeQuietly(metaIn);\n-      return;\n-    }\n-    cacheManager.cacheBlock(bpid, extBlk.getLocalBlock(),\n-        volume, blockIn, metaIn);\n+    cacheManager.cacheBlock(blockId, bpid, \n+        blockFileName, length, genstamp, volumeExecutor);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void cacheBlock(String bpid, long blockId) {\n    FsVolumeImpl volume;\n    String blockFileName;\n    long length, genstamp;\n    Executor volumeExecutor;\n\n    synchronized (this) {\n      ReplicaInfo info \u003d volumeMap.get(bpid, blockId);\n      if (info \u003d\u003d null) {\n        LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n            bpid + \": ReplicaInfo not found.\");\n        return;\n      }\n      if (info.getState() !\u003d ReplicaState.FINALIZED) {\n        LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n            bpid + \": replica is not finalized; it is in state \" +\n            info.getState());\n        return;\n      }\n      try {\n        volume \u003d (FsVolumeImpl)info.getVolume();\n        if (volume \u003d\u003d null) {\n          LOG.warn(\"Failed to cache block with id \" + blockId + \", pool \" +\n              bpid + \": volume not found.\");\n          return;\n        }\n      } catch (ClassCastException e) {\n        LOG.warn(\"Failed to cache block with id \" + blockId +\n            \": volume was not an instance of FsVolumeImpl.\");\n        return;\n      }\n      blockFileName \u003d info.getBlockFile().getAbsolutePath();\n      length \u003d info.getVisibleLength();\n      genstamp \u003d info.getGenerationStamp();\n      volumeExecutor \u003d volume.getCacheExecutor();\n    }\n    cacheManager.cacheBlock(blockId, bpid, \n        blockFileName, length, genstamp, volumeExecutor);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    }
  }
}