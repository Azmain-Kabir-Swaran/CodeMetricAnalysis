{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NumaResourceAllocator.java",
  "functionName": "allocate",
  "functionId": "allocate___containerId-ContainerId__resource-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/numa/NumaResourceAllocator.java",
  "functionStartLine": 233,
  "functionEndLine": 303,
  "numCommitsSeen": 3,
  "timeTaken": 1426,
  "changeHistory": [
    "8b3c6791b13fc57891cf81e83d4b626b4f2932e6",
    "a82d4a2e3a6a5448e371cef0cb86d5dbe4871ccd"
  ],
  "changeHistoryShort": {
    "8b3c6791b13fc57891cf81e83d4b626b4f2932e6": "Ybodychange",
    "a82d4a2e3a6a5448e371cef0cb86d5dbe4871ccd": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8b3c6791b13fc57891cf81e83d4b626b4f2932e6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9135. NM State store ResourceMappings serialization are tested with Strings instead of real Device objects. Contributed by Peter Bacsko\n",
      "commitDate": "12/07/19 8:20 AM",
      "commitName": "8b3c6791b13fc57891cf81e83d4b626b4f2932e6",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "18/03/19 10:57 AM",
      "commitNameOld": "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 115.89,
      "commitsBetweenForRepo": 807,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,71 @@\n   private NumaResourceAllocation allocate(ContainerId containerId,\n       Resource resource) {\n     for (int index \u003d 0; index \u003c numaNodesList.size(); index++) {\n       NumaNodeResource numaNode \u003d numaNodesList\n           .get((currentAssignNode + index) % numaNodesList.size());\n       if (numaNode.isResourcesAvailable(resource)) {\n         numaNode.assignResources(resource, containerId);\n         LOG.info(\"Assigning NUMA node \" + numaNode.getNodeId() + \" for memory, \"\n             + numaNode.getNodeId() + \" for cpus for the \" + containerId);\n         currentAssignNode \u003d (currentAssignNode + index + 1)\n             % numaNodesList.size();\n         return new NumaResourceAllocation(numaNode.getNodeId(),\n             resource.getMemorySize(), numaNode.getNodeId(),\n             resource.getVirtualCores());\n       }\n     }\n \n     // If there is no single node matched for the container resource\n     // Check the NUMA nodes for Memory resources\n-    NumaResourceAllocation assignedNumaNodeInfo \u003d new NumaResourceAllocation();\n-    long memreq \u003d resource.getMemorySize();\n+    long memoryRequirement \u003d resource.getMemorySize();\n+    Map\u003cString, Long\u003e memoryAllocations \u003d Maps.newHashMap();\n     for (NumaNodeResource numaNode : numaNodesList) {\n-      long memrem \u003d numaNode.assignAvailableMemory(memreq, containerId);\n-      assignedNumaNodeInfo.addMemoryNode(numaNode.getNodeId(), memreq - memrem);\n-      memreq \u003d memrem;\n-      if (memreq \u003d\u003d 0) {\n+      long memoryRemaining \u003d numaNode.\n+          assignAvailableMemory(memoryRequirement, containerId);\n+      memoryAllocations.put(numaNode.getNodeId(),\n+          memoryRequirement - memoryRemaining);\n+      memoryRequirement \u003d memoryRemaining;\n+      if (memoryRequirement \u003d\u003d 0) {\n         break;\n       }\n     }\n-    if (memreq !\u003d 0) {\n+    if (memoryRequirement !\u003d 0) {\n       LOG.info(\"There is no available memory:\" + resource.getMemorySize()\n           + \" in numa nodes for \" + containerId);\n       releaseNumaResource(containerId);\n       return null;\n     }\n \n     // Check the NUMA nodes for CPU resources\n-    int cpusreq \u003d resource.getVirtualCores();\n+    int cpusRequirement \u003d resource.getVirtualCores();\n+    Map\u003cString, Integer\u003e cpuAllocations \u003d Maps.newHashMap();\n     for (int index \u003d 0; index \u003c numaNodesList.size(); index++) {\n       NumaNodeResource numaNode \u003d numaNodesList\n           .get((currentAssignNode + index) % numaNodesList.size());\n-      int cpusrem \u003d numaNode.assignAvailableCpus(cpusreq, containerId);\n-      assignedNumaNodeInfo.addCpuNode(numaNode.getNodeId(), cpusreq - cpusrem);\n-      cpusreq \u003d cpusrem;\n-      if (cpusreq \u003d\u003d 0) {\n+      int cpusRemaining \u003d numaNode.\n+          assignAvailableCpus(cpusRequirement, containerId);\n+      cpuAllocations.put(numaNode.getNodeId(), cpusRequirement - cpusRemaining);\n+      cpusRequirement \u003d cpusRemaining;\n+      if (cpusRequirement \u003d\u003d 0) {\n         currentAssignNode \u003d (currentAssignNode + index + 1)\n             % numaNodesList.size();\n         break;\n       }\n     }\n \n-    if (cpusreq !\u003d 0) {\n+    if (cpusRequirement !\u003d 0) {\n       LOG.info(\"There are no available cpus:\" + resource.getVirtualCores()\n           + \" in numa nodes for \" + containerId);\n       releaseNumaResource(containerId);\n       return null;\n     }\n+\n+    NumaResourceAllocation assignedNumaNodeInfo \u003d\n+        new NumaResourceAllocation(memoryAllocations, cpuAllocations);\n     LOG.info(\"Assigning multiple NUMA nodes (\"\n         + StringUtils.join(\",\", assignedNumaNodeInfo.getMemNodes())\n         + \") for memory, (\"\n         + StringUtils.join(\",\", assignedNumaNodeInfo.getCpuNodes())\n         + \") for cpus for \" + containerId);\n     return assignedNumaNodeInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private NumaResourceAllocation allocate(ContainerId containerId,\n      Resource resource) {\n    for (int index \u003d 0; index \u003c numaNodesList.size(); index++) {\n      NumaNodeResource numaNode \u003d numaNodesList\n          .get((currentAssignNode + index) % numaNodesList.size());\n      if (numaNode.isResourcesAvailable(resource)) {\n        numaNode.assignResources(resource, containerId);\n        LOG.info(\"Assigning NUMA node \" + numaNode.getNodeId() + \" for memory, \"\n            + numaNode.getNodeId() + \" for cpus for the \" + containerId);\n        currentAssignNode \u003d (currentAssignNode + index + 1)\n            % numaNodesList.size();\n        return new NumaResourceAllocation(numaNode.getNodeId(),\n            resource.getMemorySize(), numaNode.getNodeId(),\n            resource.getVirtualCores());\n      }\n    }\n\n    // If there is no single node matched for the container resource\n    // Check the NUMA nodes for Memory resources\n    long memoryRequirement \u003d resource.getMemorySize();\n    Map\u003cString, Long\u003e memoryAllocations \u003d Maps.newHashMap();\n    for (NumaNodeResource numaNode : numaNodesList) {\n      long memoryRemaining \u003d numaNode.\n          assignAvailableMemory(memoryRequirement, containerId);\n      memoryAllocations.put(numaNode.getNodeId(),\n          memoryRequirement - memoryRemaining);\n      memoryRequirement \u003d memoryRemaining;\n      if (memoryRequirement \u003d\u003d 0) {\n        break;\n      }\n    }\n    if (memoryRequirement !\u003d 0) {\n      LOG.info(\"There is no available memory:\" + resource.getMemorySize()\n          + \" in numa nodes for \" + containerId);\n      releaseNumaResource(containerId);\n      return null;\n    }\n\n    // Check the NUMA nodes for CPU resources\n    int cpusRequirement \u003d resource.getVirtualCores();\n    Map\u003cString, Integer\u003e cpuAllocations \u003d Maps.newHashMap();\n    for (int index \u003d 0; index \u003c numaNodesList.size(); index++) {\n      NumaNodeResource numaNode \u003d numaNodesList\n          .get((currentAssignNode + index) % numaNodesList.size());\n      int cpusRemaining \u003d numaNode.\n          assignAvailableCpus(cpusRequirement, containerId);\n      cpuAllocations.put(numaNode.getNodeId(), cpusRequirement - cpusRemaining);\n      cpusRequirement \u003d cpusRemaining;\n      if (cpusRequirement \u003d\u003d 0) {\n        currentAssignNode \u003d (currentAssignNode + index + 1)\n            % numaNodesList.size();\n        break;\n      }\n    }\n\n    if (cpusRequirement !\u003d 0) {\n      LOG.info(\"There are no available cpus:\" + resource.getVirtualCores()\n          + \" in numa nodes for \" + containerId);\n      releaseNumaResource(containerId);\n      return null;\n    }\n\n    NumaResourceAllocation assignedNumaNodeInfo \u003d\n        new NumaResourceAllocation(memoryAllocations, cpuAllocations);\n    LOG.info(\"Assigning multiple NUMA nodes (\"\n        + StringUtils.join(\",\", assignedNumaNodeInfo.getMemNodes())\n        + \") for memory, (\"\n        + StringUtils.join(\",\", assignedNumaNodeInfo.getCpuNodes())\n        + \") for cpus for \" + containerId);\n    return assignedNumaNodeInfo;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/numa/NumaResourceAllocator.java",
      "extendedDetails": {}
    },
    "a82d4a2e3a6a5448e371cef0cb86d5dbe4871ccd": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5764. NUMA awareness support for launching containers. Contributed by Devaraj K.\n",
      "commitDate": "13/03/18 12:36 PM",
      "commitName": "a82d4a2e3a6a5448e371cef0cb86d5dbe4871ccd",
      "commitAuthor": "Miklos Szegedi",
      "diff": "@@ -0,0 +1,64 @@\n+  private NumaResourceAllocation allocate(ContainerId containerId,\n+      Resource resource) {\n+    for (int index \u003d 0; index \u003c numaNodesList.size(); index++) {\n+      NumaNodeResource numaNode \u003d numaNodesList\n+          .get((currentAssignNode + index) % numaNodesList.size());\n+      if (numaNode.isResourcesAvailable(resource)) {\n+        numaNode.assignResources(resource, containerId);\n+        LOG.info(\"Assigning NUMA node \" + numaNode.getNodeId() + \" for memory, \"\n+            + numaNode.getNodeId() + \" for cpus for the \" + containerId);\n+        currentAssignNode \u003d (currentAssignNode + index + 1)\n+            % numaNodesList.size();\n+        return new NumaResourceAllocation(numaNode.getNodeId(),\n+            resource.getMemorySize(), numaNode.getNodeId(),\n+            resource.getVirtualCores());\n+      }\n+    }\n+\n+    // If there is no single node matched for the container resource\n+    // Check the NUMA nodes for Memory resources\n+    NumaResourceAllocation assignedNumaNodeInfo \u003d new NumaResourceAllocation();\n+    long memreq \u003d resource.getMemorySize();\n+    for (NumaNodeResource numaNode : numaNodesList) {\n+      long memrem \u003d numaNode.assignAvailableMemory(memreq, containerId);\n+      assignedNumaNodeInfo.addMemoryNode(numaNode.getNodeId(), memreq - memrem);\n+      memreq \u003d memrem;\n+      if (memreq \u003d\u003d 0) {\n+        break;\n+      }\n+    }\n+    if (memreq !\u003d 0) {\n+      LOG.info(\"There is no available memory:\" + resource.getMemorySize()\n+          + \" in numa nodes for \" + containerId);\n+      releaseNumaResource(containerId);\n+      return null;\n+    }\n+\n+    // Check the NUMA nodes for CPU resources\n+    int cpusreq \u003d resource.getVirtualCores();\n+    for (int index \u003d 0; index \u003c numaNodesList.size(); index++) {\n+      NumaNodeResource numaNode \u003d numaNodesList\n+          .get((currentAssignNode + index) % numaNodesList.size());\n+      int cpusrem \u003d numaNode.assignAvailableCpus(cpusreq, containerId);\n+      assignedNumaNodeInfo.addCpuNode(numaNode.getNodeId(), cpusreq - cpusrem);\n+      cpusreq \u003d cpusrem;\n+      if (cpusreq \u003d\u003d 0) {\n+        currentAssignNode \u003d (currentAssignNode + index + 1)\n+            % numaNodesList.size();\n+        break;\n+      }\n+    }\n+\n+    if (cpusreq !\u003d 0) {\n+      LOG.info(\"There are no available cpus:\" + resource.getVirtualCores()\n+          + \" in numa nodes for \" + containerId);\n+      releaseNumaResource(containerId);\n+      return null;\n+    }\n+    LOG.info(\"Assigning multiple NUMA nodes (\"\n+        + StringUtils.join(\",\", assignedNumaNodeInfo.getMemNodes())\n+        + \") for memory, (\"\n+        + StringUtils.join(\",\", assignedNumaNodeInfo.getCpuNodes())\n+        + \") for cpus for \" + containerId);\n+    return assignedNumaNodeInfo;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private NumaResourceAllocation allocate(ContainerId containerId,\n      Resource resource) {\n    for (int index \u003d 0; index \u003c numaNodesList.size(); index++) {\n      NumaNodeResource numaNode \u003d numaNodesList\n          .get((currentAssignNode + index) % numaNodesList.size());\n      if (numaNode.isResourcesAvailable(resource)) {\n        numaNode.assignResources(resource, containerId);\n        LOG.info(\"Assigning NUMA node \" + numaNode.getNodeId() + \" for memory, \"\n            + numaNode.getNodeId() + \" for cpus for the \" + containerId);\n        currentAssignNode \u003d (currentAssignNode + index + 1)\n            % numaNodesList.size();\n        return new NumaResourceAllocation(numaNode.getNodeId(),\n            resource.getMemorySize(), numaNode.getNodeId(),\n            resource.getVirtualCores());\n      }\n    }\n\n    // If there is no single node matched for the container resource\n    // Check the NUMA nodes for Memory resources\n    NumaResourceAllocation assignedNumaNodeInfo \u003d new NumaResourceAllocation();\n    long memreq \u003d resource.getMemorySize();\n    for (NumaNodeResource numaNode : numaNodesList) {\n      long memrem \u003d numaNode.assignAvailableMemory(memreq, containerId);\n      assignedNumaNodeInfo.addMemoryNode(numaNode.getNodeId(), memreq - memrem);\n      memreq \u003d memrem;\n      if (memreq \u003d\u003d 0) {\n        break;\n      }\n    }\n    if (memreq !\u003d 0) {\n      LOG.info(\"There is no available memory:\" + resource.getMemorySize()\n          + \" in numa nodes for \" + containerId);\n      releaseNumaResource(containerId);\n      return null;\n    }\n\n    // Check the NUMA nodes for CPU resources\n    int cpusreq \u003d resource.getVirtualCores();\n    for (int index \u003d 0; index \u003c numaNodesList.size(); index++) {\n      NumaNodeResource numaNode \u003d numaNodesList\n          .get((currentAssignNode + index) % numaNodesList.size());\n      int cpusrem \u003d numaNode.assignAvailableCpus(cpusreq, containerId);\n      assignedNumaNodeInfo.addCpuNode(numaNode.getNodeId(), cpusreq - cpusrem);\n      cpusreq \u003d cpusrem;\n      if (cpusreq \u003d\u003d 0) {\n        currentAssignNode \u003d (currentAssignNode + index + 1)\n            % numaNodesList.size();\n        break;\n      }\n    }\n\n    if (cpusreq !\u003d 0) {\n      LOG.info(\"There are no available cpus:\" + resource.getVirtualCores()\n          + \" in numa nodes for \" + containerId);\n      releaseNumaResource(containerId);\n      return null;\n    }\n    LOG.info(\"Assigning multiple NUMA nodes (\"\n        + StringUtils.join(\",\", assignedNumaNodeInfo.getMemNodes())\n        + \") for memory, (\"\n        + StringUtils.join(\",\", assignedNumaNodeInfo.getCpuNodes())\n        + \") for cpus for \" + containerId);\n    return assignedNumaNodeInfo;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/numa/NumaResourceAllocator.java"
    }
  }
}