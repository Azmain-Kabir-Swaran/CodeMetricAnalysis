{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "YARNRunner.java",
  "functionName": "generateResourceRequests",
  "functionId": "generateResourceRequests",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/YARNRunner.java",
  "functionStartLine": 668,
  "functionEndLine": 791,
  "numCommitsSeen": 80,
  "timeTaken": 1219,
  "changeHistory": [
    "9a7e81083801a57d6bb96584988415cbef67460d",
    "3721cfe1fbd98c5b6aa46aefdfcf62276c28c4a4"
  ],
  "changeHistoryShort": {
    "9a7e81083801a57d6bb96584988415cbef67460d": "Ybodychange",
    "3721cfe1fbd98c5b6aa46aefdfcf62276c28c4a4": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9a7e81083801a57d6bb96584988415cbef67460d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6927. Add support for individual resource types requests in MapReduce\n(Contributed by Gergo Repas via Daniel Templeton)\n",
      "commitDate": "30/10/17 11:04 AM",
      "commitName": "9a7e81083801a57d6bb96584988415cbef67460d",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "12/10/17 10:59 AM",
      "commitNameOld": "e46d5bb962b0c942f993afc505b165b1cd96e51b",
      "commitAuthorOld": "Chris Trezzo",
      "daysBetweenCommits": 18.0,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,124 @@\n   private List\u003cResourceRequest\u003e generateResourceRequests() throws IOException {\n     Resource capability \u003d recordFactory.newRecordInstance(Resource.class);\n-    capability.setMemorySize(\n-        conf.getInt(\n-            MRJobConfig.MR_AM_VMEM_MB, MRJobConfig.DEFAULT_MR_AM_VMEM_MB\n-        )\n-    );\n-    capability.setVirtualCores(\n-        conf.getInt(\n-            MRJobConfig.MR_AM_CPU_VCORES, MRJobConfig.DEFAULT_MR_AM_CPU_VCORES\n-        )\n-    );\n+    boolean memorySet \u003d false;\n+    boolean cpuVcoresSet \u003d false;\n+    List\u003cResourceInformation\u003e resourceRequests \u003d ResourceUtils\n+        .getRequestedResourcesFromConfig(conf, MR_AM_RESOURCE_PREFIX);\n+    for (ResourceInformation resourceReq : resourceRequests) {\n+      String resourceName \u003d resourceReq.getName();\n+      if (MRJobConfig.RESOURCE_TYPE_NAME_MEMORY.equals(resourceName) ||\n+          MRJobConfig.RESOURCE_TYPE_ALTERNATIVE_NAME_MEMORY.equals(\n+              resourceName)) {\n+        if (memorySet) {\n+          throw new IllegalArgumentException(\n+              \"Only one of the following keys \" +\n+                  \"can be specified for a single job: \" +\n+                  MRJobConfig.RESOURCE_TYPE_ALTERNATIVE_NAME_MEMORY + \", \" +\n+                  MRJobConfig.RESOURCE_TYPE_NAME_MEMORY);\n+        }\n+        String units \u003d isEmpty(resourceReq.getUnits()) ?\n+            ResourceUtils.getDefaultUnit(ResourceInformation.MEMORY_URI) :\n+              resourceReq.getUnits();\n+        capability.setMemorySize(\n+            UnitsConversionUtil.convert(units, \"Mi\", resourceReq.getValue()));\n+        memorySet \u003d true;\n+        if (conf.get(MRJobConfig.MR_AM_VMEM_MB) !\u003d null) {\n+          LOG.warn(\"Configuration \" + MR_AM_RESOURCE_PREFIX +\n+              resourceName + \"\u003d\" + resourceReq.getValue() +\n+              resourceReq.getUnits() + \" is overriding the \" +\n+              MRJobConfig.MR_AM_VMEM_MB + \"\u003d\" +\n+              conf.get(MRJobConfig.MR_AM_VMEM_MB) + \" configuration\");\n+        }\n+      } else if (MRJobConfig.RESOURCE_TYPE_NAME_VCORE.equals(resourceName)) {\n+        capability.setVirtualCores(\n+            (int) UnitsConversionUtil.convert(resourceReq.getUnits(), \"\",\n+                resourceReq.getValue()));\n+        cpuVcoresSet \u003d true;\n+        if (conf.get(MRJobConfig.MR_AM_CPU_VCORES) !\u003d null) {\n+          LOG.warn(\"Configuration \" + MR_AM_RESOURCE_PREFIX +\n+              resourceName + \"\u003d\" + resourceReq.getValue() +\n+              resourceReq.getUnits() + \" is overriding the \" +\n+              MRJobConfig.MR_AM_CPU_VCORES + \"\u003d\" +\n+              conf.get(MRJobConfig.MR_AM_CPU_VCORES) + \" configuration\");\n+        }\n+      } else if (!MRJobConfig.MR_AM_VMEM_MB.equals(\n+          MR_AM_RESOURCE_PREFIX + resourceName) \u0026\u0026\n+          !MRJobConfig.MR_AM_CPU_VCORES.equals(\n+              MR_AM_RESOURCE_PREFIX + resourceName)) {\n+        // the \"mb\", \"cpu-vcores\" resource types are not processed here\n+        // since the yarn.app.mapreduce.am.resource.mb,\n+        // yarn.app.mapreduce.am.resource.cpu-vcores keys are used for\n+        // backward-compatibility - which is handled after this loop\n+        ResourceInformation resourceInformation \u003d capability\n+            .getResourceInformation(resourceName);\n+        resourceInformation.setUnits(resourceReq.getUnits());\n+        resourceInformation.setValue(resourceReq.getValue());\n+        capability.setResourceInformation(resourceName, resourceInformation);\n+      }\n+    }\n+    if (!memorySet) {\n+      capability.setMemorySize(\n+          conf.getInt(\n+              MRJobConfig.MR_AM_VMEM_MB, MRJobConfig.DEFAULT_MR_AM_VMEM_MB\n+          )\n+      );\n+    }\n+    if (!cpuVcoresSet) {\n+      capability.setVirtualCores(\n+          conf.getInt(\n+              MRJobConfig.MR_AM_CPU_VCORES, MRJobConfig.DEFAULT_MR_AM_CPU_VCORES\n+          )\n+      );\n+    }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"AppMaster capability \u003d \" + capability);\n     }\n \n     List\u003cResourceRequest\u003e amResourceRequests \u003d new ArrayList\u003c\u003e();\n     // Always have an ANY request\n     ResourceRequest amAnyResourceRequest \u003d\n         createAMResourceRequest(ResourceRequest.ANY, capability);\n     Map\u003cString, ResourceRequest\u003e rackRequests \u003d new HashMap\u003c\u003e();\n     amResourceRequests.add(amAnyResourceRequest);\n     Collection\u003cString\u003e amStrictResources \u003d conf.getStringCollection(\n         MRJobConfig.AM_STRICT_LOCALITY);\n     for (String amStrictResource : amStrictResources) {\n       amAnyResourceRequest.setRelaxLocality(false);\n       Matcher matcher \u003d RACK_NODE_PATTERN.matcher(amStrictResource);\n       if (matcher.matches()) {\n         String nodeName;\n         String rackName \u003d matcher.group(RACK_GROUP);\n         if (rackName \u003d\u003d null) {\n           rackName \u003d \"/default-rack\";\n           nodeName \u003d matcher.group(NODE_IF_NO_RACK_GROUP);\n         } else {\n           nodeName \u003d matcher.group(NODE_IF_RACK_GROUP);\n         }\n         ResourceRequest amRackResourceRequest \u003d rackRequests.get(rackName);\n         if (amRackResourceRequest \u003d\u003d null) {\n           amRackResourceRequest \u003d createAMResourceRequest(rackName, capability);\n           amResourceRequests.add(amRackResourceRequest);\n           rackRequests.put(rackName, amRackResourceRequest);\n         }\n         if (nodeName !\u003d null) {\n           amRackResourceRequest.setRelaxLocality(false);\n           ResourceRequest amNodeResourceRequest \u003d\n               createAMResourceRequest(nodeName, capability);\n           amResourceRequests.add(amNodeResourceRequest);\n         }\n       } else {\n         String errMsg \u003d\n             \"Invalid resource name: \" + amStrictResource + \" specified.\";\n         LOG.warn(errMsg);\n         throw new IOException(errMsg);\n       }\n     }\n     if (LOG.isDebugEnabled()) {\n       for (ResourceRequest amResourceRequest : amResourceRequests) {\n         LOG.debug(\"ResourceRequest: resource \u003d \"\n             + amResourceRequest.getResourceName() + \", locality \u003d \"\n             + amResourceRequest.getRelaxLocality());\n       }\n     }\n     return amResourceRequests;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cResourceRequest\u003e generateResourceRequests() throws IOException {\n    Resource capability \u003d recordFactory.newRecordInstance(Resource.class);\n    boolean memorySet \u003d false;\n    boolean cpuVcoresSet \u003d false;\n    List\u003cResourceInformation\u003e resourceRequests \u003d ResourceUtils\n        .getRequestedResourcesFromConfig(conf, MR_AM_RESOURCE_PREFIX);\n    for (ResourceInformation resourceReq : resourceRequests) {\n      String resourceName \u003d resourceReq.getName();\n      if (MRJobConfig.RESOURCE_TYPE_NAME_MEMORY.equals(resourceName) ||\n          MRJobConfig.RESOURCE_TYPE_ALTERNATIVE_NAME_MEMORY.equals(\n              resourceName)) {\n        if (memorySet) {\n          throw new IllegalArgumentException(\n              \"Only one of the following keys \" +\n                  \"can be specified for a single job: \" +\n                  MRJobConfig.RESOURCE_TYPE_ALTERNATIVE_NAME_MEMORY + \", \" +\n                  MRJobConfig.RESOURCE_TYPE_NAME_MEMORY);\n        }\n        String units \u003d isEmpty(resourceReq.getUnits()) ?\n            ResourceUtils.getDefaultUnit(ResourceInformation.MEMORY_URI) :\n              resourceReq.getUnits();\n        capability.setMemorySize(\n            UnitsConversionUtil.convert(units, \"Mi\", resourceReq.getValue()));\n        memorySet \u003d true;\n        if (conf.get(MRJobConfig.MR_AM_VMEM_MB) !\u003d null) {\n          LOG.warn(\"Configuration \" + MR_AM_RESOURCE_PREFIX +\n              resourceName + \"\u003d\" + resourceReq.getValue() +\n              resourceReq.getUnits() + \" is overriding the \" +\n              MRJobConfig.MR_AM_VMEM_MB + \"\u003d\" +\n              conf.get(MRJobConfig.MR_AM_VMEM_MB) + \" configuration\");\n        }\n      } else if (MRJobConfig.RESOURCE_TYPE_NAME_VCORE.equals(resourceName)) {\n        capability.setVirtualCores(\n            (int) UnitsConversionUtil.convert(resourceReq.getUnits(), \"\",\n                resourceReq.getValue()));\n        cpuVcoresSet \u003d true;\n        if (conf.get(MRJobConfig.MR_AM_CPU_VCORES) !\u003d null) {\n          LOG.warn(\"Configuration \" + MR_AM_RESOURCE_PREFIX +\n              resourceName + \"\u003d\" + resourceReq.getValue() +\n              resourceReq.getUnits() + \" is overriding the \" +\n              MRJobConfig.MR_AM_CPU_VCORES + \"\u003d\" +\n              conf.get(MRJobConfig.MR_AM_CPU_VCORES) + \" configuration\");\n        }\n      } else if (!MRJobConfig.MR_AM_VMEM_MB.equals(\n          MR_AM_RESOURCE_PREFIX + resourceName) \u0026\u0026\n          !MRJobConfig.MR_AM_CPU_VCORES.equals(\n              MR_AM_RESOURCE_PREFIX + resourceName)) {\n        // the \"mb\", \"cpu-vcores\" resource types are not processed here\n        // since the yarn.app.mapreduce.am.resource.mb,\n        // yarn.app.mapreduce.am.resource.cpu-vcores keys are used for\n        // backward-compatibility - which is handled after this loop\n        ResourceInformation resourceInformation \u003d capability\n            .getResourceInformation(resourceName);\n        resourceInformation.setUnits(resourceReq.getUnits());\n        resourceInformation.setValue(resourceReq.getValue());\n        capability.setResourceInformation(resourceName, resourceInformation);\n      }\n    }\n    if (!memorySet) {\n      capability.setMemorySize(\n          conf.getInt(\n              MRJobConfig.MR_AM_VMEM_MB, MRJobConfig.DEFAULT_MR_AM_VMEM_MB\n          )\n      );\n    }\n    if (!cpuVcoresSet) {\n      capability.setVirtualCores(\n          conf.getInt(\n              MRJobConfig.MR_AM_CPU_VCORES, MRJobConfig.DEFAULT_MR_AM_CPU_VCORES\n          )\n      );\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"AppMaster capability \u003d \" + capability);\n    }\n\n    List\u003cResourceRequest\u003e amResourceRequests \u003d new ArrayList\u003c\u003e();\n    // Always have an ANY request\n    ResourceRequest amAnyResourceRequest \u003d\n        createAMResourceRequest(ResourceRequest.ANY, capability);\n    Map\u003cString, ResourceRequest\u003e rackRequests \u003d new HashMap\u003c\u003e();\n    amResourceRequests.add(amAnyResourceRequest);\n    Collection\u003cString\u003e amStrictResources \u003d conf.getStringCollection(\n        MRJobConfig.AM_STRICT_LOCALITY);\n    for (String amStrictResource : amStrictResources) {\n      amAnyResourceRequest.setRelaxLocality(false);\n      Matcher matcher \u003d RACK_NODE_PATTERN.matcher(amStrictResource);\n      if (matcher.matches()) {\n        String nodeName;\n        String rackName \u003d matcher.group(RACK_GROUP);\n        if (rackName \u003d\u003d null) {\n          rackName \u003d \"/default-rack\";\n          nodeName \u003d matcher.group(NODE_IF_NO_RACK_GROUP);\n        } else {\n          nodeName \u003d matcher.group(NODE_IF_RACK_GROUP);\n        }\n        ResourceRequest amRackResourceRequest \u003d rackRequests.get(rackName);\n        if (amRackResourceRequest \u003d\u003d null) {\n          amRackResourceRequest \u003d createAMResourceRequest(rackName, capability);\n          amResourceRequests.add(amRackResourceRequest);\n          rackRequests.put(rackName, amRackResourceRequest);\n        }\n        if (nodeName !\u003d null) {\n          amRackResourceRequest.setRelaxLocality(false);\n          ResourceRequest amNodeResourceRequest \u003d\n              createAMResourceRequest(nodeName, capability);\n          amResourceRequests.add(amNodeResourceRequest);\n        }\n      } else {\n        String errMsg \u003d\n            \"Invalid resource name: \" + amStrictResource + \" specified.\";\n        LOG.warn(errMsg);\n        throw new IOException(errMsg);\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      for (ResourceRequest amResourceRequest : amResourceRequests) {\n        LOG.debug(\"ResourceRequest: resource \u003d \"\n            + amResourceRequest.getResourceName() + \", locality \u003d \"\n            + amResourceRequest.getRelaxLocality());\n      }\n    }\n    return amResourceRequests;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/YARNRunner.java",
      "extendedDetails": {}
    },
    "3721cfe1fbd98c5b6aa46aefdfcf62276c28c4a4": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-6871. Allow users to specify racks and nodes for strict locality for AMs (rkanter)\n",
      "commitDate": "21/04/17 4:12 PM",
      "commitName": "3721cfe1fbd98c5b6aa46aefdfcf62276c28c4a4",
      "commitAuthor": "Robert Kanter",
      "diff": "@@ -0,0 +1,64 @@\n+  private List\u003cResourceRequest\u003e generateResourceRequests() throws IOException {\n+    Resource capability \u003d recordFactory.newRecordInstance(Resource.class);\n+    capability.setMemorySize(\n+        conf.getInt(\n+            MRJobConfig.MR_AM_VMEM_MB, MRJobConfig.DEFAULT_MR_AM_VMEM_MB\n+        )\n+    );\n+    capability.setVirtualCores(\n+        conf.getInt(\n+            MRJobConfig.MR_AM_CPU_VCORES, MRJobConfig.DEFAULT_MR_AM_CPU_VCORES\n+        )\n+    );\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"AppMaster capability \u003d \" + capability);\n+    }\n+\n+    List\u003cResourceRequest\u003e amResourceRequests \u003d new ArrayList\u003c\u003e();\n+    // Always have an ANY request\n+    ResourceRequest amAnyResourceRequest \u003d\n+        createAMResourceRequest(ResourceRequest.ANY, capability);\n+    Map\u003cString, ResourceRequest\u003e rackRequests \u003d new HashMap\u003c\u003e();\n+    amResourceRequests.add(amAnyResourceRequest);\n+    Collection\u003cString\u003e amStrictResources \u003d conf.getStringCollection(\n+        MRJobConfig.AM_STRICT_LOCALITY);\n+    for (String amStrictResource : amStrictResources) {\n+      amAnyResourceRequest.setRelaxLocality(false);\n+      Matcher matcher \u003d RACK_NODE_PATTERN.matcher(amStrictResource);\n+      if (matcher.matches()) {\n+        String nodeName;\n+        String rackName \u003d matcher.group(RACK_GROUP);\n+        if (rackName \u003d\u003d null) {\n+          rackName \u003d \"/default-rack\";\n+          nodeName \u003d matcher.group(NODE_IF_NO_RACK_GROUP);\n+        } else {\n+          nodeName \u003d matcher.group(NODE_IF_RACK_GROUP);\n+        }\n+        ResourceRequest amRackResourceRequest \u003d rackRequests.get(rackName);\n+        if (amRackResourceRequest \u003d\u003d null) {\n+          amRackResourceRequest \u003d createAMResourceRequest(rackName, capability);\n+          amResourceRequests.add(amRackResourceRequest);\n+          rackRequests.put(rackName, amRackResourceRequest);\n+        }\n+        if (nodeName !\u003d null) {\n+          amRackResourceRequest.setRelaxLocality(false);\n+          ResourceRequest amNodeResourceRequest \u003d\n+              createAMResourceRequest(nodeName, capability);\n+          amResourceRequests.add(amNodeResourceRequest);\n+        }\n+      } else {\n+        String errMsg \u003d\n+            \"Invalid resource name: \" + amStrictResource + \" specified.\";\n+        LOG.warn(errMsg);\n+        throw new IOException(errMsg);\n+      }\n+    }\n+    if (LOG.isDebugEnabled()) {\n+      for (ResourceRequest amResourceRequest : amResourceRequests) {\n+        LOG.debug(\"ResourceRequest: resource \u003d \"\n+            + amResourceRequest.getResourceName() + \", locality \u003d \"\n+            + amResourceRequest.getRelaxLocality());\n+      }\n+    }\n+    return amResourceRequests;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cResourceRequest\u003e generateResourceRequests() throws IOException {\n    Resource capability \u003d recordFactory.newRecordInstance(Resource.class);\n    capability.setMemorySize(\n        conf.getInt(\n            MRJobConfig.MR_AM_VMEM_MB, MRJobConfig.DEFAULT_MR_AM_VMEM_MB\n        )\n    );\n    capability.setVirtualCores(\n        conf.getInt(\n            MRJobConfig.MR_AM_CPU_VCORES, MRJobConfig.DEFAULT_MR_AM_CPU_VCORES\n        )\n    );\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"AppMaster capability \u003d \" + capability);\n    }\n\n    List\u003cResourceRequest\u003e amResourceRequests \u003d new ArrayList\u003c\u003e();\n    // Always have an ANY request\n    ResourceRequest amAnyResourceRequest \u003d\n        createAMResourceRequest(ResourceRequest.ANY, capability);\n    Map\u003cString, ResourceRequest\u003e rackRequests \u003d new HashMap\u003c\u003e();\n    amResourceRequests.add(amAnyResourceRequest);\n    Collection\u003cString\u003e amStrictResources \u003d conf.getStringCollection(\n        MRJobConfig.AM_STRICT_LOCALITY);\n    for (String amStrictResource : amStrictResources) {\n      amAnyResourceRequest.setRelaxLocality(false);\n      Matcher matcher \u003d RACK_NODE_PATTERN.matcher(amStrictResource);\n      if (matcher.matches()) {\n        String nodeName;\n        String rackName \u003d matcher.group(RACK_GROUP);\n        if (rackName \u003d\u003d null) {\n          rackName \u003d \"/default-rack\";\n          nodeName \u003d matcher.group(NODE_IF_NO_RACK_GROUP);\n        } else {\n          nodeName \u003d matcher.group(NODE_IF_RACK_GROUP);\n        }\n        ResourceRequest amRackResourceRequest \u003d rackRequests.get(rackName);\n        if (amRackResourceRequest \u003d\u003d null) {\n          amRackResourceRequest \u003d createAMResourceRequest(rackName, capability);\n          amResourceRequests.add(amRackResourceRequest);\n          rackRequests.put(rackName, amRackResourceRequest);\n        }\n        if (nodeName !\u003d null) {\n          amRackResourceRequest.setRelaxLocality(false);\n          ResourceRequest amNodeResourceRequest \u003d\n              createAMResourceRequest(nodeName, capability);\n          amResourceRequests.add(amNodeResourceRequest);\n        }\n      } else {\n        String errMsg \u003d\n            \"Invalid resource name: \" + amStrictResource + \" specified.\";\n        LOG.warn(errMsg);\n        throw new IOException(errMsg);\n      }\n    }\n    if (LOG.isDebugEnabled()) {\n      for (ResourceRequest amResourceRequest : amResourceRequests) {\n        LOG.debug(\"ResourceRequest: resource \u003d \"\n            + amResourceRequest.getResourceName() + \", locality \u003d \"\n            + amResourceRequest.getRelaxLocality());\n      }\n    }\n    return amResourceRequests;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/main/java/org/apache/hadoop/mapred/YARNRunner.java"
    }
  }
}