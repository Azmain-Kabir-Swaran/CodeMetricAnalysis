{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FairScheduler.java",
  "functionName": "addApplicationAttempt",
  "functionId": "addApplicationAttempt___applicationAttemptId-ApplicationAttemptId__transferStateFromPreviousAttempt-boolean__isAttemptRecovering-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
  "functionStartLine": 586,
  "functionEndLine": 629,
  "numCommitsSeen": 661,
  "timeTaken": 10061,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030",
    "59ee8b7a88603e94b5661a8d5d088f7aa99fe049",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "486e718fc1f5befd231494e2ec06bb360484f191",
    "bda23181bf1931c37d2590e03da9acdc6688ad34",
    "c3f1c30e65cc6a10928299f50801782ecbb4ccb6",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
    "f677175f35f68bde9df72e648dffacbd31cfd620",
    "1393581bceda234c88cafec00dbfc0ef2a402e83",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
    "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
    "791e43c53b0be23b03d9b3f7d45a0df615eb90da",
    "38c32ed239d45051f5e4a51e3f29b201c17a4288",
    "7545d8bf996e5d060d5d613bf769ec52a62d428b",
    "3858b9018e3c2f4b883b02021679852591b706f7",
    "ac2cdb5f6586cc3358ea4fc818f477959d2daa38",
    "1c5b49eeafc2253d4fa92456e6ccf0f35290c889",
    "ca35ed13bfdcbcf6fdfc58f83f1f182786bb3b22",
    "171493215889a3b6bf2f6ba33212c4f06861a189",
    "345bcee0664392323b4297c0797897a96fef8958",
    "19a291a0d65b64e50571c3519414b9d54acbe28a",
    "5014a4b133000648e25ca7a801e2f23baa2273f5",
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21",
    "1943fdbec613715f3cdc3ca60cbd273115f28299",
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030": "Ybodychange",
    "59ee8b7a88603e94b5661a8d5d088f7aa99fe049": "Ybodychange",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ymultichange(Ymodifierchange,Ybodychange)",
    "486e718fc1f5befd231494e2ec06bb360484f191": "Ybodychange",
    "bda23181bf1931c37d2590e03da9acdc6688ad34": "Ymultichange(Yparameterchange,Ybodychange)",
    "c3f1c30e65cc6a10928299f50801782ecbb4ccb6": "Ymultichange(Yparameterchange,Ybodychange)",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": "Ybodychange",
    "f677175f35f68bde9df72e648dffacbd31cfd620": "Ybodychange",
    "1393581bceda234c88cafec00dbfc0ef2a402e83": "Ymultichange(Yparameterchange,Ybodychange)",
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": "Ymultichange(Yparameterchange,Ybodychange)",
    "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3": "Yrename",
    "791e43c53b0be23b03d9b3f7d45a0df615eb90da": "Yrename",
    "38c32ed239d45051f5e4a51e3f29b201c17a4288": "Yrename",
    "7545d8bf996e5d060d5d613bf769ec52a62d428b": "Ybodychange",
    "3858b9018e3c2f4b883b02021679852591b706f7": "Ybodychange",
    "ac2cdb5f6586cc3358ea4fc818f477959d2daa38": "Ybodychange",
    "1c5b49eeafc2253d4fa92456e6ccf0f35290c889": "Ybodychange",
    "ca35ed13bfdcbcf6fdfc58f83f1f182786bb3b22": "Ybodychange",
    "171493215889a3b6bf2f6ba33212c4f06861a189": "Ybodychange",
    "345bcee0664392323b4297c0797897a96fef8958": "Ybodychange",
    "19a291a0d65b64e50571c3519414b9d54acbe28a": "Ybodychange",
    "5014a4b133000648e25ca7a801e2f23baa2273f5": "Ybodychange",
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21": "Ybodychange",
    "1943fdbec613715f3cdc3ca60cbd273115f28299": "Ybodychange",
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.76,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,44 @@\n   protected void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       boolean transferStateFromPreviousAttempt,\n       boolean isAttemptRecovering) {\n     writeLock.lock();\n     try {\n       SchedulerApplication\u003cFSAppAttempt\u003e application \u003d applications.get(\n           applicationAttemptId.getApplicationId());\n       String user \u003d application.getUser();\n       FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n       FSAppAttempt attempt \u003d new FSAppAttempt(this, applicationAttemptId, user,\n           queue, new ActiveUsersManager(getRootQueueMetrics()), rmContext);\n       if (transferStateFromPreviousAttempt) {\n         attempt.transferStateFromPreviousAttempt(\n             application.getCurrentAppAttempt());\n       }\n       application.setCurrentAppAttempt(attempt);\n \n       boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, attempt);\n       queue.addApp(attempt, runnable);\n       if (runnable) {\n         maxRunningEnforcer.trackRunnableApp(attempt);\n       } else{\n         maxRunningEnforcer.trackNonRunnableApp(attempt);\n       }\n \n       queue.getMetrics().submitAppAttempt(user);\n \n       LOG.info(\"Added Application Attempt \" + applicationAttemptId\n           + \" to scheduler from user: \" + user);\n \n       if (isAttemptRecovering) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(applicationAttemptId\n-              + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n-        }\n+        LOG.debug(\"{} is recovering. Skipping notifying ATTEMPT_ADDED\",\n+            applicationAttemptId);\n       } else{\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppAttemptEvent(applicationAttemptId,\n                 RMAppAttemptEventType.ATTEMPT_ADDED));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt,\n      boolean isAttemptRecovering) {\n    writeLock.lock();\n    try {\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d applications.get(\n          applicationAttemptId.getApplicationId());\n      String user \u003d application.getUser();\n      FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n      FSAppAttempt attempt \u003d new FSAppAttempt(this, applicationAttemptId, user,\n          queue, new ActiveUsersManager(getRootQueueMetrics()), rmContext);\n      if (transferStateFromPreviousAttempt) {\n        attempt.transferStateFromPreviousAttempt(\n            application.getCurrentAppAttempt());\n      }\n      application.setCurrentAppAttempt(attempt);\n\n      boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, attempt);\n      queue.addApp(attempt, runnable);\n      if (runnable) {\n        maxRunningEnforcer.trackRunnableApp(attempt);\n      } else{\n        maxRunningEnforcer.trackNonRunnableApp(attempt);\n      }\n\n      queue.getMetrics().submitAppAttempt(user);\n\n      LOG.info(\"Added Application Attempt \" + applicationAttemptId\n          + \" to scheduler from user: \" + user);\n\n      if (isAttemptRecovering) {\n        LOG.debug(\"{} is recovering. Skipping notifying ATTEMPT_ADDED\",\n            applicationAttemptId);\n      } else{\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppAttemptEvent(applicationAttemptId,\n                RMAppAttemptEventType.ATTEMPT_ADDED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7133. Clean up lock-try order in fair scheduler. (Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "24/07/18 12:46 PM",
      "commitName": "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "11/06/18 11:12 AM",
      "commitNameOld": "c190ac2be88e574b3322cdc73a7c0af0cef708b2",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 43.07,
      "commitsBetweenForRepo": 266,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   protected void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       boolean transferStateFromPreviousAttempt,\n       boolean isAttemptRecovering) {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       SchedulerApplication\u003cFSAppAttempt\u003e application \u003d applications.get(\n           applicationAttemptId.getApplicationId());\n       String user \u003d application.getUser();\n       FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n       FSAppAttempt attempt \u003d new FSAppAttempt(this, applicationAttemptId, user,\n           queue, new ActiveUsersManager(getRootQueueMetrics()), rmContext);\n       if (transferStateFromPreviousAttempt) {\n         attempt.transferStateFromPreviousAttempt(\n             application.getCurrentAppAttempt());\n       }\n       application.setCurrentAppAttempt(attempt);\n \n       boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, attempt);\n       queue.addApp(attempt, runnable);\n       if (runnable) {\n         maxRunningEnforcer.trackRunnableApp(attempt);\n       } else{\n         maxRunningEnforcer.trackNonRunnableApp(attempt);\n       }\n \n       queue.getMetrics().submitAppAttempt(user);\n \n       LOG.info(\"Added Application Attempt \" + applicationAttemptId\n           + \" to scheduler from user: \" + user);\n \n       if (isAttemptRecovering) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(applicationAttemptId\n               + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n         }\n       } else{\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppAttemptEvent(applicationAttemptId,\n                 RMAppAttemptEventType.ATTEMPT_ADDED));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt,\n      boolean isAttemptRecovering) {\n    writeLock.lock();\n    try {\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d applications.get(\n          applicationAttemptId.getApplicationId());\n      String user \u003d application.getUser();\n      FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n      FSAppAttempt attempt \u003d new FSAppAttempt(this, applicationAttemptId, user,\n          queue, new ActiveUsersManager(getRootQueueMetrics()), rmContext);\n      if (transferStateFromPreviousAttempt) {\n        attempt.transferStateFromPreviousAttempt(\n            application.getCurrentAppAttempt());\n      }\n      application.setCurrentAppAttempt(attempt);\n\n      boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, attempt);\n      queue.addApp(attempt, runnable);\n      if (runnable) {\n        maxRunningEnforcer.trackRunnableApp(attempt);\n      } else{\n        maxRunningEnforcer.trackNonRunnableApp(attempt);\n      }\n\n      queue.getMetrics().submitAppAttempt(user);\n\n      LOG.info(\"Added Application Attempt \" + applicationAttemptId\n          + \" to scheduler from user: \" + user);\n\n      if (isAttemptRecovering) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(applicationAttemptId\n              + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n        }\n      } else{\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppAttemptEvent(applicationAttemptId,\n                RMAppAttemptEventType.ATTEMPT_ADDED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "59ee8b7a88603e94b5661a8d5d088f7aa99fe049": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4329. [YARN-5437] Allow fetching exact reason as to why a submitted app\nis in ACCEPTED state in Fair Scheduler (Contributed by Yufei Gu)\n",
      "commitDate": "09/11/16 1:11 PM",
      "commitName": "59ee8b7a88603e94b5661a8d5d088f7aa99fe049",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "20/10/16 9:17 PM",
      "commitNameOld": "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 19.7,
      "commitsBetweenForRepo": 216,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   protected void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       boolean transferStateFromPreviousAttempt,\n       boolean isAttemptRecovering) {\n     try {\n       writeLock.lock();\n       SchedulerApplication\u003cFSAppAttempt\u003e application \u003d applications.get(\n           applicationAttemptId.getApplicationId());\n       String user \u003d application.getUser();\n       FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n       FSAppAttempt attempt \u003d new FSAppAttempt(this, applicationAttemptId, user,\n           queue, new ActiveUsersManager(getRootQueueMetrics()), rmContext);\n       if (transferStateFromPreviousAttempt) {\n         attempt.transferStateFromPreviousAttempt(\n             application.getCurrentAppAttempt());\n       }\n       application.setCurrentAppAttempt(attempt);\n \n-      boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n+      boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, attempt);\n       queue.addApp(attempt, runnable);\n       if (runnable) {\n         maxRunningEnforcer.trackRunnableApp(attempt);\n       } else{\n         maxRunningEnforcer.trackNonRunnableApp(attempt);\n       }\n \n       queue.getMetrics().submitAppAttempt(user);\n \n       LOG.info(\"Added Application Attempt \" + applicationAttemptId\n           + \" to scheduler from user: \" + user);\n \n       if (isAttemptRecovering) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(applicationAttemptId\n               + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n         }\n       } else{\n         rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppAttemptEvent(applicationAttemptId,\n                 RMAppAttemptEventType.ATTEMPT_ADDED));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt,\n      boolean isAttemptRecovering) {\n    try {\n      writeLock.lock();\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d applications.get(\n          applicationAttemptId.getApplicationId());\n      String user \u003d application.getUser();\n      FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n      FSAppAttempt attempt \u003d new FSAppAttempt(this, applicationAttemptId, user,\n          queue, new ActiveUsersManager(getRootQueueMetrics()), rmContext);\n      if (transferStateFromPreviousAttempt) {\n        attempt.transferStateFromPreviousAttempt(\n            application.getCurrentAppAttempt());\n      }\n      application.setCurrentAppAttempt(attempt);\n\n      boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, attempt);\n      queue.addApp(attempt, runnable);\n      if (runnable) {\n        maxRunningEnforcer.trackRunnableApp(attempt);\n      } else{\n        maxRunningEnforcer.trackNonRunnableApp(attempt);\n      }\n\n      queue.getMetrics().submitAppAttempt(user);\n\n      LOG.info(\"Added Application Attempt \" + applicationAttemptId\n          + \" to scheduler from user: \" + user);\n\n      if (isAttemptRecovering) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(applicationAttemptId\n              + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n        }\n      } else{\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppAttemptEvent(applicationAttemptId,\n                RMAppAttemptEventType.ATTEMPT_ADDED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "03/10/16 6:03 AM",
          "commitNameOld": "0da54e8848764c71a31473516d23ada582013f8c",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,46 @@\n-  protected synchronized void addApplicationAttempt(\n+  protected void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       boolean transferStateFromPreviousAttempt,\n       boolean isAttemptRecovering) {\n-    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n-        applications.get(applicationAttemptId.getApplicationId());\n-    String user \u003d application.getUser();\n-    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n+    try {\n+      writeLock.lock();\n+      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d applications.get(\n+          applicationAttemptId.getApplicationId());\n+      String user \u003d application.getUser();\n+      FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n-    FSAppAttempt attempt \u003d\n-        new FSAppAttempt(this, applicationAttemptId, user,\n-            queue, new ActiveUsersManager(getRootQueueMetrics()),\n-            rmContext);\n-    if (transferStateFromPreviousAttempt) {\n-      attempt.transferStateFromPreviousAttempt(application\n-          .getCurrentAppAttempt());\n-    }\n-    application.setCurrentAppAttempt(attempt);\n-\n-    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n-    queue.addApp(attempt, runnable);\n-    if (runnable) {\n-      maxRunningEnforcer.trackRunnableApp(attempt);\n-    } else {\n-      maxRunningEnforcer.trackNonRunnableApp(attempt);\n-    }\n-    \n-    queue.getMetrics().submitAppAttempt(user);\n-\n-    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n-        + \" to scheduler from user: \" + user);\n-\n-    if (isAttemptRecovering) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(applicationAttemptId\n-            + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n+      FSAppAttempt attempt \u003d new FSAppAttempt(this, applicationAttemptId, user,\n+          queue, new ActiveUsersManager(getRootQueueMetrics()), rmContext);\n+      if (transferStateFromPreviousAttempt) {\n+        attempt.transferStateFromPreviousAttempt(\n+            application.getCurrentAppAttempt());\n       }\n-    } else {\n-      rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptEvent(applicationAttemptId,\n-            RMAppAttemptEventType.ATTEMPT_ADDED));\n+      application.setCurrentAppAttempt(attempt);\n+\n+      boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n+      queue.addApp(attempt, runnable);\n+      if (runnable) {\n+        maxRunningEnforcer.trackRunnableApp(attempt);\n+      } else{\n+        maxRunningEnforcer.trackNonRunnableApp(attempt);\n+      }\n+\n+      queue.getMetrics().submitAppAttempt(user);\n+\n+      LOG.info(\"Added Application Attempt \" + applicationAttemptId\n+          + \" to scheduler from user: \" + user);\n+\n+      if (isAttemptRecovering) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(applicationAttemptId\n+              + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n+        }\n+      } else{\n+        rmContext.getDispatcher().getEventHandler().handle(\n+            new RMAppAttemptEvent(applicationAttemptId,\n+                RMAppAttemptEventType.ATTEMPT_ADDED));\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt,\n      boolean isAttemptRecovering) {\n    try {\n      writeLock.lock();\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d applications.get(\n          applicationAttemptId.getApplicationId());\n      String user \u003d application.getUser();\n      FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n      FSAppAttempt attempt \u003d new FSAppAttempt(this, applicationAttemptId, user,\n          queue, new ActiveUsersManager(getRootQueueMetrics()), rmContext);\n      if (transferStateFromPreviousAttempt) {\n        attempt.transferStateFromPreviousAttempt(\n            application.getCurrentAppAttempt());\n      }\n      application.setCurrentAppAttempt(attempt);\n\n      boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n      queue.addApp(attempt, runnable);\n      if (runnable) {\n        maxRunningEnforcer.trackRunnableApp(attempt);\n      } else{\n        maxRunningEnforcer.trackNonRunnableApp(attempt);\n      }\n\n      queue.getMetrics().submitAppAttempt(user);\n\n      LOG.info(\"Added Application Attempt \" + applicationAttemptId\n          + \" to scheduler from user: \" + user);\n\n      if (isAttemptRecovering) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(applicationAttemptId\n              + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n        }\n      } else{\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppAttemptEvent(applicationAttemptId,\n                RMAppAttemptEventType.ATTEMPT_ADDED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[protected, synchronized]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "03/10/16 6:03 AM",
          "commitNameOld": "0da54e8848764c71a31473516d23ada582013f8c",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,46 @@\n-  protected synchronized void addApplicationAttempt(\n+  protected void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       boolean transferStateFromPreviousAttempt,\n       boolean isAttemptRecovering) {\n-    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n-        applications.get(applicationAttemptId.getApplicationId());\n-    String user \u003d application.getUser();\n-    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n+    try {\n+      writeLock.lock();\n+      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d applications.get(\n+          applicationAttemptId.getApplicationId());\n+      String user \u003d application.getUser();\n+      FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n-    FSAppAttempt attempt \u003d\n-        new FSAppAttempt(this, applicationAttemptId, user,\n-            queue, new ActiveUsersManager(getRootQueueMetrics()),\n-            rmContext);\n-    if (transferStateFromPreviousAttempt) {\n-      attempt.transferStateFromPreviousAttempt(application\n-          .getCurrentAppAttempt());\n-    }\n-    application.setCurrentAppAttempt(attempt);\n-\n-    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n-    queue.addApp(attempt, runnable);\n-    if (runnable) {\n-      maxRunningEnforcer.trackRunnableApp(attempt);\n-    } else {\n-      maxRunningEnforcer.trackNonRunnableApp(attempt);\n-    }\n-    \n-    queue.getMetrics().submitAppAttempt(user);\n-\n-    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n-        + \" to scheduler from user: \" + user);\n-\n-    if (isAttemptRecovering) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(applicationAttemptId\n-            + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n+      FSAppAttempt attempt \u003d new FSAppAttempt(this, applicationAttemptId, user,\n+          queue, new ActiveUsersManager(getRootQueueMetrics()), rmContext);\n+      if (transferStateFromPreviousAttempt) {\n+        attempt.transferStateFromPreviousAttempt(\n+            application.getCurrentAppAttempt());\n       }\n-    } else {\n-      rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptEvent(applicationAttemptId,\n-            RMAppAttemptEventType.ATTEMPT_ADDED));\n+      application.setCurrentAppAttempt(attempt);\n+\n+      boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n+      queue.addApp(attempt, runnable);\n+      if (runnable) {\n+        maxRunningEnforcer.trackRunnableApp(attempt);\n+      } else{\n+        maxRunningEnforcer.trackNonRunnableApp(attempt);\n+      }\n+\n+      queue.getMetrics().submitAppAttempt(user);\n+\n+      LOG.info(\"Added Application Attempt \" + applicationAttemptId\n+          + \" to scheduler from user: \" + user);\n+\n+      if (isAttemptRecovering) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(applicationAttemptId\n+              + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n+        }\n+      } else{\n+        rmContext.getDispatcher().getEventHandler().handle(\n+            new RMAppAttemptEvent(applicationAttemptId,\n+                RMAppAttemptEventType.ATTEMPT_ADDED));\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt,\n      boolean isAttemptRecovering) {\n    try {\n      writeLock.lock();\n      SchedulerApplication\u003cFSAppAttempt\u003e application \u003d applications.get(\n          applicationAttemptId.getApplicationId());\n      String user \u003d application.getUser();\n      FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n      FSAppAttempt attempt \u003d new FSAppAttempt(this, applicationAttemptId, user,\n          queue, new ActiveUsersManager(getRootQueueMetrics()), rmContext);\n      if (transferStateFromPreviousAttempt) {\n        attempt.transferStateFromPreviousAttempt(\n            application.getCurrentAppAttempt());\n      }\n      application.setCurrentAppAttempt(attempt);\n\n      boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n      queue.addApp(attempt, runnable);\n      if (runnable) {\n        maxRunningEnforcer.trackRunnableApp(attempt);\n      } else{\n        maxRunningEnforcer.trackNonRunnableApp(attempt);\n      }\n\n      queue.getMetrics().submitAppAttempt(user);\n\n      LOG.info(\"Added Application Attempt \" + applicationAttemptId\n          + \" to scheduler from user: \" + user);\n\n      if (isAttemptRecovering) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(applicationAttemptId\n              + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n        }\n      } else{\n        rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppAttemptEvent(applicationAttemptId,\n                RMAppAttemptEventType.ATTEMPT_ADDED));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "486e718fc1f5befd231494e2ec06bb360484f191": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2399. FairScheduler: Merge AppSchedulable and FSSchedulerApp into FSAppAttempt. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617600 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 2:43 PM",
      "commitName": "486e718fc1f5befd231494e2ec06bb360484f191",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "08/08/14 7:17 AM",
      "commitNameOld": "14864e9c7c879c15b5fa2d1776614ec83152918f",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 4.31,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   protected synchronized void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       boolean transferStateFromPreviousAttempt,\n       boolean isAttemptRecovering) {\n-    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n+    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     String user \u003d application.getUser();\n     FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n-    FSSchedulerApp attempt \u003d\n-        new FSSchedulerApp(applicationAttemptId, user,\n+    FSAppAttempt attempt \u003d\n+        new FSAppAttempt(this, applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n     if (transferStateFromPreviousAttempt) {\n       attempt.transferStateFromPreviousAttempt(application\n           .getCurrentAppAttempt());\n     }\n     application.setCurrentAppAttempt(attempt);\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(attempt, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(attempt);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(attempt);\n     }\n     \n     queue.getMetrics().submitAppAttempt(user);\n \n     LOG.info(\"Added Application Attempt \" + applicationAttemptId\n         + \" to scheduler from user: \" + user);\n \n     if (isAttemptRecovering) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(applicationAttemptId\n             + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n       }\n     } else {\n       rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.ATTEMPT_ADDED));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt,\n      boolean isAttemptRecovering) {\n    SchedulerApplication\u003cFSAppAttempt\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    String user \u003d application.getUser();\n    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n    FSAppAttempt attempt \u003d\n        new FSAppAttempt(this, applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    if (transferStateFromPreviousAttempt) {\n      attempt.transferStateFromPreviousAttempt(application\n          .getCurrentAppAttempt());\n    }\n    application.setCurrentAppAttempt(attempt);\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(attempt, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(attempt);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(attempt);\n    }\n    \n    queue.getMetrics().submitAppAttempt(user);\n\n    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n        + \" to scheduler from user: \" + user);\n\n    if (isAttemptRecovering) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(applicationAttemptId\n            + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n      }\n    } else {\n      rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.ATTEMPT_ADDED));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "bda23181bf1931c37d2590e03da9acdc6688ad34": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2219. Changed ResourceManager to avoid AMs and NMs getting exceptions after RM recovery but before scheduler learns about apps and app-attempts. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611222 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/14 5:14 PM",
      "commitName": "bda23181bf1931c37d2590e03da9acdc6688ad34",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2219. Changed ResourceManager to avoid AMs and NMs getting exceptions after RM recovery but before scheduler learns about apps and app-attempts. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611222 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/14 5:14 PM",
          "commitName": "bda23181bf1931c37d2590e03da9acdc6688ad34",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "15/07/14 2:48 PM",
          "commitNameOld": "43589a8df70d4dbaf86609961e27cc4e23dda993",
          "commitAuthorOld": "Mayank Bansal",
          "daysBetweenCommits": 1.1,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,43 @@\n   protected synchronized void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       boolean transferStateFromPreviousAttempt,\n-      boolean shouldNotifyAttemptAdded) {\n+      boolean isAttemptRecovering) {\n     SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     String user \u003d application.getUser();\n     FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n     FSSchedulerApp attempt \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n     if (transferStateFromPreviousAttempt) {\n       attempt.transferStateFromPreviousAttempt(application\n         .getCurrentAppAttempt());\n     }\n     application.setCurrentAppAttempt(attempt);\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(attempt, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(attempt);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(attempt);\n     }\n     \n     queue.getMetrics().submitAppAttempt(user);\n \n     LOG.info(\"Added Application Attempt \" + applicationAttemptId\n         + \" to scheduler from user: \" + user);\n \n-    if (shouldNotifyAttemptAdded) {\n-      rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppAttemptEvent(applicationAttemptId,\n-              RMAppAttemptEventType.ATTEMPT_ADDED));\n-    } else {\n+    if (isAttemptRecovering) {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Skipping notifying ATTEMPT_ADDED\");\n+        LOG.debug(applicationAttemptId\n+            + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n       }\n+    } else {\n+      rmContext.getDispatcher().getEventHandler().handle(\n+        new RMAppAttemptEvent(applicationAttemptId,\n+            RMAppAttemptEventType.ATTEMPT_ADDED));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt,\n      boolean isAttemptRecovering) {\n    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    String user \u003d application.getUser();\n    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n    FSSchedulerApp attempt \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    if (transferStateFromPreviousAttempt) {\n      attempt.transferStateFromPreviousAttempt(application\n        .getCurrentAppAttempt());\n    }\n    application.setCurrentAppAttempt(attempt);\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(attempt, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(attempt);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(attempt);\n    }\n    \n    queue.getMetrics().submitAppAttempt(user);\n\n    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n        + \" to scheduler from user: \" + user);\n\n    if (isAttemptRecovering) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(applicationAttemptId\n            + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n      }\n    } else {\n      rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.ATTEMPT_ADDED));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[applicationAttemptId-ApplicationAttemptId, transferStateFromPreviousAttempt-boolean, shouldNotifyAttemptAdded-boolean]",
            "newValue": "[applicationAttemptId-ApplicationAttemptId, transferStateFromPreviousAttempt-boolean, isAttemptRecovering-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2219. Changed ResourceManager to avoid AMs and NMs getting exceptions after RM recovery but before scheduler learns about apps and app-attempts. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611222 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/14 5:14 PM",
          "commitName": "bda23181bf1931c37d2590e03da9acdc6688ad34",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "15/07/14 2:48 PM",
          "commitNameOld": "43589a8df70d4dbaf86609961e27cc4e23dda993",
          "commitAuthorOld": "Mayank Bansal",
          "daysBetweenCommits": 1.1,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,43 @@\n   protected synchronized void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       boolean transferStateFromPreviousAttempt,\n-      boolean shouldNotifyAttemptAdded) {\n+      boolean isAttemptRecovering) {\n     SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     String user \u003d application.getUser();\n     FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n     FSSchedulerApp attempt \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n     if (transferStateFromPreviousAttempt) {\n       attempt.transferStateFromPreviousAttempt(application\n         .getCurrentAppAttempt());\n     }\n     application.setCurrentAppAttempt(attempt);\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(attempt, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(attempt);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(attempt);\n     }\n     \n     queue.getMetrics().submitAppAttempt(user);\n \n     LOG.info(\"Added Application Attempt \" + applicationAttemptId\n         + \" to scheduler from user: \" + user);\n \n-    if (shouldNotifyAttemptAdded) {\n-      rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppAttemptEvent(applicationAttemptId,\n-              RMAppAttemptEventType.ATTEMPT_ADDED));\n-    } else {\n+    if (isAttemptRecovering) {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Skipping notifying ATTEMPT_ADDED\");\n+        LOG.debug(applicationAttemptId\n+            + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n       }\n+    } else {\n+      rmContext.getDispatcher().getEventHandler().handle(\n+        new RMAppAttemptEvent(applicationAttemptId,\n+            RMAppAttemptEventType.ATTEMPT_ADDED));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt,\n      boolean isAttemptRecovering) {\n    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    String user \u003d application.getUser();\n    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n    FSSchedulerApp attempt \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    if (transferStateFromPreviousAttempt) {\n      attempt.transferStateFromPreviousAttempt(application\n        .getCurrentAppAttempt());\n    }\n    application.setCurrentAppAttempt(attempt);\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(attempt, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(attempt);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(attempt);\n    }\n    \n    queue.getMetrics().submitAppAttempt(user);\n\n    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n        + \" to scheduler from user: \" + user);\n\n    if (isAttemptRecovering) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(applicationAttemptId\n            + \" is recovering. Skipping notifying ATTEMPT_ADDED\");\n      }\n    } else {\n      rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.ATTEMPT_ADDED));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "c3f1c30e65cc6a10928299f50801782ecbb4ccb6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1365. Changed ApplicationMasterService to allow an app to re-register after RM restart. Contributed by Anubhav Dhoot\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605263 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/06/14 9:42 PM",
      "commitName": "c3f1c30e65cc6a10928299f50801782ecbb4ccb6",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1365. Changed ApplicationMasterService to allow an app to re-register after RM restart. Contributed by Anubhav Dhoot\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605263 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "24/06/14 9:42 PM",
          "commitName": "c3f1c30e65cc6a10928299f50801782ecbb4ccb6",
          "commitAuthor": "Jian He",
          "commitDateOld": "24/06/14 8:40 AM",
          "commitNameOld": "29c102cad01b8a91cbf5173ca49d2e1ed8a45eee",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 0.54,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,42 @@\n   protected synchronized void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n-      boolean transferStateFromPreviousAttempt) {\n+      boolean transferStateFromPreviousAttempt,\n+      boolean shouldNotifyAttemptAdded) {\n     SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     String user \u003d application.getUser();\n     FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n     FSSchedulerApp attempt \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n     if (transferStateFromPreviousAttempt) {\n       attempt.transferStateFromPreviousAttempt(application\n         .getCurrentAppAttempt());\n     }\n     application.setCurrentAppAttempt(attempt);\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(attempt, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(attempt);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(attempt);\n     }\n     \n     queue.getMetrics().submitAppAttempt(user);\n \n     LOG.info(\"Added Application Attempt \" + applicationAttemptId\n         + \" to scheduler from user: \" + user);\n-    rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptEvent(applicationAttemptId,\n-            RMAppAttemptEventType.ATTEMPT_ADDED));\n+\n+    if (shouldNotifyAttemptAdded) {\n+      rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppAttemptEvent(applicationAttemptId,\n+              RMAppAttemptEventType.ATTEMPT_ADDED));\n+    } else {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Skipping notifying ATTEMPT_ADDED\");\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt,\n      boolean shouldNotifyAttemptAdded) {\n    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    String user \u003d application.getUser();\n    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n    FSSchedulerApp attempt \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    if (transferStateFromPreviousAttempt) {\n      attempt.transferStateFromPreviousAttempt(application\n        .getCurrentAppAttempt());\n    }\n    application.setCurrentAppAttempt(attempt);\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(attempt, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(attempt);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(attempt);\n    }\n    \n    queue.getMetrics().submitAppAttempt(user);\n\n    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n        + \" to scheduler from user: \" + user);\n\n    if (shouldNotifyAttemptAdded) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptEvent(applicationAttemptId,\n              RMAppAttemptEventType.ATTEMPT_ADDED));\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skipping notifying ATTEMPT_ADDED\");\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[applicationAttemptId-ApplicationAttemptId, transferStateFromPreviousAttempt-boolean]",
            "newValue": "[applicationAttemptId-ApplicationAttemptId, transferStateFromPreviousAttempt-boolean, shouldNotifyAttemptAdded-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1365. Changed ApplicationMasterService to allow an app to re-register after RM restart. Contributed by Anubhav Dhoot\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605263 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "24/06/14 9:42 PM",
          "commitName": "c3f1c30e65cc6a10928299f50801782ecbb4ccb6",
          "commitAuthor": "Jian He",
          "commitDateOld": "24/06/14 8:40 AM",
          "commitNameOld": "29c102cad01b8a91cbf5173ca49d2e1ed8a45eee",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 0.54,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,42 @@\n   protected synchronized void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n-      boolean transferStateFromPreviousAttempt) {\n+      boolean transferStateFromPreviousAttempt,\n+      boolean shouldNotifyAttemptAdded) {\n     SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     String user \u003d application.getUser();\n     FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n     FSSchedulerApp attempt \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n     if (transferStateFromPreviousAttempt) {\n       attempt.transferStateFromPreviousAttempt(application\n         .getCurrentAppAttempt());\n     }\n     application.setCurrentAppAttempt(attempt);\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(attempt, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(attempt);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(attempt);\n     }\n     \n     queue.getMetrics().submitAppAttempt(user);\n \n     LOG.info(\"Added Application Attempt \" + applicationAttemptId\n         + \" to scheduler from user: \" + user);\n-    rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptEvent(applicationAttemptId,\n-            RMAppAttemptEventType.ATTEMPT_ADDED));\n+\n+    if (shouldNotifyAttemptAdded) {\n+      rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppAttemptEvent(applicationAttemptId,\n+              RMAppAttemptEventType.ATTEMPT_ADDED));\n+    } else {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Skipping notifying ATTEMPT_ADDED\");\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt,\n      boolean shouldNotifyAttemptAdded) {\n    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    String user \u003d application.getUser();\n    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n    FSSchedulerApp attempt \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    if (transferStateFromPreviousAttempt) {\n      attempt.transferStateFromPreviousAttempt(application\n        .getCurrentAppAttempt());\n    }\n    application.setCurrentAppAttempt(attempt);\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(attempt, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(attempt);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(attempt);\n    }\n    \n    queue.getMetrics().submitAppAttempt(user);\n\n    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n        + \" to scheduler from user: \" + user);\n\n    if (shouldNotifyAttemptAdded) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptEvent(applicationAttemptId,\n              RMAppAttemptEventType.ATTEMPT_ADDED));\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Skipping notifying ATTEMPT_ADDED\");\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2017. Merged some of the common scheduler code. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 10:32 PM",
      "commitName": "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/03/14 4:40 PM",
      "commitNameOld": "7bd62b8da03642612fae8349e967b9c0aa290843",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 51.24,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   protected synchronized void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       boolean transferStateFromPreviousAttempt) {\n-    SchedulerApplication application \u003d\n+    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     String user \u003d application.getUser();\n     FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n     FSSchedulerApp attempt \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n     if (transferStateFromPreviousAttempt) {\n       attempt.transferStateFromPreviousAttempt(application\n         .getCurrentAppAttempt());\n     }\n     application.setCurrentAppAttempt(attempt);\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(attempt, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(attempt);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(attempt);\n     }\n     \n     queue.getMetrics().submitAppAttempt(user);\n \n     LOG.info(\"Added Application Attempt \" + applicationAttemptId\n         + \" to scheduler from user: \" + user);\n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.ATTEMPT_ADDED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt) {\n    SchedulerApplication\u003cFSSchedulerApp\u003e application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    String user \u003d application.getUser();\n    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n    FSSchedulerApp attempt \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    if (transferStateFromPreviousAttempt) {\n      attempt.transferStateFromPreviousAttempt(application\n        .getCurrentAppAttempt());\n    }\n    application.setCurrentAppAttempt(attempt);\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(attempt, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(attempt);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(attempt);\n    }\n    \n    queue.getMetrics().submitAppAttempt(user);\n\n    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n        + \" to scheduler from user: \" + user);\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.ATTEMPT_ADDED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "f677175f35f68bde9df72e648dffacbd31cfd620": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1166. Fixed app-specific and attempt-specific QueueMetrics to be triggered by accordingly app event and attempt event. Contributed by Zhijie Shen\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557296 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 5:15 PM",
      "commitName": "f677175f35f68bde9df72e648dffacbd31cfd620",
      "commitAuthor": "Jian He",
      "commitDateOld": "10/01/14 7:04 AM",
      "commitNameOld": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.42,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   protected synchronized void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId,\n       boolean transferStateFromPreviousAttempt) {\n     SchedulerApplication application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     String user \u003d application.getUser();\n     FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n     FSSchedulerApp attempt \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n     if (transferStateFromPreviousAttempt) {\n       attempt.transferStateFromPreviousAttempt(application\n         .getCurrentAppAttempt());\n     }\n     application.setCurrentAppAttempt(attempt);\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(attempt, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(attempt);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(attempt);\n     }\n     \n-    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n+    queue.getMetrics().submitAppAttempt(user);\n \n     LOG.info(\"Added Application Attempt \" + applicationAttemptId\n         + \" to scheduler from user: \" + user);\n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.ATTEMPT_ADDED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt) {\n    SchedulerApplication application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    String user \u003d application.getUser();\n    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n    FSSchedulerApp attempt \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    if (transferStateFromPreviousAttempt) {\n      attempt.transferStateFromPreviousAttempt(application\n        .getCurrentAppAttempt());\n    }\n    application.setCurrentAppAttempt(attempt);\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(attempt, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(attempt);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(attempt);\n    }\n    \n    queue.getMetrics().submitAppAttempt(user);\n\n    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n        + \" to scheduler from user: \" + user);\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.ATTEMPT_ADDED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1393581bceda234c88cafec00dbfc0ef2a402e83": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 7:04 AM",
      "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/01/14 7:04 AM",
          "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "02/01/14 12:19 PM",
          "commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 7.78,
          "commitsBetweenForRepo": 34,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,34 @@\n   protected synchronized void addApplicationAttempt(\n-      ApplicationAttemptId applicationAttemptId) {\n+      ApplicationAttemptId applicationAttemptId,\n+      boolean transferStateFromPreviousAttempt) {\n     SchedulerApplication application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     String user \u003d application.getUser();\n     FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n-    FSSchedulerApp schedulerApp \u003d\n+    FSSchedulerApp attempt \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n+    if (transferStateFromPreviousAttempt) {\n+      attempt.transferStateFromPreviousAttempt(application\n+        .getCurrentAppAttempt());\n+    }\n+    application.setCurrentAppAttempt(attempt);\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n-    queue.addApp(schedulerApp, runnable);\n+    queue.addApp(attempt, runnable);\n     if (runnable) {\n-      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n+      maxRunningEnforcer.trackRunnableApp(attempt);\n     } else {\n-      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n+      maxRunningEnforcer.trackNonRunnableApp(attempt);\n     }\n     \n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n-    appAttempts.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Added Application Attempt \" + applicationAttemptId\n-        + \" to scheduler from user: \" + user + \", currently active: \"\n-        + appAttempts.size());\n+        + \" to scheduler from user: \" + user);\n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.ATTEMPT_ADDED));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt) {\n    SchedulerApplication application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    String user \u003d application.getUser();\n    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n    FSSchedulerApp attempt \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    if (transferStateFromPreviousAttempt) {\n      attempt.transferStateFromPreviousAttempt(application\n        .getCurrentAppAttempt());\n    }\n    application.setCurrentAppAttempt(attempt);\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(attempt, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(attempt);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(attempt);\n    }\n    \n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n        + \" to scheduler from user: \" + user);\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.ATTEMPT_ADDED));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[applicationAttemptId-ApplicationAttemptId]",
            "newValue": "[applicationAttemptId-ApplicationAttemptId, transferStateFromPreviousAttempt-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/01/14 7:04 AM",
          "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "02/01/14 12:19 PM",
          "commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 7.78,
          "commitsBetweenForRepo": 34,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,34 @@\n   protected synchronized void addApplicationAttempt(\n-      ApplicationAttemptId applicationAttemptId) {\n+      ApplicationAttemptId applicationAttemptId,\n+      boolean transferStateFromPreviousAttempt) {\n     SchedulerApplication application \u003d\n         applications.get(applicationAttemptId.getApplicationId());\n     String user \u003d application.getUser();\n     FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n-    FSSchedulerApp schedulerApp \u003d\n+    FSSchedulerApp attempt \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n+    if (transferStateFromPreviousAttempt) {\n+      attempt.transferStateFromPreviousAttempt(application\n+        .getCurrentAppAttempt());\n+    }\n+    application.setCurrentAppAttempt(attempt);\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n-    queue.addApp(schedulerApp, runnable);\n+    queue.addApp(attempt, runnable);\n     if (runnable) {\n-      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n+      maxRunningEnforcer.trackRunnableApp(attempt);\n     } else {\n-      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n+      maxRunningEnforcer.trackNonRunnableApp(attempt);\n     }\n     \n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n-    appAttempts.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Added Application Attempt \" + applicationAttemptId\n-        + \" to scheduler from user: \" + user + \", currently active: \"\n-        + appAttempts.size());\n+        + \" to scheduler from user: \" + user);\n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.ATTEMPT_ADDED));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId,\n      boolean transferStateFromPreviousAttempt) {\n    SchedulerApplication application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    String user \u003d application.getUser();\n    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n    FSSchedulerApp attempt \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    if (transferStateFromPreviousAttempt) {\n      attempt.transferStateFromPreviousAttempt(application\n        .getCurrentAppAttempt());\n    }\n    application.setCurrentAppAttempt(attempt);\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(attempt, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(attempt);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(attempt);\n    }\n    \n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n        + \" to scheduler from user: \" + user);\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.ATTEMPT_ADDED));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1493. Changed ResourceManager and Scheduler interfacing to recognize app-attempts separately from apps. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/01/14 12:19 PM",
      "commitName": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1493. Changed ResourceManager and Scheduler interfacing to recognize app-attempts separately from apps. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554896 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/01/14 12:19 PM",
          "commitName": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "12/12/13 5:44 PM",
          "commitNameOld": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 20.77,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,30 @@\n   protected synchronized void addApplicationAttempt(\n-      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n-    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n-      String message \u003d \"Reject application \" + applicationAttemptId +\n-              \" submitted by user \" + user + \" with an empty queue name.\";\n-      LOG.info(message);\n-      rmContext.getDispatcher().getEventHandler().handle(\n-              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n-      return;\n-    }\n-\n-    RMApp rmApp \u003d rmContext.getRMApps().get(\n-        applicationAttemptId.getApplicationId());\n-    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n-    if (queue \u003d\u003d null) {\n-      rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppAttemptRejectedEvent(applicationAttemptId,\n-              \"Application rejected by queue placement policy\"));\n-      return;\n-    }\n+      ApplicationAttemptId applicationAttemptId) {\n+    SchedulerApplication application \u003d\n+        applications.get(applicationAttemptId.getApplicationId());\n+    String user \u003d application.getUser();\n+    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n-    // Enforce ACLs\n-    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n-\n-    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n-        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n-      String msg \u003d \"User \" + userUgi.getUserName() +\n-    \t        \" cannot submit applications to queue \" + queue.getName();\n-      LOG.info(msg);\n-      rmContext.getDispatcher().getEventHandler().handle(\n-    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n-      return;\n-    }\n-\n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(schedulerApp, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(schedulerApp);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n     }\n     \n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n+    appAttempts.put(applicationAttemptId, schedulerApp);\n \n-    applications.put(applicationAttemptId, schedulerApp);\n-\n-    LOG.info(\"Application Submission: \" + applicationAttemptId +\n-        \", user: \"+ user +\n-        \", currently active: \" + applications.size());\n-\n+    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n+        + \" to scheduler from user: \" + user + \", currently active: \"\n+        + appAttempts.size());\n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n-            RMAppAttemptEventType.APP_ACCEPTED));\n+            RMAppAttemptEventType.ATTEMPT_ADDED));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId) {\n    SchedulerApplication application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    String user \u003d application.getUser();\n    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(schedulerApp, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n    }\n    \n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n    appAttempts.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n        + \" to scheduler from user: \" + user + \", currently active: \"\n        + appAttempts.size());\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.ATTEMPT_ADDED));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[applicationAttemptId-ApplicationAttemptId, queueName-String, user-String]",
            "newValue": "[applicationAttemptId-ApplicationAttemptId]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1493. Changed ResourceManager and Scheduler interfacing to recognize app-attempts separately from apps. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554896 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/01/14 12:19 PM",
          "commitName": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "12/12/13 5:44 PM",
          "commitNameOld": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 20.77,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,30 @@\n   protected synchronized void addApplicationAttempt(\n-      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n-    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n-      String message \u003d \"Reject application \" + applicationAttemptId +\n-              \" submitted by user \" + user + \" with an empty queue name.\";\n-      LOG.info(message);\n-      rmContext.getDispatcher().getEventHandler().handle(\n-              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n-      return;\n-    }\n-\n-    RMApp rmApp \u003d rmContext.getRMApps().get(\n-        applicationAttemptId.getApplicationId());\n-    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n-    if (queue \u003d\u003d null) {\n-      rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppAttemptRejectedEvent(applicationAttemptId,\n-              \"Application rejected by queue placement policy\"));\n-      return;\n-    }\n+      ApplicationAttemptId applicationAttemptId) {\n+    SchedulerApplication application \u003d\n+        applications.get(applicationAttemptId.getApplicationId());\n+    String user \u003d application.getUser();\n+    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n-    // Enforce ACLs\n-    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n-\n-    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n-        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n-      String msg \u003d \"User \" + userUgi.getUserName() +\n-    \t        \" cannot submit applications to queue \" + queue.getName();\n-      LOG.info(msg);\n-      rmContext.getDispatcher().getEventHandler().handle(\n-    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n-      return;\n-    }\n-\n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(schedulerApp, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(schedulerApp);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n     }\n     \n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n+    appAttempts.put(applicationAttemptId, schedulerApp);\n \n-    applications.put(applicationAttemptId, schedulerApp);\n-\n-    LOG.info(\"Application Submission: \" + applicationAttemptId +\n-        \", user: \"+ user +\n-        \", currently active: \" + applications.size());\n-\n+    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n+        + \" to scheduler from user: \" + user + \", currently active: \"\n+        + appAttempts.size());\n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n-            RMAppAttemptEventType.APP_ACCEPTED));\n+            RMAppAttemptEventType.ATTEMPT_ADDED));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId) {\n    SchedulerApplication application \u003d\n        applications.get(applicationAttemptId.getApplicationId());\n    String user \u003d application.getUser();\n    FSLeafQueue queue \u003d (FSLeafQueue) application.getQueue();\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(schedulerApp, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n    }\n    \n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n    appAttempts.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Added Application Attempt \" + applicationAttemptId\n        + \" to scheduler from user: \" + user + \", currently active: \"\n        + appAttempts.size());\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.ATTEMPT_ADDED));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3": {
      "type": "Yrename",
      "commitMessage": "YARN-1311. Fixed app specific scheduler-events\u0027 names to be app-attempt based. Contributed by Vinod Kumar Vavilapalli\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550613 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 5:44 PM",
      "commitName": "28db28d491b4e3e3ddf440db4cebab8c0ad6b7f3",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/12/13 3:45 PM",
      "commitNameOld": "791e43c53b0be23b03d9b3f7d45a0df615eb90da",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n-  protected synchronized void addApplication(\n+  protected synchronized void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(\n         applicationAttemptId.getApplicationId());\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRejectedEvent(applicationAttemptId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(schedulerApp, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(schedulerApp);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n     }\n     \n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(\n        applicationAttemptId.getApplicationId());\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRejectedEvent(applicationAttemptId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(schedulerApp, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n    }\n    \n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "addApplication",
        "newValue": "addApplicationAttempt"
      }
    },
    "791e43c53b0be23b03d9b3f7d45a0df615eb90da": {
      "type": "Yrename",
      "commitMessage": "Reverting YARN-1311. Fixed app specific scheduler-events\u0027 names to be app-attempt based. Contributed by Vinod Kumar Vavilapalli\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550594 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 3:45 PM",
      "commitName": "791e43c53b0be23b03d9b3f7d45a0df615eb90da",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/12/13 3:07 PM",
      "commitNameOld": "38c32ed239d45051f5e4a51e3f29b201c17a4288",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n-  protected synchronized void addApplicationAttempt(\n+  protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(\n         applicationAttemptId.getApplicationId());\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRejectedEvent(applicationAttemptId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(schedulerApp, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(schedulerApp);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n     }\n     \n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(\n        applicationAttemptId.getApplicationId());\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRejectedEvent(applicationAttemptId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(schedulerApp, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n    }\n    \n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "addApplicationAttempt",
        "newValue": "addApplication"
      }
    },
    "38c32ed239d45051f5e4a51e3f29b201c17a4288": {
      "type": "Yrename",
      "commitMessage": "YARN-1311. Fixed app specific scheduler-events\u0027 names to be app-attempt based. Contributed by Vinod Kumar Vavilapalli\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550579 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/12/13 3:07 PM",
      "commitName": "38c32ed239d45051f5e4a51e3f29b201c17a4288",
      "commitAuthor": "Jian He",
      "commitDateOld": "07/12/13 7:09 PM",
      "commitNameOld": "e1d3670f4c233696dc673c37b578ce46b44a6876",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n-  protected synchronized void addApplication(\n+  protected synchronized void addApplicationAttempt(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(\n         applicationAttemptId.getApplicationId());\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRejectedEvent(applicationAttemptId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n \n     boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n     queue.addApp(schedulerApp, runnable);\n     if (runnable) {\n       maxRunningEnforcer.trackRunnableApp(schedulerApp);\n     } else {\n       maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n     }\n     \n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplicationAttempt(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(\n        applicationAttemptId.getApplicationId());\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRejectedEvent(applicationAttemptId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(schedulerApp, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n    }\n    \n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "addApplication",
        "newValue": "addApplicationAttempt"
      }
    },
    "7545d8bf996e5d060d5d613bf769ec52a62d428b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1241. In Fair Scheduler, maxRunningApps does not work for non-leaf queues. (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546623 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/13 11:02 AM",
      "commitName": "7545d8bf996e5d060d5d613bf769ec52a62d428b",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "14/11/13 2:12 PM",
      "commitNameOld": "3858b9018e3c2f4b883b02021679852591b706f7",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 14.87,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,59 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(\n         applicationAttemptId.getApplicationId());\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n     if (queue \u003d\u003d null) {\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptRejectedEvent(applicationAttemptId,\n               \"Application rejected by queue placement policy\"));\n       return;\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n \n-    queue.addApp(schedulerApp);\n+    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n+    queue.addApp(schedulerApp, runnable);\n+    if (runnable) {\n+      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n+    } else {\n+      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n+    }\n+    \n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(\n        applicationAttemptId.getApplicationId());\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRejectedEvent(applicationAttemptId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    boolean runnable \u003d maxRunningEnforcer.canAppBeRunnable(queue, user);\n    queue.addApp(schedulerApp, runnable);\n    if (runnable) {\n      maxRunningEnforcer.trackRunnableApp(schedulerApp);\n    } else {\n      maxRunningEnforcer.trackNonRunnableApp(schedulerApp);\n    }\n    \n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "3858b9018e3c2f4b883b02021679852591b706f7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1392. Allow sophisticated app-to-queue placement policies in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1542105 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/11/13 2:12 PM",
      "commitName": "3858b9018e3c2f4b883b02021679852591b706f7",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "05/11/13 1:23 PM",
      "commitNameOld": "6990355e577ad19371cb656c250fb665ed14062f",
      "commitAuthorOld": "Luke Lu",
      "daysBetweenCommits": 9.03,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,52 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(\n         applicationAttemptId.getApplicationId());\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n+    if (queue \u003d\u003d null) {\n+      rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppAttemptRejectedEvent(applicationAttemptId,\n+              \"Application rejected by queue placement policy\"));\n+      return;\n+    }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(\n        applicationAttemptId.getApplicationId());\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n    if (queue \u003d\u003d null) {\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptRejectedEvent(applicationAttemptId,\n              \"Application rejected by queue placement policy\"));\n      return;\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ac2cdb5f6586cc3358ea4fc818f477959d2daa38": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1236. FairScheduler setting queue name in RMApp is not working. (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529034 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/10/13 4:29 PM",
      "commitName": "ac2cdb5f6586cc3358ea4fc818f477959d2daa38",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "02/10/13 6:17 PM",
      "commitNameOld": "2db1d4d4ee7838f2a8c0b3999b6055456798321d",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 0.92,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,46 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n-    RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n+    RMApp rmApp \u003d rmContext.getRMApps().get(\n+        applicationAttemptId.getApplicationId());\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n \n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n         \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(\n        applicationAttemptId.getApplicationId());\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1c5b49eeafc2253d4fa92456e6ccf0f35290c889": {
      "type": "Ybodychange",
      "commitMessage": "YARN-899. Added back queue level administrator-acls so that there is no regression w.r.t 1.x. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527282 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/09/13 1:21 AM",
      "commitName": "1c5b49eeafc2253d4fa92456e6ccf0f35290c889",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "09/09/13 6:24 PM",
      "commitNameOld": "59b5490989fad4c8e80dd85c3419810cdc8332f7",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 19.29,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,45 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n     if (queueName \u003d\u003d null || queueName.isEmpty()) {\n       String message \u003d \"Reject application \" + applicationAttemptId +\n               \" submitted by user \" + user + \" with an empty queue name.\";\n       LOG.info(message);\n       rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n-    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n+\n+    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n+        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n-    \n+\n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)\n        \u0026\u0026 !queue.hasAccess(QueueACL.ADMINISTER_QUEUE, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ca35ed13bfdcbcf6fdfc58f83f1f182786bb3b22": {
      "type": "Ybodychange",
      "commitMessage": "YARN-461. Fair scheduler should not accept apps with empty string queue name. (ywskycn via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505858 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/13 5:00 PM",
      "commitName": "ca35ed13bfdcbcf6fdfc58f83f1f182786bb3b22",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "11/07/13 2:39 PM",
      "commitNameOld": "171493215889a3b6bf2f6ba33212c4f06861a189",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 11.1,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,43 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n+    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n+      String message \u003d \"Reject application \" + applicationAttemptId +\n+              \" submitted by user \" + user + \" with an empty queue name.\";\n+      LOG.info(message);\n+      rmContext.getDispatcher().getEventHandler().handle(\n+              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n+      return;\n+    }\n+\n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n     FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n     \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    if (queueName \u003d\u003d null || queueName.isEmpty()) {\n      String message \u003d \"Reject application \" + applicationAttemptId +\n              \" submitted by user \" + user + \" with an empty queue name.\";\n      LOG.info(message);\n      rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppAttemptRejectedEvent(applicationAttemptId, message));\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n    \n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "171493215889a3b6bf2f6ba33212c4f06861a189": {
      "type": "Ybodychange",
      "commitMessage": "YARN-333. Schedulers cannot control the queue-name of an application. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502374 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/07/13 2:39 PM",
      "commitName": "171493215889a3b6bf2f6ba33212c4f06861a189",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "28/06/13 11:59 AM",
      "commitNameOld": "c221204ccaadcf70992d9e858ef71c6f8864ff4e",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 13.11,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,34 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n-\n-    FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n-    if (queue \u003d\u003d null) {\n-      // queue is not an existing or createable leaf queue\n-      queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n-    }\n+    RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n+    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n       String msg \u003d \"User \" + userUgi.getUserName() +\n     \t        \" cannot submit applications to queue \" + queue.getName();\n       LOG.info(msg);\n       rmContext.getDispatcher().getEventHandler().handle(\n     \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n     \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationAttemptId);\n    FSLeafQueue queue \u003d assignToQueue(rmApp, queueName, user);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n    \n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "345bcee0664392323b4297c0797897a96fef8958": {
      "type": "Ybodychange",
      "commitMessage": "YARN-319. Submitting a job to a fair scheduler queue for which the user does not have permission causes the client to wait forever. Contributed by shenhong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1437336 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/01/13 2:53 AM",
      "commitName": "345bcee0664392323b4297c0797897a96fef8958",
      "commitAuthor": "Thomas White",
      "commitDateOld": "15/01/13 9:09 AM",
      "commitNameOld": "72e631098d2db8a9a18c32c9b25b57b7af4d9275",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 7.74,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,38 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n \n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n     if (queue \u003d\u003d null) {\n       // queue is not an existing or createable leaf queue\n       queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n \n     // Enforce ACLs\n     UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n     if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n-      LOG.info(\"User \" + userUgi.getUserName() +\n-          \" cannot submit applications to queue \" + queue.getName());\n+      String msg \u003d \"User \" + userUgi.getUserName() +\n+    \t        \" cannot submit applications to queue \" + queue.getName();\n+      LOG.info(msg);\n+      rmContext.getDispatcher().getEventHandler().handle(\n+    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n       return;\n     }\n     \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n    if (queue \u003d\u003d null) {\n      // queue is not an existing or createable leaf queue\n      queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n      String msg \u003d \"User \" + userUgi.getUserName() +\n    \t        \" cannot submit applications to queue \" + queue.getName();\n      LOG.info(msg);\n      rmContext.getDispatcher().getEventHandler().handle(\n    \t        new RMAppAttemptRejectedEvent(applicationAttemptId, msg));\n      return;\n    }\n    \n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "19a291a0d65b64e50571c3519414b9d54acbe28a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-288. Fair scheduler queue doesn\u0027t accept any jobs when ACLs are configured. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1428362 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/01/13 6:32 AM",
      "commitName": "19a291a0d65b64e50571c3519414b9d54acbe28a",
      "commitAuthor": "Thomas White",
      "commitDateOld": "21/12/12 8:12 AM",
      "commitNameOld": "5014a4b133000648e25ca7a801e2f23baa2273f5",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 12.93,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,35 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n \n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n     if (queue \u003d\u003d null) {\n       // queue is not an existing or createable leaf queue\n       queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n-    \n+\n     // Enforce ACLs\n-    UserGroupInformation userUgi;\n-    try {\n-      userUgi \u003d UserGroupInformation.getCurrentUser();\n-    } catch (IOException ioe) {\n-      LOG.info(\"Failed to get current user information\");\n-      return;\n-    }\n-\n-    // Always a singleton list\n-    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueUserAclInfo(userUgi);\n-    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n+    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n+    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n       LOG.info(\"User \" + userUgi.getUserName() +\n-          \" cannot submit\" + \" applications to queue \" + queue.getName());\n+          \" cannot submit applications to queue \" + queue.getName());\n       return;\n     }\n-\n+    \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n    if (queue \u003d\u003d null) {\n      // queue is not an existing or createable leaf queue\n      queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Enforce ACLs\n    UserGroupInformation userUgi \u003d UserGroupInformation.createRemoteUser(user);\n    if (!queue.hasAccess(QueueACL.SUBMIT_APPLICATIONS, userUgi)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit applications to queue \" + queue.getName());\n      return;\n    }\n    \n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "5014a4b133000648e25ca7a801e2f23baa2273f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-282. Fair scheduler web UI double counts Apps Submitted. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1424995 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/12/12 8:12 AM",
      "commitName": "5014a4b133000648e25ca7a801e2f23baa2273f5",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "21/12/12 7:10 AM",
      "commitNameOld": "ee007d3f38e6f437a79ca47f2ebd44966860746e",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,44 @@\n   protected synchronized void addApplication(\n       ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n \n     FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n     if (queue \u003d\u003d null) {\n       // queue is not an existing or createable leaf queue\n       queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n     }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n     \n     // Enforce ACLs\n     UserGroupInformation userUgi;\n     try {\n       userUgi \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ioe) {\n       LOG.info(\"Failed to get current user information\");\n       return;\n     }\n \n     // Always a singleton list\n     List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueUserAclInfo(userUgi);\n     if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n       LOG.info(\"User \" + userUgi.getUserName() +\n           \" cannot submit\" + \" applications to queue \" + queue.getName());\n       return;\n     }\n \n     queue.addApp(schedulerApp);\n     queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n-    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n    if (queue \u003d\u003d null) {\n      // queue is not an existing or createable leaf queue\n      queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    \n    // Enforce ACLs\n    UserGroupInformation userUgi;\n    try {\n      userUgi \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get current user information\");\n      return;\n    }\n\n    // Always a singleton list\n    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueUserAclInfo(userUgi);\n    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit\" + \" applications to queue \" + queue.getName());\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21": {
      "type": "Ybodychange",
      "commitMessage": "YARN-187. Add hierarchical queues to the fair scheduler. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1415592 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/11/12 4:03 AM",
      "commitName": "ae6f1123f57c09a9cf5eed3e8c4659481417dc21",
      "commitAuthor": "Thomas White",
      "commitDateOld": "28/11/12 5:56 PM",
      "commitNameOld": "1943fdbec613715f3cdc3ca60cbd273115f28299",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.42,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,45 @@\n-  addApplication(ApplicationAttemptId applicationAttemptId,\n-      String queueName, String user) {\n+  protected synchronized void addApplication(\n+      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n \n-    FSQueue queue \u003d queueMgr.getQueue(queueName);\n+    FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n+    if (queue \u003d\u003d null) {\n+      // queue is not an existing or createable leaf queue\n+      queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n+    }\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n-            queue.getQueueSchedulable(), new ActiveUsersManager(getRootQueueMetrics()),\n+            queue, new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext);\n-\n-    // Inforce ACLs\n+    \n+    // Enforce ACLs\n     UserGroupInformation userUgi;\n     try {\n       userUgi \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ioe) {\n       LOG.info(\"Failed to get current user information\");\n       return;\n     }\n \n-    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n-        userUgi); // Always a signleton list\n+    // Always a singleton list\n+    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueUserAclInfo(userUgi);\n     if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n       LOG.info(\"User \" + userUgi.getUserName() +\n           \" cannot submit\" + \" applications to queue \" + queue.getName());\n       return;\n     }\n \n     queue.addApp(schedulerApp);\n-    queue.getQueueSchedulable().getMetrics().submitApp(user,\n-    \t\tapplicationAttemptId.getAttemptId());\n+    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n     rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n-        \", user: \" + user +\n+        \", user: \"+ user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addApplication(\n      ApplicationAttemptId applicationAttemptId, String queueName, String user) {\n\n    FSLeafQueue queue \u003d queueMgr.getLeafQueue(queueName);\n    if (queue \u003d\u003d null) {\n      // queue is not an existing or createable leaf queue\n      queue \u003d queueMgr.getLeafQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n    }\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue, new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n    \n    // Enforce ACLs\n    UserGroupInformation userUgi;\n    try {\n      userUgi \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get current user information\");\n      return;\n    }\n\n    // Always a singleton list\n    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueUserAclInfo(userUgi);\n    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit\" + \" applications to queue \" + queue.getName());\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getMetrics().submitApp(user, applicationAttemptId.getAttemptId());\n    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \"+ user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1943fdbec613715f3cdc3ca60cbd273115f28299": {
      "type": "Ybodychange",
      "commitMessage": "YARN-229. Remove old unused RM recovery code. Contributed by Bikas Saha.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1415029 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/11/12 5:56 PM",
      "commitName": "1943fdbec613715f3cdc3ca60cbd273115f28299",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "28/11/12 4:27 AM",
      "commitNameOld": "d9050e12081c0e56e1185e330badcca00e5d4b21",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   addApplication(ApplicationAttemptId applicationAttemptId,\n       String queueName, String user) {\n \n     FSQueue queue \u003d queueMgr.getQueue(queueName);\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n             queue.getQueueSchedulable(), new ActiveUsersManager(getRootQueueMetrics()),\n-            rmContext, null);\n+            rmContext);\n \n     // Inforce ACLs\n     UserGroupInformation userUgi;\n     try {\n       userUgi \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ioe) {\n       LOG.info(\"Failed to get current user information\");\n       return;\n     }\n \n     List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n         userUgi); // Always a signleton list\n     if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n       LOG.info(\"User \" + userUgi.getUserName() +\n           \" cannot submit\" + \" applications to queue \" + queue.getName());\n       return;\n     }\n \n     queue.addApp(schedulerApp);\n     queue.getQueueSchedulable().getMetrics().submitApp(user,\n     \t\tapplicationAttemptId.getAttemptId());\n     rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \" + user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  addApplication(ApplicationAttemptId applicationAttemptId,\n      String queueName, String user) {\n\n    FSQueue queue \u003d queueMgr.getQueue(queueName);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue.getQueueSchedulable(), new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext);\n\n    // Inforce ACLs\n    UserGroupInformation userUgi;\n    try {\n      userUgi \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get current user information\");\n      return;\n    }\n\n    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n        userUgi); // Always a signleton list\n    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit\" + \" applications to queue \" + queue.getName());\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getQueueSchedulable().getMetrics().submitApp(user,\n    \t\tapplicationAttemptId.getAttemptId());\n    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \" + user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-183. Clean up fair scheduler code. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1407433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/11/12 4:38 AM",
      "commitName": "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
      "commitAuthor": "Thomas White",
      "commitDateOld": "26/10/12 1:55 PM",
      "commitNameOld": "b54e794fb059fa68b115c2ca5e58f11a0d7f3985",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 13.65,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   addApplication(ApplicationAttemptId applicationAttemptId,\n       String queueName, String user) {\n \n-    FSQueue queue \u003d this.queueMgr.getQueue(queueName);\n+    FSQueue queue \u003d queueMgr.getQueue(queueName);\n \n     FSSchedulerApp schedulerApp \u003d\n         new FSSchedulerApp(applicationAttemptId, user,\n-            queue.getQueueSchedulable(), new ActiveUsersManager(this.getRootQueueMetrics()),\n+            queue.getQueueSchedulable(), new ActiveUsersManager(getRootQueueMetrics()),\n             rmContext, null);\n \n     // Inforce ACLs\n     UserGroupInformation userUgi;\n     try {\n       userUgi \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ioe) {\n       LOG.info(\"Failed to get current user information\");\n       return;\n     }\n \n     List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n         userUgi); // Always a signleton list\n     if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n       LOG.info(\"User \" + userUgi.getUserName() +\n           \" cannot submit\" + \" applications to queue \" + queue.getName());\n       return;\n     }\n \n     queue.addApp(schedulerApp);\n     queue.getQueueSchedulable().getMetrics().submitApp(user,\n     \t\tapplicationAttemptId.getAttemptId());\n     rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n \n     applications.put(applicationAttemptId, schedulerApp);\n \n     LOG.info(\"Application Submission: \" + applicationAttemptId +\n         \", user: \" + user +\n         \", currently active: \" + applications.size());\n \n     rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptEvent(applicationAttemptId,\n             RMAppAttemptEventType.APP_ACCEPTED));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  addApplication(ApplicationAttemptId applicationAttemptId,\n      String queueName, String user) {\n\n    FSQueue queue \u003d queueMgr.getQueue(queueName);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue.getQueueSchedulable(), new ActiveUsersManager(getRootQueueMetrics()),\n            rmContext, null);\n\n    // Inforce ACLs\n    UserGroupInformation userUgi;\n    try {\n      userUgi \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get current user information\");\n      return;\n    }\n\n    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n        userUgi); // Always a signleton list\n    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit\" + \" applications to queue \" + queue.getName());\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getQueueSchedulable().getMetrics().submitApp(user,\n    \t\tapplicationAttemptId.getAttemptId());\n    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \" + user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  addApplication(ApplicationAttemptId applicationAttemptId,\n      String queueName, String user) {\n\n    FSQueue queue \u003d this.queueMgr.getQueue(queueName);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue.getQueueSchedulable(), new ActiveUsersManager(this.getRootQueueMetrics()),\n            rmContext, null);\n\n    // Inforce ACLs\n    UserGroupInformation userUgi;\n    try {\n      userUgi \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get current user information\");\n      return;\n    }\n\n    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n        userUgi); // Always a signleton list\n    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit\" + \" applications to queue \" + queue.getName());\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getQueueSchedulable().getMetrics().submitApp(user,\n    \t\tapplicationAttemptId.getAttemptId());\n    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \" + user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
      }
    },
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3451. Port Fair Scheduler to MR2 (pwendell via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361020 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 5:43 PM",
      "commitName": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,42 @@\n+  addApplication(ApplicationAttemptId applicationAttemptId,\n+      String queueName, String user) {\n+\n+    FSQueue queue \u003d this.queueMgr.getQueue(queueName);\n+\n+    FSSchedulerApp schedulerApp \u003d\n+        new FSSchedulerApp(applicationAttemptId, user,\n+            queue.getQueueSchedulable(), new ActiveUsersManager(this.getRootQueueMetrics()),\n+            rmContext, null);\n+\n+    // Inforce ACLs\n+    UserGroupInformation userUgi;\n+    try {\n+      userUgi \u003d UserGroupInformation.getCurrentUser();\n+    } catch (IOException ioe) {\n+      LOG.info(\"Failed to get current user information\");\n+      return;\n+    }\n+\n+    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n+        userUgi); // Always a signleton list\n+    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n+      LOG.info(\"User \" + userUgi.getUserName() +\n+          \" cannot submit\" + \" applications to queue \" + queue.getName());\n+      return;\n+    }\n+\n+    queue.addApp(schedulerApp);\n+    queue.getQueueSchedulable().getMetrics().submitApp(user,\n+    \t\tapplicationAttemptId.getAttemptId());\n+    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n+\n+    applications.put(applicationAttemptId, schedulerApp);\n+\n+    LOG.info(\"Application Submission: \" + applicationAttemptId +\n+        \", user: \" + user +\n+        \", currently active: \" + applications.size());\n+\n+    rmContext.getDispatcher().getEventHandler().handle(\n+        new RMAppAttemptEvent(applicationAttemptId,\n+            RMAppAttemptEventType.APP_ACCEPTED));\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  addApplication(ApplicationAttemptId applicationAttemptId,\n      String queueName, String user) {\n\n    FSQueue queue \u003d this.queueMgr.getQueue(queueName);\n\n    FSSchedulerApp schedulerApp \u003d\n        new FSSchedulerApp(applicationAttemptId, user,\n            queue.getQueueSchedulable(), new ActiveUsersManager(this.getRootQueueMetrics()),\n            rmContext, null);\n\n    // Inforce ACLs\n    UserGroupInformation userUgi;\n    try {\n      userUgi \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ioe) {\n      LOG.info(\"Failed to get current user information\");\n      return;\n    }\n\n    List\u003cQueueUserACLInfo\u003e info \u003d queue.getQueueSchedulable().getQueueUserAclInfo(\n        userUgi); // Always a signleton list\n    if (!info.get(0).getUserAcls().contains(QueueACL.SUBMIT_APPLICATIONS)) {\n      LOG.info(\"User \" + userUgi.getUserName() +\n          \" cannot submit\" + \" applications to queue \" + queue.getName());\n      return;\n    }\n\n    queue.addApp(schedulerApp);\n    queue.getQueueSchedulable().getMetrics().submitApp(user,\n    \t\tapplicationAttemptId.getAttemptId());\n    rootMetrics.submitApp(user, applicationAttemptId.getAttemptId());\n\n    applications.put(applicationAttemptId, schedulerApp);\n\n    LOG.info(\"Application Submission: \" + applicationAttemptId +\n        \", user: \" + user +\n        \", currently active: \" + applications.size());\n\n    rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptEvent(applicationAttemptId,\n            RMAppAttemptEventType.APP_ACCEPTED));\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
    }
  }
}