{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "WriteManager.java",
  "functionName": "commitBeforeRead",
  "functionId": "commitBeforeRead___dfsClient-DFSClient__fileHandle-FileHandle__commitOffset-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
  "functionStartLine": 219,
  "functionEndLine": 266,
  "numCommitsSeen": 21,
  "timeTaken": 1611,
  "changeHistory": [
    "d6602b5f39833611b4afa4581552f6c4c37e23a8",
    "f37849188b05a6251584de1aed5e66d5dfa7da4f",
    "f6f2a3f1c73266bfedd802eacde60d8b19b81015",
    "b6f9d5538cf2b425652687e99503f3d566b2056a",
    "5ea533c2bfc72fd3adbfd972d18806fbc397e0f8"
  ],
  "changeHistoryShort": {
    "d6602b5f39833611b4afa4581552f6c4c37e23a8": "Ybodychange",
    "f37849188b05a6251584de1aed5e66d5dfa7da4f": "Ybodychange",
    "f6f2a3f1c73266bfedd802eacde60d8b19b81015": "Ybodychange",
    "b6f9d5538cf2b425652687e99503f3d566b2056a": "Ybodychange",
    "5ea533c2bfc72fd3adbfd972d18806fbc397e0f8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d6602b5f39833611b4afa4581552f6c4c37e23a8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11575. Supporting HDFS NFS gateway with Federated HDFS. Contributed by Mukul Kumar Singh.\n",
      "commitDate": "10/10/17 10:38 AM",
      "commitName": "d6602b5f39833611b4afa4581552f6c4c37e23a8",
      "commitAuthor": "Jitendra Pandey",
      "commitDateOld": "28/01/15 12:56 PM",
      "commitNameOld": "f37849188b05a6251584de1aed5e66d5dfa7da4f",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 985.86,
      "commitsBetweenForRepo": 7119,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   int commitBeforeRead(DFSClient dfsClient, FileHandle fileHandle,\n       long commitOffset) {\n     int status;\n     OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"No opened stream for fileId: \" + fileHandle.getFileId()\n+        LOG.debug(\"No opened stream for fileId: \" + fileHandle.dumpFileHandle()\n             + \" commitOffset\u003d\" + commitOffset\n             + \". Return success in this case.\");\n       }\n       status \u003d Nfs3Status.NFS3_OK;\n \n     } else {\n       // commit request triggered by read won\u0027t create pending comment obj\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           null, 0, null, true);\n       switch (ret) {\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n       case COMMIT_SPECIAL_WAIT:\n         /**\n          * This should happen rarely in some possible cases, such as read\n          * request arrives before DFSClient is able to quickly flush data to DN,\n          * or Prerequisite writes is not available. Won\u0027t wait since we don\u0027t\n          * want to block read.\n          */     \n         status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n         break;\n       case COMMIT_SPECIAL_SUCCESS:\n         // Read beyond eof could result in partial read\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       default:\n         LOG.error(\"Should not get commit return code: \" + ret.name());\n         throw new RuntimeException(\"Should not get commit return code: \"\n             + ret.name());\n       }\n     }\n     return status;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  int commitBeforeRead(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset) {\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No opened stream for fileId: \" + fileHandle.dumpFileHandle()\n            + \" commitOffset\u003d\" + commitOffset\n            + \". Return success in this case.\");\n      }\n      status \u003d Nfs3Status.NFS3_OK;\n\n    } else {\n      // commit request triggered by read won\u0027t create pending comment obj\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          null, 0, null, true);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n      case COMMIT_SPECIAL_WAIT:\n        /**\n         * This should happen rarely in some possible cases, such as read\n         * request arrives before DFSClient is able to quickly flush data to DN,\n         * or Prerequisite writes is not available. Won\u0027t wait since we don\u0027t\n         * want to block read.\n         */     \n        status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n        break;\n      case COMMIT_SPECIAL_SUCCESS:\n        // Read beyond eof could result in partial read\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      default:\n        LOG.error(\"Should not get commit return code: \" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code: \"\n            + ret.name());\n      }\n    }\n    return status;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "f37849188b05a6251584de1aed5e66d5dfa7da4f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7423. various typos and message formatting fixes in nfs daemon and doc. (Charles Lamb via yliu)\n",
      "commitDate": "28/01/15 12:56 PM",
      "commitName": "f37849188b05a6251584de1aed5e66d5dfa7da4f",
      "commitAuthor": "yliu",
      "commitDateOld": "27/01/15 12:58 PM",
      "commitNameOld": "2848db814a98b83e7546f65a2751e56fb5b2dbe0",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 1.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   int commitBeforeRead(DFSClient dfsClient, FileHandle fileHandle,\n       long commitOffset) {\n     int status;\n     OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"No opened stream for fileId:\" + fileHandle.getFileId()\n+        LOG.debug(\"No opened stream for fileId: \" + fileHandle.getFileId()\n             + \" commitOffset\u003d\" + commitOffset\n             + \". Return success in this case.\");\n       }\n       status \u003d Nfs3Status.NFS3_OK;\n \n     } else {\n       // commit request triggered by read won\u0027t create pending comment obj\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           null, 0, null, true);\n       switch (ret) {\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n       case COMMIT_SPECIAL_WAIT:\n         /**\n          * This should happen rarely in some possible cases, such as read\n          * request arrives before DFSClient is able to quickly flush data to DN,\n          * or Prerequisite writes is not available. Won\u0027t wait since we don\u0027t\n          * want to block read.\n          */     \n         status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n         break;\n       case COMMIT_SPECIAL_SUCCESS:\n         // Read beyond eof could result in partial read\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       default:\n-        LOG.error(\"Should not get commit return code:\" + ret.name());\n-        throw new RuntimeException(\"Should not get commit return code:\"\n+        LOG.error(\"Should not get commit return code: \" + ret.name());\n+        throw new RuntimeException(\"Should not get commit return code: \"\n             + ret.name());\n       }\n     }\n     return status;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  int commitBeforeRead(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset) {\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No opened stream for fileId: \" + fileHandle.getFileId()\n            + \" commitOffset\u003d\" + commitOffset\n            + \". Return success in this case.\");\n      }\n      status \u003d Nfs3Status.NFS3_OK;\n\n    } else {\n      // commit request triggered by read won\u0027t create pending comment obj\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          null, 0, null, true);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n      case COMMIT_SPECIAL_WAIT:\n        /**\n         * This should happen rarely in some possible cases, such as read\n         * request arrives before DFSClient is able to quickly flush data to DN,\n         * or Prerequisite writes is not available. Won\u0027t wait since we don\u0027t\n         * want to block read.\n         */     \n        status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n        break;\n      case COMMIT_SPECIAL_SUCCESS:\n        // Read beyond eof could result in partial read\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      default:\n        LOG.error(\"Should not get commit return code: \" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code: \"\n            + ret.name());\n      }\n    }\n    return status;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "f6f2a3f1c73266bfedd802eacde60d8b19b81015": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7449. Add metrics to NFS gateway. Contributed by Brandon Li\n",
      "commitDate": "11/12/14 3:40 PM",
      "commitName": "f6f2a3f1c73266bfedd802eacde60d8b19b81015",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "29/10/14 11:05 AM",
      "commitNameOld": "72a556d3b0def0ab4e4509528cc513f6df06b084",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 43.23,
      "commitsBetweenForRepo": 356,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,48 @@\n   int commitBeforeRead(DFSClient dfsClient, FileHandle fileHandle,\n       long commitOffset) {\n     int status;\n     OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"No opened stream for fileId:\" + fileHandle.getFileId()\n             + \" commitOffset\u003d\" + commitOffset\n             + \". Return success in this case.\");\n       }\n       status \u003d Nfs3Status.NFS3_OK;\n \n     } else {\n+      // commit request triggered by read won\u0027t create pending comment obj\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           null, 0, null, true);\n       switch (ret) {\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n       case COMMIT_SPECIAL_WAIT:\n         /**\n          * This should happen rarely in some possible cases, such as read\n          * request arrives before DFSClient is able to quickly flush data to DN,\n          * or Prerequisite writes is not available. Won\u0027t wait since we don\u0027t\n          * want to block read.\n          */     \n         status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n         break;\n       case COMMIT_SPECIAL_SUCCESS:\n         // Read beyond eof could result in partial read\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       default:\n         LOG.error(\"Should not get commit return code:\" + ret.name());\n         throw new RuntimeException(\"Should not get commit return code:\"\n             + ret.name());\n       }\n     }\n     return status;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  int commitBeforeRead(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset) {\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No opened stream for fileId:\" + fileHandle.getFileId()\n            + \" commitOffset\u003d\" + commitOffset\n            + \". Return success in this case.\");\n      }\n      status \u003d Nfs3Status.NFS3_OK;\n\n    } else {\n      // commit request triggered by read won\u0027t create pending comment obj\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          null, 0, null, true);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n      case COMMIT_SPECIAL_WAIT:\n        /**\n         * This should happen rarely in some possible cases, such as read\n         * request arrives before DFSClient is able to quickly flush data to DN,\n         * or Prerequisite writes is not available. Won\u0027t wait since we don\u0027t\n         * want to block read.\n         */     \n        status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n        break;\n      case COMMIT_SPECIAL_SUCCESS:\n        // Read beyond eof could result in partial read\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      default:\n        LOG.error(\"Should not get commit return code:\" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code:\"\n            + ret.name());\n      }\n    }\n    return status;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "b6f9d5538cf2b425652687e99503f3d566b2056a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7259. Unresponseive NFS mount point due to deferred COMMIT response. Contributed by Brandon Li\n",
      "commitDate": "21/10/14 10:20 AM",
      "commitName": "b6f9d5538cf2b425652687e99503f3d566b2056a",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "01/10/14 1:18 PM",
      "commitNameOld": "875aa797caee96572162ff59bc50cf97d1195348",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 19.88,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,47 @@\n   int commitBeforeRead(DFSClient dfsClient, FileHandle fileHandle,\n       long commitOffset) {\n     int status;\n     OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"No opened stream for fileId:\" + fileHandle.getFileId()\n             + \" commitOffset\u003d\" + commitOffset\n             + \". Return success in this case.\");\n       }\n       status \u003d Nfs3Status.NFS3_OK;\n \n     } else {\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           null, 0, null, true);\n       switch (ret) {\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n+      case COMMIT_SPECIAL_WAIT:\n         /**\n          * This should happen rarely in some possible cases, such as read\n          * request arrives before DFSClient is able to quickly flush data to DN,\n          * or Prerequisite writes is not available. Won\u0027t wait since we don\u0027t\n          * want to block read.\n          */     \n         status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n         break;\n+      case COMMIT_SPECIAL_SUCCESS:\n+        // Read beyond eof could result in partial read\n+        status \u003d Nfs3Status.NFS3_OK;\n+        break;\n       default:\n         LOG.error(\"Should not get commit return code:\" + ret.name());\n         throw new RuntimeException(\"Should not get commit return code:\"\n             + ret.name());\n       }\n     }\n     return status;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  int commitBeforeRead(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset) {\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No opened stream for fileId:\" + fileHandle.getFileId()\n            + \" commitOffset\u003d\" + commitOffset\n            + \". Return success in this case.\");\n      }\n      status \u003d Nfs3Status.NFS3_OK;\n\n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          null, 0, null, true);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n      case COMMIT_SPECIAL_WAIT:\n        /**\n         * This should happen rarely in some possible cases, such as read\n         * request arrives before DFSClient is able to quickly flush data to DN,\n         * or Prerequisite writes is not available. Won\u0027t wait since we don\u0027t\n         * want to block read.\n         */     \n        status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n        break;\n      case COMMIT_SPECIAL_SUCCESS:\n        // Read beyond eof could result in partial read\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      default:\n        LOG.error(\"Should not get commit return code:\" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code:\"\n            + ret.name());\n      }\n    }\n    return status;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "5ea533c2bfc72fd3adbfd972d18806fbc397e0f8": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5563. NFS gateway should commit the buffered data when read request comes after write to the same file. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546233 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/13 3:41 PM",
      "commitName": "5ea533c2bfc72fd3adbfd972d18806fbc397e0f8",
      "commitAuthor": "Brandon Li",
      "diff": "@@ -0,0 +1,42 @@\n+  int commitBeforeRead(DFSClient dfsClient, FileHandle fileHandle,\n+      long commitOffset) {\n+    int status;\n+    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n+\n+    if (openFileCtx \u003d\u003d null) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"No opened stream for fileId:\" + fileHandle.getFileId()\n+            + \" commitOffset\u003d\" + commitOffset\n+            + \". Return success in this case.\");\n+      }\n+      status \u003d Nfs3Status.NFS3_OK;\n+\n+    } else {\n+      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n+          null, 0, null, true);\n+      switch (ret) {\n+      case COMMIT_FINISHED:\n+      case COMMIT_INACTIVE_CTX:\n+        status \u003d Nfs3Status.NFS3_OK;\n+        break;\n+      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n+      case COMMIT_ERROR:\n+        status \u003d Nfs3Status.NFS3ERR_IO;\n+        break;\n+      case COMMIT_WAIT:\n+        /**\n+         * This should happen rarely in some possible cases, such as read\n+         * request arrives before DFSClient is able to quickly flush data to DN,\n+         * or Prerequisite writes is not available. Won\u0027t wait since we don\u0027t\n+         * want to block read.\n+         */     \n+        status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n+        break;\n+      default:\n+        LOG.error(\"Should not get commit return code:\" + ret.name());\n+        throw new RuntimeException(\"Should not get commit return code:\"\n+            + ret.name());\n+      }\n+    }\n+    return status;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  int commitBeforeRead(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset) {\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"No opened stream for fileId:\" + fileHandle.getFileId()\n            + \" commitOffset\u003d\" + commitOffset\n            + \". Return success in this case.\");\n      }\n      status \u003d Nfs3Status.NFS3_OK;\n\n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          null, 0, null, true);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        /**\n         * This should happen rarely in some possible cases, such as read\n         * request arrives before DFSClient is able to quickly flush data to DN,\n         * or Prerequisite writes is not available. Won\u0027t wait since we don\u0027t\n         * want to block read.\n         */     \n        status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n        break;\n      default:\n        LOG.error(\"Should not get commit return code:\" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code:\"\n            + ret.name());\n      }\n    }\n    return status;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java"
    }
  }
}