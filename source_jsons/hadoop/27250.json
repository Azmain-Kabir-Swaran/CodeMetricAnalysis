{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineParserForCompareExpr.java",
  "functionName": "parse",
  "functionId": "parse",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/reader/TimelineParserForCompareExpr.java",
  "functionStartLine": 243,
  "functionEndLine": 295,
  "numCommitsSeen": 2,
  "timeTaken": 857,
  "changeHistory": [
    "024d7c08704e6a5fcc1f53a8f56a44c84c8d5fa0",
    "089caf49fe968cf4cd3fd4f9637da89ee143991a"
  ],
  "changeHistoryShort": {
    "024d7c08704e6a5fcc1f53a8f56a44c84c8d5fa0": "Ybodychange",
    "089caf49fe968cf4cd3fd4f9637da89ee143991a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "024d7c08704e6a5fcc1f53a8f56a44c84c8d5fa0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8107. Give an informative message when incorrect format is used in ATSv2 filter attributes. (Rohith Sharma K S via Haibo Chen)\n",
      "commitDate": "06/04/18 9:39 AM",
      "commitName": "024d7c08704e6a5fcc1f53a8f56a44c84c8d5fa0",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "089caf49fe968cf4cd3fd4f9637da89ee143991a",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 635.04,
      "commitsBetweenForRepo": 4294,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,53 @@\n   public TimelineFilterList parse() throws TimelineParseException {\n     if (expr \u003d\u003d null || exprLength \u003d\u003d 0) {\n       return null;\n     }\n     boolean closingBracket \u003d false;\n     while (offset \u003c exprLength) {\n       char offsetChar \u003d expr.charAt(offset);\n       switch(offsetChar) {\n       case TimelineParseConstants.SPACE_CHAR:\n         handleSpaceChar();\n         break;\n       case TimelineParseConstants.OPENING_BRACKET_CHAR:\n         handleOpeningBracketChar();\n         break;\n       case TimelineParseConstants.CLOSING_BRACKET_CHAR:\n         handleClosingBracketChar();\n         closingBracket \u003d true;\n         break;\n       default: // other characters.\n         // Parse based on state.\n         if (currentParseState \u003d\u003d ParseState.PARSING_COMPAREOP) {\n           parseCompareOp();\n         } else if (currentParseState \u003d\u003d ParseState.PARSING_OP) {\n           parseOp(closingBracket);\n           closingBracket \u003d false;\n         } else {\n           // Might be a key or value. Move ahead.\n           offset++;\n         }\n         break;\n       }\n     }\n     if (!filterListStack.isEmpty()) {\n       filterListStack.clear();\n       throw new TimelineParseException(\"Encountered improper brackets while \" +\n           \"parsing \" + exprName + \".\");\n     }\n     if (currentParseState \u003d\u003d ParseState.PARSING_VALUE) {\n       setValueToCurrentFilter(\n           parseValue(expr.substring(kvStartOffset, offset)));\n     }\n     if (filterList \u003d\u003d null || filterList.getFilterList().isEmpty()) {\n-      filterList \u003d new TimelineFilterList(currentFilter);\n+      if (currentFilter \u003d\u003d null) {\n+        throw new TimelineParseException(\n+            \"Invalid expression provided for \" + exprName);\n+      } else {\n+        filterList \u003d new TimelineFilterList(currentFilter);\n+      }\n     } else if (currentFilter !\u003d null) {\n       filterList.addFilter(currentFilter);\n     }\n     return filterList;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelineFilterList parse() throws TimelineParseException {\n    if (expr \u003d\u003d null || exprLength \u003d\u003d 0) {\n      return null;\n    }\n    boolean closingBracket \u003d false;\n    while (offset \u003c exprLength) {\n      char offsetChar \u003d expr.charAt(offset);\n      switch(offsetChar) {\n      case TimelineParseConstants.SPACE_CHAR:\n        handleSpaceChar();\n        break;\n      case TimelineParseConstants.OPENING_BRACKET_CHAR:\n        handleOpeningBracketChar();\n        break;\n      case TimelineParseConstants.CLOSING_BRACKET_CHAR:\n        handleClosingBracketChar();\n        closingBracket \u003d true;\n        break;\n      default: // other characters.\n        // Parse based on state.\n        if (currentParseState \u003d\u003d ParseState.PARSING_COMPAREOP) {\n          parseCompareOp();\n        } else if (currentParseState \u003d\u003d ParseState.PARSING_OP) {\n          parseOp(closingBracket);\n          closingBracket \u003d false;\n        } else {\n          // Might be a key or value. Move ahead.\n          offset++;\n        }\n        break;\n      }\n    }\n    if (!filterListStack.isEmpty()) {\n      filterListStack.clear();\n      throw new TimelineParseException(\"Encountered improper brackets while \" +\n          \"parsing \" + exprName + \".\");\n    }\n    if (currentParseState \u003d\u003d ParseState.PARSING_VALUE) {\n      setValueToCurrentFilter(\n          parseValue(expr.substring(kvStartOffset, offset)));\n    }\n    if (filterList \u003d\u003d null || filterList.getFilterList().isEmpty()) {\n      if (currentFilter \u003d\u003d null) {\n        throw new TimelineParseException(\n            \"Invalid expression provided for \" + exprName);\n      } else {\n        filterList \u003d new TimelineFilterList(currentFilter);\n      }\n    } else if (currentFilter !\u003d null) {\n      filterList.addFilter(currentFilter);\n    }\n    return filterList;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/reader/TimelineParserForCompareExpr.java",
      "extendedDetails": {}
    },
    "089caf49fe968cf4cd3fd4f9637da89ee143991a": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4447. Provide a mechanism to represent complex filters and parse them at the REST layer (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "089caf49fe968cf4cd3fd4f9637da89ee143991a",
      "commitAuthor": "Sangjin Lee",
      "diff": "@@ -0,0 +1,48 @@\n+  public TimelineFilterList parse() throws TimelineParseException {\n+    if (expr \u003d\u003d null || exprLength \u003d\u003d 0) {\n+      return null;\n+    }\n+    boolean closingBracket \u003d false;\n+    while (offset \u003c exprLength) {\n+      char offsetChar \u003d expr.charAt(offset);\n+      switch(offsetChar) {\n+      case TimelineParseConstants.SPACE_CHAR:\n+        handleSpaceChar();\n+        break;\n+      case TimelineParseConstants.OPENING_BRACKET_CHAR:\n+        handleOpeningBracketChar();\n+        break;\n+      case TimelineParseConstants.CLOSING_BRACKET_CHAR:\n+        handleClosingBracketChar();\n+        closingBracket \u003d true;\n+        break;\n+      default: // other characters.\n+        // Parse based on state.\n+        if (currentParseState \u003d\u003d ParseState.PARSING_COMPAREOP) {\n+          parseCompareOp();\n+        } else if (currentParseState \u003d\u003d ParseState.PARSING_OP) {\n+          parseOp(closingBracket);\n+          closingBracket \u003d false;\n+        } else {\n+          // Might be a key or value. Move ahead.\n+          offset++;\n+        }\n+        break;\n+      }\n+    }\n+    if (!filterListStack.isEmpty()) {\n+      filterListStack.clear();\n+      throw new TimelineParseException(\"Encountered improper brackets while \" +\n+          \"parsing \" + exprName + \".\");\n+    }\n+    if (currentParseState \u003d\u003d ParseState.PARSING_VALUE) {\n+      setValueToCurrentFilter(\n+          parseValue(expr.substring(kvStartOffset, offset)));\n+    }\n+    if (filterList \u003d\u003d null || filterList.getFilterList().isEmpty()) {\n+      filterList \u003d new TimelineFilterList(currentFilter);\n+    } else if (currentFilter !\u003d null) {\n+      filterList.addFilter(currentFilter);\n+    }\n+    return filterList;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelineFilterList parse() throws TimelineParseException {\n    if (expr \u003d\u003d null || exprLength \u003d\u003d 0) {\n      return null;\n    }\n    boolean closingBracket \u003d false;\n    while (offset \u003c exprLength) {\n      char offsetChar \u003d expr.charAt(offset);\n      switch(offsetChar) {\n      case TimelineParseConstants.SPACE_CHAR:\n        handleSpaceChar();\n        break;\n      case TimelineParseConstants.OPENING_BRACKET_CHAR:\n        handleOpeningBracketChar();\n        break;\n      case TimelineParseConstants.CLOSING_BRACKET_CHAR:\n        handleClosingBracketChar();\n        closingBracket \u003d true;\n        break;\n      default: // other characters.\n        // Parse based on state.\n        if (currentParseState \u003d\u003d ParseState.PARSING_COMPAREOP) {\n          parseCompareOp();\n        } else if (currentParseState \u003d\u003d ParseState.PARSING_OP) {\n          parseOp(closingBracket);\n          closingBracket \u003d false;\n        } else {\n          // Might be a key or value. Move ahead.\n          offset++;\n        }\n        break;\n      }\n    }\n    if (!filterListStack.isEmpty()) {\n      filterListStack.clear();\n      throw new TimelineParseException(\"Encountered improper brackets while \" +\n          \"parsing \" + exprName + \".\");\n    }\n    if (currentParseState \u003d\u003d ParseState.PARSING_VALUE) {\n      setValueToCurrentFilter(\n          parseValue(expr.substring(kvStartOffset, offset)));\n    }\n    if (filterList \u003d\u003d null || filterList.getFilterList().isEmpty()) {\n      filterList \u003d new TimelineFilterList(currentFilter);\n    } else if (currentFilter !\u003d null) {\n      filterList.addFilter(currentFilter);\n    }\n    return filterList;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/reader/TimelineParserForCompareExpr.java"
    }
  }
}