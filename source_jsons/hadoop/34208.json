{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AuxServices.java",
  "functionName": "serviceInit",
  "functionId": "serviceInit___conf-Configuration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
  "functionStartLine": 742,
  "functionEndLine": 781,
  "numCommitsSeen": 36,
  "timeTaken": 12116,
  "changeHistory": [
    "1ab69a9543df555b878951e66e3da13485e7f6d5",
    "c7a5a4435ec3098c2765e8ef53b7771e0532ff61",
    "58bc34f1e347034af566d6968eb3b3439a91cc74",
    "8cdb032aff4237d8d3970057d82290e4e32c4040",
    "00ebec89f101347a5da44657e388b30c57ed9deb",
    "665bb147aa3fc198e53335931562dd69f9f0e345",
    "d5ff57a08fac983f8b5d201064ce07945f0f216e",
    "72fe54684198b7df5c5fb2114616dff6d17a4402",
    "0bbe01f8d56191edfba3b50fb9f8859a0b3f826f",
    "447bd7b5a61a5788dc2a5d29cedfc19f0e99c0f5",
    "245012a9d9b0a21b8e93837e3e1a1892adcbf73c",
    "10a4289ebfe8a079562f2006a0e28acdbd8aa0c5",
    "3ee5949912a4fcd51e19ba758b6eff276543a74a",
    "0928502029ef141759008997335ea2cd836a7154",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "fafe8cd28e726566509c679e19d7da622f29f90d",
    "ade0f0560f729e50382c6992f713f29e2dd5b270",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "1ab69a9543df555b878951e66e3da13485e7f6d5": "Ybodychange",
    "c7a5a4435ec3098c2765e8ef53b7771e0532ff61": "Ymultichange(Ymodifierchange,Ybodychange)",
    "58bc34f1e347034af566d6968eb3b3439a91cc74": "Ybodychange",
    "8cdb032aff4237d8d3970057d82290e4e32c4040": "Ybodychange",
    "00ebec89f101347a5da44657e388b30c57ed9deb": "Ybodychange",
    "665bb147aa3fc198e53335931562dd69f9f0e345": "Ybodychange",
    "d5ff57a08fac983f8b5d201064ce07945f0f216e": "Ybodychange",
    "72fe54684198b7df5c5fb2114616dff6d17a4402": "Ybodychange",
    "0bbe01f8d56191edfba3b50fb9f8859a0b3f826f": "Ybodychange",
    "447bd7b5a61a5788dc2a5d29cedfc19f0e99c0f5": "Ybodychange",
    "245012a9d9b0a21b8e93837e3e1a1892adcbf73c": "Ybodychange",
    "10a4289ebfe8a079562f2006a0e28acdbd8aa0c5": "Ybodychange",
    "3ee5949912a4fcd51e19ba758b6eff276543a74a": "Ybodychange",
    "0928502029ef141759008997335ea2cd836a7154": "Ymultichange(Yrename,Yexceptionschange,Ybodychange)",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "fafe8cd28e726566509c679e19d7da622f29f90d": "Ybodychange",
    "ade0f0560f729e50382c6992f713f29e2dd5b270": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1ab69a9543df555b878951e66e3da13485e7f6d5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9221.  Added flag to disable dynamic auxiliary service feature.\n            Contributed by Billie Rinaldi\n",
      "commitDate": "25/01/19 4:05 PM",
      "commitName": "1ab69a9543df555b878951e66e3da13485e7f6d5",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "22/01/19 3:24 PM",
      "commitNameOld": "2fa9389c2e1ca4853a61533686941c685c889dbe",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 3.03,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,40 @@\n   public synchronized void serviceInit(Configuration conf) throws Exception {\n     boolean recoveryEnabled \u003d conf.getBoolean(\n         YarnConfiguration.NM_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n     if (recoveryEnabled) {\n       stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n           STATE_STORE_ROOT_NAME);\n       stateStoreFs \u003d FileSystem.getLocal(conf);\n     }\n-    String manifestStr \u003d conf.get(YarnConfiguration.NM_AUX_SERVICES_MANIFEST);\n-    if (manifestStr \u003d\u003d null) {\n+    manifestEnabled \u003d conf.getBoolean(\n+        YarnConfiguration.NM_AUX_SERVICES_MANIFEST_ENABLED,\n+        YarnConfiguration.DEFAULT_NM_AUX_SERVICES_MANIFEST_ENABLED);\n+    if (!manifestEnabled) {\n       Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n           YarnConfiguration.NM_AUX_SERVICES);\n       for (final String sName : auxNames) {\n         AuxServiceRecord service \u003d createServiceRecordFromConfiguration(sName,\n             conf);\n         maybeRemoveAuxService(sName);\n         AuxiliaryService s \u003d initAuxService(service, conf, true);\n         addService(sName, s, service);\n       }\n     } else {\n-      manifest \u003d new Path(manifestStr);\n-      manifestFS \u003d FileSystem.get(new URI(manifestStr), conf);\n-      loadManifest(conf, false);\n+      String manifestStr \u003d conf.get(YarnConfiguration.NM_AUX_SERVICES_MANIFEST);\n+      if (manifestStr !\u003d null) {\n+        manifest \u003d new Path(manifestStr);\n+        manifestFS \u003d FileSystem.get(new URI(manifestStr), conf);\n+        loadManifest(conf, false);\n+        manifestReloadInterval \u003d conf.getLong(\n+            YarnConfiguration.NM_AUX_SERVICES_MANIFEST_RELOAD_MS,\n+            YarnConfiguration.DEFAULT_NM_AUX_SERVICES_MANIFEST_RELOAD_MS);\n+        manifestReloadTask \u003d new ManifestReloadTask();\n+      } else {\n+        LOG.info(\"Auxiliary services manifest is enabled, but no manifest \" +\n+            \"file is specified in the configuration.\");\n+      }\n     }\n-    manifestReloadInterval \u003d conf.getLong(\n-        YarnConfiguration.NM_AUX_SERVICES_MANIFEST_RELOAD_MS,\n-        YarnConfiguration.DEFAULT_NM_AUX_SERVICES_MANIFEST_RELOAD_MS);\n-    manifestReloadTask \u003d new ManifestReloadTask();\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void serviceInit(Configuration conf) throws Exception {\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n          STATE_STORE_ROOT_NAME);\n      stateStoreFs \u003d FileSystem.getLocal(conf);\n    }\n    manifestEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_AUX_SERVICES_MANIFEST_ENABLED,\n        YarnConfiguration.DEFAULT_NM_AUX_SERVICES_MANIFEST_ENABLED);\n    if (!manifestEnabled) {\n      Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n          YarnConfiguration.NM_AUX_SERVICES);\n      for (final String sName : auxNames) {\n        AuxServiceRecord service \u003d createServiceRecordFromConfiguration(sName,\n            conf);\n        maybeRemoveAuxService(sName);\n        AuxiliaryService s \u003d initAuxService(service, conf, true);\n        addService(sName, s, service);\n      }\n    } else {\n      String manifestStr \u003d conf.get(YarnConfiguration.NM_AUX_SERVICES_MANIFEST);\n      if (manifestStr !\u003d null) {\n        manifest \u003d new Path(manifestStr);\n        manifestFS \u003d FileSystem.get(new URI(manifestStr), conf);\n        loadManifest(conf, false);\n        manifestReloadInterval \u003d conf.getLong(\n            YarnConfiguration.NM_AUX_SERVICES_MANIFEST_RELOAD_MS,\n            YarnConfiguration.DEFAULT_NM_AUX_SERVICES_MANIFEST_RELOAD_MS);\n        manifestReloadTask \u003d new ManifestReloadTask();\n      } else {\n        LOG.info(\"Auxiliary services manifest is enabled, but no manifest \" +\n            \"file is specified in the configuration.\");\n      }\n    }\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "c7a5a4435ec3098c2765e8ef53b7771e0532ff61": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-9075.  Add ability to register/remove auxiliary service without restart node manager.\n            Contributed by Billie Rinaldi\n",
      "commitDate": "18/12/18 2:05 PM",
      "commitName": "c7a5a4435ec3098c2765e8ef53b7771e0532ff61",
      "commitAuthor": "Eric Yang",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-9075.  Add ability to register/remove auxiliary service without restart node manager.\n            Contributed by Billie Rinaldi\n",
          "commitDate": "18/12/18 2:05 PM",
          "commitName": "c7a5a4435ec3098c2765e8ef53b7771e0532ff61",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "06/06/18 9:55 PM",
          "commitNameOld": "58bc34f1e347034af566d6968eb3b3439a91cc74",
          "commitAuthorOld": "Rohith Sharma K S",
          "daysBetweenCommits": 194.72,
          "commitsBetweenForRepo": 1523,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,176 +1,32 @@\n-  public void serviceInit(Configuration conf) throws Exception {\n-    final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n-    Path stateStoreRoot \u003d null;\n-    FileSystem stateStoreFs \u003d null;\n+  public synchronized void serviceInit(Configuration conf) throws Exception {\n     boolean recoveryEnabled \u003d conf.getBoolean(\n         YarnConfiguration.NM_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n     if (recoveryEnabled) {\n       stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n           STATE_STORE_ROOT_NAME);\n       stateStoreFs \u003d FileSystem.getLocal(conf);\n     }\n-    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n-        YarnConfiguration.NM_AUX_SERVICES);\n-    for (final String sName : auxNames) {\n-      try {\n-        Preconditions\n-            .checkArgument(\n-                validateAuxServiceName(sName),\n-                \"The ServiceName: \" + sName + \" set in \" +\n-                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n-                \"The valid service name should only contain a-zA-Z0-9_ \" +\n-                \"and can not start with numbers\");\n-        String classKey \u003d String.format(\n-            YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n-        String className \u003d conf.get(classKey);\n-        final String appLocalClassPath \u003d conf.get(String.format(\n-            YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n-        final String appRemoteClassPath \u003d conf.get(String.format(\n-            YarnConfiguration.NM_AUX_SERVICE_REMOTE_CLASSPATH, sName));\n-        AuxiliaryService s \u003d null;\n-        boolean useCustomerClassLoader \u003d ((appLocalClassPath !\u003d null\n-            \u0026\u0026 !appLocalClassPath.isEmpty()) ||\n-            (appRemoteClassPath !\u003d null \u0026\u0026 !appRemoteClassPath.isEmpty()))\n-            \u0026\u0026 className !\u003d null \u0026\u0026 !className.isEmpty();\n-        if (useCustomerClassLoader) {\n-          // load AuxiliaryService from local class path\n-          if (appRemoteClassPath \u003d\u003d null || appRemoteClassPath.isEmpty()) {\n-            s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n-                conf, className, appLocalClassPath);\n-          } else {\n-            // load AuxiliaryService from remote class path\n-            if (appLocalClassPath !\u003d null \u0026\u0026 !appLocalClassPath.isEmpty()) {\n-              throw new YarnRuntimeException(\"The aux serivce:\" + sName\n-                  + \" has configured local classpath:\" + appLocalClassPath\n-                  + \" and remote classpath:\" + appRemoteClassPath\n-                  + \". Only one of them should be configured.\");\n-            }\n-            FileContext localLFS \u003d getLocalFileContext(conf);\n-            // create NM aux-service dir in NM localdir if it does not exist.\n-            Path nmAuxDir \u003d dirsHandler.getLocalPathForWrite(\".\"\n-                + Path.SEPARATOR + NM_AUX_SERVICE_DIR);\n-            if (!localLFS.util().exists(nmAuxDir)) {\n-              try {\n-                localLFS.mkdir(nmAuxDir, NM_AUX_SERVICE_DIR_PERM, true);\n-              } catch (IOException ex) {\n-                throw new YarnRuntimeException(\"Fail to create dir:\"\n-                    + nmAuxDir.toString(), ex);\n-              }\n-            }\n-            Path src \u003d new Path(appRemoteClassPath);\n-            FileContext remoteLFS \u003d getRemoteFileContext(src.toUri(), conf);\n-            FileStatus scFileStatus \u003d remoteLFS.getFileStatus(src);\n-            if (!scFileStatus.getOwner().equals(\n-                this.userUGI.getShortUserName())) {\n-              throw new YarnRuntimeException(\"The remote jarfile owner:\"\n-                  + scFileStatus.getOwner() + \" is not the same as the NM user:\"\n-                  + this.userUGI.getShortUserName() + \".\");\n-            }\n-            if ((scFileStatus.getPermission().toShort() \u0026 0022) !\u003d 0) {\n-              throw new YarnRuntimeException(\"The remote jarfile should not \"\n-                  + \"be writable by group or others. \"\n-                  + \"The current Permission is \"\n-                  + scFileStatus.getPermission().toShort());\n-            }\n-            Path dest \u003d null;\n-            Path downloadDest \u003d new Path(nmAuxDir,\n-                className + \"_\" + scFileStatus.getModificationTime());\n-            // check whether we need to re-download the jar\n-            // from remote directory\n-            Path targetDirPath \u003d new Path(downloadDest,\n-                scFileStatus.getPath().getName());\n-            FileStatus[] allSubDirs \u003d localLFS.util().listStatus(nmAuxDir);\n-            boolean reDownload \u003d true;\n-            for (FileStatus sub : allSubDirs) {\n-              if (sub.getPath().getName().equals(downloadDest.getName())) {\n-                reDownload \u003d false;\n-                dest \u003d new Path(targetDirPath + Path.SEPARATOR + \"*\");\n-                break;\n-              } else {\n-                if (sub.getPath().getName().contains(className) \u0026\u0026\n-                    !sub.getPath().getName().endsWith(DEL_SUFFIX)) {\n-                  Path delPath \u003d new Path(sub.getPath().getParent(),\n-                      sub.getPath().getName() + DEL_SUFFIX);\n-                  localLFS.rename(sub.getPath(), delPath);\n-                  LOG.info(\"delete old aux service jar dir:\"\n-                      + delPath.toString());\n-                  FileDeletionTask deletionTask \u003d new FileDeletionTask(\n-                      this.delService, null, delPath, null);\n-                  this.delService.delete(deletionTask);\n-                }\n-              }\n-            }\n-            if (reDownload) {\n-              LocalResourceType srcType \u003d null;\n-              String lowerDst \u003d StringUtils.toLowerCase(src.toString());\n-              if (lowerDst.endsWith(\".jar\")) {\n-                srcType \u003d LocalResourceType.FILE;\n-              } else if (lowerDst.endsWith(\".zip\") ||\n-                  lowerDst.endsWith(\".tar.gz\") || lowerDst.endsWith(\".tgz\")\n-                  || lowerDst.endsWith(\".tar\")) {\n-                srcType \u003d LocalResourceType.ARCHIVE;\n-              } else {\n-                throw new YarnRuntimeException(\n-                    \"Can not unpack file from remote-file-path:\" + src\n-                        + \"for aux-service:\" + \".\\n\");\n-              }\n-              LocalResource scRsrc \u003d LocalResource.newInstance(\n-                  URL.fromURI(src.toUri()),\n-                  srcType, LocalResourceVisibility.PRIVATE,\n-                  scFileStatus.getLen(), scFileStatus.getModificationTime());\n-              FSDownload download \u003d new FSDownload(localLFS, null, conf,\n-                  downloadDest, scRsrc, null);\n-              try {\n-                Path downloaded \u003d download.call();\n-                // don\u0027t need to convert downloaded path into a dir\n-                // since its already a jar path.\n-                dest \u003d downloaded;\n-              } catch (Exception ex) {\n-                throw new YarnRuntimeException(\n-                    \"Exception happend while downloading files \"\n-                    + \"for aux-service:\" + sName + \" and remote-file-path:\"\n-                    + src + \".\\n\" + ex.getMessage());\n-              }\n-            }\n-            s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n-                new Configuration(conf), className, dest.toString());\n-          }\n-          LOG.info(\"The aux service:\" + sName\n-              + \" are using the custom classloader\");\n-        } else {\n-          Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n-              classKey, null, AuxiliaryService.class);\n-\n-          if (sClass \u003d\u003d null) {\n-            throw new RuntimeException(\"No class defined for \" + sName);\n-          }\n-          s \u003d ReflectionUtils.newInstance(sClass, new Configuration(conf));\n-        }\n-        if (s \u003d\u003d null) {\n-          throw new RuntimeException(\"No object created for \" + sName);\n-        }\n-        // TODO better use s.getName()?\n-        if(!sName.equals(s.getName())) {\n-          LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n-              +\"configuration is for \"+s.getClass()+\" which has \"\n-              +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n-              +\"not the same tools trying to send ServiceData and read \"\n-              +\"Service Meta Data may have issues unless the refer to \"\n-              +\"the name in the config.\");\n-        }\n-        s.setAuxiliaryLocalPathHandler(auxiliaryLocalPathHandler);\n-        addService(sName, s);\n-        if (recoveryEnabled) {\n-          Path storePath \u003d new Path(stateStoreRoot, sName);\n-          stateStoreFs.mkdirs(storePath, storeDirPerms);\n-          s.setRecoveryPath(storePath);\n-        }\n-        s.init(new Configuration(conf));\n-      } catch (RuntimeException e) {\n-        LOG.error(\"Failed to initialize \" + sName, e);\n-        throw e;\n+    String manifestStr \u003d conf.get(YarnConfiguration.NM_AUX_SERVICES_MANIFEST);\n+    if (manifestStr \u003d\u003d null) {\n+      Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n+          YarnConfiguration.NM_AUX_SERVICES);\n+      for (final String sName : auxNames) {\n+        AuxServiceRecord service \u003d createServiceRecordFromConfiguration(sName,\n+            conf);\n+        maybeRemoveAuxService(sName);\n+        AuxiliaryService s \u003d initAuxService(service, conf, true);\n+        addService(sName, s, service);\n       }\n+    } else {\n+      manifest \u003d new Path(manifestStr);\n+      manifestFS \u003d FileSystem.get(new URI(manifestStr), conf);\n+      loadManifest(conf, false);\n     }\n+    manifestReloadInterval \u003d conf.getLong(\n+        YarnConfiguration.NM_AUX_SERVICES_MANIFEST_RELOAD_MS,\n+        YarnConfiguration.DEFAULT_NM_AUX_SERVICES_MANIFEST_RELOAD_MS);\n+    manifestReloadTask \u003d new ManifestReloadTask();\n+\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void serviceInit(Configuration conf) throws Exception {\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n          STATE_STORE_ROOT_NAME);\n      stateStoreFs \u003d FileSystem.getLocal(conf);\n    }\n    String manifestStr \u003d conf.get(YarnConfiguration.NM_AUX_SERVICES_MANIFEST);\n    if (manifestStr \u003d\u003d null) {\n      Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n          YarnConfiguration.NM_AUX_SERVICES);\n      for (final String sName : auxNames) {\n        AuxServiceRecord service \u003d createServiceRecordFromConfiguration(sName,\n            conf);\n        maybeRemoveAuxService(sName);\n        AuxiliaryService s \u003d initAuxService(service, conf, true);\n        addService(sName, s, service);\n      }\n    } else {\n      manifest \u003d new Path(manifestStr);\n      manifestFS \u003d FileSystem.get(new URI(manifestStr), conf);\n      loadManifest(conf, false);\n    }\n    manifestReloadInterval \u003d conf.getLong(\n        YarnConfiguration.NM_AUX_SERVICES_MANIFEST_RELOAD_MS,\n        YarnConfiguration.DEFAULT_NM_AUX_SERVICES_MANIFEST_RELOAD_MS);\n    manifestReloadTask \u003d new ManifestReloadTask();\n\n    super.serviceInit(conf);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[public, synchronized]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9075.  Add ability to register/remove auxiliary service without restart node manager.\n            Contributed by Billie Rinaldi\n",
          "commitDate": "18/12/18 2:05 PM",
          "commitName": "c7a5a4435ec3098c2765e8ef53b7771e0532ff61",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "06/06/18 9:55 PM",
          "commitNameOld": "58bc34f1e347034af566d6968eb3b3439a91cc74",
          "commitAuthorOld": "Rohith Sharma K S",
          "daysBetweenCommits": 194.72,
          "commitsBetweenForRepo": 1523,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,176 +1,32 @@\n-  public void serviceInit(Configuration conf) throws Exception {\n-    final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n-    Path stateStoreRoot \u003d null;\n-    FileSystem stateStoreFs \u003d null;\n+  public synchronized void serviceInit(Configuration conf) throws Exception {\n     boolean recoveryEnabled \u003d conf.getBoolean(\n         YarnConfiguration.NM_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n     if (recoveryEnabled) {\n       stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n           STATE_STORE_ROOT_NAME);\n       stateStoreFs \u003d FileSystem.getLocal(conf);\n     }\n-    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n-        YarnConfiguration.NM_AUX_SERVICES);\n-    for (final String sName : auxNames) {\n-      try {\n-        Preconditions\n-            .checkArgument(\n-                validateAuxServiceName(sName),\n-                \"The ServiceName: \" + sName + \" set in \" +\n-                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n-                \"The valid service name should only contain a-zA-Z0-9_ \" +\n-                \"and can not start with numbers\");\n-        String classKey \u003d String.format(\n-            YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n-        String className \u003d conf.get(classKey);\n-        final String appLocalClassPath \u003d conf.get(String.format(\n-            YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n-        final String appRemoteClassPath \u003d conf.get(String.format(\n-            YarnConfiguration.NM_AUX_SERVICE_REMOTE_CLASSPATH, sName));\n-        AuxiliaryService s \u003d null;\n-        boolean useCustomerClassLoader \u003d ((appLocalClassPath !\u003d null\n-            \u0026\u0026 !appLocalClassPath.isEmpty()) ||\n-            (appRemoteClassPath !\u003d null \u0026\u0026 !appRemoteClassPath.isEmpty()))\n-            \u0026\u0026 className !\u003d null \u0026\u0026 !className.isEmpty();\n-        if (useCustomerClassLoader) {\n-          // load AuxiliaryService from local class path\n-          if (appRemoteClassPath \u003d\u003d null || appRemoteClassPath.isEmpty()) {\n-            s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n-                conf, className, appLocalClassPath);\n-          } else {\n-            // load AuxiliaryService from remote class path\n-            if (appLocalClassPath !\u003d null \u0026\u0026 !appLocalClassPath.isEmpty()) {\n-              throw new YarnRuntimeException(\"The aux serivce:\" + sName\n-                  + \" has configured local classpath:\" + appLocalClassPath\n-                  + \" and remote classpath:\" + appRemoteClassPath\n-                  + \". Only one of them should be configured.\");\n-            }\n-            FileContext localLFS \u003d getLocalFileContext(conf);\n-            // create NM aux-service dir in NM localdir if it does not exist.\n-            Path nmAuxDir \u003d dirsHandler.getLocalPathForWrite(\".\"\n-                + Path.SEPARATOR + NM_AUX_SERVICE_DIR);\n-            if (!localLFS.util().exists(nmAuxDir)) {\n-              try {\n-                localLFS.mkdir(nmAuxDir, NM_AUX_SERVICE_DIR_PERM, true);\n-              } catch (IOException ex) {\n-                throw new YarnRuntimeException(\"Fail to create dir:\"\n-                    + nmAuxDir.toString(), ex);\n-              }\n-            }\n-            Path src \u003d new Path(appRemoteClassPath);\n-            FileContext remoteLFS \u003d getRemoteFileContext(src.toUri(), conf);\n-            FileStatus scFileStatus \u003d remoteLFS.getFileStatus(src);\n-            if (!scFileStatus.getOwner().equals(\n-                this.userUGI.getShortUserName())) {\n-              throw new YarnRuntimeException(\"The remote jarfile owner:\"\n-                  + scFileStatus.getOwner() + \" is not the same as the NM user:\"\n-                  + this.userUGI.getShortUserName() + \".\");\n-            }\n-            if ((scFileStatus.getPermission().toShort() \u0026 0022) !\u003d 0) {\n-              throw new YarnRuntimeException(\"The remote jarfile should not \"\n-                  + \"be writable by group or others. \"\n-                  + \"The current Permission is \"\n-                  + scFileStatus.getPermission().toShort());\n-            }\n-            Path dest \u003d null;\n-            Path downloadDest \u003d new Path(nmAuxDir,\n-                className + \"_\" + scFileStatus.getModificationTime());\n-            // check whether we need to re-download the jar\n-            // from remote directory\n-            Path targetDirPath \u003d new Path(downloadDest,\n-                scFileStatus.getPath().getName());\n-            FileStatus[] allSubDirs \u003d localLFS.util().listStatus(nmAuxDir);\n-            boolean reDownload \u003d true;\n-            for (FileStatus sub : allSubDirs) {\n-              if (sub.getPath().getName().equals(downloadDest.getName())) {\n-                reDownload \u003d false;\n-                dest \u003d new Path(targetDirPath + Path.SEPARATOR + \"*\");\n-                break;\n-              } else {\n-                if (sub.getPath().getName().contains(className) \u0026\u0026\n-                    !sub.getPath().getName().endsWith(DEL_SUFFIX)) {\n-                  Path delPath \u003d new Path(sub.getPath().getParent(),\n-                      sub.getPath().getName() + DEL_SUFFIX);\n-                  localLFS.rename(sub.getPath(), delPath);\n-                  LOG.info(\"delete old aux service jar dir:\"\n-                      + delPath.toString());\n-                  FileDeletionTask deletionTask \u003d new FileDeletionTask(\n-                      this.delService, null, delPath, null);\n-                  this.delService.delete(deletionTask);\n-                }\n-              }\n-            }\n-            if (reDownload) {\n-              LocalResourceType srcType \u003d null;\n-              String lowerDst \u003d StringUtils.toLowerCase(src.toString());\n-              if (lowerDst.endsWith(\".jar\")) {\n-                srcType \u003d LocalResourceType.FILE;\n-              } else if (lowerDst.endsWith(\".zip\") ||\n-                  lowerDst.endsWith(\".tar.gz\") || lowerDst.endsWith(\".tgz\")\n-                  || lowerDst.endsWith(\".tar\")) {\n-                srcType \u003d LocalResourceType.ARCHIVE;\n-              } else {\n-                throw new YarnRuntimeException(\n-                    \"Can not unpack file from remote-file-path:\" + src\n-                        + \"for aux-service:\" + \".\\n\");\n-              }\n-              LocalResource scRsrc \u003d LocalResource.newInstance(\n-                  URL.fromURI(src.toUri()),\n-                  srcType, LocalResourceVisibility.PRIVATE,\n-                  scFileStatus.getLen(), scFileStatus.getModificationTime());\n-              FSDownload download \u003d new FSDownload(localLFS, null, conf,\n-                  downloadDest, scRsrc, null);\n-              try {\n-                Path downloaded \u003d download.call();\n-                // don\u0027t need to convert downloaded path into a dir\n-                // since its already a jar path.\n-                dest \u003d downloaded;\n-              } catch (Exception ex) {\n-                throw new YarnRuntimeException(\n-                    \"Exception happend while downloading files \"\n-                    + \"for aux-service:\" + sName + \" and remote-file-path:\"\n-                    + src + \".\\n\" + ex.getMessage());\n-              }\n-            }\n-            s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n-                new Configuration(conf), className, dest.toString());\n-          }\n-          LOG.info(\"The aux service:\" + sName\n-              + \" are using the custom classloader\");\n-        } else {\n-          Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n-              classKey, null, AuxiliaryService.class);\n-\n-          if (sClass \u003d\u003d null) {\n-            throw new RuntimeException(\"No class defined for \" + sName);\n-          }\n-          s \u003d ReflectionUtils.newInstance(sClass, new Configuration(conf));\n-        }\n-        if (s \u003d\u003d null) {\n-          throw new RuntimeException(\"No object created for \" + sName);\n-        }\n-        // TODO better use s.getName()?\n-        if(!sName.equals(s.getName())) {\n-          LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n-              +\"configuration is for \"+s.getClass()+\" which has \"\n-              +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n-              +\"not the same tools trying to send ServiceData and read \"\n-              +\"Service Meta Data may have issues unless the refer to \"\n-              +\"the name in the config.\");\n-        }\n-        s.setAuxiliaryLocalPathHandler(auxiliaryLocalPathHandler);\n-        addService(sName, s);\n-        if (recoveryEnabled) {\n-          Path storePath \u003d new Path(stateStoreRoot, sName);\n-          stateStoreFs.mkdirs(storePath, storeDirPerms);\n-          s.setRecoveryPath(storePath);\n-        }\n-        s.init(new Configuration(conf));\n-      } catch (RuntimeException e) {\n-        LOG.error(\"Failed to initialize \" + sName, e);\n-        throw e;\n+    String manifestStr \u003d conf.get(YarnConfiguration.NM_AUX_SERVICES_MANIFEST);\n+    if (manifestStr \u003d\u003d null) {\n+      Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n+          YarnConfiguration.NM_AUX_SERVICES);\n+      for (final String sName : auxNames) {\n+        AuxServiceRecord service \u003d createServiceRecordFromConfiguration(sName,\n+            conf);\n+        maybeRemoveAuxService(sName);\n+        AuxiliaryService s \u003d initAuxService(service, conf, true);\n+        addService(sName, s, service);\n       }\n+    } else {\n+      manifest \u003d new Path(manifestStr);\n+      manifestFS \u003d FileSystem.get(new URI(manifestStr), conf);\n+      loadManifest(conf, false);\n     }\n+    manifestReloadInterval \u003d conf.getLong(\n+        YarnConfiguration.NM_AUX_SERVICES_MANIFEST_RELOAD_MS,\n+        YarnConfiguration.DEFAULT_NM_AUX_SERVICES_MANIFEST_RELOAD_MS);\n+    manifestReloadTask \u003d new ManifestReloadTask();\n+\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void serviceInit(Configuration conf) throws Exception {\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n          STATE_STORE_ROOT_NAME);\n      stateStoreFs \u003d FileSystem.getLocal(conf);\n    }\n    String manifestStr \u003d conf.get(YarnConfiguration.NM_AUX_SERVICES_MANIFEST);\n    if (manifestStr \u003d\u003d null) {\n      Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n          YarnConfiguration.NM_AUX_SERVICES);\n      for (final String sName : auxNames) {\n        AuxServiceRecord service \u003d createServiceRecordFromConfiguration(sName,\n            conf);\n        maybeRemoveAuxService(sName);\n        AuxiliaryService s \u003d initAuxService(service, conf, true);\n        addService(sName, s, service);\n      }\n    } else {\n      manifest \u003d new Path(manifestStr);\n      manifestFS \u003d FileSystem.get(new URI(manifestStr), conf);\n      loadManifest(conf, false);\n    }\n    manifestReloadInterval \u003d conf.getLong(\n        YarnConfiguration.NM_AUX_SERVICES_MANIFEST_RELOAD_MS,\n        YarnConfiguration.DEFAULT_NM_AUX_SERVICES_MANIFEST_RELOAD_MS);\n    manifestReloadTask \u003d new ManifestReloadTask();\n\n    super.serviceInit(conf);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "58bc34f1e347034af566d6968eb3b3439a91cc74": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8399. NodeManager is giving 403 GSS exception post upgrade to 3.1 in secure mode. Contributed by Sunil Govindan.\n",
      "commitDate": "06/06/18 9:55 PM",
      "commitName": "58bc34f1e347034af566d6968eb3b3439a91cc74",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "04/05/18 9:36 AM",
      "commitNameOld": "8cdb032aff4237d8d3970057d82290e4e32c4040",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 33.51,
      "commitsBetweenForRepo": 279,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,176 +1,176 @@\n   public void serviceInit(Configuration conf) throws Exception {\n     final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n     Path stateStoreRoot \u003d null;\n     FileSystem stateStoreFs \u003d null;\n     boolean recoveryEnabled \u003d conf.getBoolean(\n         YarnConfiguration.NM_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n     if (recoveryEnabled) {\n       stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n           STATE_STORE_ROOT_NAME);\n       stateStoreFs \u003d FileSystem.getLocal(conf);\n     }\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Preconditions\n             .checkArgument(\n                 validateAuxServiceName(sName),\n                 \"The ServiceName: \" + sName + \" set in \" +\n                 YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                 \"The valid service name should only contain a-zA-Z0-9_ \" +\n                 \"and can not start with numbers\");\n         String classKey \u003d String.format(\n             YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n         String className \u003d conf.get(classKey);\n         final String appLocalClassPath \u003d conf.get(String.format(\n             YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n         final String appRemoteClassPath \u003d conf.get(String.format(\n             YarnConfiguration.NM_AUX_SERVICE_REMOTE_CLASSPATH, sName));\n         AuxiliaryService s \u003d null;\n         boolean useCustomerClassLoader \u003d ((appLocalClassPath !\u003d null\n             \u0026\u0026 !appLocalClassPath.isEmpty()) ||\n             (appRemoteClassPath !\u003d null \u0026\u0026 !appRemoteClassPath.isEmpty()))\n             \u0026\u0026 className !\u003d null \u0026\u0026 !className.isEmpty();\n         if (useCustomerClassLoader) {\n           // load AuxiliaryService from local class path\n           if (appRemoteClassPath \u003d\u003d null || appRemoteClassPath.isEmpty()) {\n             s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n                 conf, className, appLocalClassPath);\n           } else {\n             // load AuxiliaryService from remote class path\n             if (appLocalClassPath !\u003d null \u0026\u0026 !appLocalClassPath.isEmpty()) {\n               throw new YarnRuntimeException(\"The aux serivce:\" + sName\n                   + \" has configured local classpath:\" + appLocalClassPath\n                   + \" and remote classpath:\" + appRemoteClassPath\n                   + \". Only one of them should be configured.\");\n             }\n             FileContext localLFS \u003d getLocalFileContext(conf);\n             // create NM aux-service dir in NM localdir if it does not exist.\n             Path nmAuxDir \u003d dirsHandler.getLocalPathForWrite(\".\"\n                 + Path.SEPARATOR + NM_AUX_SERVICE_DIR);\n             if (!localLFS.util().exists(nmAuxDir)) {\n               try {\n                 localLFS.mkdir(nmAuxDir, NM_AUX_SERVICE_DIR_PERM, true);\n               } catch (IOException ex) {\n                 throw new YarnRuntimeException(\"Fail to create dir:\"\n                     + nmAuxDir.toString(), ex);\n               }\n             }\n             Path src \u003d new Path(appRemoteClassPath);\n             FileContext remoteLFS \u003d getRemoteFileContext(src.toUri(), conf);\n             FileStatus scFileStatus \u003d remoteLFS.getFileStatus(src);\n             if (!scFileStatus.getOwner().equals(\n                 this.userUGI.getShortUserName())) {\n               throw new YarnRuntimeException(\"The remote jarfile owner:\"\n                   + scFileStatus.getOwner() + \" is not the same as the NM user:\"\n                   + this.userUGI.getShortUserName() + \".\");\n             }\n             if ((scFileStatus.getPermission().toShort() \u0026 0022) !\u003d 0) {\n               throw new YarnRuntimeException(\"The remote jarfile should not \"\n                   + \"be writable by group or others. \"\n                   + \"The current Permission is \"\n                   + scFileStatus.getPermission().toShort());\n             }\n             Path dest \u003d null;\n             Path downloadDest \u003d new Path(nmAuxDir,\n                 className + \"_\" + scFileStatus.getModificationTime());\n             // check whether we need to re-download the jar\n             // from remote directory\n             Path targetDirPath \u003d new Path(downloadDest,\n                 scFileStatus.getPath().getName());\n             FileStatus[] allSubDirs \u003d localLFS.util().listStatus(nmAuxDir);\n             boolean reDownload \u003d true;\n             for (FileStatus sub : allSubDirs) {\n               if (sub.getPath().getName().equals(downloadDest.getName())) {\n                 reDownload \u003d false;\n                 dest \u003d new Path(targetDirPath + Path.SEPARATOR + \"*\");\n                 break;\n               } else {\n                 if (sub.getPath().getName().contains(className) \u0026\u0026\n                     !sub.getPath().getName().endsWith(DEL_SUFFIX)) {\n                   Path delPath \u003d new Path(sub.getPath().getParent(),\n                       sub.getPath().getName() + DEL_SUFFIX);\n                   localLFS.rename(sub.getPath(), delPath);\n                   LOG.info(\"delete old aux service jar dir:\"\n                       + delPath.toString());\n                   FileDeletionTask deletionTask \u003d new FileDeletionTask(\n                       this.delService, null, delPath, null);\n                   this.delService.delete(deletionTask);\n                 }\n               }\n             }\n             if (reDownload) {\n               LocalResourceType srcType \u003d null;\n               String lowerDst \u003d StringUtils.toLowerCase(src.toString());\n               if (lowerDst.endsWith(\".jar\")) {\n                 srcType \u003d LocalResourceType.FILE;\n               } else if (lowerDst.endsWith(\".zip\") ||\n                   lowerDst.endsWith(\".tar.gz\") || lowerDst.endsWith(\".tgz\")\n                   || lowerDst.endsWith(\".tar\")) {\n                 srcType \u003d LocalResourceType.ARCHIVE;\n               } else {\n                 throw new YarnRuntimeException(\n                     \"Can not unpack file from remote-file-path:\" + src\n                         + \"for aux-service:\" + \".\\n\");\n               }\n               LocalResource scRsrc \u003d LocalResource.newInstance(\n                   URL.fromURI(src.toUri()),\n                   srcType, LocalResourceVisibility.PRIVATE,\n                   scFileStatus.getLen(), scFileStatus.getModificationTime());\n               FSDownload download \u003d new FSDownload(localLFS, null, conf,\n                   downloadDest, scRsrc, null);\n               try {\n                 Path downloaded \u003d download.call();\n                 // don\u0027t need to convert downloaded path into a dir\n                 // since its already a jar path.\n                 dest \u003d downloaded;\n               } catch (Exception ex) {\n                 throw new YarnRuntimeException(\n                     \"Exception happend while downloading files \"\n                     + \"for aux-service:\" + sName + \" and remote-file-path:\"\n                     + src + \".\\n\" + ex.getMessage());\n               }\n             }\n             s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n-                conf, className, dest.toString());\n+                new Configuration(conf), className, dest.toString());\n           }\n           LOG.info(\"The aux service:\" + sName\n               + \" are using the custom classloader\");\n         } else {\n           Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               classKey, null, AuxiliaryService.class);\n \n           if (sClass \u003d\u003d null) {\n             throw new RuntimeException(\"No class defined for \" + sName);\n           }\n-          s \u003d ReflectionUtils.newInstance(sClass, conf);\n+          s \u003d ReflectionUtils.newInstance(sClass, new Configuration(conf));\n         }\n         if (s \u003d\u003d null) {\n           throw new RuntimeException(\"No object created for \" + sName);\n         }\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n               +\"configuration is for \"+s.getClass()+\" which has \"\n               +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n               +\"not the same tools trying to send ServiceData and read \"\n               +\"Service Meta Data may have issues unless the refer to \"\n               +\"the name in the config.\");\n         }\n         s.setAuxiliaryLocalPathHandler(auxiliaryLocalPathHandler);\n         addService(sName, s);\n         if (recoveryEnabled) {\n           Path storePath \u003d new Path(stateStoreRoot, sName);\n           stateStoreFs.mkdirs(storePath, storeDirPerms);\n           s.setRecoveryPath(storePath);\n         }\n-        s.init(conf);\n+        s.init(new Configuration(conf));\n       } catch (RuntimeException e) {\n         LOG.error(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n    Path stateStoreRoot \u003d null;\n    FileSystem stateStoreFs \u003d null;\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n          STATE_STORE_ROOT_NAME);\n      stateStoreFs \u003d FileSystem.getLocal(conf);\n    }\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Preconditions\n            .checkArgument(\n                validateAuxServiceName(sName),\n                \"The ServiceName: \" + sName + \" set in \" +\n                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                \"The valid service name should only contain a-zA-Z0-9_ \" +\n                \"and can not start with numbers\");\n        String classKey \u003d String.format(\n            YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n        String className \u003d conf.get(classKey);\n        final String appLocalClassPath \u003d conf.get(String.format(\n            YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n        final String appRemoteClassPath \u003d conf.get(String.format(\n            YarnConfiguration.NM_AUX_SERVICE_REMOTE_CLASSPATH, sName));\n        AuxiliaryService s \u003d null;\n        boolean useCustomerClassLoader \u003d ((appLocalClassPath !\u003d null\n            \u0026\u0026 !appLocalClassPath.isEmpty()) ||\n            (appRemoteClassPath !\u003d null \u0026\u0026 !appRemoteClassPath.isEmpty()))\n            \u0026\u0026 className !\u003d null \u0026\u0026 !className.isEmpty();\n        if (useCustomerClassLoader) {\n          // load AuxiliaryService from local class path\n          if (appRemoteClassPath \u003d\u003d null || appRemoteClassPath.isEmpty()) {\n            s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n                conf, className, appLocalClassPath);\n          } else {\n            // load AuxiliaryService from remote class path\n            if (appLocalClassPath !\u003d null \u0026\u0026 !appLocalClassPath.isEmpty()) {\n              throw new YarnRuntimeException(\"The aux serivce:\" + sName\n                  + \" has configured local classpath:\" + appLocalClassPath\n                  + \" and remote classpath:\" + appRemoteClassPath\n                  + \". Only one of them should be configured.\");\n            }\n            FileContext localLFS \u003d getLocalFileContext(conf);\n            // create NM aux-service dir in NM localdir if it does not exist.\n            Path nmAuxDir \u003d dirsHandler.getLocalPathForWrite(\".\"\n                + Path.SEPARATOR + NM_AUX_SERVICE_DIR);\n            if (!localLFS.util().exists(nmAuxDir)) {\n              try {\n                localLFS.mkdir(nmAuxDir, NM_AUX_SERVICE_DIR_PERM, true);\n              } catch (IOException ex) {\n                throw new YarnRuntimeException(\"Fail to create dir:\"\n                    + nmAuxDir.toString(), ex);\n              }\n            }\n            Path src \u003d new Path(appRemoteClassPath);\n            FileContext remoteLFS \u003d getRemoteFileContext(src.toUri(), conf);\n            FileStatus scFileStatus \u003d remoteLFS.getFileStatus(src);\n            if (!scFileStatus.getOwner().equals(\n                this.userUGI.getShortUserName())) {\n              throw new YarnRuntimeException(\"The remote jarfile owner:\"\n                  + scFileStatus.getOwner() + \" is not the same as the NM user:\"\n                  + this.userUGI.getShortUserName() + \".\");\n            }\n            if ((scFileStatus.getPermission().toShort() \u0026 0022) !\u003d 0) {\n              throw new YarnRuntimeException(\"The remote jarfile should not \"\n                  + \"be writable by group or others. \"\n                  + \"The current Permission is \"\n                  + scFileStatus.getPermission().toShort());\n            }\n            Path dest \u003d null;\n            Path downloadDest \u003d new Path(nmAuxDir,\n                className + \"_\" + scFileStatus.getModificationTime());\n            // check whether we need to re-download the jar\n            // from remote directory\n            Path targetDirPath \u003d new Path(downloadDest,\n                scFileStatus.getPath().getName());\n            FileStatus[] allSubDirs \u003d localLFS.util().listStatus(nmAuxDir);\n            boolean reDownload \u003d true;\n            for (FileStatus sub : allSubDirs) {\n              if (sub.getPath().getName().equals(downloadDest.getName())) {\n                reDownload \u003d false;\n                dest \u003d new Path(targetDirPath + Path.SEPARATOR + \"*\");\n                break;\n              } else {\n                if (sub.getPath().getName().contains(className) \u0026\u0026\n                    !sub.getPath().getName().endsWith(DEL_SUFFIX)) {\n                  Path delPath \u003d new Path(sub.getPath().getParent(),\n                      sub.getPath().getName() + DEL_SUFFIX);\n                  localLFS.rename(sub.getPath(), delPath);\n                  LOG.info(\"delete old aux service jar dir:\"\n                      + delPath.toString());\n                  FileDeletionTask deletionTask \u003d new FileDeletionTask(\n                      this.delService, null, delPath, null);\n                  this.delService.delete(deletionTask);\n                }\n              }\n            }\n            if (reDownload) {\n              LocalResourceType srcType \u003d null;\n              String lowerDst \u003d StringUtils.toLowerCase(src.toString());\n              if (lowerDst.endsWith(\".jar\")) {\n                srcType \u003d LocalResourceType.FILE;\n              } else if (lowerDst.endsWith(\".zip\") ||\n                  lowerDst.endsWith(\".tar.gz\") || lowerDst.endsWith(\".tgz\")\n                  || lowerDst.endsWith(\".tar\")) {\n                srcType \u003d LocalResourceType.ARCHIVE;\n              } else {\n                throw new YarnRuntimeException(\n                    \"Can not unpack file from remote-file-path:\" + src\n                        + \"for aux-service:\" + \".\\n\");\n              }\n              LocalResource scRsrc \u003d LocalResource.newInstance(\n                  URL.fromURI(src.toUri()),\n                  srcType, LocalResourceVisibility.PRIVATE,\n                  scFileStatus.getLen(), scFileStatus.getModificationTime());\n              FSDownload download \u003d new FSDownload(localLFS, null, conf,\n                  downloadDest, scRsrc, null);\n              try {\n                Path downloaded \u003d download.call();\n                // don\u0027t need to convert downloaded path into a dir\n                // since its already a jar path.\n                dest \u003d downloaded;\n              } catch (Exception ex) {\n                throw new YarnRuntimeException(\n                    \"Exception happend while downloading files \"\n                    + \"for aux-service:\" + sName + \" and remote-file-path:\"\n                    + src + \".\\n\" + ex.getMessage());\n              }\n            }\n            s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n                new Configuration(conf), className, dest.toString());\n          }\n          LOG.info(\"The aux service:\" + sName\n              + \" are using the custom classloader\");\n        } else {\n          Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              classKey, null, AuxiliaryService.class);\n\n          if (sClass \u003d\u003d null) {\n            throw new RuntimeException(\"No class defined for \" + sName);\n          }\n          s \u003d ReflectionUtils.newInstance(sClass, new Configuration(conf));\n        }\n        if (s \u003d\u003d null) {\n          throw new RuntimeException(\"No object created for \" + sName);\n        }\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n              +\"configuration is for \"+s.getClass()+\" which has \"\n              +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n              +\"not the same tools trying to send ServiceData and read \"\n              +\"Service Meta Data may have issues unless the refer to \"\n              +\"the name in the config.\");\n        }\n        s.setAuxiliaryLocalPathHandler(auxiliaryLocalPathHandler);\n        addService(sName, s);\n        if (recoveryEnabled) {\n          Path storePath \u003d new Path(stateStoreRoot, sName);\n          stateStoreFs.mkdirs(storePath, storeDirPerms);\n          s.setRecoveryPath(storePath);\n        }\n        s.init(new Configuration(conf));\n      } catch (RuntimeException e) {\n        LOG.error(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "8cdb032aff4237d8d3970057d82290e4e32c4040": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8223.  Improved yarn auxiliary service to load jar file from HDFS.\n            Contributed by Zian Chen\n",
      "commitDate": "04/05/18 9:36 AM",
      "commitName": "8cdb032aff4237d8d3970057d82290e4e32c4040",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "06/04/18 9:25 PM",
      "commitNameOld": "00ebec89f101347a5da44657e388b30c57ed9deb",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 27.51,
      "commitsBetweenForRepo": 699,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,161 +1,176 @@\n   public void serviceInit(Configuration conf) throws Exception {\n     final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n     Path stateStoreRoot \u003d null;\n     FileSystem stateStoreFs \u003d null;\n     boolean recoveryEnabled \u003d conf.getBoolean(\n         YarnConfiguration.NM_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n     if (recoveryEnabled) {\n       stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n           STATE_STORE_ROOT_NAME);\n       stateStoreFs \u003d FileSystem.getLocal(conf);\n     }\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Preconditions\n             .checkArgument(\n                 validateAuxServiceName(sName),\n                 \"The ServiceName: \" + sName + \" set in \" +\n                 YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                 \"The valid service name should only contain a-zA-Z0-9_ \" +\n                 \"and can not start with numbers\");\n         String classKey \u003d String.format(\n             YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n         String className \u003d conf.get(classKey);\n         final String appLocalClassPath \u003d conf.get(String.format(\n             YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n         final String appRemoteClassPath \u003d conf.get(String.format(\n             YarnConfiguration.NM_AUX_SERVICE_REMOTE_CLASSPATH, sName));\n         AuxiliaryService s \u003d null;\n         boolean useCustomerClassLoader \u003d ((appLocalClassPath !\u003d null\n             \u0026\u0026 !appLocalClassPath.isEmpty()) ||\n             (appRemoteClassPath !\u003d null \u0026\u0026 !appRemoteClassPath.isEmpty()))\n             \u0026\u0026 className !\u003d null \u0026\u0026 !className.isEmpty();\n         if (useCustomerClassLoader) {\n           // load AuxiliaryService from local class path\n           if (appRemoteClassPath \u003d\u003d null || appRemoteClassPath.isEmpty()) {\n             s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n                 conf, className, appLocalClassPath);\n           } else {\n             // load AuxiliaryService from remote class path\n             if (appLocalClassPath !\u003d null \u0026\u0026 !appLocalClassPath.isEmpty()) {\n               throw new YarnRuntimeException(\"The aux serivce:\" + sName\n                   + \" has configured local classpath:\" + appLocalClassPath\n                   + \" and remote classpath:\" + appRemoteClassPath\n                   + \". Only one of them should be configured.\");\n             }\n             FileContext localLFS \u003d getLocalFileContext(conf);\n             // create NM aux-service dir in NM localdir if it does not exist.\n             Path nmAuxDir \u003d dirsHandler.getLocalPathForWrite(\".\"\n                 + Path.SEPARATOR + NM_AUX_SERVICE_DIR);\n             if (!localLFS.util().exists(nmAuxDir)) {\n               try {\n                 localLFS.mkdir(nmAuxDir, NM_AUX_SERVICE_DIR_PERM, true);\n               } catch (IOException ex) {\n                 throw new YarnRuntimeException(\"Fail to create dir:\"\n                     + nmAuxDir.toString(), ex);\n               }\n             }\n             Path src \u003d new Path(appRemoteClassPath);\n             FileContext remoteLFS \u003d getRemoteFileContext(src.toUri(), conf);\n             FileStatus scFileStatus \u003d remoteLFS.getFileStatus(src);\n             if (!scFileStatus.getOwner().equals(\n                 this.userUGI.getShortUserName())) {\n               throw new YarnRuntimeException(\"The remote jarfile owner:\"\n                   + scFileStatus.getOwner() + \" is not the same as the NM user:\"\n                   + this.userUGI.getShortUserName() + \".\");\n             }\n             if ((scFileStatus.getPermission().toShort() \u0026 0022) !\u003d 0) {\n               throw new YarnRuntimeException(\"The remote jarfile should not \"\n                   + \"be writable by group or others. \"\n                   + \"The current Permission is \"\n                   + scFileStatus.getPermission().toShort());\n             }\n             Path dest \u003d null;\n             Path downloadDest \u003d new Path(nmAuxDir,\n                 className + \"_\" + scFileStatus.getModificationTime());\n             // check whether we need to re-download the jar\n             // from remote directory\n             Path targetDirPath \u003d new Path(downloadDest,\n                 scFileStatus.getPath().getName());\n             FileStatus[] allSubDirs \u003d localLFS.util().listStatus(nmAuxDir);\n             boolean reDownload \u003d true;\n             for (FileStatus sub : allSubDirs) {\n               if (sub.getPath().getName().equals(downloadDest.getName())) {\n                 reDownload \u003d false;\n                 dest \u003d new Path(targetDirPath + Path.SEPARATOR + \"*\");\n                 break;\n               } else {\n                 if (sub.getPath().getName().contains(className) \u0026\u0026\n                     !sub.getPath().getName().endsWith(DEL_SUFFIX)) {\n                   Path delPath \u003d new Path(sub.getPath().getParent(),\n                       sub.getPath().getName() + DEL_SUFFIX);\n                   localLFS.rename(sub.getPath(), delPath);\n                   LOG.info(\"delete old aux service jar dir:\"\n                       + delPath.toString());\n                   FileDeletionTask deletionTask \u003d new FileDeletionTask(\n                       this.delService, null, delPath, null);\n                   this.delService.delete(deletionTask);\n                 }\n               }\n             }\n             if (reDownload) {\n+              LocalResourceType srcType \u003d null;\n+              String lowerDst \u003d StringUtils.toLowerCase(src.toString());\n+              if (lowerDst.endsWith(\".jar\")) {\n+                srcType \u003d LocalResourceType.FILE;\n+              } else if (lowerDst.endsWith(\".zip\") ||\n+                  lowerDst.endsWith(\".tar.gz\") || lowerDst.endsWith(\".tgz\")\n+                  || lowerDst.endsWith(\".tar\")) {\n+                srcType \u003d LocalResourceType.ARCHIVE;\n+              } else {\n+                throw new YarnRuntimeException(\n+                    \"Can not unpack file from remote-file-path:\" + src\n+                        + \"for aux-service:\" + \".\\n\");\n+              }\n               LocalResource scRsrc \u003d LocalResource.newInstance(\n                   URL.fromURI(src.toUri()),\n-                  LocalResourceType.ARCHIVE, LocalResourceVisibility.PRIVATE,\n+                  srcType, LocalResourceVisibility.PRIVATE,\n                   scFileStatus.getLen(), scFileStatus.getModificationTime());\n               FSDownload download \u003d new FSDownload(localLFS, null, conf,\n                   downloadDest, scRsrc, null);\n               try {\n                 Path downloaded \u003d download.call();\n-                dest \u003d new Path(downloaded + Path.SEPARATOR + \"*\");\n+                // don\u0027t need to convert downloaded path into a dir\n+                // since its already a jar path.\n+                dest \u003d downloaded;\n               } catch (Exception ex) {\n                 throw new YarnRuntimeException(\n                     \"Exception happend while downloading files \"\n                     + \"for aux-service:\" + sName + \" and remote-file-path:\"\n                     + src + \".\\n\" + ex.getMessage());\n               }\n             }\n             s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n                 conf, className, dest.toString());\n           }\n           LOG.info(\"The aux service:\" + sName\n               + \" are using the custom classloader\");\n         } else {\n           Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               classKey, null, AuxiliaryService.class);\n \n           if (sClass \u003d\u003d null) {\n             throw new RuntimeException(\"No class defined for \" + sName);\n           }\n           s \u003d ReflectionUtils.newInstance(sClass, conf);\n         }\n         if (s \u003d\u003d null) {\n           throw new RuntimeException(\"No object created for \" + sName);\n         }\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n               +\"configuration is for \"+s.getClass()+\" which has \"\n               +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n               +\"not the same tools trying to send ServiceData and read \"\n               +\"Service Meta Data may have issues unless the refer to \"\n               +\"the name in the config.\");\n         }\n         s.setAuxiliaryLocalPathHandler(auxiliaryLocalPathHandler);\n         addService(sName, s);\n         if (recoveryEnabled) {\n           Path storePath \u003d new Path(stateStoreRoot, sName);\n           stateStoreFs.mkdirs(storePath, storeDirPerms);\n           s.setRecoveryPath(storePath);\n         }\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.error(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n    Path stateStoreRoot \u003d null;\n    FileSystem stateStoreFs \u003d null;\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n          STATE_STORE_ROOT_NAME);\n      stateStoreFs \u003d FileSystem.getLocal(conf);\n    }\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Preconditions\n            .checkArgument(\n                validateAuxServiceName(sName),\n                \"The ServiceName: \" + sName + \" set in \" +\n                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                \"The valid service name should only contain a-zA-Z0-9_ \" +\n                \"and can not start with numbers\");\n        String classKey \u003d String.format(\n            YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n        String className \u003d conf.get(classKey);\n        final String appLocalClassPath \u003d conf.get(String.format(\n            YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n        final String appRemoteClassPath \u003d conf.get(String.format(\n            YarnConfiguration.NM_AUX_SERVICE_REMOTE_CLASSPATH, sName));\n        AuxiliaryService s \u003d null;\n        boolean useCustomerClassLoader \u003d ((appLocalClassPath !\u003d null\n            \u0026\u0026 !appLocalClassPath.isEmpty()) ||\n            (appRemoteClassPath !\u003d null \u0026\u0026 !appRemoteClassPath.isEmpty()))\n            \u0026\u0026 className !\u003d null \u0026\u0026 !className.isEmpty();\n        if (useCustomerClassLoader) {\n          // load AuxiliaryService from local class path\n          if (appRemoteClassPath \u003d\u003d null || appRemoteClassPath.isEmpty()) {\n            s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n                conf, className, appLocalClassPath);\n          } else {\n            // load AuxiliaryService from remote class path\n            if (appLocalClassPath !\u003d null \u0026\u0026 !appLocalClassPath.isEmpty()) {\n              throw new YarnRuntimeException(\"The aux serivce:\" + sName\n                  + \" has configured local classpath:\" + appLocalClassPath\n                  + \" and remote classpath:\" + appRemoteClassPath\n                  + \". Only one of them should be configured.\");\n            }\n            FileContext localLFS \u003d getLocalFileContext(conf);\n            // create NM aux-service dir in NM localdir if it does not exist.\n            Path nmAuxDir \u003d dirsHandler.getLocalPathForWrite(\".\"\n                + Path.SEPARATOR + NM_AUX_SERVICE_DIR);\n            if (!localLFS.util().exists(nmAuxDir)) {\n              try {\n                localLFS.mkdir(nmAuxDir, NM_AUX_SERVICE_DIR_PERM, true);\n              } catch (IOException ex) {\n                throw new YarnRuntimeException(\"Fail to create dir:\"\n                    + nmAuxDir.toString(), ex);\n              }\n            }\n            Path src \u003d new Path(appRemoteClassPath);\n            FileContext remoteLFS \u003d getRemoteFileContext(src.toUri(), conf);\n            FileStatus scFileStatus \u003d remoteLFS.getFileStatus(src);\n            if (!scFileStatus.getOwner().equals(\n                this.userUGI.getShortUserName())) {\n              throw new YarnRuntimeException(\"The remote jarfile owner:\"\n                  + scFileStatus.getOwner() + \" is not the same as the NM user:\"\n                  + this.userUGI.getShortUserName() + \".\");\n            }\n            if ((scFileStatus.getPermission().toShort() \u0026 0022) !\u003d 0) {\n              throw new YarnRuntimeException(\"The remote jarfile should not \"\n                  + \"be writable by group or others. \"\n                  + \"The current Permission is \"\n                  + scFileStatus.getPermission().toShort());\n            }\n            Path dest \u003d null;\n            Path downloadDest \u003d new Path(nmAuxDir,\n                className + \"_\" + scFileStatus.getModificationTime());\n            // check whether we need to re-download the jar\n            // from remote directory\n            Path targetDirPath \u003d new Path(downloadDest,\n                scFileStatus.getPath().getName());\n            FileStatus[] allSubDirs \u003d localLFS.util().listStatus(nmAuxDir);\n            boolean reDownload \u003d true;\n            for (FileStatus sub : allSubDirs) {\n              if (sub.getPath().getName().equals(downloadDest.getName())) {\n                reDownload \u003d false;\n                dest \u003d new Path(targetDirPath + Path.SEPARATOR + \"*\");\n                break;\n              } else {\n                if (sub.getPath().getName().contains(className) \u0026\u0026\n                    !sub.getPath().getName().endsWith(DEL_SUFFIX)) {\n                  Path delPath \u003d new Path(sub.getPath().getParent(),\n                      sub.getPath().getName() + DEL_SUFFIX);\n                  localLFS.rename(sub.getPath(), delPath);\n                  LOG.info(\"delete old aux service jar dir:\"\n                      + delPath.toString());\n                  FileDeletionTask deletionTask \u003d new FileDeletionTask(\n                      this.delService, null, delPath, null);\n                  this.delService.delete(deletionTask);\n                }\n              }\n            }\n            if (reDownload) {\n              LocalResourceType srcType \u003d null;\n              String lowerDst \u003d StringUtils.toLowerCase(src.toString());\n              if (lowerDst.endsWith(\".jar\")) {\n                srcType \u003d LocalResourceType.FILE;\n              } else if (lowerDst.endsWith(\".zip\") ||\n                  lowerDst.endsWith(\".tar.gz\") || lowerDst.endsWith(\".tgz\")\n                  || lowerDst.endsWith(\".tar\")) {\n                srcType \u003d LocalResourceType.ARCHIVE;\n              } else {\n                throw new YarnRuntimeException(\n                    \"Can not unpack file from remote-file-path:\" + src\n                        + \"for aux-service:\" + \".\\n\");\n              }\n              LocalResource scRsrc \u003d LocalResource.newInstance(\n                  URL.fromURI(src.toUri()),\n                  srcType, LocalResourceVisibility.PRIVATE,\n                  scFileStatus.getLen(), scFileStatus.getModificationTime());\n              FSDownload download \u003d new FSDownload(localLFS, null, conf,\n                  downloadDest, scRsrc, null);\n              try {\n                Path downloaded \u003d download.call();\n                // don\u0027t need to convert downloaded path into a dir\n                // since its already a jar path.\n                dest \u003d downloaded;\n              } catch (Exception ex) {\n                throw new YarnRuntimeException(\n                    \"Exception happend while downloading files \"\n                    + \"for aux-service:\" + sName + \" and remote-file-path:\"\n                    + src + \".\\n\" + ex.getMessage());\n              }\n            }\n            s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n                conf, className, dest.toString());\n          }\n          LOG.info(\"The aux service:\" + sName\n              + \" are using the custom classloader\");\n        } else {\n          Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              classKey, null, AuxiliaryService.class);\n\n          if (sClass \u003d\u003d null) {\n            throw new RuntimeException(\"No class defined for \" + sName);\n          }\n          s \u003d ReflectionUtils.newInstance(sClass, conf);\n        }\n        if (s \u003d\u003d null) {\n          throw new RuntimeException(\"No object created for \" + sName);\n        }\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n              +\"configuration is for \"+s.getClass()+\" which has \"\n              +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n              +\"not the same tools trying to send ServiceData and read \"\n              +\"Service Meta Data may have issues unless the refer to \"\n              +\"the name in the config.\");\n        }\n        s.setAuxiliaryLocalPathHandler(auxiliaryLocalPathHandler);\n        addService(sName, s);\n        if (recoveryEnabled) {\n          Path storePath \u003d new Path(stateStoreRoot, sName);\n          stateStoreFs.mkdirs(storePath, storeDirPerms);\n          s.setRecoveryPath(storePath);\n        }\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.error(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "00ebec89f101347a5da44657e388b30c57ed9deb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1151. Ability to configure auxiliary services from HDFS-based JAR files. (Xuan Gong via wangda)\n\nChange-Id: Ied37ff11e507fc86847753ba79486652c8fadfe9\n",
      "commitDate": "06/04/18 9:25 PM",
      "commitName": "00ebec89f101347a5da44657e388b30c57ed9deb",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/10/17 2:56 PM",
      "commitNameOld": "665bb147aa3fc198e53335931562dd69f9f0e345",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 161.27,
      "commitsBetweenForRepo": 1192,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,161 @@\n   public void serviceInit(Configuration conf) throws Exception {\n     final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n     Path stateStoreRoot \u003d null;\n     FileSystem stateStoreFs \u003d null;\n     boolean recoveryEnabled \u003d conf.getBoolean(\n         YarnConfiguration.NM_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n     if (recoveryEnabled) {\n       stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n           STATE_STORE_ROOT_NAME);\n       stateStoreFs \u003d FileSystem.getLocal(conf);\n     }\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Preconditions\n             .checkArgument(\n                 validateAuxServiceName(sName),\n                 \"The ServiceName: \" + sName + \" set in \" +\n                 YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                 \"The valid service name should only contain a-zA-Z0-9_ \" +\n                 \"and can not start with numbers\");\n         String classKey \u003d String.format(\n             YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n         String className \u003d conf.get(classKey);\n-        final String appClassPath \u003d conf.get(String.format(\n+        final String appLocalClassPath \u003d conf.get(String.format(\n             YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n+        final String appRemoteClassPath \u003d conf.get(String.format(\n+            YarnConfiguration.NM_AUX_SERVICE_REMOTE_CLASSPATH, sName));\n         AuxiliaryService s \u003d null;\n-        boolean useCustomerClassLoader \u003d appClassPath !\u003d null\n-            \u0026\u0026 !appClassPath.isEmpty() \u0026\u0026 className !\u003d null\n-            \u0026\u0026 !className.isEmpty();\n+        boolean useCustomerClassLoader \u003d ((appLocalClassPath !\u003d null\n+            \u0026\u0026 !appLocalClassPath.isEmpty()) ||\n+            (appRemoteClassPath !\u003d null \u0026\u0026 !appRemoteClassPath.isEmpty()))\n+            \u0026\u0026 className !\u003d null \u0026\u0026 !className.isEmpty();\n         if (useCustomerClassLoader) {\n-          s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n-              conf, className, appClassPath);\n+          // load AuxiliaryService from local class path\n+          if (appRemoteClassPath \u003d\u003d null || appRemoteClassPath.isEmpty()) {\n+            s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n+                conf, className, appLocalClassPath);\n+          } else {\n+            // load AuxiliaryService from remote class path\n+            if (appLocalClassPath !\u003d null \u0026\u0026 !appLocalClassPath.isEmpty()) {\n+              throw new YarnRuntimeException(\"The aux serivce:\" + sName\n+                  + \" has configured local classpath:\" + appLocalClassPath\n+                  + \" and remote classpath:\" + appRemoteClassPath\n+                  + \". Only one of them should be configured.\");\n+            }\n+            FileContext localLFS \u003d getLocalFileContext(conf);\n+            // create NM aux-service dir in NM localdir if it does not exist.\n+            Path nmAuxDir \u003d dirsHandler.getLocalPathForWrite(\".\"\n+                + Path.SEPARATOR + NM_AUX_SERVICE_DIR);\n+            if (!localLFS.util().exists(nmAuxDir)) {\n+              try {\n+                localLFS.mkdir(nmAuxDir, NM_AUX_SERVICE_DIR_PERM, true);\n+              } catch (IOException ex) {\n+                throw new YarnRuntimeException(\"Fail to create dir:\"\n+                    + nmAuxDir.toString(), ex);\n+              }\n+            }\n+            Path src \u003d new Path(appRemoteClassPath);\n+            FileContext remoteLFS \u003d getRemoteFileContext(src.toUri(), conf);\n+            FileStatus scFileStatus \u003d remoteLFS.getFileStatus(src);\n+            if (!scFileStatus.getOwner().equals(\n+                this.userUGI.getShortUserName())) {\n+              throw new YarnRuntimeException(\"The remote jarfile owner:\"\n+                  + scFileStatus.getOwner() + \" is not the same as the NM user:\"\n+                  + this.userUGI.getShortUserName() + \".\");\n+            }\n+            if ((scFileStatus.getPermission().toShort() \u0026 0022) !\u003d 0) {\n+              throw new YarnRuntimeException(\"The remote jarfile should not \"\n+                  + \"be writable by group or others. \"\n+                  + \"The current Permission is \"\n+                  + scFileStatus.getPermission().toShort());\n+            }\n+            Path dest \u003d null;\n+            Path downloadDest \u003d new Path(nmAuxDir,\n+                className + \"_\" + scFileStatus.getModificationTime());\n+            // check whether we need to re-download the jar\n+            // from remote directory\n+            Path targetDirPath \u003d new Path(downloadDest,\n+                scFileStatus.getPath().getName());\n+            FileStatus[] allSubDirs \u003d localLFS.util().listStatus(nmAuxDir);\n+            boolean reDownload \u003d true;\n+            for (FileStatus sub : allSubDirs) {\n+              if (sub.getPath().getName().equals(downloadDest.getName())) {\n+                reDownload \u003d false;\n+                dest \u003d new Path(targetDirPath + Path.SEPARATOR + \"*\");\n+                break;\n+              } else {\n+                if (sub.getPath().getName().contains(className) \u0026\u0026\n+                    !sub.getPath().getName().endsWith(DEL_SUFFIX)) {\n+                  Path delPath \u003d new Path(sub.getPath().getParent(),\n+                      sub.getPath().getName() + DEL_SUFFIX);\n+                  localLFS.rename(sub.getPath(), delPath);\n+                  LOG.info(\"delete old aux service jar dir:\"\n+                      + delPath.toString());\n+                  FileDeletionTask deletionTask \u003d new FileDeletionTask(\n+                      this.delService, null, delPath, null);\n+                  this.delService.delete(deletionTask);\n+                }\n+              }\n+            }\n+            if (reDownload) {\n+              LocalResource scRsrc \u003d LocalResource.newInstance(\n+                  URL.fromURI(src.toUri()),\n+                  LocalResourceType.ARCHIVE, LocalResourceVisibility.PRIVATE,\n+                  scFileStatus.getLen(), scFileStatus.getModificationTime());\n+              FSDownload download \u003d new FSDownload(localLFS, null, conf,\n+                  downloadDest, scRsrc, null);\n+              try {\n+                Path downloaded \u003d download.call();\n+                dest \u003d new Path(downloaded + Path.SEPARATOR + \"*\");\n+              } catch (Exception ex) {\n+                throw new YarnRuntimeException(\n+                    \"Exception happend while downloading files \"\n+                    + \"for aux-service:\" + sName + \" and remote-file-path:\"\n+                    + src + \".\\n\" + ex.getMessage());\n+              }\n+            }\n+            s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n+                conf, className, dest.toString());\n+          }\n           LOG.info(\"The aux service:\" + sName\n               + \" are using the custom classloader\");\n         } else {\n           Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               classKey, null, AuxiliaryService.class);\n \n           if (sClass \u003d\u003d null) {\n             throw new RuntimeException(\"No class defined for \" + sName);\n           }\n           s \u003d ReflectionUtils.newInstance(sClass, conf);\n         }\n         if (s \u003d\u003d null) {\n           throw new RuntimeException(\"No object created for \" + sName);\n         }\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n               +\"configuration is for \"+s.getClass()+\" which has \"\n               +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n               +\"not the same tools trying to send ServiceData and read \"\n               +\"Service Meta Data may have issues unless the refer to \"\n               +\"the name in the config.\");\n         }\n         s.setAuxiliaryLocalPathHandler(auxiliaryLocalPathHandler);\n         addService(sName, s);\n         if (recoveryEnabled) {\n           Path storePath \u003d new Path(stateStoreRoot, sName);\n           stateStoreFs.mkdirs(storePath, storeDirPerms);\n           s.setRecoveryPath(storePath);\n         }\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.error(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n    Path stateStoreRoot \u003d null;\n    FileSystem stateStoreFs \u003d null;\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n          STATE_STORE_ROOT_NAME);\n      stateStoreFs \u003d FileSystem.getLocal(conf);\n    }\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Preconditions\n            .checkArgument(\n                validateAuxServiceName(sName),\n                \"The ServiceName: \" + sName + \" set in \" +\n                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                \"The valid service name should only contain a-zA-Z0-9_ \" +\n                \"and can not start with numbers\");\n        String classKey \u003d String.format(\n            YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n        String className \u003d conf.get(classKey);\n        final String appLocalClassPath \u003d conf.get(String.format(\n            YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n        final String appRemoteClassPath \u003d conf.get(String.format(\n            YarnConfiguration.NM_AUX_SERVICE_REMOTE_CLASSPATH, sName));\n        AuxiliaryService s \u003d null;\n        boolean useCustomerClassLoader \u003d ((appLocalClassPath !\u003d null\n            \u0026\u0026 !appLocalClassPath.isEmpty()) ||\n            (appRemoteClassPath !\u003d null \u0026\u0026 !appRemoteClassPath.isEmpty()))\n            \u0026\u0026 className !\u003d null \u0026\u0026 !className.isEmpty();\n        if (useCustomerClassLoader) {\n          // load AuxiliaryService from local class path\n          if (appRemoteClassPath \u003d\u003d null || appRemoteClassPath.isEmpty()) {\n            s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n                conf, className, appLocalClassPath);\n          } else {\n            // load AuxiliaryService from remote class path\n            if (appLocalClassPath !\u003d null \u0026\u0026 !appLocalClassPath.isEmpty()) {\n              throw new YarnRuntimeException(\"The aux serivce:\" + sName\n                  + \" has configured local classpath:\" + appLocalClassPath\n                  + \" and remote classpath:\" + appRemoteClassPath\n                  + \". Only one of them should be configured.\");\n            }\n            FileContext localLFS \u003d getLocalFileContext(conf);\n            // create NM aux-service dir in NM localdir if it does not exist.\n            Path nmAuxDir \u003d dirsHandler.getLocalPathForWrite(\".\"\n                + Path.SEPARATOR + NM_AUX_SERVICE_DIR);\n            if (!localLFS.util().exists(nmAuxDir)) {\n              try {\n                localLFS.mkdir(nmAuxDir, NM_AUX_SERVICE_DIR_PERM, true);\n              } catch (IOException ex) {\n                throw new YarnRuntimeException(\"Fail to create dir:\"\n                    + nmAuxDir.toString(), ex);\n              }\n            }\n            Path src \u003d new Path(appRemoteClassPath);\n            FileContext remoteLFS \u003d getRemoteFileContext(src.toUri(), conf);\n            FileStatus scFileStatus \u003d remoteLFS.getFileStatus(src);\n            if (!scFileStatus.getOwner().equals(\n                this.userUGI.getShortUserName())) {\n              throw new YarnRuntimeException(\"The remote jarfile owner:\"\n                  + scFileStatus.getOwner() + \" is not the same as the NM user:\"\n                  + this.userUGI.getShortUserName() + \".\");\n            }\n            if ((scFileStatus.getPermission().toShort() \u0026 0022) !\u003d 0) {\n              throw new YarnRuntimeException(\"The remote jarfile should not \"\n                  + \"be writable by group or others. \"\n                  + \"The current Permission is \"\n                  + scFileStatus.getPermission().toShort());\n            }\n            Path dest \u003d null;\n            Path downloadDest \u003d new Path(nmAuxDir,\n                className + \"_\" + scFileStatus.getModificationTime());\n            // check whether we need to re-download the jar\n            // from remote directory\n            Path targetDirPath \u003d new Path(downloadDest,\n                scFileStatus.getPath().getName());\n            FileStatus[] allSubDirs \u003d localLFS.util().listStatus(nmAuxDir);\n            boolean reDownload \u003d true;\n            for (FileStatus sub : allSubDirs) {\n              if (sub.getPath().getName().equals(downloadDest.getName())) {\n                reDownload \u003d false;\n                dest \u003d new Path(targetDirPath + Path.SEPARATOR + \"*\");\n                break;\n              } else {\n                if (sub.getPath().getName().contains(className) \u0026\u0026\n                    !sub.getPath().getName().endsWith(DEL_SUFFIX)) {\n                  Path delPath \u003d new Path(sub.getPath().getParent(),\n                      sub.getPath().getName() + DEL_SUFFIX);\n                  localLFS.rename(sub.getPath(), delPath);\n                  LOG.info(\"delete old aux service jar dir:\"\n                      + delPath.toString());\n                  FileDeletionTask deletionTask \u003d new FileDeletionTask(\n                      this.delService, null, delPath, null);\n                  this.delService.delete(deletionTask);\n                }\n              }\n            }\n            if (reDownload) {\n              LocalResource scRsrc \u003d LocalResource.newInstance(\n                  URL.fromURI(src.toUri()),\n                  LocalResourceType.ARCHIVE, LocalResourceVisibility.PRIVATE,\n                  scFileStatus.getLen(), scFileStatus.getModificationTime());\n              FSDownload download \u003d new FSDownload(localLFS, null, conf,\n                  downloadDest, scRsrc, null);\n              try {\n                Path downloaded \u003d download.call();\n                dest \u003d new Path(downloaded + Path.SEPARATOR + \"*\");\n              } catch (Exception ex) {\n                throw new YarnRuntimeException(\n                    \"Exception happend while downloading files \"\n                    + \"for aux-service:\" + sName + \" and remote-file-path:\"\n                    + src + \".\\n\" + ex.getMessage());\n              }\n            }\n            s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n                conf, className, dest.toString());\n          }\n          LOG.info(\"The aux service:\" + sName\n              + \" are using the custom classloader\");\n        } else {\n          Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              classKey, null, AuxiliaryService.class);\n\n          if (sClass \u003d\u003d null) {\n            throw new RuntimeException(\"No class defined for \" + sName);\n          }\n          s \u003d ReflectionUtils.newInstance(sClass, conf);\n        }\n        if (s \u003d\u003d null) {\n          throw new RuntimeException(\"No object created for \" + sName);\n        }\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n              +\"configuration is for \"+s.getClass()+\" which has \"\n              +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n              +\"not the same tools trying to send ServiceData and read \"\n              +\"Service Meta Data may have issues unless the refer to \"\n              +\"the name in the config.\");\n        }\n        s.setAuxiliaryLocalPathHandler(auxiliaryLocalPathHandler);\n        addService(sName, s);\n        if (recoveryEnabled) {\n          Path storePath \u003d new Path(stateStoreRoot, sName);\n          stateStoreFs.mkdirs(storePath, storeDirPerms);\n          s.setRecoveryPath(storePath);\n        }\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.error(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "665bb147aa3fc198e53335931562dd69f9f0e345": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7244. ShuffleHandler is not aware of disks that are added. Contributed by Kuhu Shukla\n",
      "commitDate": "27/10/17 2:56 PM",
      "commitName": "665bb147aa3fc198e53335931562dd69f9f0e345",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "b664569586db39647f15340ce82ccc0f0869897e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 58.66,
      "commitsBetweenForRepo": 499,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,73 @@\n   public void serviceInit(Configuration conf) throws Exception {\n     final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n     Path stateStoreRoot \u003d null;\n     FileSystem stateStoreFs \u003d null;\n     boolean recoveryEnabled \u003d conf.getBoolean(\n         YarnConfiguration.NM_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n     if (recoveryEnabled) {\n       stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n           STATE_STORE_ROOT_NAME);\n       stateStoreFs \u003d FileSystem.getLocal(conf);\n     }\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Preconditions\n             .checkArgument(\n                 validateAuxServiceName(sName),\n                 \"The ServiceName: \" + sName + \" set in \" +\n                 YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                 \"The valid service name should only contain a-zA-Z0-9_ \" +\n                 \"and can not start with numbers\");\n         String classKey \u003d String.format(\n             YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n         String className \u003d conf.get(classKey);\n         final String appClassPath \u003d conf.get(String.format(\n             YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n         AuxiliaryService s \u003d null;\n         boolean useCustomerClassLoader \u003d appClassPath !\u003d null\n             \u0026\u0026 !appClassPath.isEmpty() \u0026\u0026 className !\u003d null\n             \u0026\u0026 !className.isEmpty();\n         if (useCustomerClassLoader) {\n           s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n               conf, className, appClassPath);\n           LOG.info(\"The aux service:\" + sName\n               + \" are using the custom classloader\");\n         } else {\n           Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               classKey, null, AuxiliaryService.class);\n \n           if (sClass \u003d\u003d null) {\n             throw new RuntimeException(\"No class defined for \" + sName);\n           }\n           s \u003d ReflectionUtils.newInstance(sClass, conf);\n         }\n         if (s \u003d\u003d null) {\n           throw new RuntimeException(\"No object created for \" + sName);\n         }\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n               +\"configuration is for \"+s.getClass()+\" which has \"\n               +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n               +\"not the same tools trying to send ServiceData and read \"\n               +\"Service Meta Data may have issues unless the refer to \"\n               +\"the name in the config.\");\n         }\n+        s.setAuxiliaryLocalPathHandler(auxiliaryLocalPathHandler);\n         addService(sName, s);\n         if (recoveryEnabled) {\n           Path storePath \u003d new Path(stateStoreRoot, sName);\n           stateStoreFs.mkdirs(storePath, storeDirPerms);\n           s.setRecoveryPath(storePath);\n         }\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.error(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n    Path stateStoreRoot \u003d null;\n    FileSystem stateStoreFs \u003d null;\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n          STATE_STORE_ROOT_NAME);\n      stateStoreFs \u003d FileSystem.getLocal(conf);\n    }\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Preconditions\n            .checkArgument(\n                validateAuxServiceName(sName),\n                \"The ServiceName: \" + sName + \" set in \" +\n                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                \"The valid service name should only contain a-zA-Z0-9_ \" +\n                \"and can not start with numbers\");\n        String classKey \u003d String.format(\n            YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n        String className \u003d conf.get(classKey);\n        final String appClassPath \u003d conf.get(String.format(\n            YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n        AuxiliaryService s \u003d null;\n        boolean useCustomerClassLoader \u003d appClassPath !\u003d null\n            \u0026\u0026 !appClassPath.isEmpty() \u0026\u0026 className !\u003d null\n            \u0026\u0026 !className.isEmpty();\n        if (useCustomerClassLoader) {\n          s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n              conf, className, appClassPath);\n          LOG.info(\"The aux service:\" + sName\n              + \" are using the custom classloader\");\n        } else {\n          Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              classKey, null, AuxiliaryService.class);\n\n          if (sClass \u003d\u003d null) {\n            throw new RuntimeException(\"No class defined for \" + sName);\n          }\n          s \u003d ReflectionUtils.newInstance(sClass, conf);\n        }\n        if (s \u003d\u003d null) {\n          throw new RuntimeException(\"No object created for \" + sName);\n        }\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n              +\"configuration is for \"+s.getClass()+\" which has \"\n              +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n              +\"not the same tools trying to send ServiceData and read \"\n              +\"Service Meta Data may have issues unless the refer to \"\n              +\"the name in the config.\");\n        }\n        s.setAuxiliaryLocalPathHandler(auxiliaryLocalPathHandler);\n        addService(sName, s);\n        if (recoveryEnabled) {\n          Path storePath \u003d new Path(stateStoreRoot, sName);\n          stateStoreFs.mkdirs(storePath, storeDirPerms);\n          s.setRecoveryPath(storePath);\n        }\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.error(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "d5ff57a08fac983f8b5d201064ce07945f0f216e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7047. Moving logging APIs over to slf4j in hadoop-yarn-server-nodemanager. Contributed by Yeliang Cang.\n",
      "commitDate": "22/08/17 1:14 AM",
      "commitName": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "07/12/16 3:07 PM",
      "commitNameOld": "72fe54684198b7df5c5fb2114616dff6d17a4402",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 257.38,
      "commitsBetweenForRepo": 1405,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   public void serviceInit(Configuration conf) throws Exception {\n     final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n     Path stateStoreRoot \u003d null;\n     FileSystem stateStoreFs \u003d null;\n     boolean recoveryEnabled \u003d conf.getBoolean(\n         YarnConfiguration.NM_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n     if (recoveryEnabled) {\n       stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n           STATE_STORE_ROOT_NAME);\n       stateStoreFs \u003d FileSystem.getLocal(conf);\n     }\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Preconditions\n             .checkArgument(\n                 validateAuxServiceName(sName),\n                 \"The ServiceName: \" + sName + \" set in \" +\n                 YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                 \"The valid service name should only contain a-zA-Z0-9_ \" +\n                 \"and can not start with numbers\");\n         String classKey \u003d String.format(\n             YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n         String className \u003d conf.get(classKey);\n         final String appClassPath \u003d conf.get(String.format(\n             YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n         AuxiliaryService s \u003d null;\n         boolean useCustomerClassLoader \u003d appClassPath !\u003d null\n             \u0026\u0026 !appClassPath.isEmpty() \u0026\u0026 className !\u003d null\n             \u0026\u0026 !className.isEmpty();\n         if (useCustomerClassLoader) {\n           s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n               conf, className, appClassPath);\n           LOG.info(\"The aux service:\" + sName\n               + \" are using the custom classloader\");\n         } else {\n           Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               classKey, null, AuxiliaryService.class);\n \n           if (sClass \u003d\u003d null) {\n             throw new RuntimeException(\"No class defined for \" + sName);\n           }\n           s \u003d ReflectionUtils.newInstance(sClass, conf);\n         }\n         if (s \u003d\u003d null) {\n           throw new RuntimeException(\"No object created for \" + sName);\n         }\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n               +\"configuration is for \"+s.getClass()+\" which has \"\n               +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n               +\"not the same tools trying to send ServiceData and read \"\n               +\"Service Meta Data may have issues unless the refer to \"\n               +\"the name in the config.\");\n         }\n         addService(sName, s);\n         if (recoveryEnabled) {\n           Path storePath \u003d new Path(stateStoreRoot, sName);\n           stateStoreFs.mkdirs(storePath, storeDirPerms);\n           s.setRecoveryPath(storePath);\n         }\n         s.init(conf);\n       } catch (RuntimeException e) {\n-        LOG.fatal(\"Failed to initialize \" + sName, e);\n+        LOG.error(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n    Path stateStoreRoot \u003d null;\n    FileSystem stateStoreFs \u003d null;\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n          STATE_STORE_ROOT_NAME);\n      stateStoreFs \u003d FileSystem.getLocal(conf);\n    }\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Preconditions\n            .checkArgument(\n                validateAuxServiceName(sName),\n                \"The ServiceName: \" + sName + \" set in \" +\n                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                \"The valid service name should only contain a-zA-Z0-9_ \" +\n                \"and can not start with numbers\");\n        String classKey \u003d String.format(\n            YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n        String className \u003d conf.get(classKey);\n        final String appClassPath \u003d conf.get(String.format(\n            YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n        AuxiliaryService s \u003d null;\n        boolean useCustomerClassLoader \u003d appClassPath !\u003d null\n            \u0026\u0026 !appClassPath.isEmpty() \u0026\u0026 className !\u003d null\n            \u0026\u0026 !className.isEmpty();\n        if (useCustomerClassLoader) {\n          s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n              conf, className, appClassPath);\n          LOG.info(\"The aux service:\" + sName\n              + \" are using the custom classloader\");\n        } else {\n          Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              classKey, null, AuxiliaryService.class);\n\n          if (sClass \u003d\u003d null) {\n            throw new RuntimeException(\"No class defined for \" + sName);\n          }\n          s \u003d ReflectionUtils.newInstance(sClass, conf);\n        }\n        if (s \u003d\u003d null) {\n          throw new RuntimeException(\"No object created for \" + sName);\n        }\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n              +\"configuration is for \"+s.getClass()+\" which has \"\n              +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n              +\"not the same tools trying to send ServiceData and read \"\n              +\"Service Meta Data may have issues unless the refer to \"\n              +\"the name in the config.\");\n        }\n        addService(sName, s);\n        if (recoveryEnabled) {\n          Path storePath \u003d new Path(stateStoreRoot, sName);\n          stateStoreFs.mkdirs(storePath, storeDirPerms);\n          s.setRecoveryPath(storePath);\n        }\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.error(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "72fe54684198b7df5c5fb2114616dff6d17a4402": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5963. Spelling errors in logging and exceptions for node manager, client, web-proxy, common, and app history code (gsohn via rkanter)\n",
      "commitDate": "07/12/16 3:07 PM",
      "commitName": "72fe54684198b7df5c5fb2114616dff6d17a4402",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "12/05/16 10:11 AM",
      "commitNameOld": "0bbe01f8d56191edfba3b50fb9f8859a0b3f826f",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 209.25,
      "commitsBetweenForRepo": 1606,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   public void serviceInit(Configuration conf) throws Exception {\n     final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n     Path stateStoreRoot \u003d null;\n     FileSystem stateStoreFs \u003d null;\n     boolean recoveryEnabled \u003d conf.getBoolean(\n         YarnConfiguration.NM_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n     if (recoveryEnabled) {\n       stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n           STATE_STORE_ROOT_NAME);\n       stateStoreFs \u003d FileSystem.getLocal(conf);\n     }\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Preconditions\n             .checkArgument(\n                 validateAuxServiceName(sName),\n                 \"The ServiceName: \" + sName + \" set in \" +\n                 YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                 \"The valid service name should only contain a-zA-Z0-9_ \" +\n                 \"and can not start with numbers\");\n         String classKey \u003d String.format(\n             YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n         String className \u003d conf.get(classKey);\n         final String appClassPath \u003d conf.get(String.format(\n             YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n         AuxiliaryService s \u003d null;\n         boolean useCustomerClassLoader \u003d appClassPath !\u003d null\n             \u0026\u0026 !appClassPath.isEmpty() \u0026\u0026 className !\u003d null\n             \u0026\u0026 !className.isEmpty();\n         if (useCustomerClassLoader) {\n           s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n               conf, className, appClassPath);\n           LOG.info(\"The aux service:\" + sName\n               + \" are using the custom classloader\");\n         } else {\n           Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               classKey, null, AuxiliaryService.class);\n \n           if (sClass \u003d\u003d null) {\n             throw new RuntimeException(\"No class defined for \" + sName);\n           }\n           s \u003d ReflectionUtils.newInstance(sClass, conf);\n         }\n         if (s \u003d\u003d null) {\n           throw new RuntimeException(\"No object created for \" + sName);\n         }\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n-          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n+          LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n               +\"configuration is for \"+s.getClass()+\" which has \"\n               +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n               +\"not the same tools trying to send ServiceData and read \"\n               +\"Service Meta Data may have issues unless the refer to \"\n               +\"the name in the config.\");\n         }\n         addService(sName, s);\n         if (recoveryEnabled) {\n           Path storePath \u003d new Path(stateStoreRoot, sName);\n           stateStoreFs.mkdirs(storePath, storeDirPerms);\n           s.setRecoveryPath(storePath);\n         }\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.fatal(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n    Path stateStoreRoot \u003d null;\n    FileSystem stateStoreFs \u003d null;\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n          STATE_STORE_ROOT_NAME);\n      stateStoreFs \u003d FileSystem.getLocal(conf);\n    }\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Preconditions\n            .checkArgument(\n                validateAuxServiceName(sName),\n                \"The ServiceName: \" + sName + \" set in \" +\n                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                \"The valid service name should only contain a-zA-Z0-9_ \" +\n                \"and can not start with numbers\");\n        String classKey \u003d String.format(\n            YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n        String className \u003d conf.get(classKey);\n        final String appClassPath \u003d conf.get(String.format(\n            YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n        AuxiliaryService s \u003d null;\n        boolean useCustomerClassLoader \u003d appClassPath !\u003d null\n            \u0026\u0026 !appClassPath.isEmpty() \u0026\u0026 className !\u003d null\n            \u0026\u0026 !className.isEmpty();\n        if (useCustomerClassLoader) {\n          s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n              conf, className, appClassPath);\n          LOG.info(\"The aux service:\" + sName\n              + \" are using the custom classloader\");\n        } else {\n          Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              classKey, null, AuxiliaryService.class);\n\n          if (sClass \u003d\u003d null) {\n            throw new RuntimeException(\"No class defined for \" + sName);\n          }\n          s \u003d ReflectionUtils.newInstance(sClass, conf);\n        }\n        if (s \u003d\u003d null) {\n          throw new RuntimeException(\"No object created for \" + sName);\n        }\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxiliary Service named \u0027\"+sName+\"\u0027 in the \"\n              +\"configuration is for \"+s.getClass()+\" which has \"\n              +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n              +\"not the same tools trying to send ServiceData and read \"\n              +\"Service Meta Data may have issues unless the refer to \"\n              +\"the name in the config.\");\n        }\n        addService(sName, s);\n        if (recoveryEnabled) {\n          Path storePath \u003d new Path(stateStoreRoot, sName);\n          stateStoreFs.mkdirs(storePath, storeDirPerms);\n          s.setRecoveryPath(storePath);\n        }\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "0bbe01f8d56191edfba3b50fb9f8859a0b3f826f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4577. Enable aux services to have their own custom classpath/jar file (Xuan Gong via sale)\n",
      "commitDate": "12/05/16 10:11 AM",
      "commitName": "0bbe01f8d56191edfba3b50fb9f8859a0b3f826f",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/15 6:58 PM",
      "commitNameOld": "1ea36299a47af302379ae0750b571ec021eb54ad",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 306.63,
      "commitsBetweenForRepo": 1998,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,72 @@\n   public void serviceInit(Configuration conf) throws Exception {\n     final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n     Path stateStoreRoot \u003d null;\n     FileSystem stateStoreFs \u003d null;\n     boolean recoveryEnabled \u003d conf.getBoolean(\n         YarnConfiguration.NM_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n     if (recoveryEnabled) {\n       stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n           STATE_STORE_ROOT_NAME);\n       stateStoreFs \u003d FileSystem.getLocal(conf);\n     }\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Preconditions\n             .checkArgument(\n                 validateAuxServiceName(sName),\n                 \"The ServiceName: \" + sName + \" set in \" +\n                 YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                 \"The valid service name should only contain a-zA-Z0-9_ \" +\n                 \"and can not start with numbers\");\n-        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n-              String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n-              AuxiliaryService.class);\n-        if (null \u003d\u003d sClass) {\n-          throw new RuntimeException(\"No class defined for \" + sName);\n+        String classKey \u003d String.format(\n+            YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n+        String className \u003d conf.get(classKey);\n+        final String appClassPath \u003d conf.get(String.format(\n+            YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n+        AuxiliaryService s \u003d null;\n+        boolean useCustomerClassLoader \u003d appClassPath !\u003d null\n+            \u0026\u0026 !appClassPath.isEmpty() \u0026\u0026 className !\u003d null\n+            \u0026\u0026 !className.isEmpty();\n+        if (useCustomerClassLoader) {\n+          s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n+              conf, className, appClassPath);\n+          LOG.info(\"The aux service:\" + sName\n+              + \" are using the custom classloader\");\n+        } else {\n+          Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n+              classKey, null, AuxiliaryService.class);\n+\n+          if (sClass \u003d\u003d null) {\n+            throw new RuntimeException(\"No class defined for \" + sName);\n+          }\n+          s \u003d ReflectionUtils.newInstance(sClass, conf);\n         }\n-        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n+        if (s \u003d\u003d null) {\n+          throw new RuntimeException(\"No object created for \" + sName);\n+        }\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n-                  +\"configuration is for \"+sClass+\" which has \"\n-                  +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n-                  +\"not the same tools trying to send ServiceData and read \"\n-                  +\"Service Meta Data may have issues unless the refer to \"\n-                  +\"the name in the config.\");\n+              +\"configuration is for \"+s.getClass()+\" which has \"\n+              +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n+              +\"not the same tools trying to send ServiceData and read \"\n+              +\"Service Meta Data may have issues unless the refer to \"\n+              +\"the name in the config.\");\n         }\n         addService(sName, s);\n         if (recoveryEnabled) {\n           Path storePath \u003d new Path(stateStoreRoot, sName);\n           stateStoreFs.mkdirs(storePath, storeDirPerms);\n           s.setRecoveryPath(storePath);\n         }\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.fatal(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n    Path stateStoreRoot \u003d null;\n    FileSystem stateStoreFs \u003d null;\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n          STATE_STORE_ROOT_NAME);\n      stateStoreFs \u003d FileSystem.getLocal(conf);\n    }\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Preconditions\n            .checkArgument(\n                validateAuxServiceName(sName),\n                \"The ServiceName: \" + sName + \" set in \" +\n                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                \"The valid service name should only contain a-zA-Z0-9_ \" +\n                \"and can not start with numbers\");\n        String classKey \u003d String.format(\n            YarnConfiguration.NM_AUX_SERVICE_FMT, sName);\n        String className \u003d conf.get(classKey);\n        final String appClassPath \u003d conf.get(String.format(\n            YarnConfiguration.NM_AUX_SERVICES_CLASSPATH, sName));\n        AuxiliaryService s \u003d null;\n        boolean useCustomerClassLoader \u003d appClassPath !\u003d null\n            \u0026\u0026 !appClassPath.isEmpty() \u0026\u0026 className !\u003d null\n            \u0026\u0026 !className.isEmpty();\n        if (useCustomerClassLoader) {\n          s \u003d AuxiliaryServiceWithCustomClassLoader.getInstance(\n              conf, className, appClassPath);\n          LOG.info(\"The aux service:\" + sName\n              + \" are using the custom classloader\");\n        } else {\n          Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              classKey, null, AuxiliaryService.class);\n\n          if (sClass \u003d\u003d null) {\n            throw new RuntimeException(\"No class defined for \" + sName);\n          }\n          s \u003d ReflectionUtils.newInstance(sClass, conf);\n        }\n        if (s \u003d\u003d null) {\n          throw new RuntimeException(\"No object created for \" + sName);\n        }\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n              +\"configuration is for \"+s.getClass()+\" which has \"\n              +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n              +\"not the same tools trying to send ServiceData and read \"\n              +\"Service Meta Data may have issues unless the refer to \"\n              +\"the name in the config.\");\n        }\n        addService(sName, s);\n        if (recoveryEnabled) {\n          Path storePath \u003d new Path(stateStoreRoot, sName);\n          stateStoreFs.mkdirs(storePath, storeDirPerms);\n          s.setRecoveryPath(storePath);\n        }\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "447bd7b5a61a5788dc2a5d29cedfc19f0e99c0f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3203. Correct a log message in AuxServices. Contributed by Brahma Reddy Battula.\n",
      "commitDate": "16/02/15 6:55 AM",
      "commitName": "447bd7b5a61a5788dc2a5d29cedfc19f0e99c0f5",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "08/04/14 10:15 AM",
      "commitNameOld": "245012a9d9b0a21b8e93837e3e1a1892adcbf73c",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 313.9,
      "commitsBetweenForRepo": 2515,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public void serviceInit(Configuration conf) throws Exception {\n     final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n     Path stateStoreRoot \u003d null;\n     FileSystem stateStoreFs \u003d null;\n     boolean recoveryEnabled \u003d conf.getBoolean(\n         YarnConfiguration.NM_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n     if (recoveryEnabled) {\n       stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n           STATE_STORE_ROOT_NAME);\n       stateStoreFs \u003d FileSystem.getLocal(conf);\n     }\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Preconditions\n             .checkArgument(\n                 validateAuxServiceName(sName),\n                 \"The ServiceName: \" + sName + \" set in \" +\n                 YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                 \"The valid service name should only contain a-zA-Z0-9_ \" +\n                 \"and can not start with numbers\");\n         Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n               AuxiliaryService.class);\n         if (null \u003d\u003d sClass) {\n           throw new RuntimeException(\"No class defined for \" + sName);\n         }\n         AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n-                  +\"configuration is for class \"+sClass+\" which has \"\n+                  +\"configuration is for \"+sClass+\" which has \"\n                   +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                   +\"not the same tools trying to send ServiceData and read \"\n                   +\"Service Meta Data may have issues unless the refer to \"\n                   +\"the name in the config.\");\n         }\n         addService(sName, s);\n         if (recoveryEnabled) {\n           Path storePath \u003d new Path(stateStoreRoot, sName);\n           stateStoreFs.mkdirs(storePath, storeDirPerms);\n           s.setRecoveryPath(storePath);\n         }\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.fatal(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n    Path stateStoreRoot \u003d null;\n    FileSystem stateStoreFs \u003d null;\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n          STATE_STORE_ROOT_NAME);\n      stateStoreFs \u003d FileSystem.getLocal(conf);\n    }\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Preconditions\n            .checkArgument(\n                validateAuxServiceName(sName),\n                \"The ServiceName: \" + sName + \" set in \" +\n                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                \"The valid service name should only contain a-zA-Z0-9_ \" +\n                \"and can not start with numbers\");\n        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n              AuxiliaryService.class);\n        if (null \u003d\u003d sClass) {\n          throw new RuntimeException(\"No class defined for \" + sName);\n        }\n        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                  +\"configuration is for \"+sClass+\" which has \"\n                  +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                  +\"not the same tools trying to send ServiceData and read \"\n                  +\"Service Meta Data may have issues unless the refer to \"\n                  +\"the name in the config.\");\n        }\n        addService(sName, s);\n        if (recoveryEnabled) {\n          Path storePath \u003d new Path(stateStoreRoot, sName);\n          stateStoreFs.mkdirs(storePath, storeDirPerms);\n          s.setRecoveryPath(storePath);\n        }\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "245012a9d9b0a21b8e93837e3e1a1892adcbf73c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1757. NM Recovery. Auxiliary service support. (Jason Lowe via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1585783 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/04/14 10:15 AM",
      "commitName": "245012a9d9b0a21b8e93837e3e1a1892adcbf73c",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "03/10/13 5:23 PM",
      "commitNameOld": "8ebf37f3691dee523f7d800bc82c7423c3e262e9",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 186.7,
      "commitsBetweenForRepo": 1299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,53 @@\n   public void serviceInit(Configuration conf) throws Exception {\n+    final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n+    Path stateStoreRoot \u003d null;\n+    FileSystem stateStoreFs \u003d null;\n+    boolean recoveryEnabled \u003d conf.getBoolean(\n+        YarnConfiguration.NM_RECOVERY_ENABLED,\n+        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n+    if (recoveryEnabled) {\n+      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n+          STATE_STORE_ROOT_NAME);\n+      stateStoreFs \u003d FileSystem.getLocal(conf);\n+    }\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Preconditions\n             .checkArgument(\n                 validateAuxServiceName(sName),\n                 \"The ServiceName: \" + sName + \" set in \" +\n                 YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                 \"The valid service name should only contain a-zA-Z0-9_ \" +\n                 \"and can not start with numbers\");\n         Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n               AuxiliaryService.class);\n         if (null \u003d\u003d sClass) {\n           throw new RuntimeException(\"No class defined for \" + sName);\n         }\n         AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                   +\"configuration is for class \"+sClass+\" which has \"\n                   +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                   +\"not the same tools trying to send ServiceData and read \"\n                   +\"Service Meta Data may have issues unless the refer to \"\n                   +\"the name in the config.\");\n         }\n         addService(sName, s);\n+        if (recoveryEnabled) {\n+          Path storePath \u003d new Path(stateStoreRoot, sName);\n+          stateStoreFs.mkdirs(storePath, storeDirPerms);\n+          s.setRecoveryPath(storePath);\n+        }\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.fatal(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    final FsPermission storeDirPerms \u003d new FsPermission((short)0700);\n    Path stateStoreRoot \u003d null;\n    FileSystem stateStoreFs \u003d null;\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      stateStoreRoot \u003d new Path(conf.get(YarnConfiguration.NM_RECOVERY_DIR),\n          STATE_STORE_ROOT_NAME);\n      stateStoreFs \u003d FileSystem.getLocal(conf);\n    }\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Preconditions\n            .checkArgument(\n                validateAuxServiceName(sName),\n                \"The ServiceName: \" + sName + \" set in \" +\n                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                \"The valid service name should only contain a-zA-Z0-9_ \" +\n                \"and can not start with numbers\");\n        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n              AuxiliaryService.class);\n        if (null \u003d\u003d sClass) {\n          throw new RuntimeException(\"No class defined for \" + sName);\n        }\n        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                  +\"configuration is for class \"+sClass+\" which has \"\n                  +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                  +\"not the same tools trying to send ServiceData and read \"\n                  +\"Service Meta Data may have issues unless the refer to \"\n                  +\"the name in the config.\");\n        }\n        addService(sName, s);\n        if (recoveryEnabled) {\n          Path storePath \u003d new Path(stateStoreRoot, sName);\n          stateStoreFs.mkdirs(storePath, storeDirPerms);\n          s.setRecoveryPath(storePath);\n        }\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "10a4289ebfe8a079562f2006a0e28acdbd8aa0c5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1229. Define constraints on Auxiliary Service names. Change ShuffleHandler service name from mapreduce.shuffle to mapreduce_shuffle. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1526065 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/09/13 5:35 PM",
      "commitName": "10a4289ebfe8a079562f2006a0e28acdbd8aa0c5",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "09/09/13 2:48 PM",
      "commitNameOld": "0f91d8485a6cd96153ad35e9babab248b20f53dc",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 15.12,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,37 @@\n   public void serviceInit(Configuration conf) throws Exception {\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n+        Preconditions\n+            .checkArgument(\n+                validateAuxServiceName(sName),\n+                \"The ServiceName: \" + sName + \" set in \" +\n+                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n+                \"The valid service name should only contain a-zA-Z0-9_ \" +\n+                \"and can not start with numbers\");\n         Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n               AuxiliaryService.class);\n         if (null \u003d\u003d sClass) {\n           throw new RuntimeException(\"No class defined for \" + sName);\n         }\n         AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                   +\"configuration is for class \"+sClass+\" which has \"\n                   +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                   +\"not the same tools trying to send ServiceData and read \"\n                   +\"Service Meta Data may have issues unless the refer to \"\n                   +\"the name in the config.\");\n         }\n         addService(sName, s);\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.fatal(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Preconditions\n            .checkArgument(\n                validateAuxServiceName(sName),\n                \"The ServiceName: \" + sName + \" set in \" +\n                YarnConfiguration.NM_AUX_SERVICES +\" is invalid.\" +\n                \"The valid service name should only contain a-zA-Z0-9_ \" +\n                \"and can not start with numbers\");\n        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n              AuxiliaryService.class);\n        if (null \u003d\u003d sClass) {\n          throw new RuntimeException(\"No class defined for \" + sName);\n        }\n        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                  +\"configuration is for class \"+sClass+\" which has \"\n                  +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                  +\"not the same tools trying to send ServiceData and read \"\n                  +\"Service Meta Data may have issues unless the refer to \"\n                  +\"the name in the config.\");\n        }\n        addService(sName, s);\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "3ee5949912a4fcd51e19ba758b6eff276543a74a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-368. Fixed a typo in error message in Auxiliary services. Contributed by Albert Chu.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1501852 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/13 10:02 AM",
      "commitName": "3ee5949912a4fcd51e19ba758b6eff276543a74a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/06/13 11:20 PM",
      "commitNameOld": "f4d80e91ae314d316100baa7770b9d73ea853d9c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 22.45,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n   public void serviceInit(Configuration conf) throws Exception {\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n               AuxiliaryService.class);\n         if (null \u003d\u003d sClass) {\n-          throw new RuntimeException(\"No class defiend for \" + sName);\n+          throw new RuntimeException(\"No class defined for \" + sName);\n         }\n         AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                   +\"configuration is for class \"+sClass+\" which has \"\n                   +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                   +\"not the same tools trying to send ServiceData and read \"\n                   +\"Service Meta Data may have issues unless the refer to \"\n                   +\"the name in the config.\");\n         }\n         addService(sName, s);\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.fatal(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n              AuxiliaryService.class);\n        if (null \u003d\u003d sClass) {\n          throw new RuntimeException(\"No class defined for \" + sName);\n        }\n        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                  +\"configuration is for class \"+sClass+\" which has \"\n                  +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                  +\"not the same tools trying to send ServiceData and read \"\n                  +\"Service Meta Data may have issues unless the refer to \"\n                  +\"the name in the config.\");\n        }\n        addService(sName, s);\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "0928502029ef141759008997335ea2cd836a7154": {
      "type": "Ymultichange(Yrename,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/06/13 8:54 AM",
      "commitName": "0928502029ef141759008997335ea2cd836a7154",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/06/13 8:54 AM",
          "commitName": "0928502029ef141759008997335ea2cd836a7154",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/08/12 10:22 PM",
          "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 309.44,
          "commitsBetweenForRepo": 1788,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,30 @@\n-  public void init(Configuration conf) {\n+  public void serviceInit(Configuration conf) throws Exception {\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n               AuxiliaryService.class);\n         if (null \u003d\u003d sClass) {\n           throw new RuntimeException(\"No class defiend for \" + sName);\n         }\n         AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                   +\"configuration is for class \"+sClass+\" which has \"\n                   +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                   +\"not the same tools trying to send ServiceData and read \"\n                   +\"Service Meta Data may have issues unless the refer to \"\n                   +\"the name in the config.\");\n         }\n         addService(sName, s);\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.fatal(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n-    super.init(conf);\n+    super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n              AuxiliaryService.class);\n        if (null \u003d\u003d sClass) {\n          throw new RuntimeException(\"No class defiend for \" + sName);\n        }\n        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                  +\"configuration is for class \"+sClass+\" which has \"\n                  +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                  +\"not the same tools trying to send ServiceData and read \"\n                  +\"Service Meta Data may have issues unless the refer to \"\n                  +\"the name in the config.\");\n        }\n        addService(sName, s);\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
          "extendedDetails": {
            "oldValue": "init",
            "newValue": "serviceInit"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/06/13 8:54 AM",
          "commitName": "0928502029ef141759008997335ea2cd836a7154",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/08/12 10:22 PM",
          "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 309.44,
          "commitsBetweenForRepo": 1788,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,30 @@\n-  public void init(Configuration conf) {\n+  public void serviceInit(Configuration conf) throws Exception {\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n               AuxiliaryService.class);\n         if (null \u003d\u003d sClass) {\n           throw new RuntimeException(\"No class defiend for \" + sName);\n         }\n         AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                   +\"configuration is for class \"+sClass+\" which has \"\n                   +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                   +\"not the same tools trying to send ServiceData and read \"\n                   +\"Service Meta Data may have issues unless the refer to \"\n                   +\"the name in the config.\");\n         }\n         addService(sName, s);\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.fatal(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n-    super.init(conf);\n+    super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n              AuxiliaryService.class);\n        if (null \u003d\u003d sClass) {\n          throw new RuntimeException(\"No class defiend for \" + sName);\n        }\n        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                  +\"configuration is for class \"+sClass+\" which has \"\n                  +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                  +\"not the same tools trying to send ServiceData and read \"\n                  +\"Service Meta Data may have issues unless the refer to \"\n                  +\"the name in the config.\");\n        }\n        addService(sName, s);\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[Exception]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/06/13 8:54 AM",
          "commitName": "0928502029ef141759008997335ea2cd836a7154",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/08/12 10:22 PM",
          "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 309.44,
          "commitsBetweenForRepo": 1788,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,30 @@\n-  public void init(Configuration conf) {\n+  public void serviceInit(Configuration conf) throws Exception {\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n         YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n               AuxiliaryService.class);\n         if (null \u003d\u003d sClass) {\n           throw new RuntimeException(\"No class defiend for \" + sName);\n         }\n         AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                   +\"configuration is for class \"+sClass+\" which has \"\n                   +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                   +\"not the same tools trying to send ServiceData and read \"\n                   +\"Service Meta Data may have issues unless the refer to \"\n                   +\"the name in the config.\");\n         }\n         addService(sName, s);\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.fatal(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n-    super.init(conf);\n+    super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void serviceInit(Configuration conf) throws Exception {\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n              AuxiliaryService.class);\n        if (null \u003d\u003d sClass) {\n          throw new RuntimeException(\"No class defiend for \" + sName);\n        }\n        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                  +\"configuration is for class \"+sClass+\" which has \"\n                  +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                  +\"not the same tools trying to send ServiceData and read \"\n                  +\"Service Meta Data may have issues unless the refer to \"\n                  +\"the name in the config.\");\n        }\n        addService(sName, s);\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.serviceInit(conf);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void init(Configuration conf) {\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n              AuxiliaryService.class);\n        if (null \u003d\u003d sClass) {\n          throw new RuntimeException(\"No class defiend for \" + sName);\n        }\n        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                  +\"configuration is for class \"+sClass+\" which has \"\n                  +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                  +\"not the same tools trying to send ServiceData and read \"\n                  +\"Service Meta Data may have issues unless the refer to \"\n                  +\"the name in the config.\");\n        }\n        addService(sName, s);\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.init(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java"
      }
    },
    "fafe8cd28e726566509c679e19d7da622f29f90d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2864. Normalize configuration variable names for YARN. Contributed by Robert Evans.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166955 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/11 6:44 PM",
      "commitName": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "08/09/11 11:40 AM",
      "commitNameOld": "6b6ef7b8e35af9bd325f6ff670cdbd0fb1265c7d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,30 @@\n   public void init(Configuration conf) {\n-    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(AUX_SERVICES);\n+    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n+        YarnConfiguration.NM_AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n-              String.format(AUX_SERVICE_CLASS_FMT, sName), null,\n+              String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n               AuxiliaryService.class);\n         if (null \u003d\u003d sClass) {\n           throw new RuntimeException(\"No class defiend for \" + sName);\n         }\n         AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n         // TODO better use s.getName()?\n         if(!sName.equals(s.getName())) {\n           LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                   +\"configuration is for class \"+sClass+\" which has \"\n                   +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                   +\"not the same tools trying to send ServiceData and read \"\n                   +\"Service Meta Data may have issues unless the refer to \"\n                   +\"the name in the config.\");\n         }\n         addService(sName, s);\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.fatal(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.init(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(\n        YarnConfiguration.NM_AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              String.format(YarnConfiguration.NM_AUX_SERVICE_FMT, sName), null,\n              AuxiliaryService.class);\n        if (null \u003d\u003d sClass) {\n          throw new RuntimeException(\"No class defiend for \" + sName);\n        }\n        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                  +\"configuration is for class \"+sClass+\" which has \"\n                  +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                  +\"not the same tools trying to send ServiceData and read \"\n                  +\"Service Meta Data may have issues unless the refer to \"\n                  +\"the name in the config.\");\n        }\n        addService(sName, s);\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.init(conf);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "ade0f0560f729e50382c6992f713f29e2dd5b270": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2652. Enabled multiple NMs to be runnable on a single node by making shuffle service port to be truely configurable. Contributed by Robert Joseph Evans.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1163585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/08/11 4:38 AM",
      "commitName": "ade0f0560f729e50382c6992f713f29e2dd5b270",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 6.48,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,29 @@\n   public void init(Configuration conf) {\n     Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(AUX_SERVICES);\n     for (final String sName : auxNames) {\n       try {\n         Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n               String.format(AUX_SERVICE_CLASS_FMT, sName), null,\n               AuxiliaryService.class);\n         if (null \u003d\u003d sClass) {\n           throw new RuntimeException(\"No class defiend for \" + sName);\n         }\n         AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n-        // TODO better use use s.getName()?\n+        // TODO better use s.getName()?\n+        if(!sName.equals(s.getName())) {\n+          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n+                  +\"configuration is for class \"+sClass+\" which has \"\n+                  +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n+                  +\"not the same tools trying to send ServiceData and read \"\n+                  +\"Service Meta Data may have issues unless the refer to \"\n+                  +\"the name in the config.\");\n+        }\n         addService(sName, s);\n         s.init(conf);\n       } catch (RuntimeException e) {\n         LOG.fatal(\"Failed to initialize \" + sName, e);\n         throw e;\n       }\n     }\n     super.init(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              String.format(AUX_SERVICE_CLASS_FMT, sName), null,\n              AuxiliaryService.class);\n        if (null \u003d\u003d sClass) {\n          throw new RuntimeException(\"No class defiend for \" + sName);\n        }\n        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n        // TODO better use s.getName()?\n        if(!sName.equals(s.getName())) {\n          LOG.warn(\"The Auxilurary Service named \u0027\"+sName+\"\u0027 in the \"\n                  +\"configuration is for class \"+sClass+\" which has \"\n                  +\"a name of \u0027\"+s.getName()+\"\u0027. Because these are \"\n                  +\"not the same tools trying to send ServiceData and read \"\n                  +\"Service Meta Data may have issues unless the refer to \"\n                  +\"the name in the config.\");\n        }\n        addService(sName, s);\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.init(conf);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void init(Configuration conf) {\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              String.format(AUX_SERVICE_CLASS_FMT, sName), null,\n              AuxiliaryService.class);\n        if (null \u003d\u003d sClass) {\n          throw new RuntimeException(\"No class defiend for \" + sName);\n        }\n        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n        // TODO better use use s.getName()?\n        addService(sName, s);\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.init(conf);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,21 @@\n+  public void init(Configuration conf) {\n+    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(AUX_SERVICES);\n+    for (final String sName : auxNames) {\n+      try {\n+        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n+              String.format(AUX_SERVICE_CLASS_FMT, sName), null,\n+              AuxiliaryService.class);\n+        if (null \u003d\u003d sClass) {\n+          throw new RuntimeException(\"No class defiend for \" + sName);\n+        }\n+        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n+        // TODO better use use s.getName()?\n+        addService(sName, s);\n+        s.init(conf);\n+      } catch (RuntimeException e) {\n+        LOG.fatal(\"Failed to initialize \" + sName, e);\n+        throw e;\n+      }\n+    }\n+    super.init(conf);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n    Collection\u003cString\u003e auxNames \u003d conf.getStringCollection(AUX_SERVICES);\n    for (final String sName : auxNames) {\n      try {\n        Class\u003c? extends AuxiliaryService\u003e sClass \u003d conf.getClass(\n              String.format(AUX_SERVICE_CLASS_FMT, sName), null,\n              AuxiliaryService.class);\n        if (null \u003d\u003d sClass) {\n          throw new RuntimeException(\"No class defiend for \" + sName);\n        }\n        AuxiliaryService s \u003d ReflectionUtils.newInstance(sClass, conf);\n        // TODO better use use s.getName()?\n        addService(sName, s);\n        s.init(conf);\n      } catch (RuntimeException e) {\n        LOG.fatal(\"Failed to initialize \" + sName, e);\n        throw e;\n      }\n    }\n    super.init(conf);\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/AuxServices.java"
    }
  }
}