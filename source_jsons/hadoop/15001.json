{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PBImageXmlWriter.java",
  "functionName": "visit",
  "functionId": "visit___file-RandomAccessFile",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageXmlWriter.java",
  "functionStartLine": 287,
  "functionEndLine": 373,
  "numCommitsSeen": 27,
  "timeTaken": 3770,
  "changeHistory": [
    "177131793a88960b734038f6e646476d568c3626",
    "299d38295d61e3ad154814b680558969449d50fe",
    "700b0e4019cf483f7532609711812150b8c44742",
    "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
    "4f8a487fcd3c5d324b0bb03157f404fb127e21e8",
    "bf5971b86a042076ff50add2ec8f90ae6198d3ca",
    "2624b20291629b4565ea45590b66f2c38f96df67",
    "a2edb11b68ae01a44092cb14ac2717a6aad93305"
  ],
  "changeHistoryShort": {
    "177131793a88960b734038f6e646476d568c3626": "Ybodychange",
    "299d38295d61e3ad154814b680558969449d50fe": "Ybodychange",
    "700b0e4019cf483f7532609711812150b8c44742": "Ybodychange",
    "b9f6d0c956f0278c8b9b83e05b523a442a730ebb": "Ybodychange",
    "4f8a487fcd3c5d324b0bb03157f404fb127e21e8": "Ybodychange",
    "bf5971b86a042076ff50add2ec8f90ae6198d3ca": "Ybodychange",
    "2624b20291629b4565ea45590b66f2c38f96df67": "Ybodychange",
    "a2edb11b68ae01a44092cb14ac2717a6aad93305": "Yintroduced"
  },
  "changeHistoryDetails": {
    "177131793a88960b734038f6e646476d568c3626": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14172. Avoid NPE when SectionName#fromString returns null. Contributed by Xiang Li.\n",
      "commitDate": "08/02/19 4:51 AM",
      "commitName": "177131793a88960b734038f6e646476d568c3626",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "15/10/18 3:18 AM",
      "commitNameOld": "b60ca37914b22550e3630fa02742d40697decb31",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 116.11,
      "commitsBetweenForRepo": 828,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,87 @@\n   public void visit(RandomAccessFile file) throws IOException {\n     if (!FSImageUtil.checkFileFormat(file)) {\n       throw new IOException(\"Unrecognized FSImage\");\n     }\n \n     FileSummary summary \u003d FSImageUtil.loadSummary(file);\n     try (FileInputStream fin \u003d new FileInputStream(file.getFD())) {\n       out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\u003cfsimage\u003e\");\n \n       out.print(\"\u003cversion\u003e\");\n       o(\"layoutVersion\", summary.getLayoutVersion());\n       o(\"onDiskVersion\", summary.getOndiskVersion());\n       // Output the version of OIV (which is not necessarily the version of\n       // the fsimage file).  This could be helpful in the case where a bug\n       // in OIV leads to information loss in the XML-- we can quickly tell\n       // if a specific fsimage XML file is affected by this bug.\n       o(\"oivRevision\", VersionInfo.getRevision());\n       out.print(\"\u003c/version\u003e\\n\");\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       for (FileSummary.Section s : sections) {\n         fin.getChannel().position(s.getOffset());\n         InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                 fin, s.getLength())));\n \n-        switch (SectionName.fromString(s.getName())) {\n+        SectionName sectionName \u003d SectionName.fromString(s.getName());\n+        if (sectionName \u003d\u003d null) {\n+          throw new IOException(\"Unrecognized section \" + s.getName());\n+        }\n+        switch (sectionName) {\n         case NS_INFO:\n           dumpNameSection(is);\n           break;\n         case STRING_TABLE:\n           loadStringTable(is);\n           break;\n         case ERASURE_CODING:\n           dumpErasureCodingSection(is);\n           break;\n         case INODE:\n           dumpINodeSection(is);\n           break;\n         case INODE_REFERENCE:\n           dumpINodeReferenceSection(is);\n           break;\n         case INODE_DIR:\n           dumpINodeDirectorySection(is);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           dumpFileUnderConstructionSection(is);\n           break;\n         case SNAPSHOT:\n           dumpSnapshotSection(is);\n           break;\n         case SNAPSHOT_DIFF:\n           dumpSnapshotDiffSection(is);\n           break;\n         case SECRET_MANAGER:\n           dumpSecretManagerSection(is);\n           break;\n         case CACHE_MANAGER:\n           dumpCacheManagerSection(is);\n           break;\n         default:\n           break;\n         }\n       }\n       out.print(\"\u003c/fsimage\u003e\\n\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void visit(RandomAccessFile file) throws IOException {\n    if (!FSImageUtil.checkFileFormat(file)) {\n      throw new IOException(\"Unrecognized FSImage\");\n    }\n\n    FileSummary summary \u003d FSImageUtil.loadSummary(file);\n    try (FileInputStream fin \u003d new FileInputStream(file.getFD())) {\n      out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\u003cfsimage\u003e\");\n\n      out.print(\"\u003cversion\u003e\");\n      o(\"layoutVersion\", summary.getLayoutVersion());\n      o(\"onDiskVersion\", summary.getOndiskVersion());\n      // Output the version of OIV (which is not necessarily the version of\n      // the fsimage file).  This could be helpful in the case where a bug\n      // in OIV leads to information loss in the XML-- we can quickly tell\n      // if a specific fsimage XML file is affected by this bug.\n      o(\"oivRevision\", VersionInfo.getRevision());\n      out.print(\"\u003c/version\u003e\\n\");\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      for (FileSummary.Section s : sections) {\n        fin.getChannel().position(s.getOffset());\n        InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                fin, s.getLength())));\n\n        SectionName sectionName \u003d SectionName.fromString(s.getName());\n        if (sectionName \u003d\u003d null) {\n          throw new IOException(\"Unrecognized section \" + s.getName());\n        }\n        switch (sectionName) {\n        case NS_INFO:\n          dumpNameSection(is);\n          break;\n        case STRING_TABLE:\n          loadStringTable(is);\n          break;\n        case ERASURE_CODING:\n          dumpErasureCodingSection(is);\n          break;\n        case INODE:\n          dumpINodeSection(is);\n          break;\n        case INODE_REFERENCE:\n          dumpINodeReferenceSection(is);\n          break;\n        case INODE_DIR:\n          dumpINodeDirectorySection(is);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          dumpFileUnderConstructionSection(is);\n          break;\n        case SNAPSHOT:\n          dumpSnapshotSection(is);\n          break;\n        case SNAPSHOT_DIFF:\n          dumpSnapshotDiffSection(is);\n          break;\n        case SECRET_MANAGER:\n          dumpSecretManagerSection(is);\n          break;\n        case CACHE_MANAGER:\n          dumpCacheManagerSection(is);\n          break;\n        default:\n          break;\n        }\n      }\n      out.print(\"\u003c/fsimage\u003e\\n\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageXmlWriter.java",
      "extendedDetails": {}
    },
    "299d38295d61e3ad154814b680558969449d50fe": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11467. Support ErasureCoding section in OIV XML/ReverseXML. Contributed by Huafeng Wang.\n",
      "commitDate": "03/11/17 12:05 PM",
      "commitName": "299d38295d61e3ad154814b680558969449d50fe",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "27/03/17 5:23 AM",
      "commitNameOld": "46d37a65cf09c2714b4c0c4ec0399031d60027a5",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 221.28,
      "commitsBetweenForRepo": 1485,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,83 @@\n   public void visit(RandomAccessFile file) throws IOException {\n     if (!FSImageUtil.checkFileFormat(file)) {\n       throw new IOException(\"Unrecognized FSImage\");\n     }\n \n     FileSummary summary \u003d FSImageUtil.loadSummary(file);\n     try (FileInputStream fin \u003d new FileInputStream(file.getFD())) {\n       out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\u003cfsimage\u003e\");\n \n       out.print(\"\u003cversion\u003e\");\n       o(\"layoutVersion\", summary.getLayoutVersion());\n       o(\"onDiskVersion\", summary.getOndiskVersion());\n       // Output the version of OIV (which is not necessarily the version of\n       // the fsimage file).  This could be helpful in the case where a bug\n       // in OIV leads to information loss in the XML-- we can quickly tell\n       // if a specific fsimage XML file is affected by this bug.\n       o(\"oivRevision\", VersionInfo.getRevision());\n       out.print(\"\u003c/version\u003e\\n\");\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       for (FileSummary.Section s : sections) {\n         fin.getChannel().position(s.getOffset());\n         InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                 fin, s.getLength())));\n \n         switch (SectionName.fromString(s.getName())) {\n         case NS_INFO:\n           dumpNameSection(is);\n           break;\n         case STRING_TABLE:\n           loadStringTable(is);\n           break;\n+        case ERASURE_CODING:\n+          dumpErasureCodingSection(is);\n+          break;\n         case INODE:\n           dumpINodeSection(is);\n           break;\n         case INODE_REFERENCE:\n           dumpINodeReferenceSection(is);\n           break;\n         case INODE_DIR:\n           dumpINodeDirectorySection(is);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           dumpFileUnderConstructionSection(is);\n           break;\n         case SNAPSHOT:\n           dumpSnapshotSection(is);\n           break;\n         case SNAPSHOT_DIFF:\n           dumpSnapshotDiffSection(is);\n           break;\n         case SECRET_MANAGER:\n           dumpSecretManagerSection(is);\n           break;\n         case CACHE_MANAGER:\n           dumpCacheManagerSection(is);\n           break;\n         default:\n           break;\n         }\n       }\n       out.print(\"\u003c/fsimage\u003e\\n\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void visit(RandomAccessFile file) throws IOException {\n    if (!FSImageUtil.checkFileFormat(file)) {\n      throw new IOException(\"Unrecognized FSImage\");\n    }\n\n    FileSummary summary \u003d FSImageUtil.loadSummary(file);\n    try (FileInputStream fin \u003d new FileInputStream(file.getFD())) {\n      out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\u003cfsimage\u003e\");\n\n      out.print(\"\u003cversion\u003e\");\n      o(\"layoutVersion\", summary.getLayoutVersion());\n      o(\"onDiskVersion\", summary.getOndiskVersion());\n      // Output the version of OIV (which is not necessarily the version of\n      // the fsimage file).  This could be helpful in the case where a bug\n      // in OIV leads to information loss in the XML-- we can quickly tell\n      // if a specific fsimage XML file is affected by this bug.\n      o(\"oivRevision\", VersionInfo.getRevision());\n      out.print(\"\u003c/version\u003e\\n\");\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      for (FileSummary.Section s : sections) {\n        fin.getChannel().position(s.getOffset());\n        InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                fin, s.getLength())));\n\n        switch (SectionName.fromString(s.getName())) {\n        case NS_INFO:\n          dumpNameSection(is);\n          break;\n        case STRING_TABLE:\n          loadStringTable(is);\n          break;\n        case ERASURE_CODING:\n          dumpErasureCodingSection(is);\n          break;\n        case INODE:\n          dumpINodeSection(is);\n          break;\n        case INODE_REFERENCE:\n          dumpINodeReferenceSection(is);\n          break;\n        case INODE_DIR:\n          dumpINodeDirectorySection(is);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          dumpFileUnderConstructionSection(is);\n          break;\n        case SNAPSHOT:\n          dumpSnapshotSection(is);\n          break;\n        case SNAPSHOT_DIFF:\n          dumpSnapshotDiffSection(is);\n          break;\n        case SECRET_MANAGER:\n          dumpSecretManagerSection(is);\n          break;\n        case CACHE_MANAGER:\n          dumpCacheManagerSection(is);\n          break;\n        default:\n          break;\n        }\n      }\n      out.print(\"\u003c/fsimage\u003e\\n\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageXmlWriter.java",
      "extendedDetails": {}
    },
    "700b0e4019cf483f7532609711812150b8c44742": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9835. OIV: add ReverseXML processor which reconstructs an fsimage from an XML file (cmccabe)\n",
      "commitDate": "02/03/16 5:56 PM",
      "commitName": "700b0e4019cf483f7532609711812150b8c44742",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "21/10/15 2:58 PM",
      "commitNameOld": "a24c6e84205c684ef864b0fc5301dc07b3578351",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 133.17,
      "commitsBetweenForRepo": 905,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,80 @@\n   public void visit(RandomAccessFile file) throws IOException {\n     if (!FSImageUtil.checkFileFormat(file)) {\n       throw new IOException(\"Unrecognized FSImage\");\n     }\n \n     FileSummary summary \u003d FSImageUtil.loadSummary(file);\n     try (FileInputStream fin \u003d new FileInputStream(file.getFD())) {\n       out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\u003cfsimage\u003e\");\n \n+      out.print(\"\u003cversion\u003e\");\n+      o(\"layoutVersion\", summary.getLayoutVersion());\n+      o(\"onDiskVersion\", summary.getOndiskVersion());\n+      // Output the version of OIV (which is not necessarily the version of\n+      // the fsimage file).  This could be helpful in the case where a bug\n+      // in OIV leads to information loss in the XML-- we can quickly tell\n+      // if a specific fsimage XML file is affected by this bug.\n+      o(\"oivRevision\", VersionInfo.getRevision());\n+      out.print(\"\u003c/version\u003e\\n\");\n+\n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       for (FileSummary.Section s : sections) {\n         fin.getChannel().position(s.getOffset());\n         InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                 fin, s.getLength())));\n \n         switch (SectionName.fromString(s.getName())) {\n         case NS_INFO:\n           dumpNameSection(is);\n           break;\n         case STRING_TABLE:\n           loadStringTable(is);\n           break;\n         case INODE:\n           dumpINodeSection(is);\n           break;\n         case INODE_REFERENCE:\n           dumpINodeReferenceSection(is);\n           break;\n         case INODE_DIR:\n           dumpINodeDirectorySection(is);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           dumpFileUnderConstructionSection(is);\n           break;\n         case SNAPSHOT:\n           dumpSnapshotSection(is);\n           break;\n         case SNAPSHOT_DIFF:\n           dumpSnapshotDiffSection(is);\n           break;\n         case SECRET_MANAGER:\n           dumpSecretManagerSection(is);\n           break;\n         case CACHE_MANAGER:\n           dumpCacheManagerSection(is);\n           break;\n         default:\n           break;\n         }\n       }\n       out.print(\"\u003c/fsimage\u003e\\n\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void visit(RandomAccessFile file) throws IOException {\n    if (!FSImageUtil.checkFileFormat(file)) {\n      throw new IOException(\"Unrecognized FSImage\");\n    }\n\n    FileSummary summary \u003d FSImageUtil.loadSummary(file);\n    try (FileInputStream fin \u003d new FileInputStream(file.getFD())) {\n      out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\u003cfsimage\u003e\");\n\n      out.print(\"\u003cversion\u003e\");\n      o(\"layoutVersion\", summary.getLayoutVersion());\n      o(\"onDiskVersion\", summary.getOndiskVersion());\n      // Output the version of OIV (which is not necessarily the version of\n      // the fsimage file).  This could be helpful in the case where a bug\n      // in OIV leads to information loss in the XML-- we can quickly tell\n      // if a specific fsimage XML file is affected by this bug.\n      o(\"oivRevision\", VersionInfo.getRevision());\n      out.print(\"\u003c/version\u003e\\n\");\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      for (FileSummary.Section s : sections) {\n        fin.getChannel().position(s.getOffset());\n        InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                fin, s.getLength())));\n\n        switch (SectionName.fromString(s.getName())) {\n        case NS_INFO:\n          dumpNameSection(is);\n          break;\n        case STRING_TABLE:\n          loadStringTable(is);\n          break;\n        case INODE:\n          dumpINodeSection(is);\n          break;\n        case INODE_REFERENCE:\n          dumpINodeReferenceSection(is);\n          break;\n        case INODE_DIR:\n          dumpINodeDirectorySection(is);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          dumpFileUnderConstructionSection(is);\n          break;\n        case SNAPSHOT:\n          dumpSnapshotSection(is);\n          break;\n        case SNAPSHOT_DIFF:\n          dumpSnapshotDiffSection(is);\n          break;\n        case SECRET_MANAGER:\n          dumpSecretManagerSection(is);\n          break;\n        case CACHE_MANAGER:\n          dumpCacheManagerSection(is);\n          break;\n        default:\n          break;\n        }\n      }\n      out.print(\"\u003c/fsimage\u003e\\n\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageXmlWriter.java",
      "extendedDetails": {}
    },
    "b9f6d0c956f0278c8b9b83e05b523a442a730ebb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7515. Fix new findbugs warnings in hadoop-hdfs. Contributed by Haohui Mai.\n",
      "commitDate": "11/12/14 12:36 PM",
      "commitName": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "08/11/14 3:39 PM",
      "commitNameOld": "6caa8100d5d2547e34356dc279fd5e65b81a925a",
      "commitAuthorOld": "Arun C. Murthy",
      "daysBetweenCommits": 32.87,
      "commitsBetweenForRepo": 232,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,70 @@\n   public void visit(RandomAccessFile file) throws IOException {\n     if (!FSImageUtil.checkFileFormat(file)) {\n       throw new IOException(\"Unrecognized FSImage\");\n     }\n \n     FileSummary summary \u003d FSImageUtil.loadSummary(file);\n-    FileInputStream fin \u003d null;\n-    try {\n-      fin \u003d new FileInputStream(file.getFD());\n+    try (FileInputStream fin \u003d new FileInputStream(file.getFD())) {\n       out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\u003cfsimage\u003e\");\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       for (FileSummary.Section s : sections) {\n         fin.getChannel().position(s.getOffset());\n         InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                 fin, s.getLength())));\n \n         switch (SectionName.fromString(s.getName())) {\n         case NS_INFO:\n           dumpNameSection(is);\n           break;\n         case STRING_TABLE:\n           loadStringTable(is);\n           break;\n         case INODE:\n           dumpINodeSection(is);\n           break;\n         case INODE_REFERENCE:\n           dumpINodeReferenceSection(is);\n           break;\n         case INODE_DIR:\n           dumpINodeDirectorySection(is);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           dumpFileUnderConstructionSection(is);\n           break;\n         case SNAPSHOT:\n           dumpSnapshotSection(is);\n           break;\n         case SNAPSHOT_DIFF:\n           dumpSnapshotDiffSection(is);\n           break;\n         case SECRET_MANAGER:\n           dumpSecretManagerSection(is);\n           break;\n         case CACHE_MANAGER:\n           dumpCacheManagerSection(is);\n           break;\n         default:\n           break;\n         }\n       }\n       out.print(\"\u003c/fsimage\u003e\\n\");\n-    } finally {\n-      IOUtils.cleanup(null, fin);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void visit(RandomAccessFile file) throws IOException {\n    if (!FSImageUtil.checkFileFormat(file)) {\n      throw new IOException(\"Unrecognized FSImage\");\n    }\n\n    FileSummary summary \u003d FSImageUtil.loadSummary(file);\n    try (FileInputStream fin \u003d new FileInputStream(file.getFD())) {\n      out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\u003cfsimage\u003e\");\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      for (FileSummary.Section s : sections) {\n        fin.getChannel().position(s.getOffset());\n        InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                fin, s.getLength())));\n\n        switch (SectionName.fromString(s.getName())) {\n        case NS_INFO:\n          dumpNameSection(is);\n          break;\n        case STRING_TABLE:\n          loadStringTable(is);\n          break;\n        case INODE:\n          dumpINodeSection(is);\n          break;\n        case INODE_REFERENCE:\n          dumpINodeReferenceSection(is);\n          break;\n        case INODE_DIR:\n          dumpINodeDirectorySection(is);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          dumpFileUnderConstructionSection(is);\n          break;\n        case SNAPSHOT:\n          dumpSnapshotSection(is);\n          break;\n        case SNAPSHOT_DIFF:\n          dumpSnapshotDiffSection(is);\n          break;\n        case SECRET_MANAGER:\n          dumpSecretManagerSection(is);\n          break;\n        case CACHE_MANAGER:\n          dumpCacheManagerSection(is);\n          break;\n        default:\n          break;\n        }\n      }\n      out.print(\"\u003c/fsimage\u003e\\n\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageXmlWriter.java",
      "extendedDetails": {}
    },
    "4f8a487fcd3c5d324b0bb03157f404fb127e21e8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5981. loadGenerator exit code is not reliable. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1570468 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/02/14 10:39 PM",
      "commitName": "4f8a487fcd3c5d324b0bb03157f404fb127e21e8",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "20/02/14 8:09 AM",
      "commitNameOld": "b23f6cc1f2dd779a683bd452b5ca014848a9b782",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.6,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,74 @@\n   public void visit(RandomAccessFile file) throws IOException {\n     if (!FSImageUtil.checkFileFormat(file)) {\n       throw new IOException(\"Unrecognized FSImage\");\n     }\n \n     FileSummary summary \u003d FSImageUtil.loadSummary(file);\n     FileInputStream fin \u003d null;\n     try {\n       fin \u003d new FileInputStream(file.getFD());\n-      out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\");\n+      out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\u003cfsimage\u003e\");\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       for (FileSummary.Section s : sections) {\n         fin.getChannel().position(s.getOffset());\n         InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                 fin, s.getLength())));\n \n         switch (SectionName.fromString(s.getName())) {\n         case NS_INFO:\n           dumpNameSection(is);\n           break;\n         case STRING_TABLE:\n           loadStringTable(is);\n           break;\n         case INODE:\n           dumpINodeSection(is);\n           break;\n         case INODE_REFERENCE:\n           dumpINodeReferenceSection(is);\n           break;\n         case INODE_DIR:\n           dumpINodeDirectorySection(is);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           dumpFileUnderConstructionSection(is);\n           break;\n         case SNAPSHOT:\n           dumpSnapshotSection(is);\n           break;\n         case SNAPSHOT_DIFF:\n           dumpSnapshotDiffSection(is);\n           break;\n         case SECRET_MANAGER:\n           dumpSecretManagerSection(is);\n           break;\n         case CACHE_MANAGER:\n           dumpCacheManagerSection(is);\n           break;\n         default:\n           break;\n         }\n       }\n+      out.print(\"\u003c/fsimage\u003e\\n\");\n     } finally {\n       IOUtils.cleanup(null, fin);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void visit(RandomAccessFile file) throws IOException {\n    if (!FSImageUtil.checkFileFormat(file)) {\n      throw new IOException(\"Unrecognized FSImage\");\n    }\n\n    FileSummary summary \u003d FSImageUtil.loadSummary(file);\n    FileInputStream fin \u003d null;\n    try {\n      fin \u003d new FileInputStream(file.getFD());\n      out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\u003cfsimage\u003e\");\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      for (FileSummary.Section s : sections) {\n        fin.getChannel().position(s.getOffset());\n        InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                fin, s.getLength())));\n\n        switch (SectionName.fromString(s.getName())) {\n        case NS_INFO:\n          dumpNameSection(is);\n          break;\n        case STRING_TABLE:\n          loadStringTable(is);\n          break;\n        case INODE:\n          dumpINodeSection(is);\n          break;\n        case INODE_REFERENCE:\n          dumpINodeReferenceSection(is);\n          break;\n        case INODE_DIR:\n          dumpINodeDirectorySection(is);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          dumpFileUnderConstructionSection(is);\n          break;\n        case SNAPSHOT:\n          dumpSnapshotSection(is);\n          break;\n        case SNAPSHOT_DIFF:\n          dumpSnapshotDiffSection(is);\n          break;\n        case SECRET_MANAGER:\n          dumpSecretManagerSection(is);\n          break;\n        case CACHE_MANAGER:\n          dumpCacheManagerSection(is);\n          break;\n        default:\n          break;\n        }\n      }\n      out.print(\"\u003c/fsimage\u003e\\n\");\n    } finally {\n      IOUtils.cleanup(null, fin);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageXmlWriter.java",
      "extendedDetails": {}
    },
    "bf5971b86a042076ff50add2ec8f90ae6198d3ca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5959. Fix typo at section name in FSImageFormatProtobuf.java. Contributed by Akira Ajisaka.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1569156 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/02/14 5:06 PM",
      "commitName": "bf5971b86a042076ff50add2ec8f90ae6198d3ca",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "17/02/14 2:28 PM",
      "commitNameOld": "2c7dfa29bdda7de5b62ceba1fe1ac89bb7e70cae",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 0.11,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   public void visit(RandomAccessFile file) throws IOException {\n     if (!FSImageUtil.checkFileFormat(file)) {\n       throw new IOException(\"Unrecognized FSImage\");\n     }\n \n     FileSummary summary \u003d FSImageUtil.loadSummary(file);\n     FileInputStream fin \u003d null;\n     try {\n       fin \u003d new FileInputStream(file.getFD());\n       out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\");\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       for (FileSummary.Section s : sections) {\n         fin.getChannel().position(s.getOffset());\n         InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                 fin, s.getLength())));\n \n         switch (SectionName.fromString(s.getName())) {\n         case NS_INFO:\n           dumpNameSection(is);\n           break;\n         case STRING_TABLE:\n           loadStringTable(is);\n           break;\n         case INODE:\n           dumpINodeSection(is);\n           break;\n-        case INODE_REFRENCE:\n+        case INODE_REFERENCE:\n           dumpINodeReferenceSection(is);\n           break;\n         case INODE_DIR:\n           dumpINodeDirectorySection(is);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           dumpFileUnderConstructionSection(is);\n           break;\n         case SNAPSHOT:\n           dumpSnapshotSection(is);\n           break;\n         case SNAPSHOT_DIFF:\n           dumpSnapshotDiffSection(is);\n           break;\n         case SECRET_MANAGER:\n           dumpSecretManagerSection(is);\n           break;\n         case CACHE_MANAGER:\n           dumpCacheManagerSection(is);\n           break;\n         default:\n           break;\n         }\n       }\n     } finally {\n       IOUtils.cleanup(null, fin);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void visit(RandomAccessFile file) throws IOException {\n    if (!FSImageUtil.checkFileFormat(file)) {\n      throw new IOException(\"Unrecognized FSImage\");\n    }\n\n    FileSummary summary \u003d FSImageUtil.loadSummary(file);\n    FileInputStream fin \u003d null;\n    try {\n      fin \u003d new FileInputStream(file.getFD());\n      out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\");\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      for (FileSummary.Section s : sections) {\n        fin.getChannel().position(s.getOffset());\n        InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                fin, s.getLength())));\n\n        switch (SectionName.fromString(s.getName())) {\n        case NS_INFO:\n          dumpNameSection(is);\n          break;\n        case STRING_TABLE:\n          loadStringTable(is);\n          break;\n        case INODE:\n          dumpINodeSection(is);\n          break;\n        case INODE_REFERENCE:\n          dumpINodeReferenceSection(is);\n          break;\n        case INODE_DIR:\n          dumpINodeDirectorySection(is);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          dumpFileUnderConstructionSection(is);\n          break;\n        case SNAPSHOT:\n          dumpSnapshotSection(is);\n          break;\n        case SNAPSHOT_DIFF:\n          dumpSnapshotDiffSection(is);\n          break;\n        case SECRET_MANAGER:\n          dumpSecretManagerSection(is);\n          break;\n        case CACHE_MANAGER:\n          dumpCacheManagerSection(is);\n          break;\n        default:\n          break;\n        }\n      }\n    } finally {\n      IOUtils.cleanup(null, fin);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageXmlWriter.java",
      "extendedDetails": {}
    },
    "2624b20291629b4565ea45590b66f2c38f96df67": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5847. Consolidate INodeReference into a separate section. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567812 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 4:00 PM",
      "commitName": "2624b20291629b4565ea45590b66f2c38f96df67",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "09/02/14 11:18 AM",
      "commitNameOld": "a2edb11b68ae01a44092cb14ac2717a6aad93305",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 3.2,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,73 @@\n   public void visit(RandomAccessFile file) throws IOException {\n     if (!FSImageUtil.checkFileFormat(file)) {\n       throw new IOException(\"Unrecognized FSImage\");\n     }\n \n     FileSummary summary \u003d FSImageUtil.loadSummary(file);\n     FileInputStream fin \u003d null;\n     try {\n       fin \u003d new FileInputStream(file.getFD());\n       out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\");\n \n       ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n           .getSectionsList());\n       Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n         @Override\n         public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n           SectionName n1 \u003d SectionName.fromString(s1.getName());\n           SectionName n2 \u003d SectionName.fromString(s2.getName());\n           if (n1 \u003d\u003d null) {\n             return n2 \u003d\u003d null ? 0 : -1;\n           } else if (n2 \u003d\u003d null) {\n             return -1;\n           } else {\n             return n1.ordinal() - n2.ordinal();\n           }\n         }\n       });\n \n       for (FileSummary.Section s : sections) {\n         fin.getChannel().position(s.getOffset());\n         InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n             summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                 fin, s.getLength())));\n \n         switch (SectionName.fromString(s.getName())) {\n         case NS_INFO:\n           dumpNameSection(is);\n           break;\n         case STRING_TABLE:\n           loadStringTable(is);\n           break;\n         case INODE:\n           dumpINodeSection(is);\n           break;\n+        case INODE_REFRENCE:\n+          dumpINodeReferenceSection(is);\n+          break;\n         case INODE_DIR:\n           dumpINodeDirectorySection(is);\n           break;\n         case FILES_UNDERCONSTRUCTION:\n           dumpFileUnderConstructionSection(is);\n           break;\n         case SNAPSHOT:\n           dumpSnapshotSection(is);\n           break;\n         case SNAPSHOT_DIFF:\n           dumpSnapshotDiffSection(is);\n           break;\n         case SECRET_MANAGER:\n           dumpSecretManagerSection(is);\n           break;\n         case CACHE_MANAGER:\n           dumpCacheManagerSection(is);\n           break;\n         default:\n           break;\n         }\n       }\n     } finally {\n       IOUtils.cleanup(null, fin);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void visit(RandomAccessFile file) throws IOException {\n    if (!FSImageUtil.checkFileFormat(file)) {\n      throw new IOException(\"Unrecognized FSImage\");\n    }\n\n    FileSummary summary \u003d FSImageUtil.loadSummary(file);\n    FileInputStream fin \u003d null;\n    try {\n      fin \u003d new FileInputStream(file.getFD());\n      out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\");\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      for (FileSummary.Section s : sections) {\n        fin.getChannel().position(s.getOffset());\n        InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                fin, s.getLength())));\n\n        switch (SectionName.fromString(s.getName())) {\n        case NS_INFO:\n          dumpNameSection(is);\n          break;\n        case STRING_TABLE:\n          loadStringTable(is);\n          break;\n        case INODE:\n          dumpINodeSection(is);\n          break;\n        case INODE_REFRENCE:\n          dumpINodeReferenceSection(is);\n          break;\n        case INODE_DIR:\n          dumpINodeDirectorySection(is);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          dumpFileUnderConstructionSection(is);\n          break;\n        case SNAPSHOT:\n          dumpSnapshotSection(is);\n          break;\n        case SNAPSHOT_DIFF:\n          dumpSnapshotDiffSection(is);\n          break;\n        case SECRET_MANAGER:\n          dumpSecretManagerSection(is);\n          break;\n        case CACHE_MANAGER:\n          dumpCacheManagerSection(is);\n          break;\n        default:\n          break;\n        }\n      }\n    } finally {\n      IOUtils.cleanup(null, fin);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageXmlWriter.java",
      "extendedDetails": {}
    },
    "a2edb11b68ae01a44092cb14ac2717a6aad93305": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5698. Use protobuf to serialize / deserialize FSImage. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1566359 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/02/14 11:18 AM",
      "commitName": "a2edb11b68ae01a44092cb14ac2717a6aad93305",
      "commitAuthor": "Jing Zhao",
      "diff": "@@ -0,0 +1,70 @@\n+  public void visit(RandomAccessFile file) throws IOException {\n+    if (!FSImageUtil.checkFileFormat(file)) {\n+      throw new IOException(\"Unrecognized FSImage\");\n+    }\n+\n+    FileSummary summary \u003d FSImageUtil.loadSummary(file);\n+    FileInputStream fin \u003d null;\n+    try {\n+      fin \u003d new FileInputStream(file.getFD());\n+      out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\");\n+\n+      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n+          .getSectionsList());\n+      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n+        @Override\n+        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n+          SectionName n1 \u003d SectionName.fromString(s1.getName());\n+          SectionName n2 \u003d SectionName.fromString(s2.getName());\n+          if (n1 \u003d\u003d null) {\n+            return n2 \u003d\u003d null ? 0 : -1;\n+          } else if (n2 \u003d\u003d null) {\n+            return -1;\n+          } else {\n+            return n1.ordinal() - n2.ordinal();\n+          }\n+        }\n+      });\n+\n+      for (FileSummary.Section s : sections) {\n+        fin.getChannel().position(s.getOffset());\n+        InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n+            summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n+                fin, s.getLength())));\n+\n+        switch (SectionName.fromString(s.getName())) {\n+        case NS_INFO:\n+          dumpNameSection(is);\n+          break;\n+        case STRING_TABLE:\n+          loadStringTable(is);\n+          break;\n+        case INODE:\n+          dumpINodeSection(is);\n+          break;\n+        case INODE_DIR:\n+          dumpINodeDirectorySection(is);\n+          break;\n+        case FILES_UNDERCONSTRUCTION:\n+          dumpFileUnderConstructionSection(is);\n+          break;\n+        case SNAPSHOT:\n+          dumpSnapshotSection(is);\n+          break;\n+        case SNAPSHOT_DIFF:\n+          dumpSnapshotDiffSection(is);\n+          break;\n+        case SECRET_MANAGER:\n+          dumpSecretManagerSection(is);\n+          break;\n+        case CACHE_MANAGER:\n+          dumpCacheManagerSection(is);\n+          break;\n+        default:\n+          break;\n+        }\n+      }\n+    } finally {\n+      IOUtils.cleanup(null, fin);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void visit(RandomAccessFile file) throws IOException {\n    if (!FSImageUtil.checkFileFormat(file)) {\n      throw new IOException(\"Unrecognized FSImage\");\n    }\n\n    FileSummary summary \u003d FSImageUtil.loadSummary(file);\n    FileInputStream fin \u003d null;\n    try {\n      fin \u003d new FileInputStream(file.getFD());\n      out.print(\"\u003c?xml version\u003d\\\"1.0\\\"?\u003e\\n\");\n\n      ArrayList\u003cFileSummary.Section\u003e sections \u003d Lists.newArrayList(summary\n          .getSectionsList());\n      Collections.sort(sections, new Comparator\u003cFileSummary.Section\u003e() {\n        @Override\n        public int compare(FileSummary.Section s1, FileSummary.Section s2) {\n          SectionName n1 \u003d SectionName.fromString(s1.getName());\n          SectionName n2 \u003d SectionName.fromString(s2.getName());\n          if (n1 \u003d\u003d null) {\n            return n2 \u003d\u003d null ? 0 : -1;\n          } else if (n2 \u003d\u003d null) {\n            return -1;\n          } else {\n            return n1.ordinal() - n2.ordinal();\n          }\n        }\n      });\n\n      for (FileSummary.Section s : sections) {\n        fin.getChannel().position(s.getOffset());\n        InputStream is \u003d FSImageUtil.wrapInputStreamForCompression(conf,\n            summary.getCodec(), new BufferedInputStream(new LimitInputStream(\n                fin, s.getLength())));\n\n        switch (SectionName.fromString(s.getName())) {\n        case NS_INFO:\n          dumpNameSection(is);\n          break;\n        case STRING_TABLE:\n          loadStringTable(is);\n          break;\n        case INODE:\n          dumpINodeSection(is);\n          break;\n        case INODE_DIR:\n          dumpINodeDirectorySection(is);\n          break;\n        case FILES_UNDERCONSTRUCTION:\n          dumpFileUnderConstructionSection(is);\n          break;\n        case SNAPSHOT:\n          dumpSnapshotSection(is);\n          break;\n        case SNAPSHOT_DIFF:\n          dumpSnapshotDiffSection(is);\n          break;\n        case SECRET_MANAGER:\n          dumpSecretManagerSection(is);\n          break;\n        case CACHE_MANAGER:\n          dumpCacheManagerSection(is);\n          break;\n        default:\n          break;\n        }\n      }\n    } finally {\n      IOUtils.cleanup(null, fin);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageXmlWriter.java"
    }
  }
}