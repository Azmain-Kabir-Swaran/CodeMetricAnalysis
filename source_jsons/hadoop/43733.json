{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ServiceApiUtil.java",
  "functionName": "validateAndResolveService",
  "functionId": "validateAndResolveService___service-Service__fs-SliderFileSystem__conf-org.apache.hadoop.conf.Configuration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
  "functionStartLine": 105,
  "functionEndLine": 249,
  "numCommitsSeen": 57,
  "timeTaken": 12297,
  "changeHistory": [
    "9f15483c5d7c94251f4c84e0155449188f202779",
    "58b97c79e34901938d59acc84ed48c1f9344996a",
    "1d6e43da51aaaab522325bdbe4b51e58934e03f1",
    "a0bde7d525911680f9e5fb0a939604865eb8e164",
    "e1f5251f3c0d6e74af1b52eda6633b728804fe2a",
    "0c559b27820d12ebe5c315c6e2d1685c6de6bd33",
    "d30d57828fddaa8667de49af879cde999907c7f6",
    "68acd88dcbfe03a0134c60b5398dfaa31ad2b786",
    "40ab068eabe50875449d601471619a4e82fff86d",
    "2191f5b533c6b4763f5d443d21127f1f8552ce64",
    "1888318c89776f0bf354c1b13e3ee169e14ff638",
    "59a9b4f4382e435b6e9eca928417bf66f70069a4",
    "e86d828548c17ebadc0e6d22b50151eebd9696d5",
    "a0574e7f4f5a6e53677ada4381db5504f263d70f",
    "845764da146e98927e8ea5b2209f19f4fc3feda5",
    "c31cd981ebabc0747cabcc07a8c8797619ed2c53",
    "ef5a3628c2428a1f8b0b17e1ff2aabe6820b63d5",
    "7da243ebe05be27ade86feac83a6243eebba619c",
    "c0120e51b944f86de4d533bcbc59f715047b9ea9",
    "18bf0dce28a9a602f67a0c28fe5c350065931bd0"
  ],
  "changeHistoryShort": {
    "9f15483c5d7c94251f4c84e0155449188f202779": "Ybodychange",
    "58b97c79e34901938d59acc84ed48c1f9344996a": "Ybodychange",
    "1d6e43da51aaaab522325bdbe4b51e58934e03f1": "Ybodychange",
    "a0bde7d525911680f9e5fb0a939604865eb8e164": "Ybodychange",
    "e1f5251f3c0d6e74af1b52eda6633b728804fe2a": "Ybodychange",
    "0c559b27820d12ebe5c315c6e2d1685c6de6bd33": "Ybodychange",
    "d30d57828fddaa8667de49af879cde999907c7f6": "Ybodychange",
    "68acd88dcbfe03a0134c60b5398dfaa31ad2b786": "Ybodychange",
    "40ab068eabe50875449d601471619a4e82fff86d": "Ymultichange(Yfilerename,Ybodychange,Yrename,Yparameterchange)",
    "2191f5b533c6b4763f5d443d21127f1f8552ce64": "Ybodychange",
    "1888318c89776f0bf354c1b13e3ee169e14ff638": "Yfilerename",
    "59a9b4f4382e435b6e9eca928417bf66f70069a4": "Ymultichange(Yparameterchange,Ybodychange)",
    "e86d828548c17ebadc0e6d22b50151eebd9696d5": "Ybodychange",
    "a0574e7f4f5a6e53677ada4381db5504f263d70f": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "845764da146e98927e8ea5b2209f19f4fc3feda5": "Ymultichange(Yrename,Yparameterchange,Yexceptionschange,Ybodychange)",
    "c31cd981ebabc0747cabcc07a8c8797619ed2c53": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
    "ef5a3628c2428a1f8b0b17e1ff2aabe6820b63d5": "Ybodychange",
    "7da243ebe05be27ade86feac83a6243eebba619c": "Ybodychange",
    "c0120e51b944f86de4d533bcbc59f715047b9ea9": "Ybodychange",
    "18bf0dce28a9a602f67a0c28fe5c350065931bd0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9f15483c5d7c94251f4c84e0155449188f202779": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8445.  Improved error message for duplicated service and component names.\n            Contributed by Chandni Singh\n",
      "commitDate": "21/06/18 8:20 AM",
      "commitName": "9f15483c5d7c94251f4c84e0155449188f202779",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "12/06/18 8:35 AM",
      "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 8.99,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,145 @@\n   public static void validateAndResolveService(Service service,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n     if (dnsEnabled) {\n       if (RegistryUtils.currentUser().length()\n           \u003e RegistryConstants.MAX_FQDN_LABEL_LENGTH) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_USER_NAME_INVALID);\n       }\n       userNamePattern.validate(RegistryUtils.currentUser());\n     }\n \n     if (StringUtils.isEmpty(service.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n \n     if (StringUtils.isEmpty(service.getVersion())) {\n       throw new IllegalArgumentException(String.format(\n           RestApiErrorMessages.ERROR_APPLICATION_VERSION_INVALID,\n           service.getName()));\n     }\n \n     validateNameFormat(service.getName(), conf);\n \n     // If the service has no components, throw error\n     if (!hasComponent(service)) {\n       throw new IllegalArgumentException(\n           \"No component specified for \" + service.getName());\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       validateKerberosPrincipal(service.getKerberosPrincipal());\n     }\n \n     // Validate the Docker client config.\n     try {\n       validateDockerClientConfiguration(service, conf);\n     } catch (IOException e) {\n       throw new IllegalArgumentException(e);\n     }\n \n     // Validate there are no component name collisions (collisions are not\n     // currently supported) and add any components from external services\n     Configuration globalConf \u003d service.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n     for (Component comp : service.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n       maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n+      if (service.getName().equals(comp.getName())) {\n+        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n+                .ERROR_COMPONENT_NAME_CONFLICTS_WITH_SERVICE_NAME,\n+            comp.getName(), service.getName()));\n+      }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n       // If artifact is of type SERVICE (which cannot be filled from global),\n       // read external service and add its components to this service\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n           Artifact.TypeEnum.SERVICE) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n         List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n           Component override \u003d service.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n     service.getComponents().removeAll(componentsToRemove);\n     service.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n     Artifact globalArtifact \u003d service.getArtifact();\n     Resource globalResource \u003d service.getResource();\n     for (Component comp : service.getComponents()) {\n       // fill in global artifact unless it is type SERVICE\n       if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n           \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n           .SERVICE) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n       validateComponent(comp, fs.getFileSystem(), conf);\n     }\n     validatePlacementPolicy(service.getComponents(), componentNames);\n \n     // validate dependency tree\n     sortByDependencies(service.getComponents());\n \n     // Service lifetime if not specified, is set to unlimited lifetime\n     if (service.getLifetime() \u003d\u003d null) {\n       service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void validateAndResolveService(Service service,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled) {\n      if (RegistryUtils.currentUser().length()\n          \u003e RegistryConstants.MAX_FQDN_LABEL_LENGTH) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_USER_NAME_INVALID);\n      }\n      userNamePattern.validate(RegistryUtils.currentUser());\n    }\n\n    if (StringUtils.isEmpty(service.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n\n    if (StringUtils.isEmpty(service.getVersion())) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_VERSION_INVALID,\n          service.getName()));\n    }\n\n    validateNameFormat(service.getName(), conf);\n\n    // If the service has no components, throw error\n    if (!hasComponent(service)) {\n      throw new IllegalArgumentException(\n          \"No component specified for \" + service.getName());\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      validateKerberosPrincipal(service.getKerberosPrincipal());\n    }\n\n    // Validate the Docker client config.\n    try {\n      validateDockerClientConfiguration(service, conf);\n    } catch (IOException e) {\n      throw new IllegalArgumentException(e);\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external services\n    Configuration globalConf \u003d service.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : service.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (service.getName().equals(comp.getName())) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n                .ERROR_COMPONENT_NAME_CONFLICTS_WITH_SERVICE_NAME,\n            comp.getName(), service.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type SERVICE (which cannot be filled from global),\n      // read external service and add its components to this service\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d service.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    service.getComponents().removeAll(componentsToRemove);\n    service.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d service.getArtifact();\n    Resource globalResource \u003d service.getResource();\n    for (Component comp : service.getComponents()) {\n      // fill in global artifact unless it is type SERVICE\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .SERVICE) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem(), conf);\n    }\n    validatePlacementPolicy(service.getComponents(), componentNames);\n\n    // validate dependency tree\n    sortByDependencies(service.getComponents());\n\n    // Service lifetime if not specified, is set to unlimited lifetime\n    if (service.getLifetime() \u003d\u003d null) {\n      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
      "extendedDetails": {}
    },
    "58b97c79e34901938d59acc84ed48c1f9344996a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8236. Invalid kerberos principal file name cause NPE in native service. Contributed by Gour Saha.\n",
      "commitDate": "14/05/18 11:47 PM",
      "commitName": "58b97c79e34901938d59acc84ed48c1f9344996a",
      "commitAuthor": "Sunil G",
      "commitDateOld": "27/04/18 6:10 AM",
      "commitNameOld": "914d6b5cb143f4f9cadd9d689ea4e278383a6779",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 17.73,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,140 @@\n   public static void validateAndResolveService(Service service,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n     if (dnsEnabled) {\n       if (RegistryUtils.currentUser().length()\n           \u003e RegistryConstants.MAX_FQDN_LABEL_LENGTH) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_USER_NAME_INVALID);\n       }\n       userNamePattern.validate(RegistryUtils.currentUser());\n     }\n \n     if (StringUtils.isEmpty(service.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n \n     if (StringUtils.isEmpty(service.getVersion())) {\n       throw new IllegalArgumentException(String.format(\n           RestApiErrorMessages.ERROR_APPLICATION_VERSION_INVALID,\n           service.getName()));\n     }\n \n     validateNameFormat(service.getName(), conf);\n \n     // If the service has no components, throw error\n     if (!hasComponent(service)) {\n       throw new IllegalArgumentException(\n           \"No component specified for \" + service.getName());\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n-      if (!StringUtils.isEmpty(service.getKerberosPrincipal().getKeytab())) {\n-        try {\n-          // validate URI format\n-          new URI(service.getKerberosPrincipal().getKeytab());\n-        } catch (URISyntaxException e) {\n-          throw new IllegalArgumentException(e);\n-        }\n-      }\n+      validateKerberosPrincipal(service.getKerberosPrincipal());\n     }\n \n     // Validate the Docker client config.\n     try {\n       validateDockerClientConfiguration(service, conf);\n     } catch (IOException e) {\n       throw new IllegalArgumentException(e);\n     }\n \n     // Validate there are no component name collisions (collisions are not\n     // currently supported) and add any components from external services\n     Configuration globalConf \u003d service.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n     for (Component comp : service.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n       maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n-      // If artifact is of type SERVICE (which cannot be filled from\n-      // global), read external service and add its components to this\n-      // service\n+      // If artifact is of type SERVICE (which cannot be filled from global),\n+      // read external service and add its components to this service\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n           Artifact.TypeEnum.SERVICE) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n         List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n           Component override \u003d service.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n     service.getComponents().removeAll(componentsToRemove);\n     service.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n     Artifact globalArtifact \u003d service.getArtifact();\n     Resource globalResource \u003d service.getResource();\n     for (Component comp : service.getComponents()) {\n       // fill in global artifact unless it is type SERVICE\n       if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n           \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n           .SERVICE) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n       validateComponent(comp, fs.getFileSystem(), conf);\n     }\n     validatePlacementPolicy(service.getComponents(), componentNames);\n \n     // validate dependency tree\n     sortByDependencies(service.getComponents());\n \n     // Service lifetime if not specified, is set to unlimited lifetime\n     if (service.getLifetime() \u003d\u003d null) {\n       service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void validateAndResolveService(Service service,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled) {\n      if (RegistryUtils.currentUser().length()\n          \u003e RegistryConstants.MAX_FQDN_LABEL_LENGTH) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_USER_NAME_INVALID);\n      }\n      userNamePattern.validate(RegistryUtils.currentUser());\n    }\n\n    if (StringUtils.isEmpty(service.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n\n    if (StringUtils.isEmpty(service.getVersion())) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_VERSION_INVALID,\n          service.getName()));\n    }\n\n    validateNameFormat(service.getName(), conf);\n\n    // If the service has no components, throw error\n    if (!hasComponent(service)) {\n      throw new IllegalArgumentException(\n          \"No component specified for \" + service.getName());\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      validateKerberosPrincipal(service.getKerberosPrincipal());\n    }\n\n    // Validate the Docker client config.\n    try {\n      validateDockerClientConfiguration(service, conf);\n    } catch (IOException e) {\n      throw new IllegalArgumentException(e);\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external services\n    Configuration globalConf \u003d service.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : service.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type SERVICE (which cannot be filled from global),\n      // read external service and add its components to this service\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d service.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    service.getComponents().removeAll(componentsToRemove);\n    service.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d service.getArtifact();\n    Resource globalResource \u003d service.getResource();\n    for (Component comp : service.getComponents()) {\n      // fill in global artifact unless it is type SERVICE\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .SERVICE) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem(), conf);\n    }\n    validatePlacementPolicy(service.getComponents(), componentNames);\n\n    // validate dependency tree\n    sortByDependencies(service.getComponents());\n\n    // Service lifetime if not specified, is set to unlimited lifetime\n    if (service.getLifetime() \u003d\u003d null) {\n      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
      "extendedDetails": {}
    },
    "1d6e43da51aaaab522325bdbe4b51e58934e03f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7996. Allow user supplied Docker client configurations with YARN native services. Contributed by Shane Kumpf\n",
      "commitDate": "17/04/18 6:57 AM",
      "commitName": "1d6e43da51aaaab522325bdbe4b51e58934e03f1",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "02/04/18 7:26 AM",
      "commitNameOld": "a0bde7d525911680f9e5fb0a939604865eb8e164",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 14.98,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,148 @@\n   public static void validateAndResolveService(Service service,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n     if (dnsEnabled) {\n       if (RegistryUtils.currentUser().length()\n           \u003e RegistryConstants.MAX_FQDN_LABEL_LENGTH) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_USER_NAME_INVALID);\n       }\n       userNamePattern.validate(RegistryUtils.currentUser());\n     }\n \n     if (StringUtils.isEmpty(service.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n \n     if (StringUtils.isEmpty(service.getVersion())) {\n       throw new IllegalArgumentException(String.format(\n           RestApiErrorMessages.ERROR_APPLICATION_VERSION_INVALID,\n           service.getName()));\n     }\n \n     validateNameFormat(service.getName(), conf);\n \n     // If the service has no components, throw error\n     if (!hasComponent(service)) {\n       throw new IllegalArgumentException(\n           \"No component specified for \" + service.getName());\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       if (!StringUtils.isEmpty(service.getKerberosPrincipal().getKeytab())) {\n         try {\n           // validate URI format\n           new URI(service.getKerberosPrincipal().getKeytab());\n         } catch (URISyntaxException e) {\n           throw new IllegalArgumentException(e);\n         }\n       }\n     }\n \n+    // Validate the Docker client config.\n+    try {\n+      validateDockerClientConfiguration(service, conf);\n+    } catch (IOException e) {\n+      throw new IllegalArgumentException(e);\n+    }\n+\n     // Validate there are no component name collisions (collisions are not\n     // currently supported) and add any components from external services\n     Configuration globalConf \u003d service.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n     for (Component comp : service.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n       maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n       // If artifact is of type SERVICE (which cannot be filled from\n       // global), read external service and add its components to this\n       // service\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n           Artifact.TypeEnum.SERVICE) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n         List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n           Component override \u003d service.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n     service.getComponents().removeAll(componentsToRemove);\n     service.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n     Artifact globalArtifact \u003d service.getArtifact();\n     Resource globalResource \u003d service.getResource();\n     for (Component comp : service.getComponents()) {\n       // fill in global artifact unless it is type SERVICE\n       if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n           \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n           .SERVICE) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n       validateComponent(comp, fs.getFileSystem(), conf);\n     }\n     validatePlacementPolicy(service.getComponents(), componentNames);\n \n     // validate dependency tree\n     sortByDependencies(service.getComponents());\n \n     // Service lifetime if not specified, is set to unlimited lifetime\n     if (service.getLifetime() \u003d\u003d null) {\n       service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void validateAndResolveService(Service service,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled) {\n      if (RegistryUtils.currentUser().length()\n          \u003e RegistryConstants.MAX_FQDN_LABEL_LENGTH) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_USER_NAME_INVALID);\n      }\n      userNamePattern.validate(RegistryUtils.currentUser());\n    }\n\n    if (StringUtils.isEmpty(service.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n\n    if (StringUtils.isEmpty(service.getVersion())) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_VERSION_INVALID,\n          service.getName()));\n    }\n\n    validateNameFormat(service.getName(), conf);\n\n    // If the service has no components, throw error\n    if (!hasComponent(service)) {\n      throw new IllegalArgumentException(\n          \"No component specified for \" + service.getName());\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      if (!StringUtils.isEmpty(service.getKerberosPrincipal().getKeytab())) {\n        try {\n          // validate URI format\n          new URI(service.getKerberosPrincipal().getKeytab());\n        } catch (URISyntaxException e) {\n          throw new IllegalArgumentException(e);\n        }\n      }\n    }\n\n    // Validate the Docker client config.\n    try {\n      validateDockerClientConfiguration(service, conf);\n    } catch (IOException e) {\n      throw new IllegalArgumentException(e);\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external services\n    Configuration globalConf \u003d service.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : service.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type SERVICE (which cannot be filled from\n      // global), read external service and add its components to this\n      // service\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d service.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    service.getComponents().removeAll(componentsToRemove);\n    service.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d service.getArtifact();\n    Resource globalResource \u003d service.getResource();\n    for (Component comp : service.getComponents()) {\n      // fill in global artifact unless it is type SERVICE\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .SERVICE) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem(), conf);\n    }\n    validatePlacementPolicy(service.getComponents(), componentNames);\n\n    // validate dependency tree\n    sortByDependencies(service.getComponents());\n\n    // Service lifetime if not specified, is set to unlimited lifetime\n    if (service.getLifetime() \u003d\u003d null) {\n      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
      "extendedDetails": {}
    },
    "a0bde7d525911680f9e5fb0a939604865eb8e164": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7142. Support placement policy in yarn native services. (Gour Saha via wangda)\n\nChange-Id: I166c67a7a34430627c17365f60bac75b6da1b434\n",
      "commitDate": "02/04/18 7:26 AM",
      "commitName": "a0bde7d525911680f9e5fb0a939604865eb8e164",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/03/18 3:46 PM",
      "commitNameOld": "27d60a16342fd39973d43b61008f54a8815a6237",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 6.65,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,141 @@\n   public static void validateAndResolveService(Service service,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n     if (dnsEnabled) {\n       if (RegistryUtils.currentUser().length()\n           \u003e RegistryConstants.MAX_FQDN_LABEL_LENGTH) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_USER_NAME_INVALID);\n       }\n       userNamePattern.validate(RegistryUtils.currentUser());\n     }\n \n     if (StringUtils.isEmpty(service.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n \n     if (StringUtils.isEmpty(service.getVersion())) {\n       throw new IllegalArgumentException(String.format(\n           RestApiErrorMessages.ERROR_APPLICATION_VERSION_INVALID,\n           service.getName()));\n     }\n \n     validateNameFormat(service.getName(), conf);\n \n     // If the service has no components, throw error\n     if (!hasComponent(service)) {\n       throw new IllegalArgumentException(\n           \"No component specified for \" + service.getName());\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       if (!StringUtils.isEmpty(service.getKerberosPrincipal().getKeytab())) {\n         try {\n           // validate URI format\n           new URI(service.getKerberosPrincipal().getKeytab());\n         } catch (URISyntaxException e) {\n           throw new IllegalArgumentException(e);\n         }\n       }\n     }\n \n     // Validate there are no component name collisions (collisions are not\n     // currently supported) and add any components from external services\n     Configuration globalConf \u003d service.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n     for (Component comp : service.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n       maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n       // If artifact is of type SERVICE (which cannot be filled from\n       // global), read external service and add its components to this\n       // service\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n           Artifact.TypeEnum.SERVICE) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n         List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n           Component override \u003d service.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n     service.getComponents().removeAll(componentsToRemove);\n     service.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n     Artifact globalArtifact \u003d service.getArtifact();\n     Resource globalResource \u003d service.getResource();\n     for (Component comp : service.getComponents()) {\n       // fill in global artifact unless it is type SERVICE\n       if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n           \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n           .SERVICE) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n       validateComponent(comp, fs.getFileSystem(), conf);\n     }\n+    validatePlacementPolicy(service.getComponents(), componentNames);\n \n     // validate dependency tree\n     sortByDependencies(service.getComponents());\n \n     // Service lifetime if not specified, is set to unlimited lifetime\n     if (service.getLifetime() \u003d\u003d null) {\n       service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void validateAndResolveService(Service service,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled) {\n      if (RegistryUtils.currentUser().length()\n          \u003e RegistryConstants.MAX_FQDN_LABEL_LENGTH) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_USER_NAME_INVALID);\n      }\n      userNamePattern.validate(RegistryUtils.currentUser());\n    }\n\n    if (StringUtils.isEmpty(service.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n\n    if (StringUtils.isEmpty(service.getVersion())) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_VERSION_INVALID,\n          service.getName()));\n    }\n\n    validateNameFormat(service.getName(), conf);\n\n    // If the service has no components, throw error\n    if (!hasComponent(service)) {\n      throw new IllegalArgumentException(\n          \"No component specified for \" + service.getName());\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      if (!StringUtils.isEmpty(service.getKerberosPrincipal().getKeytab())) {\n        try {\n          // validate URI format\n          new URI(service.getKerberosPrincipal().getKeytab());\n        } catch (URISyntaxException e) {\n          throw new IllegalArgumentException(e);\n        }\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external services\n    Configuration globalConf \u003d service.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : service.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type SERVICE (which cannot be filled from\n      // global), read external service and add its components to this\n      // service\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d service.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    service.getComponents().removeAll(componentsToRemove);\n    service.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d service.getArtifact();\n    Resource globalResource \u003d service.getResource();\n    for (Component comp : service.getComponents()) {\n      // fill in global artifact unless it is type SERVICE\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .SERVICE) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem(), conf);\n    }\n    validatePlacementPolicy(service.getComponents(), componentNames);\n\n    // validate dependency tree\n    sortByDependencies(service.getComponents());\n\n    // Service lifetime if not specified, is set to unlimited lifetime\n    if (service.getLifetime() \u003d\u003d null) {\n      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
      "extendedDetails": {}
    },
    "e1f5251f3c0d6e74af1b52eda6633b728804fe2a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7523. Introduce description and version field in Service record. Contributed by Chandni Singh\n",
      "commitDate": "10/03/18 7:49 AM",
      "commitName": "e1f5251f3c0d6e74af1b52eda6633b728804fe2a",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "24/01/18 1:50 PM",
      "commitNameOld": "0c559b27820d12ebe5c315c6e2d1685c6de6bd33",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 44.75,
      "commitsBetweenForRepo": 309,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,140 @@\n   public static void validateAndResolveService(Service service,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n     if (dnsEnabled) {\n       if (RegistryUtils.currentUser().length()\n           \u003e RegistryConstants.MAX_FQDN_LABEL_LENGTH) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_USER_NAME_INVALID);\n       }\n       userNamePattern.validate(RegistryUtils.currentUser());\n     }\n \n     if (StringUtils.isEmpty(service.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n \n+    if (StringUtils.isEmpty(service.getVersion())) {\n+      throw new IllegalArgumentException(String.format(\n+          RestApiErrorMessages.ERROR_APPLICATION_VERSION_INVALID,\n+          service.getName()));\n+    }\n+\n     validateNameFormat(service.getName(), conf);\n \n     // If the service has no components, throw error\n     if (!hasComponent(service)) {\n       throw new IllegalArgumentException(\n           \"No component specified for \" + service.getName());\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       if (!StringUtils.isEmpty(service.getKerberosPrincipal().getKeytab())) {\n         try {\n           // validate URI format\n           new URI(service.getKerberosPrincipal().getKeytab());\n         } catch (URISyntaxException e) {\n           throw new IllegalArgumentException(e);\n         }\n       }\n     }\n \n     // Validate there are no component name collisions (collisions are not\n     // currently supported) and add any components from external services\n     Configuration globalConf \u003d service.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n     for (Component comp : service.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n       maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n       // If artifact is of type SERVICE (which cannot be filled from\n       // global), read external service and add its components to this\n       // service\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n           Artifact.TypeEnum.SERVICE) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n         List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n           Component override \u003d service.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n     service.getComponents().removeAll(componentsToRemove);\n     service.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n     Artifact globalArtifact \u003d service.getArtifact();\n     Resource globalResource \u003d service.getResource();\n     for (Component comp : service.getComponents()) {\n       // fill in global artifact unless it is type SERVICE\n       if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n           \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n           .SERVICE) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n       validateComponent(comp, fs.getFileSystem(), conf);\n     }\n \n     // validate dependency tree\n     sortByDependencies(service.getComponents());\n \n     // Service lifetime if not specified, is set to unlimited lifetime\n     if (service.getLifetime() \u003d\u003d null) {\n       service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void validateAndResolveService(Service service,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled) {\n      if (RegistryUtils.currentUser().length()\n          \u003e RegistryConstants.MAX_FQDN_LABEL_LENGTH) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_USER_NAME_INVALID);\n      }\n      userNamePattern.validate(RegistryUtils.currentUser());\n    }\n\n    if (StringUtils.isEmpty(service.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n\n    if (StringUtils.isEmpty(service.getVersion())) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_VERSION_INVALID,\n          service.getName()));\n    }\n\n    validateNameFormat(service.getName(), conf);\n\n    // If the service has no components, throw error\n    if (!hasComponent(service)) {\n      throw new IllegalArgumentException(\n          \"No component specified for \" + service.getName());\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      if (!StringUtils.isEmpty(service.getKerberosPrincipal().getKeytab())) {\n        try {\n          // validate URI format\n          new URI(service.getKerberosPrincipal().getKeytab());\n        } catch (URISyntaxException e) {\n          throw new IllegalArgumentException(e);\n        }\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external services\n    Configuration globalConf \u003d service.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : service.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type SERVICE (which cannot be filled from\n      // global), read external service and add its components to this\n      // service\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d service.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    service.getComponents().removeAll(componentsToRemove);\n    service.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d service.getArtifact();\n    Resource globalResource \u003d service.getResource();\n    for (Component comp : service.getComponents()) {\n      // fill in global artifact unless it is type SERVICE\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .SERVICE) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem(), conf);\n    }\n\n    // validate dependency tree\n    sortByDependencies(service.getComponents());\n\n    // Service lifetime if not specified, is set to unlimited lifetime\n    if (service.getLifetime() \u003d\u003d null) {\n      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
      "extendedDetails": {}
    },
    "0c559b27820d12ebe5c315c6e2d1685c6de6bd33": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7777. Fix user name format in YARN Registry DNS name. Contributed by Jian He\n",
      "commitDate": "24/01/18 1:50 PM",
      "commitName": "0c559b27820d12ebe5c315c6e2d1685c6de6bd33",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "19/12/17 1:45 PM",
      "commitNameOld": "989c75109a619deeaee7461864e7cb3c289c9421",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 36.0,
      "commitsBetweenForRepo": 146,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,134 @@\n   public static void validateAndResolveService(Service service,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n-    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n-        .MAX_FQDN_LABEL_LENGTH) {\n-      throw new IllegalArgumentException(RestApiErrorMessages\n-          .ERROR_USER_NAME_INVALID);\n+    if (dnsEnabled) {\n+      if (RegistryUtils.currentUser().length()\n+          \u003e RegistryConstants.MAX_FQDN_LABEL_LENGTH) {\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_USER_NAME_INVALID);\n+      }\n+      userNamePattern.validate(RegistryUtils.currentUser());\n     }\n+\n     if (StringUtils.isEmpty(service.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n \n     validateNameFormat(service.getName(), conf);\n \n     // If the service has no components, throw error\n     if (!hasComponent(service)) {\n       throw new IllegalArgumentException(\n           \"No component specified for \" + service.getName());\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       if (!StringUtils.isEmpty(service.getKerberosPrincipal().getKeytab())) {\n         try {\n           // validate URI format\n           new URI(service.getKerberosPrincipal().getKeytab());\n         } catch (URISyntaxException e) {\n           throw new IllegalArgumentException(e);\n         }\n       }\n     }\n \n     // Validate there are no component name collisions (collisions are not\n     // currently supported) and add any components from external services\n     Configuration globalConf \u003d service.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n     for (Component comp : service.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n       maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n       // If artifact is of type SERVICE (which cannot be filled from\n       // global), read external service and add its components to this\n       // service\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n           Artifact.TypeEnum.SERVICE) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n         List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n           Component override \u003d service.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n     service.getComponents().removeAll(componentsToRemove);\n     service.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n     Artifact globalArtifact \u003d service.getArtifact();\n     Resource globalResource \u003d service.getResource();\n     for (Component comp : service.getComponents()) {\n       // fill in global artifact unless it is type SERVICE\n       if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n           \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n           .SERVICE) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n       validateComponent(comp, fs.getFileSystem(), conf);\n     }\n \n     // validate dependency tree\n     sortByDependencies(service.getComponents());\n \n     // Service lifetime if not specified, is set to unlimited lifetime\n     if (service.getLifetime() \u003d\u003d null) {\n       service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void validateAndResolveService(Service service,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled) {\n      if (RegistryUtils.currentUser().length()\n          \u003e RegistryConstants.MAX_FQDN_LABEL_LENGTH) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_USER_NAME_INVALID);\n      }\n      userNamePattern.validate(RegistryUtils.currentUser());\n    }\n\n    if (StringUtils.isEmpty(service.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n\n    validateNameFormat(service.getName(), conf);\n\n    // If the service has no components, throw error\n    if (!hasComponent(service)) {\n      throw new IllegalArgumentException(\n          \"No component specified for \" + service.getName());\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      if (!StringUtils.isEmpty(service.getKerberosPrincipal().getKeytab())) {\n        try {\n          // validate URI format\n          new URI(service.getKerberosPrincipal().getKeytab());\n        } catch (URISyntaxException e) {\n          throw new IllegalArgumentException(e);\n        }\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external services\n    Configuration globalConf \u003d service.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : service.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type SERVICE (which cannot be filled from\n      // global), read external service and add its components to this\n      // service\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d service.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    service.getComponents().removeAll(componentsToRemove);\n    service.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d service.getArtifact();\n    Resource globalResource \u003d service.getResource();\n    for (Component comp : service.getComponents()) {\n      // fill in global artifact unless it is type SERVICE\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .SERVICE) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem(), conf);\n    }\n\n    // validate dependency tree\n    sortByDependencies(service.getComponents());\n\n    // Service lifetime if not specified, is set to unlimited lifetime\n    if (service.getLifetime() \u003d\u003d null) {\n      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
      "extendedDetails": {}
    },
    "d30d57828fddaa8667de49af879cde999907c7f6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6669.  Implemented Kerberos security for YARN service framework.  (Contributed by Jian He)\n",
      "commitDate": "04/12/17 12:11 PM",
      "commitName": "d30d57828fddaa8667de49af879cde999907c7f6",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "06/11/17 1:30 PM",
      "commitNameOld": "a127f7b0fbde3942ca4329d5463bb8fe421daf7b",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 27.94,
      "commitsBetweenForRepo": 135,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,130 @@\n   public static void validateAndResolveService(Service service,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n     if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n         .MAX_FQDN_LABEL_LENGTH) {\n       throw new IllegalArgumentException(RestApiErrorMessages\n           .ERROR_USER_NAME_INVALID);\n     }\n     if (StringUtils.isEmpty(service.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n \n     validateNameFormat(service.getName(), conf);\n \n     // If the service has no components, throw error\n     if (!hasComponent(service)) {\n       throw new IllegalArgumentException(\n           \"No component specified for \" + service.getName());\n     }\n \n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      if (!StringUtils.isEmpty(service.getKerberosPrincipal().getKeytab())) {\n+        try {\n+          // validate URI format\n+          new URI(service.getKerberosPrincipal().getKeytab());\n+        } catch (URISyntaxException e) {\n+          throw new IllegalArgumentException(e);\n+        }\n+      }\n+    }\n+\n     // Validate there are no component name collisions (collisions are not\n     // currently supported) and add any components from external services\n     Configuration globalConf \u003d service.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n     for (Component comp : service.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n       maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n       // If artifact is of type SERVICE (which cannot be filled from\n       // global), read external service and add its components to this\n       // service\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n           Artifact.TypeEnum.SERVICE) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n         List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n           Component override \u003d service.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n     service.getComponents().removeAll(componentsToRemove);\n     service.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n     Artifact globalArtifact \u003d service.getArtifact();\n     Resource globalResource \u003d service.getResource();\n     for (Component comp : service.getComponents()) {\n       // fill in global artifact unless it is type SERVICE\n       if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n           \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n           .SERVICE) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n       validateComponent(comp, fs.getFileSystem(), conf);\n     }\n \n     // validate dependency tree\n     sortByDependencies(service.getComponents());\n \n     // Service lifetime if not specified, is set to unlimited lifetime\n     if (service.getLifetime() \u003d\u003d null) {\n       service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void validateAndResolveService(Service service,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH) {\n      throw new IllegalArgumentException(RestApiErrorMessages\n          .ERROR_USER_NAME_INVALID);\n    }\n    if (StringUtils.isEmpty(service.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n\n    validateNameFormat(service.getName(), conf);\n\n    // If the service has no components, throw error\n    if (!hasComponent(service)) {\n      throw new IllegalArgumentException(\n          \"No component specified for \" + service.getName());\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      if (!StringUtils.isEmpty(service.getKerberosPrincipal().getKeytab())) {\n        try {\n          // validate URI format\n          new URI(service.getKerberosPrincipal().getKeytab());\n        } catch (URISyntaxException e) {\n          throw new IllegalArgumentException(e);\n        }\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external services\n    Configuration globalConf \u003d service.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : service.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type SERVICE (which cannot be filled from\n      // global), read external service and add its components to this\n      // service\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d service.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    service.getComponents().removeAll(componentsToRemove);\n    service.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d service.getArtifact();\n    Resource globalResource \u003d service.getResource();\n    for (Component comp : service.getComponents()) {\n      // fill in global artifact unless it is type SERVICE\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .SERVICE) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem(), conf);\n    }\n\n    // validate dependency tree\n    sortByDependencies(service.getComponents());\n\n    // Service lifetime if not specified, is set to unlimited lifetime\n    if (service.getLifetime() \u003d\u003d null) {\n      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
      "extendedDetails": {}
    },
    "68acd88dcbfe03a0134c60b5398dfaa31ad2b786": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7323. Data structure update in service REST API. Contributed by Jian He\n",
      "commitDate": "06/11/17 1:30 PM",
      "commitName": "68acd88dcbfe03a0134c60b5398dfaa31ad2b786",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "06/11/17 1:30 PM",
      "commitNameOld": "40ab068eabe50875449d601471619a4e82fff86d",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,153 +1,119 @@\n   public static void validateAndResolveService(Service service,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n     if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n         .MAX_FQDN_LABEL_LENGTH) {\n       throw new IllegalArgumentException(RestApiErrorMessages\n           .ERROR_USER_NAME_INVALID);\n     }\n     if (StringUtils.isEmpty(service.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n \n     validateNameFormat(service.getName(), conf);\n \n-    // If the service has no components do top-level checks\n+    // If the service has no components, throw error\n     if (!hasComponent(service)) {\n-      // If artifact is of type SERVICE, read other service components\n-      if (service.getArtifact() !\u003d null \u0026\u0026 service.getArtifact()\n-          .getType() \u003d\u003d Artifact.TypeEnum.SERVICE) {\n-        if (StringUtils.isEmpty(service.getArtifact().getId())) {\n-          throw new IllegalArgumentException(\n-              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n-        }\n-        Service otherService \u003d loadService(fs,\n-            service.getArtifact().getId());\n-        service.setComponents(otherService.getComponents());\n-        service.setArtifact(null);\n-        SliderUtils.mergeMapsIgnoreDuplicateKeys(service.getQuicklinks(),\n-            otherService.getQuicklinks());\n-      } else {\n-        // Since it is a simple service with no components, create a default\n-        // component\n-        Component comp \u003d createDefaultComponent(service);\n-        validateComponent(comp, fs.getFileSystem(), conf);\n-        service.getComponents().add(comp);\n-        if (service.getLifetime() \u003d\u003d null) {\n-          service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n-        }\n-        return;\n-      }\n+      throw new IllegalArgumentException(\n+          \"No component specified for \" + service.getName());\n     }\n \n     // Validate there are no component name collisions (collisions are not\n     // currently supported) and add any components from external services\n-    // TODO allow name collisions? see AppState#roles\n-    // TODO or add prefix to external component names?\n     Configuration globalConf \u003d service.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n     for (Component comp : service.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n       maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n       // If artifact is of type SERVICE (which cannot be filled from\n       // global), read external service and add its components to this\n       // service\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n           Artifact.TypeEnum.SERVICE) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n         List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n           Component override \u003d service.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n     service.getComponents().removeAll(componentsToRemove);\n     service.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n     Artifact globalArtifact \u003d service.getArtifact();\n     Resource globalResource \u003d service.getResource();\n-    Long globalNumberOfContainers \u003d service.getNumberOfContainers();\n-    String globalLaunchCommand \u003d service.getLaunchCommand();\n     for (Component comp : service.getComponents()) {\n       // fill in global artifact unless it is type SERVICE\n       if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n           \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n           .SERVICE) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n-      // fill in global container count\n-      if (comp.getNumberOfContainers() \u003d\u003d null) {\n-        comp.setNumberOfContainers(globalNumberOfContainers);\n-      }\n-      // fill in global launch command\n-      if (comp.getLaunchCommand() \u003d\u003d null) {\n-        comp.setLaunchCommand(globalLaunchCommand);\n-      }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n       validateComponent(comp, fs.getFileSystem(), conf);\n     }\n \n     // validate dependency tree\n     sortByDependencies(service.getComponents());\n \n     // Service lifetime if not specified, is set to unlimited lifetime\n     if (service.getLifetime() \u003d\u003d null) {\n       service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void validateAndResolveService(Service service,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH) {\n      throw new IllegalArgumentException(RestApiErrorMessages\n          .ERROR_USER_NAME_INVALID);\n    }\n    if (StringUtils.isEmpty(service.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n\n    validateNameFormat(service.getName(), conf);\n\n    // If the service has no components, throw error\n    if (!hasComponent(service)) {\n      throw new IllegalArgumentException(\n          \"No component specified for \" + service.getName());\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external services\n    Configuration globalConf \u003d service.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : service.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type SERVICE (which cannot be filled from\n      // global), read external service and add its components to this\n      // service\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d service.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    service.getComponents().removeAll(componentsToRemove);\n    service.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d service.getArtifact();\n    Resource globalResource \u003d service.getResource();\n    for (Component comp : service.getComponents()) {\n      // fill in global artifact unless it is type SERVICE\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .SERVICE) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem(), conf);\n    }\n\n    // validate dependency tree\n    sortByDependencies(service.getComponents());\n\n    // Service lifetime if not specified, is set to unlimited lifetime\n    if (service.getLifetime() \u003d\u003d null) {\n      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
      "extendedDetails": {}
    },
    "40ab068eabe50875449d601471619a4e82fff86d": {
      "type": "Ymultichange(Yfilerename,Ybodychange,Yrename,Yparameterchange)",
      "commitMessage": "YARN-7091. Rename application to service in yarn-native-services. Contributed by Jian He\n",
      "commitDate": "06/11/17 1:30 PM",
      "commitName": "40ab068eabe50875449d601471619a4e82fff86d",
      "commitAuthor": "Billie Rinaldi",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "YARN-7091. Rename application to service in yarn-native-services. Contributed by Jian He\n",
          "commitDate": "06/11/17 1:30 PM",
          "commitName": "40ab068eabe50875449d601471619a4e82fff86d",
          "commitAuthor": "Billie Rinaldi",
          "commitDateOld": "06/11/17 1:30 PM",
          "commitNameOld": "2ba38ce8ecb1cf3836fab48cdb2c5ae7e1b5427d",
          "commitAuthorOld": "Gour Saha",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,158 +1,153 @@\n-  public static void validateAndResolveApplication(Application application,\n+  public static void validateAndResolveService(Service service,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n     if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n         .MAX_FQDN_LABEL_LENGTH) {\n       throw new IllegalArgumentException(RestApiErrorMessages\n           .ERROR_USER_NAME_INVALID);\n     }\n-    if (StringUtils.isEmpty(application.getName())) {\n+    if (StringUtils.isEmpty(service.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n-    if (!SliderUtils.isClusternameValid(application.getName()) || (dnsEnabled\n-        \u0026\u0026 application.getName().length() \u003e RegistryConstants\n-        .MAX_FQDN_LABEL_LENGTH)) {\n-      throw new IllegalArgumentException(String.format(\n-          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n-          application.getName()));\n-    }\n \n-    // If the application has no components do top-level checks\n-    if (!hasComponent(application)) {\n-      // If artifact is of type APPLICATION, read other application components\n-      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n-          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n-        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n+    validateNameFormat(service.getName(), conf);\n+\n+    // If the service has no components do top-level checks\n+    if (!hasComponent(service)) {\n+      // If artifact is of type SERVICE, read other service components\n+      if (service.getArtifact() !\u003d null \u0026\u0026 service.getArtifact()\n+          .getType() \u003d\u003d Artifact.TypeEnum.SERVICE) {\n+        if (StringUtils.isEmpty(service.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n-        Application otherApplication \u003d loadApplication(fs,\n-            application.getArtifact().getId());\n-        application.setComponents(otherApplication.getComponents());\n-        application.setArtifact(null);\n-        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n-            otherApplication.getQuicklinks());\n+        Service otherService \u003d loadService(fs,\n+            service.getArtifact().getId());\n+        service.setComponents(otherService.getComponents());\n+        service.setArtifact(null);\n+        SliderUtils.mergeMapsIgnoreDuplicateKeys(service.getQuicklinks(),\n+            otherService.getQuicklinks());\n       } else {\n-        // Since it is a simple app with no components, create a default\n+        // Since it is a simple service with no components, create a default\n         // component\n-        Component comp \u003d createDefaultComponent(application);\n-        validateComponent(comp, fs.getFileSystem());\n-        application.getComponents().add(comp);\n-        if (application.getLifetime() \u003d\u003d null) {\n-          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n+        Component comp \u003d createDefaultComponent(service);\n+        validateComponent(comp, fs.getFileSystem(), conf);\n+        service.getComponents().add(comp);\n+        if (service.getLifetime() \u003d\u003d null) {\n+          service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n         }\n         return;\n       }\n     }\n \n     // Validate there are no component name collisions (collisions are not\n-    // currently supported) and add any components from external applications\n+    // currently supported) and add any components from external services\n     // TODO allow name collisions? see AppState#roles\n     // TODO or add prefix to external component names?\n-    Configuration globalConf \u003d application.getConfiguration();\n+    Configuration globalConf \u003d service.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n-    for (Component comp : application.getComponents()) {\n+    for (Component comp : service.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n       maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n-      // If artifact is of type APPLICATION (which cannot be filled from\n-      // global), read external application and add its components to this\n-      // application\n+      // If artifact is of type SERVICE (which cannot be filled from\n+      // global), read external service and add its components to this\n+      // service\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n-          Artifact.TypeEnum.APPLICATION) {\n+          Artifact.TypeEnum.SERVICE) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n-        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n+        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n-          Component override \u003d application.getComponent(c.getName());\n+          Component override \u003d service.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n-    application.getComponents().removeAll(componentsToRemove);\n-    application.getComponents().addAll(componentsToAdd);\n+    service.getComponents().removeAll(componentsToRemove);\n+    service.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n-    Artifact globalArtifact \u003d application.getArtifact();\n-    Resource globalResource \u003d application.getResource();\n-    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n-    String globalLaunchCommand \u003d application.getLaunchCommand();\n-    for (Component comp : application.getComponents()) {\n-      // fill in global artifact unless it is type APPLICATION\n-      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n-          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n-          .APPLICATION) {\n+    Artifact globalArtifact \u003d service.getArtifact();\n+    Resource globalResource \u003d service.getResource();\n+    Long globalNumberOfContainers \u003d service.getNumberOfContainers();\n+    String globalLaunchCommand \u003d service.getLaunchCommand();\n+    for (Component comp : service.getComponents()) {\n+      // fill in global artifact unless it is type SERVICE\n+      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n+          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n+          .SERVICE) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // fill in global container count\n       if (comp.getNumberOfContainers() \u003d\u003d null) {\n         comp.setNumberOfContainers(globalNumberOfContainers);\n       }\n       // fill in global launch command\n       if (comp.getLaunchCommand() \u003d\u003d null) {\n         comp.setLaunchCommand(globalLaunchCommand);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n-      validateComponent(comp, fs.getFileSystem());\n+      validateComponent(comp, fs.getFileSystem(), conf);\n     }\n \n     // validate dependency tree\n-    sortByDependencies(application.getComponents());\n+    sortByDependencies(service.getComponents());\n \n-    // Application lifetime if not specified, is set to unlimited lifetime\n-    if (application.getLifetime() \u003d\u003d null) {\n-      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n+    // Service lifetime if not specified, is set to unlimited lifetime\n+    if (service.getLifetime() \u003d\u003d null) {\n+      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateAndResolveService(Service service,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH) {\n      throw new IllegalArgumentException(RestApiErrorMessages\n          .ERROR_USER_NAME_INVALID);\n    }\n    if (StringUtils.isEmpty(service.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n\n    validateNameFormat(service.getName(), conf);\n\n    // If the service has no components do top-level checks\n    if (!hasComponent(service)) {\n      // If artifact is of type SERVICE, read other service components\n      if (service.getArtifact() !\u003d null \u0026\u0026 service.getArtifact()\n          .getType() \u003d\u003d Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(service.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        Service otherService \u003d loadService(fs,\n            service.getArtifact().getId());\n        service.setComponents(otherService.getComponents());\n        service.setArtifact(null);\n        SliderUtils.mergeMapsIgnoreDuplicateKeys(service.getQuicklinks(),\n            otherService.getQuicklinks());\n      } else {\n        // Since it is a simple service with no components, create a default\n        // component\n        Component comp \u003d createDefaultComponent(service);\n        validateComponent(comp, fs.getFileSystem(), conf);\n        service.getComponents().add(comp);\n        if (service.getLifetime() \u003d\u003d null) {\n          service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n        }\n        return;\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external services\n    // TODO allow name collisions? see AppState#roles\n    // TODO or add prefix to external component names?\n    Configuration globalConf \u003d service.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : service.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type SERVICE (which cannot be filled from\n      // global), read external service and add its components to this\n      // service\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d service.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    service.getComponents().removeAll(componentsToRemove);\n    service.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d service.getArtifact();\n    Resource globalResource \u003d service.getResource();\n    Long globalNumberOfContainers \u003d service.getNumberOfContainers();\n    String globalLaunchCommand \u003d service.getLaunchCommand();\n    for (Component comp : service.getComponents()) {\n      // fill in global artifact unless it is type SERVICE\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .SERVICE) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // fill in global container count\n      if (comp.getNumberOfContainers() \u003d\u003d null) {\n        comp.setNumberOfContainers(globalNumberOfContainers);\n      }\n      // fill in global launch command\n      if (comp.getLaunchCommand() \u003d\u003d null) {\n        comp.setLaunchCommand(globalLaunchCommand);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem(), conf);\n    }\n\n    // validate dependency tree\n    sortByDependencies(service.getComponents());\n\n    // Service lifetime if not specified, is set to unlimited lifetime\n    if (service.getLifetime() \u003d\u003d null) {\n      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7091. Rename application to service in yarn-native-services. Contributed by Jian He\n",
          "commitDate": "06/11/17 1:30 PM",
          "commitName": "40ab068eabe50875449d601471619a4e82fff86d",
          "commitAuthor": "Billie Rinaldi",
          "commitDateOld": "06/11/17 1:30 PM",
          "commitNameOld": "2ba38ce8ecb1cf3836fab48cdb2c5ae7e1b5427d",
          "commitAuthorOld": "Gour Saha",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,158 +1,153 @@\n-  public static void validateAndResolveApplication(Application application,\n+  public static void validateAndResolveService(Service service,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n     if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n         .MAX_FQDN_LABEL_LENGTH) {\n       throw new IllegalArgumentException(RestApiErrorMessages\n           .ERROR_USER_NAME_INVALID);\n     }\n-    if (StringUtils.isEmpty(application.getName())) {\n+    if (StringUtils.isEmpty(service.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n-    if (!SliderUtils.isClusternameValid(application.getName()) || (dnsEnabled\n-        \u0026\u0026 application.getName().length() \u003e RegistryConstants\n-        .MAX_FQDN_LABEL_LENGTH)) {\n-      throw new IllegalArgumentException(String.format(\n-          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n-          application.getName()));\n-    }\n \n-    // If the application has no components do top-level checks\n-    if (!hasComponent(application)) {\n-      // If artifact is of type APPLICATION, read other application components\n-      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n-          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n-        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n+    validateNameFormat(service.getName(), conf);\n+\n+    // If the service has no components do top-level checks\n+    if (!hasComponent(service)) {\n+      // If artifact is of type SERVICE, read other service components\n+      if (service.getArtifact() !\u003d null \u0026\u0026 service.getArtifact()\n+          .getType() \u003d\u003d Artifact.TypeEnum.SERVICE) {\n+        if (StringUtils.isEmpty(service.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n-        Application otherApplication \u003d loadApplication(fs,\n-            application.getArtifact().getId());\n-        application.setComponents(otherApplication.getComponents());\n-        application.setArtifact(null);\n-        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n-            otherApplication.getQuicklinks());\n+        Service otherService \u003d loadService(fs,\n+            service.getArtifact().getId());\n+        service.setComponents(otherService.getComponents());\n+        service.setArtifact(null);\n+        SliderUtils.mergeMapsIgnoreDuplicateKeys(service.getQuicklinks(),\n+            otherService.getQuicklinks());\n       } else {\n-        // Since it is a simple app with no components, create a default\n+        // Since it is a simple service with no components, create a default\n         // component\n-        Component comp \u003d createDefaultComponent(application);\n-        validateComponent(comp, fs.getFileSystem());\n-        application.getComponents().add(comp);\n-        if (application.getLifetime() \u003d\u003d null) {\n-          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n+        Component comp \u003d createDefaultComponent(service);\n+        validateComponent(comp, fs.getFileSystem(), conf);\n+        service.getComponents().add(comp);\n+        if (service.getLifetime() \u003d\u003d null) {\n+          service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n         }\n         return;\n       }\n     }\n \n     // Validate there are no component name collisions (collisions are not\n-    // currently supported) and add any components from external applications\n+    // currently supported) and add any components from external services\n     // TODO allow name collisions? see AppState#roles\n     // TODO or add prefix to external component names?\n-    Configuration globalConf \u003d application.getConfiguration();\n+    Configuration globalConf \u003d service.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n-    for (Component comp : application.getComponents()) {\n+    for (Component comp : service.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n       maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n-      // If artifact is of type APPLICATION (which cannot be filled from\n-      // global), read external application and add its components to this\n-      // application\n+      // If artifact is of type SERVICE (which cannot be filled from\n+      // global), read external service and add its components to this\n+      // service\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n-          Artifact.TypeEnum.APPLICATION) {\n+          Artifact.TypeEnum.SERVICE) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n-        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n+        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n-          Component override \u003d application.getComponent(c.getName());\n+          Component override \u003d service.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n-    application.getComponents().removeAll(componentsToRemove);\n-    application.getComponents().addAll(componentsToAdd);\n+    service.getComponents().removeAll(componentsToRemove);\n+    service.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n-    Artifact globalArtifact \u003d application.getArtifact();\n-    Resource globalResource \u003d application.getResource();\n-    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n-    String globalLaunchCommand \u003d application.getLaunchCommand();\n-    for (Component comp : application.getComponents()) {\n-      // fill in global artifact unless it is type APPLICATION\n-      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n-          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n-          .APPLICATION) {\n+    Artifact globalArtifact \u003d service.getArtifact();\n+    Resource globalResource \u003d service.getResource();\n+    Long globalNumberOfContainers \u003d service.getNumberOfContainers();\n+    String globalLaunchCommand \u003d service.getLaunchCommand();\n+    for (Component comp : service.getComponents()) {\n+      // fill in global artifact unless it is type SERVICE\n+      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n+          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n+          .SERVICE) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // fill in global container count\n       if (comp.getNumberOfContainers() \u003d\u003d null) {\n         comp.setNumberOfContainers(globalNumberOfContainers);\n       }\n       // fill in global launch command\n       if (comp.getLaunchCommand() \u003d\u003d null) {\n         comp.setLaunchCommand(globalLaunchCommand);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n-      validateComponent(comp, fs.getFileSystem());\n+      validateComponent(comp, fs.getFileSystem(), conf);\n     }\n \n     // validate dependency tree\n-    sortByDependencies(application.getComponents());\n+    sortByDependencies(service.getComponents());\n \n-    // Application lifetime if not specified, is set to unlimited lifetime\n-    if (application.getLifetime() \u003d\u003d null) {\n-      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n+    // Service lifetime if not specified, is set to unlimited lifetime\n+    if (service.getLifetime() \u003d\u003d null) {\n+      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateAndResolveService(Service service,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH) {\n      throw new IllegalArgumentException(RestApiErrorMessages\n          .ERROR_USER_NAME_INVALID);\n    }\n    if (StringUtils.isEmpty(service.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n\n    validateNameFormat(service.getName(), conf);\n\n    // If the service has no components do top-level checks\n    if (!hasComponent(service)) {\n      // If artifact is of type SERVICE, read other service components\n      if (service.getArtifact() !\u003d null \u0026\u0026 service.getArtifact()\n          .getType() \u003d\u003d Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(service.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        Service otherService \u003d loadService(fs,\n            service.getArtifact().getId());\n        service.setComponents(otherService.getComponents());\n        service.setArtifact(null);\n        SliderUtils.mergeMapsIgnoreDuplicateKeys(service.getQuicklinks(),\n            otherService.getQuicklinks());\n      } else {\n        // Since it is a simple service with no components, create a default\n        // component\n        Component comp \u003d createDefaultComponent(service);\n        validateComponent(comp, fs.getFileSystem(), conf);\n        service.getComponents().add(comp);\n        if (service.getLifetime() \u003d\u003d null) {\n          service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n        }\n        return;\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external services\n    // TODO allow name collisions? see AppState#roles\n    // TODO or add prefix to external component names?\n    Configuration globalConf \u003d service.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : service.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type SERVICE (which cannot be filled from\n      // global), read external service and add its components to this\n      // service\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d service.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    service.getComponents().removeAll(componentsToRemove);\n    service.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d service.getArtifact();\n    Resource globalResource \u003d service.getResource();\n    Long globalNumberOfContainers \u003d service.getNumberOfContainers();\n    String globalLaunchCommand \u003d service.getLaunchCommand();\n    for (Component comp : service.getComponents()) {\n      // fill in global artifact unless it is type SERVICE\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .SERVICE) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // fill in global container count\n      if (comp.getNumberOfContainers() \u003d\u003d null) {\n        comp.setNumberOfContainers(globalNumberOfContainers);\n      }\n      // fill in global launch command\n      if (comp.getLaunchCommand() \u003d\u003d null) {\n        comp.setLaunchCommand(globalLaunchCommand);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem(), conf);\n    }\n\n    // validate dependency tree\n    sortByDependencies(service.getComponents());\n\n    // Service lifetime if not specified, is set to unlimited lifetime\n    if (service.getLifetime() \u003d\u003d null) {\n      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
          "extendedDetails": {}
        },
        {
          "type": "Yrename",
          "commitMessage": "YARN-7091. Rename application to service in yarn-native-services. Contributed by Jian He\n",
          "commitDate": "06/11/17 1:30 PM",
          "commitName": "40ab068eabe50875449d601471619a4e82fff86d",
          "commitAuthor": "Billie Rinaldi",
          "commitDateOld": "06/11/17 1:30 PM",
          "commitNameOld": "2ba38ce8ecb1cf3836fab48cdb2c5ae7e1b5427d",
          "commitAuthorOld": "Gour Saha",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,158 +1,153 @@\n-  public static void validateAndResolveApplication(Application application,\n+  public static void validateAndResolveService(Service service,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n     if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n         .MAX_FQDN_LABEL_LENGTH) {\n       throw new IllegalArgumentException(RestApiErrorMessages\n           .ERROR_USER_NAME_INVALID);\n     }\n-    if (StringUtils.isEmpty(application.getName())) {\n+    if (StringUtils.isEmpty(service.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n-    if (!SliderUtils.isClusternameValid(application.getName()) || (dnsEnabled\n-        \u0026\u0026 application.getName().length() \u003e RegistryConstants\n-        .MAX_FQDN_LABEL_LENGTH)) {\n-      throw new IllegalArgumentException(String.format(\n-          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n-          application.getName()));\n-    }\n \n-    // If the application has no components do top-level checks\n-    if (!hasComponent(application)) {\n-      // If artifact is of type APPLICATION, read other application components\n-      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n-          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n-        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n+    validateNameFormat(service.getName(), conf);\n+\n+    // If the service has no components do top-level checks\n+    if (!hasComponent(service)) {\n+      // If artifact is of type SERVICE, read other service components\n+      if (service.getArtifact() !\u003d null \u0026\u0026 service.getArtifact()\n+          .getType() \u003d\u003d Artifact.TypeEnum.SERVICE) {\n+        if (StringUtils.isEmpty(service.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n-        Application otherApplication \u003d loadApplication(fs,\n-            application.getArtifact().getId());\n-        application.setComponents(otherApplication.getComponents());\n-        application.setArtifact(null);\n-        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n-            otherApplication.getQuicklinks());\n+        Service otherService \u003d loadService(fs,\n+            service.getArtifact().getId());\n+        service.setComponents(otherService.getComponents());\n+        service.setArtifact(null);\n+        SliderUtils.mergeMapsIgnoreDuplicateKeys(service.getQuicklinks(),\n+            otherService.getQuicklinks());\n       } else {\n-        // Since it is a simple app with no components, create a default\n+        // Since it is a simple service with no components, create a default\n         // component\n-        Component comp \u003d createDefaultComponent(application);\n-        validateComponent(comp, fs.getFileSystem());\n-        application.getComponents().add(comp);\n-        if (application.getLifetime() \u003d\u003d null) {\n-          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n+        Component comp \u003d createDefaultComponent(service);\n+        validateComponent(comp, fs.getFileSystem(), conf);\n+        service.getComponents().add(comp);\n+        if (service.getLifetime() \u003d\u003d null) {\n+          service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n         }\n         return;\n       }\n     }\n \n     // Validate there are no component name collisions (collisions are not\n-    // currently supported) and add any components from external applications\n+    // currently supported) and add any components from external services\n     // TODO allow name collisions? see AppState#roles\n     // TODO or add prefix to external component names?\n-    Configuration globalConf \u003d application.getConfiguration();\n+    Configuration globalConf \u003d service.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n-    for (Component comp : application.getComponents()) {\n+    for (Component comp : service.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n       maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n-      // If artifact is of type APPLICATION (which cannot be filled from\n-      // global), read external application and add its components to this\n-      // application\n+      // If artifact is of type SERVICE (which cannot be filled from\n+      // global), read external service and add its components to this\n+      // service\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n-          Artifact.TypeEnum.APPLICATION) {\n+          Artifact.TypeEnum.SERVICE) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n-        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n+        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n-          Component override \u003d application.getComponent(c.getName());\n+          Component override \u003d service.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n-    application.getComponents().removeAll(componentsToRemove);\n-    application.getComponents().addAll(componentsToAdd);\n+    service.getComponents().removeAll(componentsToRemove);\n+    service.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n-    Artifact globalArtifact \u003d application.getArtifact();\n-    Resource globalResource \u003d application.getResource();\n-    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n-    String globalLaunchCommand \u003d application.getLaunchCommand();\n-    for (Component comp : application.getComponents()) {\n-      // fill in global artifact unless it is type APPLICATION\n-      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n-          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n-          .APPLICATION) {\n+    Artifact globalArtifact \u003d service.getArtifact();\n+    Resource globalResource \u003d service.getResource();\n+    Long globalNumberOfContainers \u003d service.getNumberOfContainers();\n+    String globalLaunchCommand \u003d service.getLaunchCommand();\n+    for (Component comp : service.getComponents()) {\n+      // fill in global artifact unless it is type SERVICE\n+      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n+          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n+          .SERVICE) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // fill in global container count\n       if (comp.getNumberOfContainers() \u003d\u003d null) {\n         comp.setNumberOfContainers(globalNumberOfContainers);\n       }\n       // fill in global launch command\n       if (comp.getLaunchCommand() \u003d\u003d null) {\n         comp.setLaunchCommand(globalLaunchCommand);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n-      validateComponent(comp, fs.getFileSystem());\n+      validateComponent(comp, fs.getFileSystem(), conf);\n     }\n \n     // validate dependency tree\n-    sortByDependencies(application.getComponents());\n+    sortByDependencies(service.getComponents());\n \n-    // Application lifetime if not specified, is set to unlimited lifetime\n-    if (application.getLifetime() \u003d\u003d null) {\n-      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n+    // Service lifetime if not specified, is set to unlimited lifetime\n+    if (service.getLifetime() \u003d\u003d null) {\n+      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateAndResolveService(Service service,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH) {\n      throw new IllegalArgumentException(RestApiErrorMessages\n          .ERROR_USER_NAME_INVALID);\n    }\n    if (StringUtils.isEmpty(service.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n\n    validateNameFormat(service.getName(), conf);\n\n    // If the service has no components do top-level checks\n    if (!hasComponent(service)) {\n      // If artifact is of type SERVICE, read other service components\n      if (service.getArtifact() !\u003d null \u0026\u0026 service.getArtifact()\n          .getType() \u003d\u003d Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(service.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        Service otherService \u003d loadService(fs,\n            service.getArtifact().getId());\n        service.setComponents(otherService.getComponents());\n        service.setArtifact(null);\n        SliderUtils.mergeMapsIgnoreDuplicateKeys(service.getQuicklinks(),\n            otherService.getQuicklinks());\n      } else {\n        // Since it is a simple service with no components, create a default\n        // component\n        Component comp \u003d createDefaultComponent(service);\n        validateComponent(comp, fs.getFileSystem(), conf);\n        service.getComponents().add(comp);\n        if (service.getLifetime() \u003d\u003d null) {\n          service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n        }\n        return;\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external services\n    // TODO allow name collisions? see AppState#roles\n    // TODO or add prefix to external component names?\n    Configuration globalConf \u003d service.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : service.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type SERVICE (which cannot be filled from\n      // global), read external service and add its components to this\n      // service\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d service.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    service.getComponents().removeAll(componentsToRemove);\n    service.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d service.getArtifact();\n    Resource globalResource \u003d service.getResource();\n    Long globalNumberOfContainers \u003d service.getNumberOfContainers();\n    String globalLaunchCommand \u003d service.getLaunchCommand();\n    for (Component comp : service.getComponents()) {\n      // fill in global artifact unless it is type SERVICE\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .SERVICE) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // fill in global container count\n      if (comp.getNumberOfContainers() \u003d\u003d null) {\n        comp.setNumberOfContainers(globalNumberOfContainers);\n      }\n      // fill in global launch command\n      if (comp.getLaunchCommand() \u003d\u003d null) {\n        comp.setLaunchCommand(globalLaunchCommand);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem(), conf);\n    }\n\n    // validate dependency tree\n    sortByDependencies(service.getComponents());\n\n    // Service lifetime if not specified, is set to unlimited lifetime\n    if (service.getLifetime() \u003d\u003d null) {\n      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
          "extendedDetails": {
            "oldValue": "validateAndResolveApplication",
            "newValue": "validateAndResolveService"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7091. Rename application to service in yarn-native-services. Contributed by Jian He\n",
          "commitDate": "06/11/17 1:30 PM",
          "commitName": "40ab068eabe50875449d601471619a4e82fff86d",
          "commitAuthor": "Billie Rinaldi",
          "commitDateOld": "06/11/17 1:30 PM",
          "commitNameOld": "2ba38ce8ecb1cf3836fab48cdb2c5ae7e1b5427d",
          "commitAuthorOld": "Gour Saha",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,158 +1,153 @@\n-  public static void validateAndResolveApplication(Application application,\n+  public static void validateAndResolveService(Service service,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n     if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n         .MAX_FQDN_LABEL_LENGTH) {\n       throw new IllegalArgumentException(RestApiErrorMessages\n           .ERROR_USER_NAME_INVALID);\n     }\n-    if (StringUtils.isEmpty(application.getName())) {\n+    if (StringUtils.isEmpty(service.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n-    if (!SliderUtils.isClusternameValid(application.getName()) || (dnsEnabled\n-        \u0026\u0026 application.getName().length() \u003e RegistryConstants\n-        .MAX_FQDN_LABEL_LENGTH)) {\n-      throw new IllegalArgumentException(String.format(\n-          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n-          application.getName()));\n-    }\n \n-    // If the application has no components do top-level checks\n-    if (!hasComponent(application)) {\n-      // If artifact is of type APPLICATION, read other application components\n-      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n-          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n-        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n+    validateNameFormat(service.getName(), conf);\n+\n+    // If the service has no components do top-level checks\n+    if (!hasComponent(service)) {\n+      // If artifact is of type SERVICE, read other service components\n+      if (service.getArtifact() !\u003d null \u0026\u0026 service.getArtifact()\n+          .getType() \u003d\u003d Artifact.TypeEnum.SERVICE) {\n+        if (StringUtils.isEmpty(service.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n-        Application otherApplication \u003d loadApplication(fs,\n-            application.getArtifact().getId());\n-        application.setComponents(otherApplication.getComponents());\n-        application.setArtifact(null);\n-        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n-            otherApplication.getQuicklinks());\n+        Service otherService \u003d loadService(fs,\n+            service.getArtifact().getId());\n+        service.setComponents(otherService.getComponents());\n+        service.setArtifact(null);\n+        SliderUtils.mergeMapsIgnoreDuplicateKeys(service.getQuicklinks(),\n+            otherService.getQuicklinks());\n       } else {\n-        // Since it is a simple app with no components, create a default\n+        // Since it is a simple service with no components, create a default\n         // component\n-        Component comp \u003d createDefaultComponent(application);\n-        validateComponent(comp, fs.getFileSystem());\n-        application.getComponents().add(comp);\n-        if (application.getLifetime() \u003d\u003d null) {\n-          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n+        Component comp \u003d createDefaultComponent(service);\n+        validateComponent(comp, fs.getFileSystem(), conf);\n+        service.getComponents().add(comp);\n+        if (service.getLifetime() \u003d\u003d null) {\n+          service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n         }\n         return;\n       }\n     }\n \n     // Validate there are no component name collisions (collisions are not\n-    // currently supported) and add any components from external applications\n+    // currently supported) and add any components from external services\n     // TODO allow name collisions? see AppState#roles\n     // TODO or add prefix to external component names?\n-    Configuration globalConf \u003d application.getConfiguration();\n+    Configuration globalConf \u003d service.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n-    for (Component comp : application.getComponents()) {\n+    for (Component comp : service.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n       maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n-      // If artifact is of type APPLICATION (which cannot be filled from\n-      // global), read external application and add its components to this\n-      // application\n+      // If artifact is of type SERVICE (which cannot be filled from\n+      // global), read external service and add its components to this\n+      // service\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n-          Artifact.TypeEnum.APPLICATION) {\n+          Artifact.TypeEnum.SERVICE) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n-        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n+        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n-          Component override \u003d application.getComponent(c.getName());\n+          Component override \u003d service.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n-    application.getComponents().removeAll(componentsToRemove);\n-    application.getComponents().addAll(componentsToAdd);\n+    service.getComponents().removeAll(componentsToRemove);\n+    service.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n-    Artifact globalArtifact \u003d application.getArtifact();\n-    Resource globalResource \u003d application.getResource();\n-    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n-    String globalLaunchCommand \u003d application.getLaunchCommand();\n-    for (Component comp : application.getComponents()) {\n-      // fill in global artifact unless it is type APPLICATION\n-      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n-          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n-          .APPLICATION) {\n+    Artifact globalArtifact \u003d service.getArtifact();\n+    Resource globalResource \u003d service.getResource();\n+    Long globalNumberOfContainers \u003d service.getNumberOfContainers();\n+    String globalLaunchCommand \u003d service.getLaunchCommand();\n+    for (Component comp : service.getComponents()) {\n+      // fill in global artifact unless it is type SERVICE\n+      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n+          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n+          .SERVICE) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // fill in global container count\n       if (comp.getNumberOfContainers() \u003d\u003d null) {\n         comp.setNumberOfContainers(globalNumberOfContainers);\n       }\n       // fill in global launch command\n       if (comp.getLaunchCommand() \u003d\u003d null) {\n         comp.setLaunchCommand(globalLaunchCommand);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n-      validateComponent(comp, fs.getFileSystem());\n+      validateComponent(comp, fs.getFileSystem(), conf);\n     }\n \n     // validate dependency tree\n-    sortByDependencies(application.getComponents());\n+    sortByDependencies(service.getComponents());\n \n-    // Application lifetime if not specified, is set to unlimited lifetime\n-    if (application.getLifetime() \u003d\u003d null) {\n-      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n+    // Service lifetime if not specified, is set to unlimited lifetime\n+    if (service.getLifetime() \u003d\u003d null) {\n+      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateAndResolveService(Service service,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH) {\n      throw new IllegalArgumentException(RestApiErrorMessages\n          .ERROR_USER_NAME_INVALID);\n    }\n    if (StringUtils.isEmpty(service.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n\n    validateNameFormat(service.getName(), conf);\n\n    // If the service has no components do top-level checks\n    if (!hasComponent(service)) {\n      // If artifact is of type SERVICE, read other service components\n      if (service.getArtifact() !\u003d null \u0026\u0026 service.getArtifact()\n          .getType() \u003d\u003d Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(service.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        Service otherService \u003d loadService(fs,\n            service.getArtifact().getId());\n        service.setComponents(otherService.getComponents());\n        service.setArtifact(null);\n        SliderUtils.mergeMapsIgnoreDuplicateKeys(service.getQuicklinks(),\n            otherService.getQuicklinks());\n      } else {\n        // Since it is a simple service with no components, create a default\n        // component\n        Component comp \u003d createDefaultComponent(service);\n        validateComponent(comp, fs.getFileSystem(), conf);\n        service.getComponents().add(comp);\n        if (service.getLifetime() \u003d\u003d null) {\n          service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n        }\n        return;\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external services\n    // TODO allow name collisions? see AppState#roles\n    // TODO or add prefix to external component names?\n    Configuration globalConf \u003d service.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : service.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type SERVICE (which cannot be filled from\n      // global), read external service and add its components to this\n      // service\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.SERVICE) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d service.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    service.getComponents().removeAll(componentsToRemove);\n    service.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d service.getArtifact();\n    Resource globalResource \u003d service.getResource();\n    Long globalNumberOfContainers \u003d service.getNumberOfContainers();\n    String globalLaunchCommand \u003d service.getLaunchCommand();\n    for (Component comp : service.getComponents()) {\n      // fill in global artifact unless it is type SERVICE\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 service.getArtifact() !\u003d null\n          \u0026\u0026 service.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .SERVICE) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // fill in global container count\n      if (comp.getNumberOfContainers() \u003d\u003d null) {\n        comp.setNumberOfContainers(globalNumberOfContainers);\n      }\n      // fill in global launch command\n      if (comp.getLaunchCommand() \u003d\u003d null) {\n        comp.setLaunchCommand(globalLaunchCommand);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem(), conf);\n    }\n\n    // validate dependency tree\n    sortByDependencies(service.getComponents());\n\n    // Service lifetime if not specified, is set to unlimited lifetime\n    if (service.getLifetime() \u003d\u003d null) {\n      service.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
          "extendedDetails": {
            "oldValue": "[application-Application, fs-SliderFileSystem, conf-org.apache.hadoop.conf.Configuration]",
            "newValue": "[service-Service, fs-SliderFileSystem, conf-org.apache.hadoop.conf.Configuration]"
          }
        }
      ]
    },
    "2191f5b533c6b4763f5d443d21127f1f8552ce64": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7050. Post cleanup after YARN-6903, removal of org.apache.slider package. Contributed by Jian He\n",
      "commitDate": "06/11/17 1:30 PM",
      "commitName": "2191f5b533c6b4763f5d443d21127f1f8552ce64",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "06/11/17 1:30 PM",
      "commitNameOld": "1888318c89776f0bf354c1b13e3ee169e14ff638",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,160 +1,158 @@\n   public static void validateAndResolveApplication(Application application,\n       SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n       IOException {\n     boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n         RegistryConstants.DEFAULT_DNS_ENABLED);\n     if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n         .MAX_FQDN_LABEL_LENGTH) {\n       throw new IllegalArgumentException(RestApiErrorMessages\n           .ERROR_USER_NAME_INVALID);\n     }\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName()) || (dnsEnabled\n         \u0026\u0026 application.getName().length() \u003e RegistryConstants\n         .MAX_FQDN_LABEL_LENGTH)) {\n       throw new IllegalArgumentException(String.format(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n           application.getName()));\n     }\n \n     // If the application has no components do top-level checks\n     if (!hasComponent(application)) {\n       // If artifact is of type APPLICATION, read other application components\n       if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n           .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (StringUtils.isEmpty(application.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         Application otherApplication \u003d loadApplication(fs,\n             application.getArtifact().getId());\n         application.setComponents(otherApplication.getComponents());\n         application.setArtifact(null);\n         SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n             otherApplication.getQuicklinks());\n       } else {\n         // Since it is a simple app with no components, create a default\n         // component\n         Component comp \u003d createDefaultComponent(application);\n         validateComponent(comp, fs.getFileSystem());\n         application.getComponents().add(comp);\n         if (application.getLifetime() \u003d\u003d null) {\n           application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n         }\n         return;\n       }\n     }\n \n     // Validate there are no component name collisions (collisions are not\n     // currently supported) and add any components from external applications\n     // TODO allow name collisions? see AppState#roles\n     // TODO or add prefix to external component names?\n     Configuration globalConf \u003d application.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n     for (Component comp : application.getComponents()) {\n       int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n-      if (comp.getUniqueComponentSupport()) {\n-        maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n-      }\n+      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n       if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n         throw new IllegalArgumentException(String.format(RestApiErrorMessages\n             .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n       }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n       // If artifact is of type APPLICATION (which cannot be filled from\n       // global), read external application and add its components to this\n       // application\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n           Artifact.TypeEnum.APPLICATION) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n         List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n           Component override \u003d application.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n     application.getComponents().removeAll(componentsToRemove);\n     application.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n     Artifact globalArtifact \u003d application.getArtifact();\n     Resource globalResource \u003d application.getResource();\n     Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n     String globalLaunchCommand \u003d application.getLaunchCommand();\n     for (Component comp : application.getComponents()) {\n       // fill in global artifact unless it is type APPLICATION\n       if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n           \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n           .APPLICATION) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // fill in global container count\n       if (comp.getNumberOfContainers() \u003d\u003d null) {\n         comp.setNumberOfContainers(globalNumberOfContainers);\n       }\n       // fill in global launch command\n       if (comp.getLaunchCommand() \u003d\u003d null) {\n         comp.setLaunchCommand(globalLaunchCommand);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n       validateComponent(comp, fs.getFileSystem());\n     }\n \n     // validate dependency tree\n     sortByDependencies(application.getComponents());\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void validateAndResolveApplication(Application application,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH) {\n      throw new IllegalArgumentException(RestApiErrorMessages\n          .ERROR_USER_NAME_INVALID);\n    }\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName()) || (dnsEnabled\n        \u0026\u0026 application.getName().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH)) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n          application.getName()));\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // If artifact is of type APPLICATION, read other application components\n      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        Application otherApplication \u003d loadApplication(fs,\n            application.getArtifact().getId());\n        application.setComponents(otherApplication.getComponents());\n        application.setArtifact(null);\n        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n            otherApplication.getQuicklinks());\n      } else {\n        // Since it is a simple app with no components, create a default\n        // component\n        Component comp \u003d createDefaultComponent(application);\n        validateComponent(comp, fs.getFileSystem());\n        application.getComponents().add(comp);\n        if (application.getLifetime() \u003d\u003d null) {\n          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n        }\n        return;\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external applications\n    // TODO allow name collisions? see AppState#roles\n    // TODO or add prefix to external component names?\n    Configuration globalConf \u003d application.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : application.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type APPLICATION (which cannot be filled from\n      // global), read external application and add its components to this\n      // application\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d application.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    application.getComponents().removeAll(componentsToRemove);\n    application.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d application.getArtifact();\n    Resource globalResource \u003d application.getResource();\n    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n    String globalLaunchCommand \u003d application.getLaunchCommand();\n    for (Component comp : application.getComponents()) {\n      // fill in global artifact unless it is type APPLICATION\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .APPLICATION) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // fill in global container count\n      if (comp.getNumberOfContainers() \u003d\u003d null) {\n        comp.setNumberOfContainers(globalNumberOfContainers);\n      }\n      // fill in global launch command\n      if (comp.getLaunchCommand() \u003d\u003d null) {\n        comp.setLaunchCommand(globalLaunchCommand);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem());\n    }\n\n    // validate dependency tree\n    sortByDependencies(application.getComponents());\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
      "extendedDetails": {}
    },
    "1888318c89776f0bf354c1b13e3ee169e14ff638": {
      "type": "Yfilerename",
      "commitMessage": "YARN-6903. Yarn-native-service framework core rewrite. Contributed by Jian He\n",
      "commitDate": "06/11/17 1:30 PM",
      "commitName": "1888318c89776f0bf354c1b13e3ee169e14ff638",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "06/11/17 1:30 PM",
      "commitNameOld": "27dcc679596edaaeb18dc42d2a812957a9d34e89",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public static void validateAndResolveApplication(Application application,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH) {\n      throw new IllegalArgumentException(RestApiErrorMessages\n          .ERROR_USER_NAME_INVALID);\n    }\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName()) || (dnsEnabled\n        \u0026\u0026 application.getName().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH)) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n          application.getName()));\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // If artifact is of type APPLICATION, read other application components\n      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        Application otherApplication \u003d loadApplication(fs,\n            application.getArtifact().getId());\n        application.setComponents(otherApplication.getComponents());\n        application.setArtifact(null);\n        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n            otherApplication.getQuicklinks());\n      } else {\n        // Since it is a simple app with no components, create a default\n        // component\n        Component comp \u003d createDefaultComponent(application);\n        validateComponent(comp, fs.getFileSystem());\n        application.getComponents().add(comp);\n        if (application.getLifetime() \u003d\u003d null) {\n          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n        }\n        return;\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external applications\n    // TODO allow name collisions? see AppState#roles\n    // TODO or add prefix to external component names?\n    Configuration globalConf \u003d application.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : application.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      if (comp.getUniqueComponentSupport()) {\n        maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      }\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type APPLICATION (which cannot be filled from\n      // global), read external application and add its components to this\n      // application\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d application.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    application.getComponents().removeAll(componentsToRemove);\n    application.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d application.getArtifact();\n    Resource globalResource \u003d application.getResource();\n    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n    String globalLaunchCommand \u003d application.getLaunchCommand();\n    for (Component comp : application.getComponents()) {\n      // fill in global artifact unless it is type APPLICATION\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .APPLICATION) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // fill in global container count\n      if (comp.getNumberOfContainers() \u003d\u003d null) {\n        comp.setNumberOfContainers(globalNumberOfContainers);\n      }\n      // fill in global launch command\n      if (comp.getLaunchCommand() \u003d\u003d null) {\n        comp.setLaunchCommand(globalLaunchCommand);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem());\n    }\n\n    // validate dependency tree\n    sortByDependencies(application.getComponents());\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/hadoop/yarn/service/utils/ServiceApiUtil.java"
      }
    },
    "59a9b4f4382e435b6e9eca928417bf66f70069a4": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6655. Validate yarn native services application submission side to ensure that the hostname should be less than 63 characters. Contributed by Billie Rinaldi\n",
      "commitDate": "06/11/17 1:30 PM",
      "commitName": "59a9b4f4382e435b6e9eca928417bf66f70069a4",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6655. Validate yarn native services application submission side to ensure that the hostname should be less than 63 characters. Contributed by Billie Rinaldi\n",
          "commitDate": "06/11/17 1:30 PM",
          "commitName": "59a9b4f4382e435b6e9eca928417bf66f70069a4",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/11/17 1:30 PM",
          "commitNameOld": "e86d828548c17ebadc0e6d22b50151eebd9696d5",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,160 @@\n   public static void validateAndResolveApplication(Application application,\n-      SliderFileSystem fs) throws IOException {\n+      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n+      IOException {\n+    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n+        RegistryConstants.DEFAULT_DNS_ENABLED);\n+    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n+        .MAX_FQDN_LABEL_LENGTH) {\n+      throw new IllegalArgumentException(RestApiErrorMessages\n+          .ERROR_USER_NAME_INVALID);\n+    }\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n-    if (!SliderUtils.isClusternameValid(application.getName())) {\n+    if (!SliderUtils.isClusternameValid(application.getName()) || (dnsEnabled\n+        \u0026\u0026 application.getName().length() \u003e RegistryConstants\n+        .MAX_FQDN_LABEL_LENGTH)) {\n       throw new IllegalArgumentException(String.format(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n           application.getName()));\n     }\n \n     // If the application has no components do top-level checks\n     if (!hasComponent(application)) {\n       // If artifact is of type APPLICATION, read other application components\n       if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n           .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (StringUtils.isEmpty(application.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         Application otherApplication \u003d loadApplication(fs,\n             application.getArtifact().getId());\n         application.setComponents(otherApplication.getComponents());\n         application.setArtifact(null);\n         SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n             otherApplication.getQuicklinks());\n       } else {\n         // Since it is a simple app with no components, create a default\n         // component\n         Component comp \u003d createDefaultComponent(application);\n         validateComponent(comp, fs.getFileSystem());\n         application.getComponents().add(comp);\n         if (application.getLifetime() \u003d\u003d null) {\n           application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n         }\n         return;\n       }\n     }\n \n     // Validate there are no component name collisions (collisions are not\n     // currently supported) and add any components from external applications\n     // TODO allow name collisions? see AppState#roles\n     // TODO or add prefix to external component names?\n     Configuration globalConf \u003d application.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n     for (Component comp : application.getComponents()) {\n+      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n+      if (comp.getUniqueComponentSupport()) {\n+        maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n+      }\n+      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n+        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n+            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n+      }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n       // If artifact is of type APPLICATION (which cannot be filled from\n       // global), read external application and add its components to this\n       // application\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n           Artifact.TypeEnum.APPLICATION) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n         List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n           Component override \u003d application.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n     application.getComponents().removeAll(componentsToRemove);\n     application.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n     Artifact globalArtifact \u003d application.getArtifact();\n     Resource globalResource \u003d application.getResource();\n     Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n     String globalLaunchCommand \u003d application.getLaunchCommand();\n     for (Component comp : application.getComponents()) {\n       // fill in global artifact unless it is type APPLICATION\n       if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n           \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n           .APPLICATION) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // fill in global container count\n       if (comp.getNumberOfContainers() \u003d\u003d null) {\n         comp.setNumberOfContainers(globalNumberOfContainers);\n       }\n       // fill in global launch command\n       if (comp.getLaunchCommand() \u003d\u003d null) {\n         comp.setLaunchCommand(globalLaunchCommand);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n       validateComponent(comp, fs.getFileSystem());\n     }\n \n     // validate dependency tree\n     sortByDependencies(application.getComponents());\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateAndResolveApplication(Application application,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH) {\n      throw new IllegalArgumentException(RestApiErrorMessages\n          .ERROR_USER_NAME_INVALID);\n    }\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName()) || (dnsEnabled\n        \u0026\u0026 application.getName().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH)) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n          application.getName()));\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // If artifact is of type APPLICATION, read other application components\n      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        Application otherApplication \u003d loadApplication(fs,\n            application.getArtifact().getId());\n        application.setComponents(otherApplication.getComponents());\n        application.setArtifact(null);\n        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n            otherApplication.getQuicklinks());\n      } else {\n        // Since it is a simple app with no components, create a default\n        // component\n        Component comp \u003d createDefaultComponent(application);\n        validateComponent(comp, fs.getFileSystem());\n        application.getComponents().add(comp);\n        if (application.getLifetime() \u003d\u003d null) {\n          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n        }\n        return;\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external applications\n    // TODO allow name collisions? see AppState#roles\n    // TODO or add prefix to external component names?\n    Configuration globalConf \u003d application.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : application.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      if (comp.getUniqueComponentSupport()) {\n        maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      }\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type APPLICATION (which cannot be filled from\n      // global), read external application and add its components to this\n      // application\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d application.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    application.getComponents().removeAll(componentsToRemove);\n    application.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d application.getArtifact();\n    Resource globalResource \u003d application.getResource();\n    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n    String globalLaunchCommand \u003d application.getLaunchCommand();\n    for (Component comp : application.getComponents()) {\n      // fill in global artifact unless it is type APPLICATION\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .APPLICATION) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // fill in global container count\n      if (comp.getNumberOfContainers() \u003d\u003d null) {\n        comp.setNumberOfContainers(globalNumberOfContainers);\n      }\n      // fill in global launch command\n      if (comp.getLaunchCommand() \u003d\u003d null) {\n        comp.setLaunchCommand(globalLaunchCommand);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem());\n    }\n\n    // validate dependency tree\n    sortByDependencies(application.getComponents());\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {
            "oldValue": "[application-Application, fs-SliderFileSystem]",
            "newValue": "[application-Application, fs-SliderFileSystem, conf-org.apache.hadoop.conf.Configuration]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6655. Validate yarn native services application submission side to ensure that the hostname should be less than 63 characters. Contributed by Billie Rinaldi\n",
          "commitDate": "06/11/17 1:30 PM",
          "commitName": "59a9b4f4382e435b6e9eca928417bf66f70069a4",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/11/17 1:30 PM",
          "commitNameOld": "e86d828548c17ebadc0e6d22b50151eebd9696d5",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,142 +1,160 @@\n   public static void validateAndResolveApplication(Application application,\n-      SliderFileSystem fs) throws IOException {\n+      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n+      IOException {\n+    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n+        RegistryConstants.DEFAULT_DNS_ENABLED);\n+    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n+        .MAX_FQDN_LABEL_LENGTH) {\n+      throw new IllegalArgumentException(RestApiErrorMessages\n+          .ERROR_USER_NAME_INVALID);\n+    }\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n-    if (!SliderUtils.isClusternameValid(application.getName())) {\n+    if (!SliderUtils.isClusternameValid(application.getName()) || (dnsEnabled\n+        \u0026\u0026 application.getName().length() \u003e RegistryConstants\n+        .MAX_FQDN_LABEL_LENGTH)) {\n       throw new IllegalArgumentException(String.format(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n           application.getName()));\n     }\n \n     // If the application has no components do top-level checks\n     if (!hasComponent(application)) {\n       // If artifact is of type APPLICATION, read other application components\n       if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n           .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (StringUtils.isEmpty(application.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         Application otherApplication \u003d loadApplication(fs,\n             application.getArtifact().getId());\n         application.setComponents(otherApplication.getComponents());\n         application.setArtifact(null);\n         SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n             otherApplication.getQuicklinks());\n       } else {\n         // Since it is a simple app with no components, create a default\n         // component\n         Component comp \u003d createDefaultComponent(application);\n         validateComponent(comp, fs.getFileSystem());\n         application.getComponents().add(comp);\n         if (application.getLifetime() \u003d\u003d null) {\n           application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n         }\n         return;\n       }\n     }\n \n     // Validate there are no component name collisions (collisions are not\n     // currently supported) and add any components from external applications\n     // TODO allow name collisions? see AppState#roles\n     // TODO or add prefix to external component names?\n     Configuration globalConf \u003d application.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n     for (Component comp : application.getComponents()) {\n+      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n+      if (comp.getUniqueComponentSupport()) {\n+        maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n+      }\n+      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n+        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n+            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n+      }\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n       // If artifact is of type APPLICATION (which cannot be filled from\n       // global), read external application and add its components to this\n       // application\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n           Artifact.TypeEnum.APPLICATION) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n         List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n           Component override \u003d application.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n     application.getComponents().removeAll(componentsToRemove);\n     application.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n     Artifact globalArtifact \u003d application.getArtifact();\n     Resource globalResource \u003d application.getResource();\n     Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n     String globalLaunchCommand \u003d application.getLaunchCommand();\n     for (Component comp : application.getComponents()) {\n       // fill in global artifact unless it is type APPLICATION\n       if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n           \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n           .APPLICATION) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // fill in global container count\n       if (comp.getNumberOfContainers() \u003d\u003d null) {\n         comp.setNumberOfContainers(globalNumberOfContainers);\n       }\n       // fill in global launch command\n       if (comp.getLaunchCommand() \u003d\u003d null) {\n         comp.setLaunchCommand(globalLaunchCommand);\n       }\n       // validate dependency existence\n       if (comp.getDependencies() !\u003d null) {\n         for (String dependency : comp.getDependencies()) {\n           if (!componentNames.contains(dependency)) {\n             throw new IllegalArgumentException(String.format(\n                 RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                 comp.getName()));\n           }\n         }\n       }\n       validateComponent(comp, fs.getFileSystem());\n     }\n \n     // validate dependency tree\n     sortByDependencies(application.getComponents());\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateAndResolveApplication(Application application,\n      SliderFileSystem fs, org.apache.hadoop.conf.Configuration conf) throws\n      IOException {\n    boolean dnsEnabled \u003d conf.getBoolean(RegistryConstants.KEY_DNS_ENABLED,\n        RegistryConstants.DEFAULT_DNS_ENABLED);\n    if (dnsEnabled \u0026\u0026 RegistryUtils.currentUser().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH) {\n      throw new IllegalArgumentException(RestApiErrorMessages\n          .ERROR_USER_NAME_INVALID);\n    }\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName()) || (dnsEnabled\n        \u0026\u0026 application.getName().length() \u003e RegistryConstants\n        .MAX_FQDN_LABEL_LENGTH)) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n          application.getName()));\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // If artifact is of type APPLICATION, read other application components\n      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        Application otherApplication \u003d loadApplication(fs,\n            application.getArtifact().getId());\n        application.setComponents(otherApplication.getComponents());\n        application.setArtifact(null);\n        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n            otherApplication.getQuicklinks());\n      } else {\n        // Since it is a simple app with no components, create a default\n        // component\n        Component comp \u003d createDefaultComponent(application);\n        validateComponent(comp, fs.getFileSystem());\n        application.getComponents().add(comp);\n        if (application.getLifetime() \u003d\u003d null) {\n          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n        }\n        return;\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external applications\n    // TODO allow name collisions? see AppState#roles\n    // TODO or add prefix to external component names?\n    Configuration globalConf \u003d application.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : application.getComponents()) {\n      int maxCompLength \u003d RegistryConstants.MAX_FQDN_LABEL_LENGTH;\n      if (comp.getUniqueComponentSupport()) {\n        maxCompLength \u003d maxCompLength - Long.toString(Long.MAX_VALUE).length();\n      }\n      if (dnsEnabled \u0026\u0026 comp.getName().length() \u003e maxCompLength) {\n        throw new IllegalArgumentException(String.format(RestApiErrorMessages\n            .ERROR_COMPONENT_NAME_INVALID, maxCompLength, comp.getName()));\n      }\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type APPLICATION (which cannot be filled from\n      // global), read external application and add its components to this\n      // application\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d application.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    application.getComponents().removeAll(componentsToRemove);\n    application.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d application.getArtifact();\n    Resource globalResource \u003d application.getResource();\n    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n    String globalLaunchCommand \u003d application.getLaunchCommand();\n    for (Component comp : application.getComponents()) {\n      // fill in global artifact unless it is type APPLICATION\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .APPLICATION) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // fill in global container count\n      if (comp.getNumberOfContainers() \u003d\u003d null) {\n        comp.setNumberOfContainers(globalNumberOfContainers);\n      }\n      // fill in global launch command\n      if (comp.getLaunchCommand() \u003d\u003d null) {\n        comp.setLaunchCommand(globalLaunchCommand);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem());\n    }\n\n    // validate dependency tree\n    sortByDependencies(application.getComponents());\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {}
        }
      ]
    },
    "e86d828548c17ebadc0e6d22b50151eebd9696d5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6716. Native services support for specifying component start order. Contributed by Billie Rinaldi\n",
      "commitDate": "06/11/17 1:30 PM",
      "commitName": "e86d828548c17ebadc0e6d22b50151eebd9696d5",
      "commitAuthor": "Jian He",
      "commitDateOld": "06/11/17 1:30 PM",
      "commitNameOld": "a0574e7f4f5a6e53677ada4381db5504f263d70f",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,142 @@\n   public static void validateAndResolveApplication(Application application,\n       SliderFileSystem fs) throws IOException {\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n       throw new IllegalArgumentException(String.format(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n           application.getName()));\n     }\n \n     // If the application has no components do top-level checks\n     if (!hasComponent(application)) {\n       // If artifact is of type APPLICATION, read other application components\n       if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n           .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (StringUtils.isEmpty(application.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         Application otherApplication \u003d loadApplication(fs,\n             application.getArtifact().getId());\n         application.setComponents(otherApplication.getComponents());\n         application.setArtifact(null);\n         SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n             otherApplication.getQuicklinks());\n       } else {\n         // Since it is a simple app with no components, create a default\n         // component\n         Component comp \u003d createDefaultComponent(application);\n         validateComponent(comp, fs.getFileSystem());\n         application.getComponents().add(comp);\n         if (application.getLifetime() \u003d\u003d null) {\n           application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n         }\n         return;\n       }\n     }\n \n     // Validate there are no component name collisions (collisions are not\n     // currently supported) and add any components from external applications\n     // TODO allow name collisions? see AppState#roles\n     // TODO or add prefix to external component names?\n     Configuration globalConf \u003d application.getConfiguration();\n     Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n     List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n     List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n     for (Component comp : application.getComponents()) {\n       if (componentNames.contains(comp.getName())) {\n         throw new IllegalArgumentException(\"Component name collision: \" +\n             comp.getName());\n       }\n       // If artifact is of type APPLICATION (which cannot be filled from\n       // global), read external application and add its components to this\n       // application\n       if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n           Artifact.TypeEnum.APPLICATION) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(\n               RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n         LOG.info(\"Marking {} for removal\", comp.getName());\n         componentsToRemove.add(comp);\n         List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n             comp.getArtifact().getId());\n         for (Component c : externalComponents) {\n           Component override \u003d application.getComponent(c.getName());\n           if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n             // allow properties from external components to be overridden /\n             // augmented by properties in this component, except for artifact\n             // which must be read from external component\n             override.mergeFrom(c);\n             LOG.info(\"Merging external component {} from external {}\", c\n                 .getName(), comp.getName());\n           } else {\n             if (componentNames.contains(c.getName())) {\n               throw new IllegalArgumentException(\"Component name collision: \" +\n                   c.getName());\n             }\n             componentNames.add(c.getName());\n             componentsToAdd.add(c);\n             LOG.info(\"Adding component {} from external {}\", c.getName(),\n                 comp.getName());\n           }\n         }\n       } else {\n         // otherwise handle as a normal component\n         componentNames.add(comp.getName());\n         // configuration\n         comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n     application.getComponents().removeAll(componentsToRemove);\n     application.getComponents().addAll(componentsToAdd);\n \n     // Validate components and let global values take effect if component level\n     // values are not provided\n     Artifact globalArtifact \u003d application.getArtifact();\n     Resource globalResource \u003d application.getResource();\n     Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n     String globalLaunchCommand \u003d application.getLaunchCommand();\n     for (Component comp : application.getComponents()) {\n       // fill in global artifact unless it is type APPLICATION\n       if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n           \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n           .APPLICATION) {\n         comp.setArtifact(globalArtifact);\n       }\n       // fill in global resource\n       if (comp.getResource() \u003d\u003d null) {\n         comp.setResource(globalResource);\n       }\n       // fill in global container count\n       if (comp.getNumberOfContainers() \u003d\u003d null) {\n         comp.setNumberOfContainers(globalNumberOfContainers);\n       }\n       // fill in global launch command\n       if (comp.getLaunchCommand() \u003d\u003d null) {\n         comp.setLaunchCommand(globalLaunchCommand);\n       }\n+      // validate dependency existence\n+      if (comp.getDependencies() !\u003d null) {\n+        for (String dependency : comp.getDependencies()) {\n+          if (!componentNames.contains(dependency)) {\n+            throw new IllegalArgumentException(String.format(\n+                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n+                comp.getName()));\n+          }\n+        }\n+      }\n       validateComponent(comp, fs.getFileSystem());\n     }\n \n+    // validate dependency tree\n+    sortByDependencies(application.getComponents());\n+\n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void validateAndResolveApplication(Application application,\n      SliderFileSystem fs) throws IOException {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n          application.getName()));\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // If artifact is of type APPLICATION, read other application components\n      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        Application otherApplication \u003d loadApplication(fs,\n            application.getArtifact().getId());\n        application.setComponents(otherApplication.getComponents());\n        application.setArtifact(null);\n        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n            otherApplication.getQuicklinks());\n      } else {\n        // Since it is a simple app with no components, create a default\n        // component\n        Component comp \u003d createDefaultComponent(application);\n        validateComponent(comp, fs.getFileSystem());\n        application.getComponents().add(comp);\n        if (application.getLifetime() \u003d\u003d null) {\n          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n        }\n        return;\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external applications\n    // TODO allow name collisions? see AppState#roles\n    // TODO or add prefix to external component names?\n    Configuration globalConf \u003d application.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : application.getComponents()) {\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type APPLICATION (which cannot be filled from\n      // global), read external application and add its components to this\n      // application\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d application.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    application.getComponents().removeAll(componentsToRemove);\n    application.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d application.getArtifact();\n    Resource globalResource \u003d application.getResource();\n    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n    String globalLaunchCommand \u003d application.getLaunchCommand();\n    for (Component comp : application.getComponents()) {\n      // fill in global artifact unless it is type APPLICATION\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .APPLICATION) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // fill in global container count\n      if (comp.getNumberOfContainers() \u003d\u003d null) {\n        comp.setNumberOfContainers(globalNumberOfContainers);\n      }\n      // fill in global launch command\n      if (comp.getLaunchCommand() \u003d\u003d null) {\n        comp.setLaunchCommand(globalLaunchCommand);\n      }\n      // validate dependency existence\n      if (comp.getDependencies() !\u003d null) {\n        for (String dependency : comp.getDependencies()) {\n          if (!componentNames.contains(dependency)) {\n            throw new IllegalArgumentException(String.format(\n                RestApiErrorMessages.ERROR_DEPENDENCY_INVALID, dependency,\n                comp.getName()));\n          }\n        }\n      }\n      validateComponent(comp, fs.getFileSystem());\n    }\n\n    // validate dependency tree\n    sortByDependencies(application.getComponents());\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
      "extendedDetails": {}
    },
    "a0574e7f4f5a6e53677ada4381db5504f263d70f": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6613. Update json validation for new native services providers. Contributed by Billie Rinaldi\n",
      "commitDate": "06/11/17 1:30 PM",
      "commitName": "a0574e7f4f5a6e53677ada4381db5504f263d70f",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-6613. Update json validation for new native services providers. Contributed by Billie Rinaldi\n",
          "commitDate": "06/11/17 1:30 PM",
          "commitName": "a0574e7f4f5a6e53677ada4381db5504f263d70f",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/11/17 1:28 PM",
          "commitNameOld": "845764da146e98927e8ea5b2209f19f4fc3feda5",
          "commitAuthorOld": "Billie Rinaldi",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,102 +1,129 @@\n-  public static void validateApplicationPayload(Application application,\n-      FileSystem fs) throws IOException {\n+  public static void validateAndResolveApplication(Application application,\n+      SliderFileSystem fs) throws IOException {\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n-      throw new IllegalArgumentException(\n-          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n+      throw new IllegalArgumentException(String.format(\n+          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n+          application.getName()));\n     }\n \n     // If the application has no components do top-level checks\n     if (!hasComponent(application)) {\n-      // artifact\n-      if (application.getArtifact() \u003d\u003d null) {\n-        throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n+      // If artifact is of type APPLICATION, read other application components\n+      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n+          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n+        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n+          throw new IllegalArgumentException(\n+              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n+        }\n+        Application otherApplication \u003d loadApplication(fs,\n+            application.getArtifact().getId());\n+        application.setComponents(otherApplication.getComponents());\n+        application.setArtifact(null);\n+        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n+            otherApplication.getQuicklinks());\n+      } else {\n+        // Since it is a simple app with no components, create a default\n+        // component\n+        Component comp \u003d createDefaultComponent(application);\n+        validateComponent(comp, fs.getFileSystem());\n+        application.getComponents().add(comp);\n+        if (application.getLifetime() \u003d\u003d null) {\n+          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n+        }\n+        return;\n       }\n-      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n-        throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n-      }\n+    }\n \n-      // If artifact is of type APPLICATION, add a slider specific property\n-      if (application.getArtifact().getType()\n-          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n-        if (application.getConfiguration() \u003d\u003d null) {\n-          application.setConfiguration(new Configuration());\n-        }\n+    // Validate there are no component name collisions (collisions are not\n+    // currently supported) and add any components from external applications\n+    // TODO allow name collisions? see AppState#roles\n+    // TODO or add prefix to external component names?\n+    Configuration globalConf \u003d application.getConfiguration();\n+    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n+    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n+    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n+    for (Component comp : application.getComponents()) {\n+      if (componentNames.contains(comp.getName())) {\n+        throw new IllegalArgumentException(\"Component name collision: \" +\n+            comp.getName());\n       }\n-      // resource\n-      validateApplicationResource(application.getResource(), null,\n-          application.getArtifact().getType());\n-\n-      // container size\n-      if (application.getNumberOfContainers() \u003d\u003d null\n-          || application.getNumberOfContainers() \u003c 0) {\n-        throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID + \": \"\n-                + application.getNumberOfContainers());\n-      }\n-      validateConfigFile(application.getConfiguration().getFiles(), fs);\n-      // Since it is a simple app with no components, create a default component\n-      application.getComponents().add(createDefaultComponent(application));\n-    } else {\n-      // If the application has components, then run checks for each component.\n-      // Let global values take effect if component level values are not\n-      // provided.\n-      Artifact globalArtifact \u003d application.getArtifact();\n-      Resource globalResource \u003d application.getResource();\n-      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n-      for (Component comp : application.getComponents()) {\n-        // artifact\n-        if (comp.getArtifact() \u003d\u003d null) {\n-          comp.setArtifact(globalArtifact);\n-        }\n-        // If still null raise validation exception\n-        if (comp.getArtifact() \u003d\u003d null) {\n-          throw new IllegalArgumentException(String\n-              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n-                  comp.getName()));\n-        }\n+      // If artifact is of type APPLICATION (which cannot be filled from\n+      // global), read external application and add its components to this\n+      // application\n+      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n+          Artifact.TypeEnum.APPLICATION) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n-          throw new IllegalArgumentException(String\n-              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n-                  comp.getName()));\n+          throw new IllegalArgumentException(\n+              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n-\n-        // If artifact is of type APPLICATION, add a slider specific property\n-        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n-          if (comp.getConfiguration() \u003d\u003d null) {\n-            comp.setConfiguration(new Configuration());\n+        LOG.info(\"Marking {} for removal\", comp.getName());\n+        componentsToRemove.add(comp);\n+        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n+            comp.getArtifact().getId());\n+        for (Component c : externalComponents) {\n+          Component override \u003d application.getComponent(c.getName());\n+          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n+            // allow properties from external components to be overridden /\n+            // augmented by properties in this component, except for artifact\n+            // which must be read from external component\n+            override.mergeFrom(c);\n+            LOG.info(\"Merging external component {} from external {}\", c\n+                .getName(), comp.getName());\n+          } else {\n+            if (componentNames.contains(c.getName())) {\n+              throw new IllegalArgumentException(\"Component name collision: \" +\n+                  c.getName());\n+            }\n+            componentNames.add(c.getName());\n+            componentsToAdd.add(c);\n+            LOG.info(\"Adding component {} from external {}\", c.getName(),\n+                comp.getName());\n           }\n-          comp.setName(comp.getArtifact().getId());\n         }\n-\n-        // resource\n-        if (comp.getResource() \u003d\u003d null) {\n-          comp.setResource(globalResource);\n-        }\n-        validateApplicationResource(comp.getResource(), comp,\n-            comp.getArtifact().getType());\n-\n-        // container count\n-        if (comp.getNumberOfContainers() \u003d\u003d null) {\n-          comp.setNumberOfContainers(globalNumberOfContainers);\n-        }\n-        if (comp.getNumberOfContainers() \u003d\u003d null\n-            || comp.getNumberOfContainers() \u003c 0) {\n-          throw new IllegalArgumentException(String.format(\n-              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID\n-                  + \": \" + comp.getNumberOfContainers(), comp.getName()));\n-        }\n-        validateConfigFile(comp.getConfiguration().getFiles(), fs);\n+      } else {\n+        // otherwise handle as a normal component\n+        componentNames.add(comp.getName());\n+        // configuration\n+        comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n+    application.getComponents().removeAll(componentsToRemove);\n+    application.getComponents().addAll(componentsToAdd);\n+\n+    // Validate components and let global values take effect if component level\n+    // values are not provided\n+    Artifact globalArtifact \u003d application.getArtifact();\n+    Resource globalResource \u003d application.getResource();\n+    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n+    String globalLaunchCommand \u003d application.getLaunchCommand();\n+    for (Component comp : application.getComponents()) {\n+      // fill in global artifact unless it is type APPLICATION\n+      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n+          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n+          .APPLICATION) {\n+        comp.setArtifact(globalArtifact);\n+      }\n+      // fill in global resource\n+      if (comp.getResource() \u003d\u003d null) {\n+        comp.setResource(globalResource);\n+      }\n+      // fill in global container count\n+      if (comp.getNumberOfContainers() \u003d\u003d null) {\n+        comp.setNumberOfContainers(globalNumberOfContainers);\n+      }\n+      // fill in global launch command\n+      if (comp.getLaunchCommand() \u003d\u003d null) {\n+        comp.setLaunchCommand(globalLaunchCommand);\n+      }\n+      validateComponent(comp, fs.getFileSystem());\n+    }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateAndResolveApplication(Application application,\n      SliderFileSystem fs) throws IOException {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n          application.getName()));\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // If artifact is of type APPLICATION, read other application components\n      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        Application otherApplication \u003d loadApplication(fs,\n            application.getArtifact().getId());\n        application.setComponents(otherApplication.getComponents());\n        application.setArtifact(null);\n        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n            otherApplication.getQuicklinks());\n      } else {\n        // Since it is a simple app with no components, create a default\n        // component\n        Component comp \u003d createDefaultComponent(application);\n        validateComponent(comp, fs.getFileSystem());\n        application.getComponents().add(comp);\n        if (application.getLifetime() \u003d\u003d null) {\n          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n        }\n        return;\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external applications\n    // TODO allow name collisions? see AppState#roles\n    // TODO or add prefix to external component names?\n    Configuration globalConf \u003d application.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : application.getComponents()) {\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type APPLICATION (which cannot be filled from\n      // global), read external application and add its components to this\n      // application\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d application.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    application.getComponents().removeAll(componentsToRemove);\n    application.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d application.getArtifact();\n    Resource globalResource \u003d application.getResource();\n    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n    String globalLaunchCommand \u003d application.getLaunchCommand();\n    for (Component comp : application.getComponents()) {\n      // fill in global artifact unless it is type APPLICATION\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .APPLICATION) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // fill in global container count\n      if (comp.getNumberOfContainers() \u003d\u003d null) {\n        comp.setNumberOfContainers(globalNumberOfContainers);\n      }\n      // fill in global launch command\n      if (comp.getLaunchCommand() \u003d\u003d null) {\n        comp.setLaunchCommand(globalLaunchCommand);\n      }\n      validateComponent(comp, fs.getFileSystem());\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {
            "oldValue": "validateApplicationPayload",
            "newValue": "validateAndResolveApplication"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6613. Update json validation for new native services providers. Contributed by Billie Rinaldi\n",
          "commitDate": "06/11/17 1:30 PM",
          "commitName": "a0574e7f4f5a6e53677ada4381db5504f263d70f",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/11/17 1:28 PM",
          "commitNameOld": "845764da146e98927e8ea5b2209f19f4fc3feda5",
          "commitAuthorOld": "Billie Rinaldi",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,102 +1,129 @@\n-  public static void validateApplicationPayload(Application application,\n-      FileSystem fs) throws IOException {\n+  public static void validateAndResolveApplication(Application application,\n+      SliderFileSystem fs) throws IOException {\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n-      throw new IllegalArgumentException(\n-          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n+      throw new IllegalArgumentException(String.format(\n+          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n+          application.getName()));\n     }\n \n     // If the application has no components do top-level checks\n     if (!hasComponent(application)) {\n-      // artifact\n-      if (application.getArtifact() \u003d\u003d null) {\n-        throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n+      // If artifact is of type APPLICATION, read other application components\n+      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n+          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n+        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n+          throw new IllegalArgumentException(\n+              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n+        }\n+        Application otherApplication \u003d loadApplication(fs,\n+            application.getArtifact().getId());\n+        application.setComponents(otherApplication.getComponents());\n+        application.setArtifact(null);\n+        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n+            otherApplication.getQuicklinks());\n+      } else {\n+        // Since it is a simple app with no components, create a default\n+        // component\n+        Component comp \u003d createDefaultComponent(application);\n+        validateComponent(comp, fs.getFileSystem());\n+        application.getComponents().add(comp);\n+        if (application.getLifetime() \u003d\u003d null) {\n+          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n+        }\n+        return;\n       }\n-      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n-        throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n-      }\n+    }\n \n-      // If artifact is of type APPLICATION, add a slider specific property\n-      if (application.getArtifact().getType()\n-          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n-        if (application.getConfiguration() \u003d\u003d null) {\n-          application.setConfiguration(new Configuration());\n-        }\n+    // Validate there are no component name collisions (collisions are not\n+    // currently supported) and add any components from external applications\n+    // TODO allow name collisions? see AppState#roles\n+    // TODO or add prefix to external component names?\n+    Configuration globalConf \u003d application.getConfiguration();\n+    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n+    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n+    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n+    for (Component comp : application.getComponents()) {\n+      if (componentNames.contains(comp.getName())) {\n+        throw new IllegalArgumentException(\"Component name collision: \" +\n+            comp.getName());\n       }\n-      // resource\n-      validateApplicationResource(application.getResource(), null,\n-          application.getArtifact().getType());\n-\n-      // container size\n-      if (application.getNumberOfContainers() \u003d\u003d null\n-          || application.getNumberOfContainers() \u003c 0) {\n-        throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID + \": \"\n-                + application.getNumberOfContainers());\n-      }\n-      validateConfigFile(application.getConfiguration().getFiles(), fs);\n-      // Since it is a simple app with no components, create a default component\n-      application.getComponents().add(createDefaultComponent(application));\n-    } else {\n-      // If the application has components, then run checks for each component.\n-      // Let global values take effect if component level values are not\n-      // provided.\n-      Artifact globalArtifact \u003d application.getArtifact();\n-      Resource globalResource \u003d application.getResource();\n-      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n-      for (Component comp : application.getComponents()) {\n-        // artifact\n-        if (comp.getArtifact() \u003d\u003d null) {\n-          comp.setArtifact(globalArtifact);\n-        }\n-        // If still null raise validation exception\n-        if (comp.getArtifact() \u003d\u003d null) {\n-          throw new IllegalArgumentException(String\n-              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n-                  comp.getName()));\n-        }\n+      // If artifact is of type APPLICATION (which cannot be filled from\n+      // global), read external application and add its components to this\n+      // application\n+      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n+          Artifact.TypeEnum.APPLICATION) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n-          throw new IllegalArgumentException(String\n-              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n-                  comp.getName()));\n+          throw new IllegalArgumentException(\n+              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n-\n-        // If artifact is of type APPLICATION, add a slider specific property\n-        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n-          if (comp.getConfiguration() \u003d\u003d null) {\n-            comp.setConfiguration(new Configuration());\n+        LOG.info(\"Marking {} for removal\", comp.getName());\n+        componentsToRemove.add(comp);\n+        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n+            comp.getArtifact().getId());\n+        for (Component c : externalComponents) {\n+          Component override \u003d application.getComponent(c.getName());\n+          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n+            // allow properties from external components to be overridden /\n+            // augmented by properties in this component, except for artifact\n+            // which must be read from external component\n+            override.mergeFrom(c);\n+            LOG.info(\"Merging external component {} from external {}\", c\n+                .getName(), comp.getName());\n+          } else {\n+            if (componentNames.contains(c.getName())) {\n+              throw new IllegalArgumentException(\"Component name collision: \" +\n+                  c.getName());\n+            }\n+            componentNames.add(c.getName());\n+            componentsToAdd.add(c);\n+            LOG.info(\"Adding component {} from external {}\", c.getName(),\n+                comp.getName());\n           }\n-          comp.setName(comp.getArtifact().getId());\n         }\n-\n-        // resource\n-        if (comp.getResource() \u003d\u003d null) {\n-          comp.setResource(globalResource);\n-        }\n-        validateApplicationResource(comp.getResource(), comp,\n-            comp.getArtifact().getType());\n-\n-        // container count\n-        if (comp.getNumberOfContainers() \u003d\u003d null) {\n-          comp.setNumberOfContainers(globalNumberOfContainers);\n-        }\n-        if (comp.getNumberOfContainers() \u003d\u003d null\n-            || comp.getNumberOfContainers() \u003c 0) {\n-          throw new IllegalArgumentException(String.format(\n-              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID\n-                  + \": \" + comp.getNumberOfContainers(), comp.getName()));\n-        }\n-        validateConfigFile(comp.getConfiguration().getFiles(), fs);\n+      } else {\n+        // otherwise handle as a normal component\n+        componentNames.add(comp.getName());\n+        // configuration\n+        comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n+    application.getComponents().removeAll(componentsToRemove);\n+    application.getComponents().addAll(componentsToAdd);\n+\n+    // Validate components and let global values take effect if component level\n+    // values are not provided\n+    Artifact globalArtifact \u003d application.getArtifact();\n+    Resource globalResource \u003d application.getResource();\n+    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n+    String globalLaunchCommand \u003d application.getLaunchCommand();\n+    for (Component comp : application.getComponents()) {\n+      // fill in global artifact unless it is type APPLICATION\n+      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n+          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n+          .APPLICATION) {\n+        comp.setArtifact(globalArtifact);\n+      }\n+      // fill in global resource\n+      if (comp.getResource() \u003d\u003d null) {\n+        comp.setResource(globalResource);\n+      }\n+      // fill in global container count\n+      if (comp.getNumberOfContainers() \u003d\u003d null) {\n+        comp.setNumberOfContainers(globalNumberOfContainers);\n+      }\n+      // fill in global launch command\n+      if (comp.getLaunchCommand() \u003d\u003d null) {\n+        comp.setLaunchCommand(globalLaunchCommand);\n+      }\n+      validateComponent(comp, fs.getFileSystem());\n+    }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateAndResolveApplication(Application application,\n      SliderFileSystem fs) throws IOException {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n          application.getName()));\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // If artifact is of type APPLICATION, read other application components\n      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        Application otherApplication \u003d loadApplication(fs,\n            application.getArtifact().getId());\n        application.setComponents(otherApplication.getComponents());\n        application.setArtifact(null);\n        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n            otherApplication.getQuicklinks());\n      } else {\n        // Since it is a simple app with no components, create a default\n        // component\n        Component comp \u003d createDefaultComponent(application);\n        validateComponent(comp, fs.getFileSystem());\n        application.getComponents().add(comp);\n        if (application.getLifetime() \u003d\u003d null) {\n          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n        }\n        return;\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external applications\n    // TODO allow name collisions? see AppState#roles\n    // TODO or add prefix to external component names?\n    Configuration globalConf \u003d application.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : application.getComponents()) {\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type APPLICATION (which cannot be filled from\n      // global), read external application and add its components to this\n      // application\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d application.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    application.getComponents().removeAll(componentsToRemove);\n    application.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d application.getArtifact();\n    Resource globalResource \u003d application.getResource();\n    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n    String globalLaunchCommand \u003d application.getLaunchCommand();\n    for (Component comp : application.getComponents()) {\n      // fill in global artifact unless it is type APPLICATION\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .APPLICATION) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // fill in global container count\n      if (comp.getNumberOfContainers() \u003d\u003d null) {\n        comp.setNumberOfContainers(globalNumberOfContainers);\n      }\n      // fill in global launch command\n      if (comp.getLaunchCommand() \u003d\u003d null) {\n        comp.setLaunchCommand(globalLaunchCommand);\n      }\n      validateComponent(comp, fs.getFileSystem());\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {
            "oldValue": "[application-Application, fs-FileSystem]",
            "newValue": "[application-Application, fs-SliderFileSystem]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6613. Update json validation for new native services providers. Contributed by Billie Rinaldi\n",
          "commitDate": "06/11/17 1:30 PM",
          "commitName": "a0574e7f4f5a6e53677ada4381db5504f263d70f",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/11/17 1:28 PM",
          "commitNameOld": "845764da146e98927e8ea5b2209f19f4fc3feda5",
          "commitAuthorOld": "Billie Rinaldi",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,102 +1,129 @@\n-  public static void validateApplicationPayload(Application application,\n-      FileSystem fs) throws IOException {\n+  public static void validateAndResolveApplication(Application application,\n+      SliderFileSystem fs) throws IOException {\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n-      throw new IllegalArgumentException(\n-          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n+      throw new IllegalArgumentException(String.format(\n+          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n+          application.getName()));\n     }\n \n     // If the application has no components do top-level checks\n     if (!hasComponent(application)) {\n-      // artifact\n-      if (application.getArtifact() \u003d\u003d null) {\n-        throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n+      // If artifact is of type APPLICATION, read other application components\n+      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n+          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n+        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n+          throw new IllegalArgumentException(\n+              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n+        }\n+        Application otherApplication \u003d loadApplication(fs,\n+            application.getArtifact().getId());\n+        application.setComponents(otherApplication.getComponents());\n+        application.setArtifact(null);\n+        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n+            otherApplication.getQuicklinks());\n+      } else {\n+        // Since it is a simple app with no components, create a default\n+        // component\n+        Component comp \u003d createDefaultComponent(application);\n+        validateComponent(comp, fs.getFileSystem());\n+        application.getComponents().add(comp);\n+        if (application.getLifetime() \u003d\u003d null) {\n+          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n+        }\n+        return;\n       }\n-      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n-        throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n-      }\n+    }\n \n-      // If artifact is of type APPLICATION, add a slider specific property\n-      if (application.getArtifact().getType()\n-          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n-        if (application.getConfiguration() \u003d\u003d null) {\n-          application.setConfiguration(new Configuration());\n-        }\n+    // Validate there are no component name collisions (collisions are not\n+    // currently supported) and add any components from external applications\n+    // TODO allow name collisions? see AppState#roles\n+    // TODO or add prefix to external component names?\n+    Configuration globalConf \u003d application.getConfiguration();\n+    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n+    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n+    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n+    for (Component comp : application.getComponents()) {\n+      if (componentNames.contains(comp.getName())) {\n+        throw new IllegalArgumentException(\"Component name collision: \" +\n+            comp.getName());\n       }\n-      // resource\n-      validateApplicationResource(application.getResource(), null,\n-          application.getArtifact().getType());\n-\n-      // container size\n-      if (application.getNumberOfContainers() \u003d\u003d null\n-          || application.getNumberOfContainers() \u003c 0) {\n-        throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID + \": \"\n-                + application.getNumberOfContainers());\n-      }\n-      validateConfigFile(application.getConfiguration().getFiles(), fs);\n-      // Since it is a simple app with no components, create a default component\n-      application.getComponents().add(createDefaultComponent(application));\n-    } else {\n-      // If the application has components, then run checks for each component.\n-      // Let global values take effect if component level values are not\n-      // provided.\n-      Artifact globalArtifact \u003d application.getArtifact();\n-      Resource globalResource \u003d application.getResource();\n-      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n-      for (Component comp : application.getComponents()) {\n-        // artifact\n-        if (comp.getArtifact() \u003d\u003d null) {\n-          comp.setArtifact(globalArtifact);\n-        }\n-        // If still null raise validation exception\n-        if (comp.getArtifact() \u003d\u003d null) {\n-          throw new IllegalArgumentException(String\n-              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n-                  comp.getName()));\n-        }\n+      // If artifact is of type APPLICATION (which cannot be filled from\n+      // global), read external application and add its components to this\n+      // application\n+      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n+          Artifact.TypeEnum.APPLICATION) {\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n-          throw new IllegalArgumentException(String\n-              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n-                  comp.getName()));\n+          throw new IllegalArgumentException(\n+              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n         }\n-\n-        // If artifact is of type APPLICATION, add a slider specific property\n-        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n-          if (comp.getConfiguration() \u003d\u003d null) {\n-            comp.setConfiguration(new Configuration());\n+        LOG.info(\"Marking {} for removal\", comp.getName());\n+        componentsToRemove.add(comp);\n+        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n+            comp.getArtifact().getId());\n+        for (Component c : externalComponents) {\n+          Component override \u003d application.getComponent(c.getName());\n+          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n+            // allow properties from external components to be overridden /\n+            // augmented by properties in this component, except for artifact\n+            // which must be read from external component\n+            override.mergeFrom(c);\n+            LOG.info(\"Merging external component {} from external {}\", c\n+                .getName(), comp.getName());\n+          } else {\n+            if (componentNames.contains(c.getName())) {\n+              throw new IllegalArgumentException(\"Component name collision: \" +\n+                  c.getName());\n+            }\n+            componentNames.add(c.getName());\n+            componentsToAdd.add(c);\n+            LOG.info(\"Adding component {} from external {}\", c.getName(),\n+                comp.getName());\n           }\n-          comp.setName(comp.getArtifact().getId());\n         }\n-\n-        // resource\n-        if (comp.getResource() \u003d\u003d null) {\n-          comp.setResource(globalResource);\n-        }\n-        validateApplicationResource(comp.getResource(), comp,\n-            comp.getArtifact().getType());\n-\n-        // container count\n-        if (comp.getNumberOfContainers() \u003d\u003d null) {\n-          comp.setNumberOfContainers(globalNumberOfContainers);\n-        }\n-        if (comp.getNumberOfContainers() \u003d\u003d null\n-            || comp.getNumberOfContainers() \u003c 0) {\n-          throw new IllegalArgumentException(String.format(\n-              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID\n-                  + \": \" + comp.getNumberOfContainers(), comp.getName()));\n-        }\n-        validateConfigFile(comp.getConfiguration().getFiles(), fs);\n+      } else {\n+        // otherwise handle as a normal component\n+        componentNames.add(comp.getName());\n+        // configuration\n+        comp.getConfiguration().mergeFrom(globalConf);\n       }\n     }\n+    application.getComponents().removeAll(componentsToRemove);\n+    application.getComponents().addAll(componentsToAdd);\n+\n+    // Validate components and let global values take effect if component level\n+    // values are not provided\n+    Artifact globalArtifact \u003d application.getArtifact();\n+    Resource globalResource \u003d application.getResource();\n+    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n+    String globalLaunchCommand \u003d application.getLaunchCommand();\n+    for (Component comp : application.getComponents()) {\n+      // fill in global artifact unless it is type APPLICATION\n+      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n+          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n+          .APPLICATION) {\n+        comp.setArtifact(globalArtifact);\n+      }\n+      // fill in global resource\n+      if (comp.getResource() \u003d\u003d null) {\n+        comp.setResource(globalResource);\n+      }\n+      // fill in global container count\n+      if (comp.getNumberOfContainers() \u003d\u003d null) {\n+        comp.setNumberOfContainers(globalNumberOfContainers);\n+      }\n+      // fill in global launch command\n+      if (comp.getLaunchCommand() \u003d\u003d null) {\n+        comp.setLaunchCommand(globalLaunchCommand);\n+      }\n+      validateComponent(comp, fs.getFileSystem());\n+    }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateAndResolveApplication(Application application,\n      SliderFileSystem fs) throws IOException {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(String.format(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT,\n          application.getName()));\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // If artifact is of type APPLICATION, read other application components\n      if (application.getArtifact() !\u003d null \u0026\u0026 application.getArtifact()\n          .getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(application.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        Application otherApplication \u003d loadApplication(fs,\n            application.getArtifact().getId());\n        application.setComponents(otherApplication.getComponents());\n        application.setArtifact(null);\n        SliderUtils.mergeMapsIgnoreDuplicateKeys(application.getQuicklinks(),\n            otherApplication.getQuicklinks());\n      } else {\n        // Since it is a simple app with no components, create a default\n        // component\n        Component comp \u003d createDefaultComponent(application);\n        validateComponent(comp, fs.getFileSystem());\n        application.getComponents().add(comp);\n        if (application.getLifetime() \u003d\u003d null) {\n          application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n        }\n        return;\n      }\n    }\n\n    // Validate there are no component name collisions (collisions are not\n    // currently supported) and add any components from external applications\n    // TODO allow name collisions? see AppState#roles\n    // TODO or add prefix to external component names?\n    Configuration globalConf \u003d application.getConfiguration();\n    Set\u003cString\u003e componentNames \u003d new HashSet\u003c\u003e();\n    List\u003cComponent\u003e componentsToRemove \u003d new ArrayList\u003c\u003e();\n    List\u003cComponent\u003e componentsToAdd \u003d new ArrayList\u003c\u003e();\n    for (Component comp : application.getComponents()) {\n      if (componentNames.contains(comp.getName())) {\n        throw new IllegalArgumentException(\"Component name collision: \" +\n            comp.getName());\n      }\n      // If artifact is of type APPLICATION (which cannot be filled from\n      // global), read external application and add its components to this\n      // application\n      if (comp.getArtifact() !\u003d null \u0026\u0026 comp.getArtifact().getType() \u003d\u003d\n          Artifact.TypeEnum.APPLICATION) {\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(\n              RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n        }\n        LOG.info(\"Marking {} for removal\", comp.getName());\n        componentsToRemove.add(comp);\n        List\u003cComponent\u003e externalComponents \u003d getApplicationComponents(fs,\n            comp.getArtifact().getId());\n        for (Component c : externalComponents) {\n          Component override \u003d application.getComponent(c.getName());\n          if (override !\u003d null \u0026\u0026 override.getArtifact() \u003d\u003d null) {\n            // allow properties from external components to be overridden /\n            // augmented by properties in this component, except for artifact\n            // which must be read from external component\n            override.mergeFrom(c);\n            LOG.info(\"Merging external component {} from external {}\", c\n                .getName(), comp.getName());\n          } else {\n            if (componentNames.contains(c.getName())) {\n              throw new IllegalArgumentException(\"Component name collision: \" +\n                  c.getName());\n            }\n            componentNames.add(c.getName());\n            componentsToAdd.add(c);\n            LOG.info(\"Adding component {} from external {}\", c.getName(),\n                comp.getName());\n          }\n        }\n      } else {\n        // otherwise handle as a normal component\n        componentNames.add(comp.getName());\n        // configuration\n        comp.getConfiguration().mergeFrom(globalConf);\n      }\n    }\n    application.getComponents().removeAll(componentsToRemove);\n    application.getComponents().addAll(componentsToAdd);\n\n    // Validate components and let global values take effect if component level\n    // values are not provided\n    Artifact globalArtifact \u003d application.getArtifact();\n    Resource globalResource \u003d application.getResource();\n    Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n    String globalLaunchCommand \u003d application.getLaunchCommand();\n    for (Component comp : application.getComponents()) {\n      // fill in global artifact unless it is type APPLICATION\n      if (comp.getArtifact() \u003d\u003d null \u0026\u0026 application.getArtifact() !\u003d null\n          \u0026\u0026 application.getArtifact().getType() !\u003d Artifact.TypeEnum\n          .APPLICATION) {\n        comp.setArtifact(globalArtifact);\n      }\n      // fill in global resource\n      if (comp.getResource() \u003d\u003d null) {\n        comp.setResource(globalResource);\n      }\n      // fill in global container count\n      if (comp.getNumberOfContainers() \u003d\u003d null) {\n        comp.setNumberOfContainers(globalNumberOfContainers);\n      }\n      // fill in global launch command\n      if (comp.getLaunchCommand() \u003d\u003d null) {\n        comp.setLaunchCommand(globalLaunchCommand);\n      }\n      validateComponent(comp, fs.getFileSystem());\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {}
        }
      ]
    },
    "845764da146e98927e8ea5b2209f19f4fc3feda5": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-6405. Improve configuring services through REST API. Contributed by Jian He\n",
      "commitDate": "06/11/17 1:28 PM",
      "commitName": "845764da146e98927e8ea5b2209f19f4fc3feda5",
      "commitAuthor": "Billie Rinaldi",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-6405. Improve configuring services through REST API. Contributed by Jian He\n",
          "commitDate": "06/11/17 1:28 PM",
          "commitName": "845764da146e98927e8ea5b2209f19f4fc3feda5",
          "commitAuthor": "Billie Rinaldi",
          "commitDateOld": "06/11/17 1:28 PM",
          "commitNameOld": "c31cd981ebabc0747cabcc07a8c8797619ed2c53",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,97 +1,102 @@\n-  public static void validateApplicationPostPayload(Application application) {\n+  public static void validateApplicationPayload(Application application,\n+      FileSystem fs) throws IOException {\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n     }\n \n     // If the application has no components do top-level checks\n     if (!hasComponent(application)) {\n       // artifact\n       if (application.getArtifact() \u003d\u003d null) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n       }\n       if (StringUtils.isEmpty(application.getArtifact().getId())) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n       }\n \n       // If artifact is of type APPLICATION, add a slider specific property\n       if (application.getArtifact().getType()\n           \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (application.getConfiguration() \u003d\u003d null) {\n           application.setConfiguration(new Configuration());\n         }\n       }\n       // resource\n       validateApplicationResource(application.getResource(), null,\n           application.getArtifact().getType());\n \n       // container size\n-      if (application.getNumberOfContainers() \u003d\u003d null) {\n+      if (application.getNumberOfContainers() \u003d\u003d null\n+          || application.getNumberOfContainers() \u003c 0) {\n         throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID);\n+            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID + \": \"\n+                + application.getNumberOfContainers());\n       }\n-\n+      validateConfigFile(application.getConfiguration().getFiles(), fs);\n       // Since it is a simple app with no components, create a default component\n       application.getComponents().add(createDefaultComponent(application));\n     } else {\n       // If the application has components, then run checks for each component.\n       // Let global values take effect if component level values are not\n       // provided.\n       Artifact globalArtifact \u003d application.getArtifact();\n       Resource globalResource \u003d application.getResource();\n       Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n       for (Component comp : application.getComponents()) {\n         // artifact\n         if (comp.getArtifact() \u003d\u003d null) {\n           comp.setArtifact(globalArtifact);\n         }\n         // If still null raise validation exception\n         if (comp.getArtifact() \u003d\u003d null) {\n           throw new IllegalArgumentException(String\n               .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n                   comp.getName()));\n         }\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(String\n               .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n                   comp.getName()));\n         }\n \n         // If artifact is of type APPLICATION, add a slider specific property\n         if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n           if (comp.getConfiguration() \u003d\u003d null) {\n             comp.setConfiguration(new Configuration());\n           }\n           comp.setName(comp.getArtifact().getId());\n         }\n \n         // resource\n         if (comp.getResource() \u003d\u003d null) {\n           comp.setResource(globalResource);\n         }\n         validateApplicationResource(comp.getResource(), comp,\n             comp.getArtifact().getType());\n \n         // container count\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           comp.setNumberOfContainers(globalNumberOfContainers);\n         }\n-        if (comp.getNumberOfContainers() \u003d\u003d null) {\n+        if (comp.getNumberOfContainers() \u003d\u003d null\n+            || comp.getNumberOfContainers() \u003c 0) {\n           throw new IllegalArgumentException(String.format(\n-              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID,\n-              comp.getName()));\n+              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID\n+                  + \": \" + comp.getNumberOfContainers(), comp.getName()));\n         }\n+        validateConfigFile(comp.getConfiguration().getFiles(), fs);\n       }\n     }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateApplicationPayload(Application application,\n      FileSystem fs) throws IOException {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // artifact\n      if (application.getArtifact() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n      }\n      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n      }\n\n      // If artifact is of type APPLICATION, add a slider specific property\n      if (application.getArtifact().getType()\n          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (application.getConfiguration() \u003d\u003d null) {\n          application.setConfiguration(new Configuration());\n        }\n      }\n      // resource\n      validateApplicationResource(application.getResource(), null,\n          application.getArtifact().getType());\n\n      // container size\n      if (application.getNumberOfContainers() \u003d\u003d null\n          || application.getNumberOfContainers() \u003c 0) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID + \": \"\n                + application.getNumberOfContainers());\n      }\n      validateConfigFile(application.getConfiguration().getFiles(), fs);\n      // Since it is a simple app with no components, create a default component\n      application.getComponents().add(createDefaultComponent(application));\n    } else {\n      // If the application has components, then run checks for each component.\n      // Let global values take effect if component level values are not\n      // provided.\n      Artifact globalArtifact \u003d application.getArtifact();\n      Resource globalResource \u003d application.getResource();\n      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n      for (Component comp : application.getComponents()) {\n        // artifact\n        if (comp.getArtifact() \u003d\u003d null) {\n          comp.setArtifact(globalArtifact);\n        }\n        // If still null raise validation exception\n        if (comp.getArtifact() \u003d\u003d null) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n\n        // If artifact is of type APPLICATION, add a slider specific property\n        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n          if (comp.getConfiguration() \u003d\u003d null) {\n            comp.setConfiguration(new Configuration());\n          }\n          comp.setName(comp.getArtifact().getId());\n        }\n\n        // resource\n        if (comp.getResource() \u003d\u003d null) {\n          comp.setResource(globalResource);\n        }\n        validateApplicationResource(comp.getResource(), comp,\n            comp.getArtifact().getType());\n\n        // container count\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          comp.setNumberOfContainers(globalNumberOfContainers);\n        }\n        if (comp.getNumberOfContainers() \u003d\u003d null\n            || comp.getNumberOfContainers() \u003c 0) {\n          throw new IllegalArgumentException(String.format(\n              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID\n                  + \": \" + comp.getNumberOfContainers(), comp.getName()));\n        }\n        validateConfigFile(comp.getConfiguration().getFiles(), fs);\n      }\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {
            "oldValue": "validateApplicationPostPayload",
            "newValue": "validateApplicationPayload"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6405. Improve configuring services through REST API. Contributed by Jian He\n",
          "commitDate": "06/11/17 1:28 PM",
          "commitName": "845764da146e98927e8ea5b2209f19f4fc3feda5",
          "commitAuthor": "Billie Rinaldi",
          "commitDateOld": "06/11/17 1:28 PM",
          "commitNameOld": "c31cd981ebabc0747cabcc07a8c8797619ed2c53",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,97 +1,102 @@\n-  public static void validateApplicationPostPayload(Application application) {\n+  public static void validateApplicationPayload(Application application,\n+      FileSystem fs) throws IOException {\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n     }\n \n     // If the application has no components do top-level checks\n     if (!hasComponent(application)) {\n       // artifact\n       if (application.getArtifact() \u003d\u003d null) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n       }\n       if (StringUtils.isEmpty(application.getArtifact().getId())) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n       }\n \n       // If artifact is of type APPLICATION, add a slider specific property\n       if (application.getArtifact().getType()\n           \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (application.getConfiguration() \u003d\u003d null) {\n           application.setConfiguration(new Configuration());\n         }\n       }\n       // resource\n       validateApplicationResource(application.getResource(), null,\n           application.getArtifact().getType());\n \n       // container size\n-      if (application.getNumberOfContainers() \u003d\u003d null) {\n+      if (application.getNumberOfContainers() \u003d\u003d null\n+          || application.getNumberOfContainers() \u003c 0) {\n         throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID);\n+            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID + \": \"\n+                + application.getNumberOfContainers());\n       }\n-\n+      validateConfigFile(application.getConfiguration().getFiles(), fs);\n       // Since it is a simple app with no components, create a default component\n       application.getComponents().add(createDefaultComponent(application));\n     } else {\n       // If the application has components, then run checks for each component.\n       // Let global values take effect if component level values are not\n       // provided.\n       Artifact globalArtifact \u003d application.getArtifact();\n       Resource globalResource \u003d application.getResource();\n       Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n       for (Component comp : application.getComponents()) {\n         // artifact\n         if (comp.getArtifact() \u003d\u003d null) {\n           comp.setArtifact(globalArtifact);\n         }\n         // If still null raise validation exception\n         if (comp.getArtifact() \u003d\u003d null) {\n           throw new IllegalArgumentException(String\n               .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n                   comp.getName()));\n         }\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(String\n               .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n                   comp.getName()));\n         }\n \n         // If artifact is of type APPLICATION, add a slider specific property\n         if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n           if (comp.getConfiguration() \u003d\u003d null) {\n             comp.setConfiguration(new Configuration());\n           }\n           comp.setName(comp.getArtifact().getId());\n         }\n \n         // resource\n         if (comp.getResource() \u003d\u003d null) {\n           comp.setResource(globalResource);\n         }\n         validateApplicationResource(comp.getResource(), comp,\n             comp.getArtifact().getType());\n \n         // container count\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           comp.setNumberOfContainers(globalNumberOfContainers);\n         }\n-        if (comp.getNumberOfContainers() \u003d\u003d null) {\n+        if (comp.getNumberOfContainers() \u003d\u003d null\n+            || comp.getNumberOfContainers() \u003c 0) {\n           throw new IllegalArgumentException(String.format(\n-              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID,\n-              comp.getName()));\n+              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID\n+                  + \": \" + comp.getNumberOfContainers(), comp.getName()));\n         }\n+        validateConfigFile(comp.getConfiguration().getFiles(), fs);\n       }\n     }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateApplicationPayload(Application application,\n      FileSystem fs) throws IOException {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // artifact\n      if (application.getArtifact() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n      }\n      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n      }\n\n      // If artifact is of type APPLICATION, add a slider specific property\n      if (application.getArtifact().getType()\n          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (application.getConfiguration() \u003d\u003d null) {\n          application.setConfiguration(new Configuration());\n        }\n      }\n      // resource\n      validateApplicationResource(application.getResource(), null,\n          application.getArtifact().getType());\n\n      // container size\n      if (application.getNumberOfContainers() \u003d\u003d null\n          || application.getNumberOfContainers() \u003c 0) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID + \": \"\n                + application.getNumberOfContainers());\n      }\n      validateConfigFile(application.getConfiguration().getFiles(), fs);\n      // Since it is a simple app with no components, create a default component\n      application.getComponents().add(createDefaultComponent(application));\n    } else {\n      // If the application has components, then run checks for each component.\n      // Let global values take effect if component level values are not\n      // provided.\n      Artifact globalArtifact \u003d application.getArtifact();\n      Resource globalResource \u003d application.getResource();\n      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n      for (Component comp : application.getComponents()) {\n        // artifact\n        if (comp.getArtifact() \u003d\u003d null) {\n          comp.setArtifact(globalArtifact);\n        }\n        // If still null raise validation exception\n        if (comp.getArtifact() \u003d\u003d null) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n\n        // If artifact is of type APPLICATION, add a slider specific property\n        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n          if (comp.getConfiguration() \u003d\u003d null) {\n            comp.setConfiguration(new Configuration());\n          }\n          comp.setName(comp.getArtifact().getId());\n        }\n\n        // resource\n        if (comp.getResource() \u003d\u003d null) {\n          comp.setResource(globalResource);\n        }\n        validateApplicationResource(comp.getResource(), comp,\n            comp.getArtifact().getType());\n\n        // container count\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          comp.setNumberOfContainers(globalNumberOfContainers);\n        }\n        if (comp.getNumberOfContainers() \u003d\u003d null\n            || comp.getNumberOfContainers() \u003c 0) {\n          throw new IllegalArgumentException(String.format(\n              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID\n                  + \": \" + comp.getNumberOfContainers(), comp.getName()));\n        }\n        validateConfigFile(comp.getConfiguration().getFiles(), fs);\n      }\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {
            "oldValue": "[application-Application]",
            "newValue": "[application-Application, fs-FileSystem]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-6405. Improve configuring services through REST API. Contributed by Jian He\n",
          "commitDate": "06/11/17 1:28 PM",
          "commitName": "845764da146e98927e8ea5b2209f19f4fc3feda5",
          "commitAuthor": "Billie Rinaldi",
          "commitDateOld": "06/11/17 1:28 PM",
          "commitNameOld": "c31cd981ebabc0747cabcc07a8c8797619ed2c53",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,97 +1,102 @@\n-  public static void validateApplicationPostPayload(Application application) {\n+  public static void validateApplicationPayload(Application application,\n+      FileSystem fs) throws IOException {\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n     }\n \n     // If the application has no components do top-level checks\n     if (!hasComponent(application)) {\n       // artifact\n       if (application.getArtifact() \u003d\u003d null) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n       }\n       if (StringUtils.isEmpty(application.getArtifact().getId())) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n       }\n \n       // If artifact is of type APPLICATION, add a slider specific property\n       if (application.getArtifact().getType()\n           \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (application.getConfiguration() \u003d\u003d null) {\n           application.setConfiguration(new Configuration());\n         }\n       }\n       // resource\n       validateApplicationResource(application.getResource(), null,\n           application.getArtifact().getType());\n \n       // container size\n-      if (application.getNumberOfContainers() \u003d\u003d null) {\n+      if (application.getNumberOfContainers() \u003d\u003d null\n+          || application.getNumberOfContainers() \u003c 0) {\n         throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID);\n+            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID + \": \"\n+                + application.getNumberOfContainers());\n       }\n-\n+      validateConfigFile(application.getConfiguration().getFiles(), fs);\n       // Since it is a simple app with no components, create a default component\n       application.getComponents().add(createDefaultComponent(application));\n     } else {\n       // If the application has components, then run checks for each component.\n       // Let global values take effect if component level values are not\n       // provided.\n       Artifact globalArtifact \u003d application.getArtifact();\n       Resource globalResource \u003d application.getResource();\n       Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n       for (Component comp : application.getComponents()) {\n         // artifact\n         if (comp.getArtifact() \u003d\u003d null) {\n           comp.setArtifact(globalArtifact);\n         }\n         // If still null raise validation exception\n         if (comp.getArtifact() \u003d\u003d null) {\n           throw new IllegalArgumentException(String\n               .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n                   comp.getName()));\n         }\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(String\n               .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n                   comp.getName()));\n         }\n \n         // If artifact is of type APPLICATION, add a slider specific property\n         if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n           if (comp.getConfiguration() \u003d\u003d null) {\n             comp.setConfiguration(new Configuration());\n           }\n           comp.setName(comp.getArtifact().getId());\n         }\n \n         // resource\n         if (comp.getResource() \u003d\u003d null) {\n           comp.setResource(globalResource);\n         }\n         validateApplicationResource(comp.getResource(), comp,\n             comp.getArtifact().getType());\n \n         // container count\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           comp.setNumberOfContainers(globalNumberOfContainers);\n         }\n-        if (comp.getNumberOfContainers() \u003d\u003d null) {\n+        if (comp.getNumberOfContainers() \u003d\u003d null\n+            || comp.getNumberOfContainers() \u003c 0) {\n           throw new IllegalArgumentException(String.format(\n-              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID,\n-              comp.getName()));\n+              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID\n+                  + \": \" + comp.getNumberOfContainers(), comp.getName()));\n         }\n+        validateConfigFile(comp.getConfiguration().getFiles(), fs);\n       }\n     }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateApplicationPayload(Application application,\n      FileSystem fs) throws IOException {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // artifact\n      if (application.getArtifact() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n      }\n      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n      }\n\n      // If artifact is of type APPLICATION, add a slider specific property\n      if (application.getArtifact().getType()\n          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (application.getConfiguration() \u003d\u003d null) {\n          application.setConfiguration(new Configuration());\n        }\n      }\n      // resource\n      validateApplicationResource(application.getResource(), null,\n          application.getArtifact().getType());\n\n      // container size\n      if (application.getNumberOfContainers() \u003d\u003d null\n          || application.getNumberOfContainers() \u003c 0) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID + \": \"\n                + application.getNumberOfContainers());\n      }\n      validateConfigFile(application.getConfiguration().getFiles(), fs);\n      // Since it is a simple app with no components, create a default component\n      application.getComponents().add(createDefaultComponent(application));\n    } else {\n      // If the application has components, then run checks for each component.\n      // Let global values take effect if component level values are not\n      // provided.\n      Artifact globalArtifact \u003d application.getArtifact();\n      Resource globalResource \u003d application.getResource();\n      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n      for (Component comp : application.getComponents()) {\n        // artifact\n        if (comp.getArtifact() \u003d\u003d null) {\n          comp.setArtifact(globalArtifact);\n        }\n        // If still null raise validation exception\n        if (comp.getArtifact() \u003d\u003d null) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n\n        // If artifact is of type APPLICATION, add a slider specific property\n        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n          if (comp.getConfiguration() \u003d\u003d null) {\n            comp.setConfiguration(new Configuration());\n          }\n          comp.setName(comp.getArtifact().getId());\n        }\n\n        // resource\n        if (comp.getResource() \u003d\u003d null) {\n          comp.setResource(globalResource);\n        }\n        validateApplicationResource(comp.getResource(), comp,\n            comp.getArtifact().getType());\n\n        // container count\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          comp.setNumberOfContainers(globalNumberOfContainers);\n        }\n        if (comp.getNumberOfContainers() \u003d\u003d null\n            || comp.getNumberOfContainers() \u003c 0) {\n          throw new IllegalArgumentException(String.format(\n              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID\n                  + \": \" + comp.getNumberOfContainers(), comp.getName()));\n        }\n        validateConfigFile(comp.getConfiguration().getFiles(), fs);\n      }\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6405. Improve configuring services through REST API. Contributed by Jian He\n",
          "commitDate": "06/11/17 1:28 PM",
          "commitName": "845764da146e98927e8ea5b2209f19f4fc3feda5",
          "commitAuthor": "Billie Rinaldi",
          "commitDateOld": "06/11/17 1:28 PM",
          "commitNameOld": "c31cd981ebabc0747cabcc07a8c8797619ed2c53",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,97 +1,102 @@\n-  public static void validateApplicationPostPayload(Application application) {\n+  public static void validateApplicationPayload(Application application,\n+      FileSystem fs) throws IOException {\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n       throw new IllegalArgumentException(\n           RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n     }\n \n     // If the application has no components do top-level checks\n     if (!hasComponent(application)) {\n       // artifact\n       if (application.getArtifact() \u003d\u003d null) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n       }\n       if (StringUtils.isEmpty(application.getArtifact().getId())) {\n         throw new IllegalArgumentException(\n             RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n       }\n \n       // If artifact is of type APPLICATION, add a slider specific property\n       if (application.getArtifact().getType()\n           \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (application.getConfiguration() \u003d\u003d null) {\n           application.setConfiguration(new Configuration());\n         }\n       }\n       // resource\n       validateApplicationResource(application.getResource(), null,\n           application.getArtifact().getType());\n \n       // container size\n-      if (application.getNumberOfContainers() \u003d\u003d null) {\n+      if (application.getNumberOfContainers() \u003d\u003d null\n+          || application.getNumberOfContainers() \u003c 0) {\n         throw new IllegalArgumentException(\n-            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID);\n+            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID + \": \"\n+                + application.getNumberOfContainers());\n       }\n-\n+      validateConfigFile(application.getConfiguration().getFiles(), fs);\n       // Since it is a simple app with no components, create a default component\n       application.getComponents().add(createDefaultComponent(application));\n     } else {\n       // If the application has components, then run checks for each component.\n       // Let global values take effect if component level values are not\n       // provided.\n       Artifact globalArtifact \u003d application.getArtifact();\n       Resource globalResource \u003d application.getResource();\n       Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n       for (Component comp : application.getComponents()) {\n         // artifact\n         if (comp.getArtifact() \u003d\u003d null) {\n           comp.setArtifact(globalArtifact);\n         }\n         // If still null raise validation exception\n         if (comp.getArtifact() \u003d\u003d null) {\n           throw new IllegalArgumentException(String\n               .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n                   comp.getName()));\n         }\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(String\n               .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n                   comp.getName()));\n         }\n \n         // If artifact is of type APPLICATION, add a slider specific property\n         if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n           if (comp.getConfiguration() \u003d\u003d null) {\n             comp.setConfiguration(new Configuration());\n           }\n           comp.setName(comp.getArtifact().getId());\n         }\n \n         // resource\n         if (comp.getResource() \u003d\u003d null) {\n           comp.setResource(globalResource);\n         }\n         validateApplicationResource(comp.getResource(), comp,\n             comp.getArtifact().getType());\n \n         // container count\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           comp.setNumberOfContainers(globalNumberOfContainers);\n         }\n-        if (comp.getNumberOfContainers() \u003d\u003d null) {\n+        if (comp.getNumberOfContainers() \u003d\u003d null\n+            || comp.getNumberOfContainers() \u003c 0) {\n           throw new IllegalArgumentException(String.format(\n-              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID,\n-              comp.getName()));\n+              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID\n+                  + \": \" + comp.getNumberOfContainers(), comp.getName()));\n         }\n+        validateConfigFile(comp.getConfiguration().getFiles(), fs);\n       }\n     }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateApplicationPayload(Application application,\n      FileSystem fs) throws IOException {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // artifact\n      if (application.getArtifact() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n      }\n      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n      }\n\n      // If artifact is of type APPLICATION, add a slider specific property\n      if (application.getArtifact().getType()\n          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (application.getConfiguration() \u003d\u003d null) {\n          application.setConfiguration(new Configuration());\n        }\n      }\n      // resource\n      validateApplicationResource(application.getResource(), null,\n          application.getArtifact().getType());\n\n      // container size\n      if (application.getNumberOfContainers() \u003d\u003d null\n          || application.getNumberOfContainers() \u003c 0) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID + \": \"\n                + application.getNumberOfContainers());\n      }\n      validateConfigFile(application.getConfiguration().getFiles(), fs);\n      // Since it is a simple app with no components, create a default component\n      application.getComponents().add(createDefaultComponent(application));\n    } else {\n      // If the application has components, then run checks for each component.\n      // Let global values take effect if component level values are not\n      // provided.\n      Artifact globalArtifact \u003d application.getArtifact();\n      Resource globalResource \u003d application.getResource();\n      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n      for (Component comp : application.getComponents()) {\n        // artifact\n        if (comp.getArtifact() \u003d\u003d null) {\n          comp.setArtifact(globalArtifact);\n        }\n        // If still null raise validation exception\n        if (comp.getArtifact() \u003d\u003d null) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n\n        // If artifact is of type APPLICATION, add a slider specific property\n        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n          if (comp.getConfiguration() \u003d\u003d null) {\n            comp.setConfiguration(new Configuration());\n          }\n          comp.setName(comp.getArtifact().getId());\n        }\n\n        // resource\n        if (comp.getResource() \u003d\u003d null) {\n          comp.setResource(globalResource);\n        }\n        validateApplicationResource(comp.getResource(), comp,\n            comp.getArtifact().getType());\n\n        // container count\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          comp.setNumberOfContainers(globalNumberOfContainers);\n        }\n        if (comp.getNumberOfContainers() \u003d\u003d null\n            || comp.getNumberOfContainers() \u003c 0) {\n          throw new IllegalArgumentException(String.format(\n              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID\n                  + \": \" + comp.getNumberOfContainers(), comp.getName()));\n        }\n        validateConfigFile(comp.getConfiguration().getFiles(), fs);\n      }\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {}
        }
      ]
    },
    "c31cd981ebabc0747cabcc07a8c8797619ed2c53": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "YARN-6255. Refactor yarn-native-services framework. Contributed by Jian He\n",
      "commitDate": "06/11/17 1:28 PM",
      "commitName": "c31cd981ebabc0747cabcc07a8c8797619ed2c53",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-6255. Refactor yarn-native-services framework. Contributed by Jian He\n",
          "commitDate": "06/11/17 1:28 PM",
          "commitName": "c31cd981ebabc0747cabcc07a8c8797619ed2c53",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/11/17 1:28 PM",
          "commitNameOld": "024e90a50838f19e92630902d7af21ad30b5772c",
          "commitAuthorOld": "Billie Rinaldi",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,97 +1,97 @@\n-  protected void validateApplicationPostPayload(Application application,\n-      Map\u003cString, String\u003e compNameArtifactIdMap) {\n+  public static void validateApplicationPostPayload(Application application) {\n     if (StringUtils.isEmpty(application.getName())) {\n-      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID);\n+      throw new IllegalArgumentException(\n+          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n-      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID_FORMAT);\n+      throw new IllegalArgumentException(\n+          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n     }\n \n     // If the application has no components do top-level checks\n-    if (application.getComponents() \u003d\u003d null\n-        || application.getComponents().size() \u003d\u003d 0) {\n+    if (!hasComponent(application)) {\n       // artifact\n       if (application.getArtifact() \u003d\u003d null) {\n-        throw new IllegalArgumentException(ERROR_ARTIFACT_INVALID);\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n       }\n       if (StringUtils.isEmpty(application.getArtifact().getId())) {\n-        throw new IllegalArgumentException(ERROR_ARTIFACT_ID_INVALID);\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n       }\n \n       // If artifact is of type APPLICATION, add a slider specific property\n-      if (application.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n+      if (application.getArtifact().getType()\n+          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (application.getConfiguration() \u003d\u003d null) {\n           application.setConfiguration(new Configuration());\n         }\n-        addPropertyToConfiguration(application.getConfiguration(),\n-            SliderKeys.COMPONENT_TYPE_KEY,\n-            SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n       }\n       // resource\n-      validateApplicationResource(application.getResource(), null, application\n-          .getArtifact().getType());\n+      validateApplicationResource(application.getResource(), null,\n+          application.getArtifact().getType());\n \n       // container size\n       if (application.getNumberOfContainers() \u003d\u003d null) {\n-        throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID);\n       }\n \n       // Since it is a simple app with no components, create a default component\n-      application.setComponents(getDefaultComponentAsList(application));\n+      application.getComponents().add(createDefaultComponent(application));\n     } else {\n       // If the application has components, then run checks for each component.\n       // Let global values take effect if component level values are not\n       // provided.\n       Artifact globalArtifact \u003d application.getArtifact();\n       Resource globalResource \u003d application.getResource();\n       Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n       for (Component comp : application.getComponents()) {\n         // artifact\n         if (comp.getArtifact() \u003d\u003d null) {\n           comp.setArtifact(globalArtifact);\n         }\n         // If still null raise validation exception\n         if (comp.getArtifact() \u003d\u003d null) {\n-          throw new IllegalArgumentException(String.format(\n-              ERROR_ARTIFACT_FOR_COMP_INVALID, comp.getName()));\n+          throw new IllegalArgumentException(String\n+              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n+                  comp.getName()));\n         }\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n-          throw new IllegalArgumentException(String.format(\n-              ERROR_ARTIFACT_ID_FOR_COMP_INVALID, comp.getName()));\n+          throw new IllegalArgumentException(String\n+              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n+                  comp.getName()));\n         }\n \n         // If artifact is of type APPLICATION, add a slider specific property\n         if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n           if (comp.getConfiguration() \u003d\u003d null) {\n             comp.setConfiguration(new Configuration());\n           }\n-          addPropertyToConfiguration(comp.getConfiguration(),\n-              SliderKeys.COMPONENT_TYPE_KEY,\n-              SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n-          compNameArtifactIdMap.put(comp.getName(), comp.getArtifact().getId());\n           comp.setName(comp.getArtifact().getId());\n         }\n \n         // resource\n         if (comp.getResource() \u003d\u003d null) {\n           comp.setResource(globalResource);\n         }\n-        validateApplicationResource(comp.getResource(), comp, comp\n-            .getArtifact().getType());\n+        validateApplicationResource(comp.getResource(), comp,\n+            comp.getArtifact().getType());\n \n         // container count\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           comp.setNumberOfContainers(globalNumberOfContainers);\n         }\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           throw new IllegalArgumentException(String.format(\n-              ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID, comp.getName()));\n+              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID,\n+              comp.getName()));\n         }\n       }\n     }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n-      application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);\n+      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateApplicationPostPayload(Application application) {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // artifact\n      if (application.getArtifact() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n      }\n      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n      }\n\n      // If artifact is of type APPLICATION, add a slider specific property\n      if (application.getArtifact().getType()\n          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (application.getConfiguration() \u003d\u003d null) {\n          application.setConfiguration(new Configuration());\n        }\n      }\n      // resource\n      validateApplicationResource(application.getResource(), null,\n          application.getArtifact().getType());\n\n      // container size\n      if (application.getNumberOfContainers() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID);\n      }\n\n      // Since it is a simple app with no components, create a default component\n      application.getComponents().add(createDefaultComponent(application));\n    } else {\n      // If the application has components, then run checks for each component.\n      // Let global values take effect if component level values are not\n      // provided.\n      Artifact globalArtifact \u003d application.getArtifact();\n      Resource globalResource \u003d application.getResource();\n      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n      for (Component comp : application.getComponents()) {\n        // artifact\n        if (comp.getArtifact() \u003d\u003d null) {\n          comp.setArtifact(globalArtifact);\n        }\n        // If still null raise validation exception\n        if (comp.getArtifact() \u003d\u003d null) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n\n        // If artifact is of type APPLICATION, add a slider specific property\n        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n          if (comp.getConfiguration() \u003d\u003d null) {\n            comp.setConfiguration(new Configuration());\n          }\n          comp.setName(comp.getArtifact().getId());\n        }\n\n        // resource\n        if (comp.getResource() \u003d\u003d null) {\n          comp.setResource(globalResource);\n        }\n        validateApplicationResource(comp.getResource(), comp,\n            comp.getArtifact().getType());\n\n        // container count\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          comp.setNumberOfContainers(globalNumberOfContainers);\n        }\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          throw new IllegalArgumentException(String.format(\n              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID,\n              comp.getName()));\n        }\n      }\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/services/api/impl/ApplicationApiService.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
            "oldMethodName": "validateApplicationPostPayload",
            "newMethodName": "validateApplicationPostPayload"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-6255. Refactor yarn-native-services framework. Contributed by Jian He\n",
          "commitDate": "06/11/17 1:28 PM",
          "commitName": "c31cd981ebabc0747cabcc07a8c8797619ed2c53",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/11/17 1:28 PM",
          "commitNameOld": "024e90a50838f19e92630902d7af21ad30b5772c",
          "commitAuthorOld": "Billie Rinaldi",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,97 +1,97 @@\n-  protected void validateApplicationPostPayload(Application application,\n-      Map\u003cString, String\u003e compNameArtifactIdMap) {\n+  public static void validateApplicationPostPayload(Application application) {\n     if (StringUtils.isEmpty(application.getName())) {\n-      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID);\n+      throw new IllegalArgumentException(\n+          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n-      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID_FORMAT);\n+      throw new IllegalArgumentException(\n+          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n     }\n \n     // If the application has no components do top-level checks\n-    if (application.getComponents() \u003d\u003d null\n-        || application.getComponents().size() \u003d\u003d 0) {\n+    if (!hasComponent(application)) {\n       // artifact\n       if (application.getArtifact() \u003d\u003d null) {\n-        throw new IllegalArgumentException(ERROR_ARTIFACT_INVALID);\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n       }\n       if (StringUtils.isEmpty(application.getArtifact().getId())) {\n-        throw new IllegalArgumentException(ERROR_ARTIFACT_ID_INVALID);\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n       }\n \n       // If artifact is of type APPLICATION, add a slider specific property\n-      if (application.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n+      if (application.getArtifact().getType()\n+          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (application.getConfiguration() \u003d\u003d null) {\n           application.setConfiguration(new Configuration());\n         }\n-        addPropertyToConfiguration(application.getConfiguration(),\n-            SliderKeys.COMPONENT_TYPE_KEY,\n-            SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n       }\n       // resource\n-      validateApplicationResource(application.getResource(), null, application\n-          .getArtifact().getType());\n+      validateApplicationResource(application.getResource(), null,\n+          application.getArtifact().getType());\n \n       // container size\n       if (application.getNumberOfContainers() \u003d\u003d null) {\n-        throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID);\n       }\n \n       // Since it is a simple app with no components, create a default component\n-      application.setComponents(getDefaultComponentAsList(application));\n+      application.getComponents().add(createDefaultComponent(application));\n     } else {\n       // If the application has components, then run checks for each component.\n       // Let global values take effect if component level values are not\n       // provided.\n       Artifact globalArtifact \u003d application.getArtifact();\n       Resource globalResource \u003d application.getResource();\n       Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n       for (Component comp : application.getComponents()) {\n         // artifact\n         if (comp.getArtifact() \u003d\u003d null) {\n           comp.setArtifact(globalArtifact);\n         }\n         // If still null raise validation exception\n         if (comp.getArtifact() \u003d\u003d null) {\n-          throw new IllegalArgumentException(String.format(\n-              ERROR_ARTIFACT_FOR_COMP_INVALID, comp.getName()));\n+          throw new IllegalArgumentException(String\n+              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n+                  comp.getName()));\n         }\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n-          throw new IllegalArgumentException(String.format(\n-              ERROR_ARTIFACT_ID_FOR_COMP_INVALID, comp.getName()));\n+          throw new IllegalArgumentException(String\n+              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n+                  comp.getName()));\n         }\n \n         // If artifact is of type APPLICATION, add a slider specific property\n         if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n           if (comp.getConfiguration() \u003d\u003d null) {\n             comp.setConfiguration(new Configuration());\n           }\n-          addPropertyToConfiguration(comp.getConfiguration(),\n-              SliderKeys.COMPONENT_TYPE_KEY,\n-              SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n-          compNameArtifactIdMap.put(comp.getName(), comp.getArtifact().getId());\n           comp.setName(comp.getArtifact().getId());\n         }\n \n         // resource\n         if (comp.getResource() \u003d\u003d null) {\n           comp.setResource(globalResource);\n         }\n-        validateApplicationResource(comp.getResource(), comp, comp\n-            .getArtifact().getType());\n+        validateApplicationResource(comp.getResource(), comp,\n+            comp.getArtifact().getType());\n \n         // container count\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           comp.setNumberOfContainers(globalNumberOfContainers);\n         }\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           throw new IllegalArgumentException(String.format(\n-              ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID, comp.getName()));\n+              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID,\n+              comp.getName()));\n         }\n       }\n     }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n-      application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);\n+      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateApplicationPostPayload(Application application) {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // artifact\n      if (application.getArtifact() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n      }\n      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n      }\n\n      // If artifact is of type APPLICATION, add a slider specific property\n      if (application.getArtifact().getType()\n          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (application.getConfiguration() \u003d\u003d null) {\n          application.setConfiguration(new Configuration());\n        }\n      }\n      // resource\n      validateApplicationResource(application.getResource(), null,\n          application.getArtifact().getType());\n\n      // container size\n      if (application.getNumberOfContainers() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID);\n      }\n\n      // Since it is a simple app with no components, create a default component\n      application.getComponents().add(createDefaultComponent(application));\n    } else {\n      // If the application has components, then run checks for each component.\n      // Let global values take effect if component level values are not\n      // provided.\n      Artifact globalArtifact \u003d application.getArtifact();\n      Resource globalResource \u003d application.getResource();\n      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n      for (Component comp : application.getComponents()) {\n        // artifact\n        if (comp.getArtifact() \u003d\u003d null) {\n          comp.setArtifact(globalArtifact);\n        }\n        // If still null raise validation exception\n        if (comp.getArtifact() \u003d\u003d null) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n\n        // If artifact is of type APPLICATION, add a slider specific property\n        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n          if (comp.getConfiguration() \u003d\u003d null) {\n            comp.setConfiguration(new Configuration());\n          }\n          comp.setName(comp.getArtifact().getId());\n        }\n\n        // resource\n        if (comp.getResource() \u003d\u003d null) {\n          comp.setResource(globalResource);\n        }\n        validateApplicationResource(comp.getResource(), comp,\n            comp.getArtifact().getType());\n\n        // container count\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          comp.setNumberOfContainers(globalNumberOfContainers);\n        }\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          throw new IllegalArgumentException(String.format(\n              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID,\n              comp.getName()));\n        }\n      }\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[public, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6255. Refactor yarn-native-services framework. Contributed by Jian He\n",
          "commitDate": "06/11/17 1:28 PM",
          "commitName": "c31cd981ebabc0747cabcc07a8c8797619ed2c53",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/11/17 1:28 PM",
          "commitNameOld": "024e90a50838f19e92630902d7af21ad30b5772c",
          "commitAuthorOld": "Billie Rinaldi",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,97 +1,97 @@\n-  protected void validateApplicationPostPayload(Application application,\n-      Map\u003cString, String\u003e compNameArtifactIdMap) {\n+  public static void validateApplicationPostPayload(Application application) {\n     if (StringUtils.isEmpty(application.getName())) {\n-      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID);\n+      throw new IllegalArgumentException(\n+          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n-      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID_FORMAT);\n+      throw new IllegalArgumentException(\n+          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n     }\n \n     // If the application has no components do top-level checks\n-    if (application.getComponents() \u003d\u003d null\n-        || application.getComponents().size() \u003d\u003d 0) {\n+    if (!hasComponent(application)) {\n       // artifact\n       if (application.getArtifact() \u003d\u003d null) {\n-        throw new IllegalArgumentException(ERROR_ARTIFACT_INVALID);\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n       }\n       if (StringUtils.isEmpty(application.getArtifact().getId())) {\n-        throw new IllegalArgumentException(ERROR_ARTIFACT_ID_INVALID);\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n       }\n \n       // If artifact is of type APPLICATION, add a slider specific property\n-      if (application.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n+      if (application.getArtifact().getType()\n+          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (application.getConfiguration() \u003d\u003d null) {\n           application.setConfiguration(new Configuration());\n         }\n-        addPropertyToConfiguration(application.getConfiguration(),\n-            SliderKeys.COMPONENT_TYPE_KEY,\n-            SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n       }\n       // resource\n-      validateApplicationResource(application.getResource(), null, application\n-          .getArtifact().getType());\n+      validateApplicationResource(application.getResource(), null,\n+          application.getArtifact().getType());\n \n       // container size\n       if (application.getNumberOfContainers() \u003d\u003d null) {\n-        throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID);\n       }\n \n       // Since it is a simple app with no components, create a default component\n-      application.setComponents(getDefaultComponentAsList(application));\n+      application.getComponents().add(createDefaultComponent(application));\n     } else {\n       // If the application has components, then run checks for each component.\n       // Let global values take effect if component level values are not\n       // provided.\n       Artifact globalArtifact \u003d application.getArtifact();\n       Resource globalResource \u003d application.getResource();\n       Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n       for (Component comp : application.getComponents()) {\n         // artifact\n         if (comp.getArtifact() \u003d\u003d null) {\n           comp.setArtifact(globalArtifact);\n         }\n         // If still null raise validation exception\n         if (comp.getArtifact() \u003d\u003d null) {\n-          throw new IllegalArgumentException(String.format(\n-              ERROR_ARTIFACT_FOR_COMP_INVALID, comp.getName()));\n+          throw new IllegalArgumentException(String\n+              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n+                  comp.getName()));\n         }\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n-          throw new IllegalArgumentException(String.format(\n-              ERROR_ARTIFACT_ID_FOR_COMP_INVALID, comp.getName()));\n+          throw new IllegalArgumentException(String\n+              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n+                  comp.getName()));\n         }\n \n         // If artifact is of type APPLICATION, add a slider specific property\n         if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n           if (comp.getConfiguration() \u003d\u003d null) {\n             comp.setConfiguration(new Configuration());\n           }\n-          addPropertyToConfiguration(comp.getConfiguration(),\n-              SliderKeys.COMPONENT_TYPE_KEY,\n-              SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n-          compNameArtifactIdMap.put(comp.getName(), comp.getArtifact().getId());\n           comp.setName(comp.getArtifact().getId());\n         }\n \n         // resource\n         if (comp.getResource() \u003d\u003d null) {\n           comp.setResource(globalResource);\n         }\n-        validateApplicationResource(comp.getResource(), comp, comp\n-            .getArtifact().getType());\n+        validateApplicationResource(comp.getResource(), comp,\n+            comp.getArtifact().getType());\n \n         // container count\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           comp.setNumberOfContainers(globalNumberOfContainers);\n         }\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           throw new IllegalArgumentException(String.format(\n-              ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID, comp.getName()));\n+              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID,\n+              comp.getName()));\n         }\n       }\n     }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n-      application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);\n+      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateApplicationPostPayload(Application application) {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // artifact\n      if (application.getArtifact() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n      }\n      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n      }\n\n      // If artifact is of type APPLICATION, add a slider specific property\n      if (application.getArtifact().getType()\n          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (application.getConfiguration() \u003d\u003d null) {\n          application.setConfiguration(new Configuration());\n        }\n      }\n      // resource\n      validateApplicationResource(application.getResource(), null,\n          application.getArtifact().getType());\n\n      // container size\n      if (application.getNumberOfContainers() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID);\n      }\n\n      // Since it is a simple app with no components, create a default component\n      application.getComponents().add(createDefaultComponent(application));\n    } else {\n      // If the application has components, then run checks for each component.\n      // Let global values take effect if component level values are not\n      // provided.\n      Artifact globalArtifact \u003d application.getArtifact();\n      Resource globalResource \u003d application.getResource();\n      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n      for (Component comp : application.getComponents()) {\n        // artifact\n        if (comp.getArtifact() \u003d\u003d null) {\n          comp.setArtifact(globalArtifact);\n        }\n        // If still null raise validation exception\n        if (comp.getArtifact() \u003d\u003d null) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n\n        // If artifact is of type APPLICATION, add a slider specific property\n        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n          if (comp.getConfiguration() \u003d\u003d null) {\n            comp.setConfiguration(new Configuration());\n          }\n          comp.setName(comp.getArtifact().getId());\n        }\n\n        // resource\n        if (comp.getResource() \u003d\u003d null) {\n          comp.setResource(globalResource);\n        }\n        validateApplicationResource(comp.getResource(), comp,\n            comp.getArtifact().getType());\n\n        // container count\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          comp.setNumberOfContainers(globalNumberOfContainers);\n        }\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          throw new IllegalArgumentException(String.format(\n              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID,\n              comp.getName()));\n        }\n      }\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6255. Refactor yarn-native-services framework. Contributed by Jian He\n",
          "commitDate": "06/11/17 1:28 PM",
          "commitName": "c31cd981ebabc0747cabcc07a8c8797619ed2c53",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/11/17 1:28 PM",
          "commitNameOld": "024e90a50838f19e92630902d7af21ad30b5772c",
          "commitAuthorOld": "Billie Rinaldi",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,97 +1,97 @@\n-  protected void validateApplicationPostPayload(Application application,\n-      Map\u003cString, String\u003e compNameArtifactIdMap) {\n+  public static void validateApplicationPostPayload(Application application) {\n     if (StringUtils.isEmpty(application.getName())) {\n-      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID);\n+      throw new IllegalArgumentException(\n+          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n-      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID_FORMAT);\n+      throw new IllegalArgumentException(\n+          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n     }\n \n     // If the application has no components do top-level checks\n-    if (application.getComponents() \u003d\u003d null\n-        || application.getComponents().size() \u003d\u003d 0) {\n+    if (!hasComponent(application)) {\n       // artifact\n       if (application.getArtifact() \u003d\u003d null) {\n-        throw new IllegalArgumentException(ERROR_ARTIFACT_INVALID);\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n       }\n       if (StringUtils.isEmpty(application.getArtifact().getId())) {\n-        throw new IllegalArgumentException(ERROR_ARTIFACT_ID_INVALID);\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n       }\n \n       // If artifact is of type APPLICATION, add a slider specific property\n-      if (application.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n+      if (application.getArtifact().getType()\n+          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (application.getConfiguration() \u003d\u003d null) {\n           application.setConfiguration(new Configuration());\n         }\n-        addPropertyToConfiguration(application.getConfiguration(),\n-            SliderKeys.COMPONENT_TYPE_KEY,\n-            SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n       }\n       // resource\n-      validateApplicationResource(application.getResource(), null, application\n-          .getArtifact().getType());\n+      validateApplicationResource(application.getResource(), null,\n+          application.getArtifact().getType());\n \n       // container size\n       if (application.getNumberOfContainers() \u003d\u003d null) {\n-        throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);\n+        throw new IllegalArgumentException(\n+            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID);\n       }\n \n       // Since it is a simple app with no components, create a default component\n-      application.setComponents(getDefaultComponentAsList(application));\n+      application.getComponents().add(createDefaultComponent(application));\n     } else {\n       // If the application has components, then run checks for each component.\n       // Let global values take effect if component level values are not\n       // provided.\n       Artifact globalArtifact \u003d application.getArtifact();\n       Resource globalResource \u003d application.getResource();\n       Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n       for (Component comp : application.getComponents()) {\n         // artifact\n         if (comp.getArtifact() \u003d\u003d null) {\n           comp.setArtifact(globalArtifact);\n         }\n         // If still null raise validation exception\n         if (comp.getArtifact() \u003d\u003d null) {\n-          throw new IllegalArgumentException(String.format(\n-              ERROR_ARTIFACT_FOR_COMP_INVALID, comp.getName()));\n+          throw new IllegalArgumentException(String\n+              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n+                  comp.getName()));\n         }\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n-          throw new IllegalArgumentException(String.format(\n-              ERROR_ARTIFACT_ID_FOR_COMP_INVALID, comp.getName()));\n+          throw new IllegalArgumentException(String\n+              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n+                  comp.getName()));\n         }\n \n         // If artifact is of type APPLICATION, add a slider specific property\n         if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n           if (comp.getConfiguration() \u003d\u003d null) {\n             comp.setConfiguration(new Configuration());\n           }\n-          addPropertyToConfiguration(comp.getConfiguration(),\n-              SliderKeys.COMPONENT_TYPE_KEY,\n-              SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n-          compNameArtifactIdMap.put(comp.getName(), comp.getArtifact().getId());\n           comp.setName(comp.getArtifact().getId());\n         }\n \n         // resource\n         if (comp.getResource() \u003d\u003d null) {\n           comp.setResource(globalResource);\n         }\n-        validateApplicationResource(comp.getResource(), comp, comp\n-            .getArtifact().getType());\n+        validateApplicationResource(comp.getResource(), comp,\n+            comp.getArtifact().getType());\n \n         // container count\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           comp.setNumberOfContainers(globalNumberOfContainers);\n         }\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           throw new IllegalArgumentException(String.format(\n-              ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID, comp.getName()));\n+              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID,\n+              comp.getName()));\n         }\n       }\n     }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n-      application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);\n+      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void validateApplicationPostPayload(Application application) {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(\n          RestApiErrorMessages.ERROR_APPLICATION_NAME_INVALID_FORMAT);\n    }\n\n    // If the application has no components do top-level checks\n    if (!hasComponent(application)) {\n      // artifact\n      if (application.getArtifact() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_INVALID);\n      }\n      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_ARTIFACT_ID_INVALID);\n      }\n\n      // If artifact is of type APPLICATION, add a slider specific property\n      if (application.getArtifact().getType()\n          \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (application.getConfiguration() \u003d\u003d null) {\n          application.setConfiguration(new Configuration());\n        }\n      }\n      // resource\n      validateApplicationResource(application.getResource(), null,\n          application.getArtifact().getType());\n\n      // container size\n      if (application.getNumberOfContainers() \u003d\u003d null) {\n        throw new IllegalArgumentException(\n            RestApiErrorMessages.ERROR_CONTAINERS_COUNT_INVALID);\n      }\n\n      // Since it is a simple app with no components, create a default component\n      application.getComponents().add(createDefaultComponent(application));\n    } else {\n      // If the application has components, then run checks for each component.\n      // Let global values take effect if component level values are not\n      // provided.\n      Artifact globalArtifact \u003d application.getArtifact();\n      Resource globalResource \u003d application.getResource();\n      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n      for (Component comp : application.getComponents()) {\n        // artifact\n        if (comp.getArtifact() \u003d\u003d null) {\n          comp.setArtifact(globalArtifact);\n        }\n        // If still null raise validation exception\n        if (comp.getArtifact() \u003d\u003d null) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(String\n              .format(RestApiErrorMessages.ERROR_ARTIFACT_ID_FOR_COMP_INVALID,\n                  comp.getName()));\n        }\n\n        // If artifact is of type APPLICATION, add a slider specific property\n        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n          if (comp.getConfiguration() \u003d\u003d null) {\n            comp.setConfiguration(new Configuration());\n          }\n          comp.setName(comp.getArtifact().getId());\n        }\n\n        // resource\n        if (comp.getResource() \u003d\u003d null) {\n          comp.setResource(globalResource);\n        }\n        validateApplicationResource(comp.getResource(), comp,\n            comp.getArtifact().getType());\n\n        // container count\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          comp.setNumberOfContainers(globalNumberOfContainers);\n        }\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          throw new IllegalArgumentException(String.format(\n              RestApiErrorMessages.ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID,\n              comp.getName()));\n        }\n      }\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(RestApiConstants.DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-slider/hadoop-yarn-slider-core/src/main/java/org/apache/slider/util/ServiceApiUtil.java",
          "extendedDetails": {
            "oldValue": "[application-Application, compNameArtifactIdMap-Map\u003cString,String\u003e]",
            "newValue": "[application-Application]"
          }
        }
      ]
    },
    "ef5a3628c2428a1f8b0b17e1ff2aabe6820b63d5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5770. Performance improvement of native-services REST API service. Contributed by Gour Saha\n",
      "commitDate": "06/11/17 1:28 PM",
      "commitName": "ef5a3628c2428a1f8b0b17e1ff2aabe6820b63d5",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "06/11/17 1:28 PM",
      "commitNameOld": "4ec1cbe86dd9e72bcd2479046ea020d7dfa22794",
      "commitAuthorOld": "Gour Saha",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,97 @@\n   protected void validateApplicationPostPayload(Application application,\n       Map\u003cString, String\u003e compNameArtifactIdMap) {\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n       throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID_FORMAT);\n     }\n \n     // If the application has no components do top-level checks\n-    if (application.getComponents() \u003d\u003d null) {\n+    if (application.getComponents() \u003d\u003d null\n+        || application.getComponents().size() \u003d\u003d 0) {\n       // artifact\n       if (application.getArtifact() \u003d\u003d null) {\n         throw new IllegalArgumentException(ERROR_ARTIFACT_INVALID);\n       }\n       if (StringUtils.isEmpty(application.getArtifact().getId())) {\n         throw new IllegalArgumentException(ERROR_ARTIFACT_ID_INVALID);\n       }\n \n       // If artifact is of type APPLICATION, add a slider specific property\n       if (application.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (application.getConfiguration() \u003d\u003d null) {\n           application.setConfiguration(new Configuration());\n         }\n         addPropertyToConfiguration(application.getConfiguration(),\n             SliderKeys.COMPONENT_TYPE_KEY,\n             SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n       }\n       // resource\n       validateApplicationResource(application.getResource(), null, application\n           .getArtifact().getType());\n \n       // container size\n       if (application.getNumberOfContainers() \u003d\u003d null) {\n         throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);\n       }\n+\n+      // Since it is a simple app with no components, create a default component\n+      application.setComponents(getDefaultComponentAsList(application));\n     } else {\n       // If the application has components, then run checks for each component.\n       // Let global values take effect if component level values are not\n       // provided.\n       Artifact globalArtifact \u003d application.getArtifact();\n       Resource globalResource \u003d application.getResource();\n       Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n       for (Component comp : application.getComponents()) {\n         // artifact\n         if (comp.getArtifact() \u003d\u003d null) {\n           comp.setArtifact(globalArtifact);\n         }\n         // If still null raise validation exception\n         if (comp.getArtifact() \u003d\u003d null) {\n           throw new IllegalArgumentException(String.format(\n               ERROR_ARTIFACT_FOR_COMP_INVALID, comp.getName()));\n         }\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(String.format(\n               ERROR_ARTIFACT_ID_FOR_COMP_INVALID, comp.getName()));\n         }\n \n         // If artifact is of type APPLICATION, add a slider specific property\n         if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n           if (comp.getConfiguration() \u003d\u003d null) {\n             comp.setConfiguration(new Configuration());\n           }\n           addPropertyToConfiguration(comp.getConfiguration(),\n               SliderKeys.COMPONENT_TYPE_KEY,\n               SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n           compNameArtifactIdMap.put(comp.getName(), comp.getArtifact().getId());\n           comp.setName(comp.getArtifact().getId());\n         }\n \n         // resource\n         if (comp.getResource() \u003d\u003d null) {\n           comp.setResource(globalResource);\n         }\n         validateApplicationResource(comp.getResource(), comp, comp\n             .getArtifact().getType());\n \n         // container count\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           comp.setNumberOfContainers(globalNumberOfContainers);\n         }\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           throw new IllegalArgumentException(String.format(\n               ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID, comp.getName()));\n         }\n       }\n     }\n \n-    // If it is a simple app with no components, then create a default component\n-    if (application.getComponents() \u003d\u003d null) {\n-      application.setComponents(getDefaultComponentAsList(application));\n-    }\n-\n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void validateApplicationPostPayload(Application application,\n      Map\u003cString, String\u003e compNameArtifactIdMap) {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID_FORMAT);\n    }\n\n    // If the application has no components do top-level checks\n    if (application.getComponents() \u003d\u003d null\n        || application.getComponents().size() \u003d\u003d 0) {\n      // artifact\n      if (application.getArtifact() \u003d\u003d null) {\n        throw new IllegalArgumentException(ERROR_ARTIFACT_INVALID);\n      }\n      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n        throw new IllegalArgumentException(ERROR_ARTIFACT_ID_INVALID);\n      }\n\n      // If artifact is of type APPLICATION, add a slider specific property\n      if (application.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (application.getConfiguration() \u003d\u003d null) {\n          application.setConfiguration(new Configuration());\n        }\n        addPropertyToConfiguration(application.getConfiguration(),\n            SliderKeys.COMPONENT_TYPE_KEY,\n            SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n      }\n      // resource\n      validateApplicationResource(application.getResource(), null, application\n          .getArtifact().getType());\n\n      // container size\n      if (application.getNumberOfContainers() \u003d\u003d null) {\n        throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);\n      }\n\n      // Since it is a simple app with no components, create a default component\n      application.setComponents(getDefaultComponentAsList(application));\n    } else {\n      // If the application has components, then run checks for each component.\n      // Let global values take effect if component level values are not\n      // provided.\n      Artifact globalArtifact \u003d application.getArtifact();\n      Resource globalResource \u003d application.getResource();\n      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n      for (Component comp : application.getComponents()) {\n        // artifact\n        if (comp.getArtifact() \u003d\u003d null) {\n          comp.setArtifact(globalArtifact);\n        }\n        // If still null raise validation exception\n        if (comp.getArtifact() \u003d\u003d null) {\n          throw new IllegalArgumentException(String.format(\n              ERROR_ARTIFACT_FOR_COMP_INVALID, comp.getName()));\n        }\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(String.format(\n              ERROR_ARTIFACT_ID_FOR_COMP_INVALID, comp.getName()));\n        }\n\n        // If artifact is of type APPLICATION, add a slider specific property\n        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n          if (comp.getConfiguration() \u003d\u003d null) {\n            comp.setConfiguration(new Configuration());\n          }\n          addPropertyToConfiguration(comp.getConfiguration(),\n              SliderKeys.COMPONENT_TYPE_KEY,\n              SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n          compNameArtifactIdMap.put(comp.getName(), comp.getArtifact().getId());\n          comp.setName(comp.getArtifact().getId());\n        }\n\n        // resource\n        if (comp.getResource() \u003d\u003d null) {\n          comp.setResource(globalResource);\n        }\n        validateApplicationResource(comp.getResource(), comp, comp\n            .getArtifact().getType());\n\n        // container count\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          comp.setNumberOfContainers(globalNumberOfContainers);\n        }\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          throw new IllegalArgumentException(String.format(\n              ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID, comp.getName()));\n        }\n      }\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/services/api/impl/ApplicationApiService.java",
      "extendedDetails": {}
    },
    "7da243ebe05be27ade86feac83a6243eebba619c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5729. Bug fixes for the service Rest API. Contributed by Gour Saha\n",
      "commitDate": "06/11/17 1:28 PM",
      "commitName": "7da243ebe05be27ade86feac83a6243eebba619c",
      "commitAuthor": "Jian He",
      "commitDateOld": "06/11/17 1:28 PM",
      "commitNameOld": "c0120e51b944f86de4d533bcbc59f715047b9ea9",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n   protected void validateApplicationPostPayload(Application application,\n       Map\u003cString, String\u003e compNameArtifactIdMap) {\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n       throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID_FORMAT);\n     }\n \n     // If the application has no components do top-level checks\n     if (application.getComponents() \u003d\u003d null) {\n       // artifact\n       if (application.getArtifact() \u003d\u003d null) {\n         throw new IllegalArgumentException(ERROR_ARTIFACT_INVALID);\n       }\n       if (StringUtils.isEmpty(application.getArtifact().getId())) {\n         throw new IllegalArgumentException(ERROR_ARTIFACT_ID_INVALID);\n       }\n \n       // If artifact is of type APPLICATION, add a slider specific property\n       if (application.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (application.getConfiguration() \u003d\u003d null) {\n           application.setConfiguration(new Configuration());\n         }\n         addPropertyToConfiguration(application.getConfiguration(),\n             SliderKeys.COMPONENT_TYPE_KEY,\n             SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n       }\n       // resource\n       validateApplicationResource(application.getResource(), null, application\n           .getArtifact().getType());\n \n       // container size\n       if (application.getNumberOfContainers() \u003d\u003d null) {\n         throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);\n       }\n     } else {\n       // If the application has components, then run checks for each component.\n       // Let global values take effect if component level values are not\n       // provided.\n       Artifact globalArtifact \u003d application.getArtifact();\n       Resource globalResource \u003d application.getResource();\n       Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n       for (Component comp : application.getComponents()) {\n         // artifact\n         if (comp.getArtifact() \u003d\u003d null) {\n           comp.setArtifact(globalArtifact);\n         }\n         // If still null raise validation exception\n         if (comp.getArtifact() \u003d\u003d null) {\n           throw new IllegalArgumentException(String.format(\n               ERROR_ARTIFACT_FOR_COMP_INVALID, comp.getName()));\n         }\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(String.format(\n               ERROR_ARTIFACT_ID_FOR_COMP_INVALID, comp.getName()));\n         }\n \n         // If artifact is of type APPLICATION, add a slider specific property\n         if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n           if (comp.getConfiguration() \u003d\u003d null) {\n             comp.setConfiguration(new Configuration());\n           }\n           addPropertyToConfiguration(comp.getConfiguration(),\n               SliderKeys.COMPONENT_TYPE_KEY,\n               SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n           compNameArtifactIdMap.put(comp.getName(), comp.getArtifact().getId());\n           comp.setName(comp.getArtifact().getId());\n         }\n \n         // resource\n         if (comp.getResource() \u003d\u003d null) {\n           comp.setResource(globalResource);\n         }\n         validateApplicationResource(comp.getResource(), comp, comp\n             .getArtifact().getType());\n \n         // container count\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           comp.setNumberOfContainers(globalNumberOfContainers);\n         }\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           throw new IllegalArgumentException(String.format(\n               ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID, comp.getName()));\n         }\n       }\n     }\n \n     // If it is a simple app with no components, then create a default component\n     if (application.getComponents() \u003d\u003d null) {\n-      application.setComponents(getDefaultComponentAsList());\n+      application.setComponents(getDefaultComponentAsList(application));\n     }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void validateApplicationPostPayload(Application application,\n      Map\u003cString, String\u003e compNameArtifactIdMap) {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID_FORMAT);\n    }\n\n    // If the application has no components do top-level checks\n    if (application.getComponents() \u003d\u003d null) {\n      // artifact\n      if (application.getArtifact() \u003d\u003d null) {\n        throw new IllegalArgumentException(ERROR_ARTIFACT_INVALID);\n      }\n      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n        throw new IllegalArgumentException(ERROR_ARTIFACT_ID_INVALID);\n      }\n\n      // If artifact is of type APPLICATION, add a slider specific property\n      if (application.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (application.getConfiguration() \u003d\u003d null) {\n          application.setConfiguration(new Configuration());\n        }\n        addPropertyToConfiguration(application.getConfiguration(),\n            SliderKeys.COMPONENT_TYPE_KEY,\n            SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n      }\n      // resource\n      validateApplicationResource(application.getResource(), null, application\n          .getArtifact().getType());\n\n      // container size\n      if (application.getNumberOfContainers() \u003d\u003d null) {\n        throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);\n      }\n    } else {\n      // If the application has components, then run checks for each component.\n      // Let global values take effect if component level values are not\n      // provided.\n      Artifact globalArtifact \u003d application.getArtifact();\n      Resource globalResource \u003d application.getResource();\n      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n      for (Component comp : application.getComponents()) {\n        // artifact\n        if (comp.getArtifact() \u003d\u003d null) {\n          comp.setArtifact(globalArtifact);\n        }\n        // If still null raise validation exception\n        if (comp.getArtifact() \u003d\u003d null) {\n          throw new IllegalArgumentException(String.format(\n              ERROR_ARTIFACT_FOR_COMP_INVALID, comp.getName()));\n        }\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(String.format(\n              ERROR_ARTIFACT_ID_FOR_COMP_INVALID, comp.getName()));\n        }\n\n        // If artifact is of type APPLICATION, add a slider specific property\n        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n          if (comp.getConfiguration() \u003d\u003d null) {\n            comp.setConfiguration(new Configuration());\n          }\n          addPropertyToConfiguration(comp.getConfiguration(),\n              SliderKeys.COMPONENT_TYPE_KEY,\n              SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n          compNameArtifactIdMap.put(comp.getName(), comp.getArtifact().getId());\n          comp.setName(comp.getArtifact().getId());\n        }\n\n        // resource\n        if (comp.getResource() \u003d\u003d null) {\n          comp.setResource(globalResource);\n        }\n        validateApplicationResource(comp.getResource(), comp, comp\n            .getArtifact().getType());\n\n        // container count\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          comp.setNumberOfContainers(globalNumberOfContainers);\n        }\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          throw new IllegalArgumentException(String.format(\n              ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID, comp.getName()));\n        }\n      }\n    }\n\n    // If it is a simple app with no components, then create a default component\n    if (application.getComponents() \u003d\u003d null) {\n      application.setComponents(getDefaultComponentAsList(application));\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/services/api/impl/ApplicationApiService.java",
      "extendedDetails": {}
    },
    "c0120e51b944f86de4d533bcbc59f715047b9ea9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5689. Update native services REST API to use agentless docker provider. Contributed by Billie Rinaldi \u0026 Gour Saha\n",
      "commitDate": "06/11/17 1:28 PM",
      "commitName": "c0120e51b944f86de4d533bcbc59f715047b9ea9",
      "commitAuthor": "Jian He",
      "commitDateOld": "06/11/17 1:28 PM",
      "commitNameOld": "18bf0dce28a9a602f67a0c28fe5c350065931bd0",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,98 @@\n   protected void validateApplicationPostPayload(Application application,\n       Map\u003cString, String\u003e compNameArtifactIdMap) {\n     if (StringUtils.isEmpty(application.getName())) {\n       throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID);\n     }\n     if (!SliderUtils.isClusternameValid(application.getName())) {\n       throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID_FORMAT);\n     }\n \n     // If the application has no components do top-level checks\n     if (application.getComponents() \u003d\u003d null) {\n       // artifact\n       if (application.getArtifact() \u003d\u003d null) {\n         throw new IllegalArgumentException(ERROR_ARTIFACT_INVALID);\n       }\n       if (StringUtils.isEmpty(application.getArtifact().getId())) {\n         throw new IllegalArgumentException(ERROR_ARTIFACT_ID_INVALID);\n       }\n \n       // If artifact is of type APPLICATION, add a slider specific property\n       if (application.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n         if (application.getConfiguration() \u003d\u003d null) {\n           application.setConfiguration(new Configuration());\n         }\n         addPropertyToConfiguration(application.getConfiguration(),\n-            PROPERTY_COMPONENT_TYPE, COMPONENT_TYPE_EXTERNAL);\n+            SliderKeys.COMPONENT_TYPE_KEY,\n+            SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n       }\n       // resource\n       validateApplicationResource(application.getResource(), null, application\n           .getArtifact().getType());\n \n       // container size\n       if (application.getNumberOfContainers() \u003d\u003d null) {\n         throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);\n       }\n     } else {\n       // If the application has components, then run checks for each component.\n       // Let global values take effect if component level values are not\n       // provided.\n       Artifact globalArtifact \u003d application.getArtifact();\n       Resource globalResource \u003d application.getResource();\n       Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n       for (Component comp : application.getComponents()) {\n         // artifact\n         if (comp.getArtifact() \u003d\u003d null) {\n           comp.setArtifact(globalArtifact);\n         }\n         // If still null raise validation exception\n         if (comp.getArtifact() \u003d\u003d null) {\n           throw new IllegalArgumentException(String.format(\n               ERROR_ARTIFACT_FOR_COMP_INVALID, comp.getName()));\n         }\n         if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n           throw new IllegalArgumentException(String.format(\n               ERROR_ARTIFACT_ID_FOR_COMP_INVALID, comp.getName()));\n         }\n \n         // If artifact is of type APPLICATION, add a slider specific property\n         if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n           if (comp.getConfiguration() \u003d\u003d null) {\n             comp.setConfiguration(new Configuration());\n           }\n           addPropertyToConfiguration(comp.getConfiguration(),\n-              PROPERTY_COMPONENT_TYPE, COMPONENT_TYPE_EXTERNAL);\n+              SliderKeys.COMPONENT_TYPE_KEY,\n+              SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n           compNameArtifactIdMap.put(comp.getName(), comp.getArtifact().getId());\n           comp.setName(comp.getArtifact().getId());\n         }\n \n         // resource\n         if (comp.getResource() \u003d\u003d null) {\n           comp.setResource(globalResource);\n         }\n         validateApplicationResource(comp.getResource(), comp, comp\n             .getArtifact().getType());\n \n         // container count\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           comp.setNumberOfContainers(globalNumberOfContainers);\n         }\n         if (comp.getNumberOfContainers() \u003d\u003d null) {\n           throw new IllegalArgumentException(String.format(\n               ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID, comp.getName()));\n         }\n       }\n     }\n \n     // If it is a simple app with no components, then create a default component\n     if (application.getComponents() \u003d\u003d null) {\n       application.setComponents(getDefaultComponentAsList());\n     }\n \n     // Application lifetime if not specified, is set to unlimited lifetime\n     if (application.getLifetime() \u003d\u003d null) {\n       application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void validateApplicationPostPayload(Application application,\n      Map\u003cString, String\u003e compNameArtifactIdMap) {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID_FORMAT);\n    }\n\n    // If the application has no components do top-level checks\n    if (application.getComponents() \u003d\u003d null) {\n      // artifact\n      if (application.getArtifact() \u003d\u003d null) {\n        throw new IllegalArgumentException(ERROR_ARTIFACT_INVALID);\n      }\n      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n        throw new IllegalArgumentException(ERROR_ARTIFACT_ID_INVALID);\n      }\n\n      // If artifact is of type APPLICATION, add a slider specific property\n      if (application.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (application.getConfiguration() \u003d\u003d null) {\n          application.setConfiguration(new Configuration());\n        }\n        addPropertyToConfiguration(application.getConfiguration(),\n            SliderKeys.COMPONENT_TYPE_KEY,\n            SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n      }\n      // resource\n      validateApplicationResource(application.getResource(), null, application\n          .getArtifact().getType());\n\n      // container size\n      if (application.getNumberOfContainers() \u003d\u003d null) {\n        throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);\n      }\n    } else {\n      // If the application has components, then run checks for each component.\n      // Let global values take effect if component level values are not\n      // provided.\n      Artifact globalArtifact \u003d application.getArtifact();\n      Resource globalResource \u003d application.getResource();\n      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n      for (Component comp : application.getComponents()) {\n        // artifact\n        if (comp.getArtifact() \u003d\u003d null) {\n          comp.setArtifact(globalArtifact);\n        }\n        // If still null raise validation exception\n        if (comp.getArtifact() \u003d\u003d null) {\n          throw new IllegalArgumentException(String.format(\n              ERROR_ARTIFACT_FOR_COMP_INVALID, comp.getName()));\n        }\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(String.format(\n              ERROR_ARTIFACT_ID_FOR_COMP_INVALID, comp.getName()));\n        }\n\n        // If artifact is of type APPLICATION, add a slider specific property\n        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n          if (comp.getConfiguration() \u003d\u003d null) {\n            comp.setConfiguration(new Configuration());\n          }\n          addPropertyToConfiguration(comp.getConfiguration(),\n              SliderKeys.COMPONENT_TYPE_KEY,\n              SliderKeys.COMPONENT_TYPE_EXTERNAL_APP);\n          compNameArtifactIdMap.put(comp.getName(), comp.getArtifact().getId());\n          comp.setName(comp.getArtifact().getId());\n        }\n\n        // resource\n        if (comp.getResource() \u003d\u003d null) {\n          comp.setResource(globalResource);\n        }\n        validateApplicationResource(comp.getResource(), comp, comp\n            .getArtifact().getType());\n\n        // container count\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          comp.setNumberOfContainers(globalNumberOfContainers);\n        }\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          throw new IllegalArgumentException(String.format(\n              ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID, comp.getName()));\n        }\n      }\n    }\n\n    // If it is a simple app with no components, then create a default component\n    if (application.getComponents() \u003d\u003d null) {\n      application.setComponents(getDefaultComponentAsList());\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/services/api/impl/ApplicationApiService.java",
      "extendedDetails": {}
    },
    "18bf0dce28a9a602f67a0c28fe5c350065931bd0": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5610. Initial code for native services REST API. Contributed by Gour Saha\n",
      "commitDate": "06/11/17 1:28 PM",
      "commitName": "18bf0dce28a9a602f67a0c28fe5c350065931bd0",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,96 @@\n+  protected void validateApplicationPostPayload(Application application,\n+      Map\u003cString, String\u003e compNameArtifactIdMap) {\n+    if (StringUtils.isEmpty(application.getName())) {\n+      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID);\n+    }\n+    if (!SliderUtils.isClusternameValid(application.getName())) {\n+      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID_FORMAT);\n+    }\n+\n+    // If the application has no components do top-level checks\n+    if (application.getComponents() \u003d\u003d null) {\n+      // artifact\n+      if (application.getArtifact() \u003d\u003d null) {\n+        throw new IllegalArgumentException(ERROR_ARTIFACT_INVALID);\n+      }\n+      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n+        throw new IllegalArgumentException(ERROR_ARTIFACT_ID_INVALID);\n+      }\n+\n+      // If artifact is of type APPLICATION, add a slider specific property\n+      if (application.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n+        if (application.getConfiguration() \u003d\u003d null) {\n+          application.setConfiguration(new Configuration());\n+        }\n+        addPropertyToConfiguration(application.getConfiguration(),\n+            PROPERTY_COMPONENT_TYPE, COMPONENT_TYPE_EXTERNAL);\n+      }\n+      // resource\n+      validateApplicationResource(application.getResource(), null, application\n+          .getArtifact().getType());\n+\n+      // container size\n+      if (application.getNumberOfContainers() \u003d\u003d null) {\n+        throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);\n+      }\n+    } else {\n+      // If the application has components, then run checks for each component.\n+      // Let global values take effect if component level values are not\n+      // provided.\n+      Artifact globalArtifact \u003d application.getArtifact();\n+      Resource globalResource \u003d application.getResource();\n+      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n+      for (Component comp : application.getComponents()) {\n+        // artifact\n+        if (comp.getArtifact() \u003d\u003d null) {\n+          comp.setArtifact(globalArtifact);\n+        }\n+        // If still null raise validation exception\n+        if (comp.getArtifact() \u003d\u003d null) {\n+          throw new IllegalArgumentException(String.format(\n+              ERROR_ARTIFACT_FOR_COMP_INVALID, comp.getName()));\n+        }\n+        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n+          throw new IllegalArgumentException(String.format(\n+              ERROR_ARTIFACT_ID_FOR_COMP_INVALID, comp.getName()));\n+        }\n+\n+        // If artifact is of type APPLICATION, add a slider specific property\n+        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n+          if (comp.getConfiguration() \u003d\u003d null) {\n+            comp.setConfiguration(new Configuration());\n+          }\n+          addPropertyToConfiguration(comp.getConfiguration(),\n+              PROPERTY_COMPONENT_TYPE, COMPONENT_TYPE_EXTERNAL);\n+          compNameArtifactIdMap.put(comp.getName(), comp.getArtifact().getId());\n+          comp.setName(comp.getArtifact().getId());\n+        }\n+\n+        // resource\n+        if (comp.getResource() \u003d\u003d null) {\n+          comp.setResource(globalResource);\n+        }\n+        validateApplicationResource(comp.getResource(), comp, comp\n+            .getArtifact().getType());\n+\n+        // container count\n+        if (comp.getNumberOfContainers() \u003d\u003d null) {\n+          comp.setNumberOfContainers(globalNumberOfContainers);\n+        }\n+        if (comp.getNumberOfContainers() \u003d\u003d null) {\n+          throw new IllegalArgumentException(String.format(\n+              ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID, comp.getName()));\n+        }\n+      }\n+    }\n+\n+    // If it is a simple app with no components, then create a default component\n+    if (application.getComponents() \u003d\u003d null) {\n+      application.setComponents(getDefaultComponentAsList());\n+    }\n+\n+    // Application lifetime if not specified, is set to unlimited lifetime\n+    if (application.getLifetime() \u003d\u003d null) {\n+      application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void validateApplicationPostPayload(Application application,\n      Map\u003cString, String\u003e compNameArtifactIdMap) {\n    if (StringUtils.isEmpty(application.getName())) {\n      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID);\n    }\n    if (!SliderUtils.isClusternameValid(application.getName())) {\n      throw new IllegalArgumentException(ERROR_APPLICATION_NAME_INVALID_FORMAT);\n    }\n\n    // If the application has no components do top-level checks\n    if (application.getComponents() \u003d\u003d null) {\n      // artifact\n      if (application.getArtifact() \u003d\u003d null) {\n        throw new IllegalArgumentException(ERROR_ARTIFACT_INVALID);\n      }\n      if (StringUtils.isEmpty(application.getArtifact().getId())) {\n        throw new IllegalArgumentException(ERROR_ARTIFACT_ID_INVALID);\n      }\n\n      // If artifact is of type APPLICATION, add a slider specific property\n      if (application.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n        if (application.getConfiguration() \u003d\u003d null) {\n          application.setConfiguration(new Configuration());\n        }\n        addPropertyToConfiguration(application.getConfiguration(),\n            PROPERTY_COMPONENT_TYPE, COMPONENT_TYPE_EXTERNAL);\n      }\n      // resource\n      validateApplicationResource(application.getResource(), null, application\n          .getArtifact().getType());\n\n      // container size\n      if (application.getNumberOfContainers() \u003d\u003d null) {\n        throw new IllegalArgumentException(ERROR_CONTAINERS_COUNT_INVALID);\n      }\n    } else {\n      // If the application has components, then run checks for each component.\n      // Let global values take effect if component level values are not\n      // provided.\n      Artifact globalArtifact \u003d application.getArtifact();\n      Resource globalResource \u003d application.getResource();\n      Long globalNumberOfContainers \u003d application.getNumberOfContainers();\n      for (Component comp : application.getComponents()) {\n        // artifact\n        if (comp.getArtifact() \u003d\u003d null) {\n          comp.setArtifact(globalArtifact);\n        }\n        // If still null raise validation exception\n        if (comp.getArtifact() \u003d\u003d null) {\n          throw new IllegalArgumentException(String.format(\n              ERROR_ARTIFACT_FOR_COMP_INVALID, comp.getName()));\n        }\n        if (StringUtils.isEmpty(comp.getArtifact().getId())) {\n          throw new IllegalArgumentException(String.format(\n              ERROR_ARTIFACT_ID_FOR_COMP_INVALID, comp.getName()));\n        }\n\n        // If artifact is of type APPLICATION, add a slider specific property\n        if (comp.getArtifact().getType() \u003d\u003d Artifact.TypeEnum.APPLICATION) {\n          if (comp.getConfiguration() \u003d\u003d null) {\n            comp.setConfiguration(new Configuration());\n          }\n          addPropertyToConfiguration(comp.getConfiguration(),\n              PROPERTY_COMPONENT_TYPE, COMPONENT_TYPE_EXTERNAL);\n          compNameArtifactIdMap.put(comp.getName(), comp.getArtifact().getId());\n          comp.setName(comp.getArtifact().getId());\n        }\n\n        // resource\n        if (comp.getResource() \u003d\u003d null) {\n          comp.setResource(globalResource);\n        }\n        validateApplicationResource(comp.getResource(), comp, comp\n            .getArtifact().getType());\n\n        // container count\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          comp.setNumberOfContainers(globalNumberOfContainers);\n        }\n        if (comp.getNumberOfContainers() \u003d\u003d null) {\n          throw new IllegalArgumentException(String.format(\n              ERROR_CONTAINERS_COUNT_FOR_COMP_INVALID, comp.getName()));\n        }\n      }\n    }\n\n    // If it is a simple app with no components, then create a default component\n    if (application.getComponents() \u003d\u003d null) {\n      application.setComponents(getDefaultComponentAsList());\n    }\n\n    // Application lifetime if not specified, is set to unlimited lifetime\n    if (application.getLifetime() \u003d\u003d null) {\n      application.setLifetime(DEFAULT_UNLIMITED_LIFETIME);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/services/api/impl/ApplicationApiService.java"
    }
  }
}