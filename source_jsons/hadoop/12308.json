{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "VolumeScanner.java",
  "functionName": "runLoop",
  "functionId": "runLoop___suspectBlock-ExtendedBlock",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/VolumeScanner.java",
  "functionStartLine": 539,
  "functionEndLine": 619,
  "numCommitsSeen": 22,
  "timeTaken": 4382,
  "changeHistory": [
    "f43a152b9729323e290908fbd4f188f6034efb3f",
    "50caba1a92cb36ce78307d47ed7624ce216562fc",
    "9a08999906824e8982ec3b47315f9b960474186a",
    "8bb9a5000ed06856abbad268c43ce1d5ad5bdd43",
    "115428176e1d919fe7d54d01b34dfda57d1b3950",
    "6e62a1a6728b1f782f64065424f92b292c3f163a"
  ],
  "changeHistoryShort": {
    "f43a152b9729323e290908fbd4f188f6034efb3f": "Ybodychange",
    "50caba1a92cb36ce78307d47ed7624ce216562fc": "Ybodychange",
    "9a08999906824e8982ec3b47315f9b960474186a": "Ybodychange",
    "8bb9a5000ed06856abbad268c43ce1d5ad5bdd43": "Ymultichange(Yparameterchange,Ybodychange)",
    "115428176e1d919fe7d54d01b34dfda57d1b3950": "Ybodychange",
    "6e62a1a6728b1f782f64065424f92b292c3f163a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f43a152b9729323e290908fbd4f188f6034efb3f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15369. Refactor method VolumeScanner#runLoop(). Contributed by Yang Yun.\n",
      "commitDate": "24/05/20 5:33 AM",
      "commitName": "f43a152b9729323e290908fbd4f188f6034efb3f",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "18/05/20 8:40 AM",
      "commitNameOld": "50caba1a92cb36ce78307d47ed7624ce216562fc",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 5.87,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,81 @@\n   private long runLoop(ExtendedBlock suspectBlock) {\n     long bytesScanned \u003d -1;\n     boolean scanError \u003d false;\n     ExtendedBlock block \u003d null;\n     try {\n       long monotonicMs \u003d Time.monotonicNow();\n       expireOldScannedBytesRecords(monotonicMs);\n \n       if (!calculateShouldScan(volume.getStorageID(), conf.targetBytesPerSec,\n           scannedBytesSum, startMinute, curMinute)) {\n         // If neededBytesPerSec is too low, then wait few seconds for some old\n         // scannedBytes records to expire.\n         return 30000L;\n       }\n \n-      // Find a usable block pool to scan.\n       if (suspectBlock !\u003d null) {\n         block \u003d suspectBlock;\n       } else {\n+        // Find a usable block pool to scan.\n         if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n           long timeout \u003d findNextUsableBlockIter();\n           if (timeout \u003e 0) {\n             LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n                 \"{} ms.\", this, timeout);\n             synchronized (stats) {\n               stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n             }\n             return timeout;\n           }\n           synchronized (stats) {\n             stats.scansSinceRestart++;\n             stats.blocksScannedInCurrentPeriod \u003d 0;\n             stats.nextBlockPoolScanStartMs \u003d -1;\n           }\n           return 0L;\n         }\n-        try {\n-          block \u003d curBlockIter.nextBlock();\n-        } catch (IOException e) {\n-          // There was an error listing the next block in the volume.  This is a\n-          // serious issue.\n-          LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n-          // On the next loop iteration, curBlockIter#eof will be set to true, and\n-          // we will pick a different block iterator.\n-          return 0L;\n-        }\n+        block \u003d getNextBlockToScan();\n         if (block \u003d\u003d null) {\n-          // The BlockIterator is at EOF.\n-          LOG.info(\"{}: finished scanning block pool {}\",\n-              this, curBlockIter.getBlockPoolId());\n-          saveBlockIterator(curBlockIter);\n-          return 0;\n-        } else if (conf.skipRecentAccessed) {\n-          // Check the access time of block file to avoid scanning recently\n-          // changed blocks, reducing disk IO.\n-          try {\n-            BlockLocalPathInfo blockLocalPathInfo \u003d\n-                volume.getDataset().getBlockLocalPathInfo(block);\n-            BasicFileAttributes attr \u003d Files.readAttributes(\n-                new File(blockLocalPathInfo.getBlockPath()).toPath(),\n-                BasicFileAttributes.class);\n-            if (System.currentTimeMillis() - attr.lastAccessTime().\n-                to(TimeUnit.MILLISECONDS) \u003c conf.scanPeriodMs) {\n-              return 0;\n-            }\n-\n-          } catch (IOException ioe) {\n-            LOG.debug(\"Failed to get access time of block {}\",\n-                block, ioe);\n-          }\n+          return 0L;\n         }\n       }\n       if (curBlockIter !\u003d null) {\n         long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n         if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n           LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n               this, curBlockIter, saveDelta);\n           saveBlockIterator(curBlockIter);\n         }\n       }\n       bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n       if (bytesScanned \u003e\u003d 0) {\n         scannedBytesSum +\u003d bytesScanned;\n         scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n       } else {\n         scanError \u003d true;\n       }\n       return 0L;\n     } finally {\n       synchronized (stats) {\n         stats.bytesScannedInPastHour \u003d scannedBytesSum;\n         if (bytesScanned \u003e 0) {\n           stats.blocksScannedInCurrentPeriod++;\n           stats.blocksScannedSinceRestart++;\n         }\n         if (scanError) {\n           stats.scanErrorsSinceRestart++;\n         }\n         if (block !\u003d null) {\n           stats.lastBlockScanned \u003d block;\n         }\n         if (curBlockIter \u003d\u003d null) {\n           stats.eof \u003d true;\n           stats.blockPoolPeriodEndsMs \u003d -1;\n         } else {\n           stats.eof \u003d curBlockIter.atEnd();\n           stats.blockPoolPeriodEndsMs \u003d\n               curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long runLoop(ExtendedBlock suspectBlock) {\n    long bytesScanned \u003d -1;\n    boolean scanError \u003d false;\n    ExtendedBlock block \u003d null;\n    try {\n      long monotonicMs \u003d Time.monotonicNow();\n      expireOldScannedBytesRecords(monotonicMs);\n\n      if (!calculateShouldScan(volume.getStorageID(), conf.targetBytesPerSec,\n          scannedBytesSum, startMinute, curMinute)) {\n        // If neededBytesPerSec is too low, then wait few seconds for some old\n        // scannedBytes records to expire.\n        return 30000L;\n      }\n\n      if (suspectBlock !\u003d null) {\n        block \u003d suspectBlock;\n      } else {\n        // Find a usable block pool to scan.\n        if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n          long timeout \u003d findNextUsableBlockIter();\n          if (timeout \u003e 0) {\n            LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n                \"{} ms.\", this, timeout);\n            synchronized (stats) {\n              stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n            }\n            return timeout;\n          }\n          synchronized (stats) {\n            stats.scansSinceRestart++;\n            stats.blocksScannedInCurrentPeriod \u003d 0;\n            stats.nextBlockPoolScanStartMs \u003d -1;\n          }\n          return 0L;\n        }\n        block \u003d getNextBlockToScan();\n        if (block \u003d\u003d null) {\n          return 0L;\n        }\n      }\n      if (curBlockIter !\u003d null) {\n        long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n        if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n          LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n              this, curBlockIter, saveDelta);\n          saveBlockIterator(curBlockIter);\n        }\n      }\n      bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n      if (bytesScanned \u003e\u003d 0) {\n        scannedBytesSum +\u003d bytesScanned;\n        scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n      } else {\n        scanError \u003d true;\n      }\n      return 0L;\n    } finally {\n      synchronized (stats) {\n        stats.bytesScannedInPastHour \u003d scannedBytesSum;\n        if (bytesScanned \u003e 0) {\n          stats.blocksScannedInCurrentPeriod++;\n          stats.blocksScannedSinceRestart++;\n        }\n        if (scanError) {\n          stats.scanErrorsSinceRestart++;\n        }\n        if (block !\u003d null) {\n          stats.lastBlockScanned \u003d block;\n        }\n        if (curBlockIter \u003d\u003d null) {\n          stats.eof \u003d true;\n          stats.blockPoolPeriodEndsMs \u003d -1;\n        } else {\n          stats.eof \u003d curBlockIter.atEnd();\n          stats.blockPoolPeriodEndsMs \u003d\n              curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/VolumeScanner.java",
      "extendedDetails": {}
    },
    "50caba1a92cb36ce78307d47ed7624ce216562fc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15207. VolumeScanner skip to scan blocks accessed during recent scan peroid. Contributed by Yang Yun.\n",
      "commitDate": "18/05/20 8:40 AM",
      "commitName": "50caba1a92cb36ce78307d47ed7624ce216562fc",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "19/08/19 1:08 PM",
      "commitNameOld": "360a96f342f3c8cb8246f011abb9bcb0b6ef3eaa",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 272.81,
      "commitsBetweenForRepo": 1218,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,112 @@\n   private long runLoop(ExtendedBlock suspectBlock) {\n     long bytesScanned \u003d -1;\n     boolean scanError \u003d false;\n     ExtendedBlock block \u003d null;\n     try {\n       long monotonicMs \u003d Time.monotonicNow();\n       expireOldScannedBytesRecords(monotonicMs);\n \n       if (!calculateShouldScan(volume.getStorageID(), conf.targetBytesPerSec,\n           scannedBytesSum, startMinute, curMinute)) {\n         // If neededBytesPerSec is too low, then wait few seconds for some old\n         // scannedBytes records to expire.\n         return 30000L;\n       }\n \n       // Find a usable block pool to scan.\n       if (suspectBlock !\u003d null) {\n         block \u003d suspectBlock;\n       } else {\n         if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n           long timeout \u003d findNextUsableBlockIter();\n           if (timeout \u003e 0) {\n             LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n                 \"{} ms.\", this, timeout);\n             synchronized (stats) {\n               stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n             }\n             return timeout;\n           }\n           synchronized (stats) {\n             stats.scansSinceRestart++;\n             stats.blocksScannedInCurrentPeriod \u003d 0;\n             stats.nextBlockPoolScanStartMs \u003d -1;\n           }\n           return 0L;\n         }\n         try {\n           block \u003d curBlockIter.nextBlock();\n         } catch (IOException e) {\n           // There was an error listing the next block in the volume.  This is a\n           // serious issue.\n           LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n           // On the next loop iteration, curBlockIter#eof will be set to true, and\n           // we will pick a different block iterator.\n           return 0L;\n         }\n         if (block \u003d\u003d null) {\n           // The BlockIterator is at EOF.\n           LOG.info(\"{}: finished scanning block pool {}\",\n               this, curBlockIter.getBlockPoolId());\n           saveBlockIterator(curBlockIter);\n           return 0;\n+        } else if (conf.skipRecentAccessed) {\n+          // Check the access time of block file to avoid scanning recently\n+          // changed blocks, reducing disk IO.\n+          try {\n+            BlockLocalPathInfo blockLocalPathInfo \u003d\n+                volume.getDataset().getBlockLocalPathInfo(block);\n+            BasicFileAttributes attr \u003d Files.readAttributes(\n+                new File(blockLocalPathInfo.getBlockPath()).toPath(),\n+                BasicFileAttributes.class);\n+            if (System.currentTimeMillis() - attr.lastAccessTime().\n+                to(TimeUnit.MILLISECONDS) \u003c conf.scanPeriodMs) {\n+              return 0;\n+            }\n+\n+          } catch (IOException ioe) {\n+            LOG.debug(\"Failed to get access time of block {}\",\n+                block, ioe);\n+          }\n         }\n       }\n       if (curBlockIter !\u003d null) {\n         long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n         if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n           LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n               this, curBlockIter, saveDelta);\n           saveBlockIterator(curBlockIter);\n         }\n       }\n       bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n       if (bytesScanned \u003e\u003d 0) {\n         scannedBytesSum +\u003d bytesScanned;\n         scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n       } else {\n         scanError \u003d true;\n       }\n       return 0L;\n     } finally {\n       synchronized (stats) {\n         stats.bytesScannedInPastHour \u003d scannedBytesSum;\n         if (bytesScanned \u003e 0) {\n           stats.blocksScannedInCurrentPeriod++;\n           stats.blocksScannedSinceRestart++;\n         }\n         if (scanError) {\n           stats.scanErrorsSinceRestart++;\n         }\n         if (block !\u003d null) {\n           stats.lastBlockScanned \u003d block;\n         }\n         if (curBlockIter \u003d\u003d null) {\n           stats.eof \u003d true;\n           stats.blockPoolPeriodEndsMs \u003d -1;\n         } else {\n           stats.eof \u003d curBlockIter.atEnd();\n           stats.blockPoolPeriodEndsMs \u003d\n               curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long runLoop(ExtendedBlock suspectBlock) {\n    long bytesScanned \u003d -1;\n    boolean scanError \u003d false;\n    ExtendedBlock block \u003d null;\n    try {\n      long monotonicMs \u003d Time.monotonicNow();\n      expireOldScannedBytesRecords(monotonicMs);\n\n      if (!calculateShouldScan(volume.getStorageID(), conf.targetBytesPerSec,\n          scannedBytesSum, startMinute, curMinute)) {\n        // If neededBytesPerSec is too low, then wait few seconds for some old\n        // scannedBytes records to expire.\n        return 30000L;\n      }\n\n      // Find a usable block pool to scan.\n      if (suspectBlock !\u003d null) {\n        block \u003d suspectBlock;\n      } else {\n        if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n          long timeout \u003d findNextUsableBlockIter();\n          if (timeout \u003e 0) {\n            LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n                \"{} ms.\", this, timeout);\n            synchronized (stats) {\n              stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n            }\n            return timeout;\n          }\n          synchronized (stats) {\n            stats.scansSinceRestart++;\n            stats.blocksScannedInCurrentPeriod \u003d 0;\n            stats.nextBlockPoolScanStartMs \u003d -1;\n          }\n          return 0L;\n        }\n        try {\n          block \u003d curBlockIter.nextBlock();\n        } catch (IOException e) {\n          // There was an error listing the next block in the volume.  This is a\n          // serious issue.\n          LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n          // On the next loop iteration, curBlockIter#eof will be set to true, and\n          // we will pick a different block iterator.\n          return 0L;\n        }\n        if (block \u003d\u003d null) {\n          // The BlockIterator is at EOF.\n          LOG.info(\"{}: finished scanning block pool {}\",\n              this, curBlockIter.getBlockPoolId());\n          saveBlockIterator(curBlockIter);\n          return 0;\n        } else if (conf.skipRecentAccessed) {\n          // Check the access time of block file to avoid scanning recently\n          // changed blocks, reducing disk IO.\n          try {\n            BlockLocalPathInfo blockLocalPathInfo \u003d\n                volume.getDataset().getBlockLocalPathInfo(block);\n            BasicFileAttributes attr \u003d Files.readAttributes(\n                new File(blockLocalPathInfo.getBlockPath()).toPath(),\n                BasicFileAttributes.class);\n            if (System.currentTimeMillis() - attr.lastAccessTime().\n                to(TimeUnit.MILLISECONDS) \u003c conf.scanPeriodMs) {\n              return 0;\n            }\n\n          } catch (IOException ioe) {\n            LOG.debug(\"Failed to get access time of block {}\",\n                block, ioe);\n          }\n        }\n      }\n      if (curBlockIter !\u003d null) {\n        long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n        if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n          LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n              this, curBlockIter, saveDelta);\n          saveBlockIterator(curBlockIter);\n        }\n      }\n      bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n      if (bytesScanned \u003e\u003d 0) {\n        scannedBytesSum +\u003d bytesScanned;\n        scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n      } else {\n        scanError \u003d true;\n      }\n      return 0L;\n    } finally {\n      synchronized (stats) {\n        stats.bytesScannedInPastHour \u003d scannedBytesSum;\n        if (bytesScanned \u003e 0) {\n          stats.blocksScannedInCurrentPeriod++;\n          stats.blocksScannedSinceRestart++;\n        }\n        if (scanError) {\n          stats.scanErrorsSinceRestart++;\n        }\n        if (block !\u003d null) {\n          stats.lastBlockScanned \u003d block;\n        }\n        if (curBlockIter \u003d\u003d null) {\n          stats.eof \u003d true;\n          stats.blockPoolPeriodEndsMs \u003d -1;\n        } else {\n          stats.eof \u003d curBlockIter.atEnd();\n          stats.blockPoolPeriodEndsMs \u003d\n              curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/VolumeScanner.java",
      "extendedDetails": {}
    },
    "9a08999906824e8982ec3b47315f9b960474186a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8850. VolumeScanner thread exits with exception if there is no block pool to be scanned but there are suspicious blocks. (Colin Patrick McCabe via yliu)\n",
      "commitDate": "04/08/15 12:54 AM",
      "commitName": "9a08999906824e8982ec3b47315f9b960474186a",
      "commitAuthor": "yliu",
      "commitDateOld": "29/06/15 2:43 PM",
      "commitNameOld": "43a1288fff5e323895fde66b9e3eb31a7412fcc2",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 35.42,
      "commitsBetweenForRepo": 213,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,94 @@\n   private long runLoop(ExtendedBlock suspectBlock) {\n     long bytesScanned \u003d -1;\n     boolean scanError \u003d false;\n     ExtendedBlock block \u003d null;\n     try {\n       long monotonicMs \u003d Time.monotonicNow();\n       expireOldScannedBytesRecords(monotonicMs);\n \n       if (!calculateShouldScan(volume.getStorageID(), conf.targetBytesPerSec,\n           scannedBytesSum, startMinute, curMinute)) {\n         // If neededBytesPerSec is too low, then wait few seconds for some old\n         // scannedBytes records to expire.\n         return 30000L;\n       }\n \n       // Find a usable block pool to scan.\n       if (suspectBlock !\u003d null) {\n         block \u003d suspectBlock;\n       } else {\n         if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n           long timeout \u003d findNextUsableBlockIter();\n           if (timeout \u003e 0) {\n             LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n                 \"{} ms.\", this, timeout);\n             synchronized (stats) {\n               stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n             }\n             return timeout;\n           }\n           synchronized (stats) {\n             stats.scansSinceRestart++;\n             stats.blocksScannedInCurrentPeriod \u003d 0;\n             stats.nextBlockPoolScanStartMs \u003d -1;\n           }\n           return 0L;\n         }\n         try {\n           block \u003d curBlockIter.nextBlock();\n         } catch (IOException e) {\n           // There was an error listing the next block in the volume.  This is a\n           // serious issue.\n           LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n           // On the next loop iteration, curBlockIter#eof will be set to true, and\n           // we will pick a different block iterator.\n           return 0L;\n         }\n         if (block \u003d\u003d null) {\n           // The BlockIterator is at EOF.\n           LOG.info(\"{}: finished scanning block pool {}\",\n               this, curBlockIter.getBlockPoolId());\n           saveBlockIterator(curBlockIter);\n           return 0;\n         }\n       }\n-      long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n-      if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n-        LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n-            this, curBlockIter, saveDelta);\n-        saveBlockIterator(curBlockIter);\n+      if (curBlockIter !\u003d null) {\n+        long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n+        if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n+          LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n+              this, curBlockIter, saveDelta);\n+          saveBlockIterator(curBlockIter);\n+        }\n       }\n       bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n       if (bytesScanned \u003e\u003d 0) {\n         scannedBytesSum +\u003d bytesScanned;\n         scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n       } else {\n         scanError \u003d true;\n       }\n       return 0L;\n     } finally {\n       synchronized (stats) {\n         stats.bytesScannedInPastHour \u003d scannedBytesSum;\n         if (bytesScanned \u003e 0) {\n           stats.blocksScannedInCurrentPeriod++;\n           stats.blocksScannedSinceRestart++;\n         }\n         if (scanError) {\n           stats.scanErrorsSinceRestart++;\n         }\n         if (block !\u003d null) {\n           stats.lastBlockScanned \u003d block;\n         }\n         if (curBlockIter \u003d\u003d null) {\n           stats.eof \u003d true;\n           stats.blockPoolPeriodEndsMs \u003d -1;\n         } else {\n           stats.eof \u003d curBlockIter.atEnd();\n           stats.blockPoolPeriodEndsMs \u003d\n               curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long runLoop(ExtendedBlock suspectBlock) {\n    long bytesScanned \u003d -1;\n    boolean scanError \u003d false;\n    ExtendedBlock block \u003d null;\n    try {\n      long monotonicMs \u003d Time.monotonicNow();\n      expireOldScannedBytesRecords(monotonicMs);\n\n      if (!calculateShouldScan(volume.getStorageID(), conf.targetBytesPerSec,\n          scannedBytesSum, startMinute, curMinute)) {\n        // If neededBytesPerSec is too low, then wait few seconds for some old\n        // scannedBytes records to expire.\n        return 30000L;\n      }\n\n      // Find a usable block pool to scan.\n      if (suspectBlock !\u003d null) {\n        block \u003d suspectBlock;\n      } else {\n        if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n          long timeout \u003d findNextUsableBlockIter();\n          if (timeout \u003e 0) {\n            LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n                \"{} ms.\", this, timeout);\n            synchronized (stats) {\n              stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n            }\n            return timeout;\n          }\n          synchronized (stats) {\n            stats.scansSinceRestart++;\n            stats.blocksScannedInCurrentPeriod \u003d 0;\n            stats.nextBlockPoolScanStartMs \u003d -1;\n          }\n          return 0L;\n        }\n        try {\n          block \u003d curBlockIter.nextBlock();\n        } catch (IOException e) {\n          // There was an error listing the next block in the volume.  This is a\n          // serious issue.\n          LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n          // On the next loop iteration, curBlockIter#eof will be set to true, and\n          // we will pick a different block iterator.\n          return 0L;\n        }\n        if (block \u003d\u003d null) {\n          // The BlockIterator is at EOF.\n          LOG.info(\"{}: finished scanning block pool {}\",\n              this, curBlockIter.getBlockPoolId());\n          saveBlockIterator(curBlockIter);\n          return 0;\n        }\n      }\n      if (curBlockIter !\u003d null) {\n        long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n        if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n          LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n              this, curBlockIter, saveDelta);\n          saveBlockIterator(curBlockIter);\n        }\n      }\n      bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n      if (bytesScanned \u003e\u003d 0) {\n        scannedBytesSum +\u003d bytesScanned;\n        scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n      } else {\n        scanError \u003d true;\n      }\n      return 0L;\n    } finally {\n      synchronized (stats) {\n        stats.bytesScannedInPastHour \u003d scannedBytesSum;\n        if (bytesScanned \u003e 0) {\n          stats.blocksScannedInCurrentPeriod++;\n          stats.blocksScannedSinceRestart++;\n        }\n        if (scanError) {\n          stats.scanErrorsSinceRestart++;\n        }\n        if (block !\u003d null) {\n          stats.lastBlockScanned \u003d block;\n        }\n        if (curBlockIter \u003d\u003d null) {\n          stats.eof \u003d true;\n          stats.blockPoolPeriodEndsMs \u003d -1;\n        } else {\n          stats.eof \u003d curBlockIter.atEnd();\n          stats.blockPoolPeriodEndsMs \u003d\n              curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/VolumeScanner.java",
      "extendedDetails": {}
    },
    "8bb9a5000ed06856abbad268c43ce1d5ad5bdd43": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7686. Re-add rapid rescan of possibly corrupt block feature to the block scanner (cmccabe)\n",
      "commitDate": "13/02/15 2:35 PM",
      "commitName": "8bb9a5000ed06856abbad268c43ce1d5ad5bdd43",
      "commitAuthor": "Colin Patrick Mccabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7686. Re-add rapid rescan of possibly corrupt block feature to the block scanner (cmccabe)\n",
          "commitDate": "13/02/15 2:35 PM",
          "commitName": "8bb9a5000ed06856abbad268c43ce1d5ad5bdd43",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "03/02/15 11:05 AM",
          "commitNameOld": "115428176e1d919fe7d54d01b34dfda57d1b3950",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 10.15,
          "commitsBetweenForRepo": 158,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,89 +1,92 @@\n-  private long runLoop() {\n+  private long runLoop(ExtendedBlock suspectBlock) {\n     long bytesScanned \u003d -1;\n     boolean scanError \u003d false;\n     ExtendedBlock block \u003d null;\n     try {\n       long monotonicMs \u003d Time.monotonicNow();\n       expireOldScannedBytesRecords(monotonicMs);\n \n       if (!calculateShouldScan(volume.getStorageID(), conf.targetBytesPerSec,\n           scannedBytesSum, startMinute, curMinute)) {\n         // If neededBytesPerSec is too low, then wait few seconds for some old\n         // scannedBytes records to expire.\n         return 30000L;\n       }\n \n       // Find a usable block pool to scan.\n-      if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n-        long timeout \u003d findNextUsableBlockIter();\n-        if (timeout \u003e 0) {\n-          LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n-              \"{} ms.\", this, timeout);\n-          synchronized (stats) {\n-            stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n+      if (suspectBlock !\u003d null) {\n+        block \u003d suspectBlock;\n+      } else {\n+        if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n+          long timeout \u003d findNextUsableBlockIter();\n+          if (timeout \u003e 0) {\n+            LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n+                \"{} ms.\", this, timeout);\n+            synchronized (stats) {\n+              stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n+            }\n+            return timeout;\n           }\n-          return timeout;\n+          synchronized (stats) {\n+            stats.scansSinceRestart++;\n+            stats.blocksScannedInCurrentPeriod \u003d 0;\n+            stats.nextBlockPoolScanStartMs \u003d -1;\n+          }\n+          return 0L;\n         }\n-        synchronized (stats) {\n-          stats.scansSinceRestart++;\n-          stats.blocksScannedInCurrentPeriod \u003d 0;\n-          stats.nextBlockPoolScanStartMs \u003d -1;\n+        try {\n+          block \u003d curBlockIter.nextBlock();\n+        } catch (IOException e) {\n+          // There was an error listing the next block in the volume.  This is a\n+          // serious issue.\n+          LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n+          // On the next loop iteration, curBlockIter#eof will be set to true, and\n+          // we will pick a different block iterator.\n+          return 0L;\n         }\n-        return 0L;\n-      }\n-\n-      try {\n-        block \u003d curBlockIter.nextBlock();\n-      } catch (IOException e) {\n-        // There was an error listing the next block in the volume.  This is a\n-        // serious issue.\n-        LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n-        // On the next loop iteration, curBlockIter#eof will be set to true, and\n-        // we will pick a different block iterator.\n-        return 0L;\n-      }\n-      if (block \u003d\u003d null) {\n-        // The BlockIterator is at EOF.\n-        LOG.info(\"{}: finished scanning block pool {}\",\n-            this, curBlockIter.getBlockPoolId());\n-        saveBlockIterator(curBlockIter);\n-        return 0;\n+        if (block \u003d\u003d null) {\n+          // The BlockIterator is at EOF.\n+          LOG.info(\"{}: finished scanning block pool {}\",\n+              this, curBlockIter.getBlockPoolId());\n+          saveBlockIterator(curBlockIter);\n+          return 0;\n+        }\n       }\n       long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n       if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n         LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n             this, curBlockIter, saveDelta);\n         saveBlockIterator(curBlockIter);\n       }\n       bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n       if (bytesScanned \u003e\u003d 0) {\n         scannedBytesSum +\u003d bytesScanned;\n         scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n       } else {\n         scanError \u003d true;\n       }\n       return 0L;\n     } finally {\n       synchronized (stats) {\n         stats.bytesScannedInPastHour \u003d scannedBytesSum;\n-        if (bytesScanned \u003e\u003d 0) {\n+        if (bytesScanned \u003e 0) {\n           stats.blocksScannedInCurrentPeriod++;\n           stats.blocksScannedSinceRestart++;\n         }\n         if (scanError) {\n           stats.scanErrorsSinceRestart++;\n         }\n         if (block !\u003d null) {\n           stats.lastBlockScanned \u003d block;\n         }\n         if (curBlockIter \u003d\u003d null) {\n           stats.eof \u003d true;\n           stats.blockPoolPeriodEndsMs \u003d -1;\n         } else {\n           stats.eof \u003d curBlockIter.atEnd();\n           stats.blockPoolPeriodEndsMs \u003d\n               curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private long runLoop(ExtendedBlock suspectBlock) {\n    long bytesScanned \u003d -1;\n    boolean scanError \u003d false;\n    ExtendedBlock block \u003d null;\n    try {\n      long monotonicMs \u003d Time.monotonicNow();\n      expireOldScannedBytesRecords(monotonicMs);\n\n      if (!calculateShouldScan(volume.getStorageID(), conf.targetBytesPerSec,\n          scannedBytesSum, startMinute, curMinute)) {\n        // If neededBytesPerSec is too low, then wait few seconds for some old\n        // scannedBytes records to expire.\n        return 30000L;\n      }\n\n      // Find a usable block pool to scan.\n      if (suspectBlock !\u003d null) {\n        block \u003d suspectBlock;\n      } else {\n        if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n          long timeout \u003d findNextUsableBlockIter();\n          if (timeout \u003e 0) {\n            LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n                \"{} ms.\", this, timeout);\n            synchronized (stats) {\n              stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n            }\n            return timeout;\n          }\n          synchronized (stats) {\n            stats.scansSinceRestart++;\n            stats.blocksScannedInCurrentPeriod \u003d 0;\n            stats.nextBlockPoolScanStartMs \u003d -1;\n          }\n          return 0L;\n        }\n        try {\n          block \u003d curBlockIter.nextBlock();\n        } catch (IOException e) {\n          // There was an error listing the next block in the volume.  This is a\n          // serious issue.\n          LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n          // On the next loop iteration, curBlockIter#eof will be set to true, and\n          // we will pick a different block iterator.\n          return 0L;\n        }\n        if (block \u003d\u003d null) {\n          // The BlockIterator is at EOF.\n          LOG.info(\"{}: finished scanning block pool {}\",\n              this, curBlockIter.getBlockPoolId());\n          saveBlockIterator(curBlockIter);\n          return 0;\n        }\n      }\n      long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n      if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n        LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n            this, curBlockIter, saveDelta);\n        saveBlockIterator(curBlockIter);\n      }\n      bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n      if (bytesScanned \u003e\u003d 0) {\n        scannedBytesSum +\u003d bytesScanned;\n        scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n      } else {\n        scanError \u003d true;\n      }\n      return 0L;\n    } finally {\n      synchronized (stats) {\n        stats.bytesScannedInPastHour \u003d scannedBytesSum;\n        if (bytesScanned \u003e 0) {\n          stats.blocksScannedInCurrentPeriod++;\n          stats.blocksScannedSinceRestart++;\n        }\n        if (scanError) {\n          stats.scanErrorsSinceRestart++;\n        }\n        if (block !\u003d null) {\n          stats.lastBlockScanned \u003d block;\n        }\n        if (curBlockIter \u003d\u003d null) {\n          stats.eof \u003d true;\n          stats.blockPoolPeriodEndsMs \u003d -1;\n        } else {\n          stats.eof \u003d curBlockIter.atEnd();\n          stats.blockPoolPeriodEndsMs \u003d\n              curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/VolumeScanner.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[suspectBlock-ExtendedBlock]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7686. Re-add rapid rescan of possibly corrupt block feature to the block scanner (cmccabe)\n",
          "commitDate": "13/02/15 2:35 PM",
          "commitName": "8bb9a5000ed06856abbad268c43ce1d5ad5bdd43",
          "commitAuthor": "Colin Patrick Mccabe",
          "commitDateOld": "03/02/15 11:05 AM",
          "commitNameOld": "115428176e1d919fe7d54d01b34dfda57d1b3950",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 10.15,
          "commitsBetweenForRepo": 158,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,89 +1,92 @@\n-  private long runLoop() {\n+  private long runLoop(ExtendedBlock suspectBlock) {\n     long bytesScanned \u003d -1;\n     boolean scanError \u003d false;\n     ExtendedBlock block \u003d null;\n     try {\n       long monotonicMs \u003d Time.monotonicNow();\n       expireOldScannedBytesRecords(monotonicMs);\n \n       if (!calculateShouldScan(volume.getStorageID(), conf.targetBytesPerSec,\n           scannedBytesSum, startMinute, curMinute)) {\n         // If neededBytesPerSec is too low, then wait few seconds for some old\n         // scannedBytes records to expire.\n         return 30000L;\n       }\n \n       // Find a usable block pool to scan.\n-      if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n-        long timeout \u003d findNextUsableBlockIter();\n-        if (timeout \u003e 0) {\n-          LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n-              \"{} ms.\", this, timeout);\n-          synchronized (stats) {\n-            stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n+      if (suspectBlock !\u003d null) {\n+        block \u003d suspectBlock;\n+      } else {\n+        if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n+          long timeout \u003d findNextUsableBlockIter();\n+          if (timeout \u003e 0) {\n+            LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n+                \"{} ms.\", this, timeout);\n+            synchronized (stats) {\n+              stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n+            }\n+            return timeout;\n           }\n-          return timeout;\n+          synchronized (stats) {\n+            stats.scansSinceRestart++;\n+            stats.blocksScannedInCurrentPeriod \u003d 0;\n+            stats.nextBlockPoolScanStartMs \u003d -1;\n+          }\n+          return 0L;\n         }\n-        synchronized (stats) {\n-          stats.scansSinceRestart++;\n-          stats.blocksScannedInCurrentPeriod \u003d 0;\n-          stats.nextBlockPoolScanStartMs \u003d -1;\n+        try {\n+          block \u003d curBlockIter.nextBlock();\n+        } catch (IOException e) {\n+          // There was an error listing the next block in the volume.  This is a\n+          // serious issue.\n+          LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n+          // On the next loop iteration, curBlockIter#eof will be set to true, and\n+          // we will pick a different block iterator.\n+          return 0L;\n         }\n-        return 0L;\n-      }\n-\n-      try {\n-        block \u003d curBlockIter.nextBlock();\n-      } catch (IOException e) {\n-        // There was an error listing the next block in the volume.  This is a\n-        // serious issue.\n-        LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n-        // On the next loop iteration, curBlockIter#eof will be set to true, and\n-        // we will pick a different block iterator.\n-        return 0L;\n-      }\n-      if (block \u003d\u003d null) {\n-        // The BlockIterator is at EOF.\n-        LOG.info(\"{}: finished scanning block pool {}\",\n-            this, curBlockIter.getBlockPoolId());\n-        saveBlockIterator(curBlockIter);\n-        return 0;\n+        if (block \u003d\u003d null) {\n+          // The BlockIterator is at EOF.\n+          LOG.info(\"{}: finished scanning block pool {}\",\n+              this, curBlockIter.getBlockPoolId());\n+          saveBlockIterator(curBlockIter);\n+          return 0;\n+        }\n       }\n       long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n       if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n         LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n             this, curBlockIter, saveDelta);\n         saveBlockIterator(curBlockIter);\n       }\n       bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n       if (bytesScanned \u003e\u003d 0) {\n         scannedBytesSum +\u003d bytesScanned;\n         scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n       } else {\n         scanError \u003d true;\n       }\n       return 0L;\n     } finally {\n       synchronized (stats) {\n         stats.bytesScannedInPastHour \u003d scannedBytesSum;\n-        if (bytesScanned \u003e\u003d 0) {\n+        if (bytesScanned \u003e 0) {\n           stats.blocksScannedInCurrentPeriod++;\n           stats.blocksScannedSinceRestart++;\n         }\n         if (scanError) {\n           stats.scanErrorsSinceRestart++;\n         }\n         if (block !\u003d null) {\n           stats.lastBlockScanned \u003d block;\n         }\n         if (curBlockIter \u003d\u003d null) {\n           stats.eof \u003d true;\n           stats.blockPoolPeriodEndsMs \u003d -1;\n         } else {\n           stats.eof \u003d curBlockIter.atEnd();\n           stats.blockPoolPeriodEndsMs \u003d\n               curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private long runLoop(ExtendedBlock suspectBlock) {\n    long bytesScanned \u003d -1;\n    boolean scanError \u003d false;\n    ExtendedBlock block \u003d null;\n    try {\n      long monotonicMs \u003d Time.monotonicNow();\n      expireOldScannedBytesRecords(monotonicMs);\n\n      if (!calculateShouldScan(volume.getStorageID(), conf.targetBytesPerSec,\n          scannedBytesSum, startMinute, curMinute)) {\n        // If neededBytesPerSec is too low, then wait few seconds for some old\n        // scannedBytes records to expire.\n        return 30000L;\n      }\n\n      // Find a usable block pool to scan.\n      if (suspectBlock !\u003d null) {\n        block \u003d suspectBlock;\n      } else {\n        if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n          long timeout \u003d findNextUsableBlockIter();\n          if (timeout \u003e 0) {\n            LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n                \"{} ms.\", this, timeout);\n            synchronized (stats) {\n              stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n            }\n            return timeout;\n          }\n          synchronized (stats) {\n            stats.scansSinceRestart++;\n            stats.blocksScannedInCurrentPeriod \u003d 0;\n            stats.nextBlockPoolScanStartMs \u003d -1;\n          }\n          return 0L;\n        }\n        try {\n          block \u003d curBlockIter.nextBlock();\n        } catch (IOException e) {\n          // There was an error listing the next block in the volume.  This is a\n          // serious issue.\n          LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n          // On the next loop iteration, curBlockIter#eof will be set to true, and\n          // we will pick a different block iterator.\n          return 0L;\n        }\n        if (block \u003d\u003d null) {\n          // The BlockIterator is at EOF.\n          LOG.info(\"{}: finished scanning block pool {}\",\n              this, curBlockIter.getBlockPoolId());\n          saveBlockIterator(curBlockIter);\n          return 0;\n        }\n      }\n      long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n      if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n        LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n            this, curBlockIter, saveDelta);\n        saveBlockIterator(curBlockIter);\n      }\n      bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n      if (bytesScanned \u003e\u003d 0) {\n        scannedBytesSum +\u003d bytesScanned;\n        scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n      } else {\n        scanError \u003d true;\n      }\n      return 0L;\n    } finally {\n      synchronized (stats) {\n        stats.bytesScannedInPastHour \u003d scannedBytesSum;\n        if (bytesScanned \u003e 0) {\n          stats.blocksScannedInCurrentPeriod++;\n          stats.blocksScannedSinceRestart++;\n        }\n        if (scanError) {\n          stats.scanErrorsSinceRestart++;\n        }\n        if (block !\u003d null) {\n          stats.lastBlockScanned \u003d block;\n        }\n        if (curBlockIter \u003d\u003d null) {\n          stats.eof \u003d true;\n          stats.blockPoolPeriodEndsMs \u003d -1;\n        } else {\n          stats.eof \u003d curBlockIter.atEnd();\n          stats.blockPoolPeriodEndsMs \u003d\n              curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n        }\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/VolumeScanner.java",
          "extendedDetails": {}
        }
      ]
    },
    "115428176e1d919fe7d54d01b34dfda57d1b3950": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7721. The HDFS BlockScanner may run fast during the first hour (cmccabe)\n",
      "commitDate": "03/02/15 11:05 AM",
      "commitName": "115428176e1d919fe7d54d01b34dfda57d1b3950",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "21/01/15 7:00 PM",
      "commitNameOld": "6e62a1a6728b1f782f64065424f92b292c3f163a",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 12.67,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,89 @@\n   private long runLoop() {\n     long bytesScanned \u003d -1;\n     boolean scanError \u003d false;\n     ExtendedBlock block \u003d null;\n     try {\n       long monotonicMs \u003d Time.monotonicNow();\n       expireOldScannedBytesRecords(monotonicMs);\n \n-      if (!calculateShouldScan(conf.targetBytesPerSec, scannedBytesSum)) {\n+      if (!calculateShouldScan(volume.getStorageID(), conf.targetBytesPerSec,\n+          scannedBytesSum, startMinute, curMinute)) {\n         // If neededBytesPerSec is too low, then wait few seconds for some old\n         // scannedBytes records to expire.\n         return 30000L;\n       }\n \n       // Find a usable block pool to scan.\n       if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n         long timeout \u003d findNextUsableBlockIter();\n         if (timeout \u003e 0) {\n           LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n               \"{} ms.\", this, timeout);\n           synchronized (stats) {\n             stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n           }\n           return timeout;\n         }\n         synchronized (stats) {\n           stats.scansSinceRestart++;\n           stats.blocksScannedInCurrentPeriod \u003d 0;\n           stats.nextBlockPoolScanStartMs \u003d -1;\n         }\n         return 0L;\n       }\n \n       try {\n         block \u003d curBlockIter.nextBlock();\n       } catch (IOException e) {\n         // There was an error listing the next block in the volume.  This is a\n         // serious issue.\n         LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n         // On the next loop iteration, curBlockIter#eof will be set to true, and\n         // we will pick a different block iterator.\n         return 0L;\n       }\n       if (block \u003d\u003d null) {\n         // The BlockIterator is at EOF.\n         LOG.info(\"{}: finished scanning block pool {}\",\n             this, curBlockIter.getBlockPoolId());\n         saveBlockIterator(curBlockIter);\n         return 0;\n       }\n       long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n       if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n         LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n             this, curBlockIter, saveDelta);\n         saveBlockIterator(curBlockIter);\n       }\n       bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n       if (bytesScanned \u003e\u003d 0) {\n         scannedBytesSum +\u003d bytesScanned;\n         scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n       } else {\n         scanError \u003d true;\n       }\n       return 0L;\n     } finally {\n       synchronized (stats) {\n         stats.bytesScannedInPastHour \u003d scannedBytesSum;\n         if (bytesScanned \u003e\u003d 0) {\n           stats.blocksScannedInCurrentPeriod++;\n           stats.blocksScannedSinceRestart++;\n         }\n         if (scanError) {\n           stats.scanErrorsSinceRestart++;\n         }\n         if (block !\u003d null) {\n           stats.lastBlockScanned \u003d block;\n         }\n         if (curBlockIter \u003d\u003d null) {\n           stats.eof \u003d true;\n           stats.blockPoolPeriodEndsMs \u003d -1;\n         } else {\n           stats.eof \u003d curBlockIter.atEnd();\n           stats.blockPoolPeriodEndsMs \u003d\n               curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long runLoop() {\n    long bytesScanned \u003d -1;\n    boolean scanError \u003d false;\n    ExtendedBlock block \u003d null;\n    try {\n      long monotonicMs \u003d Time.monotonicNow();\n      expireOldScannedBytesRecords(monotonicMs);\n\n      if (!calculateShouldScan(volume.getStorageID(), conf.targetBytesPerSec,\n          scannedBytesSum, startMinute, curMinute)) {\n        // If neededBytesPerSec is too low, then wait few seconds for some old\n        // scannedBytes records to expire.\n        return 30000L;\n      }\n\n      // Find a usable block pool to scan.\n      if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n        long timeout \u003d findNextUsableBlockIter();\n        if (timeout \u003e 0) {\n          LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n              \"{} ms.\", this, timeout);\n          synchronized (stats) {\n            stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n          }\n          return timeout;\n        }\n        synchronized (stats) {\n          stats.scansSinceRestart++;\n          stats.blocksScannedInCurrentPeriod \u003d 0;\n          stats.nextBlockPoolScanStartMs \u003d -1;\n        }\n        return 0L;\n      }\n\n      try {\n        block \u003d curBlockIter.nextBlock();\n      } catch (IOException e) {\n        // There was an error listing the next block in the volume.  This is a\n        // serious issue.\n        LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n        // On the next loop iteration, curBlockIter#eof will be set to true, and\n        // we will pick a different block iterator.\n        return 0L;\n      }\n      if (block \u003d\u003d null) {\n        // The BlockIterator is at EOF.\n        LOG.info(\"{}: finished scanning block pool {}\",\n            this, curBlockIter.getBlockPoolId());\n        saveBlockIterator(curBlockIter);\n        return 0;\n      }\n      long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n      if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n        LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n            this, curBlockIter, saveDelta);\n        saveBlockIterator(curBlockIter);\n      }\n      bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n      if (bytesScanned \u003e\u003d 0) {\n        scannedBytesSum +\u003d bytesScanned;\n        scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n      } else {\n        scanError \u003d true;\n      }\n      return 0L;\n    } finally {\n      synchronized (stats) {\n        stats.bytesScannedInPastHour \u003d scannedBytesSum;\n        if (bytesScanned \u003e\u003d 0) {\n          stats.blocksScannedInCurrentPeriod++;\n          stats.blocksScannedSinceRestart++;\n        }\n        if (scanError) {\n          stats.scanErrorsSinceRestart++;\n        }\n        if (block !\u003d null) {\n          stats.lastBlockScanned \u003d block;\n        }\n        if (curBlockIter \u003d\u003d null) {\n          stats.eof \u003d true;\n          stats.blockPoolPeriodEndsMs \u003d -1;\n        } else {\n          stats.eof \u003d curBlockIter.atEnd();\n          stats.blockPoolPeriodEndsMs \u003d\n              curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/VolumeScanner.java",
      "extendedDetails": {}
    },
    "6e62a1a6728b1f782f64065424f92b292c3f163a": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7430. Refactor the BlockScanner to use O(1) memory and use multiple threads (cmccabe)\n",
      "commitDate": "21/01/15 7:00 PM",
      "commitName": "6e62a1a6728b1f782f64065424f92b292c3f163a",
      "commitAuthor": "Colin Patrick Mccabe",
      "diff": "@@ -0,0 +1,88 @@\n+  private long runLoop() {\n+    long bytesScanned \u003d -1;\n+    boolean scanError \u003d false;\n+    ExtendedBlock block \u003d null;\n+    try {\n+      long monotonicMs \u003d Time.monotonicNow();\n+      expireOldScannedBytesRecords(monotonicMs);\n+\n+      if (!calculateShouldScan(conf.targetBytesPerSec, scannedBytesSum)) {\n+        // If neededBytesPerSec is too low, then wait few seconds for some old\n+        // scannedBytes records to expire.\n+        return 30000L;\n+      }\n+\n+      // Find a usable block pool to scan.\n+      if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n+        long timeout \u003d findNextUsableBlockIter();\n+        if (timeout \u003e 0) {\n+          LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n+              \"{} ms.\", this, timeout);\n+          synchronized (stats) {\n+            stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n+          }\n+          return timeout;\n+        }\n+        synchronized (stats) {\n+          stats.scansSinceRestart++;\n+          stats.blocksScannedInCurrentPeriod \u003d 0;\n+          stats.nextBlockPoolScanStartMs \u003d -1;\n+        }\n+        return 0L;\n+      }\n+\n+      try {\n+        block \u003d curBlockIter.nextBlock();\n+      } catch (IOException e) {\n+        // There was an error listing the next block in the volume.  This is a\n+        // serious issue.\n+        LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n+        // On the next loop iteration, curBlockIter#eof will be set to true, and\n+        // we will pick a different block iterator.\n+        return 0L;\n+      }\n+      if (block \u003d\u003d null) {\n+        // The BlockIterator is at EOF.\n+        LOG.info(\"{}: finished scanning block pool {}\",\n+            this, curBlockIter.getBlockPoolId());\n+        saveBlockIterator(curBlockIter);\n+        return 0;\n+      }\n+      long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n+      if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n+        LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n+            this, curBlockIter, saveDelta);\n+        saveBlockIterator(curBlockIter);\n+      }\n+      bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n+      if (bytesScanned \u003e\u003d 0) {\n+        scannedBytesSum +\u003d bytesScanned;\n+        scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n+      } else {\n+        scanError \u003d true;\n+      }\n+      return 0L;\n+    } finally {\n+      synchronized (stats) {\n+        stats.bytesScannedInPastHour \u003d scannedBytesSum;\n+        if (bytesScanned \u003e\u003d 0) {\n+          stats.blocksScannedInCurrentPeriod++;\n+          stats.blocksScannedSinceRestart++;\n+        }\n+        if (scanError) {\n+          stats.scanErrorsSinceRestart++;\n+        }\n+        if (block !\u003d null) {\n+          stats.lastBlockScanned \u003d block;\n+        }\n+        if (curBlockIter \u003d\u003d null) {\n+          stats.eof \u003d true;\n+          stats.blockPoolPeriodEndsMs \u003d -1;\n+        } else {\n+          stats.eof \u003d curBlockIter.atEnd();\n+          stats.blockPoolPeriodEndsMs \u003d\n+              curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private long runLoop() {\n    long bytesScanned \u003d -1;\n    boolean scanError \u003d false;\n    ExtendedBlock block \u003d null;\n    try {\n      long monotonicMs \u003d Time.monotonicNow();\n      expireOldScannedBytesRecords(monotonicMs);\n\n      if (!calculateShouldScan(conf.targetBytesPerSec, scannedBytesSum)) {\n        // If neededBytesPerSec is too low, then wait few seconds for some old\n        // scannedBytes records to expire.\n        return 30000L;\n      }\n\n      // Find a usable block pool to scan.\n      if ((curBlockIter \u003d\u003d null) || curBlockIter.atEnd()) {\n        long timeout \u003d findNextUsableBlockIter();\n        if (timeout \u003e 0) {\n          LOG.trace(\"{}: no block pools are ready to scan yet.  Waiting \" +\n              \"{} ms.\", this, timeout);\n          synchronized (stats) {\n            stats.nextBlockPoolScanStartMs \u003d Time.monotonicNow() + timeout;\n          }\n          return timeout;\n        }\n        synchronized (stats) {\n          stats.scansSinceRestart++;\n          stats.blocksScannedInCurrentPeriod \u003d 0;\n          stats.nextBlockPoolScanStartMs \u003d -1;\n        }\n        return 0L;\n      }\n\n      try {\n        block \u003d curBlockIter.nextBlock();\n      } catch (IOException e) {\n        // There was an error listing the next block in the volume.  This is a\n        // serious issue.\n        LOG.warn(\"{}: nextBlock error on {}\", this, curBlockIter);\n        // On the next loop iteration, curBlockIter#eof will be set to true, and\n        // we will pick a different block iterator.\n        return 0L;\n      }\n      if (block \u003d\u003d null) {\n        // The BlockIterator is at EOF.\n        LOG.info(\"{}: finished scanning block pool {}\",\n            this, curBlockIter.getBlockPoolId());\n        saveBlockIterator(curBlockIter);\n        return 0;\n      }\n      long saveDelta \u003d monotonicMs - curBlockIter.getLastSavedMs();\n      if (saveDelta \u003e\u003d conf.cursorSaveMs) {\n        LOG.debug(\"{}: saving block iterator {} after {} ms.\",\n            this, curBlockIter, saveDelta);\n        saveBlockIterator(curBlockIter);\n      }\n      bytesScanned \u003d scanBlock(block, conf.targetBytesPerSec);\n      if (bytesScanned \u003e\u003d 0) {\n        scannedBytesSum +\u003d bytesScanned;\n        scannedBytes[(int)(curMinute % MINUTES_PER_HOUR)] +\u003d bytesScanned;\n      } else {\n        scanError \u003d true;\n      }\n      return 0L;\n    } finally {\n      synchronized (stats) {\n        stats.bytesScannedInPastHour \u003d scannedBytesSum;\n        if (bytesScanned \u003e\u003d 0) {\n          stats.blocksScannedInCurrentPeriod++;\n          stats.blocksScannedSinceRestart++;\n        }\n        if (scanError) {\n          stats.scanErrorsSinceRestart++;\n        }\n        if (block !\u003d null) {\n          stats.lastBlockScanned \u003d block;\n        }\n        if (curBlockIter \u003d\u003d null) {\n          stats.eof \u003d true;\n          stats.blockPoolPeriodEndsMs \u003d -1;\n        } else {\n          stats.eof \u003d curBlockIter.atEnd();\n          stats.blockPoolPeriodEndsMs \u003d\n              curBlockIter.getIterStartMs() + conf.scanPeriodMs;\n        }\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/VolumeScanner.java"
    }
  }
}