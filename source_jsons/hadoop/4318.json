{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SaslDataTransferServer.java",
  "functionName": "doSaslHandshake",
  "functionId": "doSaslHandshake___peer-Peer__underlyingOut-OutputStream__underlyingIn-InputStream__saslProps-Map__String,String____callbackHandler-CallbackHandler",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferServer.java",
  "functionStartLine": 362,
  "functionEndLine": 449,
  "numCommitsSeen": 20,
  "timeTaken": 4159,
  "changeHistory": [
    "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1",
    "626fec652b9f3dae10c9af78fd220b1240f19fc7",
    "d1dd248b756e5a323ac885eefd3f81a639d6b86f",
    "5df7ecb33ab24de903f0fd98e2a055164874def5",
    "58c0bb9ed9f4a2491395b63c68046562a73526c9",
    "3b54223c0f32d42a84436c670d80b791a8e9696d"
  ],
  "changeHistoryShort": {
    "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1": "Ybodychange",
    "626fec652b9f3dae10c9af78fd220b1240f19fc7": "Ybodychange",
    "d1dd248b756e5a323ac885eefd3f81a639d6b86f": "Ymultichange(Yparameterchange,Ybodychange)",
    "5df7ecb33ab24de903f0fd98e2a055164874def5": "Ybodychange",
    "58c0bb9ed9f4a2491395b63c68046562a73526c9": "Ybodychange",
    "3b54223c0f32d42a84436c670d80b791a8e9696d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14611. Move handshake secret field from Token to BlockAccessToken. Contributed by Chen Liang.\n",
      "commitDate": "11/07/19 1:23 PM",
      "commitName": "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "12/04/19 5:37 PM",
      "commitNameOld": "626fec652b9f3dae10c9af78fd220b1240f19fc7",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 89.82,
      "commitsBetweenForRepo": 602,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,88 @@\n   private IOStreamPair doSaslHandshake(Peer peer, OutputStream underlyingOut,\n       InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n       CallbackHandler callbackHandler) throws IOException {\n \n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n \n     int magicNumber \u003d in.readInt();\n     if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n       throw new InvalidMagicNumberException(magicNumber, \n           dnConf.getEncryptDataTransfer());\n     }\n     try {\n       // step 1\n       SaslMessageWithHandshake message \u003d readSaslMessageWithHandshakeSecret(in);\n       byte[] secret \u003d message.getSecret();\n       String bpid \u003d message.getBpid();\n       if (secret !\u003d null || bpid !\u003d null) {\n         // sanity check, if one is null, the other must also not be null\n         assert(secret !\u003d null \u0026\u0026 bpid !\u003d null);\n-        String qop \u003d examineSecret(secret, bpid);\n-        if (qop !\u003d null) {\n-          saslProps.put(Sasl.QOP, qop);\n-        } else {\n-          LOG.error(\"Unable to match secret to a QOP!\");\n-        }\n+        String qop \u003d new String(secret, Charsets.UTF_8);\n+        saslProps.put(Sasl.QOP, qop);\n       }\n       SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(\n           saslProps, callbackHandler);\n \n       byte[] remoteResponse \u003d message.getPayload();\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n       sendSaslMessage(out, localResponse);\n \n       // step 2 (server-side only)\n       List\u003cCipherOption\u003e cipherOptions \u003d Lists.newArrayList();\n       remoteResponse \u003d readSaslMessageAndNegotiationCipherOptions(\n           in, cipherOptions);\n       localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n \n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n       CipherOption cipherOption \u003d null;\n       negotiatedQOP \u003d sasl.getNegotiatedQop();\n       if (sasl.isNegotiatedQopPrivacy()) {\n         // Negotiate a cipher option\n         Configuration conf \u003d dnConf.getConf();\n         cipherOption \u003d negotiateCipherOption(conf, cipherOptions);\n         if (LOG.isDebugEnabled()) {\n           if (cipherOption \u003d\u003d null) {\n             // No cipher suite is negotiated\n             String cipherSuites \u003d\n                 conf.get(DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n             if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n               // the server accepts some cipher suites, but the client does not.\n               LOG.debug(\"Server accepts cipher suites {}, \"\n                       + \"but client {} does not accept any of them\",\n                   cipherSuites, peer.getRemoteAddressString());\n             }\n           } else {\n             LOG.debug(\"Server using cipher suite {} with client {}\",\n                 cipherOption.getCipherSuite().getName(),\n                 peer.getRemoteAddressString());\n           }\n         }\n       }\n \n       // If negotiated cipher option is not null, wrap it before sending.\n       sendSaslMessageAndNegotiatedCipherOption(out, localResponse, \n           wrap(cipherOption, sasl));\n \n       // If negotiated cipher option is not null, we will use it to create \n       // stream pair.\n       return cipherOption !\u003d null ? createStreamPair(\n           dnConf.getConf(), cipherOption, underlyingOut, underlyingIn, true) : \n             sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       if (ioe instanceof SaslException \u0026\u0026\n           ioe.getCause() !\u003d null \u0026\u0026\n           ioe.getCause() instanceof InvalidEncryptionKeyException) {\n         // This could just be because the client is long-lived and hasn\u0027t gotten\n         // a new encryption key from the NN in a while. Upon receiving this\n         // error, the client will get a new encryption key from the NN and retry\n         // connecting to this DN.\n         sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n       } else {\n         sendGenericSaslErrorMessage(out, ioe.getMessage());\n       }\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private IOStreamPair doSaslHandshake(Peer peer, OutputStream underlyingOut,\n      InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n\n    int magicNumber \u003d in.readInt();\n    if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n      throw new InvalidMagicNumberException(magicNumber, \n          dnConf.getEncryptDataTransfer());\n    }\n    try {\n      // step 1\n      SaslMessageWithHandshake message \u003d readSaslMessageWithHandshakeSecret(in);\n      byte[] secret \u003d message.getSecret();\n      String bpid \u003d message.getBpid();\n      if (secret !\u003d null || bpid !\u003d null) {\n        // sanity check, if one is null, the other must also not be null\n        assert(secret !\u003d null \u0026\u0026 bpid !\u003d null);\n        String qop \u003d new String(secret, Charsets.UTF_8);\n        saslProps.put(Sasl.QOP, qop);\n      }\n      SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(\n          saslProps, callbackHandler);\n\n      byte[] remoteResponse \u003d message.getPayload();\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      sendSaslMessage(out, localResponse);\n\n      // step 2 (server-side only)\n      List\u003cCipherOption\u003e cipherOptions \u003d Lists.newArrayList();\n      remoteResponse \u003d readSaslMessageAndNegotiationCipherOptions(\n          in, cipherOptions);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      negotiatedQOP \u003d sasl.getNegotiatedQop();\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Negotiate a cipher option\n        Configuration conf \u003d dnConf.getConf();\n        cipherOption \u003d negotiateCipherOption(conf, cipherOptions);\n        if (LOG.isDebugEnabled()) {\n          if (cipherOption \u003d\u003d null) {\n            // No cipher suite is negotiated\n            String cipherSuites \u003d\n                conf.get(DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n              // the server accepts some cipher suites, but the client does not.\n              LOG.debug(\"Server accepts cipher suites {}, \"\n                      + \"but client {} does not accept any of them\",\n                  cipherSuites, peer.getRemoteAddressString());\n            }\n          } else {\n            LOG.debug(\"Server using cipher suite {} with client {}\",\n                cipherOption.getCipherSuite().getName(),\n                peer.getRemoteAddressString());\n          }\n        }\n      }\n\n      // If negotiated cipher option is not null, wrap it before sending.\n      sendSaslMessageAndNegotiatedCipherOption(out, localResponse, \n          wrap(cipherOption, sasl));\n\n      // If negotiated cipher option is not null, we will use it to create \n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          dnConf.getConf(), cipherOption, underlyingOut, underlyingIn, true) : \n            sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      if (ioe instanceof SaslException \u0026\u0026\n          ioe.getCause() !\u003d null \u0026\u0026\n          ioe.getCause() instanceof InvalidEncryptionKeyException) {\n        // This could just be because the client is long-lived and hasn\u0027t gotten\n        // a new encryption key from the NN in a while. Upon receiving this\n        // error, the client will get a new encryption key from the NN and retry\n        // connecting to this DN.\n        sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n      } else {\n        sendGenericSaslErrorMessage(out, ioe.getMessage());\n      }\n      throw ioe;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferServer.java",
      "extendedDetails": {}
    },
    "626fec652b9f3dae10c9af78fd220b1240f19fc7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13699. Add DFSClient sending handshake token to DataNode, and allow DataNode overwrite downstream QOP. Contributed by Chen Liang.\n",
      "commitDate": "12/04/19 5:37 PM",
      "commitName": "626fec652b9f3dae10c9af78fd220b1240f19fc7",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "21/12/17 11:20 AM",
      "commitNameOld": "826507c41b7dd89ce5b53d2245d09c2443423670",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 477.22,
      "commitsBetweenForRepo": 4120,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,92 @@\n   private IOStreamPair doSaslHandshake(Peer peer, OutputStream underlyingOut,\n       InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n       CallbackHandler callbackHandler) throws IOException {\n \n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n \n-    SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(saslProps,\n-      callbackHandler);\n-\n     int magicNumber \u003d in.readInt();\n     if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n       throw new InvalidMagicNumberException(magicNumber, \n           dnConf.getEncryptDataTransfer());\n     }\n     try {\n       // step 1\n-      byte[] remoteResponse \u003d readSaslMessage(in);\n+      SaslMessageWithHandshake message \u003d readSaslMessageWithHandshakeSecret(in);\n+      byte[] secret \u003d message.getSecret();\n+      String bpid \u003d message.getBpid();\n+      if (secret !\u003d null || bpid !\u003d null) {\n+        // sanity check, if one is null, the other must also not be null\n+        assert(secret !\u003d null \u0026\u0026 bpid !\u003d null);\n+        String qop \u003d examineSecret(secret, bpid);\n+        if (qop !\u003d null) {\n+          saslProps.put(Sasl.QOP, qop);\n+        } else {\n+          LOG.error(\"Unable to match secret to a QOP!\");\n+        }\n+      }\n+      SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(\n+          saslProps, callbackHandler);\n+\n+      byte[] remoteResponse \u003d message.getPayload();\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n       sendSaslMessage(out, localResponse);\n \n       // step 2 (server-side only)\n       List\u003cCipherOption\u003e cipherOptions \u003d Lists.newArrayList();\n       remoteResponse \u003d readSaslMessageAndNegotiationCipherOptions(\n           in, cipherOptions);\n       localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n \n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n       CipherOption cipherOption \u003d null;\n+      negotiatedQOP \u003d sasl.getNegotiatedQop();\n       if (sasl.isNegotiatedQopPrivacy()) {\n         // Negotiate a cipher option\n         Configuration conf \u003d dnConf.getConf();\n         cipherOption \u003d negotiateCipherOption(conf, cipherOptions);\n         if (LOG.isDebugEnabled()) {\n           if (cipherOption \u003d\u003d null) {\n             // No cipher suite is negotiated\n             String cipherSuites \u003d\n                 conf.get(DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n             if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n               // the server accepts some cipher suites, but the client does not.\n               LOG.debug(\"Server accepts cipher suites {}, \"\n                       + \"but client {} does not accept any of them\",\n                   cipherSuites, peer.getRemoteAddressString());\n             }\n           } else {\n             LOG.debug(\"Server using cipher suite {} with client {}\",\n                 cipherOption.getCipherSuite().getName(),\n                 peer.getRemoteAddressString());\n           }\n         }\n       }\n \n       // If negotiated cipher option is not null, wrap it before sending.\n       sendSaslMessageAndNegotiatedCipherOption(out, localResponse, \n           wrap(cipherOption, sasl));\n \n       // If negotiated cipher option is not null, we will use it to create \n       // stream pair.\n       return cipherOption !\u003d null ? createStreamPair(\n           dnConf.getConf(), cipherOption, underlyingOut, underlyingIn, true) : \n             sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       if (ioe instanceof SaslException \u0026\u0026\n           ioe.getCause() !\u003d null \u0026\u0026\n           ioe.getCause() instanceof InvalidEncryptionKeyException) {\n         // This could just be because the client is long-lived and hasn\u0027t gotten\n         // a new encryption key from the NN in a while. Upon receiving this\n         // error, the client will get a new encryption key from the NN and retry\n         // connecting to this DN.\n         sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n       } else {\n         sendGenericSaslErrorMessage(out, ioe.getMessage());\n       }\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private IOStreamPair doSaslHandshake(Peer peer, OutputStream underlyingOut,\n      InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n\n    int magicNumber \u003d in.readInt();\n    if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n      throw new InvalidMagicNumberException(magicNumber, \n          dnConf.getEncryptDataTransfer());\n    }\n    try {\n      // step 1\n      SaslMessageWithHandshake message \u003d readSaslMessageWithHandshakeSecret(in);\n      byte[] secret \u003d message.getSecret();\n      String bpid \u003d message.getBpid();\n      if (secret !\u003d null || bpid !\u003d null) {\n        // sanity check, if one is null, the other must also not be null\n        assert(secret !\u003d null \u0026\u0026 bpid !\u003d null);\n        String qop \u003d examineSecret(secret, bpid);\n        if (qop !\u003d null) {\n          saslProps.put(Sasl.QOP, qop);\n        } else {\n          LOG.error(\"Unable to match secret to a QOP!\");\n        }\n      }\n      SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(\n          saslProps, callbackHandler);\n\n      byte[] remoteResponse \u003d message.getPayload();\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      sendSaslMessage(out, localResponse);\n\n      // step 2 (server-side only)\n      List\u003cCipherOption\u003e cipherOptions \u003d Lists.newArrayList();\n      remoteResponse \u003d readSaslMessageAndNegotiationCipherOptions(\n          in, cipherOptions);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      negotiatedQOP \u003d sasl.getNegotiatedQop();\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Negotiate a cipher option\n        Configuration conf \u003d dnConf.getConf();\n        cipherOption \u003d negotiateCipherOption(conf, cipherOptions);\n        if (LOG.isDebugEnabled()) {\n          if (cipherOption \u003d\u003d null) {\n            // No cipher suite is negotiated\n            String cipherSuites \u003d\n                conf.get(DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n              // the server accepts some cipher suites, but the client does not.\n              LOG.debug(\"Server accepts cipher suites {}, \"\n                      + \"but client {} does not accept any of them\",\n                  cipherSuites, peer.getRemoteAddressString());\n            }\n          } else {\n            LOG.debug(\"Server using cipher suite {} with client {}\",\n                cipherOption.getCipherSuite().getName(),\n                peer.getRemoteAddressString());\n          }\n        }\n      }\n\n      // If negotiated cipher option is not null, wrap it before sending.\n      sendSaslMessageAndNegotiatedCipherOption(out, localResponse, \n          wrap(cipherOption, sasl));\n\n      // If negotiated cipher option is not null, we will use it to create \n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          dnConf.getConf(), cipherOption, underlyingOut, underlyingIn, true) : \n            sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      if (ioe instanceof SaslException \u0026\u0026\n          ioe.getCause() !\u003d null \u0026\u0026\n          ioe.getCause() instanceof InvalidEncryptionKeyException) {\n        // This could just be because the client is long-lived and hasn\u0027t gotten\n        // a new encryption key from the NN in a while. Upon receiving this\n        // error, the client will get a new encryption key from the NN and retry\n        // connecting to this DN.\n        sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n      } else {\n        sendGenericSaslErrorMessage(out, ioe.getMessage());\n      }\n      throw ioe;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferServer.java",
      "extendedDetails": {}
    },
    "d1dd248b756e5a323ac885eefd3f81a639d6b86f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9854. Log cipher suite negotiation more verbosely. Contributed by Wei-Chiu Chuang.\n",
      "commitDate": "24/02/16 12:11 PM",
      "commitName": "d1dd248b756e5a323ac885eefd3f81a639d6b86f",
      "commitAuthor": "cnauroth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9854. Log cipher suite negotiation more verbosely. Contributed by Wei-Chiu Chuang.\n",
          "commitDate": "24/02/16 12:11 PM",
          "commitName": "d1dd248b756e5a323ac885eefd3f81a639d6b86f",
          "commitAuthor": "cnauroth",
          "commitDateOld": "03/09/15 3:32 PM",
          "commitNameOld": "ed78b14ebc9a21bb57ccd088e8b49bfa457a396f",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 173.9,
          "commitsBetweenForRepo": 1199,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,78 @@\n-  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n+  private IOStreamPair doSaslHandshake(Peer peer, OutputStream underlyingOut,\n       InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n       CallbackHandler callbackHandler) throws IOException {\n \n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n \n     SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(saslProps,\n       callbackHandler);\n \n     int magicNumber \u003d in.readInt();\n     if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n       throw new InvalidMagicNumberException(magicNumber, \n           dnConf.getEncryptDataTransfer());\n     }\n     try {\n       // step 1\n       byte[] remoteResponse \u003d readSaslMessage(in);\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n       sendSaslMessage(out, localResponse);\n \n       // step 2 (server-side only)\n       List\u003cCipherOption\u003e cipherOptions \u003d Lists.newArrayList();\n       remoteResponse \u003d readSaslMessageAndNegotiationCipherOptions(\n           in, cipherOptions);\n       localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n \n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n       CipherOption cipherOption \u003d null;\n       if (sasl.isNegotiatedQopPrivacy()) {\n         // Negotiate a cipher option\n-        cipherOption \u003d negotiateCipherOption(dnConf.getConf(), cipherOptions);\n-        if (cipherOption !\u003d null) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Server using cipher suite \" + \n-                cipherOption.getCipherSuite().getName());\n+        Configuration conf \u003d dnConf.getConf();\n+        cipherOption \u003d negotiateCipherOption(conf, cipherOptions);\n+        if (LOG.isDebugEnabled()) {\n+          if (cipherOption \u003d\u003d null) {\n+            // No cipher suite is negotiated\n+            String cipherSuites \u003d\n+                conf.get(DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n+            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n+              // the server accepts some cipher suites, but the client does not.\n+              LOG.debug(\"Server accepts cipher suites {}, \"\n+                      + \"but client {} does not accept any of them\",\n+                  cipherSuites, peer.getRemoteAddressString());\n+            }\n+          } else {\n+            LOG.debug(\"Server using cipher suite {} with client {}\",\n+                cipherOption.getCipherSuite().getName(),\n+                peer.getRemoteAddressString());\n           }\n         }\n       }\n \n       // If negotiated cipher option is not null, wrap it before sending.\n       sendSaslMessageAndNegotiatedCipherOption(out, localResponse, \n           wrap(cipherOption, sasl));\n \n       // If negotiated cipher option is not null, we will use it to create \n       // stream pair.\n       return cipherOption !\u003d null ? createStreamPair(\n           dnConf.getConf(), cipherOption, underlyingOut, underlyingIn, true) : \n             sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       if (ioe instanceof SaslException \u0026\u0026\n           ioe.getCause() !\u003d null \u0026\u0026\n           ioe.getCause() instanceof InvalidEncryptionKeyException) {\n         // This could just be because the client is long-lived and hasn\u0027t gotten\n         // a new encryption key from the NN in a while. Upon receiving this\n         // error, the client will get a new encryption key from the NN and retry\n         // connecting to this DN.\n         sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n       } else {\n         sendGenericSaslErrorMessage(out, ioe.getMessage());\n       }\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private IOStreamPair doSaslHandshake(Peer peer, OutputStream underlyingOut,\n      InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n\n    SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(saslProps,\n      callbackHandler);\n\n    int magicNumber \u003d in.readInt();\n    if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n      throw new InvalidMagicNumberException(magicNumber, \n          dnConf.getEncryptDataTransfer());\n    }\n    try {\n      // step 1\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      sendSaslMessage(out, localResponse);\n\n      // step 2 (server-side only)\n      List\u003cCipherOption\u003e cipherOptions \u003d Lists.newArrayList();\n      remoteResponse \u003d readSaslMessageAndNegotiationCipherOptions(\n          in, cipherOptions);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Negotiate a cipher option\n        Configuration conf \u003d dnConf.getConf();\n        cipherOption \u003d negotiateCipherOption(conf, cipherOptions);\n        if (LOG.isDebugEnabled()) {\n          if (cipherOption \u003d\u003d null) {\n            // No cipher suite is negotiated\n            String cipherSuites \u003d\n                conf.get(DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n              // the server accepts some cipher suites, but the client does not.\n              LOG.debug(\"Server accepts cipher suites {}, \"\n                      + \"but client {} does not accept any of them\",\n                  cipherSuites, peer.getRemoteAddressString());\n            }\n          } else {\n            LOG.debug(\"Server using cipher suite {} with client {}\",\n                cipherOption.getCipherSuite().getName(),\n                peer.getRemoteAddressString());\n          }\n        }\n      }\n\n      // If negotiated cipher option is not null, wrap it before sending.\n      sendSaslMessageAndNegotiatedCipherOption(out, localResponse, \n          wrap(cipherOption, sasl));\n\n      // If negotiated cipher option is not null, we will use it to create \n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          dnConf.getConf(), cipherOption, underlyingOut, underlyingIn, true) : \n            sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      if (ioe instanceof SaslException \u0026\u0026\n          ioe.getCause() !\u003d null \u0026\u0026\n          ioe.getCause() instanceof InvalidEncryptionKeyException) {\n        // This could just be because the client is long-lived and hasn\u0027t gotten\n        // a new encryption key from the NN in a while. Upon receiving this\n        // error, the client will get a new encryption key from the NN and retry\n        // connecting to this DN.\n        sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n      } else {\n        sendGenericSaslErrorMessage(out, ioe.getMessage());\n      }\n      throw ioe;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferServer.java",
          "extendedDetails": {
            "oldValue": "[underlyingOut-OutputStream, underlyingIn-InputStream, saslProps-Map\u003cString,String\u003e, callbackHandler-CallbackHandler]",
            "newValue": "[peer-Peer, underlyingOut-OutputStream, underlyingIn-InputStream, saslProps-Map\u003cString,String\u003e, callbackHandler-CallbackHandler]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9854. Log cipher suite negotiation more verbosely. Contributed by Wei-Chiu Chuang.\n",
          "commitDate": "24/02/16 12:11 PM",
          "commitName": "d1dd248b756e5a323ac885eefd3f81a639d6b86f",
          "commitAuthor": "cnauroth",
          "commitDateOld": "03/09/15 3:32 PM",
          "commitNameOld": "ed78b14ebc9a21bb57ccd088e8b49bfa457a396f",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 173.9,
          "commitsBetweenForRepo": 1199,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,78 @@\n-  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n+  private IOStreamPair doSaslHandshake(Peer peer, OutputStream underlyingOut,\n       InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n       CallbackHandler callbackHandler) throws IOException {\n \n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n \n     SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(saslProps,\n       callbackHandler);\n \n     int magicNumber \u003d in.readInt();\n     if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n       throw new InvalidMagicNumberException(magicNumber, \n           dnConf.getEncryptDataTransfer());\n     }\n     try {\n       // step 1\n       byte[] remoteResponse \u003d readSaslMessage(in);\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n       sendSaslMessage(out, localResponse);\n \n       // step 2 (server-side only)\n       List\u003cCipherOption\u003e cipherOptions \u003d Lists.newArrayList();\n       remoteResponse \u003d readSaslMessageAndNegotiationCipherOptions(\n           in, cipherOptions);\n       localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n \n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n       CipherOption cipherOption \u003d null;\n       if (sasl.isNegotiatedQopPrivacy()) {\n         // Negotiate a cipher option\n-        cipherOption \u003d negotiateCipherOption(dnConf.getConf(), cipherOptions);\n-        if (cipherOption !\u003d null) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Server using cipher suite \" + \n-                cipherOption.getCipherSuite().getName());\n+        Configuration conf \u003d dnConf.getConf();\n+        cipherOption \u003d negotiateCipherOption(conf, cipherOptions);\n+        if (LOG.isDebugEnabled()) {\n+          if (cipherOption \u003d\u003d null) {\n+            // No cipher suite is negotiated\n+            String cipherSuites \u003d\n+                conf.get(DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n+            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n+              // the server accepts some cipher suites, but the client does not.\n+              LOG.debug(\"Server accepts cipher suites {}, \"\n+                      + \"but client {} does not accept any of them\",\n+                  cipherSuites, peer.getRemoteAddressString());\n+            }\n+          } else {\n+            LOG.debug(\"Server using cipher suite {} with client {}\",\n+                cipherOption.getCipherSuite().getName(),\n+                peer.getRemoteAddressString());\n           }\n         }\n       }\n \n       // If negotiated cipher option is not null, wrap it before sending.\n       sendSaslMessageAndNegotiatedCipherOption(out, localResponse, \n           wrap(cipherOption, sasl));\n \n       // If negotiated cipher option is not null, we will use it to create \n       // stream pair.\n       return cipherOption !\u003d null ? createStreamPair(\n           dnConf.getConf(), cipherOption, underlyingOut, underlyingIn, true) : \n             sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       if (ioe instanceof SaslException \u0026\u0026\n           ioe.getCause() !\u003d null \u0026\u0026\n           ioe.getCause() instanceof InvalidEncryptionKeyException) {\n         // This could just be because the client is long-lived and hasn\u0027t gotten\n         // a new encryption key from the NN in a while. Upon receiving this\n         // error, the client will get a new encryption key from the NN and retry\n         // connecting to this DN.\n         sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n       } else {\n         sendGenericSaslErrorMessage(out, ioe.getMessage());\n       }\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private IOStreamPair doSaslHandshake(Peer peer, OutputStream underlyingOut,\n      InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n\n    SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(saslProps,\n      callbackHandler);\n\n    int magicNumber \u003d in.readInt();\n    if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n      throw new InvalidMagicNumberException(magicNumber, \n          dnConf.getEncryptDataTransfer());\n    }\n    try {\n      // step 1\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      sendSaslMessage(out, localResponse);\n\n      // step 2 (server-side only)\n      List\u003cCipherOption\u003e cipherOptions \u003d Lists.newArrayList();\n      remoteResponse \u003d readSaslMessageAndNegotiationCipherOptions(\n          in, cipherOptions);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Negotiate a cipher option\n        Configuration conf \u003d dnConf.getConf();\n        cipherOption \u003d negotiateCipherOption(conf, cipherOptions);\n        if (LOG.isDebugEnabled()) {\n          if (cipherOption \u003d\u003d null) {\n            // No cipher suite is negotiated\n            String cipherSuites \u003d\n                conf.get(DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n              // the server accepts some cipher suites, but the client does not.\n              LOG.debug(\"Server accepts cipher suites {}, \"\n                      + \"but client {} does not accept any of them\",\n                  cipherSuites, peer.getRemoteAddressString());\n            }\n          } else {\n            LOG.debug(\"Server using cipher suite {} with client {}\",\n                cipherOption.getCipherSuite().getName(),\n                peer.getRemoteAddressString());\n          }\n        }\n      }\n\n      // If negotiated cipher option is not null, wrap it before sending.\n      sendSaslMessageAndNegotiatedCipherOption(out, localResponse, \n          wrap(cipherOption, sasl));\n\n      // If negotiated cipher option is not null, we will use it to create \n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          dnConf.getConf(), cipherOption, underlyingOut, underlyingIn, true) : \n            sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      if (ioe instanceof SaslException \u0026\u0026\n          ioe.getCause() !\u003d null \u0026\u0026\n          ioe.getCause() instanceof InvalidEncryptionKeyException) {\n        // This could just be because the client is long-lived and hasn\u0027t gotten\n        // a new encryption key from the NN in a while. Upon receiving this\n        // error, the client will get a new encryption key from the NN and retry\n        // connecting to this DN.\n        sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n      } else {\n        sendGenericSaslErrorMessage(out, ioe.getMessage());\n      }\n      throw ioe;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferServer.java",
          "extendedDetails": {}
        }
      ]
    },
    "5df7ecb33ab24de903f0fd98e2a055164874def5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7431. log message for InvalidMagicNumberException may be incorrect. Contributed by Yi Liu.\n",
      "commitDate": "18/12/14 3:03 PM",
      "commitName": "5df7ecb33ab24de903f0fd98e2a055164874def5",
      "commitAuthor": "cnauroth",
      "commitDateOld": "14/11/14 4:43 PM",
      "commitNameOld": "1925e2a4ae78ef4178393848b4d1d71b0f4a4709",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 33.93,
      "commitsBetweenForRepo": 226,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,66 @@\n   private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n       InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n       CallbackHandler callbackHandler) throws IOException {\n \n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n \n     SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(saslProps,\n       callbackHandler);\n \n     int magicNumber \u003d in.readInt();\n     if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n-      throw new InvalidMagicNumberException(magicNumber);\n+      throw new InvalidMagicNumberException(magicNumber, \n+          dnConf.getEncryptDataTransfer());\n     }\n     try {\n       // step 1\n       byte[] remoteResponse \u003d readSaslMessage(in);\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n       sendSaslMessage(out, localResponse);\n \n       // step 2 (server-side only)\n       List\u003cCipherOption\u003e cipherOptions \u003d Lists.newArrayList();\n       remoteResponse \u003d readSaslMessageAndNegotiationCipherOptions(\n           in, cipherOptions);\n       localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n \n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n       CipherOption cipherOption \u003d null;\n       if (sasl.isNegotiatedQopPrivacy()) {\n         // Negotiate a cipher option\n         cipherOption \u003d negotiateCipherOption(dnConf.getConf(), cipherOptions);\n         if (cipherOption !\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Server using cipher suite \" + \n                 cipherOption.getCipherSuite().getName());\n           }\n         }\n       }\n \n       // If negotiated cipher option is not null, wrap it before sending.\n       sendSaslMessageAndNegotiatedCipherOption(out, localResponse, \n           wrap(cipherOption, sasl));\n \n       // If negotiated cipher option is not null, we will use it to create \n       // stream pair.\n       return cipherOption !\u003d null ? createStreamPair(\n           dnConf.getConf(), cipherOption, underlyingOut, underlyingIn, true) : \n             sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       if (ioe instanceof SaslException \u0026\u0026\n           ioe.getCause() !\u003d null \u0026\u0026\n           ioe.getCause() instanceof InvalidEncryptionKeyException) {\n         // This could just be because the client is long-lived and hasn\u0027t gotten\n         // a new encryption key from the NN in a while. Upon receiving this\n         // error, the client will get a new encryption key from the NN and retry\n         // connecting to this DN.\n         sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n       } else {\n         sendGenericSaslErrorMessage(out, ioe.getMessage());\n       }\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n      InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n\n    SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(saslProps,\n      callbackHandler);\n\n    int magicNumber \u003d in.readInt();\n    if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n      throw new InvalidMagicNumberException(magicNumber, \n          dnConf.getEncryptDataTransfer());\n    }\n    try {\n      // step 1\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      sendSaslMessage(out, localResponse);\n\n      // step 2 (server-side only)\n      List\u003cCipherOption\u003e cipherOptions \u003d Lists.newArrayList();\n      remoteResponse \u003d readSaslMessageAndNegotiationCipherOptions(\n          in, cipherOptions);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Negotiate a cipher option\n        cipherOption \u003d negotiateCipherOption(dnConf.getConf(), cipherOptions);\n        if (cipherOption !\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Server using cipher suite \" + \n                cipherOption.getCipherSuite().getName());\n          }\n        }\n      }\n\n      // If negotiated cipher option is not null, wrap it before sending.\n      sendSaslMessageAndNegotiatedCipherOption(out, localResponse, \n          wrap(cipherOption, sasl));\n\n      // If negotiated cipher option is not null, we will use it to create \n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          dnConf.getConf(), cipherOption, underlyingOut, underlyingIn, true) : \n            sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      if (ioe instanceof SaslException \u0026\u0026\n          ioe.getCause() !\u003d null \u0026\u0026\n          ioe.getCause() instanceof InvalidEncryptionKeyException) {\n        // This could just be because the client is long-lived and hasn\u0027t gotten\n        // a new encryption key from the NN in a while. Upon receiving this\n        // error, the client will get a new encryption key from the NN and retry\n        // connecting to this DN.\n        sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n      } else {\n        sendGenericSaslErrorMessage(out, ioe.getMessage());\n      }\n      throw ioe;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferServer.java",
      "extendedDetails": {}
    },
    "58c0bb9ed9f4a2491395b63c68046562a73526c9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6606. Optimize HDFS Encrypted Transport performance. (yliu)\n",
      "commitDate": "28/10/14 6:11 AM",
      "commitName": "58c0bb9ed9f4a2491395b63c68046562a73526c9",
      "commitAuthor": "yliu",
      "commitDateOld": "19/09/14 9:23 PM",
      "commitNameOld": "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 38.37,
      "commitsBetweenForRepo": 354,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,65 @@\n   private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n       InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n       CallbackHandler callbackHandler) throws IOException {\n \n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n \n     SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(saslProps,\n       callbackHandler);\n \n     int magicNumber \u003d in.readInt();\n     if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n       throw new InvalidMagicNumberException(magicNumber);\n     }\n     try {\n       // step 1\n-      performSaslStep1(out, in, sasl);\n-\n-      // step 2 (server-side only)\n       byte[] remoteResponse \u003d readSaslMessage(in);\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n       sendSaslMessage(out, localResponse);\n \n+      // step 2 (server-side only)\n+      List\u003cCipherOption\u003e cipherOptions \u003d Lists.newArrayList();\n+      remoteResponse \u003d readSaslMessageAndNegotiationCipherOptions(\n+          in, cipherOptions);\n+      localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n+\n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n-      return sasl.createStreamPair(out, in);\n+      CipherOption cipherOption \u003d null;\n+      if (sasl.isNegotiatedQopPrivacy()) {\n+        // Negotiate a cipher option\n+        cipherOption \u003d negotiateCipherOption(dnConf.getConf(), cipherOptions);\n+        if (cipherOption !\u003d null) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Server using cipher suite \" + \n+                cipherOption.getCipherSuite().getName());\n+          }\n+        }\n+      }\n+\n+      // If negotiated cipher option is not null, wrap it before sending.\n+      sendSaslMessageAndNegotiatedCipherOption(out, localResponse, \n+          wrap(cipherOption, sasl));\n+\n+      // If negotiated cipher option is not null, we will use it to create \n+      // stream pair.\n+      return cipherOption !\u003d null ? createStreamPair(\n+          dnConf.getConf(), cipherOption, underlyingOut, underlyingIn, true) : \n+            sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       if (ioe instanceof SaslException \u0026\u0026\n           ioe.getCause() !\u003d null \u0026\u0026\n           ioe.getCause() instanceof InvalidEncryptionKeyException) {\n         // This could just be because the client is long-lived and hasn\u0027t gotten\n         // a new encryption key from the NN in a while. Upon receiving this\n         // error, the client will get a new encryption key from the NN and retry\n         // connecting to this DN.\n         sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n       } else {\n         sendGenericSaslErrorMessage(out, ioe.getMessage());\n       }\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n      InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n\n    SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(saslProps,\n      callbackHandler);\n\n    int magicNumber \u003d in.readInt();\n    if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n      throw new InvalidMagicNumberException(magicNumber);\n    }\n    try {\n      // step 1\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      sendSaslMessage(out, localResponse);\n\n      // step 2 (server-side only)\n      List\u003cCipherOption\u003e cipherOptions \u003d Lists.newArrayList();\n      remoteResponse \u003d readSaslMessageAndNegotiationCipherOptions(\n          in, cipherOptions);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Negotiate a cipher option\n        cipherOption \u003d negotiateCipherOption(dnConf.getConf(), cipherOptions);\n        if (cipherOption !\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Server using cipher suite \" + \n                cipherOption.getCipherSuite().getName());\n          }\n        }\n      }\n\n      // If negotiated cipher option is not null, wrap it before sending.\n      sendSaslMessageAndNegotiatedCipherOption(out, localResponse, \n          wrap(cipherOption, sasl));\n\n      // If negotiated cipher option is not null, we will use it to create \n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          dnConf.getConf(), cipherOption, underlyingOut, underlyingIn, true) : \n            sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      if (ioe instanceof SaslException \u0026\u0026\n          ioe.getCause() !\u003d null \u0026\u0026\n          ioe.getCause() instanceof InvalidEncryptionKeyException) {\n        // This could just be because the client is long-lived and hasn\u0027t gotten\n        // a new encryption key from the NN in a while. Upon receiving this\n        // error, the client will get a new encryption key from the NN and retry\n        // connecting to this DN.\n        sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n      } else {\n        sendGenericSaslErrorMessage(out, ioe.getMessage());\n      }\n      throw ioe;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferServer.java",
      "extendedDetails": {}
    },
    "3b54223c0f32d42a84436c670d80b791a8e9696d": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2856. Fix block protocol so that Datanodes don\u0027t require root or jsvc. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1610474 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/07/14 11:10 AM",
      "commitName": "3b54223c0f32d42a84436c670d80b791a8e9696d",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,42 @@\n+  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n+      InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n+      CallbackHandler callbackHandler) throws IOException {\n+\n+    DataInputStream in \u003d new DataInputStream(underlyingIn);\n+    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n+\n+    SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(saslProps,\n+      callbackHandler);\n+\n+    int magicNumber \u003d in.readInt();\n+    if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n+      throw new InvalidMagicNumberException(magicNumber);\n+    }\n+    try {\n+      // step 1\n+      performSaslStep1(out, in, sasl);\n+\n+      // step 2 (server-side only)\n+      byte[] remoteResponse \u003d readSaslMessage(in);\n+      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n+      sendSaslMessage(out, localResponse);\n+\n+      // SASL handshake is complete\n+      checkSaslComplete(sasl, saslProps);\n+\n+      return sasl.createStreamPair(out, in);\n+    } catch (IOException ioe) {\n+      if (ioe instanceof SaslException \u0026\u0026\n+          ioe.getCause() !\u003d null \u0026\u0026\n+          ioe.getCause() instanceof InvalidEncryptionKeyException) {\n+        // This could just be because the client is long-lived and hasn\u0027t gotten\n+        // a new encryption key from the NN in a while. Upon receiving this\n+        // error, the client will get a new encryption key from the NN and retry\n+        // connecting to this DN.\n+        sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n+      } else {\n+        sendGenericSaslErrorMessage(out, ioe.getMessage());\n+      }\n+      throw ioe;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n      InputStream underlyingIn, Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n\n    SaslParticipant sasl \u003d SaslParticipant.createServerSaslParticipant(saslProps,\n      callbackHandler);\n\n    int magicNumber \u003d in.readInt();\n    if (magicNumber !\u003d SASL_TRANSFER_MAGIC_NUMBER) {\n      throw new InvalidMagicNumberException(magicNumber);\n    }\n    try {\n      // step 1\n      performSaslStep1(out, in, sasl);\n\n      // step 2 (server-side only)\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      sendSaslMessage(out, localResponse);\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      return sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      if (ioe instanceof SaslException \u0026\u0026\n          ioe.getCause() !\u003d null \u0026\u0026\n          ioe.getCause() instanceof InvalidEncryptionKeyException) {\n        // This could just be because the client is long-lived and hasn\u0027t gotten\n        // a new encryption key from the NN in a while. Upon receiving this\n        // error, the client will get a new encryption key from the NN and retry\n        // connecting to this DN.\n        sendInvalidKeySaslErrorMessage(out, ioe.getCause().getMessage());\n      } else {\n        sendGenericSaslErrorMessage(out, ioe.getMessage());\n      }\n      throw ioe;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferServer.java"
    }
  }
}