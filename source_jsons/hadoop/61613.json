{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DominantResourceCalculator.java",
  "functionName": "compare",
  "functionId": "compare___clusterResource-Resource__lhs-Resource__rhs-Resource__singleType-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/resource/DominantResourceCalculator.java",
  "functionStartLine": 103,
  "functionEndLine": 168,
  "numCommitsSeen": 44,
  "timeTaken": 5873,
  "changeHistory": [
    "bb26514ba9e8a038749c4acd592a47d5cd5bf92a",
    "0921b706f7f80c40e061d2c0f8c8b2e4910071e5",
    "bf2b687412f9a830ec4834477ccf25dbe76fddcd",
    "b1fe3a222e7673fd84a878622969f958022061e9",
    "a0030c8c6f5489d8285632a651394b2b2320255c",
    "32c91223f1bd06561ea4ce2d1944e8d9a847f18c",
    "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae",
    "ebd797c48fe236b404cf3a125ac9d1f7714e291e",
    "37d7935a9d7b86635c9c1ffc03f88b49857f88a0"
  ],
  "changeHistoryShort": {
    "bb26514ba9e8a038749c4acd592a47d5cd5bf92a": "Ybodychange",
    "0921b706f7f80c40e061d2c0f8c8b2e4910071e5": "Ybodychange",
    "bf2b687412f9a830ec4834477ccf25dbe76fddcd": "Ybodychange",
    "b1fe3a222e7673fd84a878622969f958022061e9": "Ybodychange",
    "a0030c8c6f5489d8285632a651394b2b2320255c": "Ybodychange",
    "32c91223f1bd06561ea4ce2d1944e8d9a847f18c": "Ybodychange",
    "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf": "Ymultichange(Yparameterchange,Ybodychange)",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": "Ybodychange",
    "ebd797c48fe236b404cf3a125ac9d1f7714e291e": "Ybodychange",
    "37d7935a9d7b86635c9c1ffc03f88b49857f88a0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "bb26514ba9e8a038749c4acd592a47d5cd5bf92a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9785. Fix DominantResourceCalculator when one resource is zero. Contributed by Bibin A Chundatt, Sunil Govindan, Bilwa S T.\n",
      "commitDate": "02/09/19 11:55 PM",
      "commitName": "bb26514ba9e8a038749c4acd592a47d5cd5bf92a",
      "commitAuthor": "Zhankun Tang",
      "commitDateOld": "06/05/19 5:00 AM",
      "commitNameOld": "12b7059ddc8d8f67dd7131565f03a0e09cb92ca7",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 119.79,
      "commitsBetweenForRepo": 980,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n       boolean singleType) {\n     if (lhs.equals(rhs)) {\n       return 0;\n     }\n \n-    if (isInvalidDivisor(clusterResource)) {\n+    if (isAllInvalidDivisor(clusterResource)) {\n       return this.compare(lhs, rhs);\n     }\n \n     // We have to calculate the shares for all resource types for both\n     // resources and then look for which resource has the biggest\n     // share overall.\n     ResourceInformation[] clusterRes \u003d clusterResource.getResources();\n     int maxLength \u003d ResourceUtils.getNumberOfCountableResourceTypes();\n \n     // If array creation shows up as a time sink, these arrays could be cached\n     // because they\u0027re always the same length.\n     double[] lhsShares \u003d new double[maxLength];\n     double[] rhsShares \u003d new double[maxLength];\n     double diff;\n \n     try {\n       if (singleType) {\n         double[] max \u003d new double[2];\n \n         calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares, max);\n \n         diff \u003d max[0] - max[1];\n       } else if (maxLength \u003d\u003d 2) {\n         // Special case to handle the common scenario of only CPU and memory\n         // so that we can optimize for performance\n         diff \u003d calculateSharesForTwoMandatoryResources(clusterRes, lhs, rhs,\n             lhsShares, rhsShares);\n       } else {\n         calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares);\n \n         Arrays.sort(lhsShares);\n         Arrays.sort(rhsShares);\n \n         diff \u003d compareShares(lhsShares, rhsShares);\n       }\n     } catch (ArrayIndexOutOfBoundsException ex) {\n       StringWriter out \u003d new StringWriter(); // No need to close a StringWriter\n       ex.printStackTrace(new PrintWriter(out));\n \n       LOG.error(\"A problem was encountered while calculating resource \"\n           + \"availability that should not occur under normal circumstances. \"\n           + \"Please report this error to the Hadoop community by opening a \"\n           + \"JIRA ticket at http://issues.apache.org/jira and including the \"\n           + \"following information:\\n* Exception encountered: \" + out + \"* \"\n           + \"Cluster resources: \" + Arrays.toString(clusterRes) + \"\\n* \"\n           + \"LHS resource: \" + Arrays.toString(lhs.getResources()) + \"\\n* \"\n           + \"RHS resource: \" + Arrays.toString(rhs.getResources()));\n       LOG.error(\"The resource manager is in an inconsistent state. It is safe \"\n           + \"for the resource manager to be restarted as the error encountered \"\n           + \"should be transitive. If high availability is enabled, failing \"\n           + \"over to a standby resource manager is also safe.\");\n       throw new YarnRuntimeException(\"A problem was encountered while \"\n           + \"calculating resource availability that should not occur under \"\n           + \"normal circumstances. Please see the log for more information.\",\n           ex);\n     }\n \n     return (int) Math.signum(diff);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n      boolean singleType) {\n    if (lhs.equals(rhs)) {\n      return 0;\n    }\n\n    if (isAllInvalidDivisor(clusterResource)) {\n      return this.compare(lhs, rhs);\n    }\n\n    // We have to calculate the shares for all resource types for both\n    // resources and then look for which resource has the biggest\n    // share overall.\n    ResourceInformation[] clusterRes \u003d clusterResource.getResources();\n    int maxLength \u003d ResourceUtils.getNumberOfCountableResourceTypes();\n\n    // If array creation shows up as a time sink, these arrays could be cached\n    // because they\u0027re always the same length.\n    double[] lhsShares \u003d new double[maxLength];\n    double[] rhsShares \u003d new double[maxLength];\n    double diff;\n\n    try {\n      if (singleType) {\n        double[] max \u003d new double[2];\n\n        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares, max);\n\n        diff \u003d max[0] - max[1];\n      } else if (maxLength \u003d\u003d 2) {\n        // Special case to handle the common scenario of only CPU and memory\n        // so that we can optimize for performance\n        diff \u003d calculateSharesForTwoMandatoryResources(clusterRes, lhs, rhs,\n            lhsShares, rhsShares);\n      } else {\n        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares);\n\n        Arrays.sort(lhsShares);\n        Arrays.sort(rhsShares);\n\n        diff \u003d compareShares(lhsShares, rhsShares);\n      }\n    } catch (ArrayIndexOutOfBoundsException ex) {\n      StringWriter out \u003d new StringWriter(); // No need to close a StringWriter\n      ex.printStackTrace(new PrintWriter(out));\n\n      LOG.error(\"A problem was encountered while calculating resource \"\n          + \"availability that should not occur under normal circumstances. \"\n          + \"Please report this error to the Hadoop community by opening a \"\n          + \"JIRA ticket at http://issues.apache.org/jira and including the \"\n          + \"following information:\\n* Exception encountered: \" + out + \"* \"\n          + \"Cluster resources: \" + Arrays.toString(clusterRes) + \"\\n* \"\n          + \"LHS resource: \" + Arrays.toString(lhs.getResources()) + \"\\n* \"\n          + \"RHS resource: \" + Arrays.toString(rhs.getResources()));\n      LOG.error(\"The resource manager is in an inconsistent state. It is safe \"\n          + \"for the resource manager to be restarted as the error encountered \"\n          + \"should be transitive. If high availability is enabled, failing \"\n          + \"over to a standby resource manager is also safe.\");\n      throw new YarnRuntimeException(\"A problem was encountered while \"\n          + \"calculating resource availability that should not occur under \"\n          + \"normal circumstances. Please see the log for more information.\",\n          ex);\n    }\n\n    return (int) Math.signum(diff);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/resource/DominantResourceCalculator.java",
      "extendedDetails": {}
    },
    "0921b706f7f80c40e061d2c0f8c8b2e4910071e5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9037. [CSI] Ignore volume resource in resource calculators based on tags. Contributed by Sunil Govindan.\n",
      "commitDate": "07/01/19 10:30 PM",
      "commitName": "0921b706f7f80c40e061d2c0f8c8b2e4910071e5",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "05/12/18 3:16 PM",
      "commitNameOld": "912b1f9d64a61ef2663d95e2b4f286e6ee8d5ff9",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 33.3,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n       boolean singleType) {\n     if (lhs.equals(rhs)) {\n       return 0;\n     }\n \n     if (isInvalidDivisor(clusterResource)) {\n       return this.compare(lhs, rhs);\n     }\n \n     // We have to calculate the shares for all resource types for both\n     // resources and then look for which resource has the biggest\n     // share overall.\n     ResourceInformation[] clusterRes \u003d clusterResource.getResources();\n-    int maxLength \u003d ResourceUtils.getNumberOfKnownResourceTypes();\n+    int maxLength \u003d ResourceUtils.getNumberOfCountableResourceTypes();\n \n     // If array creation shows up as a time sink, these arrays could be cached\n     // because they\u0027re always the same length.\n     double[] lhsShares \u003d new double[maxLength];\n     double[] rhsShares \u003d new double[maxLength];\n     double diff;\n \n     try {\n       if (singleType) {\n         double[] max \u003d new double[2];\n \n         calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares, max);\n \n         diff \u003d max[0] - max[1];\n       } else if (maxLength \u003d\u003d 2) {\n         // Special case to handle the common scenario of only CPU and memory\n         // so that we can optimize for performance\n         diff \u003d calculateSharesForTwoMandatoryResources(clusterRes, lhs, rhs,\n             lhsShares, rhsShares);\n       } else {\n         calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares);\n \n         Arrays.sort(lhsShares);\n         Arrays.sort(rhsShares);\n \n         diff \u003d compareShares(lhsShares, rhsShares);\n       }\n     } catch (ArrayIndexOutOfBoundsException ex) {\n       StringWriter out \u003d new StringWriter(); // No need to close a StringWriter\n       ex.printStackTrace(new PrintWriter(out));\n \n       LOG.error(\"A problem was encountered while calculating resource \"\n           + \"availability that should not occur under normal circumstances. \"\n           + \"Please report this error to the Hadoop community by opening a \"\n           + \"JIRA ticket at http://issues.apache.org/jira and including the \"\n           + \"following information:\\n* Exception encountered: \" + out + \"* \"\n           + \"Cluster resources: \" + Arrays.toString(clusterRes) + \"\\n* \"\n           + \"LHS resource: \" + Arrays.toString(lhs.getResources()) + \"\\n* \"\n           + \"RHS resource: \" + Arrays.toString(rhs.getResources()));\n       LOG.error(\"The resource manager is in an inconsistent state. It is safe \"\n           + \"for the resource manager to be restarted as the error encountered \"\n           + \"should be transitive. If high availability is enabled, failing \"\n           + \"over to a standby resource manager is also safe.\");\n       throw new YarnRuntimeException(\"A problem was encountered while \"\n           + \"calculating resource availability that should not occur under \"\n           + \"normal circumstances. Please see the log for more information.\",\n           ex);\n     }\n \n     return (int) Math.signum(diff);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n      boolean singleType) {\n    if (lhs.equals(rhs)) {\n      return 0;\n    }\n\n    if (isInvalidDivisor(clusterResource)) {\n      return this.compare(lhs, rhs);\n    }\n\n    // We have to calculate the shares for all resource types for both\n    // resources and then look for which resource has the biggest\n    // share overall.\n    ResourceInformation[] clusterRes \u003d clusterResource.getResources();\n    int maxLength \u003d ResourceUtils.getNumberOfCountableResourceTypes();\n\n    // If array creation shows up as a time sink, these arrays could be cached\n    // because they\u0027re always the same length.\n    double[] lhsShares \u003d new double[maxLength];\n    double[] rhsShares \u003d new double[maxLength];\n    double diff;\n\n    try {\n      if (singleType) {\n        double[] max \u003d new double[2];\n\n        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares, max);\n\n        diff \u003d max[0] - max[1];\n      } else if (maxLength \u003d\u003d 2) {\n        // Special case to handle the common scenario of only CPU and memory\n        // so that we can optimize for performance\n        diff \u003d calculateSharesForTwoMandatoryResources(clusterRes, lhs, rhs,\n            lhsShares, rhsShares);\n      } else {\n        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares);\n\n        Arrays.sort(lhsShares);\n        Arrays.sort(rhsShares);\n\n        diff \u003d compareShares(lhsShares, rhsShares);\n      }\n    } catch (ArrayIndexOutOfBoundsException ex) {\n      StringWriter out \u003d new StringWriter(); // No need to close a StringWriter\n      ex.printStackTrace(new PrintWriter(out));\n\n      LOG.error(\"A problem was encountered while calculating resource \"\n          + \"availability that should not occur under normal circumstances. \"\n          + \"Please report this error to the Hadoop community by opening a \"\n          + \"JIRA ticket at http://issues.apache.org/jira and including the \"\n          + \"following information:\\n* Exception encountered: \" + out + \"* \"\n          + \"Cluster resources: \" + Arrays.toString(clusterRes) + \"\\n* \"\n          + \"LHS resource: \" + Arrays.toString(lhs.getResources()) + \"\\n* \"\n          + \"RHS resource: \" + Arrays.toString(rhs.getResources()));\n      LOG.error(\"The resource manager is in an inconsistent state. It is safe \"\n          + \"for the resource manager to be restarted as the error encountered \"\n          + \"should be transitive. If high availability is enabled, failing \"\n          + \"over to a standby resource manager is also safe.\");\n      throw new YarnRuntimeException(\"A problem was encountered while \"\n          + \"calculating resource availability that should not occur under \"\n          + \"normal circumstances. Please see the log for more information.\",\n          ex);\n    }\n\n    return (int) Math.signum(diff);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/resource/DominantResourceCalculator.java",
      "extendedDetails": {}
    },
    "bf2b687412f9a830ec4834477ccf25dbe76fddcd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7136. Additional Performance Improvement for Resource Profile Feature\n(Contributed by Wangda Tan via Daniel Templeton)\n",
      "commitDate": "12/09/17 9:19 AM",
      "commitName": "bf2b687412f9a830ec4834477ccf25dbe76fddcd",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "39240b61a163b127eec385decd30ffd96e694c28",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n   public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n       boolean singleType) {\n     if (lhs.equals(rhs)) {\n       return 0;\n     }\n \n     if (isInvalidDivisor(clusterResource)) {\n       return this.compare(lhs, rhs);\n     }\n \n     // We have to calculate the shares for all resource types for both\n     // resources and then look for which resource has the biggest\n     // share overall.\n     ResourceInformation[] clusterRes \u003d clusterResource.getResources();\n+    int maxLength \u003d ResourceUtils.getNumberOfKnownResourceTypes();\n+\n     // If array creation shows up as a time sink, these arrays could be cached\n     // because they\u0027re always the same length.\n-    double[] lhsShares \u003d new double[clusterRes.length];\n-    double[] rhsShares \u003d new double[clusterRes.length];\n+    double[] lhsShares \u003d new double[maxLength];\n+    double[] rhsShares \u003d new double[maxLength];\n     double diff;\n \n     try {\n       if (singleType) {\n         double[] max \u003d new double[2];\n \n         calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares, max);\n \n         diff \u003d max[0] - max[1];\n-      } else if (clusterRes.length \u003d\u003d 2) {\n+      } else if (maxLength \u003d\u003d 2) {\n         // Special case to handle the common scenario of only CPU and memory\n         // so that we can optimize for performance\n-        diff \u003d calculateSharesForMandatoryResources(clusterRes, lhs, rhs,\n+        diff \u003d calculateSharesForTwoMandatoryResources(clusterRes, lhs, rhs,\n             lhsShares, rhsShares);\n       } else {\n         calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares);\n \n         Arrays.sort(lhsShares);\n         Arrays.sort(rhsShares);\n \n         diff \u003d compareShares(lhsShares, rhsShares);\n       }\n     } catch (ArrayIndexOutOfBoundsException ex) {\n       StringWriter out \u003d new StringWriter(); // No need to close a StringWriter\n       ex.printStackTrace(new PrintWriter(out));\n \n       LOG.error(\"A problem was encountered while calculating resource \"\n           + \"availability that should not occur under normal circumstances. \"\n           + \"Please report this error to the Hadoop community by opening a \"\n           + \"JIRA ticket at http://issues.apache.org/jira and including the \"\n           + \"following information:\\n* Exception encountered: \" + out + \"* \"\n           + \"Cluster resources: \" + Arrays.toString(clusterRes) + \"\\n* \"\n           + \"LHS resource: \" + Arrays.toString(lhs.getResources()) + \"\\n* \"\n           + \"RHS resource: \" + Arrays.toString(rhs.getResources()));\n       LOG.error(\"The resource manager is in an inconsistent state. It is safe \"\n           + \"for the resource manager to be restarted as the error encountered \"\n           + \"should be transitive. If high availability is enabled, failing \"\n           + \"over to a standby resource manager is also safe.\");\n       throw new YarnRuntimeException(\"A problem was encountered while \"\n           + \"calculating resource availability that should not occur under \"\n           + \"normal circumstances. Please see the log for more information.\",\n           ex);\n     }\n \n     return (int) Math.signum(diff);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n      boolean singleType) {\n    if (lhs.equals(rhs)) {\n      return 0;\n    }\n\n    if (isInvalidDivisor(clusterResource)) {\n      return this.compare(lhs, rhs);\n    }\n\n    // We have to calculate the shares for all resource types for both\n    // resources and then look for which resource has the biggest\n    // share overall.\n    ResourceInformation[] clusterRes \u003d clusterResource.getResources();\n    int maxLength \u003d ResourceUtils.getNumberOfKnownResourceTypes();\n\n    // If array creation shows up as a time sink, these arrays could be cached\n    // because they\u0027re always the same length.\n    double[] lhsShares \u003d new double[maxLength];\n    double[] rhsShares \u003d new double[maxLength];\n    double diff;\n\n    try {\n      if (singleType) {\n        double[] max \u003d new double[2];\n\n        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares, max);\n\n        diff \u003d max[0] - max[1];\n      } else if (maxLength \u003d\u003d 2) {\n        // Special case to handle the common scenario of only CPU and memory\n        // so that we can optimize for performance\n        diff \u003d calculateSharesForTwoMandatoryResources(clusterRes, lhs, rhs,\n            lhsShares, rhsShares);\n      } else {\n        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares);\n\n        Arrays.sort(lhsShares);\n        Arrays.sort(rhsShares);\n\n        diff \u003d compareShares(lhsShares, rhsShares);\n      }\n    } catch (ArrayIndexOutOfBoundsException ex) {\n      StringWriter out \u003d new StringWriter(); // No need to close a StringWriter\n      ex.printStackTrace(new PrintWriter(out));\n\n      LOG.error(\"A problem was encountered while calculating resource \"\n          + \"availability that should not occur under normal circumstances. \"\n          + \"Please report this error to the Hadoop community by opening a \"\n          + \"JIRA ticket at http://issues.apache.org/jira and including the \"\n          + \"following information:\\n* Exception encountered: \" + out + \"* \"\n          + \"Cluster resources: \" + Arrays.toString(clusterRes) + \"\\n* \"\n          + \"LHS resource: \" + Arrays.toString(lhs.getResources()) + \"\\n* \"\n          + \"RHS resource: \" + Arrays.toString(rhs.getResources()));\n      LOG.error(\"The resource manager is in an inconsistent state. It is safe \"\n          + \"for the resource manager to be restarted as the error encountered \"\n          + \"should be transitive. If high availability is enabled, failing \"\n          + \"over to a standby resource manager is also safe.\");\n      throw new YarnRuntimeException(\"A problem was encountered while \"\n          + \"calculating resource availability that should not occur under \"\n          + \"normal circumstances. Please see the log for more information.\",\n          ex);\n    }\n\n    return (int) Math.signum(diff);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/resource/DominantResourceCalculator.java",
      "extendedDetails": {}
    },
    "b1fe3a222e7673fd84a878622969f958022061e9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7042. Clean up unit tests after YARN-6610. (Daniel Templeton via wangda)\n\nChange-Id: I8e40f704b6fcdd5b14faa9548a27986501044fa1\n",
      "commitDate": "12/09/17 9:19 AM",
      "commitName": "b1fe3a222e7673fd84a878622969f958022061e9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "a0030c8c6f5489d8285632a651394b2b2320255c",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n       boolean singleType) {\n     if (lhs.equals(rhs)) {\n       return 0;\n     }\n \n     if (isInvalidDivisor(clusterResource)) {\n       return this.compare(lhs, rhs);\n     }\n \n     // We have to calculate the shares for all resource types for both\n     // resources and then look for which resource has the biggest\n     // share overall.\n     ResourceInformation[] clusterRes \u003d clusterResource.getResources();\n     // If array creation shows up as a time sink, these arrays could be cached\n     // because they\u0027re always the same length.\n     double[] lhsShares \u003d new double[clusterRes.length];\n     double[] rhsShares \u003d new double[clusterRes.length];\n     double diff;\n \n     try {\n       if (singleType) {\n         double[] max \u003d new double[2];\n \n         calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares, max);\n \n         diff \u003d max[0] - max[1];\n       } else if (clusterRes.length \u003d\u003d 2) {\n         // Special case to handle the common scenario of only CPU and memory\n-        // so the we can optimize for performance\n+        // so that we can optimize for performance\n         diff \u003d calculateSharesForMandatoryResources(clusterRes, lhs, rhs,\n             lhsShares, rhsShares);\n       } else {\n         calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares);\n \n         Arrays.sort(lhsShares);\n         Arrays.sort(rhsShares);\n \n         diff \u003d compareShares(lhsShares, rhsShares);\n       }\n     } catch (ArrayIndexOutOfBoundsException ex) {\n       StringWriter out \u003d new StringWriter(); // No need to close a StringWriter\n       ex.printStackTrace(new PrintWriter(out));\n \n       LOG.error(\"A problem was encountered while calculating resource \"\n           + \"availability that should not occur under normal circumstances. \"\n           + \"Please report this error to the Hadoop community by opening a \"\n           + \"JIRA ticket at http://issues.apache.org/jira and including the \"\n           + \"following information:\\n* Exception encountered: \" + out + \"* \"\n           + \"Cluster resources: \" + Arrays.toString(clusterRes) + \"\\n* \"\n           + \"LHS resource: \" + Arrays.toString(lhs.getResources()) + \"\\n* \"\n           + \"RHS resource: \" + Arrays.toString(rhs.getResources()));\n       LOG.error(\"The resource manager is in an inconsistent state. It is safe \"\n           + \"for the resource manager to be restarted as the error encountered \"\n           + \"should be transitive. If high availability is enabled, failing \"\n           + \"over to a standby resource manager is also safe.\");\n       throw new YarnRuntimeException(\"A problem was encountered while \"\n           + \"calculating resource availability that should not occur under \"\n           + \"normal circumstances. Please see the log for more information.\",\n           ex);\n     }\n \n     return (int) Math.signum(diff);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n      boolean singleType) {\n    if (lhs.equals(rhs)) {\n      return 0;\n    }\n\n    if (isInvalidDivisor(clusterResource)) {\n      return this.compare(lhs, rhs);\n    }\n\n    // We have to calculate the shares for all resource types for both\n    // resources and then look for which resource has the biggest\n    // share overall.\n    ResourceInformation[] clusterRes \u003d clusterResource.getResources();\n    // If array creation shows up as a time sink, these arrays could be cached\n    // because they\u0027re always the same length.\n    double[] lhsShares \u003d new double[clusterRes.length];\n    double[] rhsShares \u003d new double[clusterRes.length];\n    double diff;\n\n    try {\n      if (singleType) {\n        double[] max \u003d new double[2];\n\n        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares, max);\n\n        diff \u003d max[0] - max[1];\n      } else if (clusterRes.length \u003d\u003d 2) {\n        // Special case to handle the common scenario of only CPU and memory\n        // so that we can optimize for performance\n        diff \u003d calculateSharesForMandatoryResources(clusterRes, lhs, rhs,\n            lhsShares, rhsShares);\n      } else {\n        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares);\n\n        Arrays.sort(lhsShares);\n        Arrays.sort(rhsShares);\n\n        diff \u003d compareShares(lhsShares, rhsShares);\n      }\n    } catch (ArrayIndexOutOfBoundsException ex) {\n      StringWriter out \u003d new StringWriter(); // No need to close a StringWriter\n      ex.printStackTrace(new PrintWriter(out));\n\n      LOG.error(\"A problem was encountered while calculating resource \"\n          + \"availability that should not occur under normal circumstances. \"\n          + \"Please report this error to the Hadoop community by opening a \"\n          + \"JIRA ticket at http://issues.apache.org/jira and including the \"\n          + \"following information:\\n* Exception encountered: \" + out + \"* \"\n          + \"Cluster resources: \" + Arrays.toString(clusterRes) + \"\\n* \"\n          + \"LHS resource: \" + Arrays.toString(lhs.getResources()) + \"\\n* \"\n          + \"RHS resource: \" + Arrays.toString(rhs.getResources()));\n      LOG.error(\"The resource manager is in an inconsistent state. It is safe \"\n          + \"for the resource manager to be restarted as the error encountered \"\n          + \"should be transitive. If high availability is enabled, failing \"\n          + \"over to a standby resource manager is also safe.\");\n      throw new YarnRuntimeException(\"A problem was encountered while \"\n          + \"calculating resource availability that should not occur under \"\n          + \"normal circumstances. Please see the log for more information.\",\n          ex);\n    }\n\n    return (int) Math.signum(diff);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/resource/DominantResourceCalculator.java",
      "extendedDetails": {}
    },
    "a0030c8c6f5489d8285632a651394b2b2320255c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6610. [YARN-3926] DominantResourceCalculator#getResourceAsValue dominant param is updated to handle multiple resources. Contributed by Daniel Templeton.\n",
      "commitDate": "12/09/17 9:19 AM",
      "commitName": "a0030c8c6f5489d8285632a651394b2b2320255c",
      "commitAuthor": "Sunil G",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "2b51b262aba0191b80dc93799574c0b959cb4f4e",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,64 @@\n   public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n       boolean singleType) {\n-    \n     if (lhs.equals(rhs)) {\n       return 0;\n     }\n \n     if (isInvalidDivisor(clusterResource)) {\n       return this.compare(lhs, rhs);\n     }\n \n-    float l \u003d getResourceAsValue(clusterResource, lhs, true);\n-    float r \u003d getResourceAsValue(clusterResource, rhs, true);\n+    // We have to calculate the shares for all resource types for both\n+    // resources and then look for which resource has the biggest\n+    // share overall.\n+    ResourceInformation[] clusterRes \u003d clusterResource.getResources();\n+    // If array creation shows up as a time sink, these arrays could be cached\n+    // because they\u0027re always the same length.\n+    double[] lhsShares \u003d new double[clusterRes.length];\n+    double[] rhsShares \u003d new double[clusterRes.length];\n+    double diff;\n \n-    if (l \u003c r) {\n-      return -1;\n-    } else if (l \u003e r) {\n-      return 1;\n-    } else if (!singleType) {\n-      l \u003d getResourceAsValue(clusterResource, lhs, false);\n-      r \u003d getResourceAsValue(clusterResource, rhs, false);\n+    try {\n+      if (singleType) {\n+        double[] max \u003d new double[2];\n \n-      if (l \u003c r) {\n-        return -1;\n-      } else if (l \u003e r) {\n-        return 1;\n+        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares, max);\n+\n+        diff \u003d max[0] - max[1];\n+      } else if (clusterRes.length \u003d\u003d 2) {\n+        // Special case to handle the common scenario of only CPU and memory\n+        // so the we can optimize for performance\n+        diff \u003d calculateSharesForMandatoryResources(clusterRes, lhs, rhs,\n+            lhsShares, rhsShares);\n+      } else {\n+        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares);\n+\n+        Arrays.sort(lhsShares);\n+        Arrays.sort(rhsShares);\n+\n+        diff \u003d compareShares(lhsShares, rhsShares);\n       }\n+    } catch (ArrayIndexOutOfBoundsException ex) {\n+      StringWriter out \u003d new StringWriter(); // No need to close a StringWriter\n+      ex.printStackTrace(new PrintWriter(out));\n+\n+      LOG.error(\"A problem was encountered while calculating resource \"\n+          + \"availability that should not occur under normal circumstances. \"\n+          + \"Please report this error to the Hadoop community by opening a \"\n+          + \"JIRA ticket at http://issues.apache.org/jira and including the \"\n+          + \"following information:\\n* Exception encountered: \" + out + \"* \"\n+          + \"Cluster resources: \" + Arrays.toString(clusterRes) + \"\\n* \"\n+          + \"LHS resource: \" + Arrays.toString(lhs.getResources()) + \"\\n* \"\n+          + \"RHS resource: \" + Arrays.toString(rhs.getResources()));\n+      LOG.error(\"The resource manager is in an inconsistent state. It is safe \"\n+          + \"for the resource manager to be restarted as the error encountered \"\n+          + \"should be transitive. If high availability is enabled, failing \"\n+          + \"over to a standby resource manager is also safe.\");\n+      throw new YarnRuntimeException(\"A problem was encountered while \"\n+          + \"calculating resource availability that should not occur under \"\n+          + \"normal circumstances. Please see the log for more information.\",\n+          ex);\n     }\n \n-    return 0;\n+    return (int) Math.signum(diff);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n      boolean singleType) {\n    if (lhs.equals(rhs)) {\n      return 0;\n    }\n\n    if (isInvalidDivisor(clusterResource)) {\n      return this.compare(lhs, rhs);\n    }\n\n    // We have to calculate the shares for all resource types for both\n    // resources and then look for which resource has the biggest\n    // share overall.\n    ResourceInformation[] clusterRes \u003d clusterResource.getResources();\n    // If array creation shows up as a time sink, these arrays could be cached\n    // because they\u0027re always the same length.\n    double[] lhsShares \u003d new double[clusterRes.length];\n    double[] rhsShares \u003d new double[clusterRes.length];\n    double diff;\n\n    try {\n      if (singleType) {\n        double[] max \u003d new double[2];\n\n        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares, max);\n\n        diff \u003d max[0] - max[1];\n      } else if (clusterRes.length \u003d\u003d 2) {\n        // Special case to handle the common scenario of only CPU and memory\n        // so the we can optimize for performance\n        diff \u003d calculateSharesForMandatoryResources(clusterRes, lhs, rhs,\n            lhsShares, rhsShares);\n      } else {\n        calculateShares(clusterRes, lhs, rhs, lhsShares, rhsShares);\n\n        Arrays.sort(lhsShares);\n        Arrays.sort(rhsShares);\n\n        diff \u003d compareShares(lhsShares, rhsShares);\n      }\n    } catch (ArrayIndexOutOfBoundsException ex) {\n      StringWriter out \u003d new StringWriter(); // No need to close a StringWriter\n      ex.printStackTrace(new PrintWriter(out));\n\n      LOG.error(\"A problem was encountered while calculating resource \"\n          + \"availability that should not occur under normal circumstances. \"\n          + \"Please report this error to the Hadoop community by opening a \"\n          + \"JIRA ticket at http://issues.apache.org/jira and including the \"\n          + \"following information:\\n* Exception encountered: \" + out + \"* \"\n          + \"Cluster resources: \" + Arrays.toString(clusterRes) + \"\\n* \"\n          + \"LHS resource: \" + Arrays.toString(lhs.getResources()) + \"\\n* \"\n          + \"RHS resource: \" + Arrays.toString(rhs.getResources()));\n      LOG.error(\"The resource manager is in an inconsistent state. It is safe \"\n          + \"for the resource manager to be restarted as the error encountered \"\n          + \"should be transitive. If high availability is enabled, failing \"\n          + \"over to a standby resource manager is also safe.\");\n      throw new YarnRuntimeException(\"A problem was encountered while \"\n          + \"calculating resource availability that should not occur under \"\n          + \"normal circumstances. Please see the log for more information.\",\n          ex);\n    }\n\n    return (int) Math.signum(diff);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/resource/DominantResourceCalculator.java",
      "extendedDetails": {}
    },
    "32c91223f1bd06561ea4ce2d1944e8d9a847f18c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4172. Extend DominantResourceCalculator to account for all resources. (Varun Vasudev via wangda)\n",
      "commitDate": "12/09/17 9:19 AM",
      "commitName": "32c91223f1bd06561ea4ce2d1944e8d9a847f18c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/07/17 4:56 AM",
      "commitNameOld": "626d730bfc4c1f6ea54e8a246a0a676cdb74937f",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 65.18,
      "commitsBetweenForRepo": 506,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,31 @@\n   public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n       boolean singleType) {\n     \n     if (lhs.equals(rhs)) {\n       return 0;\n     }\n-    \n+\n     if (isInvalidDivisor(clusterResource)) {\n-      if ((lhs.getMemorySize() \u003c rhs.getMemorySize() \u0026\u0026\n-          lhs.getVirtualCores() \u003e rhs.getVirtualCores()) ||\n-          (lhs.getMemorySize() \u003e rhs.getMemorySize() \u0026\u0026\n-          lhs.getVirtualCores() \u003c rhs.getVirtualCores())) {\n-        return 0;\n-      } else if (lhs.getMemorySize() \u003e rhs.getMemorySize()\n-          || lhs.getVirtualCores() \u003e rhs.getVirtualCores()) {\n-        return 1;\n-      } else if (lhs.getMemorySize() \u003c rhs.getMemorySize()\n-          || lhs.getVirtualCores() \u003c rhs.getVirtualCores()) {\n-        return -1;\n-      }\n+      return this.compare(lhs, rhs);\n     }\n \n     float l \u003d getResourceAsValue(clusterResource, lhs, true);\n     float r \u003d getResourceAsValue(clusterResource, rhs, true);\n-    \n+\n     if (l \u003c r) {\n       return -1;\n     } else if (l \u003e r) {\n       return 1;\n     } else if (!singleType) {\n       l \u003d getResourceAsValue(clusterResource, lhs, false);\n       r \u003d getResourceAsValue(clusterResource, rhs, false);\n+\n       if (l \u003c r) {\n         return -1;\n       } else if (l \u003e r) {\n         return 1;\n       }\n     }\n-    \n+\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n      boolean singleType) {\n    \n    if (lhs.equals(rhs)) {\n      return 0;\n    }\n\n    if (isInvalidDivisor(clusterResource)) {\n      return this.compare(lhs, rhs);\n    }\n\n    float l \u003d getResourceAsValue(clusterResource, lhs, true);\n    float r \u003d getResourceAsValue(clusterResource, rhs, true);\n\n    if (l \u003c r) {\n      return -1;\n    } else if (l \u003e r) {\n      return 1;\n    } else if (!singleType) {\n      l \u003d getResourceAsValue(clusterResource, lhs, false);\n      r \u003d getResourceAsValue(clusterResource, rhs, false);\n\n      if (l \u003c r) {\n        return -1;\n      } else if (l \u003e r) {\n        return 1;\n      }\n    }\n\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/resource/DominantResourceCalculator.java",
      "extendedDetails": {}
    },
    "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6210. FairScheduler: Node reservations can interfere with preemption. (kasha)\n",
      "commitDate": "22/02/17 3:46 PM",
      "commitName": "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6210. FairScheduler: Node reservations can interfere with preemption. (kasha)\n",
          "commitDate": "22/02/17 3:46 PM",
          "commitName": "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "29/11/16 9:40 AM",
          "commitNameOld": "25f9872be63423ada6a18481eaad2888e731fdac",
          "commitAuthorOld": "Daniel Templeton",
          "daysBetweenCommits": 85.25,
          "commitsBetweenForRepo": 426,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,41 @@\n-  public int compare(Resource clusterResource, Resource lhs, Resource rhs) {\n+  public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n+      boolean singleType) {\n     \n     if (lhs.equals(rhs)) {\n       return 0;\n     }\n     \n     if (isInvalidDivisor(clusterResource)) {\n-      if ((lhs.getMemorySize() \u003c rhs.getMemorySize() \u0026\u0026 lhs.getVirtualCores() \u003e rhs\n-          .getVirtualCores())\n-          || (lhs.getMemorySize() \u003e rhs.getMemorySize() \u0026\u0026 lhs.getVirtualCores() \u003c rhs\n-              .getVirtualCores())) {\n+      if ((lhs.getMemorySize() \u003c rhs.getMemorySize() \u0026\u0026\n+          lhs.getVirtualCores() \u003e rhs.getVirtualCores()) ||\n+          (lhs.getMemorySize() \u003e rhs.getMemorySize() \u0026\u0026\n+          lhs.getVirtualCores() \u003c rhs.getVirtualCores())) {\n         return 0;\n       } else if (lhs.getMemorySize() \u003e rhs.getMemorySize()\n           || lhs.getVirtualCores() \u003e rhs.getVirtualCores()) {\n         return 1;\n       } else if (lhs.getMemorySize() \u003c rhs.getMemorySize()\n           || lhs.getVirtualCores() \u003c rhs.getVirtualCores()) {\n         return -1;\n       }\n     }\n \n     float l \u003d getResourceAsValue(clusterResource, lhs, true);\n     float r \u003d getResourceAsValue(clusterResource, rhs, true);\n     \n     if (l \u003c r) {\n       return -1;\n     } else if (l \u003e r) {\n       return 1;\n-    } else {\n+    } else if (!singleType) {\n       l \u003d getResourceAsValue(clusterResource, lhs, false);\n       r \u003d getResourceAsValue(clusterResource, rhs, false);\n       if (l \u003c r) {\n         return -1;\n       } else if (l \u003e r) {\n         return 1;\n       }\n     }\n     \n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n      boolean singleType) {\n    \n    if (lhs.equals(rhs)) {\n      return 0;\n    }\n    \n    if (isInvalidDivisor(clusterResource)) {\n      if ((lhs.getMemorySize() \u003c rhs.getMemorySize() \u0026\u0026\n          lhs.getVirtualCores() \u003e rhs.getVirtualCores()) ||\n          (lhs.getMemorySize() \u003e rhs.getMemorySize() \u0026\u0026\n          lhs.getVirtualCores() \u003c rhs.getVirtualCores())) {\n        return 0;\n      } else if (lhs.getMemorySize() \u003e rhs.getMemorySize()\n          || lhs.getVirtualCores() \u003e rhs.getVirtualCores()) {\n        return 1;\n      } else if (lhs.getMemorySize() \u003c rhs.getMemorySize()\n          || lhs.getVirtualCores() \u003c rhs.getVirtualCores()) {\n        return -1;\n      }\n    }\n\n    float l \u003d getResourceAsValue(clusterResource, lhs, true);\n    float r \u003d getResourceAsValue(clusterResource, rhs, true);\n    \n    if (l \u003c r) {\n      return -1;\n    } else if (l \u003e r) {\n      return 1;\n    } else if (!singleType) {\n      l \u003d getResourceAsValue(clusterResource, lhs, false);\n      r \u003d getResourceAsValue(clusterResource, rhs, false);\n      if (l \u003c r) {\n        return -1;\n      } else if (l \u003e r) {\n        return 1;\n      }\n    }\n    \n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/resource/DominantResourceCalculator.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, lhs-Resource, rhs-Resource]",
            "newValue": "[clusterResource-Resource, lhs-Resource, rhs-Resource, singleType-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6210. FairScheduler: Node reservations can interfere with preemption. (kasha)\n",
          "commitDate": "22/02/17 3:46 PM",
          "commitName": "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "29/11/16 9:40 AM",
          "commitNameOld": "25f9872be63423ada6a18481eaad2888e731fdac",
          "commitAuthorOld": "Daniel Templeton",
          "daysBetweenCommits": 85.25,
          "commitsBetweenForRepo": 426,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,41 @@\n-  public int compare(Resource clusterResource, Resource lhs, Resource rhs) {\n+  public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n+      boolean singleType) {\n     \n     if (lhs.equals(rhs)) {\n       return 0;\n     }\n     \n     if (isInvalidDivisor(clusterResource)) {\n-      if ((lhs.getMemorySize() \u003c rhs.getMemorySize() \u0026\u0026 lhs.getVirtualCores() \u003e rhs\n-          .getVirtualCores())\n-          || (lhs.getMemorySize() \u003e rhs.getMemorySize() \u0026\u0026 lhs.getVirtualCores() \u003c rhs\n-              .getVirtualCores())) {\n+      if ((lhs.getMemorySize() \u003c rhs.getMemorySize() \u0026\u0026\n+          lhs.getVirtualCores() \u003e rhs.getVirtualCores()) ||\n+          (lhs.getMemorySize() \u003e rhs.getMemorySize() \u0026\u0026\n+          lhs.getVirtualCores() \u003c rhs.getVirtualCores())) {\n         return 0;\n       } else if (lhs.getMemorySize() \u003e rhs.getMemorySize()\n           || lhs.getVirtualCores() \u003e rhs.getVirtualCores()) {\n         return 1;\n       } else if (lhs.getMemorySize() \u003c rhs.getMemorySize()\n           || lhs.getVirtualCores() \u003c rhs.getVirtualCores()) {\n         return -1;\n       }\n     }\n \n     float l \u003d getResourceAsValue(clusterResource, lhs, true);\n     float r \u003d getResourceAsValue(clusterResource, rhs, true);\n     \n     if (l \u003c r) {\n       return -1;\n     } else if (l \u003e r) {\n       return 1;\n-    } else {\n+    } else if (!singleType) {\n       l \u003d getResourceAsValue(clusterResource, lhs, false);\n       r \u003d getResourceAsValue(clusterResource, rhs, false);\n       if (l \u003c r) {\n         return -1;\n       } else if (l \u003e r) {\n         return 1;\n       }\n     }\n     \n     return 0;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public int compare(Resource clusterResource, Resource lhs, Resource rhs,\n      boolean singleType) {\n    \n    if (lhs.equals(rhs)) {\n      return 0;\n    }\n    \n    if (isInvalidDivisor(clusterResource)) {\n      if ((lhs.getMemorySize() \u003c rhs.getMemorySize() \u0026\u0026\n          lhs.getVirtualCores() \u003e rhs.getVirtualCores()) ||\n          (lhs.getMemorySize() \u003e rhs.getMemorySize() \u0026\u0026\n          lhs.getVirtualCores() \u003c rhs.getVirtualCores())) {\n        return 0;\n      } else if (lhs.getMemorySize() \u003e rhs.getMemorySize()\n          || lhs.getVirtualCores() \u003e rhs.getVirtualCores()) {\n        return 1;\n      } else if (lhs.getMemorySize() \u003c rhs.getMemorySize()\n          || lhs.getVirtualCores() \u003c rhs.getVirtualCores()) {\n        return -1;\n      }\n    }\n\n    float l \u003d getResourceAsValue(clusterResource, lhs, true);\n    float r \u003d getResourceAsValue(clusterResource, rhs, true);\n    \n    if (l \u003c r) {\n      return -1;\n    } else if (l \u003e r) {\n      return 1;\n    } else if (!singleType) {\n      l \u003d getResourceAsValue(clusterResource, lhs, false);\n      r \u003d getResourceAsValue(clusterResource, rhs, false);\n      if (l \u003c r) {\n        return -1;\n      } else if (l \u003e r) {\n        return 1;\n      }\n    }\n    \n    return 0;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/resource/DominantResourceCalculator.java",
          "extendedDetails": {}
        }
      ]
    },
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4844. Add getMemorySize/getVirtualCoresSize to o.a.h.y.api.records.Resource. Contributed by Wangda Tan.\n",
      "commitDate": "29/05/16 8:54 AM",
      "commitName": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "23/09/15 1:29 PM",
      "commitNameOld": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 248.81,
      "commitsBetweenForRepo": 1666,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   public int compare(Resource clusterResource, Resource lhs, Resource rhs) {\n     \n     if (lhs.equals(rhs)) {\n       return 0;\n     }\n     \n     if (isInvalidDivisor(clusterResource)) {\n-      if ((lhs.getMemory() \u003c rhs.getMemory() \u0026\u0026 lhs.getVirtualCores() \u003e rhs\n+      if ((lhs.getMemorySize() \u003c rhs.getMemorySize() \u0026\u0026 lhs.getVirtualCores() \u003e rhs\n           .getVirtualCores())\n-          || (lhs.getMemory() \u003e rhs.getMemory() \u0026\u0026 lhs.getVirtualCores() \u003c rhs\n+          || (lhs.getMemorySize() \u003e rhs.getMemorySize() \u0026\u0026 lhs.getVirtualCores() \u003c rhs\n               .getVirtualCores())) {\n         return 0;\n-      } else if (lhs.getMemory() \u003e rhs.getMemory()\n+      } else if (lhs.getMemorySize() \u003e rhs.getMemorySize()\n           || lhs.getVirtualCores() \u003e rhs.getVirtualCores()) {\n         return 1;\n-      } else if (lhs.getMemory() \u003c rhs.getMemory()\n+      } else if (lhs.getMemorySize() \u003c rhs.getMemorySize()\n           || lhs.getVirtualCores() \u003c rhs.getVirtualCores()) {\n         return -1;\n       }\n     }\n \n     float l \u003d getResourceAsValue(clusterResource, lhs, true);\n     float r \u003d getResourceAsValue(clusterResource, rhs, true);\n     \n     if (l \u003c r) {\n       return -1;\n     } else if (l \u003e r) {\n       return 1;\n     } else {\n       l \u003d getResourceAsValue(clusterResource, lhs, false);\n       r \u003d getResourceAsValue(clusterResource, rhs, false);\n       if (l \u003c r) {\n         return -1;\n       } else if (l \u003e r) {\n         return 1;\n       }\n     }\n     \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int compare(Resource clusterResource, Resource lhs, Resource rhs) {\n    \n    if (lhs.equals(rhs)) {\n      return 0;\n    }\n    \n    if (isInvalidDivisor(clusterResource)) {\n      if ((lhs.getMemorySize() \u003c rhs.getMemorySize() \u0026\u0026 lhs.getVirtualCores() \u003e rhs\n          .getVirtualCores())\n          || (lhs.getMemorySize() \u003e rhs.getMemorySize() \u0026\u0026 lhs.getVirtualCores() \u003c rhs\n              .getVirtualCores())) {\n        return 0;\n      } else if (lhs.getMemorySize() \u003e rhs.getMemorySize()\n          || lhs.getVirtualCores() \u003e rhs.getVirtualCores()) {\n        return 1;\n      } else if (lhs.getMemorySize() \u003c rhs.getMemorySize()\n          || lhs.getVirtualCores() \u003c rhs.getVirtualCores()) {\n        return -1;\n      }\n    }\n\n    float l \u003d getResourceAsValue(clusterResource, lhs, true);\n    float r \u003d getResourceAsValue(clusterResource, rhs, true);\n    \n    if (l \u003c r) {\n      return -1;\n    } else if (l \u003e r) {\n      return 1;\n    } else {\n      l \u003d getResourceAsValue(clusterResource, lhs, false);\n      r \u003d getResourceAsValue(clusterResource, rhs, false);\n      if (l \u003c r) {\n        return -1;\n      } else if (l \u003e r) {\n        return 1;\n      }\n    }\n    \n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/resource/DominantResourceCalculator.java",
      "extendedDetails": {}
    },
    "ebd797c48fe236b404cf3a125ac9d1f7714e291e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3733. Fix DominantRC#compare() does not work as expected if cluster resource is empty. (Rohith Sharmaks via wangda)\n",
      "commitDate": "04/06/15 10:22 AM",
      "commitName": "ebd797c48fe236b404cf3a125ac9d1f7714e291e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/08/14 1:00 PM",
      "commitNameOld": "8437df8ba943e348b6a5d6370b4e0a74ff350a90",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 300.89,
      "commitsBetweenForRepo": 2666,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,40 @@\n   public int compare(Resource clusterResource, Resource lhs, Resource rhs) {\n     \n     if (lhs.equals(rhs)) {\n       return 0;\n     }\n     \n+    if (isInvalidDivisor(clusterResource)) {\n+      if ((lhs.getMemory() \u003c rhs.getMemory() \u0026\u0026 lhs.getVirtualCores() \u003e rhs\n+          .getVirtualCores())\n+          || (lhs.getMemory() \u003e rhs.getMemory() \u0026\u0026 lhs.getVirtualCores() \u003c rhs\n+              .getVirtualCores())) {\n+        return 0;\n+      } else if (lhs.getMemory() \u003e rhs.getMemory()\n+          || lhs.getVirtualCores() \u003e rhs.getVirtualCores()) {\n+        return 1;\n+      } else if (lhs.getMemory() \u003c rhs.getMemory()\n+          || lhs.getVirtualCores() \u003c rhs.getVirtualCores()) {\n+        return -1;\n+      }\n+    }\n+\n     float l \u003d getResourceAsValue(clusterResource, lhs, true);\n     float r \u003d getResourceAsValue(clusterResource, rhs, true);\n     \n     if (l \u003c r) {\n       return -1;\n     } else if (l \u003e r) {\n       return 1;\n     } else {\n       l \u003d getResourceAsValue(clusterResource, lhs, false);\n       r \u003d getResourceAsValue(clusterResource, rhs, false);\n       if (l \u003c r) {\n         return -1;\n       } else if (l \u003e r) {\n         return 1;\n       }\n     }\n     \n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int compare(Resource clusterResource, Resource lhs, Resource rhs) {\n    \n    if (lhs.equals(rhs)) {\n      return 0;\n    }\n    \n    if (isInvalidDivisor(clusterResource)) {\n      if ((lhs.getMemory() \u003c rhs.getMemory() \u0026\u0026 lhs.getVirtualCores() \u003e rhs\n          .getVirtualCores())\n          || (lhs.getMemory() \u003e rhs.getMemory() \u0026\u0026 lhs.getVirtualCores() \u003c rhs\n              .getVirtualCores())) {\n        return 0;\n      } else if (lhs.getMemory() \u003e rhs.getMemory()\n          || lhs.getVirtualCores() \u003e rhs.getVirtualCores()) {\n        return 1;\n      } else if (lhs.getMemory() \u003c rhs.getMemory()\n          || lhs.getVirtualCores() \u003c rhs.getVirtualCores()) {\n        return -1;\n      }\n    }\n\n    float l \u003d getResourceAsValue(clusterResource, lhs, true);\n    float r \u003d getResourceAsValue(clusterResource, rhs, true);\n    \n    if (l \u003c r) {\n      return -1;\n    } else if (l \u003e r) {\n      return 1;\n    } else {\n      l \u003d getResourceAsValue(clusterResource, lhs, false);\n      r \u003d getResourceAsValue(clusterResource, rhs, false);\n      if (l \u003c r) {\n        return -1;\n      } else if (l \u003e r) {\n        return 1;\n      }\n    }\n    \n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/resource/DominantResourceCalculator.java",
      "extendedDetails": {}
    },
    "37d7935a9d7b86635c9c1ffc03f88b49857f88a0": {
      "type": "Yintroduced",
      "commitMessage": "YARN-827. Need to make Resource arithmetic methods accessible^CJian He via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1495533 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/06/13 11:28 AM",
      "commitName": "37d7935a9d7b86635c9c1ffc03f88b49857f88a0",
      "commitAuthor": "Bikas Saha",
      "diff": "@@ -0,0 +1,25 @@\n+  public int compare(Resource clusterResource, Resource lhs, Resource rhs) {\n+    \n+    if (lhs.equals(rhs)) {\n+      return 0;\n+    }\n+    \n+    float l \u003d getResourceAsValue(clusterResource, lhs, true);\n+    float r \u003d getResourceAsValue(clusterResource, rhs, true);\n+    \n+    if (l \u003c r) {\n+      return -1;\n+    } else if (l \u003e r) {\n+      return 1;\n+    } else {\n+      l \u003d getResourceAsValue(clusterResource, lhs, false);\n+      r \u003d getResourceAsValue(clusterResource, rhs, false);\n+      if (l \u003c r) {\n+        return -1;\n+      } else if (l \u003e r) {\n+        return 1;\n+      }\n+    }\n+    \n+    return 0;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int compare(Resource clusterResource, Resource lhs, Resource rhs) {\n    \n    if (lhs.equals(rhs)) {\n      return 0;\n    }\n    \n    float l \u003d getResourceAsValue(clusterResource, lhs, true);\n    float r \u003d getResourceAsValue(clusterResource, rhs, true);\n    \n    if (l \u003c r) {\n      return -1;\n    } else if (l \u003e r) {\n      return 1;\n    } else {\n      l \u003d getResourceAsValue(clusterResource, lhs, false);\n      r \u003d getResourceAsValue(clusterResource, rhs, false);\n      if (l \u003c r) {\n        return -1;\n      } else if (l \u003e r) {\n        return 1;\n      }\n    }\n    \n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/resource/DominantResourceCalculator.java"
    }
  }
}