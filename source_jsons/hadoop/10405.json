{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataXceiver.java",
  "functionName": "copyBlock",
  "functionId": "copyBlock___block-ExtendedBlock(modifiers-final)__blockToken-Token__BlockTokenIdentifier__(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
  "functionStartLine": 1076,
  "functionEndLine": 1149,
  "numCommitsSeen": 126,
  "timeTaken": 9740,
  "changeHistory": [
    "915cbc91c0a12cc7b4d3ef4ea951941defbbcb33",
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
    "e24a923db50879f7dbe5d2afac0e6757089fb07d",
    "aea31eee78a287f251447686ba3f5bbcfe9c60a3",
    "38c4c14472996562eb3d610649246770c2888c6b",
    "4da8490b512a33a255ed27309860859388d7c168",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "36e4cd3be6f7fec8db82d3d1bcb258af470ece2e",
    "02e7dec79d2d4f2b801435343219d8fb53ec931f",
    "085b1e293ff53f7a86aa21406cfd4bfa0f3bf33b",
    "2d4f3e567e4bb8068c028de12df118a4f3fa6343",
    "86cad007d7d6366b293bb9a073814889081c8662",
    "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24",
    "3052ad1f0069af5caee621374b29d17d7f12ab51",
    "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7",
    "837e17b2eac1471d93e2eff395272063b265fee7",
    "239b2742d0e80d13c970fd062af4930e672fe903",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
    "9b4a7900c7dfc0590316eedaa97144f938885651",
    "905a127850d5e0cba85c2e075f989fa0f5cf129a",
    "1c940637b14eee777a65d153d0d712a1aea3866c",
    "c46876982ed90d0819a94b518f6135b82334d10d",
    "e90a5b40430cc1fbce075d34b31e3cc05fd9831f",
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "ef223e8e8e1e18733fc18cd84e34dd0bb0f9a710",
    "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
    "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "915cbc91c0a12cc7b4d3ef4ea951941defbbcb33": "Ybodychange",
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": "Ybodychange",
    "e24a923db50879f7dbe5d2afac0e6757089fb07d": "Ybodychange",
    "aea31eee78a287f251447686ba3f5bbcfe9c60a3": "Ybodychange",
    "38c4c14472996562eb3d610649246770c2888c6b": "Ybodychange",
    "4da8490b512a33a255ed27309860859388d7c168": "Ybodychange",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "36e4cd3be6f7fec8db82d3d1bcb258af470ece2e": "Ybodychange",
    "02e7dec79d2d4f2b801435343219d8fb53ec931f": "Ybodychange",
    "085b1e293ff53f7a86aa21406cfd4bfa0f3bf33b": "Ybodychange",
    "2d4f3e567e4bb8068c028de12df118a4f3fa6343": "Ybodychange",
    "86cad007d7d6366b293bb9a073814889081c8662": "Ybodychange",
    "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24": "Ybodychange",
    "3052ad1f0069af5caee621374b29d17d7f12ab51": "Ybodychange",
    "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7": "Ybodychange",
    "837e17b2eac1471d93e2eff395272063b265fee7": "Ybodychange",
    "239b2742d0e80d13c970fd062af4930e672fe903": "Ybodychange",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": "Ybodychange",
    "9b4a7900c7dfc0590316eedaa97144f938885651": "Ybodychange",
    "905a127850d5e0cba85c2e075f989fa0f5cf129a": "Ybodychange",
    "1c940637b14eee777a65d153d0d712a1aea3866c": "Ybodychange",
    "c46876982ed90d0819a94b518f6135b82334d10d": "Ybodychange",
    "e90a5b40430cc1fbce075d34b31e3cc05fd9831f": "Ybodychange",
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "ef223e8e8e1e18733fc18cd84e34dd0bb0f9a710": "Ybodychange",
    "2f48fae72aa52e6ec42264cad24fab36b6a426c2": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Yparametermetachange)",
    "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "915cbc91c0a12cc7b4d3ef4ea951941defbbcb33": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14706. Checksums are not checked if block meta file is less than 7 bytes. Contributed by Stephen O\u0027Donnell.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "02/09/19 9:47 AM",
      "commitName": "915cbc91c0a12cc7b4d3ef4ea951941defbbcb33",
      "commitAuthor": "Stephen O\u0027Donnell",
      "commitDateOld": "12/04/19 5:37 PM",
      "commitNameOld": "626fec652b9f3dae10c9af78fd220b1240f19fc7",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 142.67,
      "commitsBetweenForRepo": 1088,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,74 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     DataOutputStream reply \u003d getBufferedOutputStream();\n     checkAccess(reply, true, block, blockToken, Op.COPY_BLOCK,\n         BlockTokenIdentifier.AccessMode.COPY);\n \n     if (datanode.data.getPinning(block)) {\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n       LOG.info(msg);\n       sendResponse(Status.ERROR_BLOCK_PINNED, msg);\n       return;\n     }\n     \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null, CachingStrategy.newDropBehind());\n \n       OutputStream baseStream \u003d getOutputStream();\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n \n       long beginRead \u003d Time.monotonicNow();\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream,\n                                         dataXceiverServer.balanceThrottler);\n       long duration \u003d Time.monotonicNow() - beginRead;\n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       datanode.metrics.incrTotalReadTime(duration);\n       \n       LOG.info(\"Copied {} to {}\", block, peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock {} received exception {}\", block, ioe.toString());\n       incrDatanodeNetworkErrors();\n+      // Normally the client reports a bad block to the NN. However if the\n+      // meta file is corrupt or an disk error occurs (EIO), then the client\n+      // never gets a chance to do validation, and hence will never report\n+      // the block as bad. For some classes of IO exception, the DN should\n+      // report the block as bad, via the handleBadBlock() method\n+      datanode.handleBadBlock(block, ioe, false);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    DataOutputStream reply \u003d getBufferedOutputStream();\n    checkAccess(reply, true, block, blockToken, Op.COPY_BLOCK,\n        BlockTokenIdentifier.AccessMode.COPY);\n\n    if (datanode.data.getPinning(block)) {\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n      LOG.info(msg);\n      sendResponse(Status.ERROR_BLOCK_PINNED, msg);\n      return;\n    }\n    \n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      OutputStream baseStream \u003d getOutputStream();\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n\n      long beginRead \u003d Time.monotonicNow();\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream,\n                                        dataXceiverServer.balanceThrottler);\n      long duration \u003d Time.monotonicNow() - beginRead;\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      datanode.metrics.incrTotalReadTime(duration);\n      \n      LOG.info(\"Copied {} to {}\", block, peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock {} received exception {}\", block, ioe.toString());\n      incrDatanodeNetworkErrors();\n      // Normally the client reports a bad block to the NN. However if the\n      // meta file is corrupt or an disk error occurs (EIO), then the client\n      // never gets a chance to do validation, and hence will never report\n      // the block as bad. For some classes of IO exception, the DN should\n      // report the block as bad, via the handleBadBlock() method\n      datanode.handleBadBlock(block, ioe, false);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10571. Use Log.*(Object, Throwable) overload to log exceptions.\nContributed by Andras Bokor.\n",
      "commitDate": "14/02/18 8:20 AM",
      "commitName": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "01/11/17 1:41 AM",
      "commitNameOld": "56b88b06705441f6f171eec7fb2fa77946ca204b",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 105.32,
      "commitsBetweenForRepo": 696,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     DataOutputStream reply \u003d getBufferedOutputStream();\n     checkAccess(reply, true, block, blockToken, Op.COPY_BLOCK,\n         BlockTokenIdentifier.AccessMode.COPY);\n \n     if (datanode.data.getPinning(block)) {\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n       LOG.info(msg);\n       sendResponse(Status.ERROR_BLOCK_PINNED, msg);\n       return;\n     }\n     \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null, CachingStrategy.newDropBehind());\n \n       OutputStream baseStream \u003d getOutputStream();\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n \n       long beginRead \u003d Time.monotonicNow();\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream,\n                                         dataXceiverServer.balanceThrottler);\n       long duration \u003d Time.monotonicNow() - beginRead;\n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       datanode.metrics.incrTotalReadTime(duration);\n       \n-      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n+      LOG.info(\"Copied {} to {}\", block, peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n-      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n+      LOG.info(\"opCopyBlock {} received exception {}\", block, ioe.toString());\n       incrDatanodeNetworkErrors();\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    DataOutputStream reply \u003d getBufferedOutputStream();\n    checkAccess(reply, true, block, blockToken, Op.COPY_BLOCK,\n        BlockTokenIdentifier.AccessMode.COPY);\n\n    if (datanode.data.getPinning(block)) {\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n      LOG.info(msg);\n      sendResponse(Status.ERROR_BLOCK_PINNED, msg);\n      return;\n    }\n    \n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      OutputStream baseStream \u003d getOutputStream();\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n\n      long beginRead \u003d Time.monotonicNow();\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream,\n                                        dataXceiverServer.balanceThrottler);\n      long duration \u003d Time.monotonicNow() - beginRead;\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      datanode.metrics.incrTotalReadTime(duration);\n      \n      LOG.info(\"Copied {} to {}\", block, peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock {} received exception {}\", block, ioe.toString());\n      incrDatanodeNetworkErrors();\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "e24a923db50879f7dbe5d2afac0e6757089fb07d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11164: Mover should avoid unnecessary retries if the block is pinned. Contributed by Rakesh R\n",
      "commitDate": "13/12/16 5:09 PM",
      "commitName": "e24a923db50879f7dbe5d2afac0e6757089fb07d",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "30/08/16 10:43 AM",
      "commitNameOld": "c4ee6915a14e00342755d7cdcbf2d61518f306aa",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 105.31,
      "commitsBetweenForRepo": 759,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     DataOutputStream reply \u003d getBufferedOutputStream();\n     checkAccess(reply, true, block, blockToken,\n         Op.COPY_BLOCK, BlockTokenIdentifier.AccessMode.COPY);\n \n     if (datanode.data.getPinning(block)) {\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n       LOG.info(msg);\n-      sendResponse(ERROR, msg);\n+      sendResponse(Status.ERROR_BLOCK_PINNED, msg);\n       return;\n     }\n     \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null, CachingStrategy.newDropBehind());\n \n       OutputStream baseStream \u003d getOutputStream();\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n \n       long beginRead \u003d Time.monotonicNow();\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream,\n                                         dataXceiverServer.balanceThrottler);\n       long duration \u003d Time.monotonicNow() - beginRead;\n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       datanode.metrics.incrTotalReadTime(duration);\n       \n       LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       incrDatanodeNetworkErrors();\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    DataOutputStream reply \u003d getBufferedOutputStream();\n    checkAccess(reply, true, block, blockToken,\n        Op.COPY_BLOCK, BlockTokenIdentifier.AccessMode.COPY);\n\n    if (datanode.data.getPinning(block)) {\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n      LOG.info(msg);\n      sendResponse(Status.ERROR_BLOCK_PINNED, msg);\n      return;\n    }\n    \n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      OutputStream baseStream \u003d getOutputStream();\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n\n      long beginRead \u003d Time.monotonicNow();\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream,\n                                        dataXceiverServer.balanceThrottler);\n      long duration \u003d Time.monotonicNow() - beginRead;\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      datanode.metrics.incrTotalReadTime(duration);\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      incrDatanodeNetworkErrors();\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "aea31eee78a287f251447686ba3f5bbcfe9c60a3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9713. DataXceiver#copyBlock should return if block is pinned. Contributed by Uma Maheswara Rao G.\n",
      "commitDate": "07/02/16 8:50 PM",
      "commitName": "aea31eee78a287f251447686ba3f5bbcfe9c60a3",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "08/01/16 9:13 AM",
      "commitNameOld": "38c4c14472996562eb3d610649246770c2888c6b",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 30.48,
      "commitsBetweenForRepo": 217,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,68 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     DataOutputStream reply \u003d getBufferedOutputStream();\n     checkAccess(reply, true, block, blockToken,\n         Op.COPY_BLOCK, BlockTokenIdentifier.AccessMode.COPY);\n \n     if (datanode.data.getPinning(block)) {\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n+      return;\n     }\n     \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null, CachingStrategy.newDropBehind());\n \n       OutputStream baseStream \u003d getOutputStream();\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n \n       long beginRead \u003d Time.monotonicNow();\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream,\n                                         dataXceiverServer.balanceThrottler);\n       long duration \u003d Time.monotonicNow() - beginRead;\n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       datanode.metrics.incrTotalReadTime(duration);\n       \n       LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       incrDatanodeNetworkErrors();\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    DataOutputStream reply \u003d getBufferedOutputStream();\n    checkAccess(reply, true, block, blockToken,\n        Op.COPY_BLOCK, BlockTokenIdentifier.AccessMode.COPY);\n\n    if (datanode.data.getPinning(block)) {\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n    \n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      OutputStream baseStream \u003d getOutputStream();\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n\n      long beginRead \u003d Time.monotonicNow();\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream,\n                                        dataXceiverServer.balanceThrottler);\n      long duration \u003d Time.monotonicNow() - beginRead;\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      datanode.metrics.incrTotalReadTime(duration);\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      incrDatanodeNetworkErrors();\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "38c4c14472996562eb3d610649246770c2888c6b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9574. Reduce client failures during datanode restart. Contributed by Kihwal Lee.\n",
      "commitDate": "08/01/16 9:13 AM",
      "commitName": "38c4c14472996562eb3d610649246770c2888c6b",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/01/16 2:32 PM",
      "commitNameOld": "778146eaae5b1e17928a1f26fb1e46536a6ee510",
      "commitAuthorOld": "Uma Mahesh",
      "daysBetweenCommits": 3.78,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,67 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n-    // Read in the header\n-    if (datanode.isBlockTokenEnabled) {\n-      try {\n-        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n-            BlockTokenIdentifier.AccessMode.COPY);\n-      } catch (InvalidToken e) {\n-        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n-            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n-            + e.getLocalizedMessage());\n-        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n-        return;\n-      }\n+    DataOutputStream reply \u003d getBufferedOutputStream();\n+    checkAccess(reply, true, block, blockToken,\n+        Op.COPY_BLOCK, BlockTokenIdentifier.AccessMode.COPY);\n \n-    }\n-    \n     if (datanode.data.getPinning(block)) {\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n     }\n     \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n-    DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null, CachingStrategy.newDropBehind());\n \n-      // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n-      reply \u003d new DataOutputStream(new BufferedOutputStream(\n-          baseStream, smallBufferSize));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n \n       long beginRead \u003d Time.monotonicNow();\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream,\n                                         dataXceiverServer.balanceThrottler);\n       long duration \u003d Time.monotonicNow() - beginRead;\n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       datanode.metrics.incrTotalReadTime(duration);\n       \n       LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       incrDatanodeNetworkErrors();\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    DataOutputStream reply \u003d getBufferedOutputStream();\n    checkAccess(reply, true, block, blockToken,\n        Op.COPY_BLOCK, BlockTokenIdentifier.AccessMode.COPY);\n\n    if (datanode.data.getPinning(block)) {\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n    }\n    \n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      OutputStream baseStream \u003d getOutputStream();\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n\n      long beginRead \u003d Time.monotonicNow();\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream,\n                                        dataXceiverServer.balanceThrottler);\n      long duration \u003d Time.monotonicNow() - beginRead;\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      datanode.metrics.incrTotalReadTime(duration);\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      incrDatanodeNetworkErrors();\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "4da8490b512a33a255ed27309860859388d7c168": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8314. Move HdfsServerConstants#IO_FILE_BUFFER_SIZE and SMALL_BUFFER_SIZE to the users. Contributed by Li Lu.\n",
      "commitDate": "05/05/15 3:41 PM",
      "commitName": "4da8490b512a33a255ed27309860859388d7c168",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "02/05/15 10:03 AM",
      "commitNameOld": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 3.23,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenIdentifier.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n     \n     if (datanode.data.getPinning(block)) {\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n     }\n     \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null, CachingStrategy.newDropBehind());\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n-          baseStream, HdfsServerConstants.SMALL_BUFFER_SIZE));\n+          baseStream, smallBufferSize));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n \n       long beginRead \u003d Time.monotonicNow();\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream,\n                                         dataXceiverServer.balanceThrottler);\n       long duration \u003d Time.monotonicNow() - beginRead;\n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       datanode.metrics.incrTotalReadTime(duration);\n       \n       LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       incrDatanodeNetworkErrors();\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenIdentifier.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n    \n    if (datanode.data.getPinning(block)) {\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n    }\n    \n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, smallBufferSize));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n\n      long beginRead \u003d Time.monotonicNow();\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream,\n                                        dataXceiverServer.balanceThrottler);\n      long duration \u003d Time.monotonicNow() - beginRead;\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      datanode.metrics.incrTotalReadTime(duration);\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      incrDatanodeNetworkErrors();\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "23/04/15 7:00 PM",
      "commitNameOld": "a0e0a63209b5eb17dca5cc503be36aa52defeabd",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 8.63,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenIdentifier.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n     \n     if (datanode.data.getPinning(block)) {\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n     }\n     \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null, CachingStrategy.newDropBehind());\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n-          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n+          baseStream, HdfsServerConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n \n       long beginRead \u003d Time.monotonicNow();\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream,\n                                         dataXceiverServer.balanceThrottler);\n       long duration \u003d Time.monotonicNow() - beginRead;\n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       datanode.metrics.incrTotalReadTime(duration);\n       \n       LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       incrDatanodeNetworkErrors();\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenIdentifier.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n    \n    if (datanode.data.getPinning(block)) {\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n    }\n    \n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsServerConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n\n      long beginRead \u003d Time.monotonicNow();\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream,\n                                        dataXceiverServer.balanceThrottler);\n      long duration \u003d Time.monotonicNow() - beginRead;\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      datanode.metrics.incrTotalReadTime(duration);\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      incrDatanodeNetworkErrors();\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "36e4cd3be6f7fec8db82d3d1bcb258af470ece2e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8103. Move BlockTokenSecretManager.AccessMode into BlockTokenIdentifier. Contributed by Haohui Mai.\n",
      "commitDate": "10/04/15 4:36 PM",
      "commitName": "36e4cd3be6f7fec8db82d3d1bcb258af470ece2e",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "20/03/15 12:02 PM",
      "commitNameOld": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 21.19,
      "commitsBetweenForRepo": 196,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n-            BlockTokenSecretManager.AccessMode.COPY);\n+            BlockTokenIdentifier.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n     \n     if (datanode.data.getPinning(block)) {\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n     }\n     \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null, CachingStrategy.newDropBehind());\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n \n       long beginRead \u003d Time.monotonicNow();\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream,\n                                         dataXceiverServer.balanceThrottler);\n       long duration \u003d Time.monotonicNow() - beginRead;\n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       datanode.metrics.incrTotalReadTime(duration);\n       \n       LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       incrDatanodeNetworkErrors();\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenIdentifier.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n    \n    if (datanode.data.getPinning(block)) {\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n    }\n    \n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n\n      long beginRead \u003d Time.monotonicNow();\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream,\n                                        dataXceiverServer.balanceThrottler);\n      long duration \u003d Time.monotonicNow() - beginRead;\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      datanode.metrics.incrTotalReadTime(duration);\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      incrDatanodeNetworkErrors();\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "02e7dec79d2d4f2b801435343219d8fb53ec931f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7773. Additional metrics in HDFS to be accessed via jmx. Contributed by Anu Engineer.\n",
      "commitDate": "20/02/15 12:37 PM",
      "commitName": "02e7dec79d2d4f2b801435343219d8fb53ec931f",
      "commitAuthor": "cnauroth",
      "commitDateOld": "11/02/15 3:12 PM",
      "commitNameOld": "085b1e293ff53f7a86aa21406cfd4bfa0f3bf33b",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 8.89,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,82 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n     \n     if (datanode.data.getPinning(block)) {\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n     }\n     \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null, CachingStrategy.newDropBehind());\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n-      // send block content to the target\n-      long read \u003d blockSender.sendBlock(reply, baseStream, \n-                                        dataXceiverServer.balanceThrottler);\n \n+      long beginRead \u003d Time.monotonicNow();\n+      // send block content to the target\n+      long read \u003d blockSender.sendBlock(reply, baseStream,\n+                                        dataXceiverServer.balanceThrottler);\n+      long duration \u003d Time.monotonicNow() - beginRead;\n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n+      datanode.metrics.incrTotalReadTime(duration);\n       \n       LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       incrDatanodeNetworkErrors();\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n    \n    if (datanode.data.getPinning(block)) {\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n    }\n    \n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n\n      long beginRead \u003d Time.monotonicNow();\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream,\n                                        dataXceiverServer.balanceThrottler);\n      long duration \u003d Time.monotonicNow() - beginRead;\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      datanode.metrics.incrTotalReadTime(duration);\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      incrDatanodeNetworkErrors();\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "085b1e293ff53f7a86aa21406cfd4bfa0f3bf33b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6133. Add a feature for replica pinning so that a pinned replica will not be moved by Balancer/Mover.  Contributed by zhaoyunjiong\n",
      "commitDate": "11/02/15 3:12 PM",
      "commitName": "085b1e293ff53f7a86aa21406cfd4bfa0f3bf33b",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "18/12/14 3:03 PM",
      "commitNameOld": "5df7ecb33ab24de903f0fd98e2a055164874def5",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 55.01,
      "commitsBetweenForRepo": 369,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,79 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n-\n+    \n+    if (datanode.data.getPinning(block)) {\n+      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n+          \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n+      LOG.info(msg);\n+      sendResponse(ERROR, msg);\n+    }\n+    \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null, CachingStrategy.newDropBehind());\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       incrDatanodeNetworkErrors();\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n    \n    if (datanode.data.getPinning(block)) {\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because it\u0027s pinned \";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n    }\n    \n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      incrDatanodeNetworkErrors();\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "2d4f3e567e4bb8068c028de12df118a4f3fa6343": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7331. Add Datanode network counts to datanode jmx page. Contributed by Charles Lamb.\n",
      "commitDate": "21/11/14 4:36 PM",
      "commitName": "2d4f3e567e4bb8068c028de12df118a4f3fa6343",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "08/11/14 10:24 PM",
      "commitNameOld": "9ba8d8c7eb65eeb6fe673f04e493d9eedd95a822",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 12.76,
      "commitsBetweenForRepo": 104,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null, CachingStrategy.newDropBehind());\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n-      datanode.metrics.incrDatanodeNetworkErrors();\n+      incrDatanodeNetworkErrors();\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      incrDatanodeNetworkErrors();\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "86cad007d7d6366b293bb9a073814889081c8662": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7222. Expose DataNode network errors as a metric. (Charles Lamb via wang)\n",
      "commitDate": "23/10/14 12:53 PM",
      "commitName": "86cad007d7d6366b293bb9a073814889081c8662",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "27/08/14 9:47 PM",
      "commitNameOld": "a317bd7b02c37bd57743bfad59593ec12f53f4ed",
      "commitAuthorOld": "arp",
      "daysBetweenCommits": 56.63,
      "commitsBetweenForRepo": 574,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,72 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null, CachingStrategy.newDropBehind());\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n+      datanode.metrics.incrDatanodeNetworkErrors();\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      datanode.metrics.incrDatanodeNetworkErrors();\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4817.  Make HDFS advisory caching configurable on a per-file basis.  (Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/13 11:15 AM",
      "commitName": "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "09/05/13 5:03 PM",
      "commitNameOld": "a18fd620d070cf8e84aaf80d93807ac9ee207a0f",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 73.76,
      "commitsBetweenForRepo": 437,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n           \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n-          null);\n+          null, CachingStrategy.newDropBehind());\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null, CachingStrategy.newDropBehind());\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "3052ad1f0069af5caee621374b29d17d7f12ab51": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3429. DataNode reads checksums even if client does not need them. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1433117 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/01/13 12:47 PM",
      "commitName": "3052ad1f0069af5caee621374b29d17d7f12ab51",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "09/01/13 1:20 PM",
      "commitNameOld": "3cd17b614e9436d06cd9b4ccc5f9cf59fbe1cf21",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 4.98,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n       + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n-      blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n+      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n           null);\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n      + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, true, datanode, \n          null);\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1431097 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/13 1:34 PM",
      "commitName": "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "08/01/13 6:39 PM",
      "commitNameOld": "837e17b2eac1471d93e2eff395272063b265fee7",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,71 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n-      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n-      + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n+      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n+          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n+          \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n           null);\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n-      LOG.info(\"Copied \" + block + \" to \" + s.getRemoteSocketAddress());\n+      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n          null);\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "837e17b2eac1471d93e2eff395272063b265fee7": {
      "type": "Ybodychange",
      "commitMessage": "svn merge -c -1430507 . for reverting HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430662 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 6:39 PM",
      "commitName": "837e17b2eac1471d93e2eff395272063b265fee7",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "08/01/13 12:44 PM",
      "commitNameOld": "239b2742d0e80d13c970fd062af4930e672fe903",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,70 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n-      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n-          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n-          \"quota is exceeded.\";\n+      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n+      + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n           null);\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n-      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n+      LOG.info(\"Copied \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n      + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n          null);\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "239b2742d0e80d13c970fd062af4930e672fe903": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430507 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 12:44 PM",
      "commitName": "239b2742d0e80d13c970fd062af4930e672fe903",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "28/10/12 4:10 PM",
      "commitNameOld": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 71.9,
      "commitsBetweenForRepo": 300,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,71 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n-      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n-      + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n+      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n+          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n+          \"quota is exceeded.\";\n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n           null);\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n-      LOG.info(\"Copied \" + block + \" to \" + s.getRemoteSocketAddress());\n+      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" \" +\n          \"to \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n          null);\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied \" + block + \" to \" + peer.getRemoteAddressString());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4122. Cleanup HDFS logs and reduce the size of logged messages. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1403120 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/12 4:10 PM",
      "commitName": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "24/08/12 7:15 AM",
      "commitNameOld": "c46de830da98959f40dd41c95bdebecdfb9ea730",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 65.37,
      "commitsBetweenForRepo": 392,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n       + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.info(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n           null);\n \n       // set up response stream\n       OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n-      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n+      LOG.info(\"Copied \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n      + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n          null);\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "9b4a7900c7dfc0590316eedaa97144f938885651": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3637. Add support for encrypting the DataTransferProtocol. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370354 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 9:40 AM",
      "commitName": "9b4a7900c7dfc0590316eedaa97144f938885651",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "15/07/12 7:58 PM",
      "commitNameOld": "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 22.57,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,70 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n-        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\", dnConf.socketWriteTimeout);\n+        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n       + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.info(msg);\n-      sendResponse(s, ERROR, msg, dnConf.socketWriteTimeout);\n+      sendResponse(ERROR, msg);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n           null);\n \n       // set up response stream\n-      OutputStream baseStream \u003d NetUtils.getOutputStream(\n-          s, dnConf.socketWriteTimeout);\n+      OutputStream baseStream \u003d getOutputStream();\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n      + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.info(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n          null);\n\n      // set up response stream\n      OutputStream baseStream \u003d getOutputStream();\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "905a127850d5e0cba85c2e075f989fa0f5cf129a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2562. Refactor DN configuration variables out of DataNode class. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1203543 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/11 1:04 AM",
      "commitName": "905a127850d5e0cba85c2e075f989fa0f5cf129a",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "31/10/11 10:17 PM",
      "commitNameOld": "1c940637b14eee777a65d153d0d712a1aea3866c",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 17.16,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n-        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\", datanode.socketWriteTimeout);\n+        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\", dnConf.socketWriteTimeout);\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n       + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.info(msg);\n-      sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);\n+      sendResponse(s, ERROR, msg, dnConf.socketWriteTimeout);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n           null);\n \n       // set up response stream\n       OutputStream baseStream \u003d NetUtils.getOutputStream(\n-          s, datanode.socketWriteTimeout);\n+          s, dnConf.socketWriteTimeout);\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeSuccessWithChecksumInfo(blockSender, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\", dnConf.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n      + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.info(msg);\n      sendResponse(s, ERROR, msg, dnConf.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n          null);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, dnConf.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "1c940637b14eee777a65d153d0d712a1aea3866c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2521. Remove custom checksum headers from data transfer protocol. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195829 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/11 10:17 PM",
      "commitName": "1c940637b14eee777a65d153d0d712a1aea3866c",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "31/10/11 2:53 PM",
      "commitNameOld": "c46876982ed90d0819a94b518f6135b82334d10d",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.31,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\", datanode.socketWriteTimeout);\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n       + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.info(msg);\n       sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n-      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n-          datanode, null);\n+      blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n+          null);\n \n       // set up response stream\n       OutputStream baseStream \u003d NetUtils.getOutputStream(\n           s, datanode.socketWriteTimeout);\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n-      writeResponse(SUCCESS, null, reply);\n+      writeSuccessWithChecksumInfo(blockSender, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\", datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n      + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.info(msg);\n      sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, datanode, \n          null);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeSuccessWithChecksumInfo(blockSender, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "c46876982ed90d0819a94b518f6135b82334d10d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2512. Add textual error message to data transfer protocol responses. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195693 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/11 2:53 PM",
      "commitName": "c46876982ed90d0819a94b518f6135b82334d10d",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "23/10/11 1:17 PM",
      "commitNameOld": "6e0991704ffda5cf4cff758f0e7086523fa7bcb4",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 8.07,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,71 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n-        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n+        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\", datanode.socketWriteTimeout);\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n-      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n-          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n-      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n+      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n+      + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n+      LOG.info(msg);\n+      sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n           datanode, null);\n \n       // set up response stream\n       OutputStream baseStream \u003d NetUtils.getOutputStream(\n           s, datanode.socketWriteTimeout);\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n-      writeResponse(SUCCESS, reply);\n+      writeResponse(SUCCESS, null, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\", datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to copy block \" + block.getBlockId() + \" to \" \n      + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.info(msg);\n      sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n          datanode, null);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeResponse(SUCCESS, null, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "e90a5b40430cc1fbce075d34b31e3cc05fd9831f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2371. Refactor BlockSender.java for better readability. Contributed by Suresh Srinivas.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1177161 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/09/11 9:40 PM",
      "commitName": "e90a5b40430cc1fbce075d34b31e3cc05fd9831f",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "04/09/11 12:30 PM",
      "commitNameOld": "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 24.38,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n-          datanode);\n+          datanode, null);\n \n       // set up response stream\n       OutputStream baseStream \u003d NetUtils.getOutputStream(\n           s, datanode.socketWriteTimeout);\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeResponse(SUCCESS, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n          datanode, null);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeResponse(SUCCESS, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1620. Rename HdfsConstants -\u003e HdfsServerConstants, FSConstants -\u003e HdfsConstants. (Harsh J Chouraria via atm)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165096 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/11 12:30 PM",
      "commitName": "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 10.8,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n           datanode);\n \n       // set up response stream\n       OutputStream baseStream \u003d NetUtils.getOutputStream(\n           s, datanode.socketWriteTimeout);\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n-          baseStream, FSConstants.SMALL_BUFFER_SIZE));\n+          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeResponse(SUCCESS, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n          datanode);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, HdfsConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeResponse(SUCCESS, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n          datanode);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, FSConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeResponse(SUCCESS, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n          datanode);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, FSConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeResponse(SUCCESS, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java"
      }
    },
    "ef223e8e8e1e18733fc18cd84e34dd0bb0f9a710": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2241. Remove implementing FSConstants interface to just get the constants from the interface. Contributed by Suresh Srinivas.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1156420 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/08/11 5:46 PM",
      "commitName": "ef223e8e8e1e18733fc18cd84e34dd0bb0f9a710",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "12/07/11 6:11 PM",
      "commitNameOld": "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
      "commitAuthorOld": "Jitendra Nath Pandey",
      "daysBetweenCommits": 28.98,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public void copyBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n           datanode);\n \n       // set up response stream\n       OutputStream baseStream \u003d NetUtils.getOutputStream(\n           s, datanode.socketWriteTimeout);\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n-          baseStream, SMALL_BUFFER_SIZE));\n+          baseStream, FSConstants.SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeResponse(SUCCESS, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n          datanode);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, FSConstants.SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeResponse(SUCCESS, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "2f48fae72aa52e6ec42264cad24fab36b6a426c2": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Yparametermetachange)",
      "commitMessage": "HDFS-2087. Declare methods in DataTransferProtocol interface, and change Sender and Receiver to implement the interface.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139124 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/06/11 4:57 PM",
      "commitName": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-2087. Declare methods in DataTransferProtocol interface, and change Sender and Receiver to implement the interface.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139124 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/06/11 4:57 PM",
          "commitName": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "21/06/11 10:12 AM",
          "commitNameOld": "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 2.28,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,70 @@\n-  protected void opCopyBlock(DataInputStream in, ExtendedBlock block,\n-      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n+  public void copyBlock(final ExtendedBlock block,\n+      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n           datanode);\n \n       // set up response stream\n       OutputStream baseStream \u003d NetUtils.getOutputStream(\n           s, datanode.socketWriteTimeout);\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeResponse(SUCCESS, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n          datanode);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeResponse(SUCCESS, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "opCopyBlock",
            "newValue": "copyBlock"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-2087. Declare methods in DataTransferProtocol interface, and change Sender and Receiver to implement the interface.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139124 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/06/11 4:57 PM",
          "commitName": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "21/06/11 10:12 AM",
          "commitNameOld": "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 2.28,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,70 @@\n-  protected void opCopyBlock(DataInputStream in, ExtendedBlock block,\n-      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n+  public void copyBlock(final ExtendedBlock block,\n+      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n           datanode);\n \n       // set up response stream\n       OutputStream baseStream \u003d NetUtils.getOutputStream(\n           s, datanode.socketWriteTimeout);\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeResponse(SUCCESS, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n          datanode);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeResponse(SUCCESS, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[in-DataInputStream, block-ExtendedBlock, blockToken-Token\u003cBlockTokenIdentifier\u003e]",
            "newValue": "[block-ExtendedBlock(modifiers-final), blockToken-Token\u003cBlockTokenIdentifier\u003e(modifiers-final)]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-2087. Declare methods in DataTransferProtocol interface, and change Sender and Receiver to implement the interface.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139124 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/06/11 4:57 PM",
          "commitName": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "21/06/11 10:12 AM",
          "commitNameOld": "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 2.28,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,70 @@\n-  protected void opCopyBlock(DataInputStream in, ExtendedBlock block,\n-      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n+  public void copyBlock(final ExtendedBlock block,\n+      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n           datanode);\n \n       // set up response stream\n       OutputStream baseStream \u003d NetUtils.getOutputStream(\n           s, datanode.socketWriteTimeout);\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeResponse(SUCCESS, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n          datanode);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeResponse(SUCCESS, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HDFS-2087. Declare methods in DataTransferProtocol interface, and change Sender and Receiver to implement the interface.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139124 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/06/11 4:57 PM",
          "commitName": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "21/06/11 10:12 AM",
          "commitNameOld": "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 2.28,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,70 @@\n-  protected void opCopyBlock(DataInputStream in, ExtendedBlock block,\n-      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n+  public void copyBlock(final ExtendedBlock block,\n+      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n           datanode);\n \n       // set up response stream\n       OutputStream baseStream \u003d NetUtils.getOutputStream(\n           s, datanode.socketWriteTimeout);\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeResponse(SUCCESS, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n       LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void copyBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n          datanode);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeResponse(SUCCESS, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[in-DataInputStream, block-ExtendedBlock, blockToken-Token\u003cBlockTokenIdentifier\u003e]",
            "newValue": "[block-ExtendedBlock(modifiers-final), blockToken-Token\u003cBlockTokenIdentifier\u003e(modifiers-final)]"
          }
        }
      ]
    },
    "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1568. Improve the log messages in DataXceiver.  Contributed by Joey Echeverria\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1138098 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/06/11 10:12 AM",
      "commitName": "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "15/06/11 2:36 PM",
      "commitNameOld": "6a3963cc8b4cdadf6dc8d2a9ca4f3af4da50a1d2",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 5.82,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,70 @@\n   protected void opCopyBlock(DataInputStream in, ExtendedBlock block,\n       Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Copying block \" + block);\n     // Read in the header\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.COPY);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n \n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     BlockSender blockSender \u003d null;\n     DataOutputStream reply \u003d null;\n     boolean isOpSuccess \u003d true;\n \n     try {\n       // check if the block exists or not\n       blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n           datanode);\n \n       // set up response stream\n       OutputStream baseStream \u003d NetUtils.getOutputStream(\n           s, datanode.socketWriteTimeout);\n       reply \u003d new DataOutputStream(new BufferedOutputStream(\n           baseStream, SMALL_BUFFER_SIZE));\n \n       // send status first\n       writeResponse(SUCCESS, reply);\n       // send block content to the target\n       long read \u003d blockSender.sendBlock(reply, baseStream, \n                                         dataXceiverServer.balanceThrottler);\n \n       datanode.metrics.incrBytesRead((int) read);\n       datanode.metrics.incrBlocksRead();\n       \n       LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n     } catch (IOException ioe) {\n       isOpSuccess \u003d false;\n+      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       dataXceiverServer.balanceThrottler.release();\n       if (isOpSuccess) {\n         try {\n           // send one last byte to indicate that the resource is cleaned.\n           reply.writeChar(\u0027d\u0027);\n         } catch (IOException ignored) {\n         }\n       }\n       IOUtils.closeStream(reply);\n       IOUtils.closeStream(blockSender);\n     }\n \n     //update metrics    \n     datanode.metrics.addCopyBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void opCopyBlock(DataInputStream in, ExtendedBlock block,\n      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n          datanode);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeResponse(SUCCESS, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      LOG.info(\"opCopyBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,69 @@\n+  protected void opCopyBlock(DataInputStream in, ExtendedBlock block,\n+      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n+    updateCurrentThreadName(\"Copying block \" + block);\n+    // Read in the header\n+    if (datanode.isBlockTokenEnabled) {\n+      try {\n+        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n+            BlockTokenSecretManager.AccessMode.COPY);\n+      } catch (InvalidToken e) {\n+        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n+            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n+            + e.getLocalizedMessage());\n+        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n+        return;\n+      }\n+\n+    }\n+\n+    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n+      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n+          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n+      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n+      return;\n+    }\n+\n+    BlockSender blockSender \u003d null;\n+    DataOutputStream reply \u003d null;\n+    boolean isOpSuccess \u003d true;\n+\n+    try {\n+      // check if the block exists or not\n+      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n+          datanode);\n+\n+      // set up response stream\n+      OutputStream baseStream \u003d NetUtils.getOutputStream(\n+          s, datanode.socketWriteTimeout);\n+      reply \u003d new DataOutputStream(new BufferedOutputStream(\n+          baseStream, SMALL_BUFFER_SIZE));\n+\n+      // send status first\n+      writeResponse(SUCCESS, reply);\n+      // send block content to the target\n+      long read \u003d blockSender.sendBlock(reply, baseStream, \n+                                        dataXceiverServer.balanceThrottler);\n+\n+      datanode.metrics.incrBytesRead((int) read);\n+      datanode.metrics.incrBlocksRead();\n+      \n+      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n+    } catch (IOException ioe) {\n+      isOpSuccess \u003d false;\n+      throw ioe;\n+    } finally {\n+      dataXceiverServer.balanceThrottler.release();\n+      if (isOpSuccess) {\n+        try {\n+          // send one last byte to indicate that the resource is cleaned.\n+          reply.writeChar(\u0027d\u0027);\n+        } catch (IOException ignored) {\n+        }\n+      }\n+      IOUtils.closeStream(reply);\n+      IOUtils.closeStream(blockSender);\n+    }\n+\n+    //update metrics    \n+    datanode.metrics.addCopyBlockOp(elapsed());\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void opCopyBlock(DataInputStream in, ExtendedBlock block,\n      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Copying block \" + block);\n    // Read in the header\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.COPY);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_COPY_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.info(\"Not able to copy block \" + block.getBlockId() + \" to \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    BlockSender blockSender \u003d null;\n    DataOutputStream reply \u003d null;\n    boolean isOpSuccess \u003d true;\n\n    try {\n      // check if the block exists or not\n      blockSender \u003d new BlockSender(block, 0, -1, false, false, false, \n          datanode);\n\n      // set up response stream\n      OutputStream baseStream \u003d NetUtils.getOutputStream(\n          s, datanode.socketWriteTimeout);\n      reply \u003d new DataOutputStream(new BufferedOutputStream(\n          baseStream, SMALL_BUFFER_SIZE));\n\n      // send status first\n      writeResponse(SUCCESS, reply);\n      // send block content to the target\n      long read \u003d blockSender.sendBlock(reply, baseStream, \n                                        dataXceiverServer.balanceThrottler);\n\n      datanode.metrics.incrBytesRead((int) read);\n      datanode.metrics.incrBlocksRead();\n      \n      LOG.info(\"Copied block \" + block + \" to \" + s.getRemoteSocketAddress());\n    } catch (IOException ioe) {\n      isOpSuccess \u003d false;\n      throw ioe;\n    } finally {\n      dataXceiverServer.balanceThrottler.release();\n      if (isOpSuccess) {\n        try {\n          // send one last byte to indicate that the resource is cleaned.\n          reply.writeChar(\u0027d\u0027);\n        } catch (IOException ignored) {\n        }\n      }\n      IOUtils.closeStream(reply);\n      IOUtils.closeStream(blockSender);\n    }\n\n    //update metrics    \n    datanode.metrics.addCopyBlockOp(elapsed());\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java"
    }
  }
}