{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SchedulerApplicationAttempt.java",
  "functionName": "addToNewlyAllocatedContainers",
  "functionId": "addToNewlyAllocatedContainers___node-SchedulerNode__rmContainer-RMContainer",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java",
  "functionStartLine": 854,
  "functionEndLine": 887,
  "numCommitsSeen": 105,
  "timeTaken": 3213,
  "changeHistory": [
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4"
  ],
  "changeHistoryShort": {
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": "Ybodychange",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": "Yintroduced"
  },
  "changeHistoryDetails": {
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6216. Unify Container Resizing code paths with Container Updates making it scheduler agnostic. (Arun Suresh via wangda)\n",
      "commitDate": "28/02/17 10:35 AM",
      "commitName": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/02/17 10:23 AM",
      "commitNameOld": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 19.01,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,34 @@\n   protected synchronized void addToNewlyAllocatedContainers(\n       SchedulerNode node, RMContainer rmContainer) {\n-    if (oppContainerContext \u003d\u003d null) {\n-      newlyAllocatedContainers.add(rmContainer);\n-      return;\n-    }\n     ContainerId matchedContainerId \u003d\n         getUpdateContext().matchContainerToOutstandingIncreaseReq(\n             node, rmContainer.getAllocatedSchedulerKey(), rmContainer);\n     if (matchedContainerId !\u003d null) {\n       if (ContainerUpdateContext.UNDEFINED \u003d\u003d matchedContainerId) {\n         // This is a spurious allocation (relaxLocality \u003d false\n         // resulted in the Container being allocated on an NM on the same host\n         // but not on the NM running the container to be updated. Can\n         // happen if more than one NM exists on the same host.. usually\n         // occurs when using MiniYARNCluster to test).\n         tempContainerToKill.add(rmContainer);\n       } else {\n-        newlyPromotedContainers.put(matchedContainerId, rmContainer);\n+        RMContainer existingContainer \u003d getRMContainer(matchedContainerId);\n+        // If this container was already GUARANTEED, then it is an\n+        // increase, else its a promotion\n+        if (existingContainer \u003d\u003d null ||\n+            EnumSet.of(RMContainerState.COMPLETED, RMContainerState.KILLED,\n+                RMContainerState.EXPIRED, RMContainerState.RELEASED).contains(\n+                    existingContainer.getState())) {\n+          tempContainerToKill.add(rmContainer);\n+        } else {\n+          if (ExecutionType.GUARANTEED \u003d\u003d existingContainer.getExecutionType()) {\n+            newlyIncreasedContainers.put(matchedContainerId, rmContainer);\n+          } else {\n+            newlyPromotedContainers.put(matchedContainerId, rmContainer);\n+          }\n+        }\n       }\n     } else {\n       newlyAllocatedContainers.add(rmContainer);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addToNewlyAllocatedContainers(\n      SchedulerNode node, RMContainer rmContainer) {\n    ContainerId matchedContainerId \u003d\n        getUpdateContext().matchContainerToOutstandingIncreaseReq(\n            node, rmContainer.getAllocatedSchedulerKey(), rmContainer);\n    if (matchedContainerId !\u003d null) {\n      if (ContainerUpdateContext.UNDEFINED \u003d\u003d matchedContainerId) {\n        // This is a spurious allocation (relaxLocality \u003d false\n        // resulted in the Container being allocated on an NM on the same host\n        // but not on the NM running the container to be updated. Can\n        // happen if more than one NM exists on the same host.. usually\n        // occurs when using MiniYARNCluster to test).\n        tempContainerToKill.add(rmContainer);\n      } else {\n        RMContainer existingContainer \u003d getRMContainer(matchedContainerId);\n        // If this container was already GUARANTEED, then it is an\n        // increase, else its a promotion\n        if (existingContainer \u003d\u003d null ||\n            EnumSet.of(RMContainerState.COMPLETED, RMContainerState.KILLED,\n                RMContainerState.EXPIRED, RMContainerState.RELEASED).contains(\n                    existingContainer.getState())) {\n          tempContainerToKill.add(rmContainer);\n        } else {\n          if (ExecutionType.GUARANTEED \u003d\u003d existingContainer.getExecutionType()) {\n            newlyIncreasedContainers.put(matchedContainerId, rmContainer);\n          } else {\n            newlyPromotedContainers.put(matchedContainerId, rmContainer);\n          }\n        }\n      }\n    } else {\n      newlyAllocatedContainers.add(rmContainer);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java",
      "extendedDetails": {}
    },
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5959. RM changes to support change of container ExecutionType. (Arun Suresh via wangda)\n",
      "commitDate": "05/01/17 10:31 AM",
      "commitName": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,24 @@\n+  protected synchronized void addToNewlyAllocatedContainers(\n+      SchedulerNode node, RMContainer rmContainer) {\n+    if (oppContainerContext \u003d\u003d null) {\n+      newlyAllocatedContainers.add(rmContainer);\n+      return;\n+    }\n+    ContainerId matchedContainerId \u003d\n+        getUpdateContext().matchContainerToOutstandingIncreaseReq(\n+            node, rmContainer.getAllocatedSchedulerKey(), rmContainer);\n+    if (matchedContainerId !\u003d null) {\n+      if (ContainerUpdateContext.UNDEFINED \u003d\u003d matchedContainerId) {\n+        // This is a spurious allocation (relaxLocality \u003d false\n+        // resulted in the Container being allocated on an NM on the same host\n+        // but not on the NM running the container to be updated. Can\n+        // happen if more than one NM exists on the same host.. usually\n+        // occurs when using MiniYARNCluster to test).\n+        tempContainerToKill.add(rmContainer);\n+      } else {\n+        newlyPromotedContainers.put(matchedContainerId, rmContainer);\n+      }\n+    } else {\n+      newlyAllocatedContainers.add(rmContainer);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void addToNewlyAllocatedContainers(\n      SchedulerNode node, RMContainer rmContainer) {\n    if (oppContainerContext \u003d\u003d null) {\n      newlyAllocatedContainers.add(rmContainer);\n      return;\n    }\n    ContainerId matchedContainerId \u003d\n        getUpdateContext().matchContainerToOutstandingIncreaseReq(\n            node, rmContainer.getAllocatedSchedulerKey(), rmContainer);\n    if (matchedContainerId !\u003d null) {\n      if (ContainerUpdateContext.UNDEFINED \u003d\u003d matchedContainerId) {\n        // This is a spurious allocation (relaxLocality \u003d false\n        // resulted in the Container being allocated on an NM on the same host\n        // but not on the NM running the container to be updated. Can\n        // happen if more than one NM exists on the same host.. usually\n        // occurs when using MiniYARNCluster to test).\n        tempContainerToKill.add(rmContainer);\n      } else {\n        newlyPromotedContainers.put(matchedContainerId, rmContainer);\n      }\n    } else {\n      newlyAllocatedContainers.add(rmContainer);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApplicationAttempt.java"
    }
  }
}