{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "MapTask.java",
  "functionName": "collect",
  "functionId": "collect___key-K__value-V__partition-int(modifiers-final)",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/MapTask.java",
  "functionStartLine": 1082,
  "functionEndLine": 1201,
  "numCommitsSeen": 36,
  "timeTaken": 9402,
  "changeHistory": [
    "cae55de2cd1f9ea068f3410c8bdea14cf55738cb",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "cae55de2cd1f9ea068f3410c8bdea14cf55738cb": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Ymovefromfile",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cae55de2cd1f9ea068f3410c8bdea14cf55738cb": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5462. In map-side sort, swap entire meta entries instead of indexes for better cache performance. (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1514608 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/08/13 1:11 AM",
      "commitName": "cae55de2cd1f9ea068f3410c8bdea14cf55738cb",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "05/08/13 11:36 PM",
      "commitNameOld": "0cb2fdc3b4fbbaa6153b6421a63082dc006f8eb4",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 10.07,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,120 @@\n     public synchronized void collect(K key, V value, final int partition\n                                      ) throws IOException {\n       reporter.progress();\n       if (key.getClass() !\u003d keyClass) {\n         throw new IOException(\"Type mismatch in key from map: expected \"\n                               + keyClass.getName() + \", received \"\n                               + key.getClass().getName());\n       }\n       if (value.getClass() !\u003d valClass) {\n         throw new IOException(\"Type mismatch in value from map: expected \"\n                               + valClass.getName() + \", received \"\n                               + value.getClass().getName());\n       }\n       if (partition \u003c 0 || partition \u003e\u003d partitions) {\n         throw new IOException(\"Illegal partition for \" + key + \" (\" +\n             partition + \")\");\n       }\n       checkSpillException();\n       bufferRemaining -\u003d METASIZE;\n       if (bufferRemaining \u003c\u003d 0) {\n         // start spill if the thread is not running and the soft limit has been\n         // reached\n         spillLock.lock();\n         try {\n           do {\n             if (!spillInProgress) {\n               final int kvbidx \u003d 4 * kvindex;\n               final int kvbend \u003d 4 * kvend;\n               // serialized, unspilled bytes always lie between kvindex and\n               // bufindex, crossing the equator. Note that any void space\n               // created by a reset must be included in \"used\" bytes\n               final int bUsed \u003d distanceTo(kvbidx, bufindex);\n               final boolean bufsoftlimit \u003d bUsed \u003e\u003d softLimit;\n               if ((kvbend + METASIZE) % kvbuffer.length !\u003d\n                   equator - (equator % METASIZE)) {\n                 // spill finished, reclaim space\n                 resetSpill();\n                 bufferRemaining \u003d Math.min(\n                     distanceTo(bufindex, kvbidx) - 2 * METASIZE,\n                     softLimit - bUsed) - METASIZE;\n                 continue;\n               } else if (bufsoftlimit \u0026\u0026 kvindex !\u003d kvend) {\n                 // spill records, if any collected; check latter, as it may\n                 // be possible for metadata alignment to hit spill pcnt\n                 startSpill();\n                 final int avgRec \u003d (int)\n                   (mapOutputByteCounter.getCounter() /\n                   mapOutputRecordCounter.getCounter());\n                 // leave at least half the split buffer for serialization data\n                 // ensure that kvindex \u003e\u003d bufindex\n                 final int distkvi \u003d distanceTo(bufindex, kvbidx);\n                 final int newPos \u003d (bufindex +\n                   Math.max(2 * METASIZE - 1,\n                           Math.min(distkvi / 2,\n                                    distkvi / (METASIZE + avgRec) * METASIZE)))\n                   % kvbuffer.length;\n                 setEquator(newPos);\n                 bufmark \u003d bufindex \u003d newPos;\n                 final int serBound \u003d 4 * kvend;\n                 // bytes remaining before the lock must be held and limits\n                 // checked is the minimum of three arcs: the metadata space, the\n                 // serialization space, and the soft limit\n                 bufferRemaining \u003d Math.min(\n                     // metadata max\n                     distanceTo(bufend, newPos),\n                     Math.min(\n                       // serialization max\n                       distanceTo(newPos, serBound),\n                       // soft limit\n                       softLimit)) - 2 * METASIZE;\n               }\n             }\n           } while (false);\n         } finally {\n           spillLock.unlock();\n         }\n       }\n \n       try {\n         // serialize key bytes into buffer\n         int keystart \u003d bufindex;\n         keySerializer.serialize(key);\n         if (bufindex \u003c keystart) {\n           // wrapped the key; must make contiguous\n           bb.shiftBufferedKey();\n           keystart \u003d 0;\n         }\n         // serialize value bytes into buffer\n         final int valstart \u003d bufindex;\n         valSerializer.serialize(value);\n         // It\u0027s possible for records to have zero length, i.e. the serializer\n         // will perform no writes. To ensure that the boundary conditions are\n         // checked and that the kvindex invariant is maintained, perform a\n         // zero-length write into the buffer. The logic monitoring this could be\n         // moved into collect, but this is cleaner and inexpensive. For now, it\n         // is acceptable.\n         bb.write(b0, 0, 0);\n \n         // the record must be marked after the preceding write, as the metadata\n         // for this record are not yet written\n         int valend \u003d bb.markRecord();\n \n         mapOutputRecordCounter.increment(1);\n         mapOutputByteCounter.increment(\n             distanceTo(keystart, valend, bufvoid));\n \n         // write accounting info\n-        kvmeta.put(kvindex + INDEX, kvindex);\n         kvmeta.put(kvindex + PARTITION, partition);\n         kvmeta.put(kvindex + KEYSTART, keystart);\n         kvmeta.put(kvindex + VALSTART, valstart);\n+        kvmeta.put(kvindex + VALLEN, distanceTo(valstart, valend));\n         // advance kvindex\n         kvindex \u003d (kvindex - NMETA + kvmeta.capacity()) % kvmeta.capacity();\n       } catch (MapBufferTooSmallException e) {\n         LOG.info(\"Record too large for in-memory buffer: \" + e.getMessage());\n         spillSingleRecord(key, value, partition);\n         mapOutputRecordCounter.increment(1);\n         return;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public synchronized void collect(K key, V value, final int partition\n                                     ) throws IOException {\n      reporter.progress();\n      if (key.getClass() !\u003d keyClass) {\n        throw new IOException(\"Type mismatch in key from map: expected \"\n                              + keyClass.getName() + \", received \"\n                              + key.getClass().getName());\n      }\n      if (value.getClass() !\u003d valClass) {\n        throw new IOException(\"Type mismatch in value from map: expected \"\n                              + valClass.getName() + \", received \"\n                              + value.getClass().getName());\n      }\n      if (partition \u003c 0 || partition \u003e\u003d partitions) {\n        throw new IOException(\"Illegal partition for \" + key + \" (\" +\n            partition + \")\");\n      }\n      checkSpillException();\n      bufferRemaining -\u003d METASIZE;\n      if (bufferRemaining \u003c\u003d 0) {\n        // start spill if the thread is not running and the soft limit has been\n        // reached\n        spillLock.lock();\n        try {\n          do {\n            if (!spillInProgress) {\n              final int kvbidx \u003d 4 * kvindex;\n              final int kvbend \u003d 4 * kvend;\n              // serialized, unspilled bytes always lie between kvindex and\n              // bufindex, crossing the equator. Note that any void space\n              // created by a reset must be included in \"used\" bytes\n              final int bUsed \u003d distanceTo(kvbidx, bufindex);\n              final boolean bufsoftlimit \u003d bUsed \u003e\u003d softLimit;\n              if ((kvbend + METASIZE) % kvbuffer.length !\u003d\n                  equator - (equator % METASIZE)) {\n                // spill finished, reclaim space\n                resetSpill();\n                bufferRemaining \u003d Math.min(\n                    distanceTo(bufindex, kvbidx) - 2 * METASIZE,\n                    softLimit - bUsed) - METASIZE;\n                continue;\n              } else if (bufsoftlimit \u0026\u0026 kvindex !\u003d kvend) {\n                // spill records, if any collected; check latter, as it may\n                // be possible for metadata alignment to hit spill pcnt\n                startSpill();\n                final int avgRec \u003d (int)\n                  (mapOutputByteCounter.getCounter() /\n                  mapOutputRecordCounter.getCounter());\n                // leave at least half the split buffer for serialization data\n                // ensure that kvindex \u003e\u003d bufindex\n                final int distkvi \u003d distanceTo(bufindex, kvbidx);\n                final int newPos \u003d (bufindex +\n                  Math.max(2 * METASIZE - 1,\n                          Math.min(distkvi / 2,\n                                   distkvi / (METASIZE + avgRec) * METASIZE)))\n                  % kvbuffer.length;\n                setEquator(newPos);\n                bufmark \u003d bufindex \u003d newPos;\n                final int serBound \u003d 4 * kvend;\n                // bytes remaining before the lock must be held and limits\n                // checked is the minimum of three arcs: the metadata space, the\n                // serialization space, and the soft limit\n                bufferRemaining \u003d Math.min(\n                    // metadata max\n                    distanceTo(bufend, newPos),\n                    Math.min(\n                      // serialization max\n                      distanceTo(newPos, serBound),\n                      // soft limit\n                      softLimit)) - 2 * METASIZE;\n              }\n            }\n          } while (false);\n        } finally {\n          spillLock.unlock();\n        }\n      }\n\n      try {\n        // serialize key bytes into buffer\n        int keystart \u003d bufindex;\n        keySerializer.serialize(key);\n        if (bufindex \u003c keystart) {\n          // wrapped the key; must make contiguous\n          bb.shiftBufferedKey();\n          keystart \u003d 0;\n        }\n        // serialize value bytes into buffer\n        final int valstart \u003d bufindex;\n        valSerializer.serialize(value);\n        // It\u0027s possible for records to have zero length, i.e. the serializer\n        // will perform no writes. To ensure that the boundary conditions are\n        // checked and that the kvindex invariant is maintained, perform a\n        // zero-length write into the buffer. The logic monitoring this could be\n        // moved into collect, but this is cleaner and inexpensive. For now, it\n        // is acceptable.\n        bb.write(b0, 0, 0);\n\n        // the record must be marked after the preceding write, as the metadata\n        // for this record are not yet written\n        int valend \u003d bb.markRecord();\n\n        mapOutputRecordCounter.increment(1);\n        mapOutputByteCounter.increment(\n            distanceTo(keystart, valend, bufvoid));\n\n        // write accounting info\n        kvmeta.put(kvindex + PARTITION, partition);\n        kvmeta.put(kvindex + KEYSTART, keystart);\n        kvmeta.put(kvindex + VALSTART, valstart);\n        kvmeta.put(kvindex + VALLEN, distanceTo(valstart, valend));\n        // advance kvindex\n        kvindex \u003d (kvindex - NMETA + kvmeta.capacity()) % kvmeta.capacity();\n      } catch (MapBufferTooSmallException e) {\n        LOG.info(\"Record too large for in-memory buffer: \" + e.getMessage());\n        spillSingleRecord(key, value, partition);\n        mapOutputRecordCounter.increment(1);\n        return;\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/MapTask.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public synchronized void collect(K key, V value, final int partition\n                                     ) throws IOException {\n      reporter.progress();\n      if (key.getClass() !\u003d keyClass) {\n        throw new IOException(\"Type mismatch in key from map: expected \"\n                              + keyClass.getName() + \", received \"\n                              + key.getClass().getName());\n      }\n      if (value.getClass() !\u003d valClass) {\n        throw new IOException(\"Type mismatch in value from map: expected \"\n                              + valClass.getName() + \", received \"\n                              + value.getClass().getName());\n      }\n      if (partition \u003c 0 || partition \u003e\u003d partitions) {\n        throw new IOException(\"Illegal partition for \" + key + \" (\" +\n            partition + \")\");\n      }\n      checkSpillException();\n      bufferRemaining -\u003d METASIZE;\n      if (bufferRemaining \u003c\u003d 0) {\n        // start spill if the thread is not running and the soft limit has been\n        // reached\n        spillLock.lock();\n        try {\n          do {\n            if (!spillInProgress) {\n              final int kvbidx \u003d 4 * kvindex;\n              final int kvbend \u003d 4 * kvend;\n              // serialized, unspilled bytes always lie between kvindex and\n              // bufindex, crossing the equator. Note that any void space\n              // created by a reset must be included in \"used\" bytes\n              final int bUsed \u003d distanceTo(kvbidx, bufindex);\n              final boolean bufsoftlimit \u003d bUsed \u003e\u003d softLimit;\n              if ((kvbend + METASIZE) % kvbuffer.length !\u003d\n                  equator - (equator % METASIZE)) {\n                // spill finished, reclaim space\n                resetSpill();\n                bufferRemaining \u003d Math.min(\n                    distanceTo(bufindex, kvbidx) - 2 * METASIZE,\n                    softLimit - bUsed) - METASIZE;\n                continue;\n              } else if (bufsoftlimit \u0026\u0026 kvindex !\u003d kvend) {\n                // spill records, if any collected; check latter, as it may\n                // be possible for metadata alignment to hit spill pcnt\n                startSpill();\n                final int avgRec \u003d (int)\n                  (mapOutputByteCounter.getCounter() /\n                  mapOutputRecordCounter.getCounter());\n                // leave at least half the split buffer for serialization data\n                // ensure that kvindex \u003e\u003d bufindex\n                final int distkvi \u003d distanceTo(bufindex, kvbidx);\n                final int newPos \u003d (bufindex +\n                  Math.max(2 * METASIZE - 1,\n                          Math.min(distkvi / 2,\n                                   distkvi / (METASIZE + avgRec) * METASIZE)))\n                  % kvbuffer.length;\n                setEquator(newPos);\n                bufmark \u003d bufindex \u003d newPos;\n                final int serBound \u003d 4 * kvend;\n                // bytes remaining before the lock must be held and limits\n                // checked is the minimum of three arcs: the metadata space, the\n                // serialization space, and the soft limit\n                bufferRemaining \u003d Math.min(\n                    // metadata max\n                    distanceTo(bufend, newPos),\n                    Math.min(\n                      // serialization max\n                      distanceTo(newPos, serBound),\n                      // soft limit\n                      softLimit)) - 2 * METASIZE;\n              }\n            }\n          } while (false);\n        } finally {\n          spillLock.unlock();\n        }\n      }\n\n      try {\n        // serialize key bytes into buffer\n        int keystart \u003d bufindex;\n        keySerializer.serialize(key);\n        if (bufindex \u003c keystart) {\n          // wrapped the key; must make contiguous\n          bb.shiftBufferedKey();\n          keystart \u003d 0;\n        }\n        // serialize value bytes into buffer\n        final int valstart \u003d bufindex;\n        valSerializer.serialize(value);\n        // It\u0027s possible for records to have zero length, i.e. the serializer\n        // will perform no writes. To ensure that the boundary conditions are\n        // checked and that the kvindex invariant is maintained, perform a\n        // zero-length write into the buffer. The logic monitoring this could be\n        // moved into collect, but this is cleaner and inexpensive. For now, it\n        // is acceptable.\n        bb.write(b0, 0, 0);\n\n        // the record must be marked after the preceding write, as the metadata\n        // for this record are not yet written\n        int valend \u003d bb.markRecord();\n\n        mapOutputRecordCounter.increment(1);\n        mapOutputByteCounter.increment(\n            distanceTo(keystart, valend, bufvoid));\n\n        // write accounting info\n        kvmeta.put(kvindex + INDEX, kvindex);\n        kvmeta.put(kvindex + PARTITION, partition);\n        kvmeta.put(kvindex + KEYSTART, keystart);\n        kvmeta.put(kvindex + VALSTART, valstart);\n        // advance kvindex\n        kvindex \u003d (kvindex - NMETA + kvmeta.capacity()) % kvmeta.capacity();\n      } catch (MapBufferTooSmallException e) {\n        LOG.info(\"Record too large for in-memory buffer: \" + e.getMessage());\n        spillSingleRecord(key, value, partition);\n        mapOutputRecordCounter.increment(1);\n        return;\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/MapTask.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/MapTask.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/MapTask.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Ymovefromfile",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/08/11 8:02 PM",
      "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public synchronized void collect(K key, V value, final int partition\n                                     ) throws IOException {\n      reporter.progress();\n      if (key.getClass() !\u003d keyClass) {\n        throw new IOException(\"Type mismatch in key from map: expected \"\n                              + keyClass.getName() + \", received \"\n                              + key.getClass().getName());\n      }\n      if (value.getClass() !\u003d valClass) {\n        throw new IOException(\"Type mismatch in value from map: expected \"\n                              + valClass.getName() + \", received \"\n                              + value.getClass().getName());\n      }\n      if (partition \u003c 0 || partition \u003e\u003d partitions) {\n        throw new IOException(\"Illegal partition for \" + key + \" (\" +\n            partition + \")\");\n      }\n      checkSpillException();\n      bufferRemaining -\u003d METASIZE;\n      if (bufferRemaining \u003c\u003d 0) {\n        // start spill if the thread is not running and the soft limit has been\n        // reached\n        spillLock.lock();\n        try {\n          do {\n            if (!spillInProgress) {\n              final int kvbidx \u003d 4 * kvindex;\n              final int kvbend \u003d 4 * kvend;\n              // serialized, unspilled bytes always lie between kvindex and\n              // bufindex, crossing the equator. Note that any void space\n              // created by a reset must be included in \"used\" bytes\n              final int bUsed \u003d distanceTo(kvbidx, bufindex);\n              final boolean bufsoftlimit \u003d bUsed \u003e\u003d softLimit;\n              if ((kvbend + METASIZE) % kvbuffer.length !\u003d\n                  equator - (equator % METASIZE)) {\n                // spill finished, reclaim space\n                resetSpill();\n                bufferRemaining \u003d Math.min(\n                    distanceTo(bufindex, kvbidx) - 2 * METASIZE,\n                    softLimit - bUsed) - METASIZE;\n                continue;\n              } else if (bufsoftlimit \u0026\u0026 kvindex !\u003d kvend) {\n                // spill records, if any collected; check latter, as it may\n                // be possible for metadata alignment to hit spill pcnt\n                startSpill();\n                final int avgRec \u003d (int)\n                  (mapOutputByteCounter.getCounter() /\n                  mapOutputRecordCounter.getCounter());\n                // leave at least half the split buffer for serialization data\n                // ensure that kvindex \u003e\u003d bufindex\n                final int distkvi \u003d distanceTo(bufindex, kvbidx);\n                final int newPos \u003d (bufindex +\n                  Math.max(2 * METASIZE - 1,\n                          Math.min(distkvi / 2,\n                                   distkvi / (METASIZE + avgRec) * METASIZE)))\n                  % kvbuffer.length;\n                setEquator(newPos);\n                bufmark \u003d bufindex \u003d newPos;\n                final int serBound \u003d 4 * kvend;\n                // bytes remaining before the lock must be held and limits\n                // checked is the minimum of three arcs: the metadata space, the\n                // serialization space, and the soft limit\n                bufferRemaining \u003d Math.min(\n                    // metadata max\n                    distanceTo(bufend, newPos),\n                    Math.min(\n                      // serialization max\n                      distanceTo(newPos, serBound),\n                      // soft limit\n                      softLimit)) - 2 * METASIZE;\n              }\n            }\n          } while (false);\n        } finally {\n          spillLock.unlock();\n        }\n      }\n\n      try {\n        // serialize key bytes into buffer\n        int keystart \u003d bufindex;\n        keySerializer.serialize(key);\n        if (bufindex \u003c keystart) {\n          // wrapped the key; must make contiguous\n          bb.shiftBufferedKey();\n          keystart \u003d 0;\n        }\n        // serialize value bytes into buffer\n        final int valstart \u003d bufindex;\n        valSerializer.serialize(value);\n        // It\u0027s possible for records to have zero length, i.e. the serializer\n        // will perform no writes. To ensure that the boundary conditions are\n        // checked and that the kvindex invariant is maintained, perform a\n        // zero-length write into the buffer. The logic monitoring this could be\n        // moved into collect, but this is cleaner and inexpensive. For now, it\n        // is acceptable.\n        bb.write(b0, 0, 0);\n\n        // the record must be marked after the preceding write, as the metadata\n        // for this record are not yet written\n        int valend \u003d bb.markRecord();\n\n        mapOutputRecordCounter.increment(1);\n        mapOutputByteCounter.increment(\n            distanceTo(keystart, valend, bufvoid));\n\n        // write accounting info\n        kvmeta.put(kvindex + INDEX, kvindex);\n        kvmeta.put(kvindex + PARTITION, partition);\n        kvmeta.put(kvindex + KEYSTART, keystart);\n        kvmeta.put(kvindex + VALSTART, valstart);\n        // advance kvindex\n        kvindex \u003d (kvindex - NMETA + kvmeta.capacity()) % kvmeta.capacity();\n      } catch (MapBufferTooSmallException e) {\n        LOG.info(\"Record too large for in-memory buffer: \" + e.getMessage());\n        spillSingleRecord(key, value, partition);\n        mapOutputRecordCounter.increment(1);\n        return;\n      }\n    }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/MapTask.java",
      "extendedDetails": {
        "oldPath": "mapreduce/src/java/org/apache/hadoop/mapred/MapTask.java",
        "newPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapred/MapTask.java",
        "oldMethodName": "collect",
        "newMethodName": "collect"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,120 @@\n+    public synchronized void collect(K key, V value, final int partition\n+                                     ) throws IOException {\n+      reporter.progress();\n+      if (key.getClass() !\u003d keyClass) {\n+        throw new IOException(\"Type mismatch in key from map: expected \"\n+                              + keyClass.getName() + \", received \"\n+                              + key.getClass().getName());\n+      }\n+      if (value.getClass() !\u003d valClass) {\n+        throw new IOException(\"Type mismatch in value from map: expected \"\n+                              + valClass.getName() + \", received \"\n+                              + value.getClass().getName());\n+      }\n+      if (partition \u003c 0 || partition \u003e\u003d partitions) {\n+        throw new IOException(\"Illegal partition for \" + key + \" (\" +\n+            partition + \")\");\n+      }\n+      checkSpillException();\n+      bufferRemaining -\u003d METASIZE;\n+      if (bufferRemaining \u003c\u003d 0) {\n+        // start spill if the thread is not running and the soft limit has been\n+        // reached\n+        spillLock.lock();\n+        try {\n+          do {\n+            if (!spillInProgress) {\n+              final int kvbidx \u003d 4 * kvindex;\n+              final int kvbend \u003d 4 * kvend;\n+              // serialized, unspilled bytes always lie between kvindex and\n+              // bufindex, crossing the equator. Note that any void space\n+              // created by a reset must be included in \"used\" bytes\n+              final int bUsed \u003d distanceTo(kvbidx, bufindex);\n+              final boolean bufsoftlimit \u003d bUsed \u003e\u003d softLimit;\n+              if ((kvbend + METASIZE) % kvbuffer.length !\u003d\n+                  equator - (equator % METASIZE)) {\n+                // spill finished, reclaim space\n+                resetSpill();\n+                bufferRemaining \u003d Math.min(\n+                    distanceTo(bufindex, kvbidx) - 2 * METASIZE,\n+                    softLimit - bUsed) - METASIZE;\n+                continue;\n+              } else if (bufsoftlimit \u0026\u0026 kvindex !\u003d kvend) {\n+                // spill records, if any collected; check latter, as it may\n+                // be possible for metadata alignment to hit spill pcnt\n+                startSpill();\n+                final int avgRec \u003d (int)\n+                  (mapOutputByteCounter.getCounter() /\n+                  mapOutputRecordCounter.getCounter());\n+                // leave at least half the split buffer for serialization data\n+                // ensure that kvindex \u003e\u003d bufindex\n+                final int distkvi \u003d distanceTo(bufindex, kvbidx);\n+                final int newPos \u003d (bufindex +\n+                  Math.max(2 * METASIZE - 1,\n+                          Math.min(distkvi / 2,\n+                                   distkvi / (METASIZE + avgRec) * METASIZE)))\n+                  % kvbuffer.length;\n+                setEquator(newPos);\n+                bufmark \u003d bufindex \u003d newPos;\n+                final int serBound \u003d 4 * kvend;\n+                // bytes remaining before the lock must be held and limits\n+                // checked is the minimum of three arcs: the metadata space, the\n+                // serialization space, and the soft limit\n+                bufferRemaining \u003d Math.min(\n+                    // metadata max\n+                    distanceTo(bufend, newPos),\n+                    Math.min(\n+                      // serialization max\n+                      distanceTo(newPos, serBound),\n+                      // soft limit\n+                      softLimit)) - 2 * METASIZE;\n+              }\n+            }\n+          } while (false);\n+        } finally {\n+          spillLock.unlock();\n+        }\n+      }\n+\n+      try {\n+        // serialize key bytes into buffer\n+        int keystart \u003d bufindex;\n+        keySerializer.serialize(key);\n+        if (bufindex \u003c keystart) {\n+          // wrapped the key; must make contiguous\n+          bb.shiftBufferedKey();\n+          keystart \u003d 0;\n+        }\n+        // serialize value bytes into buffer\n+        final int valstart \u003d bufindex;\n+        valSerializer.serialize(value);\n+        // It\u0027s possible for records to have zero length, i.e. the serializer\n+        // will perform no writes. To ensure that the boundary conditions are\n+        // checked and that the kvindex invariant is maintained, perform a\n+        // zero-length write into the buffer. The logic monitoring this could be\n+        // moved into collect, but this is cleaner and inexpensive. For now, it\n+        // is acceptable.\n+        bb.write(b0, 0, 0);\n+\n+        // the record must be marked after the preceding write, as the metadata\n+        // for this record are not yet written\n+        int valend \u003d bb.markRecord();\n+\n+        mapOutputRecordCounter.increment(1);\n+        mapOutputByteCounter.increment(\n+            distanceTo(keystart, valend, bufvoid));\n+\n+        // write accounting info\n+        kvmeta.put(kvindex + INDEX, kvindex);\n+        kvmeta.put(kvindex + PARTITION, partition);\n+        kvmeta.put(kvindex + KEYSTART, keystart);\n+        kvmeta.put(kvindex + VALSTART, valstart);\n+        // advance kvindex\n+        kvindex \u003d (kvindex - NMETA + kvmeta.capacity()) % kvmeta.capacity();\n+      } catch (MapBufferTooSmallException e) {\n+        LOG.info(\"Record too large for in-memory buffer: \" + e.getMessage());\n+        spillSingleRecord(key, value, partition);\n+        mapOutputRecordCounter.increment(1);\n+        return;\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public synchronized void collect(K key, V value, final int partition\n                                     ) throws IOException {\n      reporter.progress();\n      if (key.getClass() !\u003d keyClass) {\n        throw new IOException(\"Type mismatch in key from map: expected \"\n                              + keyClass.getName() + \", received \"\n                              + key.getClass().getName());\n      }\n      if (value.getClass() !\u003d valClass) {\n        throw new IOException(\"Type mismatch in value from map: expected \"\n                              + valClass.getName() + \", received \"\n                              + value.getClass().getName());\n      }\n      if (partition \u003c 0 || partition \u003e\u003d partitions) {\n        throw new IOException(\"Illegal partition for \" + key + \" (\" +\n            partition + \")\");\n      }\n      checkSpillException();\n      bufferRemaining -\u003d METASIZE;\n      if (bufferRemaining \u003c\u003d 0) {\n        // start spill if the thread is not running and the soft limit has been\n        // reached\n        spillLock.lock();\n        try {\n          do {\n            if (!spillInProgress) {\n              final int kvbidx \u003d 4 * kvindex;\n              final int kvbend \u003d 4 * kvend;\n              // serialized, unspilled bytes always lie between kvindex and\n              // bufindex, crossing the equator. Note that any void space\n              // created by a reset must be included in \"used\" bytes\n              final int bUsed \u003d distanceTo(kvbidx, bufindex);\n              final boolean bufsoftlimit \u003d bUsed \u003e\u003d softLimit;\n              if ((kvbend + METASIZE) % kvbuffer.length !\u003d\n                  equator - (equator % METASIZE)) {\n                // spill finished, reclaim space\n                resetSpill();\n                bufferRemaining \u003d Math.min(\n                    distanceTo(bufindex, kvbidx) - 2 * METASIZE,\n                    softLimit - bUsed) - METASIZE;\n                continue;\n              } else if (bufsoftlimit \u0026\u0026 kvindex !\u003d kvend) {\n                // spill records, if any collected; check latter, as it may\n                // be possible for metadata alignment to hit spill pcnt\n                startSpill();\n                final int avgRec \u003d (int)\n                  (mapOutputByteCounter.getCounter() /\n                  mapOutputRecordCounter.getCounter());\n                // leave at least half the split buffer for serialization data\n                // ensure that kvindex \u003e\u003d bufindex\n                final int distkvi \u003d distanceTo(bufindex, kvbidx);\n                final int newPos \u003d (bufindex +\n                  Math.max(2 * METASIZE - 1,\n                          Math.min(distkvi / 2,\n                                   distkvi / (METASIZE + avgRec) * METASIZE)))\n                  % kvbuffer.length;\n                setEquator(newPos);\n                bufmark \u003d bufindex \u003d newPos;\n                final int serBound \u003d 4 * kvend;\n                // bytes remaining before the lock must be held and limits\n                // checked is the minimum of three arcs: the metadata space, the\n                // serialization space, and the soft limit\n                bufferRemaining \u003d Math.min(\n                    // metadata max\n                    distanceTo(bufend, newPos),\n                    Math.min(\n                      // serialization max\n                      distanceTo(newPos, serBound),\n                      // soft limit\n                      softLimit)) - 2 * METASIZE;\n              }\n            }\n          } while (false);\n        } finally {\n          spillLock.unlock();\n        }\n      }\n\n      try {\n        // serialize key bytes into buffer\n        int keystart \u003d bufindex;\n        keySerializer.serialize(key);\n        if (bufindex \u003c keystart) {\n          // wrapped the key; must make contiguous\n          bb.shiftBufferedKey();\n          keystart \u003d 0;\n        }\n        // serialize value bytes into buffer\n        final int valstart \u003d bufindex;\n        valSerializer.serialize(value);\n        // It\u0027s possible for records to have zero length, i.e. the serializer\n        // will perform no writes. To ensure that the boundary conditions are\n        // checked and that the kvindex invariant is maintained, perform a\n        // zero-length write into the buffer. The logic monitoring this could be\n        // moved into collect, but this is cleaner and inexpensive. For now, it\n        // is acceptable.\n        bb.write(b0, 0, 0);\n\n        // the record must be marked after the preceding write, as the metadata\n        // for this record are not yet written\n        int valend \u003d bb.markRecord();\n\n        mapOutputRecordCounter.increment(1);\n        mapOutputByteCounter.increment(\n            distanceTo(keystart, valend, bufvoid));\n\n        // write accounting info\n        kvmeta.put(kvindex + INDEX, kvindex);\n        kvmeta.put(kvindex + PARTITION, partition);\n        kvmeta.put(kvindex + KEYSTART, keystart);\n        kvmeta.put(kvindex + VALSTART, valstart);\n        // advance kvindex\n        kvindex \u003d (kvindex - NMETA + kvmeta.capacity()) % kvmeta.capacity();\n      } catch (MapBufferTooSmallException e) {\n        LOG.info(\"Record too large for in-memory buffer: \" + e.getMessage());\n        spillSingleRecord(key, value, partition);\n        mapOutputRecordCounter.increment(1);\n        return;\n      }\n    }",
      "path": "mapreduce/src/java/org/apache/hadoop/mapred/MapTask.java"
    }
  }
}