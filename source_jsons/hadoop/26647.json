{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JobImpl.java",
  "functionName": "makeUberDecision",
  "functionId": "makeUberDecision___dataInputLength-long",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/JobImpl.java",
  "functionStartLine": 1216,
  "functionEndLine": 1314,
  "numCommitsSeen": 94,
  "timeTaken": 3781,
  "changeHistory": [
    "cf74772064de0ce7cefd541e3f407442f4f0e281",
    "45efc966ee1a1bda0271464dcee2564862d53b1f",
    "4b2ded8202f9d07ba44066650dc4e5c987cbbacc",
    "3d95049f79fe7edb92dd6d20c3a60ccdc46c4b0e",
    "dd6aa0cf124786e473bf373bc5e0957e50fc9b5d",
    "2c5c8fdb80546467274607b26a1295b352c58fc8",
    "80ab78c21728e9979e892283e9e0caf6ab3b0fef",
    "e3806060ce01557ba75094665b032dcca5656a19",
    "2f19c59f1d6f74a2f881aaa57344d556d7b3eb3c",
    "b7ae5a6cb7b2d3e3112ac53007e984caeb07de58"
  ],
  "changeHistoryShort": {
    "cf74772064de0ce7cefd541e3f407442f4f0e281": "Ybodychange",
    "45efc966ee1a1bda0271464dcee2564862d53b1f": "Ybodychange",
    "4b2ded8202f9d07ba44066650dc4e5c987cbbacc": "Ybodychange",
    "3d95049f79fe7edb92dd6d20c3a60ccdc46c4b0e": "Ybodychange",
    "dd6aa0cf124786e473bf373bc5e0957e50fc9b5d": "Ybodychange",
    "2c5c8fdb80546467274607b26a1295b352c58fc8": "Ybodychange",
    "80ab78c21728e9979e892283e9e0caf6ab3b0fef": "Ybodychange",
    "e3806060ce01557ba75094665b032dcca5656a19": "Ybodychange",
    "2f19c59f1d6f74a2f881aaa57344d556d7b3eb3c": "Ybodychange",
    "b7ae5a6cb7b2d3e3112ac53007e984caeb07de58": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cf74772064de0ce7cefd541e3f407442f4f0e281": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5801. Uber mode\u0027s log message is missing a vcore reason  (Steven Wong via aw)\n",
      "commitDate": "21/07/15 10:58 AM",
      "commitName": "cf74772064de0ce7cefd541e3f407442f4f0e281",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "13/07/15 1:52 AM",
      "commitNameOld": "19295b36d90e26616accee73b1f7743aab5df692",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 8.38,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,99 @@\n   private void makeUberDecision(long dataInputLength) {\n     //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n     // until AM-resizing supported,\n     // must depend on job client to pass fat-slot needs)\n     // these are no longer \"system\" settings, necessarily; user may override\n     int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n \n     int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n \n     long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n         fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                    // [File?]InputFormat and default block size\n                                    // from that\n \n     long sysMemSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n             MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n \n     long sysCPUSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_CPU_VCORES,\n             MRJobConfig.DEFAULT_MR_AM_CPU_VCORES);\n \n     boolean uberEnabled \u003d\n         conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n     boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n     boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n     boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n     // ignoring overhead due to UberAM and statics as negligible here:\n     long requiredMapMB \u003d conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0);\n     long requiredReduceMB \u003d conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0);\n     long requiredMB \u003d Math.max(requiredMapMB, requiredReduceMB);\n     int requiredMapCores \u003d conf.getInt(\n             MRJobConfig.MAP_CPU_VCORES, \n             MRJobConfig.DEFAULT_MAP_CPU_VCORES);\n     int requiredReduceCores \u003d conf.getInt(\n             MRJobConfig.REDUCE_CPU_VCORES, \n             MRJobConfig.DEFAULT_REDUCE_CPU_VCORES);\n     int requiredCores \u003d Math.max(requiredMapCores, requiredReduceCores);    \n     if (numReduceTasks \u003d\u003d 0) {\n       requiredMB \u003d requiredMapMB;\n       requiredCores \u003d requiredMapCores;\n     }\n     boolean smallMemory \u003d\n         (requiredMB \u003c\u003d sysMemSizeForUberSlot)\n         || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT);\n     \n     boolean smallCpu \u003d requiredCores \u003c\u003d sysCPUSizeForUberSlot;\n     boolean notChainJob \u003d !isChainJob(conf);\n \n     // User has overall veto power over uberization, or user can modify\n     // limits (overriding system settings and potentially shooting\n     // themselves in the head).  Note that ChainMapper/Reducer are\n     // fundamentally incompatible with MR-1220; they employ a blocking\n     // queue between the maps/reduces and thus require parallel execution,\n     // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n     // and thus requires sequential execution.\n     isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n         \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 smallCpu \n         \u0026\u0026 notChainJob;\n \n     if (isUber) {\n       LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n           + numReduceTasks + \"r tasks (\" + dataInputLength\n           + \" input bytes) will run sequentially on single node.\");\n \n       // make sure reduces are scheduled only after all map are completed\n       conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                         1.0f);\n       // uber-subtask attempts all get launched on same node; if one fails,\n       // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n       // limit attempts to 1 (or at most 2?  probably not...)\n       conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n       conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n \n       // disable speculation\n       conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n       conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n     } else {\n       StringBuilder msg \u003d new StringBuilder();\n       msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n       if (!uberEnabled)\n         msg.append(\" not enabled;\");\n       if (!smallNumMapTasks)\n         msg.append(\" too many maps;\");\n       if (!smallNumReduceTasks)\n         msg.append(\" too many reduces;\");\n       if (!smallInput)\n         msg.append(\" too much input;\");\n       if (!smallCpu)\n         msg.append(\" too much CPU;\");\n       if (!smallMemory)\n         msg.append(\" too much RAM;\");\n+      if (!smallCpu)\n+          msg.append(\" too much CPU;\");\n       if (!notChainJob)\n         msg.append(\" chainjob;\");\n       LOG.info(msg.toString());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void makeUberDecision(long dataInputLength) {\n    //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n    // until AM-resizing supported,\n    // must depend on job client to pass fat-slot needs)\n    // these are no longer \"system\" settings, necessarily; user may override\n    int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n\n    int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n\n    long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n        fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                   // [File?]InputFormat and default block size\n                                   // from that\n\n    long sysMemSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n            MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n\n    long sysCPUSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_CPU_VCORES,\n            MRJobConfig.DEFAULT_MR_AM_CPU_VCORES);\n\n    boolean uberEnabled \u003d\n        conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n    boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n    boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n    boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n    // ignoring overhead due to UberAM and statics as negligible here:\n    long requiredMapMB \u003d conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0);\n    long requiredReduceMB \u003d conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0);\n    long requiredMB \u003d Math.max(requiredMapMB, requiredReduceMB);\n    int requiredMapCores \u003d conf.getInt(\n            MRJobConfig.MAP_CPU_VCORES, \n            MRJobConfig.DEFAULT_MAP_CPU_VCORES);\n    int requiredReduceCores \u003d conf.getInt(\n            MRJobConfig.REDUCE_CPU_VCORES, \n            MRJobConfig.DEFAULT_REDUCE_CPU_VCORES);\n    int requiredCores \u003d Math.max(requiredMapCores, requiredReduceCores);    \n    if (numReduceTasks \u003d\u003d 0) {\n      requiredMB \u003d requiredMapMB;\n      requiredCores \u003d requiredMapCores;\n    }\n    boolean smallMemory \u003d\n        (requiredMB \u003c\u003d sysMemSizeForUberSlot)\n        || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT);\n    \n    boolean smallCpu \u003d requiredCores \u003c\u003d sysCPUSizeForUberSlot;\n    boolean notChainJob \u003d !isChainJob(conf);\n\n    // User has overall veto power over uberization, or user can modify\n    // limits (overriding system settings and potentially shooting\n    // themselves in the head).  Note that ChainMapper/Reducer are\n    // fundamentally incompatible with MR-1220; they employ a blocking\n    // queue between the maps/reduces and thus require parallel execution,\n    // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n    // and thus requires sequential execution.\n    isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 smallCpu \n        \u0026\u0026 notChainJob;\n\n    if (isUber) {\n      LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n          + numReduceTasks + \"r tasks (\" + dataInputLength\n          + \" input bytes) will run sequentially on single node.\");\n\n      // make sure reduces are scheduled only after all map are completed\n      conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                        1.0f);\n      // uber-subtask attempts all get launched on same node; if one fails,\n      // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n      // limit attempts to 1 (or at most 2?  probably not...)\n      conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n      conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n\n      // disable speculation\n      conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n      conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n    } else {\n      StringBuilder msg \u003d new StringBuilder();\n      msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n      if (!uberEnabled)\n        msg.append(\" not enabled;\");\n      if (!smallNumMapTasks)\n        msg.append(\" too many maps;\");\n      if (!smallNumReduceTasks)\n        msg.append(\" too many reduces;\");\n      if (!smallInput)\n        msg.append(\" too much input;\");\n      if (!smallCpu)\n        msg.append(\" too much CPU;\");\n      if (!smallMemory)\n        msg.append(\" too much RAM;\");\n      if (!smallCpu)\n          msg.append(\" too much CPU;\");\n      if (!notChainJob)\n        msg.append(\" chainjob;\");\n      LOG.info(msg.toString());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/JobImpl.java",
      "extendedDetails": {}
    },
    "45efc966ee1a1bda0271464dcee2564862d53b1f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6071. JobImpl#makeUberDecision doesn\u0027t log that Uber mode is disabled because of too much CPUs. Contributed by Tsuyoshi OZAWA\n",
      "commitDate": "05/09/14 6:42 AM",
      "commitName": "45efc966ee1a1bda0271464dcee2564862d53b1f",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "18/08/14 10:57 AM",
      "commitNameOld": "f8e871d01b851cd5d8c57dd7e364b3e787521765",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 17.82,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,97 @@\n   private void makeUberDecision(long dataInputLength) {\n     //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n     // until AM-resizing supported,\n     // must depend on job client to pass fat-slot needs)\n     // these are no longer \"system\" settings, necessarily; user may override\n     int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n \n     int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n \n     long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n         fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                    // [File?]InputFormat and default block size\n                                    // from that\n \n     long sysMemSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n             MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n \n     long sysCPUSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_CPU_VCORES,\n             MRJobConfig.DEFAULT_MR_AM_CPU_VCORES);\n \n     boolean uberEnabled \u003d\n         conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n     boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n     boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n     boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n     // ignoring overhead due to UberAM and statics as negligible here:\n     long requiredMapMB \u003d conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0);\n     long requiredReduceMB \u003d conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0);\n     long requiredMB \u003d Math.max(requiredMapMB, requiredReduceMB);\n     int requiredMapCores \u003d conf.getInt(\n             MRJobConfig.MAP_CPU_VCORES, \n             MRJobConfig.DEFAULT_MAP_CPU_VCORES);\n     int requiredReduceCores \u003d conf.getInt(\n             MRJobConfig.REDUCE_CPU_VCORES, \n             MRJobConfig.DEFAULT_REDUCE_CPU_VCORES);\n     int requiredCores \u003d Math.max(requiredMapCores, requiredReduceCores);    \n     if (numReduceTasks \u003d\u003d 0) {\n       requiredMB \u003d requiredMapMB;\n       requiredCores \u003d requiredMapCores;\n     }\n     boolean smallMemory \u003d\n         (requiredMB \u003c\u003d sysMemSizeForUberSlot)\n         || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT);\n     \n     boolean smallCpu \u003d requiredCores \u003c\u003d sysCPUSizeForUberSlot;\n     boolean notChainJob \u003d !isChainJob(conf);\n \n     // User has overall veto power over uberization, or user can modify\n     // limits (overriding system settings and potentially shooting\n     // themselves in the head).  Note that ChainMapper/Reducer are\n     // fundamentally incompatible with MR-1220; they employ a blocking\n     // queue between the maps/reduces and thus require parallel execution,\n     // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n     // and thus requires sequential execution.\n     isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n         \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 smallCpu \n         \u0026\u0026 notChainJob;\n \n     if (isUber) {\n       LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n           + numReduceTasks + \"r tasks (\" + dataInputLength\n           + \" input bytes) will run sequentially on single node.\");\n \n       // make sure reduces are scheduled only after all map are completed\n       conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                         1.0f);\n       // uber-subtask attempts all get launched on same node; if one fails,\n       // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n       // limit attempts to 1 (or at most 2?  probably not...)\n       conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n       conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n \n       // disable speculation\n       conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n       conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n     } else {\n       StringBuilder msg \u003d new StringBuilder();\n       msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n       if (!uberEnabled)\n         msg.append(\" not enabled;\");\n       if (!smallNumMapTasks)\n         msg.append(\" too many maps;\");\n       if (!smallNumReduceTasks)\n         msg.append(\" too many reduces;\");\n       if (!smallInput)\n         msg.append(\" too much input;\");\n+      if (!smallCpu)\n+        msg.append(\" too much CPU;\");\n       if (!smallMemory)\n         msg.append(\" too much RAM;\");\n       if (!notChainJob)\n         msg.append(\" chainjob;\");\n       LOG.info(msg.toString());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void makeUberDecision(long dataInputLength) {\n    //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n    // until AM-resizing supported,\n    // must depend on job client to pass fat-slot needs)\n    // these are no longer \"system\" settings, necessarily; user may override\n    int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n\n    int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n\n    long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n        fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                   // [File?]InputFormat and default block size\n                                   // from that\n\n    long sysMemSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n            MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n\n    long sysCPUSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_CPU_VCORES,\n            MRJobConfig.DEFAULT_MR_AM_CPU_VCORES);\n\n    boolean uberEnabled \u003d\n        conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n    boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n    boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n    boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n    // ignoring overhead due to UberAM and statics as negligible here:\n    long requiredMapMB \u003d conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0);\n    long requiredReduceMB \u003d conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0);\n    long requiredMB \u003d Math.max(requiredMapMB, requiredReduceMB);\n    int requiredMapCores \u003d conf.getInt(\n            MRJobConfig.MAP_CPU_VCORES, \n            MRJobConfig.DEFAULT_MAP_CPU_VCORES);\n    int requiredReduceCores \u003d conf.getInt(\n            MRJobConfig.REDUCE_CPU_VCORES, \n            MRJobConfig.DEFAULT_REDUCE_CPU_VCORES);\n    int requiredCores \u003d Math.max(requiredMapCores, requiredReduceCores);    \n    if (numReduceTasks \u003d\u003d 0) {\n      requiredMB \u003d requiredMapMB;\n      requiredCores \u003d requiredMapCores;\n    }\n    boolean smallMemory \u003d\n        (requiredMB \u003c\u003d sysMemSizeForUberSlot)\n        || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT);\n    \n    boolean smallCpu \u003d requiredCores \u003c\u003d sysCPUSizeForUberSlot;\n    boolean notChainJob \u003d !isChainJob(conf);\n\n    // User has overall veto power over uberization, or user can modify\n    // limits (overriding system settings and potentially shooting\n    // themselves in the head).  Note that ChainMapper/Reducer are\n    // fundamentally incompatible with MR-1220; they employ a blocking\n    // queue between the maps/reduces and thus require parallel execution,\n    // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n    // and thus requires sequential execution.\n    isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 smallCpu \n        \u0026\u0026 notChainJob;\n\n    if (isUber) {\n      LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n          + numReduceTasks + \"r tasks (\" + dataInputLength\n          + \" input bytes) will run sequentially on single node.\");\n\n      // make sure reduces are scheduled only after all map are completed\n      conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                        1.0f);\n      // uber-subtask attempts all get launched on same node; if one fails,\n      // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n      // limit attempts to 1 (or at most 2?  probably not...)\n      conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n      conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n\n      // disable speculation\n      conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n      conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n    } else {\n      StringBuilder msg \u003d new StringBuilder();\n      msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n      if (!uberEnabled)\n        msg.append(\" not enabled;\");\n      if (!smallNumMapTasks)\n        msg.append(\" too many maps;\");\n      if (!smallNumReduceTasks)\n        msg.append(\" too many reduces;\");\n      if (!smallInput)\n        msg.append(\" too much input;\");\n      if (!smallCpu)\n        msg.append(\" too much CPU;\");\n      if (!smallMemory)\n        msg.append(\" too much RAM;\");\n      if (!notChainJob)\n        msg.append(\" chainjob;\");\n      LOG.info(msg.toString());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/JobImpl.java",
      "extendedDetails": {}
    },
    "4b2ded8202f9d07ba44066650dc4e5c987cbbacc": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5517. Fixed MapReduce ApplicationMaster to not validate reduce side resource configuration for deciding uber-mode on map-only jobs. Contributed by Siqi Li.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1608595 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/07/14 1:14 PM",
      "commitName": "4b2ded8202f9d07ba44066650dc4e5c987cbbacc",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/05/14 11:27 AM",
      "commitNameOld": "4bc3371824d6f0495a5a6a2892c0683b4d66a5a8",
      "commitAuthorOld": "Jonathan Turner Eagles",
      "daysBetweenCommits": 55.07,
      "commitsBetweenForRepo": 335,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,95 @@\n   private void makeUberDecision(long dataInputLength) {\n     //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n     // until AM-resizing supported,\n     // must depend on job client to pass fat-slot needs)\n     // these are no longer \"system\" settings, necessarily; user may override\n     int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n \n     int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n \n     long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n         fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                    // [File?]InputFormat and default block size\n                                    // from that\n \n     long sysMemSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n             MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n \n     long sysCPUSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_CPU_VCORES,\n             MRJobConfig.DEFAULT_MR_AM_CPU_VCORES);\n \n     boolean uberEnabled \u003d\n         conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n     boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n     boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n     boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n     // ignoring overhead due to UberAM and statics as negligible here:\n+    long requiredMapMB \u003d conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0);\n+    long requiredReduceMB \u003d conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0);\n+    long requiredMB \u003d Math.max(requiredMapMB, requiredReduceMB);\n+    int requiredMapCores \u003d conf.getInt(\n+            MRJobConfig.MAP_CPU_VCORES, \n+            MRJobConfig.DEFAULT_MAP_CPU_VCORES);\n+    int requiredReduceCores \u003d conf.getInt(\n+            MRJobConfig.REDUCE_CPU_VCORES, \n+            MRJobConfig.DEFAULT_REDUCE_CPU_VCORES);\n+    int requiredCores \u003d Math.max(requiredMapCores, requiredReduceCores);    \n+    if (numReduceTasks \u003d\u003d 0) {\n+      requiredMB \u003d requiredMapMB;\n+      requiredCores \u003d requiredMapCores;\n+    }\n     boolean smallMemory \u003d\n-        ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n-            conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n-            \u003c\u003d sysMemSizeForUberSlot)\n-            || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n-    boolean smallCpu \u003d\n-        (\n-            Math.max(\n-                conf.getInt(\n-                    MRJobConfig.MAP_CPU_VCORES, \n-                    MRJobConfig.DEFAULT_MAP_CPU_VCORES), \n-                conf.getInt(\n-                    MRJobConfig.REDUCE_CPU_VCORES, \n-                    MRJobConfig.DEFAULT_REDUCE_CPU_VCORES)) \n-             \u003c\u003d sysCPUSizeForUberSlot\n-        );\n+        (requiredMB \u003c\u003d sysMemSizeForUberSlot)\n+        || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT);\n+    \n+    boolean smallCpu \u003d requiredCores \u003c\u003d sysCPUSizeForUberSlot;\n     boolean notChainJob \u003d !isChainJob(conf);\n \n     // User has overall veto power over uberization, or user can modify\n     // limits (overriding system settings and potentially shooting\n     // themselves in the head).  Note that ChainMapper/Reducer are\n     // fundamentally incompatible with MR-1220; they employ a blocking\n     // queue between the maps/reduces and thus require parallel execution,\n     // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n     // and thus requires sequential execution.\n     isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n         \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 smallCpu \n         \u0026\u0026 notChainJob;\n \n     if (isUber) {\n       LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n           + numReduceTasks + \"r tasks (\" + dataInputLength\n           + \" input bytes) will run sequentially on single node.\");\n \n       // make sure reduces are scheduled only after all map are completed\n       conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                         1.0f);\n       // uber-subtask attempts all get launched on same node; if one fails,\n       // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n       // limit attempts to 1 (or at most 2?  probably not...)\n       conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n       conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n \n       // disable speculation\n       conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n       conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n     } else {\n       StringBuilder msg \u003d new StringBuilder();\n       msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n       if (!uberEnabled)\n         msg.append(\" not enabled;\");\n       if (!smallNumMapTasks)\n         msg.append(\" too many maps;\");\n       if (!smallNumReduceTasks)\n         msg.append(\" too many reduces;\");\n       if (!smallInput)\n         msg.append(\" too much input;\");\n       if (!smallMemory)\n         msg.append(\" too much RAM;\");\n       if (!notChainJob)\n         msg.append(\" chainjob;\");\n       LOG.info(msg.toString());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void makeUberDecision(long dataInputLength) {\n    //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n    // until AM-resizing supported,\n    // must depend on job client to pass fat-slot needs)\n    // these are no longer \"system\" settings, necessarily; user may override\n    int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n\n    int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n\n    long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n        fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                   // [File?]InputFormat and default block size\n                                   // from that\n\n    long sysMemSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n            MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n\n    long sysCPUSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_CPU_VCORES,\n            MRJobConfig.DEFAULT_MR_AM_CPU_VCORES);\n\n    boolean uberEnabled \u003d\n        conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n    boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n    boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n    boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n    // ignoring overhead due to UberAM and statics as negligible here:\n    long requiredMapMB \u003d conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0);\n    long requiredReduceMB \u003d conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0);\n    long requiredMB \u003d Math.max(requiredMapMB, requiredReduceMB);\n    int requiredMapCores \u003d conf.getInt(\n            MRJobConfig.MAP_CPU_VCORES, \n            MRJobConfig.DEFAULT_MAP_CPU_VCORES);\n    int requiredReduceCores \u003d conf.getInt(\n            MRJobConfig.REDUCE_CPU_VCORES, \n            MRJobConfig.DEFAULT_REDUCE_CPU_VCORES);\n    int requiredCores \u003d Math.max(requiredMapCores, requiredReduceCores);    \n    if (numReduceTasks \u003d\u003d 0) {\n      requiredMB \u003d requiredMapMB;\n      requiredCores \u003d requiredMapCores;\n    }\n    boolean smallMemory \u003d\n        (requiredMB \u003c\u003d sysMemSizeForUberSlot)\n        || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT);\n    \n    boolean smallCpu \u003d requiredCores \u003c\u003d sysCPUSizeForUberSlot;\n    boolean notChainJob \u003d !isChainJob(conf);\n\n    // User has overall veto power over uberization, or user can modify\n    // limits (overriding system settings and potentially shooting\n    // themselves in the head).  Note that ChainMapper/Reducer are\n    // fundamentally incompatible with MR-1220; they employ a blocking\n    // queue between the maps/reduces and thus require parallel execution,\n    // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n    // and thus requires sequential execution.\n    isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 smallCpu \n        \u0026\u0026 notChainJob;\n\n    if (isUber) {\n      LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n          + numReduceTasks + \"r tasks (\" + dataInputLength\n          + \" input bytes) will run sequentially on single node.\");\n\n      // make sure reduces are scheduled only after all map are completed\n      conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                        1.0f);\n      // uber-subtask attempts all get launched on same node; if one fails,\n      // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n      // limit attempts to 1 (or at most 2?  probably not...)\n      conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n      conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n\n      // disable speculation\n      conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n      conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n    } else {\n      StringBuilder msg \u003d new StringBuilder();\n      msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n      if (!uberEnabled)\n        msg.append(\" not enabled;\");\n      if (!smallNumMapTasks)\n        msg.append(\" too many maps;\");\n      if (!smallNumReduceTasks)\n        msg.append(\" too many reduces;\");\n      if (!smallInput)\n        msg.append(\" too much input;\");\n      if (!smallMemory)\n        msg.append(\" too much RAM;\");\n      if (!notChainJob)\n        msg.append(\" chainjob;\");\n      LOG.info(msg.toString());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/JobImpl.java",
      "extendedDetails": {}
    },
    "3d95049f79fe7edb92dd6d20c3a60ccdc46c4b0e": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5481. Enable uber jobs to have multiple reducers (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1541844 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/11/13 11:56 PM",
      "commitName": "3d95049f79fe7edb92dd6d20c3a60ccdc46c4b0e",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "06/10/13 1:53 PM",
      "commitNameOld": "f0799c55360e1e77224955f331892390e4361729",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 38.46,
      "commitsBetweenForRepo": 228,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,92 @@\n   private void makeUberDecision(long dataInputLength) {\n     //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n     // until AM-resizing supported,\n     // must depend on job client to pass fat-slot needs)\n     // these are no longer \"system\" settings, necessarily; user may override\n     int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n \n-    //FIXME: handling multiple reduces within a single AM does not seem to\n-    //work.\n     int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n-    boolean isValidUberMaxReduces \u003d (sysMaxReduces \u003d\u003d 0)\n-        || (sysMaxReduces \u003d\u003d 1);\n \n     long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n         fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                    // [File?]InputFormat and default block size\n                                    // from that\n \n     long sysMemSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n             MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n \n     long sysCPUSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_CPU_VCORES,\n             MRJobConfig.DEFAULT_MR_AM_CPU_VCORES);\n \n     boolean uberEnabled \u003d\n         conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n     boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n     boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n     boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n     // ignoring overhead due to UberAM and statics as negligible here:\n     boolean smallMemory \u003d\n         ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n             conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n             \u003c\u003d sysMemSizeForUberSlot)\n             || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n     boolean smallCpu \u003d\n         (\n             Math.max(\n                 conf.getInt(\n                     MRJobConfig.MAP_CPU_VCORES, \n                     MRJobConfig.DEFAULT_MAP_CPU_VCORES), \n                 conf.getInt(\n                     MRJobConfig.REDUCE_CPU_VCORES, \n                     MRJobConfig.DEFAULT_REDUCE_CPU_VCORES)) \n              \u003c\u003d sysCPUSizeForUberSlot\n         );\n     boolean notChainJob \u003d !isChainJob(conf);\n \n     // User has overall veto power over uberization, or user can modify\n     // limits (overriding system settings and potentially shooting\n     // themselves in the head).  Note that ChainMapper/Reducer are\n     // fundamentally incompatible with MR-1220; they employ a blocking\n     // queue between the maps/reduces and thus require parallel execution,\n     // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n     // and thus requires sequential execution.\n     isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n         \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 smallCpu \n-        \u0026\u0026 notChainJob \u0026\u0026 isValidUberMaxReduces;\n+        \u0026\u0026 notChainJob;\n \n     if (isUber) {\n       LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n           + numReduceTasks + \"r tasks (\" + dataInputLength\n           + \" input bytes) will run sequentially on single node.\");\n \n       // make sure reduces are scheduled only after all map are completed\n       conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                         1.0f);\n       // uber-subtask attempts all get launched on same node; if one fails,\n       // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n       // limit attempts to 1 (or at most 2?  probably not...)\n       conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n       conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n \n       // disable speculation\n       conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n       conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n     } else {\n       StringBuilder msg \u003d new StringBuilder();\n       msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n       if (!uberEnabled)\n         msg.append(\" not enabled;\");\n       if (!smallNumMapTasks)\n         msg.append(\" too many maps;\");\n       if (!smallNumReduceTasks)\n         msg.append(\" too many reduces;\");\n       if (!smallInput)\n         msg.append(\" too much input;\");\n       if (!smallMemory)\n         msg.append(\" too much RAM;\");\n       if (!notChainJob)\n         msg.append(\" chainjob;\");\n-      if (!isValidUberMaxReduces)\n-        msg.append(\" not supported uber max reduces\");\n       LOG.info(msg.toString());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void makeUberDecision(long dataInputLength) {\n    //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n    // until AM-resizing supported,\n    // must depend on job client to pass fat-slot needs)\n    // these are no longer \"system\" settings, necessarily; user may override\n    int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n\n    int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n\n    long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n        fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                   // [File?]InputFormat and default block size\n                                   // from that\n\n    long sysMemSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n            MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n\n    long sysCPUSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_CPU_VCORES,\n            MRJobConfig.DEFAULT_MR_AM_CPU_VCORES);\n\n    boolean uberEnabled \u003d\n        conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n    boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n    boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n    boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n    // ignoring overhead due to UberAM and statics as negligible here:\n    boolean smallMemory \u003d\n        ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n            conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n            \u003c\u003d sysMemSizeForUberSlot)\n            || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n    boolean smallCpu \u003d\n        (\n            Math.max(\n                conf.getInt(\n                    MRJobConfig.MAP_CPU_VCORES, \n                    MRJobConfig.DEFAULT_MAP_CPU_VCORES), \n                conf.getInt(\n                    MRJobConfig.REDUCE_CPU_VCORES, \n                    MRJobConfig.DEFAULT_REDUCE_CPU_VCORES)) \n             \u003c\u003d sysCPUSizeForUberSlot\n        );\n    boolean notChainJob \u003d !isChainJob(conf);\n\n    // User has overall veto power over uberization, or user can modify\n    // limits (overriding system settings and potentially shooting\n    // themselves in the head).  Note that ChainMapper/Reducer are\n    // fundamentally incompatible with MR-1220; they employ a blocking\n    // queue between the maps/reduces and thus require parallel execution,\n    // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n    // and thus requires sequential execution.\n    isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 smallCpu \n        \u0026\u0026 notChainJob;\n\n    if (isUber) {\n      LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n          + numReduceTasks + \"r tasks (\" + dataInputLength\n          + \" input bytes) will run sequentially on single node.\");\n\n      // make sure reduces are scheduled only after all map are completed\n      conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                        1.0f);\n      // uber-subtask attempts all get launched on same node; if one fails,\n      // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n      // limit attempts to 1 (or at most 2?  probably not...)\n      conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n      conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n\n      // disable speculation\n      conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n      conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n    } else {\n      StringBuilder msg \u003d new StringBuilder();\n      msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n      if (!uberEnabled)\n        msg.append(\" not enabled;\");\n      if (!smallNumMapTasks)\n        msg.append(\" too many maps;\");\n      if (!smallNumReduceTasks)\n        msg.append(\" too many reduces;\");\n      if (!smallInput)\n        msg.append(\" too much input;\");\n      if (!smallMemory)\n        msg.append(\" too much RAM;\");\n      if (!notChainJob)\n        msg.append(\" chainjob;\");\n      LOG.info(msg.toString());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/JobImpl.java",
      "extendedDetails": {}
    },
    "dd6aa0cf124786e473bf373bc5e0957e50fc9b5d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4936. JobImpl uber checks for cpu are wrong. Contributed by Arun C Murthy\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1433445 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/01/13 6:45 AM",
      "commitName": "dd6aa0cf124786e473bf373bc5e0957e50fc9b5d",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "08/01/13 9:28 PM",
      "commitNameOld": "2c5c8fdb80546467274607b26a1295b352c58fc8",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 6.39,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,98 @@\n   private void makeUberDecision(long dataInputLength) {\n     //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n     // until AM-resizing supported,\n     // must depend on job client to pass fat-slot needs)\n     // these are no longer \"system\" settings, necessarily; user may override\n     int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n \n     //FIXME: handling multiple reduces within a single AM does not seem to\n     //work.\n     int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n     boolean isValidUberMaxReduces \u003d (sysMaxReduces \u003d\u003d 0)\n         || (sysMaxReduces \u003d\u003d 1);\n \n     long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n         fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                    // [File?]InputFormat and default block size\n                                    // from that\n \n     long sysMemSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n             MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n \n     long sysCPUSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_CPU_VCORES,\n             MRJobConfig.DEFAULT_MR_AM_CPU_VCORES);\n \n     boolean uberEnabled \u003d\n         conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n     boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n     boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n     boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n     // ignoring overhead due to UberAM and statics as negligible here:\n     boolean smallMemory \u003d\n         ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n             conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n             \u003c\u003d sysMemSizeForUberSlot)\n             || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n     boolean smallCpu \u003d\n         (\n             Math.max(\n-                conf.getInt(MRJobConfig.MAP_CPU_VCORES, 1), \n-                conf.getInt(MRJobConfig.REDUCE_CPU_VCORES, 1)) \u003c \n-             sysCPUSizeForUberSlot\n+                conf.getInt(\n+                    MRJobConfig.MAP_CPU_VCORES, \n+                    MRJobConfig.DEFAULT_MAP_CPU_VCORES), \n+                conf.getInt(\n+                    MRJobConfig.REDUCE_CPU_VCORES, \n+                    MRJobConfig.DEFAULT_REDUCE_CPU_VCORES)) \n+             \u003c\u003d sysCPUSizeForUberSlot\n         );\n     boolean notChainJob \u003d !isChainJob(conf);\n \n     // User has overall veto power over uberization, or user can modify\n     // limits (overriding system settings and potentially shooting\n     // themselves in the head).  Note that ChainMapper/Reducer are\n     // fundamentally incompatible with MR-1220; they employ a blocking\n     // queue between the maps/reduces and thus require parallel execution,\n     // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n     // and thus requires sequential execution.\n     isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n         \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 smallCpu \n         \u0026\u0026 notChainJob \u0026\u0026 isValidUberMaxReduces;\n \n     if (isUber) {\n       LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n           + numReduceTasks + \"r tasks (\" + dataInputLength\n           + \" input bytes) will run sequentially on single node.\");\n \n       // make sure reduces are scheduled only after all map are completed\n       conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                         1.0f);\n       // uber-subtask attempts all get launched on same node; if one fails,\n       // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n       // limit attempts to 1 (or at most 2?  probably not...)\n       conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n       conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n \n       // disable speculation\n       conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n       conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n     } else {\n       StringBuilder msg \u003d new StringBuilder();\n       msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n       if (!uberEnabled)\n         msg.append(\" not enabled;\");\n       if (!smallNumMapTasks)\n         msg.append(\" too many maps;\");\n       if (!smallNumReduceTasks)\n         msg.append(\" too many reduces;\");\n       if (!smallInput)\n         msg.append(\" too much input;\");\n       if (!smallMemory)\n         msg.append(\" too much RAM;\");\n       if (!notChainJob)\n         msg.append(\" chainjob;\");\n       if (!isValidUberMaxReduces)\n         msg.append(\" not supported uber max reduces\");\n       LOG.info(msg.toString());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void makeUberDecision(long dataInputLength) {\n    //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n    // until AM-resizing supported,\n    // must depend on job client to pass fat-slot needs)\n    // these are no longer \"system\" settings, necessarily; user may override\n    int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n\n    //FIXME: handling multiple reduces within a single AM does not seem to\n    //work.\n    int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n    boolean isValidUberMaxReduces \u003d (sysMaxReduces \u003d\u003d 0)\n        || (sysMaxReduces \u003d\u003d 1);\n\n    long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n        fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                   // [File?]InputFormat and default block size\n                                   // from that\n\n    long sysMemSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n            MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n\n    long sysCPUSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_CPU_VCORES,\n            MRJobConfig.DEFAULT_MR_AM_CPU_VCORES);\n\n    boolean uberEnabled \u003d\n        conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n    boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n    boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n    boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n    // ignoring overhead due to UberAM and statics as negligible here:\n    boolean smallMemory \u003d\n        ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n            conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n            \u003c\u003d sysMemSizeForUberSlot)\n            || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n    boolean smallCpu \u003d\n        (\n            Math.max(\n                conf.getInt(\n                    MRJobConfig.MAP_CPU_VCORES, \n                    MRJobConfig.DEFAULT_MAP_CPU_VCORES), \n                conf.getInt(\n                    MRJobConfig.REDUCE_CPU_VCORES, \n                    MRJobConfig.DEFAULT_REDUCE_CPU_VCORES)) \n             \u003c\u003d sysCPUSizeForUberSlot\n        );\n    boolean notChainJob \u003d !isChainJob(conf);\n\n    // User has overall veto power over uberization, or user can modify\n    // limits (overriding system settings and potentially shooting\n    // themselves in the head).  Note that ChainMapper/Reducer are\n    // fundamentally incompatible with MR-1220; they employ a blocking\n    // queue between the maps/reduces and thus require parallel execution,\n    // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n    // and thus requires sequential execution.\n    isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 smallCpu \n        \u0026\u0026 notChainJob \u0026\u0026 isValidUberMaxReduces;\n\n    if (isUber) {\n      LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n          + numReduceTasks + \"r tasks (\" + dataInputLength\n          + \" input bytes) will run sequentially on single node.\");\n\n      // make sure reduces are scheduled only after all map are completed\n      conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                        1.0f);\n      // uber-subtask attempts all get launched on same node; if one fails,\n      // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n      // limit attempts to 1 (or at most 2?  probably not...)\n      conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n      conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n\n      // disable speculation\n      conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n      conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n    } else {\n      StringBuilder msg \u003d new StringBuilder();\n      msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n      if (!uberEnabled)\n        msg.append(\" not enabled;\");\n      if (!smallNumMapTasks)\n        msg.append(\" too many maps;\");\n      if (!smallNumReduceTasks)\n        msg.append(\" too many reduces;\");\n      if (!smallInput)\n        msg.append(\" too much input;\");\n      if (!smallMemory)\n        msg.append(\" too much RAM;\");\n      if (!notChainJob)\n        msg.append(\" chainjob;\");\n      if (!isValidUberMaxReduces)\n        msg.append(\" not supported uber max reduces\");\n      LOG.info(msg.toString());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/JobImpl.java",
      "extendedDetails": {}
    },
    "2c5c8fdb80546467274607b26a1295b352c58fc8": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4520. Added support for MapReduce applications to request for CPU cores along-with memory post YARN-2. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430688 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 9:28 PM",
      "commitName": "2c5c8fdb80546467274607b26a1295b352c58fc8",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "04/01/13 12:35 PM",
      "commitNameOld": "64e4fb983e022d8d3375a3e1b8facbf95f7ba403",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 4.37,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,94 @@\n   private void makeUberDecision(long dataInputLength) {\n     //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n     // until AM-resizing supported,\n     // must depend on job client to pass fat-slot needs)\n     // these are no longer \"system\" settings, necessarily; user may override\n     int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n \n     //FIXME: handling multiple reduces within a single AM does not seem to\n     //work.\n     int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n     boolean isValidUberMaxReduces \u003d (sysMaxReduces \u003d\u003d 0)\n         || (sysMaxReduces \u003d\u003d 1);\n \n     long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n         fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                    // [File?]InputFormat and default block size\n                                    // from that\n \n     long sysMemSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n             MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n \n+    long sysCPUSizeForUberSlot \u003d\n+        conf.getInt(MRJobConfig.MR_AM_CPU_VCORES,\n+            MRJobConfig.DEFAULT_MR_AM_CPU_VCORES);\n+\n     boolean uberEnabled \u003d\n         conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n     boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n     boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n     boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n     // ignoring overhead due to UberAM and statics as negligible here:\n     boolean smallMemory \u003d\n         ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n             conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n             \u003c\u003d sysMemSizeForUberSlot)\n             || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n+    boolean smallCpu \u003d\n+        (\n+            Math.max(\n+                conf.getInt(MRJobConfig.MAP_CPU_VCORES, 1), \n+                conf.getInt(MRJobConfig.REDUCE_CPU_VCORES, 1)) \u003c \n+             sysCPUSizeForUberSlot\n+        );\n     boolean notChainJob \u003d !isChainJob(conf);\n \n     // User has overall veto power over uberization, or user can modify\n     // limits (overriding system settings and potentially shooting\n     // themselves in the head).  Note that ChainMapper/Reducer are\n     // fundamentally incompatible with MR-1220; they employ a blocking\n     // queue between the maps/reduces and thus require parallel execution,\n     // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n     // and thus requires sequential execution.\n     isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n-        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 notChainJob \u0026\u0026 isValidUberMaxReduces;\n+        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 smallCpu \n+        \u0026\u0026 notChainJob \u0026\u0026 isValidUberMaxReduces;\n \n     if (isUber) {\n       LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n           + numReduceTasks + \"r tasks (\" + dataInputLength\n           + \" input bytes) will run sequentially on single node.\");\n \n       // make sure reduces are scheduled only after all map are completed\n       conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                         1.0f);\n       // uber-subtask attempts all get launched on same node; if one fails,\n       // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n       // limit attempts to 1 (or at most 2?  probably not...)\n       conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n       conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n \n       // disable speculation\n       conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n       conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n     } else {\n       StringBuilder msg \u003d new StringBuilder();\n       msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n       if (!uberEnabled)\n         msg.append(\" not enabled;\");\n       if (!smallNumMapTasks)\n         msg.append(\" too many maps;\");\n       if (!smallNumReduceTasks)\n         msg.append(\" too many reduces;\");\n       if (!smallInput)\n         msg.append(\" too much input;\");\n       if (!smallMemory)\n         msg.append(\" too much RAM;\");\n       if (!notChainJob)\n         msg.append(\" chainjob;\");\n       if (!isValidUberMaxReduces)\n         msg.append(\" not supported uber max reduces\");\n       LOG.info(msg.toString());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void makeUberDecision(long dataInputLength) {\n    //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n    // until AM-resizing supported,\n    // must depend on job client to pass fat-slot needs)\n    // these are no longer \"system\" settings, necessarily; user may override\n    int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n\n    //FIXME: handling multiple reduces within a single AM does not seem to\n    //work.\n    int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n    boolean isValidUberMaxReduces \u003d (sysMaxReduces \u003d\u003d 0)\n        || (sysMaxReduces \u003d\u003d 1);\n\n    long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n        fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                   // [File?]InputFormat and default block size\n                                   // from that\n\n    long sysMemSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n            MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n\n    long sysCPUSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_CPU_VCORES,\n            MRJobConfig.DEFAULT_MR_AM_CPU_VCORES);\n\n    boolean uberEnabled \u003d\n        conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n    boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n    boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n    boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n    // ignoring overhead due to UberAM and statics as negligible here:\n    boolean smallMemory \u003d\n        ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n            conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n            \u003c\u003d sysMemSizeForUberSlot)\n            || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n    boolean smallCpu \u003d\n        (\n            Math.max(\n                conf.getInt(MRJobConfig.MAP_CPU_VCORES, 1), \n                conf.getInt(MRJobConfig.REDUCE_CPU_VCORES, 1)) \u003c \n             sysCPUSizeForUberSlot\n        );\n    boolean notChainJob \u003d !isChainJob(conf);\n\n    // User has overall veto power over uberization, or user can modify\n    // limits (overriding system settings and potentially shooting\n    // themselves in the head).  Note that ChainMapper/Reducer are\n    // fundamentally incompatible with MR-1220; they employ a blocking\n    // queue between the maps/reduces and thus require parallel execution,\n    // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n    // and thus requires sequential execution.\n    isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 smallCpu \n        \u0026\u0026 notChainJob \u0026\u0026 isValidUberMaxReduces;\n\n    if (isUber) {\n      LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n          + numReduceTasks + \"r tasks (\" + dataInputLength\n          + \" input bytes) will run sequentially on single node.\");\n\n      // make sure reduces are scheduled only after all map are completed\n      conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                        1.0f);\n      // uber-subtask attempts all get launched on same node; if one fails,\n      // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n      // limit attempts to 1 (or at most 2?  probably not...)\n      conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n      conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n\n      // disable speculation\n      conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n      conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n    } else {\n      StringBuilder msg \u003d new StringBuilder();\n      msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n      if (!uberEnabled)\n        msg.append(\" not enabled;\");\n      if (!smallNumMapTasks)\n        msg.append(\" too many maps;\");\n      if (!smallNumReduceTasks)\n        msg.append(\" too many reduces;\");\n      if (!smallInput)\n        msg.append(\" too much input;\");\n      if (!smallMemory)\n        msg.append(\" too much RAM;\");\n      if (!notChainJob)\n        msg.append(\" chainjob;\");\n      if (!isValidUberMaxReduces)\n        msg.append(\" not supported uber max reduces\");\n      LOG.info(msg.toString());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/JobImpl.java",
      "extendedDetails": {}
    },
    "80ab78c21728e9979e892283e9e0caf6ab3b0fef": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4133. MR over viewfs is broken (John George via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1329403 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/12 12:44 PM",
      "commitName": "80ab78c21728e9979e892283e9e0caf6ab3b0fef",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "19/04/12 9:22 AM",
      "commitNameOld": "e3806060ce01557ba75094665b032dcca5656a19",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 4.14,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   private void makeUberDecision(long dataInputLength) {\n     //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n     // until AM-resizing supported,\n     // must depend on job client to pass fat-slot needs)\n     // these are no longer \"system\" settings, necessarily; user may override\n     int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n \n     //FIXME: handling multiple reduces within a single AM does not seem to\n     //work.\n     int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n     boolean isValidUberMaxReduces \u003d (sysMaxReduces \u003d\u003d 0)\n         || (sysMaxReduces \u003d\u003d 1);\n \n     long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n-        fs.getDefaultBlockSize()); // FIXME: this is wrong; get FS from\n+        fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                    // [File?]InputFormat and default block size\n                                    // from that\n \n     long sysMemSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n             MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n \n     boolean uberEnabled \u003d\n         conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n     boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n     boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n     boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n     // ignoring overhead due to UberAM and statics as negligible here:\n     boolean smallMemory \u003d\n         ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n             conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n             \u003c\u003d sysMemSizeForUberSlot)\n             || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n     boolean notChainJob \u003d !isChainJob(conf);\n \n     // User has overall veto power over uberization, or user can modify\n     // limits (overriding system settings and potentially shooting\n     // themselves in the head).  Note that ChainMapper/Reducer are\n     // fundamentally incompatible with MR-1220; they employ a blocking\n     // queue between the maps/reduces and thus require parallel execution,\n     // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n     // and thus requires sequential execution.\n     isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n         \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 notChainJob \u0026\u0026 isValidUberMaxReduces;\n \n     if (isUber) {\n       LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n           + numReduceTasks + \"r tasks (\" + dataInputLength\n           + \" input bytes) will run sequentially on single node.\");\n \n       // make sure reduces are scheduled only after all map are completed\n       conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                         1.0f);\n       // uber-subtask attempts all get launched on same node; if one fails,\n       // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n       // limit attempts to 1 (or at most 2?  probably not...)\n       conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n       conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n \n       // disable speculation\n       conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n       conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n     } else {\n       StringBuilder msg \u003d new StringBuilder();\n       msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n       if (!uberEnabled)\n         msg.append(\" not enabled;\");\n       if (!smallNumMapTasks)\n         msg.append(\" too many maps;\");\n       if (!smallNumReduceTasks)\n         msg.append(\" too many reduces;\");\n       if (!smallInput)\n         msg.append(\" too much input;\");\n       if (!smallMemory)\n         msg.append(\" too much RAM;\");\n       if (!notChainJob)\n         msg.append(\" chainjob;\");\n       if (!isValidUberMaxReduces)\n         msg.append(\" not supported uber max reduces\");\n       LOG.info(msg.toString());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void makeUberDecision(long dataInputLength) {\n    //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n    // until AM-resizing supported,\n    // must depend on job client to pass fat-slot needs)\n    // these are no longer \"system\" settings, necessarily; user may override\n    int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n\n    //FIXME: handling multiple reduces within a single AM does not seem to\n    //work.\n    int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n    boolean isValidUberMaxReduces \u003d (sysMaxReduces \u003d\u003d 0)\n        || (sysMaxReduces \u003d\u003d 1);\n\n    long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n        fs.getDefaultBlockSize(this.remoteJobSubmitDir)); // FIXME: this is wrong; get FS from\n                                   // [File?]InputFormat and default block size\n                                   // from that\n\n    long sysMemSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n            MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n\n    boolean uberEnabled \u003d\n        conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n    boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n    boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n    boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n    // ignoring overhead due to UberAM and statics as negligible here:\n    boolean smallMemory \u003d\n        ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n            conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n            \u003c\u003d sysMemSizeForUberSlot)\n            || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n    boolean notChainJob \u003d !isChainJob(conf);\n\n    // User has overall veto power over uberization, or user can modify\n    // limits (overriding system settings and potentially shooting\n    // themselves in the head).  Note that ChainMapper/Reducer are\n    // fundamentally incompatible with MR-1220; they employ a blocking\n    // queue between the maps/reduces and thus require parallel execution,\n    // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n    // and thus requires sequential execution.\n    isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 notChainJob \u0026\u0026 isValidUberMaxReduces;\n\n    if (isUber) {\n      LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n          + numReduceTasks + \"r tasks (\" + dataInputLength\n          + \" input bytes) will run sequentially on single node.\");\n\n      // make sure reduces are scheduled only after all map are completed\n      conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                        1.0f);\n      // uber-subtask attempts all get launched on same node; if one fails,\n      // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n      // limit attempts to 1 (or at most 2?  probably not...)\n      conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n      conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n\n      // disable speculation\n      conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n      conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n    } else {\n      StringBuilder msg \u003d new StringBuilder();\n      msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n      if (!uberEnabled)\n        msg.append(\" not enabled;\");\n      if (!smallNumMapTasks)\n        msg.append(\" too many maps;\");\n      if (!smallNumReduceTasks)\n        msg.append(\" too many reduces;\");\n      if (!smallInput)\n        msg.append(\" too much input;\");\n      if (!smallMemory)\n        msg.append(\" too much RAM;\");\n      if (!notChainJob)\n        msg.append(\" chainjob;\");\n      if (!isValidUberMaxReduces)\n        msg.append(\" not supported uber max reduces\");\n      LOG.info(msg.toString());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/JobImpl.java",
      "extendedDetails": {}
    },
    "e3806060ce01557ba75094665b032dcca5656a19": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4159. Job is running in Uber mode after setting \"mapreduce.job.ubertask.maxreduces\" to zero (Devaraj K via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1328031 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/04/12 9:22 AM",
      "commitName": "e3806060ce01557ba75094665b032dcca5656a19",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "17/04/12 6:59 PM",
      "commitNameOld": "7d04a96027ad75877b41b7cd8f67455dd13159d7",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 1.6,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,82 @@\n   private void makeUberDecision(long dataInputLength) {\n     //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n     // until AM-resizing supported,\n     // must depend on job client to pass fat-slot needs)\n     // these are no longer \"system\" settings, necessarily; user may override\n     int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n \n     //FIXME: handling multiple reduces within a single AM does not seem to\n     //work.\n-    // int sysMaxReduces \u003d\n-    //     job.conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n-    int sysMaxReduces \u003d 1;\n+    int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n+    boolean isValidUberMaxReduces \u003d (sysMaxReduces \u003d\u003d 0)\n+        || (sysMaxReduces \u003d\u003d 1);\n \n     long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n         fs.getDefaultBlockSize()); // FIXME: this is wrong; get FS from\n                                    // [File?]InputFormat and default block size\n                                    // from that\n \n     long sysMemSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n             MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n \n     boolean uberEnabled \u003d\n         conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n     boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n     boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n     boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n     // ignoring overhead due to UberAM and statics as negligible here:\n     boolean smallMemory \u003d\n         ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n             conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n             \u003c\u003d sysMemSizeForUberSlot)\n             || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n     boolean notChainJob \u003d !isChainJob(conf);\n \n     // User has overall veto power over uberization, or user can modify\n     // limits (overriding system settings and potentially shooting\n     // themselves in the head).  Note that ChainMapper/Reducer are\n     // fundamentally incompatible with MR-1220; they employ a blocking\n     // queue between the maps/reduces and thus require parallel execution,\n     // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n     // and thus requires sequential execution.\n     isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n-        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 notChainJob;\n+        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 notChainJob \u0026\u0026 isValidUberMaxReduces;\n \n     if (isUber) {\n       LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n           + numReduceTasks + \"r tasks (\" + dataInputLength\n           + \" input bytes) will run sequentially on single node.\");\n \n       // make sure reduces are scheduled only after all map are completed\n       conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                         1.0f);\n       // uber-subtask attempts all get launched on same node; if one fails,\n       // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n       // limit attempts to 1 (or at most 2?  probably not...)\n       conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n       conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n \n       // disable speculation\n       conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n       conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n     } else {\n       StringBuilder msg \u003d new StringBuilder();\n       msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n       if (!uberEnabled)\n         msg.append(\" not enabled;\");\n       if (!smallNumMapTasks)\n         msg.append(\" too many maps;\");\n       if (!smallNumReduceTasks)\n         msg.append(\" too many reduces;\");\n       if (!smallInput)\n         msg.append(\" too much input;\");\n       if (!smallMemory)\n         msg.append(\" too much RAM;\");\n       if (!notChainJob)\n-        msg.append(\" chainjob\");\n+        msg.append(\" chainjob;\");\n+      if (!isValidUberMaxReduces)\n+        msg.append(\" not supported uber max reduces\");\n       LOG.info(msg.toString());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void makeUberDecision(long dataInputLength) {\n    //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n    // until AM-resizing supported,\n    // must depend on job client to pass fat-slot needs)\n    // these are no longer \"system\" settings, necessarily; user may override\n    int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n\n    //FIXME: handling multiple reduces within a single AM does not seem to\n    //work.\n    int sysMaxReduces \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n    boolean isValidUberMaxReduces \u003d (sysMaxReduces \u003d\u003d 0)\n        || (sysMaxReduces \u003d\u003d 1);\n\n    long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n        fs.getDefaultBlockSize()); // FIXME: this is wrong; get FS from\n                                   // [File?]InputFormat and default block size\n                                   // from that\n\n    long sysMemSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n            MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n\n    boolean uberEnabled \u003d\n        conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n    boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n    boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n    boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n    // ignoring overhead due to UberAM and statics as negligible here:\n    boolean smallMemory \u003d\n        ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n            conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n            \u003c\u003d sysMemSizeForUberSlot)\n            || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n    boolean notChainJob \u003d !isChainJob(conf);\n\n    // User has overall veto power over uberization, or user can modify\n    // limits (overriding system settings and potentially shooting\n    // themselves in the head).  Note that ChainMapper/Reducer are\n    // fundamentally incompatible with MR-1220; they employ a blocking\n    // queue between the maps/reduces and thus require parallel execution,\n    // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n    // and thus requires sequential execution.\n    isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 notChainJob \u0026\u0026 isValidUberMaxReduces;\n\n    if (isUber) {\n      LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n          + numReduceTasks + \"r tasks (\" + dataInputLength\n          + \" input bytes) will run sequentially on single node.\");\n\n      // make sure reduces are scheduled only after all map are completed\n      conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                        1.0f);\n      // uber-subtask attempts all get launched on same node; if one fails,\n      // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n      // limit attempts to 1 (or at most 2?  probably not...)\n      conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n      conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n\n      // disable speculation\n      conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n      conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n    } else {\n      StringBuilder msg \u003d new StringBuilder();\n      msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n      if (!uberEnabled)\n        msg.append(\" not enabled;\");\n      if (!smallNumMapTasks)\n        msg.append(\" too many maps;\");\n      if (!smallNumReduceTasks)\n        msg.append(\" too many reduces;\");\n      if (!smallInput)\n        msg.append(\" too much input;\");\n      if (!smallMemory)\n        msg.append(\" too much RAM;\");\n      if (!notChainJob)\n        msg.append(\" chainjob;\");\n      if (!isValidUberMaxReduces)\n        msg.append(\" not supported uber max reduces\");\n      LOG.info(msg.toString());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/JobImpl.java",
      "extendedDetails": {}
    },
    "2f19c59f1d6f74a2f881aaa57344d556d7b3eb3c": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3610. Remove use of the \u0027dfs.block.size\u0027 config for default block size fetching. Use FS#getDefaultBlocksize instead. (Sho Shimauchi via harsh)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1227091 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/01/12 1:39 AM",
      "commitName": "2f19c59f1d6f74a2f881aaa57344d556d7b3eb3c",
      "commitAuthor": "Harsh J",
      "commitDateOld": "27/12/11 11:54 AM",
      "commitNameOld": "fcbad14a3da7fadbb601bf245552ecca2fbc5026",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.57,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,80 @@\n   private void makeUberDecision(long dataInputLength) {\n     //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n     // until AM-resizing supported,\n     // must depend on job client to pass fat-slot needs)\n     // these are no longer \"system\" settings, necessarily; user may override\n     int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n \n     //FIXME: handling multiple reduces within a single AM does not seem to\n     //work.\n     // int sysMaxReduces \u003d\n     //     job.conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n     int sysMaxReduces \u003d 1;\n \n     long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n-        conf.getLong(\"dfs.block.size\", 64*1024*1024));  //FIXME: this is\n-    // wrong; get FS from [File?]InputFormat and default block size from that\n+        fs.getDefaultBlockSize()); // FIXME: this is wrong; get FS from\n+                                   // [File?]InputFormat and default block size\n+                                   // from that\n \n     long sysMemSizeForUberSlot \u003d\n         conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n             MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n \n     boolean uberEnabled \u003d\n         conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n     boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n     boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n     boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n     // ignoring overhead due to UberAM and statics as negligible here:\n     boolean smallMemory \u003d\n         ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n             conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n             \u003c\u003d sysMemSizeForUberSlot)\n             || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n     boolean notChainJob \u003d !isChainJob(conf);\n \n     // User has overall veto power over uberization, or user can modify\n     // limits (overriding system settings and potentially shooting\n     // themselves in the head).  Note that ChainMapper/Reducer are\n     // fundamentally incompatible with MR-1220; they employ a blocking\n     // queue between the maps/reduces and thus require parallel execution,\n     // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n     // and thus requires sequential execution.\n     isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n         \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 notChainJob;\n \n     if (isUber) {\n       LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n           + numReduceTasks + \"r tasks (\" + dataInputLength\n           + \" input bytes) will run sequentially on single node.\");\n \n       // make sure reduces are scheduled only after all map are completed\n       conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                         1.0f);\n       // uber-subtask attempts all get launched on same node; if one fails,\n       // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n       // limit attempts to 1 (or at most 2?  probably not...)\n       conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n       conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n \n       // disable speculation\n       conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n       conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n     } else {\n       StringBuilder msg \u003d new StringBuilder();\n       msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n       if (!uberEnabled)\n         msg.append(\" not enabled;\");\n       if (!smallNumMapTasks)\n         msg.append(\" too many maps;\");\n       if (!smallNumReduceTasks)\n         msg.append(\" too many reduces;\");\n       if (!smallInput)\n         msg.append(\" too much input;\");\n       if (!smallMemory)\n         msg.append(\" too much RAM;\");\n       if (!notChainJob)\n         msg.append(\" chainjob\");\n       LOG.info(msg.toString());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void makeUberDecision(long dataInputLength) {\n    //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n    // until AM-resizing supported,\n    // must depend on job client to pass fat-slot needs)\n    // these are no longer \"system\" settings, necessarily; user may override\n    int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n\n    //FIXME: handling multiple reduces within a single AM does not seem to\n    //work.\n    // int sysMaxReduces \u003d\n    //     job.conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n    int sysMaxReduces \u003d 1;\n\n    long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n        fs.getDefaultBlockSize()); // FIXME: this is wrong; get FS from\n                                   // [File?]InputFormat and default block size\n                                   // from that\n\n    long sysMemSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n            MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n\n    boolean uberEnabled \u003d\n        conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n    boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n    boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n    boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n    // ignoring overhead due to UberAM and statics as negligible here:\n    boolean smallMemory \u003d\n        ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n            conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n            \u003c\u003d sysMemSizeForUberSlot)\n            || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n    boolean notChainJob \u003d !isChainJob(conf);\n\n    // User has overall veto power over uberization, or user can modify\n    // limits (overriding system settings and potentially shooting\n    // themselves in the head).  Note that ChainMapper/Reducer are\n    // fundamentally incompatible with MR-1220; they employ a blocking\n    // queue between the maps/reduces and thus require parallel execution,\n    // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n    // and thus requires sequential execution.\n    isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 notChainJob;\n\n    if (isUber) {\n      LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n          + numReduceTasks + \"r tasks (\" + dataInputLength\n          + \" input bytes) will run sequentially on single node.\");\n\n      // make sure reduces are scheduled only after all map are completed\n      conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                        1.0f);\n      // uber-subtask attempts all get launched on same node; if one fails,\n      // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n      // limit attempts to 1 (or at most 2?  probably not...)\n      conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n      conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n\n      // disable speculation\n      conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n      conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n    } else {\n      StringBuilder msg \u003d new StringBuilder();\n      msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n      if (!uberEnabled)\n        msg.append(\" not enabled;\");\n      if (!smallNumMapTasks)\n        msg.append(\" too many maps;\");\n      if (!smallNumReduceTasks)\n        msg.append(\" too many reduces;\");\n      if (!smallInput)\n        msg.append(\" too much input;\");\n      if (!smallMemory)\n        msg.append(\" too much RAM;\");\n      if (!notChainJob)\n        msg.append(\" chainjob\");\n      LOG.info(msg.toString());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/JobImpl.java",
      "extendedDetails": {}
    },
    "b7ae5a6cb7b2d3e3112ac53007e984caeb07de58": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3426. Fixed MR AM in uber mode to write map intermediate outputs in the correct directory to work properly in secure mode. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1213987 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/11 3:35 PM",
      "commitName": "b7ae5a6cb7b2d3e3112ac53007e984caeb07de58",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,79 @@\n+  private void makeUberDecision(long dataInputLength) {\n+    //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n+    // until AM-resizing supported,\n+    // must depend on job client to pass fat-slot needs)\n+    // these are no longer \"system\" settings, necessarily; user may override\n+    int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n+\n+    //FIXME: handling multiple reduces within a single AM does not seem to\n+    //work.\n+    // int sysMaxReduces \u003d\n+    //     job.conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n+    int sysMaxReduces \u003d 1;\n+\n+    long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n+        conf.getLong(\"dfs.block.size\", 64*1024*1024));  //FIXME: this is\n+    // wrong; get FS from [File?]InputFormat and default block size from that\n+\n+    long sysMemSizeForUberSlot \u003d\n+        conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n+            MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n+\n+    boolean uberEnabled \u003d\n+        conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n+    boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n+    boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n+    boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n+    // ignoring overhead due to UberAM and statics as negligible here:\n+    boolean smallMemory \u003d\n+        ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n+            conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n+            \u003c\u003d sysMemSizeForUberSlot)\n+            || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n+    boolean notChainJob \u003d !isChainJob(conf);\n+\n+    // User has overall veto power over uberization, or user can modify\n+    // limits (overriding system settings and potentially shooting\n+    // themselves in the head).  Note that ChainMapper/Reducer are\n+    // fundamentally incompatible with MR-1220; they employ a blocking\n+    // queue between the maps/reduces and thus require parallel execution,\n+    // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n+    // and thus requires sequential execution.\n+    isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n+        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 notChainJob;\n+\n+    if (isUber) {\n+      LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n+          + numReduceTasks + \"r tasks (\" + dataInputLength\n+          + \" input bytes) will run sequentially on single node.\");\n+\n+      // make sure reduces are scheduled only after all map are completed\n+      conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n+                        1.0f);\n+      // uber-subtask attempts all get launched on same node; if one fails,\n+      // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n+      // limit attempts to 1 (or at most 2?  probably not...)\n+      conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n+      conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n+\n+      // disable speculation\n+      conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n+      conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n+    } else {\n+      StringBuilder msg \u003d new StringBuilder();\n+      msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n+      if (!uberEnabled)\n+        msg.append(\" not enabled;\");\n+      if (!smallNumMapTasks)\n+        msg.append(\" too many maps;\");\n+      if (!smallNumReduceTasks)\n+        msg.append(\" too many reduces;\");\n+      if (!smallInput)\n+        msg.append(\" too much input;\");\n+      if (!smallMemory)\n+        msg.append(\" too much RAM;\");\n+      if (!notChainJob)\n+        msg.append(\" chainjob\");\n+      LOG.info(msg.toString());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void makeUberDecision(long dataInputLength) {\n    //FIXME:  need new memory criterion for uber-decision (oops, too late here;\n    // until AM-resizing supported,\n    // must depend on job client to pass fat-slot needs)\n    // these are no longer \"system\" settings, necessarily; user may override\n    int sysMaxMaps \u003d conf.getInt(MRJobConfig.JOB_UBERTASK_MAXMAPS, 9);\n\n    //FIXME: handling multiple reduces within a single AM does not seem to\n    //work.\n    // int sysMaxReduces \u003d\n    //     job.conf.getInt(MRJobConfig.JOB_UBERTASK_MAXREDUCES, 1);\n    int sysMaxReduces \u003d 1;\n\n    long sysMaxBytes \u003d conf.getLong(MRJobConfig.JOB_UBERTASK_MAXBYTES,\n        conf.getLong(\"dfs.block.size\", 64*1024*1024));  //FIXME: this is\n    // wrong; get FS from [File?]InputFormat and default block size from that\n\n    long sysMemSizeForUberSlot \u003d\n        conf.getInt(MRJobConfig.MR_AM_VMEM_MB,\n            MRJobConfig.DEFAULT_MR_AM_VMEM_MB);\n\n    boolean uberEnabled \u003d\n        conf.getBoolean(MRJobConfig.JOB_UBERTASK_ENABLE, false);\n    boolean smallNumMapTasks \u003d (numMapTasks \u003c\u003d sysMaxMaps);\n    boolean smallNumReduceTasks \u003d (numReduceTasks \u003c\u003d sysMaxReduces);\n    boolean smallInput \u003d (dataInputLength \u003c\u003d sysMaxBytes);\n    // ignoring overhead due to UberAM and statics as negligible here:\n    boolean smallMemory \u003d\n        ( (Math.max(conf.getLong(MRJobConfig.MAP_MEMORY_MB, 0),\n            conf.getLong(MRJobConfig.REDUCE_MEMORY_MB, 0))\n            \u003c\u003d sysMemSizeForUberSlot)\n            || (sysMemSizeForUberSlot \u003d\u003d JobConf.DISABLED_MEMORY_LIMIT));\n    boolean notChainJob \u003d !isChainJob(conf);\n\n    // User has overall veto power over uberization, or user can modify\n    // limits (overriding system settings and potentially shooting\n    // themselves in the head).  Note that ChainMapper/Reducer are\n    // fundamentally incompatible with MR-1220; they employ a blocking\n    // queue between the maps/reduces and thus require parallel execution,\n    // while \"uber-AM\" (MR AM + LocalContainerLauncher) loops over tasks\n    // and thus requires sequential execution.\n    isUber \u003d uberEnabled \u0026\u0026 smallNumMapTasks \u0026\u0026 smallNumReduceTasks\n        \u0026\u0026 smallInput \u0026\u0026 smallMemory \u0026\u0026 notChainJob;\n\n    if (isUber) {\n      LOG.info(\"Uberizing job \" + jobId + \": \" + numMapTasks + \"m+\"\n          + numReduceTasks + \"r tasks (\" + dataInputLength\n          + \" input bytes) will run sequentially on single node.\");\n\n      // make sure reduces are scheduled only after all map are completed\n      conf.setFloat(MRJobConfig.COMPLETED_MAPS_FOR_REDUCE_SLOWSTART,\n                        1.0f);\n      // uber-subtask attempts all get launched on same node; if one fails,\n      // probably should retry elsewhere, i.e., move entire uber-AM:  ergo,\n      // limit attempts to 1 (or at most 2?  probably not...)\n      conf.setInt(MRJobConfig.MAP_MAX_ATTEMPTS, 1);\n      conf.setInt(MRJobConfig.REDUCE_MAX_ATTEMPTS, 1);\n\n      // disable speculation\n      conf.setBoolean(MRJobConfig.MAP_SPECULATIVE, false);\n      conf.setBoolean(MRJobConfig.REDUCE_SPECULATIVE, false);\n    } else {\n      StringBuilder msg \u003d new StringBuilder();\n      msg.append(\"Not uberizing \").append(jobId).append(\" because:\");\n      if (!uberEnabled)\n        msg.append(\" not enabled;\");\n      if (!smallNumMapTasks)\n        msg.append(\" too many maps;\");\n      if (!smallNumReduceTasks)\n        msg.append(\" too many reduces;\");\n      if (!smallInput)\n        msg.append(\" too much input;\");\n      if (!smallMemory)\n        msg.append(\" too much RAM;\");\n      if (!notChainJob)\n        msg.append(\" chainjob\");\n      LOG.info(msg.toString());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/JobImpl.java"
    }
  }
}