{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ReadBufferManager.java",
  "functionName": "tryEvict",
  "functionId": "tryEvict",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/ReadBufferManager.java",
  "functionStartLine": 215,
  "functionEndLine": 258,
  "numCommitsSeen": 3,
  "timeTaken": 961,
  "changeHistory": [
    "53b993e6048ffaaf98e460690211fc08efb20cf2",
    "f044deedbbfee0812316d587139cb828f27172e9"
  ],
  "changeHistoryShort": {
    "53b993e6048ffaaf98e460690211fc08efb20cf2": "Ybodychange",
    "f044deedbbfee0812316d587139cb828f27172e9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "53b993e6048ffaaf98e460690211fc08efb20cf2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16852: Report read-ahead error back\n\nContributed by Sneha Vijayarajan",
      "commitDate": "27/05/20 1:51 PM",
      "commitName": "53b993e6048ffaaf98e460690211fc08efb20cf2",
      "commitAuthor": "Sneha Vijayarajan",
      "commitDateOld": "17/09/18 12:54 PM",
      "commitNameOld": "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be",
      "commitAuthorOld": "Thomas Marquardt",
      "daysBetweenCommits": 618.04,
      "commitsBetweenForRepo": 3845,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n   private synchronized boolean tryEvict() {\n     ReadBuffer nodeToEvict \u003d null;\n     if (completedReadList.size() \u003c\u003d 0) {\n       return false;  // there are no evict-able buffers\n     }\n \n     // first, try buffers where all bytes have been consumed (approximated as first and last bytes consumed)\n     for (ReadBuffer buf : completedReadList) {\n       if (buf.isFirstByteConsumed() \u0026\u0026 buf.isLastByteConsumed()) {\n         nodeToEvict \u003d buf;\n         break;\n       }\n     }\n     if (nodeToEvict !\u003d null) {\n       return evict(nodeToEvict);\n     }\n \n     // next, try buffers where any bytes have been consumed (may be a bad idea? have to experiment and see)\n     for (ReadBuffer buf : completedReadList) {\n       if (buf.isAnyByteConsumed()) {\n         nodeToEvict \u003d buf;\n         break;\n       }\n     }\n \n     if (nodeToEvict !\u003d null) {\n       return evict(nodeToEvict);\n     }\n \n     // next, try any old nodes that have not been consumed\n     long earliestBirthday \u003d Long.MAX_VALUE;\n     for (ReadBuffer buf : completedReadList) {\n       if (buf.getTimeStamp() \u003c earliestBirthday) {\n         nodeToEvict \u003d buf;\n         earliestBirthday \u003d buf.getTimeStamp();\n       }\n     }\n-    if ((currentTimeMillis() - earliestBirthday \u003e THRESHOLD_AGE_MILLISECONDS) \u0026\u0026 (nodeToEvict !\u003d null)) {\n+    if ((currentTimeMillis() - earliestBirthday \u003e thresholdAgeMilliseconds) \u0026\u0026 (nodeToEvict !\u003d null)) {\n       return evict(nodeToEvict);\n     }\n \n     // nothing can be evicted\n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized boolean tryEvict() {\n    ReadBuffer nodeToEvict \u003d null;\n    if (completedReadList.size() \u003c\u003d 0) {\n      return false;  // there are no evict-able buffers\n    }\n\n    // first, try buffers where all bytes have been consumed (approximated as first and last bytes consumed)\n    for (ReadBuffer buf : completedReadList) {\n      if (buf.isFirstByteConsumed() \u0026\u0026 buf.isLastByteConsumed()) {\n        nodeToEvict \u003d buf;\n        break;\n      }\n    }\n    if (nodeToEvict !\u003d null) {\n      return evict(nodeToEvict);\n    }\n\n    // next, try buffers where any bytes have been consumed (may be a bad idea? have to experiment and see)\n    for (ReadBuffer buf : completedReadList) {\n      if (buf.isAnyByteConsumed()) {\n        nodeToEvict \u003d buf;\n        break;\n      }\n    }\n\n    if (nodeToEvict !\u003d null) {\n      return evict(nodeToEvict);\n    }\n\n    // next, try any old nodes that have not been consumed\n    long earliestBirthday \u003d Long.MAX_VALUE;\n    for (ReadBuffer buf : completedReadList) {\n      if (buf.getTimeStamp() \u003c earliestBirthday) {\n        nodeToEvict \u003d buf;\n        earliestBirthday \u003d buf.getTimeStamp();\n      }\n    }\n    if ((currentTimeMillis() - earliestBirthday \u003e thresholdAgeMilliseconds) \u0026\u0026 (nodeToEvict !\u003d null)) {\n      return evict(nodeToEvict);\n    }\n\n    // nothing can be evicted\n    return false;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/ReadBufferManager.java",
      "extendedDetails": {}
    },
    "f044deedbbfee0812316d587139cb828f27172e9": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15407. HADOOP-15540. Support Windows Azure Storage - Blob file system \"ABFS\" in Hadoop: Core Commit.\n\nContributed by Shane Mainali, Thomas Marquardt, Zichen Sun, Georgi Chalakov, Esfandiar Manii, Amit Singh, Dana Kaban, Da Zhou, Junhua Gu, Saher Ahwal, Saurabh Pant, James Baker, Shaoyu Zhang, Lawrence Chen, Kevin Chen and Steve Loughran\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "f044deedbbfee0812316d587139cb828f27172e9",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,44 @@\n+  private synchronized boolean tryEvict() {\n+    ReadBuffer nodeToEvict \u003d null;\n+    if (completedReadList.size() \u003c\u003d 0) {\n+      return false;  // there are no evict-able buffers\n+    }\n+\n+    // first, try buffers where all bytes have been consumed (approximated as first and last bytes consumed)\n+    for (ReadBuffer buf : completedReadList) {\n+      if (buf.isFirstByteConsumed() \u0026\u0026 buf.isLastByteConsumed()) {\n+        nodeToEvict \u003d buf;\n+        break;\n+      }\n+    }\n+    if (nodeToEvict !\u003d null) {\n+      return evict(nodeToEvict);\n+    }\n+\n+    // next, try buffers where any bytes have been consumed (may be a bad idea? have to experiment and see)\n+    for (ReadBuffer buf : completedReadList) {\n+      if (buf.isAnyByteConsumed()) {\n+        nodeToEvict \u003d buf;\n+        break;\n+      }\n+    }\n+\n+    if (nodeToEvict !\u003d null) {\n+      return evict(nodeToEvict);\n+    }\n+\n+    // next, try any old nodes that have not been consumed\n+    long earliestBirthday \u003d Long.MAX_VALUE;\n+    for (ReadBuffer buf : completedReadList) {\n+      if (buf.getTimeStamp() \u003c earliestBirthday) {\n+        nodeToEvict \u003d buf;\n+        earliestBirthday \u003d buf.getTimeStamp();\n+      }\n+    }\n+    if ((currentTimeMillis() - earliestBirthday \u003e THRESHOLD_AGE_MILLISECONDS) \u0026\u0026 (nodeToEvict !\u003d null)) {\n+      return evict(nodeToEvict);\n+    }\n+\n+    // nothing can be evicted\n+    return false;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized boolean tryEvict() {\n    ReadBuffer nodeToEvict \u003d null;\n    if (completedReadList.size() \u003c\u003d 0) {\n      return false;  // there are no evict-able buffers\n    }\n\n    // first, try buffers where all bytes have been consumed (approximated as first and last bytes consumed)\n    for (ReadBuffer buf : completedReadList) {\n      if (buf.isFirstByteConsumed() \u0026\u0026 buf.isLastByteConsumed()) {\n        nodeToEvict \u003d buf;\n        break;\n      }\n    }\n    if (nodeToEvict !\u003d null) {\n      return evict(nodeToEvict);\n    }\n\n    // next, try buffers where any bytes have been consumed (may be a bad idea? have to experiment and see)\n    for (ReadBuffer buf : completedReadList) {\n      if (buf.isAnyByteConsumed()) {\n        nodeToEvict \u003d buf;\n        break;\n      }\n    }\n\n    if (nodeToEvict !\u003d null) {\n      return evict(nodeToEvict);\n    }\n\n    // next, try any old nodes that have not been consumed\n    long earliestBirthday \u003d Long.MAX_VALUE;\n    for (ReadBuffer buf : completedReadList) {\n      if (buf.getTimeStamp() \u003c earliestBirthday) {\n        nodeToEvict \u003d buf;\n        earliestBirthday \u003d buf.getTimeStamp();\n      }\n    }\n    if ((currentTimeMillis() - earliestBirthday \u003e THRESHOLD_AGE_MILLISECONDS) \u0026\u0026 (nodeToEvict !\u003d null)) {\n      return evict(nodeToEvict);\n    }\n\n    // nothing can be evicted\n    return false;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/ReadBufferManager.java"
    }
  }
}