{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FsVolumeImpl.java",
  "functionName": "nextBlock",
  "functionId": "nextBlock",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
  "functionStartLine": 778,
  "functionEndLine": 831,
  "numCommitsSeen": 71,
  "timeTaken": 3048,
  "changeHistory": [
    "7820737cfa178d9de1bcbb1e99b9677d70901914",
    "0d1c1152f1ce2706f92109bfbdff0d62e98e6797",
    "6e62a1a6728b1f782f64065424f92b292c3f163a"
  ],
  "changeHistoryShort": {
    "7820737cfa178d9de1bcbb1e99b9677d70901914": "Ybodychange",
    "0d1c1152f1ce2706f92109bfbdff0d62e98e6797": "Ybodychange",
    "6e62a1a6728b1f782f64065424f92b292c3f163a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7820737cfa178d9de1bcbb1e99b9677d70901914": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9735. DiskBalancer : Refactor moveBlockAcrossStorage to be used by disk balancer. Contributed by Anu Engineer.\n",
      "commitDate": "23/06/16 6:20 PM",
      "commitName": "7820737cfa178d9de1bcbb1e99b9677d70901914",
      "commitAuthor": "Anu Engineer",
      "commitDateOld": "03/05/16 4:52 PM",
      "commitNameOld": "6d77d6eab7790ed7ae2cad5b327ba5d1deb485db",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 51.06,
      "commitsBetweenForRepo": 368,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,54 @@\n     public ExtendedBlock nextBlock() throws IOException {\n       if (state.atEnd) {\n         return null;\n       }\n       try {\n         while (true) {\n           List\u003cString\u003e entries \u003d getSubdirEntries();\n           if (entries !\u003d null) {\n             state.curEntry \u003d nextSorted(entries, state.curEntry);\n             if (state.curEntry \u003d\u003d null) {\n               LOG.trace(\"nextBlock({}, {}): advancing from {} to next \" +\n                   \"subdirectory.\", storageID, bpid, state.curFinalizedSubDir);\n             } else {\n               ExtendedBlock block \u003d\n                   new ExtendedBlock(bpid, Block.filename2id(state.curEntry));\n               File expectedBlockDir \u003d DatanodeUtil.idToBlockDir(\n                   new File(\".\"), block.getBlockId());\n               File actualBlockDir \u003d Paths.get(\".\",\n                   state.curFinalizedDir, state.curFinalizedSubDir).toFile();\n               if (!expectedBlockDir.equals(actualBlockDir)) {\n                 LOG.error(\"nextBlock({}, {}): block id {} found in invalid \" +\n                     \"directory.  Expected directory: {}.  \" +\n                     \"Actual directory: {}\", storageID, bpid,\n                     block.getBlockId(), expectedBlockDir.getPath(),\n                     actualBlockDir.getPath());\n                 continue;\n               }\n+\n+              File blkFile \u003d getBlockFile(bpid, block);\n+              File metaFile \u003d FsDatasetUtil.findMetaFile(blkFile);\n+              block.setGenerationStamp(\n+                  Block.getGenerationStamp(metaFile.getName()));\n+              block.setNumBytes(blkFile.length());\n+\n               LOG.trace(\"nextBlock({}, {}): advancing to {}\",\n                   storageID, bpid, block);\n               return block;\n             }\n           }\n           state.curFinalizedSubDir \u003d getNextFinalizedSubDir();\n           if (state.curFinalizedSubDir \u003d\u003d null) {\n             state.curFinalizedDir \u003d getNextFinalizedDir();\n             if (state.curFinalizedDir \u003d\u003d null) {\n               state.atEnd \u003d true;\n               return null;\n             }\n           }\n         }\n       } catch (IOException e) {\n         state.atEnd \u003d true;\n         LOG.error(\"nextBlock({}, {}): I/O error\", storageID, bpid, e);\n         throw e;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ExtendedBlock nextBlock() throws IOException {\n      if (state.atEnd) {\n        return null;\n      }\n      try {\n        while (true) {\n          List\u003cString\u003e entries \u003d getSubdirEntries();\n          if (entries !\u003d null) {\n            state.curEntry \u003d nextSorted(entries, state.curEntry);\n            if (state.curEntry \u003d\u003d null) {\n              LOG.trace(\"nextBlock({}, {}): advancing from {} to next \" +\n                  \"subdirectory.\", storageID, bpid, state.curFinalizedSubDir);\n            } else {\n              ExtendedBlock block \u003d\n                  new ExtendedBlock(bpid, Block.filename2id(state.curEntry));\n              File expectedBlockDir \u003d DatanodeUtil.idToBlockDir(\n                  new File(\".\"), block.getBlockId());\n              File actualBlockDir \u003d Paths.get(\".\",\n                  state.curFinalizedDir, state.curFinalizedSubDir).toFile();\n              if (!expectedBlockDir.equals(actualBlockDir)) {\n                LOG.error(\"nextBlock({}, {}): block id {} found in invalid \" +\n                    \"directory.  Expected directory: {}.  \" +\n                    \"Actual directory: {}\", storageID, bpid,\n                    block.getBlockId(), expectedBlockDir.getPath(),\n                    actualBlockDir.getPath());\n                continue;\n              }\n\n              File blkFile \u003d getBlockFile(bpid, block);\n              File metaFile \u003d FsDatasetUtil.findMetaFile(blkFile);\n              block.setGenerationStamp(\n                  Block.getGenerationStamp(metaFile.getName()));\n              block.setNumBytes(blkFile.length());\n\n              LOG.trace(\"nextBlock({}, {}): advancing to {}\",\n                  storageID, bpid, block);\n              return block;\n            }\n          }\n          state.curFinalizedSubDir \u003d getNextFinalizedSubDir();\n          if (state.curFinalizedSubDir \u003d\u003d null) {\n            state.curFinalizedDir \u003d getNextFinalizedDir();\n            if (state.curFinalizedDir \u003d\u003d null) {\n              state.atEnd \u003d true;\n              return null;\n            }\n          }\n        }\n      } catch (IOException e) {\n        state.atEnd \u003d true;\n        LOG.error(\"nextBlock({}, {}): I/O error\", storageID, bpid, e);\n        throw e;\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
      "extendedDetails": {}
    },
    "0d1c1152f1ce2706f92109bfbdff0d62e98e6797": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10282. The VolumeScanner should warn about replica files which are misplaced. Contributed by Colin Patrick McCabe.\n",
      "commitDate": "14/04/16 5:58 AM",
      "commitName": "0d1c1152f1ce2706f92109bfbdff0d62e98e6797",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "18/03/16 8:24 AM",
      "commitNameOld": "63c966a3fbeb675959fc4101e65de9f57aecd17d",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 26.9,
      "commitsBetweenForRepo": 162,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,47 @@\n     public ExtendedBlock nextBlock() throws IOException {\n       if (state.atEnd) {\n         return null;\n       }\n       try {\n         while (true) {\n           List\u003cString\u003e entries \u003d getSubdirEntries();\n           if (entries !\u003d null) {\n             state.curEntry \u003d nextSorted(entries, state.curEntry);\n             if (state.curEntry \u003d\u003d null) {\n               LOG.trace(\"nextBlock({}, {}): advancing from {} to next \" +\n                   \"subdirectory.\", storageID, bpid, state.curFinalizedSubDir);\n             } else {\n               ExtendedBlock block \u003d\n                   new ExtendedBlock(bpid, Block.filename2id(state.curEntry));\n+              File expectedBlockDir \u003d DatanodeUtil.idToBlockDir(\n+                  new File(\".\"), block.getBlockId());\n+              File actualBlockDir \u003d Paths.get(\".\",\n+                  state.curFinalizedDir, state.curFinalizedSubDir).toFile();\n+              if (!expectedBlockDir.equals(actualBlockDir)) {\n+                LOG.error(\"nextBlock({}, {}): block id {} found in invalid \" +\n+                    \"directory.  Expected directory: {}.  \" +\n+                    \"Actual directory: {}\", storageID, bpid,\n+                    block.getBlockId(), expectedBlockDir.getPath(),\n+                    actualBlockDir.getPath());\n+                continue;\n+              }\n               LOG.trace(\"nextBlock({}, {}): advancing to {}\",\n                   storageID, bpid, block);\n               return block;\n             }\n           }\n           state.curFinalizedSubDir \u003d getNextFinalizedSubDir();\n           if (state.curFinalizedSubDir \u003d\u003d null) {\n             state.curFinalizedDir \u003d getNextFinalizedDir();\n             if (state.curFinalizedDir \u003d\u003d null) {\n               state.atEnd \u003d true;\n               return null;\n             }\n           }\n         }\n       } catch (IOException e) {\n         state.atEnd \u003d true;\n         LOG.error(\"nextBlock({}, {}): I/O error\", storageID, bpid, e);\n         throw e;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ExtendedBlock nextBlock() throws IOException {\n      if (state.atEnd) {\n        return null;\n      }\n      try {\n        while (true) {\n          List\u003cString\u003e entries \u003d getSubdirEntries();\n          if (entries !\u003d null) {\n            state.curEntry \u003d nextSorted(entries, state.curEntry);\n            if (state.curEntry \u003d\u003d null) {\n              LOG.trace(\"nextBlock({}, {}): advancing from {} to next \" +\n                  \"subdirectory.\", storageID, bpid, state.curFinalizedSubDir);\n            } else {\n              ExtendedBlock block \u003d\n                  new ExtendedBlock(bpid, Block.filename2id(state.curEntry));\n              File expectedBlockDir \u003d DatanodeUtil.idToBlockDir(\n                  new File(\".\"), block.getBlockId());\n              File actualBlockDir \u003d Paths.get(\".\",\n                  state.curFinalizedDir, state.curFinalizedSubDir).toFile();\n              if (!expectedBlockDir.equals(actualBlockDir)) {\n                LOG.error(\"nextBlock({}, {}): block id {} found in invalid \" +\n                    \"directory.  Expected directory: {}.  \" +\n                    \"Actual directory: {}\", storageID, bpid,\n                    block.getBlockId(), expectedBlockDir.getPath(),\n                    actualBlockDir.getPath());\n                continue;\n              }\n              LOG.trace(\"nextBlock({}, {}): advancing to {}\",\n                  storageID, bpid, block);\n              return block;\n            }\n          }\n          state.curFinalizedSubDir \u003d getNextFinalizedSubDir();\n          if (state.curFinalizedSubDir \u003d\u003d null) {\n            state.curFinalizedDir \u003d getNextFinalizedDir();\n            if (state.curFinalizedDir \u003d\u003d null) {\n              state.atEnd \u003d true;\n              return null;\n            }\n          }\n        }\n      } catch (IOException e) {\n        state.atEnd \u003d true;\n        LOG.error(\"nextBlock({}, {}): I/O error\", storageID, bpid, e);\n        throw e;\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java",
      "extendedDetails": {}
    },
    "6e62a1a6728b1f782f64065424f92b292c3f163a": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7430. Refactor the BlockScanner to use O(1) memory and use multiple threads (cmccabe)\n",
      "commitDate": "21/01/15 7:00 PM",
      "commitName": "6e62a1a6728b1f782f64065424f92b292c3f163a",
      "commitAuthor": "Colin Patrick Mccabe",
      "diff": "@@ -0,0 +1,35 @@\n+    public ExtendedBlock nextBlock() throws IOException {\n+      if (state.atEnd) {\n+        return null;\n+      }\n+      try {\n+        while (true) {\n+          List\u003cString\u003e entries \u003d getSubdirEntries();\n+          if (entries !\u003d null) {\n+            state.curEntry \u003d nextSorted(entries, state.curEntry);\n+            if (state.curEntry \u003d\u003d null) {\n+              LOG.trace(\"nextBlock({}, {}): advancing from {} to next \" +\n+                  \"subdirectory.\", storageID, bpid, state.curFinalizedSubDir);\n+            } else {\n+              ExtendedBlock block \u003d\n+                  new ExtendedBlock(bpid, Block.filename2id(state.curEntry));\n+              LOG.trace(\"nextBlock({}, {}): advancing to {}\",\n+                  storageID, bpid, block);\n+              return block;\n+            }\n+          }\n+          state.curFinalizedSubDir \u003d getNextFinalizedSubDir();\n+          if (state.curFinalizedSubDir \u003d\u003d null) {\n+            state.curFinalizedDir \u003d getNextFinalizedDir();\n+            if (state.curFinalizedDir \u003d\u003d null) {\n+              state.atEnd \u003d true;\n+              return null;\n+            }\n+          }\n+        }\n+      } catch (IOException e) {\n+        state.atEnd \u003d true;\n+        LOG.error(\"nextBlock({}, {}): I/O error\", storageID, bpid, e);\n+        throw e;\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public ExtendedBlock nextBlock() throws IOException {\n      if (state.atEnd) {\n        return null;\n      }\n      try {\n        while (true) {\n          List\u003cString\u003e entries \u003d getSubdirEntries();\n          if (entries !\u003d null) {\n            state.curEntry \u003d nextSorted(entries, state.curEntry);\n            if (state.curEntry \u003d\u003d null) {\n              LOG.trace(\"nextBlock({}, {}): advancing from {} to next \" +\n                  \"subdirectory.\", storageID, bpid, state.curFinalizedSubDir);\n            } else {\n              ExtendedBlock block \u003d\n                  new ExtendedBlock(bpid, Block.filename2id(state.curEntry));\n              LOG.trace(\"nextBlock({}, {}): advancing to {}\",\n                  storageID, bpid, block);\n              return block;\n            }\n          }\n          state.curFinalizedSubDir \u003d getNextFinalizedSubDir();\n          if (state.curFinalizedSubDir \u003d\u003d null) {\n            state.curFinalizedDir \u003d getNextFinalizedDir();\n            if (state.curFinalizedDir \u003d\u003d null) {\n              state.atEnd \u003d true;\n              return null;\n            }\n          }\n        }\n      } catch (IOException e) {\n        state.atEnd \u003d true;\n        LOG.error(\"nextBlock({}, {}): I/O error\", storageID, bpid, e);\n        throw e;\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsVolumeImpl.java"
    }
  }
}