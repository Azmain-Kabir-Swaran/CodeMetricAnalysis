{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NodeAttributesCLI.java",
  "functionName": "buildNodeLabelsListFromStr",
  "functionId": "buildNodeLabelsListFromStr___args-String__validateForAttributes-boolean__operation-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/NodeAttributesCLI.java",
  "functionStartLine": 597,
  "functionEndLine": 691,
  "numCommitsSeen": 6,
  "timeTaken": 3726,
  "changeHistory": [
    "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1",
    "901e85238da08129374d44af80716b07f0b912e6",
    "2475fb0a1e2158aac11829c6e33eae3e02bf33ea"
  ],
  "changeHistoryShort": {
    "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1": "Ymultichange(Ymovefromfile,Ybodychange,Yrename,Yparameterchange)",
    "901e85238da08129374d44af80716b07f0b912e6": "Ybodychange",
    "2475fb0a1e2158aac11829c6e33eae3e02bf33ea": "Yintroduced"
  },
  "changeHistoryDetails": {
    "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yrename,Yparameterchange)",
      "commitMessage": "YARN-8103. Add CLI interface to query node attributes. Contributed by Bibin A Chundatt.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1",
      "commitAuthor": "Naganarasimha",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-8103. Add CLI interface to query node attributes. Contributed by Bibin A Chundatt.\n",
          "commitDate": "12/09/18 3:31 AM",
          "commitName": "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1",
          "commitAuthor": "Naganarasimha",
          "commitDateOld": "12/09/18 3:31 AM",
          "commitNameOld": "76183428b76524818fc250ae97bbf973dc910e1c",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 2,
          "diff": "@@ -1,94 +1,95 @@\n-  private List\u003cNodeToAttributes\u003e buildNodeLabelsMapFromStr(String args,\n-      boolean validateForAttributes, AttributeMappingOperationType operation) {\n-    Map\u003cString,NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n-    for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n-      // for each node to attribute mapping\n-      nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n-      if (nodeToAttributesStr.isEmpty()\n-          || nodeToAttributesStr.startsWith(\"#\")) {\n-        continue;\n-      }\n-      if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n-        throw new IllegalArgumentException(\n-            INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n-      }\n-      String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n-      Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n-          \"Node name cannot be empty\");\n-      String node \u003d nodeToAttributes[0];\n-      String[] attributeNameValueType \u003d null;\n-      List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n-      NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n-      String attributeValue;\n-      String attributeName;\n-      Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n-\n-      String attributesStr[];\n-      if (nodeToAttributes.length \u003d\u003d 2) {\n-        // fetching multiple attributes for a node\n-        attributesStr \u003d nodeToAttributes[1].split(\",\");\n-        for (String attributeStr : attributesStr) {\n-          // get information about each attribute.\n-          attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n-                                                            // value\n-          Preconditions.checkArgument(\n-              !(attributeNameValueType[0] \u003d\u003d null\n-                  || attributeNameValueType[0].isEmpty()),\n-              \"Attribute name cannot be null or empty\");\n-          attributeValue \u003d attributeNameValueType.length \u003e 1\n-              ? attributeNameValueType[1] : \"\";\n-          int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n-          if (indexOfOpenBracket \u003d\u003d -1) {\n-            attributeName \u003d attributeNameValueType[0];\n-          } else if (indexOfOpenBracket \u003d\u003d 0) {\n-            throw new IllegalArgumentException(\"Attribute for node \" + node\n-                + \" is not properly configured : \" + attributeStr);\n-          } else {\n-            // attribute type has been explicitly configured\n-            int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n-            if (indexOfCloseBracket \u003d\u003d -1\n-                || indexOfCloseBracket \u003c indexOfOpenBracket) {\n-              throw new IllegalArgumentException(\"Attribute for node \" + node\n-                  + \" is not properly Configured : \" + attributeStr);\n-            }\n-            String attributeTypeStr;\n-            attributeName \u003d\n-                attributeNameValueType[0].substring(0, indexOfOpenBracket);\n-            attributeTypeStr \u003d attributeNameValueType[0]\n-                .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n-            try {\n-              attributeType \u003d NodeAttributeType\n-                  .valueOf(attributeTypeStr.trim().toUpperCase());\n-            } catch (IllegalArgumentException e) {\n-              throw new IllegalArgumentException(\n-                  \"Invalid Attribute type configuration : \" + attributeTypeStr\n-                      + \" in \" + attributeStr);\n-            }\n-          }\n-          if (attributeNamesMapped.contains(attributeName)) {\n-            throw new IllegalArgumentException(\"Attribute \" + attributeName\n-                + \" has been mapped more than once in  : \"\n-                + nodeToAttributesStr);\n-          }\n-          // TODO when we support different type of attribute type we need to\n-          // cross verify whether input attributes itself is not violating\n-          // attribute Name to Type mapping.\n-          attributesList\n-              .add(NodeAttribute.newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n-                  attributeName.trim(), attributeType, attributeValue.trim()));\n+    private List\u003cNodeToAttributes\u003e buildNodeLabelsListFromStr(String args,\n+        boolean validateForAttributes, String operation) {\n+      Map\u003cString, NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n+      for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n+        // for each node to attribute mapping\n+        nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n+        if (nodeToAttributesStr.isEmpty() || nodeToAttributesStr\n+            .startsWith(\"#\")) {\n+          continue;\n         }\n-      }\n-      if (validateForAttributes) {\n-        Preconditions.checkArgument((attributesList.size() \u003e 0),\n-            \"Attributes cannot be null or empty for Operation \"\n-                + operation.name() + \" on the node \" + node);\n-      }\n-      nodeToAttributesMap\n-          .put(node,NodeToAttributes.newInstance(node, attributesList));\n-    }\n+        if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n+          throw new IllegalArgumentException(\n+              INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n+        }\n+        String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n+        Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n+            \"Node name cannot be empty\");\n+        String node \u003d nodeToAttributes[0];\n+        String[] attributeNameValueType \u003d null;\n+        List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n+        NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n+        String attributeValue;\n+        String attributeName;\n+        Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n \n-    if (nodeToAttributesMap.isEmpty()) {\n-      throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n-    }\n-    return Lists.newArrayList(nodeToAttributesMap.values());\n-  }\n\\ No newline at end of file\n+        String[] attributesStr;\n+        if (nodeToAttributes.length \u003d\u003d 2) {\n+          // fetching multiple attributes for a node\n+          attributesStr \u003d nodeToAttributes[1].split(\",\");\n+          for (String attributeStr : attributesStr) {\n+            // get information about each attribute.\n+            attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n+            // value\n+            Preconditions.checkArgument(\n+                !(attributeNameValueType[0] \u003d\u003d null || attributeNameValueType[0]\n+                    .isEmpty()), \"Attribute name cannot be null or empty\");\n+            attributeValue \u003d attributeNameValueType.length \u003e 1 ?\n+                attributeNameValueType[1] :\n+                \"\";\n+            int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n+            if (indexOfOpenBracket \u003d\u003d -1) {\n+              attributeName \u003d attributeNameValueType[0];\n+            } else if (indexOfOpenBracket \u003d\u003d 0) {\n+              throw new IllegalArgumentException(\"Attribute for node \" + node\n+                  + \" is not properly configured : \" + attributeStr);\n+            } else {\n+              // attribute type has been explicitly configured\n+              int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n+              if (indexOfCloseBracket \u003d\u003d -1\n+                  || indexOfCloseBracket \u003c indexOfOpenBracket) {\n+                throw new IllegalArgumentException(\"Attribute for node \" + node\n+                    + \" is not properly Configured : \" + attributeStr);\n+              }\n+              String attributeTypeStr;\n+              attributeName \u003d\n+                  attributeNameValueType[0].substring(0, indexOfOpenBracket);\n+              attributeTypeStr \u003d attributeNameValueType[0]\n+                  .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n+              try {\n+                attributeType \u003d NodeAttributeType\n+                    .valueOf(attributeTypeStr.trim().toUpperCase());\n+              } catch (IllegalArgumentException e) {\n+                throw new IllegalArgumentException(\n+                    \"Invalid Attribute type configuration : \" + attributeTypeStr\n+                        + \" in \" + attributeStr);\n+              }\n+            }\n+            if (attributeNamesMapped.contains(attributeName)) {\n+              throw new IllegalArgumentException(\"Attribute \" + attributeName\n+                  + \" has been mapped more than once in  : \"\n+                  + nodeToAttributesStr);\n+            }\n+            // TODO when we support different type of attribute type we need to\n+            // cross verify whether input attributes itself is not violating\n+            // attribute Name to Type mapping.\n+            attributesList.add(NodeAttribute\n+                .newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n+                    attributeName.trim(), attributeType,\n+                    attributeValue.trim()));\n+          }\n+        }\n+        if (validateForAttributes) {\n+          Preconditions.checkArgument((attributesList.size() \u003e 0),\n+              \"Attributes cannot be null or empty for Operation [\" + operation\n+                  + \"] on the node \" + node);\n+        }\n+        nodeToAttributesMap\n+            .put(node, NodeToAttributes.newInstance(node, attributesList));\n+      }\n+\n+      if (nodeToAttributesMap.isEmpty()) {\n+        throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n+      }\n+      return Lists.newArrayList(nodeToAttributesMap.values());\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    private List\u003cNodeToAttributes\u003e buildNodeLabelsListFromStr(String args,\n        boolean validateForAttributes, String operation) {\n      Map\u003cString, NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n      for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n        // for each node to attribute mapping\n        nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n        if (nodeToAttributesStr.isEmpty() || nodeToAttributesStr\n            .startsWith(\"#\")) {\n          continue;\n        }\n        if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n          throw new IllegalArgumentException(\n              INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n        }\n        String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n        Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n            \"Node name cannot be empty\");\n        String node \u003d nodeToAttributes[0];\n        String[] attributeNameValueType \u003d null;\n        List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n        NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n        String attributeValue;\n        String attributeName;\n        Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n\n        String[] attributesStr;\n        if (nodeToAttributes.length \u003d\u003d 2) {\n          // fetching multiple attributes for a node\n          attributesStr \u003d nodeToAttributes[1].split(\",\");\n          for (String attributeStr : attributesStr) {\n            // get information about each attribute.\n            attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n            // value\n            Preconditions.checkArgument(\n                !(attributeNameValueType[0] \u003d\u003d null || attributeNameValueType[0]\n                    .isEmpty()), \"Attribute name cannot be null or empty\");\n            attributeValue \u003d attributeNameValueType.length \u003e 1 ?\n                attributeNameValueType[1] :\n                \"\";\n            int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n            if (indexOfOpenBracket \u003d\u003d -1) {\n              attributeName \u003d attributeNameValueType[0];\n            } else if (indexOfOpenBracket \u003d\u003d 0) {\n              throw new IllegalArgumentException(\"Attribute for node \" + node\n                  + \" is not properly configured : \" + attributeStr);\n            } else {\n              // attribute type has been explicitly configured\n              int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n              if (indexOfCloseBracket \u003d\u003d -1\n                  || indexOfCloseBracket \u003c indexOfOpenBracket) {\n                throw new IllegalArgumentException(\"Attribute for node \" + node\n                    + \" is not properly Configured : \" + attributeStr);\n              }\n              String attributeTypeStr;\n              attributeName \u003d\n                  attributeNameValueType[0].substring(0, indexOfOpenBracket);\n              attributeTypeStr \u003d attributeNameValueType[0]\n                  .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n              try {\n                attributeType \u003d NodeAttributeType\n                    .valueOf(attributeTypeStr.trim().toUpperCase());\n              } catch (IllegalArgumentException e) {\n                throw new IllegalArgumentException(\n                    \"Invalid Attribute type configuration : \" + attributeTypeStr\n                        + \" in \" + attributeStr);\n              }\n            }\n            if (attributeNamesMapped.contains(attributeName)) {\n              throw new IllegalArgumentException(\"Attribute \" + attributeName\n                  + \" has been mapped more than once in  : \"\n                  + nodeToAttributesStr);\n            }\n            // TODO when we support different type of attribute type we need to\n            // cross verify whether input attributes itself is not violating\n            // attribute Name to Type mapping.\n            attributesList.add(NodeAttribute\n                .newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n                    attributeName.trim(), attributeType,\n                    attributeValue.trim()));\n          }\n        }\n        if (validateForAttributes) {\n          Preconditions.checkArgument((attributesList.size() \u003e 0),\n              \"Attributes cannot be null or empty for Operation [\" + operation\n                  + \"] on the node \" + node);\n        }\n        nodeToAttributesMap\n            .put(node, NodeToAttributes.newInstance(node, attributesList));\n      }\n\n      if (nodeToAttributesMap.isEmpty()) {\n        throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n      }\n      return Lists.newArrayList(nodeToAttributesMap.values());\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/NodeAttributesCLI.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/NodeAttributesCLI.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/NodeAttributesCLI.java",
            "oldMethodName": "buildNodeLabelsMapFromStr",
            "newMethodName": "buildNodeLabelsListFromStr"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8103. Add CLI interface to query node attributes. Contributed by Bibin A Chundatt.\n",
          "commitDate": "12/09/18 3:31 AM",
          "commitName": "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1",
          "commitAuthor": "Naganarasimha",
          "commitDateOld": "12/09/18 3:31 AM",
          "commitNameOld": "76183428b76524818fc250ae97bbf973dc910e1c",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 2,
          "diff": "@@ -1,94 +1,95 @@\n-  private List\u003cNodeToAttributes\u003e buildNodeLabelsMapFromStr(String args,\n-      boolean validateForAttributes, AttributeMappingOperationType operation) {\n-    Map\u003cString,NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n-    for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n-      // for each node to attribute mapping\n-      nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n-      if (nodeToAttributesStr.isEmpty()\n-          || nodeToAttributesStr.startsWith(\"#\")) {\n-        continue;\n-      }\n-      if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n-        throw new IllegalArgumentException(\n-            INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n-      }\n-      String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n-      Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n-          \"Node name cannot be empty\");\n-      String node \u003d nodeToAttributes[0];\n-      String[] attributeNameValueType \u003d null;\n-      List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n-      NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n-      String attributeValue;\n-      String attributeName;\n-      Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n-\n-      String attributesStr[];\n-      if (nodeToAttributes.length \u003d\u003d 2) {\n-        // fetching multiple attributes for a node\n-        attributesStr \u003d nodeToAttributes[1].split(\",\");\n-        for (String attributeStr : attributesStr) {\n-          // get information about each attribute.\n-          attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n-                                                            // value\n-          Preconditions.checkArgument(\n-              !(attributeNameValueType[0] \u003d\u003d null\n-                  || attributeNameValueType[0].isEmpty()),\n-              \"Attribute name cannot be null or empty\");\n-          attributeValue \u003d attributeNameValueType.length \u003e 1\n-              ? attributeNameValueType[1] : \"\";\n-          int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n-          if (indexOfOpenBracket \u003d\u003d -1) {\n-            attributeName \u003d attributeNameValueType[0];\n-          } else if (indexOfOpenBracket \u003d\u003d 0) {\n-            throw new IllegalArgumentException(\"Attribute for node \" + node\n-                + \" is not properly configured : \" + attributeStr);\n-          } else {\n-            // attribute type has been explicitly configured\n-            int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n-            if (indexOfCloseBracket \u003d\u003d -1\n-                || indexOfCloseBracket \u003c indexOfOpenBracket) {\n-              throw new IllegalArgumentException(\"Attribute for node \" + node\n-                  + \" is not properly Configured : \" + attributeStr);\n-            }\n-            String attributeTypeStr;\n-            attributeName \u003d\n-                attributeNameValueType[0].substring(0, indexOfOpenBracket);\n-            attributeTypeStr \u003d attributeNameValueType[0]\n-                .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n-            try {\n-              attributeType \u003d NodeAttributeType\n-                  .valueOf(attributeTypeStr.trim().toUpperCase());\n-            } catch (IllegalArgumentException e) {\n-              throw new IllegalArgumentException(\n-                  \"Invalid Attribute type configuration : \" + attributeTypeStr\n-                      + \" in \" + attributeStr);\n-            }\n-          }\n-          if (attributeNamesMapped.contains(attributeName)) {\n-            throw new IllegalArgumentException(\"Attribute \" + attributeName\n-                + \" has been mapped more than once in  : \"\n-                + nodeToAttributesStr);\n-          }\n-          // TODO when we support different type of attribute type we need to\n-          // cross verify whether input attributes itself is not violating\n-          // attribute Name to Type mapping.\n-          attributesList\n-              .add(NodeAttribute.newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n-                  attributeName.trim(), attributeType, attributeValue.trim()));\n+    private List\u003cNodeToAttributes\u003e buildNodeLabelsListFromStr(String args,\n+        boolean validateForAttributes, String operation) {\n+      Map\u003cString, NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n+      for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n+        // for each node to attribute mapping\n+        nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n+        if (nodeToAttributesStr.isEmpty() || nodeToAttributesStr\n+            .startsWith(\"#\")) {\n+          continue;\n         }\n-      }\n-      if (validateForAttributes) {\n-        Preconditions.checkArgument((attributesList.size() \u003e 0),\n-            \"Attributes cannot be null or empty for Operation \"\n-                + operation.name() + \" on the node \" + node);\n-      }\n-      nodeToAttributesMap\n-          .put(node,NodeToAttributes.newInstance(node, attributesList));\n-    }\n+        if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n+          throw new IllegalArgumentException(\n+              INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n+        }\n+        String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n+        Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n+            \"Node name cannot be empty\");\n+        String node \u003d nodeToAttributes[0];\n+        String[] attributeNameValueType \u003d null;\n+        List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n+        NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n+        String attributeValue;\n+        String attributeName;\n+        Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n \n-    if (nodeToAttributesMap.isEmpty()) {\n-      throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n-    }\n-    return Lists.newArrayList(nodeToAttributesMap.values());\n-  }\n\\ No newline at end of file\n+        String[] attributesStr;\n+        if (nodeToAttributes.length \u003d\u003d 2) {\n+          // fetching multiple attributes for a node\n+          attributesStr \u003d nodeToAttributes[1].split(\",\");\n+          for (String attributeStr : attributesStr) {\n+            // get information about each attribute.\n+            attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n+            // value\n+            Preconditions.checkArgument(\n+                !(attributeNameValueType[0] \u003d\u003d null || attributeNameValueType[0]\n+                    .isEmpty()), \"Attribute name cannot be null or empty\");\n+            attributeValue \u003d attributeNameValueType.length \u003e 1 ?\n+                attributeNameValueType[1] :\n+                \"\";\n+            int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n+            if (indexOfOpenBracket \u003d\u003d -1) {\n+              attributeName \u003d attributeNameValueType[0];\n+            } else if (indexOfOpenBracket \u003d\u003d 0) {\n+              throw new IllegalArgumentException(\"Attribute for node \" + node\n+                  + \" is not properly configured : \" + attributeStr);\n+            } else {\n+              // attribute type has been explicitly configured\n+              int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n+              if (indexOfCloseBracket \u003d\u003d -1\n+                  || indexOfCloseBracket \u003c indexOfOpenBracket) {\n+                throw new IllegalArgumentException(\"Attribute for node \" + node\n+                    + \" is not properly Configured : \" + attributeStr);\n+              }\n+              String attributeTypeStr;\n+              attributeName \u003d\n+                  attributeNameValueType[0].substring(0, indexOfOpenBracket);\n+              attributeTypeStr \u003d attributeNameValueType[0]\n+                  .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n+              try {\n+                attributeType \u003d NodeAttributeType\n+                    .valueOf(attributeTypeStr.trim().toUpperCase());\n+              } catch (IllegalArgumentException e) {\n+                throw new IllegalArgumentException(\n+                    \"Invalid Attribute type configuration : \" + attributeTypeStr\n+                        + \" in \" + attributeStr);\n+              }\n+            }\n+            if (attributeNamesMapped.contains(attributeName)) {\n+              throw new IllegalArgumentException(\"Attribute \" + attributeName\n+                  + \" has been mapped more than once in  : \"\n+                  + nodeToAttributesStr);\n+            }\n+            // TODO when we support different type of attribute type we need to\n+            // cross verify whether input attributes itself is not violating\n+            // attribute Name to Type mapping.\n+            attributesList.add(NodeAttribute\n+                .newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n+                    attributeName.trim(), attributeType,\n+                    attributeValue.trim()));\n+          }\n+        }\n+        if (validateForAttributes) {\n+          Preconditions.checkArgument((attributesList.size() \u003e 0),\n+              \"Attributes cannot be null or empty for Operation [\" + operation\n+                  + \"] on the node \" + node);\n+        }\n+        nodeToAttributesMap\n+            .put(node, NodeToAttributes.newInstance(node, attributesList));\n+      }\n+\n+      if (nodeToAttributesMap.isEmpty()) {\n+        throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n+      }\n+      return Lists.newArrayList(nodeToAttributesMap.values());\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    private List\u003cNodeToAttributes\u003e buildNodeLabelsListFromStr(String args,\n        boolean validateForAttributes, String operation) {\n      Map\u003cString, NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n      for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n        // for each node to attribute mapping\n        nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n        if (nodeToAttributesStr.isEmpty() || nodeToAttributesStr\n            .startsWith(\"#\")) {\n          continue;\n        }\n        if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n          throw new IllegalArgumentException(\n              INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n        }\n        String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n        Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n            \"Node name cannot be empty\");\n        String node \u003d nodeToAttributes[0];\n        String[] attributeNameValueType \u003d null;\n        List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n        NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n        String attributeValue;\n        String attributeName;\n        Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n\n        String[] attributesStr;\n        if (nodeToAttributes.length \u003d\u003d 2) {\n          // fetching multiple attributes for a node\n          attributesStr \u003d nodeToAttributes[1].split(\",\");\n          for (String attributeStr : attributesStr) {\n            // get information about each attribute.\n            attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n            // value\n            Preconditions.checkArgument(\n                !(attributeNameValueType[0] \u003d\u003d null || attributeNameValueType[0]\n                    .isEmpty()), \"Attribute name cannot be null or empty\");\n            attributeValue \u003d attributeNameValueType.length \u003e 1 ?\n                attributeNameValueType[1] :\n                \"\";\n            int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n            if (indexOfOpenBracket \u003d\u003d -1) {\n              attributeName \u003d attributeNameValueType[0];\n            } else if (indexOfOpenBracket \u003d\u003d 0) {\n              throw new IllegalArgumentException(\"Attribute for node \" + node\n                  + \" is not properly configured : \" + attributeStr);\n            } else {\n              // attribute type has been explicitly configured\n              int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n              if (indexOfCloseBracket \u003d\u003d -1\n                  || indexOfCloseBracket \u003c indexOfOpenBracket) {\n                throw new IllegalArgumentException(\"Attribute for node \" + node\n                    + \" is not properly Configured : \" + attributeStr);\n              }\n              String attributeTypeStr;\n              attributeName \u003d\n                  attributeNameValueType[0].substring(0, indexOfOpenBracket);\n              attributeTypeStr \u003d attributeNameValueType[0]\n                  .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n              try {\n                attributeType \u003d NodeAttributeType\n                    .valueOf(attributeTypeStr.trim().toUpperCase());\n              } catch (IllegalArgumentException e) {\n                throw new IllegalArgumentException(\n                    \"Invalid Attribute type configuration : \" + attributeTypeStr\n                        + \" in \" + attributeStr);\n              }\n            }\n            if (attributeNamesMapped.contains(attributeName)) {\n              throw new IllegalArgumentException(\"Attribute \" + attributeName\n                  + \" has been mapped more than once in  : \"\n                  + nodeToAttributesStr);\n            }\n            // TODO when we support different type of attribute type we need to\n            // cross verify whether input attributes itself is not violating\n            // attribute Name to Type mapping.\n            attributesList.add(NodeAttribute\n                .newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n                    attributeName.trim(), attributeType,\n                    attributeValue.trim()));\n          }\n        }\n        if (validateForAttributes) {\n          Preconditions.checkArgument((attributesList.size() \u003e 0),\n              \"Attributes cannot be null or empty for Operation [\" + operation\n                  + \"] on the node \" + node);\n        }\n        nodeToAttributesMap\n            .put(node, NodeToAttributes.newInstance(node, attributesList));\n      }\n\n      if (nodeToAttributesMap.isEmpty()) {\n        throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n      }\n      return Lists.newArrayList(nodeToAttributesMap.values());\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/NodeAttributesCLI.java",
          "extendedDetails": {}
        },
        {
          "type": "Yrename",
          "commitMessage": "YARN-8103. Add CLI interface to query node attributes. Contributed by Bibin A Chundatt.\n",
          "commitDate": "12/09/18 3:31 AM",
          "commitName": "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1",
          "commitAuthor": "Naganarasimha",
          "commitDateOld": "12/09/18 3:31 AM",
          "commitNameOld": "76183428b76524818fc250ae97bbf973dc910e1c",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 2,
          "diff": "@@ -1,94 +1,95 @@\n-  private List\u003cNodeToAttributes\u003e buildNodeLabelsMapFromStr(String args,\n-      boolean validateForAttributes, AttributeMappingOperationType operation) {\n-    Map\u003cString,NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n-    for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n-      // for each node to attribute mapping\n-      nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n-      if (nodeToAttributesStr.isEmpty()\n-          || nodeToAttributesStr.startsWith(\"#\")) {\n-        continue;\n-      }\n-      if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n-        throw new IllegalArgumentException(\n-            INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n-      }\n-      String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n-      Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n-          \"Node name cannot be empty\");\n-      String node \u003d nodeToAttributes[0];\n-      String[] attributeNameValueType \u003d null;\n-      List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n-      NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n-      String attributeValue;\n-      String attributeName;\n-      Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n-\n-      String attributesStr[];\n-      if (nodeToAttributes.length \u003d\u003d 2) {\n-        // fetching multiple attributes for a node\n-        attributesStr \u003d nodeToAttributes[1].split(\",\");\n-        for (String attributeStr : attributesStr) {\n-          // get information about each attribute.\n-          attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n-                                                            // value\n-          Preconditions.checkArgument(\n-              !(attributeNameValueType[0] \u003d\u003d null\n-                  || attributeNameValueType[0].isEmpty()),\n-              \"Attribute name cannot be null or empty\");\n-          attributeValue \u003d attributeNameValueType.length \u003e 1\n-              ? attributeNameValueType[1] : \"\";\n-          int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n-          if (indexOfOpenBracket \u003d\u003d -1) {\n-            attributeName \u003d attributeNameValueType[0];\n-          } else if (indexOfOpenBracket \u003d\u003d 0) {\n-            throw new IllegalArgumentException(\"Attribute for node \" + node\n-                + \" is not properly configured : \" + attributeStr);\n-          } else {\n-            // attribute type has been explicitly configured\n-            int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n-            if (indexOfCloseBracket \u003d\u003d -1\n-                || indexOfCloseBracket \u003c indexOfOpenBracket) {\n-              throw new IllegalArgumentException(\"Attribute for node \" + node\n-                  + \" is not properly Configured : \" + attributeStr);\n-            }\n-            String attributeTypeStr;\n-            attributeName \u003d\n-                attributeNameValueType[0].substring(0, indexOfOpenBracket);\n-            attributeTypeStr \u003d attributeNameValueType[0]\n-                .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n-            try {\n-              attributeType \u003d NodeAttributeType\n-                  .valueOf(attributeTypeStr.trim().toUpperCase());\n-            } catch (IllegalArgumentException e) {\n-              throw new IllegalArgumentException(\n-                  \"Invalid Attribute type configuration : \" + attributeTypeStr\n-                      + \" in \" + attributeStr);\n-            }\n-          }\n-          if (attributeNamesMapped.contains(attributeName)) {\n-            throw new IllegalArgumentException(\"Attribute \" + attributeName\n-                + \" has been mapped more than once in  : \"\n-                + nodeToAttributesStr);\n-          }\n-          // TODO when we support different type of attribute type we need to\n-          // cross verify whether input attributes itself is not violating\n-          // attribute Name to Type mapping.\n-          attributesList\n-              .add(NodeAttribute.newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n-                  attributeName.trim(), attributeType, attributeValue.trim()));\n+    private List\u003cNodeToAttributes\u003e buildNodeLabelsListFromStr(String args,\n+        boolean validateForAttributes, String operation) {\n+      Map\u003cString, NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n+      for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n+        // for each node to attribute mapping\n+        nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n+        if (nodeToAttributesStr.isEmpty() || nodeToAttributesStr\n+            .startsWith(\"#\")) {\n+          continue;\n         }\n-      }\n-      if (validateForAttributes) {\n-        Preconditions.checkArgument((attributesList.size() \u003e 0),\n-            \"Attributes cannot be null or empty for Operation \"\n-                + operation.name() + \" on the node \" + node);\n-      }\n-      nodeToAttributesMap\n-          .put(node,NodeToAttributes.newInstance(node, attributesList));\n-    }\n+        if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n+          throw new IllegalArgumentException(\n+              INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n+        }\n+        String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n+        Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n+            \"Node name cannot be empty\");\n+        String node \u003d nodeToAttributes[0];\n+        String[] attributeNameValueType \u003d null;\n+        List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n+        NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n+        String attributeValue;\n+        String attributeName;\n+        Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n \n-    if (nodeToAttributesMap.isEmpty()) {\n-      throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n-    }\n-    return Lists.newArrayList(nodeToAttributesMap.values());\n-  }\n\\ No newline at end of file\n+        String[] attributesStr;\n+        if (nodeToAttributes.length \u003d\u003d 2) {\n+          // fetching multiple attributes for a node\n+          attributesStr \u003d nodeToAttributes[1].split(\",\");\n+          for (String attributeStr : attributesStr) {\n+            // get information about each attribute.\n+            attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n+            // value\n+            Preconditions.checkArgument(\n+                !(attributeNameValueType[0] \u003d\u003d null || attributeNameValueType[0]\n+                    .isEmpty()), \"Attribute name cannot be null or empty\");\n+            attributeValue \u003d attributeNameValueType.length \u003e 1 ?\n+                attributeNameValueType[1] :\n+                \"\";\n+            int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n+            if (indexOfOpenBracket \u003d\u003d -1) {\n+              attributeName \u003d attributeNameValueType[0];\n+            } else if (indexOfOpenBracket \u003d\u003d 0) {\n+              throw new IllegalArgumentException(\"Attribute for node \" + node\n+                  + \" is not properly configured : \" + attributeStr);\n+            } else {\n+              // attribute type has been explicitly configured\n+              int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n+              if (indexOfCloseBracket \u003d\u003d -1\n+                  || indexOfCloseBracket \u003c indexOfOpenBracket) {\n+                throw new IllegalArgumentException(\"Attribute for node \" + node\n+                    + \" is not properly Configured : \" + attributeStr);\n+              }\n+              String attributeTypeStr;\n+              attributeName \u003d\n+                  attributeNameValueType[0].substring(0, indexOfOpenBracket);\n+              attributeTypeStr \u003d attributeNameValueType[0]\n+                  .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n+              try {\n+                attributeType \u003d NodeAttributeType\n+                    .valueOf(attributeTypeStr.trim().toUpperCase());\n+              } catch (IllegalArgumentException e) {\n+                throw new IllegalArgumentException(\n+                    \"Invalid Attribute type configuration : \" + attributeTypeStr\n+                        + \" in \" + attributeStr);\n+              }\n+            }\n+            if (attributeNamesMapped.contains(attributeName)) {\n+              throw new IllegalArgumentException(\"Attribute \" + attributeName\n+                  + \" has been mapped more than once in  : \"\n+                  + nodeToAttributesStr);\n+            }\n+            // TODO when we support different type of attribute type we need to\n+            // cross verify whether input attributes itself is not violating\n+            // attribute Name to Type mapping.\n+            attributesList.add(NodeAttribute\n+                .newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n+                    attributeName.trim(), attributeType,\n+                    attributeValue.trim()));\n+          }\n+        }\n+        if (validateForAttributes) {\n+          Preconditions.checkArgument((attributesList.size() \u003e 0),\n+              \"Attributes cannot be null or empty for Operation [\" + operation\n+                  + \"] on the node \" + node);\n+        }\n+        nodeToAttributesMap\n+            .put(node, NodeToAttributes.newInstance(node, attributesList));\n+      }\n+\n+      if (nodeToAttributesMap.isEmpty()) {\n+        throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n+      }\n+      return Lists.newArrayList(nodeToAttributesMap.values());\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    private List\u003cNodeToAttributes\u003e buildNodeLabelsListFromStr(String args,\n        boolean validateForAttributes, String operation) {\n      Map\u003cString, NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n      for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n        // for each node to attribute mapping\n        nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n        if (nodeToAttributesStr.isEmpty() || nodeToAttributesStr\n            .startsWith(\"#\")) {\n          continue;\n        }\n        if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n          throw new IllegalArgumentException(\n              INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n        }\n        String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n        Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n            \"Node name cannot be empty\");\n        String node \u003d nodeToAttributes[0];\n        String[] attributeNameValueType \u003d null;\n        List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n        NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n        String attributeValue;\n        String attributeName;\n        Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n\n        String[] attributesStr;\n        if (nodeToAttributes.length \u003d\u003d 2) {\n          // fetching multiple attributes for a node\n          attributesStr \u003d nodeToAttributes[1].split(\",\");\n          for (String attributeStr : attributesStr) {\n            // get information about each attribute.\n            attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n            // value\n            Preconditions.checkArgument(\n                !(attributeNameValueType[0] \u003d\u003d null || attributeNameValueType[0]\n                    .isEmpty()), \"Attribute name cannot be null or empty\");\n            attributeValue \u003d attributeNameValueType.length \u003e 1 ?\n                attributeNameValueType[1] :\n                \"\";\n            int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n            if (indexOfOpenBracket \u003d\u003d -1) {\n              attributeName \u003d attributeNameValueType[0];\n            } else if (indexOfOpenBracket \u003d\u003d 0) {\n              throw new IllegalArgumentException(\"Attribute for node \" + node\n                  + \" is not properly configured : \" + attributeStr);\n            } else {\n              // attribute type has been explicitly configured\n              int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n              if (indexOfCloseBracket \u003d\u003d -1\n                  || indexOfCloseBracket \u003c indexOfOpenBracket) {\n                throw new IllegalArgumentException(\"Attribute for node \" + node\n                    + \" is not properly Configured : \" + attributeStr);\n              }\n              String attributeTypeStr;\n              attributeName \u003d\n                  attributeNameValueType[0].substring(0, indexOfOpenBracket);\n              attributeTypeStr \u003d attributeNameValueType[0]\n                  .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n              try {\n                attributeType \u003d NodeAttributeType\n                    .valueOf(attributeTypeStr.trim().toUpperCase());\n              } catch (IllegalArgumentException e) {\n                throw new IllegalArgumentException(\n                    \"Invalid Attribute type configuration : \" + attributeTypeStr\n                        + \" in \" + attributeStr);\n              }\n            }\n            if (attributeNamesMapped.contains(attributeName)) {\n              throw new IllegalArgumentException(\"Attribute \" + attributeName\n                  + \" has been mapped more than once in  : \"\n                  + nodeToAttributesStr);\n            }\n            // TODO when we support different type of attribute type we need to\n            // cross verify whether input attributes itself is not violating\n            // attribute Name to Type mapping.\n            attributesList.add(NodeAttribute\n                .newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n                    attributeName.trim(), attributeType,\n                    attributeValue.trim()));\n          }\n        }\n        if (validateForAttributes) {\n          Preconditions.checkArgument((attributesList.size() \u003e 0),\n              \"Attributes cannot be null or empty for Operation [\" + operation\n                  + \"] on the node \" + node);\n        }\n        nodeToAttributesMap\n            .put(node, NodeToAttributes.newInstance(node, attributesList));\n      }\n\n      if (nodeToAttributesMap.isEmpty()) {\n        throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n      }\n      return Lists.newArrayList(nodeToAttributesMap.values());\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/NodeAttributesCLI.java",
          "extendedDetails": {
            "oldValue": "buildNodeLabelsMapFromStr",
            "newValue": "buildNodeLabelsListFromStr"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8103. Add CLI interface to query node attributes. Contributed by Bibin A Chundatt.\n",
          "commitDate": "12/09/18 3:31 AM",
          "commitName": "eb08543c7a5d1fd97a1915dbc5a11a2ba2066ba1",
          "commitAuthor": "Naganarasimha",
          "commitDateOld": "12/09/18 3:31 AM",
          "commitNameOld": "76183428b76524818fc250ae97bbf973dc910e1c",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 2,
          "diff": "@@ -1,94 +1,95 @@\n-  private List\u003cNodeToAttributes\u003e buildNodeLabelsMapFromStr(String args,\n-      boolean validateForAttributes, AttributeMappingOperationType operation) {\n-    Map\u003cString,NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n-    for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n-      // for each node to attribute mapping\n-      nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n-      if (nodeToAttributesStr.isEmpty()\n-          || nodeToAttributesStr.startsWith(\"#\")) {\n-        continue;\n-      }\n-      if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n-        throw new IllegalArgumentException(\n-            INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n-      }\n-      String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n-      Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n-          \"Node name cannot be empty\");\n-      String node \u003d nodeToAttributes[0];\n-      String[] attributeNameValueType \u003d null;\n-      List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n-      NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n-      String attributeValue;\n-      String attributeName;\n-      Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n-\n-      String attributesStr[];\n-      if (nodeToAttributes.length \u003d\u003d 2) {\n-        // fetching multiple attributes for a node\n-        attributesStr \u003d nodeToAttributes[1].split(\",\");\n-        for (String attributeStr : attributesStr) {\n-          // get information about each attribute.\n-          attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n-                                                            // value\n-          Preconditions.checkArgument(\n-              !(attributeNameValueType[0] \u003d\u003d null\n-                  || attributeNameValueType[0].isEmpty()),\n-              \"Attribute name cannot be null or empty\");\n-          attributeValue \u003d attributeNameValueType.length \u003e 1\n-              ? attributeNameValueType[1] : \"\";\n-          int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n-          if (indexOfOpenBracket \u003d\u003d -1) {\n-            attributeName \u003d attributeNameValueType[0];\n-          } else if (indexOfOpenBracket \u003d\u003d 0) {\n-            throw new IllegalArgumentException(\"Attribute for node \" + node\n-                + \" is not properly configured : \" + attributeStr);\n-          } else {\n-            // attribute type has been explicitly configured\n-            int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n-            if (indexOfCloseBracket \u003d\u003d -1\n-                || indexOfCloseBracket \u003c indexOfOpenBracket) {\n-              throw new IllegalArgumentException(\"Attribute for node \" + node\n-                  + \" is not properly Configured : \" + attributeStr);\n-            }\n-            String attributeTypeStr;\n-            attributeName \u003d\n-                attributeNameValueType[0].substring(0, indexOfOpenBracket);\n-            attributeTypeStr \u003d attributeNameValueType[0]\n-                .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n-            try {\n-              attributeType \u003d NodeAttributeType\n-                  .valueOf(attributeTypeStr.trim().toUpperCase());\n-            } catch (IllegalArgumentException e) {\n-              throw new IllegalArgumentException(\n-                  \"Invalid Attribute type configuration : \" + attributeTypeStr\n-                      + \" in \" + attributeStr);\n-            }\n-          }\n-          if (attributeNamesMapped.contains(attributeName)) {\n-            throw new IllegalArgumentException(\"Attribute \" + attributeName\n-                + \" has been mapped more than once in  : \"\n-                + nodeToAttributesStr);\n-          }\n-          // TODO when we support different type of attribute type we need to\n-          // cross verify whether input attributes itself is not violating\n-          // attribute Name to Type mapping.\n-          attributesList\n-              .add(NodeAttribute.newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n-                  attributeName.trim(), attributeType, attributeValue.trim()));\n+    private List\u003cNodeToAttributes\u003e buildNodeLabelsListFromStr(String args,\n+        boolean validateForAttributes, String operation) {\n+      Map\u003cString, NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n+      for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n+        // for each node to attribute mapping\n+        nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n+        if (nodeToAttributesStr.isEmpty() || nodeToAttributesStr\n+            .startsWith(\"#\")) {\n+          continue;\n         }\n-      }\n-      if (validateForAttributes) {\n-        Preconditions.checkArgument((attributesList.size() \u003e 0),\n-            \"Attributes cannot be null or empty for Operation \"\n-                + operation.name() + \" on the node \" + node);\n-      }\n-      nodeToAttributesMap\n-          .put(node,NodeToAttributes.newInstance(node, attributesList));\n-    }\n+        if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n+          throw new IllegalArgumentException(\n+              INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n+        }\n+        String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n+        Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n+            \"Node name cannot be empty\");\n+        String node \u003d nodeToAttributes[0];\n+        String[] attributeNameValueType \u003d null;\n+        List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n+        NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n+        String attributeValue;\n+        String attributeName;\n+        Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n \n-    if (nodeToAttributesMap.isEmpty()) {\n-      throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n-    }\n-    return Lists.newArrayList(nodeToAttributesMap.values());\n-  }\n\\ No newline at end of file\n+        String[] attributesStr;\n+        if (nodeToAttributes.length \u003d\u003d 2) {\n+          // fetching multiple attributes for a node\n+          attributesStr \u003d nodeToAttributes[1].split(\",\");\n+          for (String attributeStr : attributesStr) {\n+            // get information about each attribute.\n+            attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n+            // value\n+            Preconditions.checkArgument(\n+                !(attributeNameValueType[0] \u003d\u003d null || attributeNameValueType[0]\n+                    .isEmpty()), \"Attribute name cannot be null or empty\");\n+            attributeValue \u003d attributeNameValueType.length \u003e 1 ?\n+                attributeNameValueType[1] :\n+                \"\";\n+            int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n+            if (indexOfOpenBracket \u003d\u003d -1) {\n+              attributeName \u003d attributeNameValueType[0];\n+            } else if (indexOfOpenBracket \u003d\u003d 0) {\n+              throw new IllegalArgumentException(\"Attribute for node \" + node\n+                  + \" is not properly configured : \" + attributeStr);\n+            } else {\n+              // attribute type has been explicitly configured\n+              int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n+              if (indexOfCloseBracket \u003d\u003d -1\n+                  || indexOfCloseBracket \u003c indexOfOpenBracket) {\n+                throw new IllegalArgumentException(\"Attribute for node \" + node\n+                    + \" is not properly Configured : \" + attributeStr);\n+              }\n+              String attributeTypeStr;\n+              attributeName \u003d\n+                  attributeNameValueType[0].substring(0, indexOfOpenBracket);\n+              attributeTypeStr \u003d attributeNameValueType[0]\n+                  .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n+              try {\n+                attributeType \u003d NodeAttributeType\n+                    .valueOf(attributeTypeStr.trim().toUpperCase());\n+              } catch (IllegalArgumentException e) {\n+                throw new IllegalArgumentException(\n+                    \"Invalid Attribute type configuration : \" + attributeTypeStr\n+                        + \" in \" + attributeStr);\n+              }\n+            }\n+            if (attributeNamesMapped.contains(attributeName)) {\n+              throw new IllegalArgumentException(\"Attribute \" + attributeName\n+                  + \" has been mapped more than once in  : \"\n+                  + nodeToAttributesStr);\n+            }\n+            // TODO when we support different type of attribute type we need to\n+            // cross verify whether input attributes itself is not violating\n+            // attribute Name to Type mapping.\n+            attributesList.add(NodeAttribute\n+                .newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n+                    attributeName.trim(), attributeType,\n+                    attributeValue.trim()));\n+          }\n+        }\n+        if (validateForAttributes) {\n+          Preconditions.checkArgument((attributesList.size() \u003e 0),\n+              \"Attributes cannot be null or empty for Operation [\" + operation\n+                  + \"] on the node \" + node);\n+        }\n+        nodeToAttributesMap\n+            .put(node, NodeToAttributes.newInstance(node, attributesList));\n+      }\n+\n+      if (nodeToAttributesMap.isEmpty()) {\n+        throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n+      }\n+      return Lists.newArrayList(nodeToAttributesMap.values());\n+    }\n\\ No newline at end of file\n",
          "actualSource": "    private List\u003cNodeToAttributes\u003e buildNodeLabelsListFromStr(String args,\n        boolean validateForAttributes, String operation) {\n      Map\u003cString, NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n      for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n        // for each node to attribute mapping\n        nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n        if (nodeToAttributesStr.isEmpty() || nodeToAttributesStr\n            .startsWith(\"#\")) {\n          continue;\n        }\n        if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n          throw new IllegalArgumentException(\n              INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n        }\n        String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n        Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n            \"Node name cannot be empty\");\n        String node \u003d nodeToAttributes[0];\n        String[] attributeNameValueType \u003d null;\n        List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n        NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n        String attributeValue;\n        String attributeName;\n        Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n\n        String[] attributesStr;\n        if (nodeToAttributes.length \u003d\u003d 2) {\n          // fetching multiple attributes for a node\n          attributesStr \u003d nodeToAttributes[1].split(\",\");\n          for (String attributeStr : attributesStr) {\n            // get information about each attribute.\n            attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n            // value\n            Preconditions.checkArgument(\n                !(attributeNameValueType[0] \u003d\u003d null || attributeNameValueType[0]\n                    .isEmpty()), \"Attribute name cannot be null or empty\");\n            attributeValue \u003d attributeNameValueType.length \u003e 1 ?\n                attributeNameValueType[1] :\n                \"\";\n            int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n            if (indexOfOpenBracket \u003d\u003d -1) {\n              attributeName \u003d attributeNameValueType[0];\n            } else if (indexOfOpenBracket \u003d\u003d 0) {\n              throw new IllegalArgumentException(\"Attribute for node \" + node\n                  + \" is not properly configured : \" + attributeStr);\n            } else {\n              // attribute type has been explicitly configured\n              int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n              if (indexOfCloseBracket \u003d\u003d -1\n                  || indexOfCloseBracket \u003c indexOfOpenBracket) {\n                throw new IllegalArgumentException(\"Attribute for node \" + node\n                    + \" is not properly Configured : \" + attributeStr);\n              }\n              String attributeTypeStr;\n              attributeName \u003d\n                  attributeNameValueType[0].substring(0, indexOfOpenBracket);\n              attributeTypeStr \u003d attributeNameValueType[0]\n                  .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n              try {\n                attributeType \u003d NodeAttributeType\n                    .valueOf(attributeTypeStr.trim().toUpperCase());\n              } catch (IllegalArgumentException e) {\n                throw new IllegalArgumentException(\n                    \"Invalid Attribute type configuration : \" + attributeTypeStr\n                        + \" in \" + attributeStr);\n              }\n            }\n            if (attributeNamesMapped.contains(attributeName)) {\n              throw new IllegalArgumentException(\"Attribute \" + attributeName\n                  + \" has been mapped more than once in  : \"\n                  + nodeToAttributesStr);\n            }\n            // TODO when we support different type of attribute type we need to\n            // cross verify whether input attributes itself is not violating\n            // attribute Name to Type mapping.\n            attributesList.add(NodeAttribute\n                .newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n                    attributeName.trim(), attributeType,\n                    attributeValue.trim()));\n          }\n        }\n        if (validateForAttributes) {\n          Preconditions.checkArgument((attributesList.size() \u003e 0),\n              \"Attributes cannot be null or empty for Operation [\" + operation\n                  + \"] on the node \" + node);\n        }\n        nodeToAttributesMap\n            .put(node, NodeToAttributes.newInstance(node, attributesList));\n      }\n\n      if (nodeToAttributesMap.isEmpty()) {\n        throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n      }\n      return Lists.newArrayList(nodeToAttributesMap.values());\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/NodeAttributesCLI.java",
          "extendedDetails": {
            "oldValue": "[args-String, validateForAttributes-boolean, operation-AttributeMappingOperationType]",
            "newValue": "[args-String, validateForAttributes-boolean, operation-String]"
          }
        }
      ]
    },
    "901e85238da08129374d44af80716b07f0b912e6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8033. CLI Integration with NodeAttributesManagerImpl. Contributed by Naganarasimha G R.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "901e85238da08129374d44af80716b07f0b912e6",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "12/09/18 3:30 AM",
      "commitNameOld": "2475fb0a1e2158aac11829c6e33eae3e02bf33ea",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,94 @@\n   private List\u003cNodeToAttributes\u003e buildNodeLabelsMapFromStr(String args,\n       boolean validateForAttributes, AttributeMappingOperationType operation) {\n-    List\u003cNodeToAttributes\u003e nodeToAttributesList \u003d new ArrayList\u003c\u003e();\n+    Map\u003cString,NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n     for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n       // for each node to attribute mapping\n       nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n       if (nodeToAttributesStr.isEmpty()\n           || nodeToAttributesStr.startsWith(\"#\")) {\n         continue;\n       }\n       if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n         throw new IllegalArgumentException(\n             INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n       }\n       String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n       Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n           \"Node name cannot be empty\");\n       String node \u003d nodeToAttributes[0];\n       String[] attributeNameValueType \u003d null;\n       List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n       NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n       String attributeValue;\n       String attributeName;\n       Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n \n       String attributesStr[];\n       if (nodeToAttributes.length \u003d\u003d 2) {\n         // fetching multiple attributes for a node\n         attributesStr \u003d nodeToAttributes[1].split(\",\");\n         for (String attributeStr : attributesStr) {\n           // get information about each attribute.\n           attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n                                                             // value\n           Preconditions.checkArgument(\n               !(attributeNameValueType[0] \u003d\u003d null\n                   || attributeNameValueType[0].isEmpty()),\n               \"Attribute name cannot be null or empty\");\n           attributeValue \u003d attributeNameValueType.length \u003e 1\n               ? attributeNameValueType[1] : \"\";\n           int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n           if (indexOfOpenBracket \u003d\u003d -1) {\n             attributeName \u003d attributeNameValueType[0];\n           } else if (indexOfOpenBracket \u003d\u003d 0) {\n             throw new IllegalArgumentException(\"Attribute for node \" + node\n                 + \" is not properly configured : \" + attributeStr);\n           } else {\n             // attribute type has been explicitly configured\n             int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n             if (indexOfCloseBracket \u003d\u003d -1\n                 || indexOfCloseBracket \u003c indexOfOpenBracket) {\n               throw new IllegalArgumentException(\"Attribute for node \" + node\n                   + \" is not properly Configured : \" + attributeStr);\n             }\n             String attributeTypeStr;\n             attributeName \u003d\n                 attributeNameValueType[0].substring(0, indexOfOpenBracket);\n             attributeTypeStr \u003d attributeNameValueType[0]\n                 .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n             try {\n               attributeType \u003d NodeAttributeType\n                   .valueOf(attributeTypeStr.trim().toUpperCase());\n             } catch (IllegalArgumentException e) {\n               throw new IllegalArgumentException(\n                   \"Invalid Attribute type configuration : \" + attributeTypeStr\n                       + \" in \" + attributeStr);\n             }\n           }\n           if (attributeNamesMapped.contains(attributeName)) {\n             throw new IllegalArgumentException(\"Attribute \" + attributeName\n                 + \" has been mapped more than once in  : \"\n                 + nodeToAttributesStr);\n           }\n           // TODO when we support different type of attribute type we need to\n           // cross verify whether input attributes itself is not violating\n           // attribute Name to Type mapping.\n-          attributesList.add(NodeAttribute.newInstance(attributeName.trim(),\n-              attributeType, attributeValue.trim()));\n+          attributesList\n+              .add(NodeAttribute.newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n+                  attributeName.trim(), attributeType, attributeValue.trim()));\n         }\n       }\n       if (validateForAttributes) {\n         Preconditions.checkArgument((attributesList.size() \u003e 0),\n             \"Attributes cannot be null or empty for Operation \"\n                 + operation.name() + \" on the node \" + node);\n       }\n-      nodeToAttributesList\n-          .add(NodeToAttributes.newInstance(node, attributesList));\n+      nodeToAttributesMap\n+          .put(node,NodeToAttributes.newInstance(node, attributesList));\n     }\n \n-    if (nodeToAttributesList.isEmpty()) {\n+    if (nodeToAttributesMap.isEmpty()) {\n       throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n     }\n-    return nodeToAttributesList;\n+    return Lists.newArrayList(nodeToAttributesMap.values());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cNodeToAttributes\u003e buildNodeLabelsMapFromStr(String args,\n      boolean validateForAttributes, AttributeMappingOperationType operation) {\n    Map\u003cString,NodeToAttributes\u003e nodeToAttributesMap \u003d new HashMap\u003c\u003e();\n    for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n      // for each node to attribute mapping\n      nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n      if (nodeToAttributesStr.isEmpty()\n          || nodeToAttributesStr.startsWith(\"#\")) {\n        continue;\n      }\n      if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n        throw new IllegalArgumentException(\n            INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n      }\n      String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n      Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n          \"Node name cannot be empty\");\n      String node \u003d nodeToAttributes[0];\n      String[] attributeNameValueType \u003d null;\n      List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n      NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n      String attributeValue;\n      String attributeName;\n      Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n\n      String attributesStr[];\n      if (nodeToAttributes.length \u003d\u003d 2) {\n        // fetching multiple attributes for a node\n        attributesStr \u003d nodeToAttributes[1].split(\",\");\n        for (String attributeStr : attributesStr) {\n          // get information about each attribute.\n          attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n                                                            // value\n          Preconditions.checkArgument(\n              !(attributeNameValueType[0] \u003d\u003d null\n                  || attributeNameValueType[0].isEmpty()),\n              \"Attribute name cannot be null or empty\");\n          attributeValue \u003d attributeNameValueType.length \u003e 1\n              ? attributeNameValueType[1] : \"\";\n          int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n          if (indexOfOpenBracket \u003d\u003d -1) {\n            attributeName \u003d attributeNameValueType[0];\n          } else if (indexOfOpenBracket \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"Attribute for node \" + node\n                + \" is not properly configured : \" + attributeStr);\n          } else {\n            // attribute type has been explicitly configured\n            int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n            if (indexOfCloseBracket \u003d\u003d -1\n                || indexOfCloseBracket \u003c indexOfOpenBracket) {\n              throw new IllegalArgumentException(\"Attribute for node \" + node\n                  + \" is not properly Configured : \" + attributeStr);\n            }\n            String attributeTypeStr;\n            attributeName \u003d\n                attributeNameValueType[0].substring(0, indexOfOpenBracket);\n            attributeTypeStr \u003d attributeNameValueType[0]\n                .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n            try {\n              attributeType \u003d NodeAttributeType\n                  .valueOf(attributeTypeStr.trim().toUpperCase());\n            } catch (IllegalArgumentException e) {\n              throw new IllegalArgumentException(\n                  \"Invalid Attribute type configuration : \" + attributeTypeStr\n                      + \" in \" + attributeStr);\n            }\n          }\n          if (attributeNamesMapped.contains(attributeName)) {\n            throw new IllegalArgumentException(\"Attribute \" + attributeName\n                + \" has been mapped more than once in  : \"\n                + nodeToAttributesStr);\n          }\n          // TODO when we support different type of attribute type we need to\n          // cross verify whether input attributes itself is not violating\n          // attribute Name to Type mapping.\n          attributesList\n              .add(NodeAttribute.newInstance(NodeAttribute.PREFIX_CENTRALIZED,\n                  attributeName.trim(), attributeType, attributeValue.trim()));\n        }\n      }\n      if (validateForAttributes) {\n        Preconditions.checkArgument((attributesList.size() \u003e 0),\n            \"Attributes cannot be null or empty for Operation \"\n                + operation.name() + \" on the node \" + node);\n      }\n      nodeToAttributesMap\n          .put(node,NodeToAttributes.newInstance(node, attributesList));\n    }\n\n    if (nodeToAttributesMap.isEmpty()) {\n      throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n    }\n    return Lists.newArrayList(nodeToAttributesMap.values());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/NodeAttributesCLI.java",
      "extendedDetails": {}
    },
    "2475fb0a1e2158aac11829c6e33eae3e02bf33ea": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6856. [YARN-3409] Support CLI for Node Attributes Mapping. Contributed by Naganarasimha G R.\n",
      "commitDate": "12/09/18 3:30 AM",
      "commitName": "2475fb0a1e2158aac11829c6e33eae3e02bf33ea",
      "commitAuthor": "Naganarasimha",
      "diff": "@@ -0,0 +1,93 @@\n+  private List\u003cNodeToAttributes\u003e buildNodeLabelsMapFromStr(String args,\n+      boolean validateForAttributes, AttributeMappingOperationType operation) {\n+    List\u003cNodeToAttributes\u003e nodeToAttributesList \u003d new ArrayList\u003c\u003e();\n+    for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n+      // for each node to attribute mapping\n+      nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n+      if (nodeToAttributesStr.isEmpty()\n+          || nodeToAttributesStr.startsWith(\"#\")) {\n+        continue;\n+      }\n+      if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n+        throw new IllegalArgumentException(\n+            INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n+      }\n+      String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n+      Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n+          \"Node name cannot be empty\");\n+      String node \u003d nodeToAttributes[0];\n+      String[] attributeNameValueType \u003d null;\n+      List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n+      NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n+      String attributeValue;\n+      String attributeName;\n+      Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n+\n+      String attributesStr[];\n+      if (nodeToAttributes.length \u003d\u003d 2) {\n+        // fetching multiple attributes for a node\n+        attributesStr \u003d nodeToAttributes[1].split(\",\");\n+        for (String attributeStr : attributesStr) {\n+          // get information about each attribute.\n+          attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n+                                                            // value\n+          Preconditions.checkArgument(\n+              !(attributeNameValueType[0] \u003d\u003d null\n+                  || attributeNameValueType[0].isEmpty()),\n+              \"Attribute name cannot be null or empty\");\n+          attributeValue \u003d attributeNameValueType.length \u003e 1\n+              ? attributeNameValueType[1] : \"\";\n+          int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n+          if (indexOfOpenBracket \u003d\u003d -1) {\n+            attributeName \u003d attributeNameValueType[0];\n+          } else if (indexOfOpenBracket \u003d\u003d 0) {\n+            throw new IllegalArgumentException(\"Attribute for node \" + node\n+                + \" is not properly configured : \" + attributeStr);\n+          } else {\n+            // attribute type has been explicitly configured\n+            int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n+            if (indexOfCloseBracket \u003d\u003d -1\n+                || indexOfCloseBracket \u003c indexOfOpenBracket) {\n+              throw new IllegalArgumentException(\"Attribute for node \" + node\n+                  + \" is not properly Configured : \" + attributeStr);\n+            }\n+            String attributeTypeStr;\n+            attributeName \u003d\n+                attributeNameValueType[0].substring(0, indexOfOpenBracket);\n+            attributeTypeStr \u003d attributeNameValueType[0]\n+                .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n+            try {\n+              attributeType \u003d NodeAttributeType\n+                  .valueOf(attributeTypeStr.trim().toUpperCase());\n+            } catch (IllegalArgumentException e) {\n+              throw new IllegalArgumentException(\n+                  \"Invalid Attribute type configuration : \" + attributeTypeStr\n+                      + \" in \" + attributeStr);\n+            }\n+          }\n+          if (attributeNamesMapped.contains(attributeName)) {\n+            throw new IllegalArgumentException(\"Attribute \" + attributeName\n+                + \" has been mapped more than once in  : \"\n+                + nodeToAttributesStr);\n+          }\n+          // TODO when we support different type of attribute type we need to\n+          // cross verify whether input attributes itself is not violating\n+          // attribute Name to Type mapping.\n+          attributesList.add(NodeAttribute.newInstance(attributeName.trim(),\n+              attributeType, attributeValue.trim()));\n+        }\n+      }\n+      if (validateForAttributes) {\n+        Preconditions.checkArgument((attributesList.size() \u003e 0),\n+            \"Attributes cannot be null or empty for Operation \"\n+                + operation.name() + \" on the node \" + node);\n+      }\n+      nodeToAttributesList\n+          .add(NodeToAttributes.newInstance(node, attributesList));\n+    }\n+\n+    if (nodeToAttributesList.isEmpty()) {\n+      throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n+    }\n+    return nodeToAttributesList;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cNodeToAttributes\u003e buildNodeLabelsMapFromStr(String args,\n      boolean validateForAttributes, AttributeMappingOperationType operation) {\n    List\u003cNodeToAttributes\u003e nodeToAttributesList \u003d new ArrayList\u003c\u003e();\n    for (String nodeToAttributesStr : args.split(\"[ \\n]\")) {\n      // for each node to attribute mapping\n      nodeToAttributesStr \u003d nodeToAttributesStr.trim();\n      if (nodeToAttributesStr.isEmpty()\n          || nodeToAttributesStr.startsWith(\"#\")) {\n        continue;\n      }\n      if (nodeToAttributesStr.indexOf(\":\") \u003d\u003d -1) {\n        throw new IllegalArgumentException(\n            INVALID_MAPPING_ERR_MSG + nodeToAttributesStr);\n      }\n      String[] nodeToAttributes \u003d nodeToAttributesStr.split(\":\");\n      Preconditions.checkArgument(!nodeToAttributes[0].trim().isEmpty(),\n          \"Node name cannot be empty\");\n      String node \u003d nodeToAttributes[0];\n      String[] attributeNameValueType \u003d null;\n      List\u003cNodeAttribute\u003e attributesList \u003d new ArrayList\u003c\u003e();\n      NodeAttributeType attributeType \u003d NodeAttributeType.STRING;\n      String attributeValue;\n      String attributeName;\n      Set\u003cString\u003e attributeNamesMapped \u003d new HashSet\u003c\u003e();\n\n      String attributesStr[];\n      if (nodeToAttributes.length \u003d\u003d 2) {\n        // fetching multiple attributes for a node\n        attributesStr \u003d nodeToAttributes[1].split(\",\");\n        for (String attributeStr : attributesStr) {\n          // get information about each attribute.\n          attributeNameValueType \u003d attributeStr.split(\"\u003d\"); // to find name\n                                                            // value\n          Preconditions.checkArgument(\n              !(attributeNameValueType[0] \u003d\u003d null\n                  || attributeNameValueType[0].isEmpty()),\n              \"Attribute name cannot be null or empty\");\n          attributeValue \u003d attributeNameValueType.length \u003e 1\n              ? attributeNameValueType[1] : \"\";\n          int indexOfOpenBracket \u003d attributeNameValueType[0].indexOf(\"(\");\n          if (indexOfOpenBracket \u003d\u003d -1) {\n            attributeName \u003d attributeNameValueType[0];\n          } else if (indexOfOpenBracket \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"Attribute for node \" + node\n                + \" is not properly configured : \" + attributeStr);\n          } else {\n            // attribute type has been explicitly configured\n            int indexOfCloseBracket \u003d attributeNameValueType[0].indexOf(\")\");\n            if (indexOfCloseBracket \u003d\u003d -1\n                || indexOfCloseBracket \u003c indexOfOpenBracket) {\n              throw new IllegalArgumentException(\"Attribute for node \" + node\n                  + \" is not properly Configured : \" + attributeStr);\n            }\n            String attributeTypeStr;\n            attributeName \u003d\n                attributeNameValueType[0].substring(0, indexOfOpenBracket);\n            attributeTypeStr \u003d attributeNameValueType[0]\n                .substring(indexOfOpenBracket + 1, indexOfCloseBracket);\n            try {\n              attributeType \u003d NodeAttributeType\n                  .valueOf(attributeTypeStr.trim().toUpperCase());\n            } catch (IllegalArgumentException e) {\n              throw new IllegalArgumentException(\n                  \"Invalid Attribute type configuration : \" + attributeTypeStr\n                      + \" in \" + attributeStr);\n            }\n          }\n          if (attributeNamesMapped.contains(attributeName)) {\n            throw new IllegalArgumentException(\"Attribute \" + attributeName\n                + \" has been mapped more than once in  : \"\n                + nodeToAttributesStr);\n          }\n          // TODO when we support different type of attribute type we need to\n          // cross verify whether input attributes itself is not violating\n          // attribute Name to Type mapping.\n          attributesList.add(NodeAttribute.newInstance(attributeName.trim(),\n              attributeType, attributeValue.trim()));\n        }\n      }\n      if (validateForAttributes) {\n        Preconditions.checkArgument((attributesList.size() \u003e 0),\n            \"Attributes cannot be null or empty for Operation \"\n                + operation.name() + \" on the node \" + node);\n      }\n      nodeToAttributesList\n          .add(NodeToAttributes.newInstance(node, attributesList));\n    }\n\n    if (nodeToAttributesList.isEmpty()) {\n      throw new IllegalArgumentException(NO_MAPPING_ERR_MSG);\n    }\n    return nodeToAttributesList;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/NodeAttributesCLI.java"
    }
  }
}