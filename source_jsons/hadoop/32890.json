{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerCleanup.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerCleanup.java",
  "functionStartLine": 86,
  "functionEndLine": 182,
  "numCommitsSeen": 7,
  "timeTaken": 3345,
  "changeHistory": [
    "0e22e9ab83438af37d821cb2f96e31f9a19ace2c",
    "29465bf169a7e348a4f32265083450faf66d5631",
    "79d3d35398cb5348cfd62e41e3318ec7a337421a",
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "2e636dd3c497a9f0042642296b127686012de57a",
    "5ce70e1211e624d58e8bb1181aec00729ebdc085"
  ],
  "changeHistoryShort": {
    "0e22e9ab83438af37d821cb2f96e31f9a19ace2c": "Ybodychange",
    "29465bf169a7e348a4f32265083450faf66d5631": "Ybodychange",
    "79d3d35398cb5348cfd62e41e3318ec7a337421a": "Ybodychange",
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "2e636dd3c497a9f0042642296b127686012de57a": "Ybodychange",
    "5ce70e1211e624d58e8bb1181aec00729ebdc085": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0e22e9ab83438af37d821cb2f96e31f9a19ace2c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9562. Add Java changes for the new RuncContainerRuntime. Contributed by Eric Badger\n",
      "commitDate": "18/11/19 1:56 PM",
      "commitName": "0e22e9ab83438af37d821cb2f96e31f9a19ace2c",
      "commitAuthor": "Eric Badger",
      "commitDateOld": "14/08/19 10:42 AM",
      "commitNameOld": "167acd87daf61be9a27dfb5af6e7cbacb96e44de",
      "commitAuthorOld": "HUAN-PING SU",
      "daysBetweenCommits": 96.18,
      "commitsBetweenForRepo": 637,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,97 @@\n   public void run() {\n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d containerId.toString();\n     LOG.info(\"Cleaning up container \" + containerIdStr);\n \n     try {\n       context.getNMStateStore().storeContainerKilled(containerId);\n     } catch (IOException e) {\n       LOG.error(\"Unable to mark container \" + containerId\n           + \" killed in store\", e);\n     }\n \n     // launch flag will be set to true if process already launched,\n     // in process of launching, or failed to launch.\n     boolean alreadyLaunched \u003d !launch.markLaunched() ||\n         launch.isLaunchCompleted();\n     if (!alreadyLaunched) {\n       LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n           + \" No cleanup needed to be done\");\n       return;\n     }\n     LOG.debug(\"Marking container {} as inactive\", containerIdStr);\n     // this should ensure that if the container process has not launched\n     // by this time, it will never be launched\n     exec.deactivateContainer(containerId);\n     Path pidFilePath \u003d launch.getPidFilePath();\n     LOG.debug(\"Getting pid for container {} to kill\"\n         + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n         pidFilePath : \"null\");\n     // however the container process may have already started\n     try {\n \n       // get process id from pid file if available\n       // else if shell is still active, get it from the shell\n       String processId \u003d launch.getContainerPid();\n \n       // kill process\n       String user \u003d container.getUser();\n       if (processId !\u003d null) {\n         signalProcess(processId, user, containerIdStr);\n       } else {\n         // Normally this means that the process was notified about\n         // deactivateContainer above and did not start.\n         // Since we already set the state to RUNNING or REINITIALIZING\n         // we have to send a killed event to continue.\n         if (!launch.isLaunchCompleted()) {\n           LOG.warn(\"Container clean up before pid file created \"\n               + containerIdStr);\n           dispatcher.getEventHandler().handle(\n               new ContainerExitEvent(container.getContainerId(),\n                   ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                   Shell.WINDOWS ?\n                       ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                       ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                   \"Container terminated before pid file created.\"));\n           // There is a possibility that the launch grabbed the file name before\n           // the deactivateContainer above but it was slow enough to avoid\n           // getContainerPid.\n           // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS\n           // reduces the likelihood of this race condition and process leak.\n         }\n       }\n \n       // rm container in docker\n-      if (OCIContainerRuntime.isOCICompliantContainerRequested(conf,\n+      if (DockerLinuxContainerRuntime.isDockerContainerRequested(conf,\n           container.getLaunchContext().getEnvironment())) {\n         rmDockerContainerDelayed();\n       }\n     } catch (Exception e) {\n       String message \u003d\n           \"Exception when trying to cleanup container \" + containerIdStr\n               + \": \" + StringUtils.stringifyException(e);\n       LOG.warn(message);\n       dispatcher.getEventHandler().handle(\n           new ContainerDiagnosticsUpdateEvent(containerId, message));\n     } finally {\n       // cleanup pid file if present\n       if (pidFilePath !\u003d null) {\n         try {\n           FileContext lfs \u003d FileContext.getLocalFSFileContext();\n           lfs.delete(pidFilePath, false);\n           lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);\n         } catch (IOException ioe) {\n           LOG.warn(\"{} exception trying to delete pid file {}. Ignoring.\",\n               containerId, pidFilePath, ioe);\n         }\n       }\n     }\n \n     try {\n       // Reap the container\n       launch.reapContainer();\n     } catch (IOException ioe) {\n       LOG.warn(\"{} exception trying to reap container. Ignoring.\", containerId,\n           ioe);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n    LOG.info(\"Cleaning up container \" + containerIdStr);\n\n    try {\n      context.getNMStateStore().storeContainerKilled(containerId);\n    } catch (IOException e) {\n      LOG.error(\"Unable to mark container \" + containerId\n          + \" killed in store\", e);\n    }\n\n    // launch flag will be set to true if process already launched,\n    // in process of launching, or failed to launch.\n    boolean alreadyLaunched \u003d !launch.markLaunched() ||\n        launch.isLaunchCompleted();\n    if (!alreadyLaunched) {\n      LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n          + \" No cleanup needed to be done\");\n      return;\n    }\n    LOG.debug(\"Marking container {} as inactive\", containerIdStr);\n    // this should ensure that if the container process has not launched\n    // by this time, it will never be launched\n    exec.deactivateContainer(containerId);\n    Path pidFilePath \u003d launch.getPidFilePath();\n    LOG.debug(\"Getting pid for container {} to kill\"\n        + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n        pidFilePath : \"null\");\n    // however the container process may have already started\n    try {\n\n      // get process id from pid file if available\n      // else if shell is still active, get it from the shell\n      String processId \u003d launch.getContainerPid();\n\n      // kill process\n      String user \u003d container.getUser();\n      if (processId !\u003d null) {\n        signalProcess(processId, user, containerIdStr);\n      } else {\n        // Normally this means that the process was notified about\n        // deactivateContainer above and did not start.\n        // Since we already set the state to RUNNING or REINITIALIZING\n        // we have to send a killed event to continue.\n        if (!launch.isLaunchCompleted()) {\n          LOG.warn(\"Container clean up before pid file created \"\n              + containerIdStr);\n          dispatcher.getEventHandler().handle(\n              new ContainerExitEvent(container.getContainerId(),\n                  ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                  Shell.WINDOWS ?\n                      ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                      ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                  \"Container terminated before pid file created.\"));\n          // There is a possibility that the launch grabbed the file name before\n          // the deactivateContainer above but it was slow enough to avoid\n          // getContainerPid.\n          // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS\n          // reduces the likelihood of this race condition and process leak.\n        }\n      }\n\n      // rm container in docker\n      if (DockerLinuxContainerRuntime.isDockerContainerRequested(conf,\n          container.getLaunchContext().getEnvironment())) {\n        rmDockerContainerDelayed();\n      }\n    } catch (Exception e) {\n      String message \u003d\n          \"Exception when trying to cleanup container \" + containerIdStr\n              + \": \" + StringUtils.stringifyException(e);\n      LOG.warn(message);\n      dispatcher.getEventHandler().handle(\n          new ContainerDiagnosticsUpdateEvent(containerId, message));\n    } finally {\n      // cleanup pid file if present\n      if (pidFilePath !\u003d null) {\n        try {\n          FileContext lfs \u003d FileContext.getLocalFSFileContext();\n          lfs.delete(pidFilePath, false);\n          lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);\n        } catch (IOException ioe) {\n          LOG.warn(\"{} exception trying to delete pid file {}. Ignoring.\",\n              containerId, pidFilePath, ioe);\n        }\n      }\n    }\n\n    try {\n      // Reap the container\n      launch.reapContainer();\n    } catch (IOException ioe) {\n      LOG.warn(\"{} exception trying to reap container. Ignoring.\", containerId,\n          ioe);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerCleanup.java",
      "extendedDetails": {}
    },
    "29465bf169a7e348a4f32265083450faf66d5631": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9560. Restructure DockerLinuxContainerRuntime to extend OCIContainerRuntime.\n           Contributed by Eric Badger, Jim Brennan, Craig Condit\n",
      "commitDate": "28/06/19 2:18 PM",
      "commitName": "29465bf169a7e348a4f32265083450faf66d5631",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "25/04/19 6:21 PM",
      "commitNameOld": "79d3d35398cb5348cfd62e41e3318ec7a337421a",
      "commitAuthorOld": "Eric Badger",
      "daysBetweenCommits": 63.83,
      "commitsBetweenForRepo": 471,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,97 @@\n   public void run() {\n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d containerId.toString();\n     LOG.info(\"Cleaning up container \" + containerIdStr);\n \n     try {\n       context.getNMStateStore().storeContainerKilled(containerId);\n     } catch (IOException e) {\n       LOG.error(\"Unable to mark container \" + containerId\n           + \" killed in store\", e);\n     }\n \n     // launch flag will be set to true if process already launched,\n     // in process of launching, or failed to launch.\n     boolean alreadyLaunched \u003d !launch.markLaunched() ||\n         launch.isLaunchCompleted();\n     if (!alreadyLaunched) {\n       LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n           + \" No cleanup needed to be done\");\n       return;\n     }\n     LOG.debug(\"Marking container {} as inactive\", containerIdStr);\n     // this should ensure that if the container process has not launched\n     // by this time, it will never be launched\n     exec.deactivateContainer(containerId);\n     Path pidFilePath \u003d launch.getPidFilePath();\n     LOG.debug(\"Getting pid for container {} to kill\"\n         + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n         pidFilePath : \"null\");\n     // however the container process may have already started\n     try {\n \n       // get process id from pid file if available\n       // else if shell is still active, get it from the shell\n       String processId \u003d launch.getContainerPid();\n \n       // kill process\n       String user \u003d container.getUser();\n       if (processId !\u003d null) {\n         signalProcess(processId, user, containerIdStr);\n       } else {\n         // Normally this means that the process was notified about\n         // deactivateContainer above and did not start.\n         // Since we already set the state to RUNNING or REINITIALIZING\n         // we have to send a killed event to continue.\n         if (!launch.isLaunchCompleted()) {\n           LOG.warn(\"Container clean up before pid file created \"\n               + containerIdStr);\n           dispatcher.getEventHandler().handle(\n               new ContainerExitEvent(container.getContainerId(),\n                   ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                   Shell.WINDOWS ?\n                       ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                       ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                   \"Container terminated before pid file created.\"));\n           // There is a possibility that the launch grabbed the file name before\n           // the deactivateContainer above but it was slow enough to avoid\n           // getContainerPid.\n           // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS\n           // reduces the likelihood of this race condition and process leak.\n         }\n       }\n \n       // rm container in docker\n-      if (DockerLinuxContainerRuntime.isDockerContainerRequested(conf,\n+      if (OCIContainerRuntime.isOCICompliantContainerRequested(conf,\n           container.getLaunchContext().getEnvironment())) {\n         rmDockerContainerDelayed();\n       }\n     } catch (Exception e) {\n       String message \u003d\n           \"Exception when trying to cleanup container \" + containerIdStr\n               + \": \" + StringUtils.stringifyException(e);\n       LOG.warn(message);\n       dispatcher.getEventHandler().handle(\n           new ContainerDiagnosticsUpdateEvent(containerId, message));\n     } finally {\n       // cleanup pid file if present\n       if (pidFilePath !\u003d null) {\n         try {\n           FileContext lfs \u003d FileContext.getLocalFSFileContext();\n           lfs.delete(pidFilePath, false);\n           lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);\n         } catch (IOException ioe) {\n           LOG.warn(\"{} exception trying to delete pid file {}. Ignoring.\",\n               containerId, pidFilePath, ioe);\n         }\n       }\n     }\n \n     try {\n       // Reap the container\n       launch.reapContainer();\n     } catch (IOException ioe) {\n       LOG.warn(\"{} exception trying to reap container. Ignoring.\", containerId,\n           ioe);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n    LOG.info(\"Cleaning up container \" + containerIdStr);\n\n    try {\n      context.getNMStateStore().storeContainerKilled(containerId);\n    } catch (IOException e) {\n      LOG.error(\"Unable to mark container \" + containerId\n          + \" killed in store\", e);\n    }\n\n    // launch flag will be set to true if process already launched,\n    // in process of launching, or failed to launch.\n    boolean alreadyLaunched \u003d !launch.markLaunched() ||\n        launch.isLaunchCompleted();\n    if (!alreadyLaunched) {\n      LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n          + \" No cleanup needed to be done\");\n      return;\n    }\n    LOG.debug(\"Marking container {} as inactive\", containerIdStr);\n    // this should ensure that if the container process has not launched\n    // by this time, it will never be launched\n    exec.deactivateContainer(containerId);\n    Path pidFilePath \u003d launch.getPidFilePath();\n    LOG.debug(\"Getting pid for container {} to kill\"\n        + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n        pidFilePath : \"null\");\n    // however the container process may have already started\n    try {\n\n      // get process id from pid file if available\n      // else if shell is still active, get it from the shell\n      String processId \u003d launch.getContainerPid();\n\n      // kill process\n      String user \u003d container.getUser();\n      if (processId !\u003d null) {\n        signalProcess(processId, user, containerIdStr);\n      } else {\n        // Normally this means that the process was notified about\n        // deactivateContainer above and did not start.\n        // Since we already set the state to RUNNING or REINITIALIZING\n        // we have to send a killed event to continue.\n        if (!launch.isLaunchCompleted()) {\n          LOG.warn(\"Container clean up before pid file created \"\n              + containerIdStr);\n          dispatcher.getEventHandler().handle(\n              new ContainerExitEvent(container.getContainerId(),\n                  ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                  Shell.WINDOWS ?\n                      ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                      ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                  \"Container terminated before pid file created.\"));\n          // There is a possibility that the launch grabbed the file name before\n          // the deactivateContainer above but it was slow enough to avoid\n          // getContainerPid.\n          // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS\n          // reduces the likelihood of this race condition and process leak.\n        }\n      }\n\n      // rm container in docker\n      if (OCIContainerRuntime.isOCICompliantContainerRequested(conf,\n          container.getLaunchContext().getEnvironment())) {\n        rmDockerContainerDelayed();\n      }\n    } catch (Exception e) {\n      String message \u003d\n          \"Exception when trying to cleanup container \" + containerIdStr\n              + \": \" + StringUtils.stringifyException(e);\n      LOG.warn(message);\n      dispatcher.getEventHandler().handle(\n          new ContainerDiagnosticsUpdateEvent(containerId, message));\n    } finally {\n      // cleanup pid file if present\n      if (pidFilePath !\u003d null) {\n        try {\n          FileContext lfs \u003d FileContext.getLocalFSFileContext();\n          lfs.delete(pidFilePath, false);\n          lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);\n        } catch (IOException ioe) {\n          LOG.warn(\"{} exception trying to delete pid file {}. Ignoring.\",\n              containerId, pidFilePath, ioe);\n        }\n      }\n    }\n\n    try {\n      // Reap the container\n      launch.reapContainer();\n    } catch (IOException ioe) {\n      LOG.warn(\"{} exception trying to reap container. Ignoring.\", containerId,\n          ioe);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerCleanup.java",
      "extendedDetails": {}
    },
    "79d3d35398cb5348cfd62e41e3318ec7a337421a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9486. Docker container exited with failure does not get clean up correctly. Contributed by Eric Yang\n",
      "commitDate": "25/04/19 6:21 PM",
      "commitName": "79d3d35398cb5348cfd62e41e3318ec7a337421a",
      "commitAuthor": "Eric Badger",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 41.08,
      "commitsBetweenForRepo": 273,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,97 @@\n   public void run() {\n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d containerId.toString();\n     LOG.info(\"Cleaning up container \" + containerIdStr);\n \n     try {\n       context.getNMStateStore().storeContainerKilled(containerId);\n     } catch (IOException e) {\n       LOG.error(\"Unable to mark container \" + containerId\n           + \" killed in store\", e);\n     }\n \n-    // launch flag will be set to true if process already launched\n-    boolean alreadyLaunched \u003d !launch.markLaunched();\n+    // launch flag will be set to true if process already launched,\n+    // in process of launching, or failed to launch.\n+    boolean alreadyLaunched \u003d !launch.markLaunched() ||\n+        launch.isLaunchCompleted();\n     if (!alreadyLaunched) {\n       LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n           + \" No cleanup needed to be done\");\n       return;\n     }\n     LOG.debug(\"Marking container {} as inactive\", containerIdStr);\n     // this should ensure that if the container process has not launched\n     // by this time, it will never be launched\n     exec.deactivateContainer(containerId);\n     Path pidFilePath \u003d launch.getPidFilePath();\n     LOG.debug(\"Getting pid for container {} to kill\"\n         + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n         pidFilePath : \"null\");\n     // however the container process may have already started\n     try {\n \n       // get process id from pid file if available\n       // else if shell is still active, get it from the shell\n       String processId \u003d launch.getContainerPid();\n \n       // kill process\n       String user \u003d container.getUser();\n       if (processId !\u003d null) {\n         signalProcess(processId, user, containerIdStr);\n       } else {\n         // Normally this means that the process was notified about\n         // deactivateContainer above and did not start.\n         // Since we already set the state to RUNNING or REINITIALIZING\n         // we have to send a killed event to continue.\n         if (!launch.isLaunchCompleted()) {\n           LOG.warn(\"Container clean up before pid file created \"\n               + containerIdStr);\n           dispatcher.getEventHandler().handle(\n               new ContainerExitEvent(container.getContainerId(),\n                   ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                   Shell.WINDOWS ?\n                       ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                       ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                   \"Container terminated before pid file created.\"));\n           // There is a possibility that the launch grabbed the file name before\n           // the deactivateContainer above but it was slow enough to avoid\n           // getContainerPid.\n           // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS\n           // reduces the likelihood of this race condition and process leak.\n         }\n       }\n \n       // rm container in docker\n       if (DockerLinuxContainerRuntime.isDockerContainerRequested(conf,\n           container.getLaunchContext().getEnvironment())) {\n         rmDockerContainerDelayed();\n       }\n     } catch (Exception e) {\n       String message \u003d\n           \"Exception when trying to cleanup container \" + containerIdStr\n               + \": \" + StringUtils.stringifyException(e);\n       LOG.warn(message);\n       dispatcher.getEventHandler().handle(\n           new ContainerDiagnosticsUpdateEvent(containerId, message));\n     } finally {\n       // cleanup pid file if present\n       if (pidFilePath !\u003d null) {\n         try {\n           FileContext lfs \u003d FileContext.getLocalFSFileContext();\n           lfs.delete(pidFilePath, false);\n           lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);\n         } catch (IOException ioe) {\n           LOG.warn(\"{} exception trying to delete pid file {}. Ignoring.\",\n               containerId, pidFilePath, ioe);\n         }\n       }\n     }\n \n     try {\n       // Reap the container\n       launch.reapContainer();\n     } catch (IOException ioe) {\n       LOG.warn(\"{} exception trying to reap container. Ignoring.\", containerId,\n           ioe);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n    LOG.info(\"Cleaning up container \" + containerIdStr);\n\n    try {\n      context.getNMStateStore().storeContainerKilled(containerId);\n    } catch (IOException e) {\n      LOG.error(\"Unable to mark container \" + containerId\n          + \" killed in store\", e);\n    }\n\n    // launch flag will be set to true if process already launched,\n    // in process of launching, or failed to launch.\n    boolean alreadyLaunched \u003d !launch.markLaunched() ||\n        launch.isLaunchCompleted();\n    if (!alreadyLaunched) {\n      LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n          + \" No cleanup needed to be done\");\n      return;\n    }\n    LOG.debug(\"Marking container {} as inactive\", containerIdStr);\n    // this should ensure that if the container process has not launched\n    // by this time, it will never be launched\n    exec.deactivateContainer(containerId);\n    Path pidFilePath \u003d launch.getPidFilePath();\n    LOG.debug(\"Getting pid for container {} to kill\"\n        + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n        pidFilePath : \"null\");\n    // however the container process may have already started\n    try {\n\n      // get process id from pid file if available\n      // else if shell is still active, get it from the shell\n      String processId \u003d launch.getContainerPid();\n\n      // kill process\n      String user \u003d container.getUser();\n      if (processId !\u003d null) {\n        signalProcess(processId, user, containerIdStr);\n      } else {\n        // Normally this means that the process was notified about\n        // deactivateContainer above and did not start.\n        // Since we already set the state to RUNNING or REINITIALIZING\n        // we have to send a killed event to continue.\n        if (!launch.isLaunchCompleted()) {\n          LOG.warn(\"Container clean up before pid file created \"\n              + containerIdStr);\n          dispatcher.getEventHandler().handle(\n              new ContainerExitEvent(container.getContainerId(),\n                  ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                  Shell.WINDOWS ?\n                      ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                      ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                  \"Container terminated before pid file created.\"));\n          // There is a possibility that the launch grabbed the file name before\n          // the deactivateContainer above but it was slow enough to avoid\n          // getContainerPid.\n          // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS\n          // reduces the likelihood of this race condition and process leak.\n        }\n      }\n\n      // rm container in docker\n      if (DockerLinuxContainerRuntime.isDockerContainerRequested(conf,\n          container.getLaunchContext().getEnvironment())) {\n        rmDockerContainerDelayed();\n      }\n    } catch (Exception e) {\n      String message \u003d\n          \"Exception when trying to cleanup container \" + containerIdStr\n              + \": \" + StringUtils.stringifyException(e);\n      LOG.warn(message);\n      dispatcher.getEventHandler().handle(\n          new ContainerDiagnosticsUpdateEvent(containerId, message));\n    } finally {\n      // cleanup pid file if present\n      if (pidFilePath !\u003d null) {\n        try {\n          FileContext lfs \u003d FileContext.getLocalFSFileContext();\n          lfs.delete(pidFilePath, false);\n          lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);\n        } catch (IOException ioe) {\n          LOG.warn(\"{} exception trying to delete pid file {}. Ignoring.\",\n              containerId, pidFilePath, ioe);\n        }\n      }\n    }\n\n    try {\n      // Reap the container\n      launch.reapContainer();\n    } catch (IOException ioe) {\n      LOG.warn(\"{} exception trying to reap container. Ignoring.\", containerId,\n          ioe);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerCleanup.java",
      "extendedDetails": {}
    },
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "28/01/19 3:05 PM",
      "commitNameOld": "2e636dd3c497a9f0042642296b127686012de57a",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 46.01,
      "commitsBetweenForRepo": 396,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,95 @@\n   public void run() {\n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d containerId.toString();\n     LOG.info(\"Cleaning up container \" + containerIdStr);\n \n     try {\n       context.getNMStateStore().storeContainerKilled(containerId);\n     } catch (IOException e) {\n       LOG.error(\"Unable to mark container \" + containerId\n           + \" killed in store\", e);\n     }\n \n     // launch flag will be set to true if process already launched\n     boolean alreadyLaunched \u003d !launch.markLaunched();\n     if (!alreadyLaunched) {\n       LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n           + \" No cleanup needed to be done\");\n       return;\n     }\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Marking container \" + containerIdStr + \" as inactive\");\n-    }\n+    LOG.debug(\"Marking container {} as inactive\", containerIdStr);\n     // this should ensure that if the container process has not launched\n     // by this time, it will never be launched\n     exec.deactivateContainer(containerId);\n     Path pidFilePath \u003d launch.getPidFilePath();\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Getting pid for container {} to kill\"\n-              + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n-          pidFilePath : \"null\");\n-    }\n-\n+    LOG.debug(\"Getting pid for container {} to kill\"\n+        + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n+        pidFilePath : \"null\");\n     // however the container process may have already started\n     try {\n \n       // get process id from pid file if available\n       // else if shell is still active, get it from the shell\n       String processId \u003d launch.getContainerPid();\n \n       // kill process\n       String user \u003d container.getUser();\n       if (processId !\u003d null) {\n         signalProcess(processId, user, containerIdStr);\n       } else {\n         // Normally this means that the process was notified about\n         // deactivateContainer above and did not start.\n         // Since we already set the state to RUNNING or REINITIALIZING\n         // we have to send a killed event to continue.\n         if (!launch.isLaunchCompleted()) {\n           LOG.warn(\"Container clean up before pid file created \"\n               + containerIdStr);\n           dispatcher.getEventHandler().handle(\n               new ContainerExitEvent(container.getContainerId(),\n                   ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                   Shell.WINDOWS ?\n                       ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                       ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                   \"Container terminated before pid file created.\"));\n           // There is a possibility that the launch grabbed the file name before\n           // the deactivateContainer above but it was slow enough to avoid\n           // getContainerPid.\n           // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS\n           // reduces the likelihood of this race condition and process leak.\n         }\n       }\n \n       // rm container in docker\n       if (DockerLinuxContainerRuntime.isDockerContainerRequested(conf,\n           container.getLaunchContext().getEnvironment())) {\n         rmDockerContainerDelayed();\n       }\n     } catch (Exception e) {\n       String message \u003d\n           \"Exception when trying to cleanup container \" + containerIdStr\n               + \": \" + StringUtils.stringifyException(e);\n       LOG.warn(message);\n       dispatcher.getEventHandler().handle(\n           new ContainerDiagnosticsUpdateEvent(containerId, message));\n     } finally {\n       // cleanup pid file if present\n       if (pidFilePath !\u003d null) {\n         try {\n           FileContext lfs \u003d FileContext.getLocalFSFileContext();\n           lfs.delete(pidFilePath, false);\n           lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);\n         } catch (IOException ioe) {\n           LOG.warn(\"{} exception trying to delete pid file {}. Ignoring.\",\n               containerId, pidFilePath, ioe);\n         }\n       }\n     }\n \n     try {\n       // Reap the container\n       launch.reapContainer();\n     } catch (IOException ioe) {\n       LOG.warn(\"{} exception trying to reap container. Ignoring.\", containerId,\n           ioe);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n    LOG.info(\"Cleaning up container \" + containerIdStr);\n\n    try {\n      context.getNMStateStore().storeContainerKilled(containerId);\n    } catch (IOException e) {\n      LOG.error(\"Unable to mark container \" + containerId\n          + \" killed in store\", e);\n    }\n\n    // launch flag will be set to true if process already launched\n    boolean alreadyLaunched \u003d !launch.markLaunched();\n    if (!alreadyLaunched) {\n      LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n          + \" No cleanup needed to be done\");\n      return;\n    }\n    LOG.debug(\"Marking container {} as inactive\", containerIdStr);\n    // this should ensure that if the container process has not launched\n    // by this time, it will never be launched\n    exec.deactivateContainer(containerId);\n    Path pidFilePath \u003d launch.getPidFilePath();\n    LOG.debug(\"Getting pid for container {} to kill\"\n        + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n        pidFilePath : \"null\");\n    // however the container process may have already started\n    try {\n\n      // get process id from pid file if available\n      // else if shell is still active, get it from the shell\n      String processId \u003d launch.getContainerPid();\n\n      // kill process\n      String user \u003d container.getUser();\n      if (processId !\u003d null) {\n        signalProcess(processId, user, containerIdStr);\n      } else {\n        // Normally this means that the process was notified about\n        // deactivateContainer above and did not start.\n        // Since we already set the state to RUNNING or REINITIALIZING\n        // we have to send a killed event to continue.\n        if (!launch.isLaunchCompleted()) {\n          LOG.warn(\"Container clean up before pid file created \"\n              + containerIdStr);\n          dispatcher.getEventHandler().handle(\n              new ContainerExitEvent(container.getContainerId(),\n                  ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                  Shell.WINDOWS ?\n                      ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                      ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                  \"Container terminated before pid file created.\"));\n          // There is a possibility that the launch grabbed the file name before\n          // the deactivateContainer above but it was slow enough to avoid\n          // getContainerPid.\n          // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS\n          // reduces the likelihood of this race condition and process leak.\n        }\n      }\n\n      // rm container in docker\n      if (DockerLinuxContainerRuntime.isDockerContainerRequested(conf,\n          container.getLaunchContext().getEnvironment())) {\n        rmDockerContainerDelayed();\n      }\n    } catch (Exception e) {\n      String message \u003d\n          \"Exception when trying to cleanup container \" + containerIdStr\n              + \": \" + StringUtils.stringifyException(e);\n      LOG.warn(message);\n      dispatcher.getEventHandler().handle(\n          new ContainerDiagnosticsUpdateEvent(containerId, message));\n    } finally {\n      // cleanup pid file if present\n      if (pidFilePath !\u003d null) {\n        try {\n          FileContext lfs \u003d FileContext.getLocalFSFileContext();\n          lfs.delete(pidFilePath, false);\n          lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);\n        } catch (IOException ioe) {\n          LOG.warn(\"{} exception trying to delete pid file {}. Ignoring.\",\n              containerId, pidFilePath, ioe);\n        }\n      }\n    }\n\n    try {\n      // Reap the container\n      launch.reapContainer();\n    } catch (IOException ioe) {\n      LOG.warn(\"{} exception trying to reap container. Ignoring.\", containerId,\n          ioe);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerCleanup.java",
      "extendedDetails": {}
    },
    "2e636dd3c497a9f0042642296b127686012de57a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9074. Consolidate docker removal logic in ContainerCleanup.\n           Contributed by Zhaohui Xin\n",
      "commitDate": "28/01/19 3:05 PM",
      "commitName": "2e636dd3c497a9f0042642296b127686012de57a",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "10/10/18 7:52 AM",
      "commitNameOld": "5ce70e1211e624d58e8bb1181aec00729ebdc085",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 110.34,
      "commitsBetweenForRepo": 815,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,100 @@\n   public void run() {\n     ContainerId containerId \u003d container.getContainerId();\n     String containerIdStr \u003d containerId.toString();\n     LOG.info(\"Cleaning up container \" + containerIdStr);\n \n     try {\n       context.getNMStateStore().storeContainerKilled(containerId);\n     } catch (IOException e) {\n       LOG.error(\"Unable to mark container \" + containerId\n           + \" killed in store\", e);\n     }\n \n     // launch flag will be set to true if process already launched\n     boolean alreadyLaunched \u003d !launch.markLaunched();\n     if (!alreadyLaunched) {\n       LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n           + \" No cleanup needed to be done\");\n       return;\n     }\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Marking container \" + containerIdStr + \" as inactive\");\n     }\n     // this should ensure that if the container process has not launched\n     // by this time, it will never be launched\n     exec.deactivateContainer(containerId);\n     Path pidFilePath \u003d launch.getPidFilePath();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Getting pid for container {} to kill\"\n               + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n           pidFilePath : \"null\");\n     }\n \n     // however the container process may have already started\n     try {\n \n       // get process id from pid file if available\n       // else if shell is still active, get it from the shell\n       String processId \u003d launch.getContainerPid();\n \n       // kill process\n       String user \u003d container.getUser();\n       if (processId !\u003d null) {\n         signalProcess(processId, user, containerIdStr);\n       } else {\n         // Normally this means that the process was notified about\n         // deactivateContainer above and did not start.\n         // Since we already set the state to RUNNING or REINITIALIZING\n         // we have to send a killed event to continue.\n         if (!launch.isLaunchCompleted()) {\n           LOG.warn(\"Container clean up before pid file created \"\n               + containerIdStr);\n           dispatcher.getEventHandler().handle(\n               new ContainerExitEvent(container.getContainerId(),\n                   ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                   Shell.WINDOWS ?\n                       ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                       ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                   \"Container terminated before pid file created.\"));\n           // There is a possibility that the launch grabbed the file name before\n           // the deactivateContainer above but it was slow enough to avoid\n           // getContainerPid.\n           // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS\n           // reduces the likelihood of this race condition and process leak.\n         }\n-        // The Docker container may not have fully started, reap the container.\n-        if (DockerLinuxContainerRuntime.isDockerContainerRequested(conf,\n-            container.getLaunchContext().getEnvironment())) {\n-          reapDockerContainerNoPid(user);\n-        }\n+      }\n+\n+      // rm container in docker\n+      if (DockerLinuxContainerRuntime.isDockerContainerRequested(conf,\n+          container.getLaunchContext().getEnvironment())) {\n+        rmDockerContainerDelayed();\n       }\n     } catch (Exception e) {\n       String message \u003d\n           \"Exception when trying to cleanup container \" + containerIdStr\n               + \": \" + StringUtils.stringifyException(e);\n       LOG.warn(message);\n       dispatcher.getEventHandler().handle(\n           new ContainerDiagnosticsUpdateEvent(containerId, message));\n     } finally {\n       // cleanup pid file if present\n       if (pidFilePath !\u003d null) {\n         try {\n           FileContext lfs \u003d FileContext.getLocalFSFileContext();\n           lfs.delete(pidFilePath, false);\n           lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);\n         } catch (IOException ioe) {\n           LOG.warn(\"{} exception trying to delete pid file {}. Ignoring.\",\n               containerId, pidFilePath, ioe);\n         }\n       }\n     }\n \n     try {\n       // Reap the container\n       launch.reapContainer();\n     } catch (IOException ioe) {\n       LOG.warn(\"{} exception trying to reap container. Ignoring.\", containerId,\n           ioe);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n    LOG.info(\"Cleaning up container \" + containerIdStr);\n\n    try {\n      context.getNMStateStore().storeContainerKilled(containerId);\n    } catch (IOException e) {\n      LOG.error(\"Unable to mark container \" + containerId\n          + \" killed in store\", e);\n    }\n\n    // launch flag will be set to true if process already launched\n    boolean alreadyLaunched \u003d !launch.markLaunched();\n    if (!alreadyLaunched) {\n      LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n          + \" No cleanup needed to be done\");\n      return;\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Marking container \" + containerIdStr + \" as inactive\");\n    }\n    // this should ensure that if the container process has not launched\n    // by this time, it will never be launched\n    exec.deactivateContainer(containerId);\n    Path pidFilePath \u003d launch.getPidFilePath();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Getting pid for container {} to kill\"\n              + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n          pidFilePath : \"null\");\n    }\n\n    // however the container process may have already started\n    try {\n\n      // get process id from pid file if available\n      // else if shell is still active, get it from the shell\n      String processId \u003d launch.getContainerPid();\n\n      // kill process\n      String user \u003d container.getUser();\n      if (processId !\u003d null) {\n        signalProcess(processId, user, containerIdStr);\n      } else {\n        // Normally this means that the process was notified about\n        // deactivateContainer above and did not start.\n        // Since we already set the state to RUNNING or REINITIALIZING\n        // we have to send a killed event to continue.\n        if (!launch.isLaunchCompleted()) {\n          LOG.warn(\"Container clean up before pid file created \"\n              + containerIdStr);\n          dispatcher.getEventHandler().handle(\n              new ContainerExitEvent(container.getContainerId(),\n                  ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                  Shell.WINDOWS ?\n                      ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                      ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                  \"Container terminated before pid file created.\"));\n          // There is a possibility that the launch grabbed the file name before\n          // the deactivateContainer above but it was slow enough to avoid\n          // getContainerPid.\n          // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS\n          // reduces the likelihood of this race condition and process leak.\n        }\n      }\n\n      // rm container in docker\n      if (DockerLinuxContainerRuntime.isDockerContainerRequested(conf,\n          container.getLaunchContext().getEnvironment())) {\n        rmDockerContainerDelayed();\n      }\n    } catch (Exception e) {\n      String message \u003d\n          \"Exception when trying to cleanup container \" + containerIdStr\n              + \": \" + StringUtils.stringifyException(e);\n      LOG.warn(message);\n      dispatcher.getEventHandler().handle(\n          new ContainerDiagnosticsUpdateEvent(containerId, message));\n    } finally {\n      // cleanup pid file if present\n      if (pidFilePath !\u003d null) {\n        try {\n          FileContext lfs \u003d FileContext.getLocalFSFileContext();\n          lfs.delete(pidFilePath, false);\n          lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);\n        } catch (IOException ioe) {\n          LOG.warn(\"{} exception trying to delete pid file {}. Ignoring.\",\n              containerId, pidFilePath, ioe);\n        }\n      }\n    }\n\n    try {\n      // Reap the container\n      launch.reapContainer();\n    } catch (IOException ioe) {\n      LOG.warn(\"{} exception trying to reap container. Ignoring.\", containerId,\n          ioe);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerCleanup.java",
      "extendedDetails": {}
    },
    "5ce70e1211e624d58e8bb1181aec00729ebdc085": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7644. NM gets backed up deleting docker containers. Contributed by Chandni Singh\n",
      "commitDate": "10/10/18 7:52 AM",
      "commitName": "5ce70e1211e624d58e8bb1181aec00729ebdc085",
      "commitAuthor": "Jason Lowe",
      "diff": "@@ -0,0 +1,99 @@\n+  public void run() {\n+    ContainerId containerId \u003d container.getContainerId();\n+    String containerIdStr \u003d containerId.toString();\n+    LOG.info(\"Cleaning up container \" + containerIdStr);\n+\n+    try {\n+      context.getNMStateStore().storeContainerKilled(containerId);\n+    } catch (IOException e) {\n+      LOG.error(\"Unable to mark container \" + containerId\n+          + \" killed in store\", e);\n+    }\n+\n+    // launch flag will be set to true if process already launched\n+    boolean alreadyLaunched \u003d !launch.markLaunched();\n+    if (!alreadyLaunched) {\n+      LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n+          + \" No cleanup needed to be done\");\n+      return;\n+    }\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Marking container \" + containerIdStr + \" as inactive\");\n+    }\n+    // this should ensure that if the container process has not launched\n+    // by this time, it will never be launched\n+    exec.deactivateContainer(containerId);\n+    Path pidFilePath \u003d launch.getPidFilePath();\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Getting pid for container {} to kill\"\n+              + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n+          pidFilePath : \"null\");\n+    }\n+\n+    // however the container process may have already started\n+    try {\n+\n+      // get process id from pid file if available\n+      // else if shell is still active, get it from the shell\n+      String processId \u003d launch.getContainerPid();\n+\n+      // kill process\n+      String user \u003d container.getUser();\n+      if (processId !\u003d null) {\n+        signalProcess(processId, user, containerIdStr);\n+      } else {\n+        // Normally this means that the process was notified about\n+        // deactivateContainer above and did not start.\n+        // Since we already set the state to RUNNING or REINITIALIZING\n+        // we have to send a killed event to continue.\n+        if (!launch.isLaunchCompleted()) {\n+          LOG.warn(\"Container clean up before pid file created \"\n+              + containerIdStr);\n+          dispatcher.getEventHandler().handle(\n+              new ContainerExitEvent(container.getContainerId(),\n+                  ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n+                  Shell.WINDOWS ?\n+                      ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n+                      ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n+                  \"Container terminated before pid file created.\"));\n+          // There is a possibility that the launch grabbed the file name before\n+          // the deactivateContainer above but it was slow enough to avoid\n+          // getContainerPid.\n+          // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS\n+          // reduces the likelihood of this race condition and process leak.\n+        }\n+        // The Docker container may not have fully started, reap the container.\n+        if (DockerLinuxContainerRuntime.isDockerContainerRequested(conf,\n+            container.getLaunchContext().getEnvironment())) {\n+          reapDockerContainerNoPid(user);\n+        }\n+      }\n+    } catch (Exception e) {\n+      String message \u003d\n+          \"Exception when trying to cleanup container \" + containerIdStr\n+              + \": \" + StringUtils.stringifyException(e);\n+      LOG.warn(message);\n+      dispatcher.getEventHandler().handle(\n+          new ContainerDiagnosticsUpdateEvent(containerId, message));\n+    } finally {\n+      // cleanup pid file if present\n+      if (pidFilePath !\u003d null) {\n+        try {\n+          FileContext lfs \u003d FileContext.getLocalFSFileContext();\n+          lfs.delete(pidFilePath, false);\n+          lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);\n+        } catch (IOException ioe) {\n+          LOG.warn(\"{} exception trying to delete pid file {}. Ignoring.\",\n+              containerId, pidFilePath, ioe);\n+        }\n+      }\n+    }\n+\n+    try {\n+      // Reap the container\n+      launch.reapContainer();\n+    } catch (IOException ioe) {\n+      LOG.warn(\"{} exception trying to reap container. Ignoring.\", containerId,\n+          ioe);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void run() {\n    ContainerId containerId \u003d container.getContainerId();\n    String containerIdStr \u003d containerId.toString();\n    LOG.info(\"Cleaning up container \" + containerIdStr);\n\n    try {\n      context.getNMStateStore().storeContainerKilled(containerId);\n    } catch (IOException e) {\n      LOG.error(\"Unable to mark container \" + containerId\n          + \" killed in store\", e);\n    }\n\n    // launch flag will be set to true if process already launched\n    boolean alreadyLaunched \u003d !launch.markLaunched();\n    if (!alreadyLaunched) {\n      LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n          + \" No cleanup needed to be done\");\n      return;\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Marking container \" + containerIdStr + \" as inactive\");\n    }\n    // this should ensure that if the container process has not launched\n    // by this time, it will never be launched\n    exec.deactivateContainer(containerId);\n    Path pidFilePath \u003d launch.getPidFilePath();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Getting pid for container {} to kill\"\n              + \" from pid file {}\", containerIdStr, pidFilePath !\u003d null ?\n          pidFilePath : \"null\");\n    }\n\n    // however the container process may have already started\n    try {\n\n      // get process id from pid file if available\n      // else if shell is still active, get it from the shell\n      String processId \u003d launch.getContainerPid();\n\n      // kill process\n      String user \u003d container.getUser();\n      if (processId !\u003d null) {\n        signalProcess(processId, user, containerIdStr);\n      } else {\n        // Normally this means that the process was notified about\n        // deactivateContainer above and did not start.\n        // Since we already set the state to RUNNING or REINITIALIZING\n        // we have to send a killed event to continue.\n        if (!launch.isLaunchCompleted()) {\n          LOG.warn(\"Container clean up before pid file created \"\n              + containerIdStr);\n          dispatcher.getEventHandler().handle(\n              new ContainerExitEvent(container.getContainerId(),\n                  ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                  Shell.WINDOWS ?\n                      ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                      ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                  \"Container terminated before pid file created.\"));\n          // There is a possibility that the launch grabbed the file name before\n          // the deactivateContainer above but it was slow enough to avoid\n          // getContainerPid.\n          // Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS\n          // reduces the likelihood of this race condition and process leak.\n        }\n        // The Docker container may not have fully started, reap the container.\n        if (DockerLinuxContainerRuntime.isDockerContainerRequested(conf,\n            container.getLaunchContext().getEnvironment())) {\n          reapDockerContainerNoPid(user);\n        }\n      }\n    } catch (Exception e) {\n      String message \u003d\n          \"Exception when trying to cleanup container \" + containerIdStr\n              + \": \" + StringUtils.stringifyException(e);\n      LOG.warn(message);\n      dispatcher.getEventHandler().handle(\n          new ContainerDiagnosticsUpdateEvent(containerId, message));\n    } finally {\n      // cleanup pid file if present\n      if (pidFilePath !\u003d null) {\n        try {\n          FileContext lfs \u003d FileContext.getLocalFSFileContext();\n          lfs.delete(pidFilePath, false);\n          lfs.delete(pidFilePath.suffix(EXIT_CODE_FILE_SUFFIX), false);\n        } catch (IOException ioe) {\n          LOG.warn(\"{} exception trying to delete pid file {}. Ignoring.\",\n              containerId, pidFilePath, ioe);\n        }\n      }\n    }\n\n    try {\n      // Reap the container\n      launch.reapContainer();\n    } catch (IOException ioe) {\n      LOG.warn(\"{} exception trying to reap container. Ignoring.\", containerId,\n          ioe);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainerCleanup.java"
    }
  }
}