{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StoragePolicySatisfier.java",
  "functionName": "findSourceAndTargetToMove",
  "functionId": "findSourceAndTargetToMove___blockMovingInfos-List__BlockMovingInfo____blockInfo-LocatedBlock__sourceWithStorageList-List__StorageTypeNodePair____expectedTypes-List__StorageType____targetDns-EnumMap__StorageType,List__DatanodeWithStorage.StorageDetails______ecPolicy-ErasureCodingPolicy__excludeNodes-List__DatanodeInfo__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
  "functionStartLine": 590,
  "functionEndLine": 683,
  "numCommitsSeen": 88,
  "timeTaken": 13931,
  "changeHistory": [
    "2acc50b826fa8b00f2b09d9546c4b3215b89d46d",
    "75ccc1396b677777cdc0d4992a4af3911f9f88c2",
    "3159b39cf8ef704835325263154fb1a1cecc109d",
    "8d4f74e7339abc77dc0daa162d7bd2814bd79b3d",
    "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d",
    "78420719eb1f138c6f10558befb7bc8ebcc28a54",
    "00eceed233d6e80d5c7137bf5b5286746ec4d5fb",
    "20f9c623360d8ec534f8ddb0b993b4363a359e89",
    "f8fc96a66ea3cbd41a3915c4546ff816451cf9db",
    "df2b551e79c9e5d8bdd981c48be52bae5f0d9a82",
    "b7bed9f00a25bcad6f9c3543f5a1fb0a1f23b0e9",
    "b07291e176c489c2eec3da1850b790b8ba691a3e",
    "1438da494424193e330f24edef823bbd60dc37d2"
  ],
  "changeHistoryShort": {
    "2acc50b826fa8b00f2b09d9546c4b3215b89d46d": "Ymultichange(Yparameterchange,Ybodychange)",
    "75ccc1396b677777cdc0d4992a4af3911f9f88c2": "Ymultichange(Yparameterchange,Ybodychange)",
    "3159b39cf8ef704835325263154fb1a1cecc109d": "Ybodychange",
    "8d4f74e7339abc77dc0daa162d7bd2814bd79b3d": "Ybodychange",
    "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d": "Ymultichange(Yparameterchange,Ybodychange)",
    "78420719eb1f138c6f10558befb7bc8ebcc28a54": "Yfilerename",
    "00eceed233d6e80d5c7137bf5b5286746ec4d5fb": "Ybodychange",
    "20f9c623360d8ec534f8ddb0b993b4363a359e89": "Ybodychange",
    "f8fc96a66ea3cbd41a3915c4546ff816451cf9db": "Ybodychange",
    "df2b551e79c9e5d8bdd981c48be52bae5f0d9a82": "Ymultichange(Yparameterchange,Ybodychange)",
    "b7bed9f00a25bcad6f9c3543f5a1fb0a1f23b0e9": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "b07291e176c489c2eec3da1850b790b8ba691a3e": "Ybodychange",
    "1438da494424193e330f24edef823bbd60dc37d2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2acc50b826fa8b00f2b09d9546c4b3215b89d46d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-13165: [SPS]: Collects successfully moved block details via IBR. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "2acc50b826fa8b00f2b09d9546c4b3215b89d46d",
      "commitAuthor": "Rakesh Radhakrishnan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-13165: [SPS]: Collects successfully moved block details via IBR. Contributed by Rakesh R.\n",
          "commitDate": "12/08/18 3:06 AM",
          "commitName": "2acc50b826fa8b00f2b09d9546c4b3215b89d46d",
          "commitAuthor": "Rakesh Radhakrishnan",
          "commitDateOld": "12/08/18 3:06 AM",
          "commitNameOld": "75ccc1396b677777cdc0d4992a4af3911f9f88c2",
          "commitAuthorOld": "Surendra Singh Lilhore",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,94 @@\n   private boolean findSourceAndTargetToMove(\n       List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expectedTypes,\n       EnumMap\u003cStorageType, List\u003cDatanodeWithStorage.StorageDetails\u003e\u003e targetDns,\n-      ErasureCodingPolicy ecPolicy) {\n+      ErasureCodingPolicy ecPolicy, List\u003cDatanodeInfo\u003e excludeNodes) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n-    List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n \n       // Check whether the block replica is already placed in the expected\n       // storage type in this source datanode.\n       if (!expectedTypes.contains(existingTypeNodePair.storageType)) {\n         StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n             existingTypeNodePair.dn, targetDns, expectedTypes);\n         if (chosenTarget !\u003d null) {\n           if (blockInfo.isStriped()) {\n             buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos,\n                 ecPolicy);\n           } else {\n             buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos);\n           }\n           expectedTypes.remove(chosenTarget.storageType);\n         }\n       }\n-      // To avoid choosing this excludeNodes as targets later\n-      excludeNodes.add(existingTypeNodePair.dn);\n     }\n-\n+    // If all the sources and targets are paired within same node, then simply\n+    // return.\n+    if (expectedTypes.size() \u003c\u003d 0) {\n+      return foundMatchingTargetNodesForBlock;\n+    }\n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n       if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n         continue;\n       }\n       if (chosenTarget \u003d\u003d null \u0026\u0026 dnCacheMgr.getCluster().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expectedTypes, Matcher.SAME_NODE_GROUP, targetDns,\n             excludeNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n                 Matcher.SAME_RACK, targetDns, excludeNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n                 Matcher.ANY_OTHER, targetDns, excludeNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         if (blockInfo.isStriped()) {\n           buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos, ecPolicy);\n         } else {\n           buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos);\n         }\n \n         expectedTypes.remove(chosenTarget.storageType);\n         excludeNodes.add(chosenTarget.dn);\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expectedTypes, blockInfo, existingTypeNodePair.storageType);\n       }\n     }\n \n     if (expectedTypes.size() \u003e 0) {\n       foundMatchingTargetNodesForBlock \u003d false;\n     }\n \n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expectedTypes,\n      EnumMap\u003cStorageType, List\u003cDatanodeWithStorage.StorageDetails\u003e\u003e targetDns,\n      ErasureCodingPolicy ecPolicy, List\u003cDatanodeInfo\u003e excludeNodes) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n\n      // Check whether the block replica is already placed in the expected\n      // storage type in this source datanode.\n      if (!expectedTypes.contains(existingTypeNodePair.storageType)) {\n        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n            existingTypeNodePair.dn, targetDns, expectedTypes);\n        if (chosenTarget !\u003d null) {\n          if (blockInfo.isStriped()) {\n            buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos,\n                ecPolicy);\n          } else {\n            buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos);\n          }\n          expectedTypes.remove(chosenTarget.storageType);\n        }\n      }\n    }\n    // If all the sources and targets are paired within same node, then simply\n    // return.\n    if (expectedTypes.size() \u003c\u003d 0) {\n      return foundMatchingTargetNodesForBlock;\n    }\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 dnCacheMgr.getCluster().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expectedTypes, Matcher.SAME_NODE_GROUP, targetDns,\n            excludeNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n                Matcher.SAME_RACK, targetDns, excludeNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n                Matcher.ANY_OTHER, targetDns, excludeNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        if (blockInfo.isStriped()) {\n          buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos, ecPolicy);\n        } else {\n          buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos);\n        }\n\n        expectedTypes.remove(chosenTarget.storageType);\n        excludeNodes.add(chosenTarget.dn);\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expectedTypes, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expectedTypes.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    return foundMatchingTargetNodesForBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
          "extendedDetails": {
            "oldValue": "[blockMovingInfos-List\u003cBlockMovingInfo\u003e, blockInfo-LocatedBlock, sourceWithStorageList-List\u003cStorageTypeNodePair\u003e, expectedTypes-List\u003cStorageType\u003e, targetDns-EnumMap\u003cStorageType,List\u003cDatanodeWithStorage.StorageDetails\u003e\u003e, ecPolicy-ErasureCodingPolicy]",
            "newValue": "[blockMovingInfos-List\u003cBlockMovingInfo\u003e, blockInfo-LocatedBlock, sourceWithStorageList-List\u003cStorageTypeNodePair\u003e, expectedTypes-List\u003cStorageType\u003e, targetDns-EnumMap\u003cStorageType,List\u003cDatanodeWithStorage.StorageDetails\u003e\u003e, ecPolicy-ErasureCodingPolicy, excludeNodes-List\u003cDatanodeInfo\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13165: [SPS]: Collects successfully moved block details via IBR. Contributed by Rakesh R.\n",
          "commitDate": "12/08/18 3:06 AM",
          "commitName": "2acc50b826fa8b00f2b09d9546c4b3215b89d46d",
          "commitAuthor": "Rakesh Radhakrishnan",
          "commitDateOld": "12/08/18 3:06 AM",
          "commitNameOld": "75ccc1396b677777cdc0d4992a4af3911f9f88c2",
          "commitAuthorOld": "Surendra Singh Lilhore",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,94 @@\n   private boolean findSourceAndTargetToMove(\n       List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expectedTypes,\n       EnumMap\u003cStorageType, List\u003cDatanodeWithStorage.StorageDetails\u003e\u003e targetDns,\n-      ErasureCodingPolicy ecPolicy) {\n+      ErasureCodingPolicy ecPolicy, List\u003cDatanodeInfo\u003e excludeNodes) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n-    List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n \n       // Check whether the block replica is already placed in the expected\n       // storage type in this source datanode.\n       if (!expectedTypes.contains(existingTypeNodePair.storageType)) {\n         StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n             existingTypeNodePair.dn, targetDns, expectedTypes);\n         if (chosenTarget !\u003d null) {\n           if (blockInfo.isStriped()) {\n             buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos,\n                 ecPolicy);\n           } else {\n             buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos);\n           }\n           expectedTypes.remove(chosenTarget.storageType);\n         }\n       }\n-      // To avoid choosing this excludeNodes as targets later\n-      excludeNodes.add(existingTypeNodePair.dn);\n     }\n-\n+    // If all the sources and targets are paired within same node, then simply\n+    // return.\n+    if (expectedTypes.size() \u003c\u003d 0) {\n+      return foundMatchingTargetNodesForBlock;\n+    }\n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n       if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n         continue;\n       }\n       if (chosenTarget \u003d\u003d null \u0026\u0026 dnCacheMgr.getCluster().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expectedTypes, Matcher.SAME_NODE_GROUP, targetDns,\n             excludeNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n                 Matcher.SAME_RACK, targetDns, excludeNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n                 Matcher.ANY_OTHER, targetDns, excludeNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         if (blockInfo.isStriped()) {\n           buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos, ecPolicy);\n         } else {\n           buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos);\n         }\n \n         expectedTypes.remove(chosenTarget.storageType);\n         excludeNodes.add(chosenTarget.dn);\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expectedTypes, blockInfo, existingTypeNodePair.storageType);\n       }\n     }\n \n     if (expectedTypes.size() \u003e 0) {\n       foundMatchingTargetNodesForBlock \u003d false;\n     }\n \n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expectedTypes,\n      EnumMap\u003cStorageType, List\u003cDatanodeWithStorage.StorageDetails\u003e\u003e targetDns,\n      ErasureCodingPolicy ecPolicy, List\u003cDatanodeInfo\u003e excludeNodes) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n\n      // Check whether the block replica is already placed in the expected\n      // storage type in this source datanode.\n      if (!expectedTypes.contains(existingTypeNodePair.storageType)) {\n        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n            existingTypeNodePair.dn, targetDns, expectedTypes);\n        if (chosenTarget !\u003d null) {\n          if (blockInfo.isStriped()) {\n            buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos,\n                ecPolicy);\n          } else {\n            buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos);\n          }\n          expectedTypes.remove(chosenTarget.storageType);\n        }\n      }\n    }\n    // If all the sources and targets are paired within same node, then simply\n    // return.\n    if (expectedTypes.size() \u003c\u003d 0) {\n      return foundMatchingTargetNodesForBlock;\n    }\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 dnCacheMgr.getCluster().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expectedTypes, Matcher.SAME_NODE_GROUP, targetDns,\n            excludeNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n                Matcher.SAME_RACK, targetDns, excludeNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n                Matcher.ANY_OTHER, targetDns, excludeNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        if (blockInfo.isStriped()) {\n          buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos, ecPolicy);\n        } else {\n          buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos);\n        }\n\n        expectedTypes.remove(chosenTarget.storageType);\n        excludeNodes.add(chosenTarget.dn);\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expectedTypes, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expectedTypes.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    return foundMatchingTargetNodesForBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
          "extendedDetails": {}
        }
      ]
    },
    "75ccc1396b677777cdc0d4992a4af3911f9f88c2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-13166: [SPS]: Implement caching mechanism to keep LIVE datanodes to minimize costly getLiveDatanodeStorageReport() calls. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "75ccc1396b677777cdc0d4992a4af3911f9f88c2",
      "commitAuthor": "Surendra Singh Lilhore",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-13166: [SPS]: Implement caching mechanism to keep LIVE datanodes to minimize costly getLiveDatanodeStorageReport() calls. Contributed by Rakesh R.\n",
          "commitDate": "12/08/18 3:06 AM",
          "commitName": "75ccc1396b677777cdc0d4992a4af3911f9f88c2",
          "commitAuthor": "Surendra Singh Lilhore",
          "commitDateOld": "12/08/18 3:06 AM",
          "commitNameOld": "8467ec24fb74f30371d5a13e893fc56309ee9372",
          "commitAuthorOld": "Rakesh Radhakrishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,93 @@\n   private boolean findSourceAndTargetToMove(\n       List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n-      List\u003cStorageType\u003e expected,\n-      StorageTypeNodeMap locsForExpectedStorageTypes,\n+      List\u003cStorageType\u003e expectedTypes,\n+      EnumMap\u003cStorageType, List\u003cDatanodeWithStorage.StorageDetails\u003e\u003e targetDns,\n       ErasureCodingPolicy ecPolicy) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n     List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n \n       // Check whether the block replica is already placed in the expected\n       // storage type in this source datanode.\n-      if (!expected.contains(existingTypeNodePair.storageType)) {\n+      if (!expectedTypes.contains(existingTypeNodePair.storageType)) {\n         StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n-            existingTypeNodePair.dn, expected);\n+            existingTypeNodePair.dn, targetDns, expectedTypes);\n         if (chosenTarget !\u003d null) {\n           if (blockInfo.isStriped()) {\n             buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos,\n                 ecPolicy);\n           } else {\n             buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos);\n           }\n-          expected.remove(chosenTarget.storageType);\n+          expectedTypes.remove(chosenTarget.storageType);\n         }\n       }\n       // To avoid choosing this excludeNodes as targets later\n       excludeNodes.add(existingTypeNodePair.dn);\n     }\n \n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n       if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n         continue;\n       }\n-      if (chosenTarget \u003d\u003d null \u0026\u0026 ctxt\n-          .getNetworkTopology().isNodeGroupAware()) {\n+      if (chosenTarget \u003d\u003d null \u0026\u0026 dnCacheMgr.getCluster().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n-            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n+            expectedTypes, Matcher.SAME_NODE_GROUP, targetDns,\n             excludeNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n-            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n-                Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n+            chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n+                Matcher.SAME_RACK, targetDns, excludeNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n-            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n-                Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n+            chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n+                Matcher.ANY_OTHER, targetDns, excludeNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         if (blockInfo.isStriped()) {\n           buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos, ecPolicy);\n         } else {\n           buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos);\n         }\n \n-        expected.remove(chosenTarget.storageType);\n+        expectedTypes.remove(chosenTarget.storageType);\n         excludeNodes.add(chosenTarget.dn);\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n-            expected, blockInfo, existingTypeNodePair.storageType);\n+            expectedTypes, blockInfo, existingTypeNodePair.storageType);\n       }\n     }\n \n-    if (expected.size() \u003e 0) {\n+    if (expectedTypes.size() \u003e 0) {\n       foundMatchingTargetNodesForBlock \u003d false;\n     }\n \n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expectedTypes,\n      EnumMap\u003cStorageType, List\u003cDatanodeWithStorage.StorageDetails\u003e\u003e targetDns,\n      ErasureCodingPolicy ecPolicy) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n\n      // Check whether the block replica is already placed in the expected\n      // storage type in this source datanode.\n      if (!expectedTypes.contains(existingTypeNodePair.storageType)) {\n        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n            existingTypeNodePair.dn, targetDns, expectedTypes);\n        if (chosenTarget !\u003d null) {\n          if (blockInfo.isStriped()) {\n            buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos,\n                ecPolicy);\n          } else {\n            buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos);\n          }\n          expectedTypes.remove(chosenTarget.storageType);\n        }\n      }\n      // To avoid choosing this excludeNodes as targets later\n      excludeNodes.add(existingTypeNodePair.dn);\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 dnCacheMgr.getCluster().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expectedTypes, Matcher.SAME_NODE_GROUP, targetDns,\n            excludeNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n                Matcher.SAME_RACK, targetDns, excludeNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n                Matcher.ANY_OTHER, targetDns, excludeNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        if (blockInfo.isStriped()) {\n          buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos, ecPolicy);\n        } else {\n          buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos);\n        }\n\n        expectedTypes.remove(chosenTarget.storageType);\n        excludeNodes.add(chosenTarget.dn);\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expectedTypes, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expectedTypes.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    return foundMatchingTargetNodesForBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
          "extendedDetails": {
            "oldValue": "[blockMovingInfos-List\u003cBlockMovingInfo\u003e, blockInfo-LocatedBlock, sourceWithStorageList-List\u003cStorageTypeNodePair\u003e, expected-List\u003cStorageType\u003e, locsForExpectedStorageTypes-StorageTypeNodeMap, ecPolicy-ErasureCodingPolicy]",
            "newValue": "[blockMovingInfos-List\u003cBlockMovingInfo\u003e, blockInfo-LocatedBlock, sourceWithStorageList-List\u003cStorageTypeNodePair\u003e, expectedTypes-List\u003cStorageType\u003e, targetDns-EnumMap\u003cStorageType,List\u003cDatanodeWithStorage.StorageDetails\u003e\u003e, ecPolicy-ErasureCodingPolicy]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13166: [SPS]: Implement caching mechanism to keep LIVE datanodes to minimize costly getLiveDatanodeStorageReport() calls. Contributed by Rakesh R.\n",
          "commitDate": "12/08/18 3:06 AM",
          "commitName": "75ccc1396b677777cdc0d4992a4af3911f9f88c2",
          "commitAuthor": "Surendra Singh Lilhore",
          "commitDateOld": "12/08/18 3:06 AM",
          "commitNameOld": "8467ec24fb74f30371d5a13e893fc56309ee9372",
          "commitAuthorOld": "Rakesh Radhakrishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,93 @@\n   private boolean findSourceAndTargetToMove(\n       List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n-      List\u003cStorageType\u003e expected,\n-      StorageTypeNodeMap locsForExpectedStorageTypes,\n+      List\u003cStorageType\u003e expectedTypes,\n+      EnumMap\u003cStorageType, List\u003cDatanodeWithStorage.StorageDetails\u003e\u003e targetDns,\n       ErasureCodingPolicy ecPolicy) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n     List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n \n       // Check whether the block replica is already placed in the expected\n       // storage type in this source datanode.\n-      if (!expected.contains(existingTypeNodePair.storageType)) {\n+      if (!expectedTypes.contains(existingTypeNodePair.storageType)) {\n         StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n-            existingTypeNodePair.dn, expected);\n+            existingTypeNodePair.dn, targetDns, expectedTypes);\n         if (chosenTarget !\u003d null) {\n           if (blockInfo.isStriped()) {\n             buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos,\n                 ecPolicy);\n           } else {\n             buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos);\n           }\n-          expected.remove(chosenTarget.storageType);\n+          expectedTypes.remove(chosenTarget.storageType);\n         }\n       }\n       // To avoid choosing this excludeNodes as targets later\n       excludeNodes.add(existingTypeNodePair.dn);\n     }\n \n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n       if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n         continue;\n       }\n-      if (chosenTarget \u003d\u003d null \u0026\u0026 ctxt\n-          .getNetworkTopology().isNodeGroupAware()) {\n+      if (chosenTarget \u003d\u003d null \u0026\u0026 dnCacheMgr.getCluster().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n-            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n+            expectedTypes, Matcher.SAME_NODE_GROUP, targetDns,\n             excludeNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n-            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n-                Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n+            chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n+                Matcher.SAME_RACK, targetDns, excludeNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n-            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n-                Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n+            chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n+                Matcher.ANY_OTHER, targetDns, excludeNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         if (blockInfo.isStriped()) {\n           buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos, ecPolicy);\n         } else {\n           buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos);\n         }\n \n-        expected.remove(chosenTarget.storageType);\n+        expectedTypes.remove(chosenTarget.storageType);\n         excludeNodes.add(chosenTarget.dn);\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n-            expected, blockInfo, existingTypeNodePair.storageType);\n+            expectedTypes, blockInfo, existingTypeNodePair.storageType);\n       }\n     }\n \n-    if (expected.size() \u003e 0) {\n+    if (expectedTypes.size() \u003e 0) {\n       foundMatchingTargetNodesForBlock \u003d false;\n     }\n \n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expectedTypes,\n      EnumMap\u003cStorageType, List\u003cDatanodeWithStorage.StorageDetails\u003e\u003e targetDns,\n      ErasureCodingPolicy ecPolicy) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n\n      // Check whether the block replica is already placed in the expected\n      // storage type in this source datanode.\n      if (!expectedTypes.contains(existingTypeNodePair.storageType)) {\n        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n            existingTypeNodePair.dn, targetDns, expectedTypes);\n        if (chosenTarget !\u003d null) {\n          if (blockInfo.isStriped()) {\n            buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos,\n                ecPolicy);\n          } else {\n            buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos);\n          }\n          expectedTypes.remove(chosenTarget.storageType);\n        }\n      }\n      // To avoid choosing this excludeNodes as targets later\n      excludeNodes.add(existingTypeNodePair.dn);\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 dnCacheMgr.getCluster().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expectedTypes, Matcher.SAME_NODE_GROUP, targetDns,\n            excludeNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n                Matcher.SAME_RACK, targetDns, excludeNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expectedTypes,\n                Matcher.ANY_OTHER, targetDns, excludeNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        if (blockInfo.isStriped()) {\n          buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos, ecPolicy);\n        } else {\n          buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos);\n        }\n\n        expectedTypes.remove(chosenTarget.storageType);\n        excludeNodes.add(chosenTarget.dn);\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expectedTypes, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expectedTypes.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    return foundMatchingTargetNodesForBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
          "extendedDetails": {}
        }
      ]
    },
    "3159b39cf8ef704835325263154fb1a1cecc109d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13025. [SPS]: Implement a mechanism to scan the files for external SPS. Contributed by Uma Maheswara Rao G.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "3159b39cf8ef704835325263154fb1a1cecc109d",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "8d4f74e7339abc77dc0daa162d7bd2814bd79b3d",
      "commitAuthorOld": "Rakesh Radhakrishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,94 @@\n   private boolean findSourceAndTargetToMove(\n       List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n       StorageTypeNodeMap locsForExpectedStorageTypes,\n       ErasureCodingPolicy ecPolicy) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n     List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n \n       // Check whether the block replica is already placed in the expected\n       // storage type in this source datanode.\n       if (!expected.contains(existingTypeNodePair.storageType)) {\n         StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n             existingTypeNodePair.dn, expected);\n         if (chosenTarget !\u003d null) {\n           if (blockInfo.isStriped()) {\n             buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos,\n                 ecPolicy);\n           } else {\n             buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos);\n           }\n           expected.remove(chosenTarget.storageType);\n-          // TODO: We can increment scheduled block count for this node?\n         }\n       }\n       // To avoid choosing this excludeNodes as targets later\n       excludeNodes.add(existingTypeNodePair.dn);\n     }\n \n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n       if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n         continue;\n       }\n       if (chosenTarget \u003d\u003d null \u0026\u0026 ctxt\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n             excludeNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         if (blockInfo.isStriped()) {\n           buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos, ecPolicy);\n         } else {\n           buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos);\n         }\n \n         expected.remove(chosenTarget.storageType);\n         excludeNodes.add(chosenTarget.dn);\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expected, blockInfo, existingTypeNodePair.storageType);\n       }\n     }\n \n     if (expected.size() \u003e 0) {\n       foundMatchingTargetNodesForBlock \u003d false;\n     }\n \n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes,\n      ErasureCodingPolicy ecPolicy) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n\n      // Check whether the block replica is already placed in the expected\n      // storage type in this source datanode.\n      if (!expected.contains(existingTypeNodePair.storageType)) {\n        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n            existingTypeNodePair.dn, expected);\n        if (chosenTarget !\u003d null) {\n          if (blockInfo.isStriped()) {\n            buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos,\n                ecPolicy);\n          } else {\n            buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos);\n          }\n          expected.remove(chosenTarget.storageType);\n        }\n      }\n      // To avoid choosing this excludeNodes as targets later\n      excludeNodes.add(existingTypeNodePair.dn);\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 ctxt\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            excludeNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        if (blockInfo.isStriped()) {\n          buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos, ecPolicy);\n        } else {\n          buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos);\n        }\n\n        expected.remove(chosenTarget.storageType);\n        excludeNodes.add(chosenTarget.dn);\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expected.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    return foundMatchingTargetNodesForBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
      "extendedDetails": {}
    },
    "8d4f74e7339abc77dc0daa162d7bd2814bd79b3d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12911. [SPS]: Modularize the SPS code and expose necessary interfaces for external/internal implementations. Contributed by Uma Maheswara Rao G\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "8d4f74e7339abc77dc0daa162d7bd2814bd79b3d",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,95 @@\n   private boolean findSourceAndTargetToMove(\n       List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n       StorageTypeNodeMap locsForExpectedStorageTypes,\n       ErasureCodingPolicy ecPolicy) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n     List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n \n       // Check whether the block replica is already placed in the expected\n       // storage type in this source datanode.\n       if (!expected.contains(existingTypeNodePair.storageType)) {\n         StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n             existingTypeNodePair.dn, expected);\n         if (chosenTarget !\u003d null) {\n           if (blockInfo.isStriped()) {\n             buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos,\n                 ecPolicy);\n           } else {\n             buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos);\n           }\n           expected.remove(chosenTarget.storageType);\n           // TODO: We can increment scheduled block count for this node?\n         }\n       }\n       // To avoid choosing this excludeNodes as targets later\n       excludeNodes.add(existingTypeNodePair.dn);\n     }\n \n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n       if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n         continue;\n       }\n       if (chosenTarget \u003d\u003d null \u0026\u0026 ctxt\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n             excludeNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         if (blockInfo.isStriped()) {\n           buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos, ecPolicy);\n         } else {\n           buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos);\n         }\n \n         expected.remove(chosenTarget.storageType);\n         excludeNodes.add(chosenTarget.dn);\n-        // TODO: We can increment scheduled block count for this node?\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expected, blockInfo, existingTypeNodePair.storageType);\n       }\n     }\n \n     if (expected.size() \u003e 0) {\n       foundMatchingTargetNodesForBlock \u003d false;\n     }\n \n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes,\n      ErasureCodingPolicy ecPolicy) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n\n      // Check whether the block replica is already placed in the expected\n      // storage type in this source datanode.\n      if (!expected.contains(existingTypeNodePair.storageType)) {\n        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n            existingTypeNodePair.dn, expected);\n        if (chosenTarget !\u003d null) {\n          if (blockInfo.isStriped()) {\n            buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos,\n                ecPolicy);\n          } else {\n            buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos);\n          }\n          expected.remove(chosenTarget.storageType);\n          // TODO: We can increment scheduled block count for this node?\n        }\n      }\n      // To avoid choosing this excludeNodes as targets later\n      excludeNodes.add(existingTypeNodePair.dn);\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 ctxt\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            excludeNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        if (blockInfo.isStriped()) {\n          buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos, ecPolicy);\n        } else {\n          buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos);\n        }\n\n        expected.remove(chosenTarget.storageType);\n        excludeNodes.add(chosenTarget.dn);\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expected.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    return foundMatchingTargetNodesForBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
      "extendedDetails": {}
    },
    "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-12982 : [SPS]: Reduce the locking and cleanup the Namesystem access. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d",
      "commitAuthor": "Surendra Singh Lilhore",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-12982 : [SPS]: Reduce the locking and cleanup the Namesystem access. Contributed by Rakesh R.\n",
          "commitDate": "12/08/18 3:06 AM",
          "commitName": "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d",
          "commitAuthor": "Surendra Singh Lilhore",
          "commitDateOld": "12/08/18 3:06 AM",
          "commitNameOld": "78420719eb1f138c6f10558befb7bc8ebcc28a54",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,96 @@\n   private boolean findSourceAndTargetToMove(\n-      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n+      List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n-      StorageTypeNodeMap locsForExpectedStorageTypes) {\n+      StorageTypeNodeMap locsForExpectedStorageTypes,\n+      ErasureCodingPolicy ecPolicy) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n-    List\u003cDatanodeDescriptor\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n+    List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n \n       // Check whether the block replica is already placed in the expected\n       // storage type in this source datanode.\n       if (!expected.contains(existingTypeNodePair.storageType)) {\n-        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n-            blockInfo, existingTypeNodePair.dn, expected);\n+        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n+            existingTypeNodePair.dn, expected);\n         if (chosenTarget !\u003d null) {\n           if (blockInfo.isStriped()) {\n             buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n-                chosenTarget.storageType, blockMovingInfos);\n+                chosenTarget.storageType, blockMovingInfos,\n+                ecPolicy);\n           } else {\n             buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos);\n           }\n           expected.remove(chosenTarget.storageType);\n           // TODO: We can increment scheduled block count for this node?\n         }\n       }\n       // To avoid choosing this excludeNodes as targets later\n       excludeNodes.add(existingTypeNodePair.dn);\n     }\n \n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n       if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n         continue;\n       }\n-      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n+      if (chosenTarget \u003d\u003d null \u0026\u0026 ctxt\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n             excludeNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         if (blockInfo.isStriped()) {\n           buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n-              chosenTarget.storageType, blockMovingInfos);\n+              chosenTarget.storageType, blockMovingInfos, ecPolicy);\n         } else {\n           buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos);\n         }\n \n         expected.remove(chosenTarget.storageType);\n         excludeNodes.add(chosenTarget.dn);\n         // TODO: We can increment scheduled block count for this node?\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expected, blockInfo, existingTypeNodePair.storageType);\n       }\n     }\n \n     if (expected.size() \u003e 0) {\n       foundMatchingTargetNodesForBlock \u003d false;\n     }\n \n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes,\n      ErasureCodingPolicy ecPolicy) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n\n      // Check whether the block replica is already placed in the expected\n      // storage type in this source datanode.\n      if (!expected.contains(existingTypeNodePair.storageType)) {\n        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n            existingTypeNodePair.dn, expected);\n        if (chosenTarget !\u003d null) {\n          if (blockInfo.isStriped()) {\n            buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos,\n                ecPolicy);\n          } else {\n            buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos);\n          }\n          expected.remove(chosenTarget.storageType);\n          // TODO: We can increment scheduled block count for this node?\n        }\n      }\n      // To avoid choosing this excludeNodes as targets later\n      excludeNodes.add(existingTypeNodePair.dn);\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 ctxt\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            excludeNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        if (blockInfo.isStriped()) {\n          buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos, ecPolicy);\n        } else {\n          buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos);\n        }\n\n        expected.remove(chosenTarget.storageType);\n        excludeNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expected.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    return foundMatchingTargetNodesForBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
          "extendedDetails": {
            "oldValue": "[blockMovingInfos-List\u003cBlockMovingInfo\u003e, blockInfo-BlockInfo, sourceWithStorageList-List\u003cStorageTypeNodePair\u003e, expected-List\u003cStorageType\u003e, locsForExpectedStorageTypes-StorageTypeNodeMap]",
            "newValue": "[blockMovingInfos-List\u003cBlockMovingInfo\u003e, blockInfo-LocatedBlock, sourceWithStorageList-List\u003cStorageTypeNodePair\u003e, expected-List\u003cStorageType\u003e, locsForExpectedStorageTypes-StorageTypeNodeMap, ecPolicy-ErasureCodingPolicy]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12982 : [SPS]: Reduce the locking and cleanup the Namesystem access. Contributed by Rakesh R.\n",
          "commitDate": "12/08/18 3:06 AM",
          "commitName": "05d4daf6ba3e5bd40f46e8003ee12fc7c613453d",
          "commitAuthor": "Surendra Singh Lilhore",
          "commitDateOld": "12/08/18 3:06 AM",
          "commitNameOld": "78420719eb1f138c6f10558befb7bc8ebcc28a54",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,96 @@\n   private boolean findSourceAndTargetToMove(\n-      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n+      List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n-      StorageTypeNodeMap locsForExpectedStorageTypes) {\n+      StorageTypeNodeMap locsForExpectedStorageTypes,\n+      ErasureCodingPolicy ecPolicy) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n-    List\u003cDatanodeDescriptor\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n+    List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n \n       // Check whether the block replica is already placed in the expected\n       // storage type in this source datanode.\n       if (!expected.contains(existingTypeNodePair.storageType)) {\n-        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n-            blockInfo, existingTypeNodePair.dn, expected);\n+        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n+            existingTypeNodePair.dn, expected);\n         if (chosenTarget !\u003d null) {\n           if (blockInfo.isStriped()) {\n             buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n-                chosenTarget.storageType, blockMovingInfos);\n+                chosenTarget.storageType, blockMovingInfos,\n+                ecPolicy);\n           } else {\n             buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                 existingTypeNodePair.storageType, chosenTarget.dn,\n                 chosenTarget.storageType, blockMovingInfos);\n           }\n           expected.remove(chosenTarget.storageType);\n           // TODO: We can increment scheduled block count for this node?\n         }\n       }\n       // To avoid choosing this excludeNodes as targets later\n       excludeNodes.add(existingTypeNodePair.dn);\n     }\n \n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n       if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n         continue;\n       }\n-      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n+      if (chosenTarget \u003d\u003d null \u0026\u0026 ctxt\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n             excludeNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         if (blockInfo.isStriped()) {\n           buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n-              chosenTarget.storageType, blockMovingInfos);\n+              chosenTarget.storageType, blockMovingInfos, ecPolicy);\n         } else {\n           buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n               existingTypeNodePair.storageType, chosenTarget.dn,\n               chosenTarget.storageType, blockMovingInfos);\n         }\n \n         expected.remove(chosenTarget.storageType);\n         excludeNodes.add(chosenTarget.dn);\n         // TODO: We can increment scheduled block count for this node?\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expected, blockInfo, existingTypeNodePair.storageType);\n       }\n     }\n \n     if (expected.size() \u003e 0) {\n       foundMatchingTargetNodesForBlock \u003d false;\n     }\n \n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, LocatedBlock blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes,\n      ErasureCodingPolicy ecPolicy) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n\n      // Check whether the block replica is already placed in the expected\n      // storage type in this source datanode.\n      if (!expected.contains(existingTypeNodePair.storageType)) {\n        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n            existingTypeNodePair.dn, expected);\n        if (chosenTarget !\u003d null) {\n          if (blockInfo.isStriped()) {\n            buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos,\n                ecPolicy);\n          } else {\n            buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos);\n          }\n          expected.remove(chosenTarget.storageType);\n          // TODO: We can increment scheduled block count for this node?\n        }\n      }\n      // To avoid choosing this excludeNodes as targets later\n      excludeNodes.add(existingTypeNodePair.dn);\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 ctxt\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            excludeNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        if (blockInfo.isStriped()) {\n          buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos, ecPolicy);\n        } else {\n          buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos);\n        }\n\n        expected.remove(chosenTarget.storageType);\n        excludeNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expected.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    return foundMatchingTargetNodesForBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
          "extendedDetails": {}
        }
      ]
    },
    "78420719eb1f138c6f10558befb7bc8ebcc28a54": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-12955: [SPS]: Move SPS classes to a separate package. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "78420719eb1f138c6f10558befb7bc8ebcc28a54",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "c561cb316e365ef674784cd6cf0b12c0fbc271a3",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeDescriptor\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n\n      // Check whether the block replica is already placed in the expected\n      // storage type in this source datanode.\n      if (!expected.contains(existingTypeNodePair.storageType)) {\n        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n            blockInfo, existingTypeNodePair.dn, expected);\n        if (chosenTarget !\u003d null) {\n          if (blockInfo.isStriped()) {\n            buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos);\n          } else {\n            buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos);\n          }\n          expected.remove(chosenTarget.storageType);\n          // TODO: We can increment scheduled block count for this node?\n        }\n      }\n      // To avoid choosing this excludeNodes as targets later\n      excludeNodes.add(existingTypeNodePair.dn);\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            excludeNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        if (blockInfo.isStriped()) {\n          buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos);\n        } else {\n          buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos);\n        }\n\n        expected.remove(chosenTarget.storageType);\n        excludeNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expected.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    return foundMatchingTargetNodesForBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/sps/StoragePolicySatisfier.java"
      }
    },
    "00eceed233d6e80d5c7137bf5b5286746ec4d5fb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12570: [SPS]: Refactor Co-ordinator datanode logic to track the block storage movements. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "00eceed233d6e80d5c7137bf5b5286746ec4d5fb",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "bfd3f8bd8a9ae2186ec3e4addc71f912ec7b8923",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,94 @@\n   private boolean findSourceAndTargetToMove(\n       List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n       StorageTypeNodeMap locsForExpectedStorageTypes) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n-    List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n-    List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n-    List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n-    List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeDescriptor\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n \n       // Check whether the block replica is already placed in the expected\n       // storage type in this source datanode.\n       if (!expected.contains(existingTypeNodePair.storageType)) {\n         StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n             blockInfo, existingTypeNodePair.dn, expected);\n         if (chosenTarget !\u003d null) {\n-          sourceNodes.add(existingTypeNodePair.dn);\n-          sourceStorageTypes.add(existingTypeNodePair.storageType);\n-          targetNodes.add(chosenTarget.dn);\n-          targetStorageTypes.add(chosenTarget.storageType);\n+          if (blockInfo.isStriped()) {\n+            buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n+                existingTypeNodePair.storageType, chosenTarget.dn,\n+                chosenTarget.storageType, blockMovingInfos);\n+          } else {\n+            buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n+                existingTypeNodePair.storageType, chosenTarget.dn,\n+                chosenTarget.storageType, blockMovingInfos);\n+          }\n           expected.remove(chosenTarget.storageType);\n           // TODO: We can increment scheduled block count for this node?\n         }\n       }\n       // To avoid choosing this excludeNodes as targets later\n       excludeNodes.add(existingTypeNodePair.dn);\n     }\n \n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n-      if (sourceNodes.contains(existingTypeNodePair.dn)) {\n+      if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n         continue;\n       }\n       if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n             excludeNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n       }\n       if (null !\u003d chosenTarget) {\n-        sourceNodes.add(existingTypeNodePair.dn);\n-        sourceStorageTypes.add(existingTypeNodePair.storageType);\n-        targetNodes.add(chosenTarget.dn);\n-        targetStorageTypes.add(chosenTarget.storageType);\n+        if (blockInfo.isStriped()) {\n+          buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n+              existingTypeNodePair.storageType, chosenTarget.dn,\n+              chosenTarget.storageType, blockMovingInfos);\n+        } else {\n+          buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n+              existingTypeNodePair.storageType, chosenTarget.dn,\n+              chosenTarget.storageType, blockMovingInfos);\n+        }\n+\n         expected.remove(chosenTarget.storageType);\n         excludeNodes.add(chosenTarget.dn);\n         // TODO: We can increment scheduled block count for this node?\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expected, blockInfo, existingTypeNodePair.storageType);\n       }\n     }\n \n     if (expected.size() \u003e 0) {\n       foundMatchingTargetNodesForBlock \u003d false;\n     }\n \n-    blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n-        sourceStorageTypes, targetNodes, targetStorageTypes));\n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeDescriptor\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n\n      // Check whether the block replica is already placed in the expected\n      // storage type in this source datanode.\n      if (!expected.contains(existingTypeNodePair.storageType)) {\n        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n            blockInfo, existingTypeNodePair.dn, expected);\n        if (chosenTarget !\u003d null) {\n          if (blockInfo.isStriped()) {\n            buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos);\n          } else {\n            buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n                existingTypeNodePair.storageType, chosenTarget.dn,\n                chosenTarget.storageType, blockMovingInfos);\n          }\n          expected.remove(chosenTarget.storageType);\n          // TODO: We can increment scheduled block count for this node?\n        }\n      }\n      // To avoid choosing this excludeNodes as targets later\n      excludeNodes.add(existingTypeNodePair.dn);\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (checkIfAlreadyChosen(blockMovingInfos, existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            excludeNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        if (blockInfo.isStriped()) {\n          buildStripedBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos);\n        } else {\n          buildContinuousBlockMovingInfos(blockInfo, existingTypeNodePair.dn,\n              existingTypeNodePair.storageType, chosenTarget.dn,\n              chosenTarget.storageType, blockMovingInfos);\n        }\n\n        expected.remove(chosenTarget.storageType);\n        excludeNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expected.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    return foundMatchingTargetNodesForBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
      "extendedDetails": {}
    },
    "20f9c623360d8ec534f8ddb0b993b4363a359e89": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11726. [SPS]: StoragePolicySatisfier should not select same storage type as source and destination in same datanode. Surendra Singh Lilhore.\n",
      "commitDate": "12/08/18 3:05 AM",
      "commitName": "20f9c623360d8ec534f8ddb0b993b4363a359e89",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "12/08/18 3:05 AM",
      "commitNameOld": "5ce332dc9a072f8850ab71ba16898faf8e866c06",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,89 @@\n   private boolean findSourceAndTargetToMove(\n       List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n       StorageTypeNodeMap locsForExpectedStorageTypes) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n     List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeDescriptor\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n-      StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n-          existingTypeNodePair.dn, expected);\n-      if (chosenTarget !\u003d null) {\n-        sourceNodes.add(existingTypeNodePair.dn);\n-        sourceStorageTypes.add(existingTypeNodePair.storageType);\n-        targetNodes.add(chosenTarget.dn);\n-        targetStorageTypes.add(chosenTarget.storageType);\n-        expected.remove(chosenTarget.storageType);\n-        // TODO: We can increment scheduled block count for this node?\n+\n+      // Check whether the block replica is already placed in the expected\n+      // storage type in this source datanode.\n+      if (!expected.contains(existingTypeNodePair.storageType)) {\n+        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n+            blockInfo, existingTypeNodePair.dn, expected);\n+        if (chosenTarget !\u003d null) {\n+          sourceNodes.add(existingTypeNodePair.dn);\n+          sourceStorageTypes.add(existingTypeNodePair.storageType);\n+          targetNodes.add(chosenTarget.dn);\n+          targetStorageTypes.add(chosenTarget.storageType);\n+          expected.remove(chosenTarget.storageType);\n+          // TODO: We can increment scheduled block count for this node?\n+        }\n       }\n       // To avoid choosing this excludeNodes as targets later\n       excludeNodes.add(existingTypeNodePair.dn);\n     }\n \n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n       if (sourceNodes.contains(existingTypeNodePair.dn)) {\n         continue;\n       }\n       if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n             excludeNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         sourceNodes.add(existingTypeNodePair.dn);\n         sourceStorageTypes.add(existingTypeNodePair.storageType);\n         targetNodes.add(chosenTarget.dn);\n         targetStorageTypes.add(chosenTarget.storageType);\n         expected.remove(chosenTarget.storageType);\n         excludeNodes.add(chosenTarget.dn);\n         // TODO: We can increment scheduled block count for this node?\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expected, blockInfo, existingTypeNodePair.storageType);\n       }\n     }\n \n     if (expected.size() \u003e 0) {\n       foundMatchingTargetNodesForBlock \u003d false;\n     }\n \n     blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n         sourceStorageTypes, targetNodes, targetStorageTypes));\n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeDescriptor\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n\n      // Check whether the block replica is already placed in the expected\n      // storage type in this source datanode.\n      if (!expected.contains(existingTypeNodePair.storageType)) {\n        StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n            blockInfo, existingTypeNodePair.dn, expected);\n        if (chosenTarget !\u003d null) {\n          sourceNodes.add(existingTypeNodePair.dn);\n          sourceStorageTypes.add(existingTypeNodePair.storageType);\n          targetNodes.add(chosenTarget.dn);\n          targetStorageTypes.add(chosenTarget.storageType);\n          expected.remove(chosenTarget.storageType);\n          // TODO: We can increment scheduled block count for this node?\n        }\n      }\n      // To avoid choosing this excludeNodes as targets later\n      excludeNodes.add(existingTypeNodePair.dn);\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (sourceNodes.contains(existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            excludeNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        expected.remove(chosenTarget.storageType);\n        excludeNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expected.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n        sourceStorageTypes, targetNodes, targetStorageTypes));\n    return foundMatchingTargetNodesForBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
      "extendedDetails": {}
    },
    "f8fc96a66ea3cbd41a3915c4546ff816451cf9db": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11309. [SPS]: chooseTargetTypeInSameNode should pass accurate block size to chooseStorage4Block while choosing target. Contributed by Uma Maheswara Rao G\n",
      "commitDate": "12/08/18 3:05 AM",
      "commitName": "f8fc96a66ea3cbd41a3915c4546ff816451cf9db",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "12/08/18 3:05 AM",
      "commitNameOld": "6215e35bb633706753a464ad3e8633366e6a10b2",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,84 @@\n   private boolean findSourceAndTargetToMove(\n       List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n       StorageTypeNodeMap locsForExpectedStorageTypes) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n     List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n-    List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n+    List\u003cDatanodeDescriptor\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n-      StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n+      StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n           existingTypeNodePair.dn, expected);\n       if (chosenTarget !\u003d null) {\n         sourceNodes.add(existingTypeNodePair.dn);\n         sourceStorageTypes.add(existingTypeNodePair.storageType);\n         targetNodes.add(chosenTarget.dn);\n         targetStorageTypes.add(chosenTarget.storageType);\n-        chosenNodes.add(chosenTarget.dn);\n         expected.remove(chosenTarget.storageType);\n         // TODO: We can increment scheduled block count for this node?\n       }\n+      // To avoid choosing this excludeNodes as targets later\n+      excludeNodes.add(existingTypeNodePair.dn);\n     }\n \n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n       if (sourceNodes.contains(existingTypeNodePair.dn)) {\n         continue;\n       }\n       if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n-            chosenNodes);\n+            excludeNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n-                Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n+                Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n-                Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n+                Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         sourceNodes.add(existingTypeNodePair.dn);\n         sourceStorageTypes.add(existingTypeNodePair.storageType);\n         targetNodes.add(chosenTarget.dn);\n         targetStorageTypes.add(chosenTarget.storageType);\n-        chosenNodes.add(chosenTarget.dn);\n         expected.remove(chosenTarget.storageType);\n+        excludeNodes.add(chosenTarget.dn);\n         // TODO: We can increment scheduled block count for this node?\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expected, blockInfo, existingTypeNodePair.storageType);\n       }\n     }\n \n     if (expected.size() \u003e 0) {\n       foundMatchingTargetNodesForBlock \u003d false;\n     }\n \n     blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n         sourceStorageTypes, targetNodes, targetStorageTypes));\n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeDescriptor\u003e excludeNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(blockInfo,\n          existingTypeNodePair.dn, expected);\n      if (chosenTarget !\u003d null) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        expected.remove(chosenTarget.storageType);\n        // TODO: We can increment scheduled block count for this node?\n      }\n      // To avoid choosing this excludeNodes as targets later\n      excludeNodes.add(existingTypeNodePair.dn);\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (sourceNodes.contains(existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            excludeNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, excludeNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, excludeNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        expected.remove(chosenTarget.storageType);\n        excludeNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expected.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n        sourceStorageTypes, targetNodes, targetStorageTypes));\n    return foundMatchingTargetNodesForBlock;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
      "extendedDetails": {}
    },
    "df2b551e79c9e5d8bdd981c48be52bae5f0d9a82": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-11293: [SPS]: Local DN should be given preference as source node, when target available in same node. Contributed by Yuanbo Liu and Uma Maheswara Rao G\n",
      "commitDate": "12/08/18 3:05 AM",
      "commitName": "df2b551e79c9e5d8bdd981c48be52bae5f0d9a82",
      "commitAuthor": "Uma Maheswara Rao G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-11293: [SPS]: Local DN should be given preference as source node, when target available in same node. Contributed by Yuanbo Liu and Uma Maheswara Rao G\n",
          "commitDate": "12/08/18 3:05 AM",
          "commitName": "df2b551e79c9e5d8bdd981c48be52bae5f0d9a82",
          "commitAuthor": "Uma Maheswara Rao G",
          "commitDateOld": "12/08/18 3:05 AM",
          "commitNameOld": "422f870607effd88b704c93783220bcedf9ddfb1",
          "commitAuthorOld": "Rakesh Radhakrishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,83 @@\n   private boolean findSourceAndTargetToMove(\n       List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n-      List\u003cStorageType\u003e existing,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n       StorageTypeNodeMap locsForExpectedStorageTypes) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n     List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n           existingTypeNodePair.dn, expected);\n       if (chosenTarget !\u003d null) {\n         sourceNodes.add(existingTypeNodePair.dn);\n         sourceStorageTypes.add(existingTypeNodePair.storageType);\n         targetNodes.add(chosenTarget.dn);\n         targetStorageTypes.add(chosenTarget.storageType);\n         chosenNodes.add(chosenTarget.dn);\n+        expected.remove(chosenTarget.storageType);\n         // TODO: We can increment scheduled block count for this node?\n       }\n     }\n \n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n       if (sourceNodes.contains(existingTypeNodePair.dn)) {\n         continue;\n       }\n       if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n             chosenNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         sourceNodes.add(existingTypeNodePair.dn);\n         sourceStorageTypes.add(existingTypeNodePair.storageType);\n         targetNodes.add(chosenTarget.dn);\n         targetStorageTypes.add(chosenTarget.storageType);\n         chosenNodes.add(chosenTarget.dn);\n+        expected.remove(chosenTarget.storageType);\n         // TODO: We can increment scheduled block count for this node?\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expected, blockInfo, existingTypeNodePair.storageType);\n-        foundMatchingTargetNodesForBlock \u003d false;\n       }\n     }\n \n+    if (expected.size() \u003e 0) {\n+      foundMatchingTargetNodesForBlock \u003d false;\n+    }\n+\n     blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n         sourceStorageTypes, targetNodes, targetStorageTypes));\n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n          existingTypeNodePair.dn, expected);\n      if (chosenTarget !\u003d null) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        chosenNodes.add(chosenTarget.dn);\n        expected.remove(chosenTarget.storageType);\n        // TODO: We can increment scheduled block count for this node?\n      }\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (sourceNodes.contains(existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            chosenNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        chosenNodes.add(chosenTarget.dn);\n        expected.remove(chosenTarget.storageType);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expected.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n        sourceStorageTypes, targetNodes, targetStorageTypes));\n    return foundMatchingTargetNodesForBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
          "extendedDetails": {
            "oldValue": "[blockMovingInfos-List\u003cBlockMovingInfo\u003e, blockInfo-BlockInfo, existing-List\u003cStorageType\u003e, sourceWithStorageList-List\u003cStorageTypeNodePair\u003e, expected-List\u003cStorageType\u003e, locsForExpectedStorageTypes-StorageTypeNodeMap]",
            "newValue": "[blockMovingInfos-List\u003cBlockMovingInfo\u003e, blockInfo-BlockInfo, sourceWithStorageList-List\u003cStorageTypeNodePair\u003e, expected-List\u003cStorageType\u003e, locsForExpectedStorageTypes-StorageTypeNodeMap]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-11293: [SPS]: Local DN should be given preference as source node, when target available in same node. Contributed by Yuanbo Liu and Uma Maheswara Rao G\n",
          "commitDate": "12/08/18 3:05 AM",
          "commitName": "df2b551e79c9e5d8bdd981c48be52bae5f0d9a82",
          "commitAuthor": "Uma Maheswara Rao G",
          "commitDateOld": "12/08/18 3:05 AM",
          "commitNameOld": "422f870607effd88b704c93783220bcedf9ddfb1",
          "commitAuthorOld": "Rakesh Radhakrishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,83 @@\n   private boolean findSourceAndTargetToMove(\n       List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n-      List\u003cStorageType\u003e existing,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n       StorageTypeNodeMap locsForExpectedStorageTypes) {\n     boolean foundMatchingTargetNodesForBlock \u003d true;\n     List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n \n     // Looping over all the source node locations and choose the target\n     // storage within same node if possible. This is done separately to\n     // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n           existingTypeNodePair.dn, expected);\n       if (chosenTarget !\u003d null) {\n         sourceNodes.add(existingTypeNodePair.dn);\n         sourceStorageTypes.add(existingTypeNodePair.storageType);\n         targetNodes.add(chosenTarget.dn);\n         targetStorageTypes.add(chosenTarget.storageType);\n         chosenNodes.add(chosenTarget.dn);\n+        expected.remove(chosenTarget.storageType);\n         // TODO: We can increment scheduled block count for this node?\n       }\n     }\n \n     // Looping over all the source node locations. Choose a remote target\n     // storage node if it was not found out within same node.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d null;\n       // Chosen the target storage within same datanode. So just skipping this\n       // source node.\n       if (sourceNodes.contains(existingTypeNodePair.dn)) {\n         continue;\n       }\n       if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n             chosenNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         sourceNodes.add(existingTypeNodePair.dn);\n         sourceStorageTypes.add(existingTypeNodePair.storageType);\n         targetNodes.add(chosenTarget.dn);\n         targetStorageTypes.add(chosenTarget.storageType);\n         chosenNodes.add(chosenTarget.dn);\n+        expected.remove(chosenTarget.storageType);\n         // TODO: We can increment scheduled block count for this node?\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expected, blockInfo, existingTypeNodePair.storageType);\n-        foundMatchingTargetNodesForBlock \u003d false;\n       }\n     }\n \n+    if (expected.size() \u003e 0) {\n+      foundMatchingTargetNodesForBlock \u003d false;\n+    }\n+\n     blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n         sourceStorageTypes, targetNodes, targetStorageTypes));\n     return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n          existingTypeNodePair.dn, expected);\n      if (chosenTarget !\u003d null) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        chosenNodes.add(chosenTarget.dn);\n        expected.remove(chosenTarget.storageType);\n        // TODO: We can increment scheduled block count for this node?\n      }\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (sourceNodes.contains(existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            chosenNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        chosenNodes.add(chosenTarget.dn);\n        expected.remove(chosenTarget.storageType);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n      }\n    }\n\n    if (expected.size() \u003e 0) {\n      foundMatchingTargetNodesForBlock \u003d false;\n    }\n\n    blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n        sourceStorageTypes, targetNodes, targetStorageTypes));\n    return foundMatchingTargetNodesForBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
          "extendedDetails": {}
        }
      ]
    },
    "b7bed9f00a25bcad6f9c3543f5a1fb0a1f23b0e9": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-11248: [SPS]: Handle partial block location movements. Contributed by Rakesh R\n",
      "commitDate": "12/08/18 3:05 AM",
      "commitName": "b7bed9f00a25bcad6f9c3543f5a1fb0a1f23b0e9",
      "commitAuthor": "Uma Maheswara Rao G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-11248: [SPS]: Handle partial block location movements. Contributed by Rakesh R\n",
          "commitDate": "12/08/18 3:05 AM",
          "commitName": "b7bed9f00a25bcad6f9c3543f5a1fb0a1f23b0e9",
          "commitAuthor": "Uma Maheswara Rao G",
          "commitDateOld": "12/08/18 3:05 AM",
          "commitNameOld": "5179d99b7e1faeac1ce041967480115913d9f795",
          "commitAuthorOld": "Rakesh Radhakrishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,79 @@\n-  private BlockMovingInfo findSourceAndTargetToMove(BlockInfo blockInfo,\n+  private boolean findSourceAndTargetToMove(\n+      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n       List\u003cStorageType\u003e existing,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n       StorageTypeNodeMap locsForExpectedStorageTypes) {\n+    boolean foundMatchingTargetNodesForBlock \u003d true;\n     List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n+\n+    // Looping over all the source node locations and choose the target\n+    // storage within same node if possible. This is done separately to\n+    // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n           existingTypeNodePair.dn, expected);\n+      if (chosenTarget !\u003d null) {\n+        sourceNodes.add(existingTypeNodePair.dn);\n+        sourceStorageTypes.add(existingTypeNodePair.storageType);\n+        targetNodes.add(chosenTarget.dn);\n+        targetStorageTypes.add(chosenTarget.storageType);\n+        chosenNodes.add(chosenTarget.dn);\n+        // TODO: We can increment scheduled block count for this node?\n+      }\n+    }\n \n+    // Looping over all the source node locations. Choose a remote target\n+    // storage node if it was not found out within same node.\n+    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n+      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n+      StorageTypeNodePair chosenTarget \u003d null;\n+      // Chosen the target storage within same datanode. So just skipping this\n+      // source node.\n+      if (sourceNodes.contains(existingTypeNodePair.dn)) {\n+        continue;\n+      }\n       if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n             chosenNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         sourceNodes.add(existingTypeNodePair.dn);\n         sourceStorageTypes.add(existingTypeNodePair.storageType);\n         targetNodes.add(chosenTarget.dn);\n         targetStorageTypes.add(chosenTarget.storageType);\n         chosenNodes.add(chosenTarget.dn);\n         // TODO: We can increment scheduled block count for this node?\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expected, blockInfo, existingTypeNodePair.storageType);\n-        sourceNodes.add(existingTypeNodePair.dn);\n-        sourceStorageTypes.add(existingTypeNodePair.storageType);\n-        // Imp: Not setting the target details, empty targets. Later, this is\n-        // used as an indicator for retrying this block movement.\n+        foundMatchingTargetNodesForBlock \u003d false;\n       }\n     }\n-    BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blockInfo,\n-        sourceNodes.toArray(new DatanodeInfo[sourceNodes.size()]),\n-        targetNodes.toArray(new DatanodeInfo[targetNodes.size()]),\n-        sourceStorageTypes.toArray(new StorageType[sourceStorageTypes.size()]),\n-        targetStorageTypes.toArray(new StorageType[targetStorageTypes.size()]));\n-    return blkMovingInfo;\n+\n+    blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n+        sourceStorageTypes, targetNodes, targetStorageTypes));\n+    return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n      List\u003cStorageType\u003e existing,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n          existingTypeNodePair.dn, expected);\n      if (chosenTarget !\u003d null) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        chosenNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      }\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (sourceNodes.contains(existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            chosenNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        chosenNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n        foundMatchingTargetNodesForBlock \u003d false;\n      }\n    }\n\n    blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n        sourceStorageTypes, targetNodes, targetStorageTypes));\n    return foundMatchingTargetNodesForBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
          "extendedDetails": {
            "oldValue": "[blockInfo-BlockInfo, existing-List\u003cStorageType\u003e, sourceWithStorageList-List\u003cStorageTypeNodePair\u003e, expected-List\u003cStorageType\u003e, locsForExpectedStorageTypes-StorageTypeNodeMap]",
            "newValue": "[blockMovingInfos-List\u003cBlockMovingInfo\u003e, blockInfo-BlockInfo, existing-List\u003cStorageType\u003e, sourceWithStorageList-List\u003cStorageTypeNodePair\u003e, expected-List\u003cStorageType\u003e, locsForExpectedStorageTypes-StorageTypeNodeMap]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-11248: [SPS]: Handle partial block location movements. Contributed by Rakesh R\n",
          "commitDate": "12/08/18 3:05 AM",
          "commitName": "b7bed9f00a25bcad6f9c3543f5a1fb0a1f23b0e9",
          "commitAuthor": "Uma Maheswara Rao G",
          "commitDateOld": "12/08/18 3:05 AM",
          "commitNameOld": "5179d99b7e1faeac1ce041967480115913d9f795",
          "commitAuthorOld": "Rakesh Radhakrishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,79 @@\n-  private BlockMovingInfo findSourceAndTargetToMove(BlockInfo blockInfo,\n+  private boolean findSourceAndTargetToMove(\n+      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n       List\u003cStorageType\u003e existing,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n       StorageTypeNodeMap locsForExpectedStorageTypes) {\n+    boolean foundMatchingTargetNodesForBlock \u003d true;\n     List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n+\n+    // Looping over all the source node locations and choose the target\n+    // storage within same node if possible. This is done separately to\n+    // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n           existingTypeNodePair.dn, expected);\n+      if (chosenTarget !\u003d null) {\n+        sourceNodes.add(existingTypeNodePair.dn);\n+        sourceStorageTypes.add(existingTypeNodePair.storageType);\n+        targetNodes.add(chosenTarget.dn);\n+        targetStorageTypes.add(chosenTarget.storageType);\n+        chosenNodes.add(chosenTarget.dn);\n+        // TODO: We can increment scheduled block count for this node?\n+      }\n+    }\n \n+    // Looping over all the source node locations. Choose a remote target\n+    // storage node if it was not found out within same node.\n+    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n+      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n+      StorageTypeNodePair chosenTarget \u003d null;\n+      // Chosen the target storage within same datanode. So just skipping this\n+      // source node.\n+      if (sourceNodes.contains(existingTypeNodePair.dn)) {\n+        continue;\n+      }\n       if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n             chosenNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         sourceNodes.add(existingTypeNodePair.dn);\n         sourceStorageTypes.add(existingTypeNodePair.storageType);\n         targetNodes.add(chosenTarget.dn);\n         targetStorageTypes.add(chosenTarget.storageType);\n         chosenNodes.add(chosenTarget.dn);\n         // TODO: We can increment scheduled block count for this node?\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expected, blockInfo, existingTypeNodePair.storageType);\n-        sourceNodes.add(existingTypeNodePair.dn);\n-        sourceStorageTypes.add(existingTypeNodePair.storageType);\n-        // Imp: Not setting the target details, empty targets. Later, this is\n-        // used as an indicator for retrying this block movement.\n+        foundMatchingTargetNodesForBlock \u003d false;\n       }\n     }\n-    BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blockInfo,\n-        sourceNodes.toArray(new DatanodeInfo[sourceNodes.size()]),\n-        targetNodes.toArray(new DatanodeInfo[targetNodes.size()]),\n-        sourceStorageTypes.toArray(new StorageType[sourceStorageTypes.size()]),\n-        targetStorageTypes.toArray(new StorageType[targetStorageTypes.size()]));\n-    return blkMovingInfo;\n+\n+    blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n+        sourceStorageTypes, targetNodes, targetStorageTypes));\n+    return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n      List\u003cStorageType\u003e existing,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n          existingTypeNodePair.dn, expected);\n      if (chosenTarget !\u003d null) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        chosenNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      }\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (sourceNodes.contains(existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            chosenNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        chosenNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n        foundMatchingTargetNodesForBlock \u003d false;\n      }\n    }\n\n    blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n        sourceStorageTypes, targetNodes, targetStorageTypes));\n    return foundMatchingTargetNodesForBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
          "extendedDetails": {
            "oldValue": "BlockMovingInfo",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-11248: [SPS]: Handle partial block location movements. Contributed by Rakesh R\n",
          "commitDate": "12/08/18 3:05 AM",
          "commitName": "b7bed9f00a25bcad6f9c3543f5a1fb0a1f23b0e9",
          "commitAuthor": "Uma Maheswara Rao G",
          "commitDateOld": "12/08/18 3:05 AM",
          "commitNameOld": "5179d99b7e1faeac1ce041967480115913d9f795",
          "commitAuthorOld": "Rakesh Radhakrishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,79 @@\n-  private BlockMovingInfo findSourceAndTargetToMove(BlockInfo blockInfo,\n+  private boolean findSourceAndTargetToMove(\n+      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n       List\u003cStorageType\u003e existing,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n       StorageTypeNodeMap locsForExpectedStorageTypes) {\n+    boolean foundMatchingTargetNodesForBlock \u003d true;\n     List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n+\n+    // Looping over all the source node locations and choose the target\n+    // storage within same node if possible. This is done separately to\n+    // avoid choosing a target which already has this block.\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n       StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n           existingTypeNodePair.dn, expected);\n+      if (chosenTarget !\u003d null) {\n+        sourceNodes.add(existingTypeNodePair.dn);\n+        sourceStorageTypes.add(existingTypeNodePair.storageType);\n+        targetNodes.add(chosenTarget.dn);\n+        targetStorageTypes.add(chosenTarget.storageType);\n+        chosenNodes.add(chosenTarget.dn);\n+        // TODO: We can increment scheduled block count for this node?\n+      }\n+    }\n \n+    // Looping over all the source node locations. Choose a remote target\n+    // storage node if it was not found out within same node.\n+    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n+      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n+      StorageTypeNodePair chosenTarget \u003d null;\n+      // Chosen the target storage within same datanode. So just skipping this\n+      // source node.\n+      if (sourceNodes.contains(existingTypeNodePair.dn)) {\n+        continue;\n+      }\n       if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n             chosenNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         sourceNodes.add(existingTypeNodePair.dn);\n         sourceStorageTypes.add(existingTypeNodePair.storageType);\n         targetNodes.add(chosenTarget.dn);\n         targetStorageTypes.add(chosenTarget.storageType);\n         chosenNodes.add(chosenTarget.dn);\n         // TODO: We can increment scheduled block count for this node?\n       } else {\n         LOG.warn(\n             \"Failed to choose target datanode for the required\"\n                 + \" storage types {}, block:{}, existing storage type:{}\",\n             expected, blockInfo, existingTypeNodePair.storageType);\n-        sourceNodes.add(existingTypeNodePair.dn);\n-        sourceStorageTypes.add(existingTypeNodePair.storageType);\n-        // Imp: Not setting the target details, empty targets. Later, this is\n-        // used as an indicator for retrying this block movement.\n+        foundMatchingTargetNodesForBlock \u003d false;\n       }\n     }\n-    BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blockInfo,\n-        sourceNodes.toArray(new DatanodeInfo[sourceNodes.size()]),\n-        targetNodes.toArray(new DatanodeInfo[targetNodes.size()]),\n-        sourceStorageTypes.toArray(new StorageType[sourceStorageTypes.size()]),\n-        targetStorageTypes.toArray(new StorageType[targetStorageTypes.size()]));\n-    return blkMovingInfo;\n+\n+    blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n+        sourceStorageTypes, targetNodes, targetStorageTypes));\n+    return foundMatchingTargetNodesForBlock;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean findSourceAndTargetToMove(\n      List\u003cBlockMovingInfo\u003e blockMovingInfos, BlockInfo blockInfo,\n      List\u003cStorageType\u003e existing,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes) {\n    boolean foundMatchingTargetNodesForBlock \u003d true;\n    List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n\n    // Looping over all the source node locations and choose the target\n    // storage within same node if possible. This is done separately to\n    // avoid choosing a target which already has this block.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n          existingTypeNodePair.dn, expected);\n      if (chosenTarget !\u003d null) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        chosenNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      }\n    }\n\n    // Looping over all the source node locations. Choose a remote target\n    // storage node if it was not found out within same node.\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d null;\n      // Chosen the target storage within same datanode. So just skipping this\n      // source node.\n      if (sourceNodes.contains(existingTypeNodePair.dn)) {\n        continue;\n      }\n      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            chosenNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        chosenNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n        foundMatchingTargetNodesForBlock \u003d false;\n      }\n    }\n\n    blockMovingInfos.addAll(getBlockMovingInfos(blockInfo, sourceNodes,\n        sourceStorageTypes, targetNodes, targetStorageTypes));\n    return foundMatchingTargetNodesForBlock;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
          "extendedDetails": {}
        }
      ]
    },
    "b07291e176c489c2eec3da1850b790b8ba691a3e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11151. [SPS]: StoragePolicySatisfier should gracefully handle when there is no target node with the required storage type. Contributed by Rakesh R\n",
      "commitDate": "12/08/18 3:05 AM",
      "commitName": "b07291e176c489c2eec3da1850b790b8ba691a3e",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "12/08/18 3:05 AM",
      "commitNameOld": "19b5aee3e42cd1d6c77a58ab2eea185b5afd60b2",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,59 @@\n   private BlockMovingInfo findSourceAndTargetToMove(BlockInfo blockInfo,\n       List\u003cStorageType\u003e existing,\n       List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n       List\u003cStorageType\u003e expected,\n       StorageTypeNodeMap locsForExpectedStorageTypes) {\n     List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n     List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n     List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n     for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n       StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n-      StorageTypeNodePair chosenTarget \u003d\n-          chooseTargetTypeInSameNode(existingTypeNodePair.dn, expected,\n-              locsForExpectedStorageTypes, chosenNodes);\n+      StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n+          existingTypeNodePair.dn, expected);\n \n       if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n           .getNetworkTopology().isNodeGroupAware()) {\n         chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n             expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n             chosenNodes);\n       }\n \n       // Then, match nodes on the same rack\n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n       }\n \n       if (chosenTarget \u003d\u003d null) {\n         chosenTarget \u003d\n             chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                 Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n       }\n       if (null !\u003d chosenTarget) {\n         sourceNodes.add(existingTypeNodePair.dn);\n         sourceStorageTypes.add(existingTypeNodePair.storageType);\n         targetNodes.add(chosenTarget.dn);\n         targetStorageTypes.add(chosenTarget.storageType);\n         chosenNodes.add(chosenTarget.dn);\n         // TODO: We can increment scheduled block count for this node?\n       } else {\n-        // TODO: Failed to ChooseTargetNodes...So let just retry. Shall we\n-        // proceed without this targets? Then what should be final result?\n-        // How about pack empty target, means target node could not be chosen ,\n-        // so result should be RETRY_REQUIRED from DN always.\n-        // Log..unable to choose target node for source datanodeDescriptor\n+        LOG.warn(\n+            \"Failed to choose target datanode for the required\"\n+                + \" storage types {}, block:{}, existing storage type:{}\",\n+            expected, blockInfo, existingTypeNodePair.storageType);\n         sourceNodes.add(existingTypeNodePair.dn);\n         sourceStorageTypes.add(existingTypeNodePair.storageType);\n-        targetNodes.add(null);\n-        targetStorageTypes.add(null);\n+        // Imp: Not setting the target details, empty targets. Later, this is\n+        // used as an indicator for retrying this block movement.\n       }\n     }\n     BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blockInfo,\n         sourceNodes.toArray(new DatanodeInfo[sourceNodes.size()]),\n         targetNodes.toArray(new DatanodeInfo[targetNodes.size()]),\n         sourceStorageTypes.toArray(new StorageType[sourceStorageTypes.size()]),\n         targetStorageTypes.toArray(new StorageType[targetStorageTypes.size()]));\n     return blkMovingInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockMovingInfo findSourceAndTargetToMove(BlockInfo blockInfo,\n      List\u003cStorageType\u003e existing,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes) {\n    List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d chooseTargetTypeInSameNode(\n          existingTypeNodePair.dn, expected);\n\n      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            chosenNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        chosenNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        LOG.warn(\n            \"Failed to choose target datanode for the required\"\n                + \" storage types {}, block:{}, existing storage type:{}\",\n            expected, blockInfo, existingTypeNodePair.storageType);\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        // Imp: Not setting the target details, empty targets. Later, this is\n        // used as an indicator for retrying this block movement.\n      }\n    }\n    BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blockInfo,\n        sourceNodes.toArray(new DatanodeInfo[sourceNodes.size()]),\n        targetNodes.toArray(new DatanodeInfo[targetNodes.size()]),\n        sourceStorageTypes.toArray(new StorageType[sourceStorageTypes.size()]),\n        targetStorageTypes.toArray(new StorageType[targetStorageTypes.size()]));\n    return blkMovingInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java",
      "extendedDetails": {}
    },
    "1438da494424193e330f24edef823bbd60dc37d2": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10800: [SPS]: Daemon thread in Namenode to find blocks placed in other storage than what the policy specifies. Contributed by Uma Maheswara Rao G\n",
      "commitDate": "12/08/18 3:05 AM",
      "commitName": "1438da494424193e330f24edef823bbd60dc37d2",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,61 @@\n+  private BlockMovingInfo findSourceAndTargetToMove(BlockInfo blockInfo,\n+      List\u003cStorageType\u003e existing,\n+      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n+      List\u003cStorageType\u003e expected,\n+      StorageTypeNodeMap locsForExpectedStorageTypes) {\n+    List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n+    List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n+    List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n+    List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n+    List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n+    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n+      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n+      StorageTypeNodePair chosenTarget \u003d\n+          chooseTargetTypeInSameNode(existingTypeNodePair.dn, expected,\n+              locsForExpectedStorageTypes, chosenNodes);\n+\n+      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n+          .getNetworkTopology().isNodeGroupAware()) {\n+        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n+            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n+            chosenNodes);\n+      }\n+\n+      // Then, match nodes on the same rack\n+      if (chosenTarget \u003d\u003d null) {\n+        chosenTarget \u003d\n+            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n+                Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n+      }\n+\n+      if (chosenTarget \u003d\u003d null) {\n+        chosenTarget \u003d\n+            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n+                Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n+      }\n+      if (null !\u003d chosenTarget) {\n+        sourceNodes.add(existingTypeNodePair.dn);\n+        sourceStorageTypes.add(existingTypeNodePair.storageType);\n+        targetNodes.add(chosenTarget.dn);\n+        targetStorageTypes.add(chosenTarget.storageType);\n+        chosenNodes.add(chosenTarget.dn);\n+        // TODO: We can increment scheduled block count for this node?\n+      } else {\n+        // TODO: Failed to ChooseTargetNodes...So let just retry. Shall we\n+        // proceed without this targets? Then what should be final result?\n+        // How about pack empty target, means target node could not be chosen ,\n+        // so result should be RETRY_REQUIRED from DN always.\n+        // Log..unable to choose target node for source datanodeDescriptor\n+        sourceNodes.add(existingTypeNodePair.dn);\n+        sourceStorageTypes.add(existingTypeNodePair.storageType);\n+        targetNodes.add(null);\n+        targetStorageTypes.add(null);\n+      }\n+    }\n+    BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blockInfo,\n+        sourceNodes.toArray(new DatanodeInfo[sourceNodes.size()]),\n+        targetNodes.toArray(new DatanodeInfo[targetNodes.size()]),\n+        sourceStorageTypes.toArray(new StorageType[sourceStorageTypes.size()]),\n+        targetStorageTypes.toArray(new StorageType[targetStorageTypes.size()]));\n+    return blkMovingInfo;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private BlockMovingInfo findSourceAndTargetToMove(BlockInfo blockInfo,\n      List\u003cStorageType\u003e existing,\n      List\u003cStorageTypeNodePair\u003e sourceWithStorageList,\n      List\u003cStorageType\u003e expected,\n      StorageTypeNodeMap locsForExpectedStorageTypes) {\n    List\u003cDatanodeInfo\u003e sourceNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e sourceStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeInfo\u003e targetNodes \u003d new ArrayList\u003c\u003e();\n    List\u003cStorageType\u003e targetStorageTypes \u003d new ArrayList\u003c\u003e();\n    List\u003cDatanodeDescriptor\u003e chosenNodes \u003d new ArrayList\u003c\u003e();\n    for (int i \u003d 0; i \u003c sourceWithStorageList.size(); i++) {\n      StorageTypeNodePair existingTypeNodePair \u003d sourceWithStorageList.get(i);\n      StorageTypeNodePair chosenTarget \u003d\n          chooseTargetTypeInSameNode(existingTypeNodePair.dn, expected,\n              locsForExpectedStorageTypes, chosenNodes);\n\n      if (chosenTarget \u003d\u003d null \u0026\u0026 blockManager.getDatanodeManager()\n          .getNetworkTopology().isNodeGroupAware()) {\n        chosenTarget \u003d chooseTarget(blockInfo, existingTypeNodePair.dn,\n            expected, Matcher.SAME_NODE_GROUP, locsForExpectedStorageTypes,\n            chosenNodes);\n      }\n\n      // Then, match nodes on the same rack\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.SAME_RACK, locsForExpectedStorageTypes, chosenNodes);\n      }\n\n      if (chosenTarget \u003d\u003d null) {\n        chosenTarget \u003d\n            chooseTarget(blockInfo, existingTypeNodePair.dn, expected,\n                Matcher.ANY_OTHER, locsForExpectedStorageTypes, chosenNodes);\n      }\n      if (null !\u003d chosenTarget) {\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(chosenTarget.dn);\n        targetStorageTypes.add(chosenTarget.storageType);\n        chosenNodes.add(chosenTarget.dn);\n        // TODO: We can increment scheduled block count for this node?\n      } else {\n        // TODO: Failed to ChooseTargetNodes...So let just retry. Shall we\n        // proceed without this targets? Then what should be final result?\n        // How about pack empty target, means target node could not be chosen ,\n        // so result should be RETRY_REQUIRED from DN always.\n        // Log..unable to choose target node for source datanodeDescriptor\n        sourceNodes.add(existingTypeNodePair.dn);\n        sourceStorageTypes.add(existingTypeNodePair.storageType);\n        targetNodes.add(null);\n        targetStorageTypes.add(null);\n      }\n    }\n    BlockMovingInfo blkMovingInfo \u003d new BlockMovingInfo(blockInfo,\n        sourceNodes.toArray(new DatanodeInfo[sourceNodes.size()]),\n        targetNodes.toArray(new DatanodeInfo[targetNodes.size()]),\n        sourceStorageTypes.toArray(new StorageType[sourceStorageTypes.size()]),\n        targetStorageTypes.toArray(new StorageType[targetStorageTypes.size()]));\n    return blkMovingInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/StoragePolicySatisfier.java"
    }
  }
}