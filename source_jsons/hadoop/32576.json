{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NMWebServices.java",
  "functionName": "write",
  "functionId": "write___os-OutputStream",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
  "functionStartLine": 475,
  "functionEndLine": 523,
  "numCommitsSeen": 32,
  "timeTaken": 4061,
  "changeHistory": [
    "91cc070d67533ebb3325b982eba2135e0d175a82",
    "ad45d19998c1b0da25754d0016854046731fa623",
    "ce2d5bfa5f84e7e563980796549b56ef1e4bbf1e",
    "327c9980aafce52cc02d2b8885fc4e9f628ab23c",
    "c35fa4a0e57b99415e284c7c2f3b1a0bebc610c2",
    "58be55b6e07b94aa55ed87c461f3e5c04cc61630",
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
    "a759abcd898224c3481c55aa7e424bc286f60b15"
  ],
  "changeHistoryShort": {
    "91cc070d67533ebb3325b982eba2135e0d175a82": "Ybodychange",
    "ad45d19998c1b0da25754d0016854046731fa623": "Ybodychange",
    "ce2d5bfa5f84e7e563980796549b56ef1e4bbf1e": "Ybodychange",
    "327c9980aafce52cc02d2b8885fc4e9f628ab23c": "Ybodychange",
    "c35fa4a0e57b99415e284c7c2f3b1a0bebc610c2": "Ybodychange",
    "58be55b6e07b94aa55ed87c461f3e5c04cc61630": "Ybodychange",
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf": "Ybodychange",
    "a759abcd898224c3481c55aa7e424bc286f60b15": "Yintroduced"
  },
  "changeHistoryDetails": {
    "91cc070d67533ebb3325b982eba2135e0d175a82": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6877. Create an abstract log reader for extendability. Contributed by Xuan Gong.\n",
      "commitDate": "31/08/17 4:41 PM",
      "commitName": "91cc070d67533ebb3325b982eba2135e0d175a82",
      "commitAuthor": "Junping Du",
      "commitDateOld": "29/08/17 3:16 PM",
      "commitNameOld": "ad45d19998c1b0da25754d0016854046731fa623",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 2.06,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,49 @@\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             LogToolUtils.outputContainerLogThroughZeroCopy(\n                 containerId.toString(), nmContext.getNodeId().toString(),\n                 outputFileName, fileLength, bytes, lastModifiedTime, fis, os,\n                 ContainerLogAggregationType.LOCAL);\n             StringBuilder sb \u003d new StringBuilder();\n             String endOfFile \u003d \"End of LogType:\" + outputFileName;\n             sb.append(endOfFile + \".\");\n             if (isRunning) {\n               sb.append(\"This log file belongs to a running container (\"\n                   + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n             } else {\n               sb.append(\"\\n\");\n             }\n             sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                 + \"\\n\\n\");\n             os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n             // If we have aggregated logs for this container,\n             // output the aggregation logs as well.\n             ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                 .getApplicationId();\n             Application app \u003d nmContext.getApplications().get(appId);\n             String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n             try {\n-              int bufferSize \u003d 65536;\n-              byte[] buf \u003d new byte[bufferSize];\n-              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n-                  appId, appOwner, containerId.toString(),\n-                  nmContext.getNodeId().toString(), outputFileName, bytes,\n-                  os, buf);\n+              ContainerLogsRequest logRequest \u003d new ContainerLogsRequest();\n+              logRequest.setAppId(appId);\n+              logRequest.setAppOwner(appOwner);\n+              logRequest.setContainerId(containerId.toString());\n+              logRequest.setNodeId(nmContext.getNodeId().toString());\n+              logRequest.setBytes(bytes);\n+              Set\u003cString\u003e logTypes \u003d new HashSet\u003c\u003e();\n+              logTypes.add(outputFileName);\n+              logRequest.setLogTypes(logTypes);\n+              factory.getFileControllerForRead(appId, appOwner)\n+                  .readAggregatedLogs(logRequest, os);\n             } catch (Exception ex) {\n               // Something wrong when we try to access the aggregated log.\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Can not access the aggregated log for \"\n                     + \"the container:\" + containerId);\n                 LOG.debug(ex.getMessage());\n               }\n             }\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            LogToolUtils.outputContainerLogThroughZeroCopy(\n                containerId.toString(), nmContext.getNodeId().toString(),\n                outputFileName, fileLength, bytes, lastModifiedTime, fis, os,\n                ContainerLogAggregationType.LOCAL);\n            StringBuilder sb \u003d new StringBuilder();\n            String endOfFile \u003d \"End of LogType:\" + outputFileName;\n            sb.append(endOfFile + \".\");\n            if (isRunning) {\n              sb.append(\"This log file belongs to a running container (\"\n                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n            } else {\n              sb.append(\"\\n\");\n            }\n            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                + \"\\n\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n            // If we have aggregated logs for this container,\n            // output the aggregation logs as well.\n            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                .getApplicationId();\n            Application app \u003d nmContext.getApplications().get(appId);\n            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n            try {\n              ContainerLogsRequest logRequest \u003d new ContainerLogsRequest();\n              logRequest.setAppId(appId);\n              logRequest.setAppOwner(appOwner);\n              logRequest.setContainerId(containerId.toString());\n              logRequest.setNodeId(nmContext.getNodeId().toString());\n              logRequest.setBytes(bytes);\n              Set\u003cString\u003e logTypes \u003d new HashSet\u003c\u003e();\n              logTypes.add(outputFileName);\n              logRequest.setLogTypes(logTypes);\n              factory.getFileControllerForRead(appId, appOwner)\n                  .readAggregatedLogs(logRequest, os);\n            } catch (Exception ex) {\n              // Something wrong when we try to access the aggregated log.\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Can not access the aggregated log for \"\n                    + \"the container:\" + containerId);\n                LOG.debug(ex.getMessage());\n              }\n            }\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "ad45d19998c1b0da25754d0016854046731fa623": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7037. Optimize data transfer with zero-copy approach for containerlogs REST API in NMWebServices. Contributed by Tao Yang.\n",
      "commitDate": "29/08/17 3:16 PM",
      "commitName": "ad45d19998c1b0da25754d0016854046731fa623",
      "commitAuthor": "Junping Du",
      "commitDateOld": "22/08/17 1:14 AM",
      "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 7.58,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n-            int bufferSize \u003d 65536;\n-            byte[] buf \u003d new byte[bufferSize];\n-            LogToolUtils.outputContainerLog(containerId.toString(),\n-                nmContext.getNodeId().toString(), outputFileName, fileLength,\n-                bytes, lastModifiedTime, fis, os, buf,\n+            LogToolUtils.outputContainerLogThroughZeroCopy(\n+                containerId.toString(), nmContext.getNodeId().toString(),\n+                outputFileName, fileLength, bytes, lastModifiedTime, fis, os,\n                 ContainerLogAggregationType.LOCAL);\n             StringBuilder sb \u003d new StringBuilder();\n             String endOfFile \u003d \"End of LogType:\" + outputFileName;\n             sb.append(endOfFile + \".\");\n             if (isRunning) {\n               sb.append(\"This log file belongs to a running container (\"\n                   + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n             } else {\n               sb.append(\"\\n\");\n             }\n             sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                 + \"\\n\\n\");\n             os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n             // If we have aggregated logs for this container,\n             // output the aggregation logs as well.\n             ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                 .getApplicationId();\n             Application app \u003d nmContext.getApplications().get(appId);\n             String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n             try {\n+              int bufferSize \u003d 65536;\n+              byte[] buf \u003d new byte[bufferSize];\n               LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                   appId, appOwner, containerId.toString(),\n                   nmContext.getNodeId().toString(), outputFileName, bytes,\n                   os, buf);\n             } catch (Exception ex) {\n               // Something wrong when we try to access the aggregated log.\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Can not access the aggregated log for \"\n                     + \"the container:\" + containerId);\n                 LOG.debug(ex.getMessage());\n               }\n             }\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            LogToolUtils.outputContainerLogThroughZeroCopy(\n                containerId.toString(), nmContext.getNodeId().toString(),\n                outputFileName, fileLength, bytes, lastModifiedTime, fis, os,\n                ContainerLogAggregationType.LOCAL);\n            StringBuilder sb \u003d new StringBuilder();\n            String endOfFile \u003d \"End of LogType:\" + outputFileName;\n            sb.append(endOfFile + \".\");\n            if (isRunning) {\n              sb.append(\"This log file belongs to a running container (\"\n                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n            } else {\n              sb.append(\"\\n\");\n            }\n            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                + \"\\n\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n            // If we have aggregated logs for this container,\n            // output the aggregation logs as well.\n            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                .getApplicationId();\n            Application app \u003d nmContext.getApplications().get(appId);\n            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n            try {\n              int bufferSize \u003d 65536;\n              byte[] buf \u003d new byte[bufferSize];\n              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                  appId, appOwner, containerId.toString(),\n                  nmContext.getNodeId().toString(), outputFileName, bytes,\n                  os, buf);\n            } catch (Exception ex) {\n              // Something wrong when we try to access the aggregated log.\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Can not access the aggregated log for \"\n                    + \"the container:\" + containerId);\n                LOG.debug(ex.getMessage());\n              }\n            }\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "ce2d5bfa5f84e7e563980796549b56ef1e4bbf1e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6174. Log files pattern should be same for both running and finished container. Contributed by Xuan Gong.\n",
      "commitDate": "15/02/17 9:05 AM",
      "commitName": "ce2d5bfa5f84e7e563980796549b56ef1e4bbf1e",
      "commitAuthor": "Junping Du",
      "commitDateOld": "13/02/17 6:12 AM",
      "commitNameOld": "464ff479ceec76609dca3539081de6b503b17325",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 2.12,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,44 @@\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n             LogToolUtils.outputContainerLog(containerId.toString(),\n                 nmContext.getNodeId().toString(), outputFileName, fileLength,\n-                bytes, lastModifiedTime, fis, os, buf, ContainerLogType.LOCAL);\n+                bytes, lastModifiedTime, fis, os, buf,\n+                ContainerLogAggregationType.LOCAL);\n             StringBuilder sb \u003d new StringBuilder();\n-            String endOfFile \u003d \"End of LogFile:\" + outputFileName;\n+            String endOfFile \u003d \"End of LogType:\" + outputFileName;\n             sb.append(endOfFile + \".\");\n             if (isRunning) {\n               sb.append(\"This log file belongs to a running container (\"\n                   + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n             } else {\n               sb.append(\"\\n\");\n             }\n             sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                 + \"\\n\\n\");\n             os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n             // If we have aggregated logs for this container,\n             // output the aggregation logs as well.\n             ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                 .getApplicationId();\n             Application app \u003d nmContext.getApplications().get(appId);\n             String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n             try {\n               LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                   appId, appOwner, containerId.toString(),\n                   nmContext.getNodeId().toString(), outputFileName, bytes,\n                   os, buf);\n             } catch (Exception ex) {\n               // Something wrong when we try to access the aggregated log.\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"Can not access the aggregated log for \"\n                     + \"the container:\" + containerId);\n                 LOG.debug(ex.getMessage());\n               }\n             }\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            LogToolUtils.outputContainerLog(containerId.toString(),\n                nmContext.getNodeId().toString(), outputFileName, fileLength,\n                bytes, lastModifiedTime, fis, os, buf,\n                ContainerLogAggregationType.LOCAL);\n            StringBuilder sb \u003d new StringBuilder();\n            String endOfFile \u003d \"End of LogType:\" + outputFileName;\n            sb.append(endOfFile + \".\");\n            if (isRunning) {\n              sb.append(\"This log file belongs to a running container (\"\n                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n            } else {\n              sb.append(\"\\n\");\n            }\n            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                + \"\\n\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n            // If we have aggregated logs for this container,\n            // output the aggregation logs as well.\n            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                .getApplicationId();\n            Application app \u003d nmContext.getApplications().get(appId);\n            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n            try {\n              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                  appId, appOwner, containerId.toString(),\n                  nmContext.getNodeId().toString(), outputFileName, bytes,\n                  os, buf);\n            } catch (Exception ex) {\n              // Something wrong when we try to access the aggregated log.\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Can not access the aggregated log for \"\n                    + \"the container:\" + containerId);\n                LOG.debug(ex.getMessage());\n              }\n            }\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "327c9980aafce52cc02d2b8885fc4e9f628ab23c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6100. Improve YARN webservice to output aggregated container logs. Contributed by Xuan Gong.\n",
      "commitDate": "02/02/17 12:41 AM",
      "commitName": "327c9980aafce52cc02d2b8885fc4e9f628ab23c",
      "commitAuthor": "Junping Du",
      "commitDateOld": "24/01/17 3:26 PM",
      "commitNameOld": "8528d85a68c0e6ea71026df4d3026e7edc206b2d",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 8.39,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,43 @@\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n-            long toSkip \u003d 0;\n-            long totalBytesToRead \u003d fileLength;\n-            long skipAfterRead \u003d 0;\n-            if (bytes \u003c 0) {\n-              long absBytes \u003d Math.abs(bytes);\n-              if (absBytes \u003c fileLength) {\n-                toSkip \u003d fileLength - absBytes;\n-                totalBytesToRead \u003d absBytes;\n-              }\n-              org.apache.hadoop.io.IOUtils.skipFully(fis, toSkip);\n+            LogToolUtils.outputContainerLog(containerId.toString(),\n+                nmContext.getNodeId().toString(), outputFileName, fileLength,\n+                bytes, lastModifiedTime, fis, os, buf, ContainerLogType.LOCAL);\n+            StringBuilder sb \u003d new StringBuilder();\n+            String endOfFile \u003d \"End of LogFile:\" + outputFileName;\n+            sb.append(endOfFile + \".\");\n+            if (isRunning) {\n+              sb.append(\"This log file belongs to a running container (\"\n+                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n             } else {\n-              if (bytes \u003c fileLength) {\n-                totalBytesToRead \u003d bytes;\n-                skipAfterRead \u003d fileLength - bytes;\n+              sb.append(\"\\n\");\n+            }\n+            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n+                + \"\\n\\n\");\n+            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n+            // If we have aggregated logs for this container,\n+            // output the aggregation logs as well.\n+            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n+                .getApplicationId();\n+            Application app \u003d nmContext.getApplications().get(appId);\n+            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n+            try {\n+              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n+                  appId, appOwner, containerId.toString(),\n+                  nmContext.getNodeId().toString(), outputFileName, bytes,\n+                  os, buf);\n+            } catch (Exception ex) {\n+              // Something wrong when we try to access the aggregated log.\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Can not access the aggregated log for \"\n+                    + \"the container:\" + containerId);\n+                LOG.debug(ex.getMessage());\n               }\n             }\n-\n-            long curRead \u003d 0;\n-            long pendingRead \u003d totalBytesToRead - curRead;\n-            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n-                : (int) pendingRead;\n-            int len \u003d fis.read(buf, 0, toRead);\n-            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n-              os.write(buf, 0, len);\n-              curRead +\u003d len;\n-\n-              pendingRead \u003d totalBytesToRead - curRead;\n-              toRead \u003d pendingRead \u003e buf.length ? buf.length\n-                  : (int) pendingRead;\n-              len \u003d fis.read(buf, 0, toRead);\n-            }\n-            org.apache.hadoop.io.IOUtils.skipFully(fis, skipAfterRead);\n-            os.flush();\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            LogToolUtils.outputContainerLog(containerId.toString(),\n                nmContext.getNodeId().toString(), outputFileName, fileLength,\n                bytes, lastModifiedTime, fis, os, buf, ContainerLogType.LOCAL);\n            StringBuilder sb \u003d new StringBuilder();\n            String endOfFile \u003d \"End of LogFile:\" + outputFileName;\n            sb.append(endOfFile + \".\");\n            if (isRunning) {\n              sb.append(\"This log file belongs to a running container (\"\n                  + containerIdStr + \") and so may not be complete.\" + \"\\n\");\n            } else {\n              sb.append(\"\\n\");\n            }\n            sb.append(StringUtils.repeat(\"*\", endOfFile.length() + 50)\n                + \"\\n\\n\");\n            os.write(sb.toString().getBytes(Charset.forName(\"UTF-8\")));\n            // If we have aggregated logs for this container,\n            // output the aggregation logs as well.\n            ApplicationId appId \u003d containerId.getApplicationAttemptId()\n                .getApplicationId();\n            Application app \u003d nmContext.getApplications().get(appId);\n            String appOwner \u003d app \u003d\u003d null ? null : app.getUser();\n            try {\n              LogToolUtils.outputAggregatedContainerLog(nmContext.getConf(),\n                  appId, appOwner, containerId.toString(),\n                  nmContext.getNodeId().toString(), outputFileName, bytes,\n                  os, buf);\n            } catch (Exception ex) {\n              // Something wrong when we try to access the aggregated log.\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Can not access the aggregated log for \"\n                    + \"the container:\" + containerId);\n                LOG.debug(ex.getMessage());\n              }\n            }\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "c35fa4a0e57b99415e284c7c2f3b1a0bebc610c2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5251. Yarn CLI to obtain App logs for last \u0027n\u0027 bytes fails. Contributed by Xuan Gong.\n",
      "commitDate": "17/06/16 8:24 AM",
      "commitName": "c35fa4a0e57b99415e284c7c2f3b1a0bebc610c2",
      "commitAuthor": "Junping Du",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 2.72,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,42 @@\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           try {\n             int bufferSize \u003d 65536;\n             byte[] buf \u003d new byte[bufferSize];\n             long toSkip \u003d 0;\n             long totalBytesToRead \u003d fileLength;\n+            long skipAfterRead \u003d 0;\n             if (bytes \u003c 0) {\n               long absBytes \u003d Math.abs(bytes);\n               if (absBytes \u003c fileLength) {\n                 toSkip \u003d fileLength - absBytes;\n                 totalBytesToRead \u003d absBytes;\n               }\n-              long skippedBytes \u003d fis.skip(toSkip);\n-              if (skippedBytes !\u003d toSkip) {\n-                throw new IOException(\"The bytes were skipped are different \"\n-                    + \"from the caller requested\");\n-              }\n+              org.apache.hadoop.io.IOUtils.skipFully(fis, toSkip);\n             } else {\n               if (bytes \u003c fileLength) {\n                 totalBytesToRead \u003d bytes;\n+                skipAfterRead \u003d fileLength - bytes;\n               }\n             }\n \n             long curRead \u003d 0;\n             long pendingRead \u003d totalBytesToRead - curRead;\n             int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                 : (int) pendingRead;\n             int len \u003d fis.read(buf, 0, toRead);\n             while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n               os.write(buf, 0, len);\n               curRead +\u003d len;\n \n               pendingRead \u003d totalBytesToRead - curRead;\n               toRead \u003d pendingRead \u003e buf.length ? buf.length\n                   : (int) pendingRead;\n               len \u003d fis.read(buf, 0, toRead);\n             }\n+            org.apache.hadoop.io.IOUtils.skipFully(fis, skipAfterRead);\n             os.flush();\n           } finally {\n             IOUtils.closeQuietly(fis);\n           }\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            long toSkip \u003d 0;\n            long totalBytesToRead \u003d fileLength;\n            long skipAfterRead \u003d 0;\n            if (bytes \u003c 0) {\n              long absBytes \u003d Math.abs(bytes);\n              if (absBytes \u003c fileLength) {\n                toSkip \u003d fileLength - absBytes;\n                totalBytesToRead \u003d absBytes;\n              }\n              org.apache.hadoop.io.IOUtils.skipFully(fis, toSkip);\n            } else {\n              if (bytes \u003c fileLength) {\n                totalBytesToRead \u003d bytes;\n                skipAfterRead \u003d fileLength - bytes;\n              }\n            }\n\n            long curRead \u003d 0;\n            long pendingRead \u003d totalBytesToRead - curRead;\n            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                : (int) pendingRead;\n            int len \u003d fis.read(buf, 0, toRead);\n            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n              os.write(buf, 0, len);\n              curRead +\u003d len;\n\n              pendingRead \u003d totalBytesToRead - curRead;\n              toRead \u003d pendingRead \u003e buf.length ? buf.length\n                  : (int) pendingRead;\n              len \u003d fis.read(buf, 0, toRead);\n            }\n            org.apache.hadoop.io.IOUtils.skipFully(fis, skipAfterRead);\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "58be55b6e07b94aa55ed87c461f3e5c04cc61630": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5199. Close LogReader in in AHSWebServices#getStreamingOutput and\nFileInputStream in NMWebServices#getLogs. Contributed by Xuan Gong\n",
      "commitDate": "07/06/16 4:07 PM",
      "commitName": "58be55b6e07b94aa55ed87c461f3e5c04cc61630",
      "commitAuthor": "Xuan",
      "commitDateOld": "01/06/16 1:44 PM",
      "commitNameOld": "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 6.1,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,43 @@\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n-          int bufferSize \u003d 65536;\n-          byte[] buf \u003d new byte[bufferSize];\n-          long toSkip \u003d 0;\n-          long totalBytesToRead \u003d fileLength;\n-          if (bytes \u003c 0) {\n-            long absBytes \u003d Math.abs(bytes);\n-            if (absBytes \u003c fileLength) {\n-              toSkip \u003d fileLength - absBytes;\n-              totalBytesToRead \u003d absBytes;\n+          try {\n+            int bufferSize \u003d 65536;\n+            byte[] buf \u003d new byte[bufferSize];\n+            long toSkip \u003d 0;\n+            long totalBytesToRead \u003d fileLength;\n+            if (bytes \u003c 0) {\n+              long absBytes \u003d Math.abs(bytes);\n+              if (absBytes \u003c fileLength) {\n+                toSkip \u003d fileLength - absBytes;\n+                totalBytesToRead \u003d absBytes;\n+              }\n+              long skippedBytes \u003d fis.skip(toSkip);\n+              if (skippedBytes !\u003d toSkip) {\n+                throw new IOException(\"The bytes were skipped are different \"\n+                    + \"from the caller requested\");\n+              }\n+            } else {\n+              if (bytes \u003c fileLength) {\n+                totalBytesToRead \u003d bytes;\n+              }\n             }\n-            long skippedBytes \u003d fis.skip(toSkip);\n-            if (skippedBytes !\u003d toSkip) {\n-              throw new IOException(\"The bytes were skipped are different \"\n-                  + \"from the caller requested\");\n-            }\n-          } else {\n-            if (bytes \u003c fileLength) {\n-              totalBytesToRead \u003d bytes;\n-            }\n-          }\n \n-          long curRead \u003d 0;\n-          long pendingRead \u003d totalBytesToRead - curRead;\n-          int toRead \u003d pendingRead \u003e buf.length ? buf.length\n-              : (int) pendingRead;\n-          int len \u003d fis.read(buf, 0, toRead);\n-          while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n-            os.write(buf, 0, len);\n-            curRead +\u003d len;\n-\n-            pendingRead \u003d totalBytesToRead - curRead;\n-            toRead \u003d pendingRead \u003e buf.length ? buf.length\n+            long curRead \u003d 0;\n+            long pendingRead \u003d totalBytesToRead - curRead;\n+            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                 : (int) pendingRead;\n-            len \u003d fis.read(buf, 0, toRead);\n+            int len \u003d fis.read(buf, 0, toRead);\n+            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n+              os.write(buf, 0, len);\n+              curRead +\u003d len;\n+\n+              pendingRead \u003d totalBytesToRead - curRead;\n+              toRead \u003d pendingRead \u003e buf.length ? buf.length\n+                  : (int) pendingRead;\n+              len \u003d fis.read(buf, 0, toRead);\n+            }\n+            os.flush();\n+          } finally {\n+            IOUtils.closeQuietly(fis);\n           }\n-          os.flush();\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          try {\n            int bufferSize \u003d 65536;\n            byte[] buf \u003d new byte[bufferSize];\n            long toSkip \u003d 0;\n            long totalBytesToRead \u003d fileLength;\n            if (bytes \u003c 0) {\n              long absBytes \u003d Math.abs(bytes);\n              if (absBytes \u003c fileLength) {\n                toSkip \u003d fileLength - absBytes;\n                totalBytesToRead \u003d absBytes;\n              }\n              long skippedBytes \u003d fis.skip(toSkip);\n              if (skippedBytes !\u003d toSkip) {\n                throw new IOException(\"The bytes were skipped are different \"\n                    + \"from the caller requested\");\n              }\n            } else {\n              if (bytes \u003c fileLength) {\n                totalBytesToRead \u003d bytes;\n              }\n            }\n\n            long curRead \u003d 0;\n            long pendingRead \u003d totalBytesToRead - curRead;\n            int toRead \u003d pendingRead \u003e buf.length ? buf.length\n                : (int) pendingRead;\n            int len \u003d fis.read(buf, 0, toRead);\n            while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n              os.write(buf, 0, len);\n              curRead +\u003d len;\n\n              pendingRead \u003d totalBytesToRead - curRead;\n              toRead \u003d pendingRead \u003e buf.length ? buf.length\n                  : (int) pendingRead;\n              len \u003d fis.read(buf, 0, toRead);\n            }\n            os.flush();\n          } finally {\n            IOUtils.closeQuietly(fis);\n          }\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "0bc05e40fa7e183efe8463ada459c621da3ce3bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5088. Improve \"yarn log\" command-line to read the last K bytes for the log files. Contributed by Xuan Gong\n",
      "commitDate": "01/06/16 1:44 PM",
      "commitName": "0bc05e40fa7e183efe8463ada459c621da3ce3bf",
      "commitAuthor": "Xuan",
      "commitDateOld": "25/05/16 6:31 AM",
      "commitNameOld": "9a31e5dfef42929951d305f31200ca4f80d86632",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 7.3,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,10 +1,39 @@\n         public void write(OutputStream os) throws IOException,\n             WebApplicationException {\n           int bufferSize \u003d 65536;\n           byte[] buf \u003d new byte[bufferSize];\n-          int len;\n-          while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n+          long toSkip \u003d 0;\n+          long totalBytesToRead \u003d fileLength;\n+          if (bytes \u003c 0) {\n+            long absBytes \u003d Math.abs(bytes);\n+            if (absBytes \u003c fileLength) {\n+              toSkip \u003d fileLength - absBytes;\n+              totalBytesToRead \u003d absBytes;\n+            }\n+            long skippedBytes \u003d fis.skip(toSkip);\n+            if (skippedBytes !\u003d toSkip) {\n+              throw new IOException(\"The bytes were skipped are different \"\n+                  + \"from the caller requested\");\n+            }\n+          } else {\n+            if (bytes \u003c fileLength) {\n+              totalBytesToRead \u003d bytes;\n+            }\n+          }\n+\n+          long curRead \u003d 0;\n+          long pendingRead \u003d totalBytesToRead - curRead;\n+          int toRead \u003d pendingRead \u003e buf.length ? buf.length\n+              : (int) pendingRead;\n+          int len \u003d fis.read(buf, 0, toRead);\n+          while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n             os.write(buf, 0, len);\n+            curRead +\u003d len;\n+\n+            pendingRead \u003d totalBytesToRead - curRead;\n+            toRead \u003d pendingRead \u003e buf.length ? buf.length\n+                : (int) pendingRead;\n+            len \u003d fis.read(buf, 0, toRead);\n           }\n           os.flush();\n         }\n\\ No newline at end of file\n",
      "actualSource": "        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          int bufferSize \u003d 65536;\n          byte[] buf \u003d new byte[bufferSize];\n          long toSkip \u003d 0;\n          long totalBytesToRead \u003d fileLength;\n          if (bytes \u003c 0) {\n            long absBytes \u003d Math.abs(bytes);\n            if (absBytes \u003c fileLength) {\n              toSkip \u003d fileLength - absBytes;\n              totalBytesToRead \u003d absBytes;\n            }\n            long skippedBytes \u003d fis.skip(toSkip);\n            if (skippedBytes !\u003d toSkip) {\n              throw new IOException(\"The bytes were skipped are different \"\n                  + \"from the caller requested\");\n            }\n          } else {\n            if (bytes \u003c fileLength) {\n              totalBytesToRead \u003d bytes;\n            }\n          }\n\n          long curRead \u003d 0;\n          long pendingRead \u003d totalBytesToRead - curRead;\n          int toRead \u003d pendingRead \u003e buf.length ? buf.length\n              : (int) pendingRead;\n          int len \u003d fis.read(buf, 0, toRead);\n          while (len !\u003d -1 \u0026\u0026 curRead \u003c totalBytesToRead) {\n            os.write(buf, 0, len);\n            curRead +\u003d len;\n\n            pendingRead \u003d totalBytesToRead - curRead;\n            toRead \u003d pendingRead \u003e buf.length ? buf.length\n                : (int) pendingRead;\n            len \u003d fis.read(buf, 0, toRead);\n          }\n          os.flush();\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java",
      "extendedDetails": {}
    },
    "a759abcd898224c3481c55aa7e424bc286f60b15": {
      "type": "Yintroduced",
      "commitMessage": "YARN-649. Added a new NM web-service to serve container logs in plain text over HTTP. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1519326 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/09/13 5:09 PM",
      "commitName": "a759abcd898224c3481c55aa7e424bc286f60b15",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,10 @@\n+        public void write(OutputStream os) throws IOException,\n+            WebApplicationException {\n+          int bufferSize \u003d 65536;\n+          byte[] buf \u003d new byte[bufferSize];\n+          int len;\n+          while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n+            os.write(buf, 0, len);\n+          }\n+          os.flush();\n+        }\n\\ No newline at end of file\n",
      "actualSource": "        public void write(OutputStream os) throws IOException,\n            WebApplicationException {\n          int bufferSize \u003d 65536;\n          byte[] buf \u003d new byte[bufferSize];\n          int len;\n          while ((len \u003d fis.read(buf, 0, bufferSize)) \u003e 0) {\n            os.write(buf, 0, len);\n          }\n          os.flush();\n        }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/webapp/NMWebServices.java"
    }
  }
}