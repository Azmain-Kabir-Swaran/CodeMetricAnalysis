{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockReportLeaseManager.java",
  "functionName": "checkLease",
  "functionId": "checkLease___dn-DatanodeDescriptor__monotonicNowMs-long__id-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockReportLeaseManager.java",
  "functionStartLine": 293,
  "functionEndLine": 328,
  "numCommitsSeen": 5,
  "timeTaken": 2472,
  "changeHistory": [
    "c4463f2ef20d2cb634a1249246f83c451975f3dc",
    "85a20508bd04851d47c24b7562ec2927d5403446",
    "12b5b06c063d93e6c683c9b6fac9a96912f59e59"
  ],
  "changeHistoryShort": {
    "c4463f2ef20d2cb634a1249246f83c451975f3dc": "Ybodychange",
    "85a20508bd04851d47c24b7562ec2927d5403446": "Ybodychange",
    "12b5b06c063d93e6c683c9b6fac9a96912f59e59": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c4463f2ef20d2cb634a1249246f83c451975f3dc": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-10301. Interleaving processing of storages from repeated block reports causes false zombie storage detection, removes valid blocks. Contributed by Vinitha Gankidi.\"\n\nThis reverts commit 85a20508bd04851d47c24b7562ec2927d5403446.\n",
      "commitDate": "01/08/16 10:34 PM",
      "commitName": "c4463f2ef20d2cb634a1249246f83c451975f3dc",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "25/07/16 6:50 PM",
      "commitNameOld": "85a20508bd04851d47c24b7562ec2927d5403446",
      "commitAuthorOld": "Vinitha Reddy Gankidi",
      "daysBetweenCommits": 7.16,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   public synchronized boolean checkLease(DatanodeDescriptor dn,\n                                          long monotonicNowMs, long id) {\n     if (id \u003d\u003d 0) {\n       LOG.debug(\"Datanode {} is using BR lease id 0x0 to bypass \" +\n           \"rate-limiting.\", dn.getDatanodeUuid());\n       return true;\n     }\n     NodeData node \u003d nodes.get(dn.getDatanodeUuid());\n     if (node \u003d\u003d null) {\n       LOG.info(\"BR lease 0x{} is not valid for unknown datanode {}\",\n           Long.toHexString(id), dn.getDatanodeUuid());\n       return false;\n     }\n     if (node.leaseId \u003d\u003d 0) {\n-      LOG.warn(\"BR lease 0x{} is not found for DN {}, because the DN \" +\n+      LOG.warn(\"BR lease 0x{} is not valid for DN {}, because the DN \" +\n                \"is not in the pending set.\",\n                Long.toHexString(id), dn.getDatanodeUuid());\n-      return true;\n+      return false;\n     }\n     if (pruneIfExpired(monotonicNowMs, node)) {\n       LOG.warn(\"BR lease 0x{} is not valid for DN {}, because the lease \" +\n                \"has expired.\", Long.toHexString(id), dn.getDatanodeUuid());\n       return false;\n     }\n     if (id !\u003d node.leaseId) {\n       LOG.warn(\"BR lease 0x{} is not valid for DN {}.  Expected BR lease 0x{}.\",\n           Long.toHexString(id), dn.getDatanodeUuid(),\n           Long.toHexString(node.leaseId));\n       return false;\n     }\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"BR lease 0x{} is valid for DN {}.\",\n           Long.toHexString(id), dn.getDatanodeUuid());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized boolean checkLease(DatanodeDescriptor dn,\n                                         long monotonicNowMs, long id) {\n    if (id \u003d\u003d 0) {\n      LOG.debug(\"Datanode {} is using BR lease id 0x0 to bypass \" +\n          \"rate-limiting.\", dn.getDatanodeUuid());\n      return true;\n    }\n    NodeData node \u003d nodes.get(dn.getDatanodeUuid());\n    if (node \u003d\u003d null) {\n      LOG.info(\"BR lease 0x{} is not valid for unknown datanode {}\",\n          Long.toHexString(id), dn.getDatanodeUuid());\n      return false;\n    }\n    if (node.leaseId \u003d\u003d 0) {\n      LOG.warn(\"BR lease 0x{} is not valid for DN {}, because the DN \" +\n               \"is not in the pending set.\",\n               Long.toHexString(id), dn.getDatanodeUuid());\n      return false;\n    }\n    if (pruneIfExpired(monotonicNowMs, node)) {\n      LOG.warn(\"BR lease 0x{} is not valid for DN {}, because the lease \" +\n               \"has expired.\", Long.toHexString(id), dn.getDatanodeUuid());\n      return false;\n    }\n    if (id !\u003d node.leaseId) {\n      LOG.warn(\"BR lease 0x{} is not valid for DN {}.  Expected BR lease 0x{}.\",\n          Long.toHexString(id), dn.getDatanodeUuid(),\n          Long.toHexString(node.leaseId));\n      return false;\n    }\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"BR lease 0x{} is valid for DN {}.\",\n          Long.toHexString(id), dn.getDatanodeUuid());\n    }\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockReportLeaseManager.java",
      "extendedDetails": {}
    },
    "85a20508bd04851d47c24b7562ec2927d5403446": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10301. Interleaving processing of storages from repeated block reports causes false zombie storage detection, removes valid blocks. Contributed by Vinitha Gankidi.",
      "commitDate": "25/07/16 6:50 PM",
      "commitName": "85a20508bd04851d47c24b7562ec2927d5403446",
      "commitAuthor": "Vinitha Reddy Gankidi",
      "commitDateOld": "17/06/15 5:01 PM",
      "commitNameOld": "45ced38f10fcb9f831218b890786aaeb7987fed4",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 404.08,
      "commitsBetweenForRepo": 2789,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   public synchronized boolean checkLease(DatanodeDescriptor dn,\n                                          long monotonicNowMs, long id) {\n     if (id \u003d\u003d 0) {\n       LOG.debug(\"Datanode {} is using BR lease id 0x0 to bypass \" +\n           \"rate-limiting.\", dn.getDatanodeUuid());\n       return true;\n     }\n     NodeData node \u003d nodes.get(dn.getDatanodeUuid());\n     if (node \u003d\u003d null) {\n       LOG.info(\"BR lease 0x{} is not valid for unknown datanode {}\",\n           Long.toHexString(id), dn.getDatanodeUuid());\n       return false;\n     }\n     if (node.leaseId \u003d\u003d 0) {\n-      LOG.warn(\"BR lease 0x{} is not valid for DN {}, because the DN \" +\n+      LOG.warn(\"BR lease 0x{} is not found for DN {}, because the DN \" +\n                \"is not in the pending set.\",\n                Long.toHexString(id), dn.getDatanodeUuid());\n-      return false;\n+      return true;\n     }\n     if (pruneIfExpired(monotonicNowMs, node)) {\n       LOG.warn(\"BR lease 0x{} is not valid for DN {}, because the lease \" +\n                \"has expired.\", Long.toHexString(id), dn.getDatanodeUuid());\n       return false;\n     }\n     if (id !\u003d node.leaseId) {\n       LOG.warn(\"BR lease 0x{} is not valid for DN {}.  Expected BR lease 0x{}.\",\n           Long.toHexString(id), dn.getDatanodeUuid(),\n           Long.toHexString(node.leaseId));\n       return false;\n     }\n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"BR lease 0x{} is valid for DN {}.\",\n           Long.toHexString(id), dn.getDatanodeUuid());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized boolean checkLease(DatanodeDescriptor dn,\n                                         long monotonicNowMs, long id) {\n    if (id \u003d\u003d 0) {\n      LOG.debug(\"Datanode {} is using BR lease id 0x0 to bypass \" +\n          \"rate-limiting.\", dn.getDatanodeUuid());\n      return true;\n    }\n    NodeData node \u003d nodes.get(dn.getDatanodeUuid());\n    if (node \u003d\u003d null) {\n      LOG.info(\"BR lease 0x{} is not valid for unknown datanode {}\",\n          Long.toHexString(id), dn.getDatanodeUuid());\n      return false;\n    }\n    if (node.leaseId \u003d\u003d 0) {\n      LOG.warn(\"BR lease 0x{} is not found for DN {}, because the DN \" +\n               \"is not in the pending set.\",\n               Long.toHexString(id), dn.getDatanodeUuid());\n      return true;\n    }\n    if (pruneIfExpired(monotonicNowMs, node)) {\n      LOG.warn(\"BR lease 0x{} is not valid for DN {}, because the lease \" +\n               \"has expired.\", Long.toHexString(id), dn.getDatanodeUuid());\n      return false;\n    }\n    if (id !\u003d node.leaseId) {\n      LOG.warn(\"BR lease 0x{} is not valid for DN {}.  Expected BR lease 0x{}.\",\n          Long.toHexString(id), dn.getDatanodeUuid(),\n          Long.toHexString(node.leaseId));\n      return false;\n    }\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"BR lease 0x{} is valid for DN {}.\",\n          Long.toHexString(id), dn.getDatanodeUuid());\n    }\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockReportLeaseManager.java",
      "extendedDetails": {}
    },
    "12b5b06c063d93e6c683c9b6fac9a96912f59e59": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7923. The DataNodes should rate-limit their full block reports by asking the NN on heartbeat messages (cmccabe)\n",
      "commitDate": "12/06/15 11:17 AM",
      "commitName": "12b5b06c063d93e6c683c9b6fac9a96912f59e59",
      "commitAuthor": "Colin Patrick Mccabe",
      "diff": "@@ -0,0 +1,36 @@\n+  public synchronized boolean checkLease(DatanodeDescriptor dn,\n+                                         long monotonicNowMs, long id) {\n+    if (id \u003d\u003d 0) {\n+      LOG.debug(\"Datanode {} is using BR lease id 0x0 to bypass \" +\n+          \"rate-limiting.\", dn.getDatanodeUuid());\n+      return true;\n+    }\n+    NodeData node \u003d nodes.get(dn.getDatanodeUuid());\n+    if (node \u003d\u003d null) {\n+      LOG.info(\"BR lease 0x{} is not valid for unknown datanode {}\",\n+          Long.toHexString(id), dn.getDatanodeUuid());\n+      return false;\n+    }\n+    if (node.leaseId \u003d\u003d 0) {\n+      LOG.warn(\"BR lease 0x{} is not valid for DN {}, because the DN \" +\n+               \"is not in the pending set.\",\n+               Long.toHexString(id), dn.getDatanodeUuid());\n+      return false;\n+    }\n+    if (pruneIfExpired(monotonicNowMs, node)) {\n+      LOG.warn(\"BR lease 0x{} is not valid for DN {}, because the lease \" +\n+               \"has expired.\", Long.toHexString(id), dn.getDatanodeUuid());\n+      return false;\n+    }\n+    if (id !\u003d node.leaseId) {\n+      LOG.warn(\"BR lease 0x{} is not valid for DN {}.  Expected BR lease 0x{}.\",\n+          Long.toHexString(id), dn.getDatanodeUuid(),\n+          Long.toHexString(node.leaseId));\n+      return false;\n+    }\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(\"BR lease 0x{} is valid for DN {}.\",\n+          Long.toHexString(id), dn.getDatanodeUuid());\n+    }\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized boolean checkLease(DatanodeDescriptor dn,\n                                         long monotonicNowMs, long id) {\n    if (id \u003d\u003d 0) {\n      LOG.debug(\"Datanode {} is using BR lease id 0x0 to bypass \" +\n          \"rate-limiting.\", dn.getDatanodeUuid());\n      return true;\n    }\n    NodeData node \u003d nodes.get(dn.getDatanodeUuid());\n    if (node \u003d\u003d null) {\n      LOG.info(\"BR lease 0x{} is not valid for unknown datanode {}\",\n          Long.toHexString(id), dn.getDatanodeUuid());\n      return false;\n    }\n    if (node.leaseId \u003d\u003d 0) {\n      LOG.warn(\"BR lease 0x{} is not valid for DN {}, because the DN \" +\n               \"is not in the pending set.\",\n               Long.toHexString(id), dn.getDatanodeUuid());\n      return false;\n    }\n    if (pruneIfExpired(monotonicNowMs, node)) {\n      LOG.warn(\"BR lease 0x{} is not valid for DN {}, because the lease \" +\n               \"has expired.\", Long.toHexString(id), dn.getDatanodeUuid());\n      return false;\n    }\n    if (id !\u003d node.leaseId) {\n      LOG.warn(\"BR lease 0x{} is not valid for DN {}.  Expected BR lease 0x{}.\",\n          Long.toHexString(id), dn.getDatanodeUuid(),\n          Long.toHexString(node.leaseId));\n      return false;\n    }\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"BR lease 0x{} is valid for DN {}.\",\n          Long.toHexString(id), dn.getDatanodeUuid());\n    }\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockReportLeaseManager.java"
    }
  }
}