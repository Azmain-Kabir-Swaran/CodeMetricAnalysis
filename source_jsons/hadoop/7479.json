{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirRenameOp.java",
  "functionName": "renameForEditLog",
  "functionId": "renameForEditLog___fsd-FSDirectory__src-String__dst-String__timestamp-long__options-Options.Rename",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
  "functionStartLine": 328,
  "functionEndLine": 341,
  "numCommitsSeen": 262,
  "timeTaken": 19448,
  "changeHistory": [
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
    "5f34402adae191232fe78e62990396ca07f314bb",
    "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
    "b2c85db86c9a62b0a03ee87547265077f664970a",
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
    "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
    "3425ae5d7eaa27b2526d0e0c07bdfea9440359f8",
    "f20d36312681658f12c3fad49a8c0deddfa5f333",
    "8044a12ac02cc4495935a3afded8c1d4369c1445",
    "ceed0f6c46736323bd1b077125ff4e217c649208",
    "76a621ffd2d66bf012a554f4400091a92a5b473e",
    "c38665282884122d3c82b6f68376cce036aee748",
    "31617733aca2025cff1ffb841a533a5b1de016a5",
    "08986fdbed5a15bcdc57d142922911759b97e9d1",
    "4cf94aaf809c77b3b7dc925faa39a72d53e4246e",
    "ae9109b911b3d9e2d6ca50b400379fc31deeb0cf",
    "0689363343a281a6f7f6f395227668bddc2663eb",
    "2b03ae94216a76a477f3d6250d076ebbf61e998a",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795",
    "44a6560b5da3f79d2299579a36e7a2a60a91f823",
    "6431192c0ee00ecfe578b270889b0c7a0a9cb8c8",
    "d46e1608626c64400d2b6c7693a4c035783c55b4",
    "bf99961d67bf59dad6a861655407f9e0a5f21aa5",
    "3a3e0f573129c8308332d4b301a9319ee579d85a",
    "0fa5cad0b27780c27a284c23101b1099d4886506",
    "92e0416ced279a910616985bf11fa3f8b1b1de9b",
    "6bda1f20ad396918edde211f709f5819a361b51e",
    "9c6a7bebe23ffb85d7fd95607f3b7bb4fe82dbe4",
    "ca848beb533790ae8abb6498f5d4676594fbae4c",
    "1096917649fd951be633e5619518764f23cca645",
    "25aab4203c465403ae0c4ad62ec948094e023489",
    "9701555899315c94584b24d8717c1d7540a4a491",
    "3b3ea5c4220e674064c7603a449f63904c10bac1",
    "8d95784bf1a7fcf473fd5a9fed0140521a92a968",
    "b1333e5b561d01a010e2e1311e8501879f377bdc",
    "f29fa9e820e25730d00a1a00c51c6f11028fb5a7",
    "e7db60fbfcc222b32d610ffd912683494674ad2f",
    "2372e394dd99d69d396327d5a5e172953a8b8c6a",
    "93872b58e50eb6ecf65544cc9e8aea5a4988e19b",
    "b9f965de120b5278ac84a7e98aecb32aafde4c16",
    "cbbaa93ae09bf5cf643263faf78f99315c4f3a8d",
    "9821af9ce8a56a2c583f1ed938902c20e897048f",
    "88eea2157275d4c7e1bf70cac98fe52c326f3585",
    "9047eb516261b8c9c380d140a43dfdd5d701dee5",
    "d66f9e8269424f588180f2659c8cf132a2a7dfc9",
    "2116d0520e528c44fa280f2a5b28594c6d6fc28a",
    "099762a0bc960066f8157fdd1e495b6752a6f802",
    "b94cf83a113564ec07880c44d6b03a461f9fc923",
    "1734215a10fd93e38849ed0235b5e026b7f50f83",
    "34413c2000d9262faa37fde88a72939587edc776",
    "7ee5ce3176a74d217551b5981f809a56c719424b",
    "d174f574bafcfefc635c64a47f258b1ce5d5c84e",
    "1b3b09d94794622e8336220d897a1f10c4654677",
    "0e796b61e829c4bf763caf13b0f53cb1bcefdeee",
    "10dc6b09272dbf2022907681e134104e7d418021",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": "Ybodychange",
    "5f34402adae191232fe78e62990396ca07f314bb": "Ybodychange",
    "a49cc74b4c72195dee1dfb6f9548e5e411dff553": "Ybodychange",
    "b2c85db86c9a62b0a03ee87547265077f664970a": "Ymultichange(Yreturntypechange,Ybodychange)",
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0": "Yrename",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": "Ybodychange",
    "042699401ebe5186fa5556a79f8f9a206e5ebcd7": "Ymultichange(Ymovefromfile,Ymodifierchange,Yexceptionschange,Ybodychange,Yparameterchange)",
    "3425ae5d7eaa27b2526d0e0c07bdfea9440359f8": "Ybodychange",
    "f20d36312681658f12c3fad49a8c0deddfa5f333": "Ybodychange",
    "8044a12ac02cc4495935a3afded8c1d4369c1445": "Ybodychange",
    "ceed0f6c46736323bd1b077125ff4e217c649208": "Ybodychange",
    "76a621ffd2d66bf012a554f4400091a92a5b473e": "Ybodychange",
    "c38665282884122d3c82b6f68376cce036aee748": "Ybodychange",
    "31617733aca2025cff1ffb841a533a5b1de016a5": "Ybodychange",
    "08986fdbed5a15bcdc57d142922911759b97e9d1": "Ybodychange",
    "4cf94aaf809c77b3b7dc925faa39a72d53e4246e": "Ybodychange",
    "ae9109b911b3d9e2d6ca50b400379fc31deeb0cf": "Ybodychange",
    "0689363343a281a6f7f6f395227668bddc2663eb": "Ybodychange",
    "2b03ae94216a76a477f3d6250d076ebbf61e998a": "Ybodychange",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": "Ybodychange",
    "44a6560b5da3f79d2299579a36e7a2a60a91f823": "Ybodychange",
    "6431192c0ee00ecfe578b270889b0c7a0a9cb8c8": "Ybodychange",
    "d46e1608626c64400d2b6c7693a4c035783c55b4": "Ybodychange",
    "bf99961d67bf59dad6a861655407f9e0a5f21aa5": "Ybodychange",
    "3a3e0f573129c8308332d4b301a9319ee579d85a": "Ybodychange",
    "0fa5cad0b27780c27a284c23101b1099d4886506": "Ybodychange",
    "92e0416ced279a910616985bf11fa3f8b1b1de9b": "Ybodychange",
    "6bda1f20ad396918edde211f709f5819a361b51e": "Ybodychange",
    "9c6a7bebe23ffb85d7fd95607f3b7bb4fe82dbe4": "Ybodychange",
    "ca848beb533790ae8abb6498f5d4676594fbae4c": "Ybodychange",
    "1096917649fd951be633e5619518764f23cca645": "Ybodychange",
    "25aab4203c465403ae0c4ad62ec948094e023489": "Ybodychange",
    "9701555899315c94584b24d8717c1d7540a4a491": "Ybodychange",
    "3b3ea5c4220e674064c7603a449f63904c10bac1": "Ybodychange",
    "8d95784bf1a7fcf473fd5a9fed0140521a92a968": "Ybodychange",
    "b1333e5b561d01a010e2e1311e8501879f377bdc": "Ybodychange",
    "f29fa9e820e25730d00a1a00c51c6f11028fb5a7": "Ybodychange",
    "e7db60fbfcc222b32d610ffd912683494674ad2f": "Ybodychange",
    "2372e394dd99d69d396327d5a5e172953a8b8c6a": "Ybodychange",
    "93872b58e50eb6ecf65544cc9e8aea5a4988e19b": "Ybodychange",
    "b9f965de120b5278ac84a7e98aecb32aafde4c16": "Ybodychange",
    "cbbaa93ae09bf5cf643263faf78f99315c4f3a8d": "Ybodychange",
    "9821af9ce8a56a2c583f1ed938902c20e897048f": "Ybodychange",
    "88eea2157275d4c7e1bf70cac98fe52c326f3585": "Ybodychange",
    "9047eb516261b8c9c380d140a43dfdd5d701dee5": "Ybodychange",
    "d66f9e8269424f588180f2659c8cf132a2a7dfc9": "Ybodychange",
    "2116d0520e528c44fa280f2a5b28594c6d6fc28a": "Ybodychange",
    "099762a0bc960066f8157fdd1e495b6752a6f802": "Ybodychange",
    "b94cf83a113564ec07880c44d6b03a461f9fc923": "Ybodychange",
    "1734215a10fd93e38849ed0235b5e026b7f50f83": "Ybodychange",
    "34413c2000d9262faa37fde88a72939587edc776": "Ybodychange",
    "7ee5ce3176a74d217551b5981f809a56c719424b": "Ybodychange",
    "d174f574bafcfefc635c64a47f258b1ce5d5c84e": "Ybodychange",
    "1b3b09d94794622e8336220d897a1f10c4654677": "Ybodychange",
    "0e796b61e829c4bf763caf13b0f53cb1bcefdeee": "Ybodychange",
    "10dc6b09272dbf2022907681e134104e7d418021": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
      "commitDate": "24/10/16 3:14 PM",
      "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "06/10/16 1:11 PM",
      "commitNameOld": "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 18.09,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,14 +1,14 @@\n   static void renameForEditLog(\n       FSDirectory fsd, String src, String dst, long timestamp,\n       Options.Rename... options)\n       throws IOException {\n     BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n-    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n+    final INodesInPath srcIIP \u003d fsd.getINodesInPath(src, DirOp.WRITE_LINK);\n+    final INodesInPath dstIIP \u003d fsd.getINodesInPath(dst, DirOp.WRITE_LINK);\n     unprotectedRenameTo(fsd, srcIIP, dstIIP, timestamp,\n         collectedBlocks, options);\n     if (!collectedBlocks.getToDeleteList().isEmpty()) {\n       fsd.getFSNamesystem().getBlockManager()\n           .removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void renameForEditLog(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      Options.Rename... options)\n      throws IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath(src, DirOp.WRITE_LINK);\n    final INodesInPath dstIIP \u003d fsd.getINodesInPath(dst, DirOp.WRITE_LINK);\n    unprotectedRenameTo(fsd, srcIIP, dstIIP, timestamp,\n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      fsd.getFSNamesystem().getBlockManager()\n          .removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "5f34402adae191232fe78e62990396ca07f314bb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10779. Rename does not need to re-solve destination. Contributed by Daryn Sharp.\n",
      "commitDate": "28/09/16 3:57 PM",
      "commitName": "5f34402adae191232fe78e62990396ca07f314bb",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "22/08/16 6:29 PM",
      "commitNameOld": "c49333becfa7652460976a61eb86522010bcfeed",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 36.89,
      "commitsBetweenForRepo": 212,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,14 +1,14 @@\n   static void renameForEditLog(\n       FSDirectory fsd, String src, String dst, long timestamp,\n       Options.Rename... options)\n       throws IOException {\n     BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n     final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n-    unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n+    unprotectedRenameTo(fsd, srcIIP, dstIIP, timestamp,\n         collectedBlocks, options);\n     if (!collectedBlocks.getToDeleteList().isEmpty()) {\n       fsd.getFSNamesystem().getBlockManager()\n           .removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void renameForEditLog(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      Options.Rename... options)\n      throws IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    unprotectedRenameTo(fsd, srcIIP, dstIIP, timestamp,\n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      fsd.getFSNamesystem().getBlockManager()\n          .removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "a49cc74b4c72195dee1dfb6f9548e5e411dff553": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9129. Move the safemode block count into BlockManager. Contributed by Mingliang Liu.\n",
      "commitDate": "01/12/15 4:09 PM",
      "commitName": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "21/10/15 4:58 PM",
      "commitNameOld": "3dadf369d550c2ae393b751cb5a184dbfe2814df",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 41.01,
      "commitsBetweenForRepo": 316,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,14 @@\n   static void renameForEditLog(\n       FSDirectory fsd, String src, String dst, long timestamp,\n       Options.Rename... options)\n       throws IOException {\n     BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n     final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n         collectedBlocks, options);\n     if (!collectedBlocks.getToDeleteList().isEmpty()) {\n-      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n+      fsd.getFSNamesystem().getBlockManager()\n+          .removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void renameForEditLog(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      Options.Rename... options)\n      throws IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      fsd.getFSNamesystem().getBlockManager()\n          .removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "b2c85db86c9a62b0a03ee87547265077f664970a": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-7728. Avoid updating quota usage while loading edits. Contributed by Jing Zhao.\n",
      "commitDate": "13/05/15 9:50 PM",
      "commitName": "b2c85db86c9a62b0a03ee87547265077f664970a",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-7728. Avoid updating quota usage while loading edits. Contributed by Jing Zhao.\n",
          "commitDate": "13/05/15 9:50 PM",
          "commitName": "b2c85db86c9a62b0a03ee87547265077f664970a",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "09/05/15 10:51 PM",
          "commitNameOld": "4536399d47f6c061e149e2504600804a0f1e093d",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 3.96,
          "commitsBetweenForRepo": 43,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,13 @@\n-  static boolean renameForEditLog(\n+  static void renameForEditLog(\n       FSDirectory fsd, String src, String dst, long timestamp,\n       Options.Rename... options)\n       throws IOException {\n     BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n     final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n-    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n+    unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n         collectedBlocks, options);\n     if (!collectedBlocks.getToDeleteList().isEmpty()) {\n       fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n-    return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static void renameForEditLog(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      Options.Rename... options)\n      throws IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "boolean",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7728. Avoid updating quota usage while loading edits. Contributed by Jing Zhao.\n",
          "commitDate": "13/05/15 9:50 PM",
          "commitName": "b2c85db86c9a62b0a03ee87547265077f664970a",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "09/05/15 10:51 PM",
          "commitNameOld": "4536399d47f6c061e149e2504600804a0f1e093d",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 3.96,
          "commitsBetweenForRepo": 43,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,14 +1,13 @@\n-  static boolean renameForEditLog(\n+  static void renameForEditLog(\n       FSDirectory fsd, String src, String dst, long timestamp,\n       Options.Rename... options)\n       throws IOException {\n     BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n     final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n-    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n+    unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n         collectedBlocks, options);\n     if (!collectedBlocks.getToDeleteList().isEmpty()) {\n       fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n-    return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static void renameForEditLog(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      Options.Rename... options)\n      throws IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0": {
      "type": "Yrename",
      "commitMessage": "HDFS-7484. Make FSDirectory#addINode take existing INodes as its parameter. Contributed by Jing Zhao.\n",
      "commitDate": "22/12/14 11:19 PM",
      "commitName": "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "18/12/14 11:25 AM",
      "commitNameOld": "65f2a4ee600dfffa5203450261da3c1989de25a9",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 4.5,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,14 +1,14 @@\n-  static boolean unprotectedRenameTo(\n+  static boolean renameForEditLog(\n       FSDirectory fsd, String src, String dst, long timestamp,\n       Options.Rename... options)\n       throws IOException {\n     BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n     final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n     final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n     boolean ret \u003d unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n         collectedBlocks, options);\n     if (!collectedBlocks.getToDeleteList().isEmpty()) {\n       fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean renameForEditLog(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      Options.Rename... options)\n      throws IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {
        "oldValue": "unprotectedRenameTo",
        "newValue": "renameForEditLog"
      }
    },
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
      "commitDate": "12/12/14 3:13 PM",
      "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "11/12/14 12:36 PM",
      "commitNameOld": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.11,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,12 +1,14 @@\n   static boolean unprotectedRenameTo(\n       FSDirectory fsd, String src, String dst, long timestamp,\n       Options.Rename... options)\n       throws IOException {\n     BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, timestamp,\n+    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n+    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n+    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n         collectedBlocks, options);\n     if (!collectedBlocks.getToDeleteList().isEmpty()) {\n       fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      Options.Rename... options)\n      throws IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    final INodesInPath srcIIP \u003d fsd.getINodesInPath4Write(src, false);\n    final INodesInPath dstIIP \u003d fsd.getINodesInPath4Write(dst, false);\n    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, srcIIP, dstIIP, timestamp,\n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
      "extendedDetails": {}
    },
    "042699401ebe5186fa5556a79f8f9a206e5ebcd7": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Yexceptionschange,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
      "commitDate": "01/12/14 9:48 PM",
      "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,12 +1,12 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n-      Options.Rename... options) throws FileAlreadyExistsException, \n-      FileNotFoundException, ParentNotDirectoryException, \n-      QuotaExceededException, UnresolvedLinkException, IOException {\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp,\n+      Options.Rename... options)\n+      throws IOException {\n     BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-    boolean ret \u003d unprotectedRenameTo(src, dst, timestamp, \n+    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, timestamp,\n         collectedBlocks, options);\n     if (!collectedBlocks.getToDeleteList().isEmpty()) {\n-      getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n+      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      Options.Rename... options)\n      throws IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, timestamp,\n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
            "oldMethodName": "unprotectedRenameTo",
            "newMethodName": "unprotectedRenameTo"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,12 +1,12 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n-      Options.Rename... options) throws FileAlreadyExistsException, \n-      FileNotFoundException, ParentNotDirectoryException, \n-      QuotaExceededException, UnresolvedLinkException, IOException {\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp,\n+      Options.Rename... options)\n+      throws IOException {\n     BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-    boolean ret \u003d unprotectedRenameTo(src, dst, timestamp, \n+    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, timestamp,\n         collectedBlocks, options);\n     if (!collectedBlocks.getToDeleteList().isEmpty()) {\n-      getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n+      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      Options.Rename... options)\n      throws IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, timestamp,\n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,12 +1,12 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n-      Options.Rename... options) throws FileAlreadyExistsException, \n-      FileNotFoundException, ParentNotDirectoryException, \n-      QuotaExceededException, UnresolvedLinkException, IOException {\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp,\n+      Options.Rename... options)\n+      throws IOException {\n     BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-    boolean ret \u003d unprotectedRenameTo(src, dst, timestamp, \n+    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, timestamp,\n         collectedBlocks, options);\n     if (!collectedBlocks.getToDeleteList().isEmpty()) {\n-      getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n+      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      Options.Rename... options)\n      throws IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, timestamp,\n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[FileAlreadyExistsException, FileNotFoundException, ParentNotDirectoryException, QuotaExceededException, UnresolvedLinkException, IOException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,12 +1,12 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n-      Options.Rename... options) throws FileAlreadyExistsException, \n-      FileNotFoundException, ParentNotDirectoryException, \n-      QuotaExceededException, UnresolvedLinkException, IOException {\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp,\n+      Options.Rename... options)\n+      throws IOException {\n     BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-    boolean ret \u003d unprotectedRenameTo(src, dst, timestamp, \n+    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, timestamp,\n         collectedBlocks, options);\n     if (!collectedBlocks.getToDeleteList().isEmpty()) {\n-      getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n+      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      Options.Rename... options)\n      throws IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, timestamp,\n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7438. Consolidate the implementation of rename() into a single class. Contributed by Haohui Mai.\n",
          "commitDate": "01/12/14 9:48 PM",
          "commitName": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "01/12/14 9:36 PM",
          "commitNameOld": "0af44ea8462437f8e7a8271b15a19677fd7f05a1",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,12 +1,12 @@\n-  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n-      Options.Rename... options) throws FileAlreadyExistsException, \n-      FileNotFoundException, ParentNotDirectoryException, \n-      QuotaExceededException, UnresolvedLinkException, IOException {\n+  static boolean unprotectedRenameTo(\n+      FSDirectory fsd, String src, String dst, long timestamp,\n+      Options.Rename... options)\n+      throws IOException {\n     BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-    boolean ret \u003d unprotectedRenameTo(src, dst, timestamp, \n+    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, timestamp,\n         collectedBlocks, options);\n     if (!collectedBlocks.getToDeleteList().isEmpty()) {\n-      getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n+      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static boolean unprotectedRenameTo(\n      FSDirectory fsd, String src, String dst, long timestamp,\n      Options.Rename... options)\n      throws IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    boolean ret \u003d unprotectedRenameTo(fsd, src, dst, timestamp,\n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      fsd.getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n    return ret;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirRenameOp.java",
          "extendedDetails": {
            "oldValue": "[src-String, dst-String, timestamp-long, options-Options.Rename]",
            "newValue": "[fsd-FSDirectory, src-String, dst-String, timestamp-long, options-Options.Rename]"
          }
        }
      ]
    },
    "3425ae5d7eaa27b2526d0e0c07bdfea9440359f8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2975. Rename with overwrite flag true can make NameNode to stuck in safemode on NN (crash + restart). (Yi Liu via umamahesh)\n",
      "commitDate": "03/09/14 6:23 AM",
      "commitName": "3425ae5d7eaa27b2526d0e0c07bdfea9440359f8",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "20/08/14 11:19 AM",
      "commitNameOld": "834fccf02b5202176f3c0a5e580c46855ca5d1d5",
      "commitAuthorOld": "",
      "daysBetweenCommits": 13.79,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,12 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n-      Options.Rename... options) throws FileAlreadyExistsException,\n-      FileNotFoundException, ParentNotDirectoryException,\n+      Options.Rename... options) throws FileAlreadyExistsException, \n+      FileNotFoundException, ParentNotDirectoryException, \n       QuotaExceededException, UnresolvedLinkException, IOException {\n-    assert hasWriteLock();\n-    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n-            (Rename.OVERWRITE);\n-\n-    final String error;\n-    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n-    final INode srcInode \u003d srcIIP.getLastINode();\n-    validateRenameSource(src, srcIIP);\n-\n-    // validate the destination\n-    if (dst.equals(src)) {\n-      throw new FileAlreadyExistsException(\n-          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n+    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n+    boolean ret \u003d unprotectedRenameTo(src, dst, timestamp, \n+        collectedBlocks, options);\n+    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n+      getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n     }\n-    validateRenameDestination(src, dst, srcInode);\n-\n-    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n-    if (dstIIP.getINodes().length \u003d\u003d 1) {\n-      error \u003d \"rename destination cannot be the root\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n-      throw new IOException(error);\n-    }\n-\n-    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n-    final INode dstInode \u003d dstIIP.getLastINode();\n-    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n-    if (dstInode !\u003d null) { // Destination exists\n-      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n-      checkSnapshot(dstInode, snapshottableDirs);\n-    }\n-\n-    INode dstParent \u003d dstIIP.getINode(-2);\n-    if (dstParent \u003d\u003d null) {\n-      error \u003d \"rename destination parent \" + dst + \" not found.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n-      throw new FileNotFoundException(error);\n-    }\n-    if (!dstParent.isDirectory()) {\n-      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n-      throw new ParentNotDirectoryException(error);\n-    }\n-\n-    // Ensure dst has quota to accommodate rename\n-    verifyFsLimitsForRename(srcIIP, dstIIP);\n-    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n-\n-    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n-\n-    boolean undoRemoveSrc \u003d true;\n-    final long removedSrc \u003d removeLastINode(srcIIP);\n-    if (removedSrc \u003d\u003d -1) {\n-      error \u003d \"Failed to rename \" + src + \" to \" + dst\n-          + \" because the source can not be removed\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n-      throw new IOException(error);\n-    }\n-    \n-    boolean undoRemoveDst \u003d false;\n-    INode removedDst \u003d null;\n-    long removedNum \u003d 0;\n-    try {\n-      if (dstInode !\u003d null) { // dst exists remove it\n-        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n-          removedDst \u003d dstIIP.getLastINode();\n-          undoRemoveDst \u003d true;\n-        }\n-      }\n-\n-      // add src as dst to complete rename\n-      if (tx.addSourceToDestination()) {\n-        undoRemoveSrc \u003d false;\n-        if (NameNode.stateChangeLog.isDebugEnabled()) {\n-          NameNode.stateChangeLog.debug(\n-              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n-              + \" is renamed to \" + dst);\n-        }\n-\n-        tx.updateMtimeAndLease(timestamp);\n-\n-        // Collect the blocks and remove the lease for previous dst\n-        boolean filesDeleted \u003d false;\n-        if (removedDst !\u003d null) {\n-          undoRemoveDst \u003d false;\n-          if (removedNum \u003e 0) {\n-            BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n-            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n-              removedDst.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n-              filesDeleted \u003d true;\n-            } else {\n-              filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n-                  dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n-                  true).get(Quota.NAMESPACE) \u003e\u003d 0;\n-            }\n-            getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n-                removedINodes, false);\n-          }\n-        }\n-\n-        if (snapshottableDirs.size() \u003e 0) {\n-          // There are snapshottable directories (without snapshots) to be\n-          // deleted. Need to update the SnapshotManager.\n-          namesystem.removeSnapshottableDirs(snapshottableDirs);\n-        }\n-\n-        tx.updateQuotasInSourceTree();\n-        return filesDeleted;\n-      }\n-    } finally {\n-      if (undoRemoveSrc) {\n-        tx.restoreSource();\n-      }\n-\n-      if (undoRemoveDst) {\n-        // Rename failed - restore dst\n-        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n-          dstParent.asDirectory().undoRename4DstParent(removedDst,\n-              dstIIP.getLatestSnapshotId());\n-        } else {\n-          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n-        }\n-        if (removedDst.isReference()) {\n-          final INodeReference removedDstRef \u003d removedDst.asReference();\n-          final INodeReference.WithCount wc \u003d \n-              (WithCount) removedDstRef.getReferredINode().asReference();\n-          wc.addReference(removedDstRef);\n-        }\n-      }\n-    }\n-    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-        + \"failed to rename \" + src + \" to \" + dst);\n-    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n+    return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException, \n      FileNotFoundException, ParentNotDirectoryException, \n      QuotaExceededException, UnresolvedLinkException, IOException {\n    BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n    boolean ret \u003d unprotectedRenameTo(src, dst, timestamp, \n        collectedBlocks, options);\n    if (!collectedBlocks.getToDeleteList().isEmpty()) {\n      getFSNamesystem().removeBlocksAndUpdateSafemodeTotal(collectedBlocks);\n    }\n    return ret;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "f20d36312681658f12c3fad49a8c0deddfa5f333": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6870. Blocks and INodes could leak for Rename with overwrite flag. Contributed by Yi Liu.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1619192 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/08/14 11:13 AM",
      "commitName": "f20d36312681658f12c3fad49a8c0deddfa5f333",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "11/08/14 2:28 PM",
      "commitNameOld": "80691b073fe7c104a8684c0a8900a1657bcdc03f",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 8.86,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,141 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n             (Rename.OVERWRITE);\n \n     final String error;\n     final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     validateRenameDestination(src, dst, srcInode);\n \n     INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n-        long filesDeleted \u003d -1;\n+        boolean filesDeleted \u003d false;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n-            filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n-                dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n-                true).get(Quota.NAMESPACE);\n+            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n+              removedDst.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n+              filesDeleted \u003d true;\n+            } else {\n+              filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n+                  dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n+                  true).get(Quota.NAMESPACE) \u003e\u003d 0;\n+            }\n             getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                 removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n-        return filesDeleted \u003e\u003d 0;\n+        return filesDeleted;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n            (Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    validateRenameDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        boolean filesDeleted \u003d false;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            if (!removedDst.isInLatestSnapshot(dstIIP.getLatestSnapshotId())) {\n              removedDst.destroyAndCollectBlocks(collectedBlocks, removedINodes);\n              filesDeleted \u003d true;\n            } else {\n              filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                  dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                  true).get(Quota.NAMESPACE) \u003e\u003d 0;\n            }\n            getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "8044a12ac02cc4495935a3afded8c1d4369c1445": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6618. FSNamesystem#delete drops the FSN lock between removing INodes from the tree and deleting them from the inode map (kihwal via cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1609380 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/07/14 8:49 PM",
      "commitName": "8044a12ac02cc4495935a3afded8c1d4369c1445",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "07/07/14 5:08 PM",
      "commitNameOld": "76a621ffd2d66bf012a554f4400091a92a5b473e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 2.15,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,136 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n             (Rename.OVERWRITE);\n \n     final String error;\n     final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     validateRenameDestination(src, dst, srcInode);\n \n     INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                 dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                 true).get(Quota.NAMESPACE);\n             getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n-                removedINodes);\n+                removedINodes, false);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n            (Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    validateRenameDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                true).get(Quota.NAMESPACE);\n            getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                removedINodes, false);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "ceed0f6c46736323bd1b077125ff4e217c649208": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6635. Refactor encryption zone functionality into new EncryptionZoneManager class. (wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1608657 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/07/14 9:34 PM",
      "commitName": "ceed0f6c46736323bd1b077125ff4e217c649208",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "07/07/14 1:43 PM",
      "commitNameOld": "dda85637df2c970d905b550c89208ac6ca63994d",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.33,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,138 +1,138 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n             (Rename.OVERWRITE);\n \n     final String error;\n     final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     validateRenameDestination(src, dst, srcInode);\n \n     INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n-    checkEncryptionZoneMoveValidity(srcIIP, dstIIP, src);\n+    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                 dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                 true).get(Quota.NAMESPACE);\n             getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                 removedINodes);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n            (Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    validateRenameDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    ezManager.checkMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                true).get(Quota.NAMESPACE);\n            getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                removedINodes);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "76a621ffd2d66bf012a554f4400091a92a5b473e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6609. Use DirectorySnapshottableFeature to represent a snapshottable directory. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1608631 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/07/14 5:08 PM",
      "commitName": "76a621ffd2d66bf012a554f4400091a92a5b473e",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "23/06/14 11:56 PM",
      "commitNameOld": "08986fdbed5a15bcdc57d142922911759b97e9d1",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 13.72,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,136 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n             (Rename.OVERWRITE);\n \n     final String error;\n     final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     validateRenameSource(src, srcIIP);\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     validateRenameDestination(src, dst, srcInode);\n \n     INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n-    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n-        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n+    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n \n       // add src as dst to complete rename\n       if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                 dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                 true).get(Quota.NAMESPACE);\n             getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                 removedINodes);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n \n         tx.updateQuotasInSourceTree();\n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         tx.restoreSource();\n       }\n \n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n            (Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    validateRenameDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectory\u003e snapshottableDirs \u003d new ArrayList\u003cINodeDirectory\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                true).get(Quota.NAMESPACE);\n            getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                removedINodes);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "c38665282884122d3c82b6f68376cce036aee748": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6516. List of Encryption Zones should be based on inodes (clamb)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1607770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/07/14 5:24 PM",
      "commitName": "c38665282884122d3c82b6f68376cce036aee748",
      "commitAuthor": "Charles Lamb",
      "commitDateOld": "02/07/14 5:58 PM",
      "commitNameOld": "2a3bccddd939ee0d6941aa2d22edc67dea85fe35",
      "commitAuthorOld": "Charles Lamb",
      "daysBetweenCommits": 0.98,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,283 +1,283 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     final String error;\n     final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n-    checkEncryptionZoneMoveValidity(src, dst);\n+    checkEncryptionZoneMoveValidity(srcIIP, dstIIP, src);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(Snapshot.CURRENT_STATE_ID);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n         toDst \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                 dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                 true).get(Quota.NAMESPACE);\n             getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                 removedINodes);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           srcChild \u003d withCount.getReferredINode();\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           srcChild \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (srcParent.isWithSnapshot()) {\n           srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    final String error;\n    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    checkEncryptionZoneMoveValidity(srcIIP, dstIIP, src);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(Snapshot.CURRENT_STATE_ID);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        toDst \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                true).get(Quota.NAMESPACE);\n            getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                removedINodes);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          srcChild \u003d withCount.getReferredINode();\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          srcChild \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (srcParent.isWithSnapshot()) {\n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "31617733aca2025cff1ffb841a533a5b1de016a5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6389. Rename restrictions for encryption zones. (clamb)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1606253 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/06/14 2:45 PM",
      "commitName": "31617733aca2025cff1ffb841a533a5b1de016a5",
      "commitAuthor": "Charles Lamb",
      "commitDateOld": "27/06/14 1:43 PM",
      "commitNameOld": "2efea952139b30dd1c881eed0b443ffa72be6dce",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,282 +1,283 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     final String error;\n     final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n+    checkEncryptionZoneMoveValidity(src, dst);\n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(Snapshot.CURRENT_STATE_ID);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n         toDst \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                 dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                 true).get(Quota.NAMESPACE);\n             getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                 removedINodes);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           srcChild \u003d withCount.getReferredINode();\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           srcChild \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (srcParent.isWithSnapshot()) {\n           srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    final String error;\n    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    checkEncryptionZoneMoveValidity(src, dst);\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(Snapshot.CURRENT_STATE_ID);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        toDst \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                true).get(Quota.NAMESPACE);\n            getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                removedINodes);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          srcChild \u003d withCount.getReferredINode();\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          srcChild \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (srcParent.isWithSnapshot()) {\n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "08986fdbed5a15bcdc57d142922911759b97e9d1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6562. Refactor rename() in FSDirectory. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605016 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/06/14 11:56 PM",
      "commitName": "08986fdbed5a15bcdc57d142922911759b97e9d1",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "22/06/14 12:39 AM",
      "commitNameOld": "1e89eba47d0f291b33fc26f9406231fc70b63a87",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.97,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,282 +1,137 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n-    boolean overwrite \u003d false;\n-    if (null !\u003d options) {\n-      for (Rename option : options) {\n-        if (option \u003d\u003d Rename.OVERWRITE) {\n-          overwrite \u003d true;\n-        }\n-      }\n-    }\n+    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n+            (Rename.OVERWRITE);\n+\n     final String error;\n     final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n-    // validate source\n-    if (srcInode \u003d\u003d null) {\n-      error \u003d \"rename source \" + src + \" is not found.\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n-      throw new FileNotFoundException(error);\n-    }\n-    if (srcIIP.getINodes().length \u003d\u003d 1) {\n-      error \u003d \"rename source cannot be the root\";\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n-      throw new IOException(error);\n-    }\n-    // srcInode and its subtree cannot contain snapshottable directories with\n-    // snapshots\n-    checkSnapshot(srcInode, null);\n-    \n+    validateRenameSource(src, srcIIP);\n+\n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n-    if (srcInode.isSymlink() \u0026\u0026 \n-        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n-      throw new FileAlreadyExistsException(\n-          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n-    }\n-    // dst cannot be a directory or a file under src\n-    if (dst.startsWith(src) \u0026\u0026 \n-        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n-      error \u003d \"Rename destination \" + dst\n-          + \" is a directory or file under source \" + src;\n-      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-          + error);\n-      throw new IOException(error);\n-    }\n+    validateRenameDestination(src, dst, srcInode);\n+\n     INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n-      // It\u0027s OK to rename a file to a symlink and vice versa\n-      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n-        error \u003d \"Source \" + src + \" and destination \" + dst\n-            + \" must both be directories\";\n-        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-            + error);\n-        throw new IOException(error);\n-      }\n-      if (!overwrite) { // If destination exists, overwrite flag must be true\n-        error \u003d \"rename destination \" + dst + \" already exists\";\n-        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-            + error);\n-        throw new FileAlreadyExistsException(error);\n-      }\n-      if (dstInode.isDirectory()) {\n-        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n-            .getChildrenList(Snapshot.CURRENT_STATE_ID);\n-        if (!children.isEmpty()) {\n-          error \u003d \"rename destination directory is not empty: \" + dst;\n-          NameNode.stateChangeLog.warn(\n-              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n-          throw new IOException(error);\n-        }\n-      }\n+      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n-    INode srcChild \u003d srcIIP.getLastINode();\n-    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n-    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n-        srcIIP.getLatestSnapshotId());\n-    final boolean srcChildIsReference \u003d srcChild.isReference();\n-    \n-    // Record the snapshot on srcChild. After the rename, before any new \n-    // snapshot is taken on the dst tree, changes will be recorded in the latest\n-    // snapshot of the src tree.\n-    if (isSrcInSnapshot) {\n-      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n-      srcIIP.setLastINode(srcChild);\n-    }\n-    \n-    // check srcChild for reference\n-    final INodeReference.WithCount withCount;\n-    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n-        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n-    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n-    if (isSrcInSnapshot) {\n-      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n-          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n-      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n-      srcChild \u003d withName;\n-      srcIIP.setLastINode(srcChild);\n-      // get the counts before rename\n-      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n-    } else if (srcChildIsReference) {\n-      // srcChild is reference but srcChild is not in latest snapshot\n-      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n-    } else {\n-      withCount \u003d null;\n-    }\n-    \n+    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n+\n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n-    if (dstParent.getParent() \u003d\u003d null) {\n-      // src and dst file/dir are in the same directory, and the dstParent has\n-      // been replaced when we removed the src. Refresh the dstIIP and\n-      // dstParent.\n-      dstIIP \u003d getINodesInPath4Write(dst, false);\n-    }\n-    \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n-      \n-      srcChild \u003d srcIIP.getLastINode();\n-\n-      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n-      final INode toDst;\n-      if (withCount \u003d\u003d null) {\n-        srcChild.setLocalName(dstChildName);\n-        toDst \u003d srcChild;\n-      } else {\n-        withCount.getReferredINode().setLocalName(dstChildName);\n-        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n-        toDst \u003d new INodeReference.DstReference(\n-            dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n-      }\n \n       // add src as dst to complete rename\n-      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n+      if (tx.addSourceToDestination()) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n-        final INode srcParent \u003d srcIIP.getINode(-2);\n-        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n-        dstParent \u003d dstIIP.getINode(-2);\n-        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n-        // update moved lease with new filename\n-        getFSNamesystem().unprotectedChangeLease(src, dst);\n+        tx.updateMtimeAndLease(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           if (removedNum \u003e 0) {\n             BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n             List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n             filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                 dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                 true).get(Quota.NAMESPACE);\n             getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                 removedINodes);\n           }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n-        \n-        // update the quota usage in src tree\n-        if (isSrcInSnapshot) {\n-          // get the counts after rename\n-          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n-              Quota.Counts.newInstance(), false);\n-          newSrcCounts.subtract(oldSrcCounts);\n-          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n-              newSrcCounts.get(Quota.DISKSPACE), false);\n-        }\n-        \n+\n+        tx.updateQuotasInSourceTree();\n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n-        // Rename failed - restore src\n-        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n-        final INode oldSrcChild \u003d srcChild;\n-        // put it back\n-        if (withCount \u003d\u003d null) {\n-          srcChild.setLocalName(srcChildName);\n-        } else if (!srcChildIsReference) { // src must be in snapshot\n-          // the withCount node will no longer be used thus no need to update\n-          // its reference number here\n-          srcChild \u003d withCount.getReferredINode();\n-          srcChild.setLocalName(srcChildName);\n-        } else {\n-          withCount.removeReference(oldSrcChild.asReference());\n-          srcChild \u003d new INodeReference.DstReference(\n-              srcParent, withCount, srcRefDstSnapshot);\n-          withCount.getReferredINode().setLocalName(srcChildName);\n-        }\n-        \n-        if (srcParent.isWithSnapshot()) {\n-          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n-        } else {\n-          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n-          // the srcChild back\n-          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n-        }\n+        tx.restoreSource();\n       }\n+\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d options !\u003d null \u0026\u0026 Arrays.asList(options).contains\n            (Rename.OVERWRITE);\n\n    final String error;\n    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    validateRenameSource(src, srcIIP);\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    validateRenameDestination(src, dst, srcInode);\n\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      validateRenameOverwrite(src, dst, overwrite, srcInode, dstInode);\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    RenameOperation tx \u003d new RenameOperation(src, dst, srcIIP, dstIIP);\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n\n      // add src as dst to complete rename\n      if (tx.addSourceToDestination()) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        tx.updateMtimeAndLease(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                true).get(Quota.NAMESPACE);\n            getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                removedINodes);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n\n        tx.updateQuotasInSourceTree();\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        tx.restoreSource();\n      }\n\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "4cf94aaf809c77b3b7dc925faa39a72d53e4246e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6551. Rename with OVERWRITE option may throw NPE when the target file/directory is a reference INode. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1603612 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/06/14 12:57 PM",
      "commitName": "4cf94aaf809c77b3b7dc925faa39a72d53e4246e",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "13/06/14 11:04 AM",
      "commitNameOld": "02f3ff33876752f0cce0d91eef62a4d564e11072",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 5.08,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,279 +1,282 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     final String error;\n     final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(Snapshot.CURRENT_STATE_ID);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n+    long removedNum \u003d 0;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        if (removeLastINode(dstIIP) !\u003d -1) {\n+        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n         toDst \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n-          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-          List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n-          filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n-              dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes, true)\n-              .get(Quota.NAMESPACE);\n-          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n-              removedINodes);\n+          if (removedNum \u003e 0) {\n+            BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n+            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n+            filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n+                dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n+                true).get(Quota.NAMESPACE);\n+            getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n+                removedINodes);\n+          }\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           srcChild \u003d withCount.getReferredINode();\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           srcChild \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (srcParent.isWithSnapshot()) {\n           srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    final String error;\n    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(Snapshot.CURRENT_STATE_ID);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    long removedNum \u003d 0;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if ((removedNum \u003d removeLastINode(dstIIP)) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        toDst \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          if (removedNum \u003e 0) {\n            BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n            List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n            filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n                dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes,\n                true).get(Quota.NAMESPACE);\n            getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n                removedINodes);\n          }\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          srcChild \u003d withCount.getReferredINode();\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          srcChild \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (srcParent.isWithSnapshot()) {\n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "ae9109b911b3d9e2d6ca50b400379fc31deeb0cf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6328. Clean up dead code in FSDirectory. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593755 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/14 10:06 PM",
      "commitName": "ae9109b911b3d9e2d6ca50b400379fc31deeb0cf",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "30/04/14 10:44 AM",
      "commitNameOld": "0689363343a281a6f7f6f395227668bddc2663eb",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 10.47,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,282 +1,279 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n-    String error \u003d null;\n+    final String error;\n     final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(Snapshot.CURRENT_STATE_ID);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n-        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n+        toDst \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n-        toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n               dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes, true)\n               .get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n               removedINodes);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n-          final INode originalChild \u003d withCount.getReferredINode();\n-          srcChild \u003d originalChild;\n+          srcChild \u003d withCount.getReferredINode();\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n-          final INodeReference originalRef \u003d new INodeReference.DstReference(\n+          srcChild \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n-          srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (srcParent.isWithSnapshot()) {\n           srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    final String error;\n    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(Snapshot.CURRENT_STATE_ID);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        toDst \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n              dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes, true)\n              .get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n              removedINodes);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          srcChild \u003d withCount.getReferredINode();\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          srcChild \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (srcParent.isWithSnapshot()) {\n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "0689363343a281a6f7f6f395227668bddc2663eb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6304. Consolidate the logic of path resolution in FSDirectory. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1591411 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/04/14 10:44 AM",
      "commitName": "0689363343a281a6f7f6f395227668bddc2663eb",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "24/04/14 7:05 PM",
      "commitNameOld": "10a037cccb00c9f791da394bf2dc05985fb80612",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,282 +1,282 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n-    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n+    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n-    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n+    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(Snapshot.CURRENT_STATE_ID);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n-      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n+      dstIIP \u003d getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n         toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n               dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes, true)\n               .get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n               removedINodes);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (srcParent.isWithSnapshot()) {\n           srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(Snapshot.CURRENT_STATE_ID);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n              dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes, true)\n              .get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n              removedINodes);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (srcParent.isWithSnapshot()) {\n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "2b03ae94216a76a477f3d6250d076ebbf61e998a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6099. HDFS file system limits not enforced on renames. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1579122 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/03/14 8:46 PM",
      "commitName": "2b03ae94216a76a477f3d6250d076ebbf61e998a",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "13/03/14 9:52 PM",
      "commitNameOld": "d37c31a2dbb85f6b58baae27db106fabe629a3cd",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.95,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,281 +1,282 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(Snapshot.CURRENT_STATE_ID);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n+    verifyFsLimitsForRename(srcIIP, dstIIP);\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n         toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n               dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes, true)\n               .get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n               removedINodes);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (srcParent.isWithSnapshot()) {\n           srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n               dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(Snapshot.CURRENT_STATE_ID);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyFsLimitsForRename(srcIIP, dstIIP);\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n              dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes, true)\n              .get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n              removedINodes);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (srcParent.isWithSnapshot()) {\n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5715. Use Snapshot ID to indicate the corresponding Snapshot for a FileDiff/DirectoryDiff. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/14 12:52 PM",
      "commitName": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "14/12/13 2:13 AM",
      "commitNameOld": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 24.44,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,284 +1,281 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n-            .getChildrenList(null);\n+            .getChildrenList(Snapshot.CURRENT_STATE_ID);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n-        srcIIP.getLatestSnapshot());\n+        srcIIP.getLatestSnapshotId());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n-      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n+      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n-        .getDstSnapshotId() : Snapshot.INVALID_ID;\n+        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n-          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n+          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n-      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n-          Snapshot.INVALID_ID);\n+      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n-        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n+        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n-            dstIIP.getINode(-2).asDirectory(), withCount,\n-            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n+            dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n         toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n-        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n+        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n         dstParent \u003d dstIIP.getINode(-2);\n-        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n+        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n-          filesDeleted \u003d removedDst.cleanSubtree(null,\n-              dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes, true)\n+          filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n+              dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes, true)\n               .get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n               removedINodes);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n-              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n+              Quota.Counts.newInstance(), false);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (srcParent.isWithSnapshot()) {\n-          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild,\n-              srcIIP.getLatestSnapshot());\n+          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n           dstParent.asDirectory().undoRename4DstParent(removedDst,\n-              dstIIP.getLatestSnapshot());\n+              dstIIP.getLatestSnapshotId());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(Snapshot.CURRENT_STATE_ID);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshotId());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshotId());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.CURRENT_STATE_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshotId()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        int dstSnapshotId \u003d dstIIP.getLatestSnapshotId();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount, dstSnapshotId);\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshotId());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshotId());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          filesDeleted \u003d removedDst.cleanSubtree(Snapshot.CURRENT_STATE_ID,\n              dstIIP.getLatestSnapshotId(), collectedBlocks, removedINodes, true)\n              .get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n              removedINodes);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (srcParent.isWithSnapshot()) {\n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild);\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshotId());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "44a6560b5da3f79d2299579a36e7a2a60a91f823": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5632. Flatten INodeDirectory hierarchy: Replace INodeDirectoryWithSnapshot with DirectoryWithSnapshotFeature.  Contributed by jing9 \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550917 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/12/13 2:13 AM",
      "commitName": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "02/12/13 9:41 AM",
      "commitNameOld": "18159be495f96bde4bd4fa2cacb14aafb87e87bc",
      "commitAuthorOld": "",
      "daysBetweenCommits": 11.69,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,287 +1,284 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n-      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n-          inodeMap);\n+      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n           Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n-        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n-            inodeMap);\n+        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent \u003d dstIIP.getINode(-2);\n-        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n-            inodeMap);\n+        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           filesDeleted \u003d removedDst.cleanSubtree(null,\n               dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes, true)\n               .get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n               removedINodes);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n-        if (srcParent instanceof INodeDirectoryWithSnapshot) {\n-          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n-              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n+        if (srcParent.isWithSnapshot()) {\n+          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild,\n+              srcIIP.getLatestSnapshot());\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n-        if (dstParent instanceof INodeDirectoryWithSnapshot) {\n-          ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n-              removedDst, dstIIP.getLatestSnapshot());\n+        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n+          dstParent.asDirectory().undoRename4DstParent(removedDst,\n+              dstIIP.getLatestSnapshot());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes, true)\n              .get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n              removedINodes);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (srcParent.isWithSnapshot()) {\n          srcParent.undoRename4ScrParent(oldSrcChild.asReference(), srcChild,\n              srcIIP.getLatestSnapshot());\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent.isDirectory() \u0026\u0026 dstParent.asDirectory().isWithSnapshot()) {\n          dstParent.asDirectory().undoRename4DstParent(removedDst,\n              dstIIP.getLatestSnapshot());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "6431192c0ee00ecfe578b270889b0c7a0a9cb8c8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4879. Add BlockedArrayList collection to avoid CMS full GCs (Contributed by Todd Lipcon)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1520667 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/13 12:05 PM",
      "commitName": "6431192c0ee00ecfe578b270889b0c7a0a9cb8c8",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "17/08/13 2:16 PM",
      "commitNameOld": "214d4377fc151297c85b09273dfe8fdddae40d3d",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 19.91,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,287 +1,287 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n           inodeMap);\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n           Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n             inodeMap);\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n             inodeMap);\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-          List\u003cINode\u003e removedINodes \u003d new ArrayList\u003cINode\u003e();\n+          List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           filesDeleted \u003d removedDst.cleanSubtree(null,\n               dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes, true)\n               .get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n               removedINodes);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (srcParent instanceof INodeDirectoryWithSnapshot) {\n           ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n               oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent instanceof INodeDirectoryWithSnapshot) {\n           ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n               removedDst, dstIIP.getLatestSnapshot());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n          inodeMap);\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n            inodeMap);\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n            inodeMap);\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e removedINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes, true)\n              .get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n              removedINodes);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (srcParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n              removedDst, dstIIP.getLatestSnapshot());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "d46e1608626c64400d2b6c7693a4c035783c55b4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4877. Snapshot: fix the scenario where a directory is renamed under its prior descendant. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490421 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/13 1:15 PM",
      "commitName": "d46e1608626c64400d2b6c7693a4c035783c55b4",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "30/05/13 10:26 AM",
      "commitNameOld": "bf99961d67bf59dad6a861655407f9e0a5f21aa5",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 7.12,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,287 +1,287 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n           inodeMap);\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n           Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n             inodeMap);\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n             inodeMap);\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e removedINodes \u003d new ArrayList\u003cINode\u003e();\n           filesDeleted \u003d removedDst.cleanSubtree(null,\n-              dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes).get(\n-              Quota.NAMESPACE);\n+              dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes, true)\n+              .get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n               removedINodes);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n-              newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n+              newSrcCounts.get(Quota.DISKSPACE), false);\n         }\n         \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n           srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n           withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (srcParent instanceof INodeDirectoryWithSnapshot) {\n           ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n               oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent instanceof INodeDirectoryWithSnapshot) {\n           ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n               removedDst, dstIIP.getLatestSnapshot());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n          inodeMap);\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n            inodeMap);\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n            inodeMap);\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e removedINodes \u003d new ArrayList\u003cINode\u003e();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes, true)\n              .get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n              removedINodes);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (srcParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n              removedDst, dstIIP.getLatestSnapshot());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "bf99961d67bf59dad6a861655407f9e0a5f21aa5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4848. copyFromLocal and renaming a file to .snapshot should output that .snapshot is a reserved name. Contributed by Jing Zhao\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1487942 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/13 10:26 AM",
      "commitName": "bf99961d67bf59dad6a861655407f9e0a5f21aa5",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "29/05/13 2:25 PM",
      "commitNameOld": "719034c12c1105e3ab2e033bce30798750e38e2d",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 0.83,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,285 +1,287 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n           inodeMap);\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n           Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n             inodeMap);\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n             inodeMap);\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e removedINodes \u003d new ArrayList\u003cINode\u003e();\n           filesDeleted \u003d removedDst.cleanSubtree(null,\n               dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes).get(\n               Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n               removedINodes);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n         }\n         \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n+          srcChild.setLocalName(srcChildName);\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n+          withCount.getReferredINode().setLocalName(srcChildName);\n         }\n         \n         if (srcParent instanceof INodeDirectoryWithSnapshot) {\n           ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n               oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent instanceof INodeDirectoryWithSnapshot) {\n           ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n               removedDst, dstIIP.getLatestSnapshot());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n          inodeMap);\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n            inodeMap);\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n            inodeMap);\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e removedINodes \u003d new ArrayList\u003cINode\u003e();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes).get(\n              Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n              removedINodes);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n          srcChild.setLocalName(srcChildName);\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n          withCount.getReferredINode().setLocalName(srcChildName);\n        }\n        \n        if (srcParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n              removedDst, dstIIP.getLatestSnapshot());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "3a3e0f573129c8308332d4b301a9319ee579d85a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4760. Update inodeMap after node replacement.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1477827 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/04/13 2:05 PM",
      "commitName": "3a3e0f573129c8308332d4b301a9319ee579d85a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "26/04/13 5:05 PM",
      "commitNameOld": "5276f4e04dbeabe4dbcddafaa1cd386b912f6345",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.87,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,282 +1,285 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n-      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n+      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n+          inodeMap);\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n       // get the counts before rename\n       withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n           Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n-        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n+        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n+            inodeMap);\n         dstParent \u003d dstIIP.getINode(-2);\n-        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n+        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n+            inodeMap);\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e removedINodes \u003d new ArrayList\u003cINode\u003e();\n           filesDeleted \u003d removedDst.cleanSubtree(null,\n               dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes).get(\n               Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n               removedINodes);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         \n         // update the quota usage in src tree\n         if (isSrcInSnapshot) {\n           // get the counts after rename\n           Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n               Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n           newSrcCounts.subtract(oldSrcCounts);\n           srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n               newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n         }\n         \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           // the withCount node will no longer be used thus no need to update\n           // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n         } else {\n           withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           srcChild \u003d originalRef;\n         }\n         \n         if (srcParent instanceof INodeDirectoryWithSnapshot) {\n           ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n               oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent instanceof INodeDirectoryWithSnapshot) {\n           ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n               removedDst, dstIIP.getLatestSnapshot());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n         if (removedDst.isReference()) {\n           final INodeReference removedDstRef \u003d removedDst.asReference();\n           final INodeReference.WithCount wc \u003d \n               (WithCount) removedDstRef.getReferredINode().asReference();\n           wc.addReference(removedDstRef);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot(),\n          inodeMap);\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot(),\n            inodeMap);\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot(),\n            inodeMap);\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e removedINodes \u003d new ArrayList\u003cINode\u003e();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes).get(\n              Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n              removedINodes);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n        }\n        \n        if (srcParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n              removedDst, dstIIP.getLatestSnapshot());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "0fa5cad0b27780c27a284c23101b1099d4886506": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4686. Update quota computation for rename and INodeReference.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1471647 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/04/13 1:31 PM",
      "commitName": "0fa5cad0b27780c27a284c23101b1099d4886506",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "22/04/13 5:00 PM",
      "commitNameOld": "92e0416ced279a910616985bf11fa3f8b1b1de9b",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 1.85,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,261 +1,282 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n+    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n-          .replaceChild4ReferenceWithName(srcChild); \n+          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n+      // get the counts before rename\n+      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n+          Snapshot.INVALID_ID);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n-        withCount.setParentReference(ref);\n-        withCount.incrementReferenceCount();\n         toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e removedINodes \u003d new ArrayList\u003cINode\u003e();\n           filesDeleted \u003d removedDst.cleanSubtree(null,\n               dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes).get(\n               Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n               removedINodes);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n+        \n+        // update the quota usage in src tree\n+        if (isSrcInSnapshot) {\n+          // get the counts after rename\n+          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n+              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n+          newSrcCounts.subtract(oldSrcCounts);\n+          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n+              newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n+        }\n+        \n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n+          // the withCount node will no longer be used thus no need to update\n+          // its reference number here\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n         } else {\n+          withCount.removeReference(oldSrcChild.asReference());\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n-          withCount.setParentReference(originalRef);\n           srcChild \u003d originalRef;\n         }\n         \n         if (srcParent instanceof INodeDirectoryWithSnapshot) {\n           ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n               oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent instanceof INodeDirectoryWithSnapshot) {\n           ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n               removedDst, dstIIP.getLatestSnapshot());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n+        if (removedDst.isReference()) {\n+          final INodeReference removedDstRef \u003d removedDst.asReference();\n+          final INodeReference.WithCount wc \u003d \n+              (WithCount) removedDstRef.getReferredINode().asReference();\n+          wc.addReference(removedDstRef);\n+        }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    Quota.Counts oldSrcCounts \u003d Quota.Counts.newInstance();    \n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild, srcIIP.getLatestSnapshot()); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n      // get the counts before rename\n      withCount.getReferredINode().computeQuotaUsage(oldSrcCounts, true,\n          Snapshot.INVALID_ID);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e removedINodes \u003d new ArrayList\u003cINode\u003e();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes).get(\n              Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n              removedINodes);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        \n        // update the quota usage in src tree\n        if (isSrcInSnapshot) {\n          // get the counts after rename\n          Quota.Counts newSrcCounts \u003d srcChild.computeQuotaUsage(\n              Quota.Counts.newInstance(), false, Snapshot.INVALID_ID);\n          newSrcCounts.subtract(oldSrcCounts);\n          srcParent.addSpaceConsumed(newSrcCounts.get(Quota.NAMESPACE),\n              newSrcCounts.get(Quota.DISKSPACE), false, Snapshot.INVALID_ID);\n        }\n        \n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          // the withCount node will no longer be used thus no need to update\n          // its reference number here\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n        } else {\n          withCount.removeReference(oldSrcChild.asReference());\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          srcChild \u003d originalRef;\n        }\n        \n        if (srcParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n              removedDst, dstIIP.getLatestSnapshot());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n        if (removedDst.isReference()) {\n          final INodeReference removedDstRef \u003d removedDst.asReference();\n          final INodeReference.WithCount wc \u003d \n              (WithCount) removedDstRef.getReferredINode().asReference();\n          wc.addReference(removedDstRef);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "92e0416ced279a910616985bf11fa3f8b1b1de9b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4727. Update inodeMap after deleting files/directories/snapshots.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1470756 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/04/13 5:00 PM",
      "commitName": "92e0416ced279a910616985bf11fa3f8b1b1de9b",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "20/04/13 1:22 PM",
      "commitNameOld": "27b3f84fe58530caa2eac18e924da7de4c859578",
      "commitAuthorOld": "",
      "daysBetweenCommits": 2.15,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,258 +1,261 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n         .getDstSnapshotId() : Snapshot.INVALID_ID;\n     if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild); \n       withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n     } else if (srcChildIsReference) {\n       // srcChild is reference but srcChild is not in latest snapshot\n       withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         withCount.setParentReference(ref);\n         withCount.incrementReferenceCount();\n         toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n+          List\u003cINode\u003e removedINodes \u003d new ArrayList\u003cINode\u003e();\n           filesDeleted \u003d removedDst.cleanSubtree(null,\n-              dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n-          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n+              dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes).get(\n+              Quota.NAMESPACE);\n+          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n+              removedINodes);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n         final INode oldSrcChild \u003d srcChild;\n         // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcChild \u003d originalChild;\n         } else {\n           final INodeReference originalRef \u003d new INodeReference.DstReference(\n               srcParent, withCount, srcRefDstSnapshot);\n           withCount.setParentReference(originalRef);\n           srcChild \u003d originalRef;\n         }\n         \n         if (srcParent instanceof INodeDirectoryWithSnapshot) {\n           ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n               oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n         } else {\n           // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n           // the srcChild back\n           addLastINodeNoQuotaCheck(srcIIP, srcChild);\n         }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         if (dstParent instanceof INodeDirectoryWithSnapshot) {\n           ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n               removedDst, dstIIP.getLatestSnapshot());\n         } else {\n           addLastINodeNoQuotaCheck(dstIIP, removedDst);\n         }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        withCount.setParentReference(ref);\n        withCount.incrementReferenceCount();\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e removedINodes \u003d new ArrayList\u003cINode\u003e();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks, removedINodes).get(\n              Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks,\n              removedINodes);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n        } else {\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          withCount.setParentReference(originalRef);\n          srcChild \u003d originalRef;\n        }\n        \n        if (srcParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n              removedDst, dstIIP.getLatestSnapshot());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "6bda1f20ad396918edde211f709f5819a361b51e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4700. Fix the undo section of rename with snapshots.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1468632 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/04/13 3:03 PM",
      "commitName": "6bda1f20ad396918edde211f709f5819a361b51e",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "15/04/13 2:42 PM",
      "commitNameOld": "d13f6ebe20aaf5ec31c4298db3e2e761f72e906e",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 1.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,236 +1,258 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     // srcInode and its subtree cannot contain snapshottable directories with\n     // snapshots\n     checkSnapshot(srcInode, null);\n     \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n     // Record the snapshot on srcChild. After the rename, before any new \n     // snapshot is taken on the dst tree, changes will be recorded in the latest\n     // snapshot of the src tree.\n     if (isSrcInSnapshot) {\n       srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n       srcIIP.setLastINode(srcChild);\n     }\n     \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n-    if (srcChildIsReference || isSrcInSnapshot) {\n+    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n+        .getDstSnapshotId() : Snapshot.INVALID_ID;\n+    if (isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild); \n-      withCount \u003d (INodeReference.WithCount)withName.getReferredINode();\n+      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n+    } else if (srcChildIsReference) {\n+      // srcChild is reference but srcChild is not in latest snapshot\n+      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n     if (dstParent.getParent() \u003d\u003d null) {\n       // src and dst file/dir are in the same directory, and the dstParent has\n       // been replaced when we removed the src. Refresh the dstIIP and\n       // dstParent.\n       dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     }\n     \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n         Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n         final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n             dstIIP.getINode(-2).asDirectory(), withCount,\n             dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         withCount.setParentReference(ref);\n         withCount.incrementReferenceCount();\n         toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d removedDst.cleanSubtree(null,\n               dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n-        srcChild \u003d srcIIP.getLastINode();\n+        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n+        final INode oldSrcChild \u003d srcChild;\n+        // put it back\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n-          final INodeDirectoryWithSnapshot srcParent\n-              \u003d (INodeDirectoryWithSnapshot)srcIIP.getINode(-2).asDirectory();\n           final INode originalChild \u003d withCount.getReferredINode();\n-          srcParent.replaceRemovedChild(srcChild, originalChild);\n           srcChild \u003d originalChild;\n+        } else {\n+          final INodeReference originalRef \u003d new INodeReference.DstReference(\n+              srcParent, withCount, srcRefDstSnapshot);\n+          withCount.setParentReference(originalRef);\n+          srcChild \u003d originalRef;\n         }\n-        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n+        \n+        if (srcParent instanceof INodeDirectoryWithSnapshot) {\n+          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n+              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n+        } else {\n+          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n+          // the srcChild back\n+          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n+        }\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n-        addLastINodeNoQuotaCheck(dstIIP, removedDst);\n+        if (dstParent instanceof INodeDirectoryWithSnapshot) {\n+          ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n+              removedDst, dstIIP.getLatestSnapshot());\n+        } else {\n+          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n+        }\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    int srcRefDstSnapshot \u003d srcChildIsReference ? srcChild.asReference()\n        .getDstSnapshotId() : Snapshot.INVALID_ID;\n    if (isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild); \n      withCount \u003d (INodeReference.WithCount) withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n    } else if (srcChildIsReference) {\n      // srcChild is reference but srcChild is not in latest snapshot\n      withCount \u003d (WithCount) srcChild.asReference().getReferredINode();\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        withCount.setParentReference(ref);\n        withCount.incrementReferenceCount();\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        final INodeDirectory srcParent \u003d srcIIP.getINode(-2).asDirectory();\n        final INode oldSrcChild \u003d srcChild;\n        // put it back\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcChild \u003d originalChild;\n        } else {\n          final INodeReference originalRef \u003d new INodeReference.DstReference(\n              srcParent, withCount, srcRefDstSnapshot);\n          withCount.setParentReference(originalRef);\n          srcChild \u003d originalRef;\n        }\n        \n        if (srcParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) srcParent).undoRename4ScrParent(\n              oldSrcChild.asReference(), srcChild, srcIIP.getLatestSnapshot());\n        } else {\n          // srcParent is not an INodeDirectoryWithSnapshot, we only need to add\n          // the srcChild back\n          addLastINodeNoQuotaCheck(srcIIP, srcChild);\n        }\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        if (dstParent instanceof INodeDirectoryWithSnapshot) {\n          ((INodeDirectoryWithSnapshot) dstParent).undoRename4DstParent(\n              removedDst, dstIIP.getLatestSnapshot());\n        } else {\n          addLastINodeNoQuotaCheck(dstIIP, removedDst);\n        }\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "9c6a7bebe23ffb85d7fd95607f3b7bb4fe82dbe4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4675. Fix rename across snapshottable directories.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1467540 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/04/13 7:48 PM",
      "commitName": "9c6a7bebe23ffb85d7fd95607f3b7bb4fe82dbe4",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "10/04/13 1:17 PM",
      "commitNameOld": "3209d4a3c4d4c227ca50bbcd1ab3e939beceec35",
      "commitAuthorOld": "",
      "daysBetweenCommits": 2.27,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,224 +1,236 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n-\n+    // srcInode and its subtree cannot contain snapshottable directories with\n+    // snapshots\n+    checkSnapshot(srcInode, null);\n+    \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n-    final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n+    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n-    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n-        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n+    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n+        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n-      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n-      if (snapshotNode !\u003d null) {\n-        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n-            + \" cannot be deleted for renaming since \"\n-            + snapshotNode.getFullPathName()\n-            + \" is snapshottable and already has snapshots\";\n-        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-            + error);\n-        throw new IOException(error);\n-      }\n+      checkSnapshot(dstInode, snapshottableDirs);\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n     final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n         srcIIP.getLatestSnapshot());\n     final boolean srcChildIsReference \u003d srcChild.isReference();\n     \n+    // Record the snapshot on srcChild. After the rename, before any new \n+    // snapshot is taken on the dst tree, changes will be recorded in the latest\n+    // snapshot of the src tree.\n+    if (isSrcInSnapshot) {\n+      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n+      srcIIP.setLastINode(srcChild);\n+    }\n+    \n     // check srcChild for reference\n     final INodeReference.WithCount withCount;\n     if (srcChildIsReference || isSrcInSnapshot) {\n       final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n           .replaceChild4ReferenceWithName(srcChild); \n       withCount \u003d (INodeReference.WithCount)withName.getReferredINode();\n       srcChild \u003d withName;\n       srcIIP.setLastINode(srcChild);\n     } else {\n       withCount \u003d null;\n     }\n     \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     \n+    if (dstParent.getParent() \u003d\u003d null) {\n+      // src and dst file/dir are in the same directory, and the dstParent has\n+      // been replaced when we removed the src. Refresh the dstIIP and\n+      // dstParent.\n+      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n+    }\n+    \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       \n       srcChild \u003d srcIIP.getLastINode();\n \n       final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n       final INode toDst;\n       if (withCount \u003d\u003d null) {\n         srcChild.setLocalName(dstChildName);\n         toDst \u003d srcChild;\n       } else {\n         withCount.getReferredINode().setLocalName(dstChildName);\n-        final INodeReference ref \u003d new INodeReference(dstIIP.getINode(-2), withCount);\n+        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n+        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n+            dstIIP.getINode(-2).asDirectory(), withCount,\n+            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n         withCount.setParentReference(ref);\n         withCount.incrementReferenceCount();\n         toDst \u003d ref;\n       }\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d removedDst.cleanSubtree(null,\n               dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         srcChild \u003d srcIIP.getLastINode();\n         if (withCount \u003d\u003d null) {\n           srcChild.setLocalName(srcChildName);\n         } else if (!srcChildIsReference) { // src must be in snapshot\n           final INodeDirectoryWithSnapshot srcParent\n               \u003d (INodeDirectoryWithSnapshot)srcIIP.getINode(-2).asDirectory();\n           final INode originalChild \u003d withCount.getReferredINode();\n           srcParent.replaceRemovedChild(srcChild, originalChild);\n           srcChild \u003d originalChild;\n         }\n         addLastINodeNoQuotaCheck(srcIIP, srcChild);\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         addLastINodeNoQuotaCheck(dstIIP, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    // srcInode and its subtree cannot contain snapshottable directories with\n    // snapshots\n    checkSnapshot(srcInode, null);\n    \n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      checkSnapshot(dstInode, snapshottableDirs);\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // Record the snapshot on srcChild. After the rename, before any new \n    // snapshot is taken on the dst tree, changes will be recorded in the latest\n    // snapshot of the src tree.\n    if (isSrcInSnapshot) {\n      srcChild \u003d srcChild.recordModification(srcIIP.getLatestSnapshot());\n      srcIIP.setLastINode(srcChild);\n    }\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    if (srcChildIsReference || isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild); \n      withCount \u003d (INodeReference.WithCount)withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    if (dstParent.getParent() \u003d\u003d null) {\n      // src and dst file/dir are in the same directory, and the dstParent has\n      // been replaced when we removed the src. Refresh the dstIIP and\n      // dstParent.\n      dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        Snapshot dstSnapshot \u003d dstIIP.getLatestSnapshot();\n        final INodeReference.DstReference ref \u003d new INodeReference.DstReference(\n            dstIIP.getINode(-2).asDirectory(), withCount,\n            dstSnapshot \u003d\u003d null ? Snapshot.INVALID_ID : dstSnapshot.getId());\n        withCount.setParentReference(ref);\n        withCount.incrementReferenceCount();\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        srcChild \u003d srcIIP.getLastINode();\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          final INodeDirectoryWithSnapshot srcParent\n              \u003d (INodeDirectoryWithSnapshot)srcIIP.getINode(-2).asDirectory();\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcParent.replaceRemovedChild(srcChild, originalChild);\n          srcChild \u003d originalChild;\n        }\n        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        addLastINodeNoQuotaCheck(dstIIP, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "ca848beb533790ae8abb6498f5d4676594fbae4c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4647. Rename should call setLocalName after an inode is removed from snapshots.  Contributed by Arpit Agarwal\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1464795 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/04/13 4:52 PM",
      "commitName": "ca848beb533790ae8abb6498f5d4676594fbae4c",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "01/04/13 4:24 PM",
      "commitNameOld": "1096917649fd951be633e5619518764f23cca645",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,192 +1,224 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n+    INode srcChild \u003d srcIIP.getLastINode();\n+    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n+    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n+        srcIIP.getLatestSnapshot());\n+    final boolean srcChildIsReference \u003d srcChild.isReference();\n+    \n+    // check srcChild for reference\n+    final INodeReference.WithCount withCount;\n+    if (srcChildIsReference || isSrcInSnapshot) {\n+      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n+          .replaceChild4ReferenceWithName(srcChild); \n+      withCount \u003d (INodeReference.WithCount)withName.getReferredINode();\n+      srcChild \u003d withName;\n+      srcIIP.setLastINode(srcChild);\n+    } else {\n+      withCount \u003d null;\n+    }\n+    \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n-    final INode srcChild \u003d srcIIP.getLastINode();\n-    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n-\n+    \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n-      //TODO: setLocalName breaks created/deleted lists\n-      srcChild.setLocalName(dstIIP.getLastLocalName());\n+      \n+      srcChild \u003d srcIIP.getLastINode();\n+\n+      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n+      final INode toDst;\n+      if (withCount \u003d\u003d null) {\n+        srcChild.setLocalName(dstChildName);\n+        toDst \u003d srcChild;\n+      } else {\n+        withCount.getReferredINode().setLocalName(dstChildName);\n+        final INodeReference ref \u003d new INodeReference(dstIIP.getINode(-2), withCount);\n+        withCount.setParentReference(ref);\n+        withCount.incrementReferenceCount();\n+        toDst \u003d ref;\n+      }\n \n       // add src as dst to complete rename\n-      if (addLastINodeNoQuotaCheck(dstIIP, srcChild)) {\n+      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d removedDst.cleanSubtree(null,\n               dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n \n-        if (srcIIP.getLatestSnapshot() !\u003d null) {\n-          createReferences4Rename(srcChild, srcChildName,\n-              (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n-              dstParent.asDirectory());\n-        }\n-\n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n-        srcChild.setLocalName(srcChildName);\n+        srcChild \u003d srcIIP.getLastINode();\n+        if (withCount \u003d\u003d null) {\n+          srcChild.setLocalName(srcChildName);\n+        } else if (!srcChildIsReference) { // src must be in snapshot\n+          final INodeDirectoryWithSnapshot srcParent\n+              \u003d (INodeDirectoryWithSnapshot)srcIIP.getINode(-2).asDirectory();\n+          final INode originalChild \u003d withCount.getReferredINode();\n+          srcParent.replaceRemovedChild(srcChild, originalChild);\n+          srcChild \u003d originalChild;\n+        }\n         addLastINodeNoQuotaCheck(srcIIP, srcChild);\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         addLastINodeNoQuotaCheck(dstIIP, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n    final boolean isSrcInSnapshot \u003d srcChild.isInLatestSnapshot(\n        srcIIP.getLatestSnapshot());\n    final boolean srcChildIsReference \u003d srcChild.isReference();\n    \n    // check srcChild for reference\n    final INodeReference.WithCount withCount;\n    if (srcChildIsReference || isSrcInSnapshot) {\n      final INodeReference.WithName withName \u003d srcIIP.getINode(-2).asDirectory()\n          .replaceChild4ReferenceWithName(srcChild); \n      withCount \u003d (INodeReference.WithCount)withName.getReferredINode();\n      srcChild \u003d withName;\n      srcIIP.setLastINode(srcChild);\n    } else {\n      withCount \u003d null;\n    }\n    \n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    \n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      \n      srcChild \u003d srcIIP.getLastINode();\n\n      final byte[] dstChildName \u003d dstIIP.getLastLocalName();\n      final INode toDst;\n      if (withCount \u003d\u003d null) {\n        srcChild.setLocalName(dstChildName);\n        toDst \u003d srcChild;\n      } else {\n        withCount.getReferredINode().setLocalName(dstChildName);\n        final INodeReference ref \u003d new INodeReference(dstIIP.getINode(-2), withCount);\n        withCount.setParentReference(ref);\n        withCount.incrementReferenceCount();\n        toDst \u003d ref;\n      }\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, toDst)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        srcChild \u003d srcIIP.getLastINode();\n        if (withCount \u003d\u003d null) {\n          srcChild.setLocalName(srcChildName);\n        } else if (!srcChildIsReference) { // src must be in snapshot\n          final INodeDirectoryWithSnapshot srcParent\n              \u003d (INodeDirectoryWithSnapshot)srcIIP.getINode(-2).asDirectory();\n          final INode originalChild \u003d withCount.getReferredINode();\n          srcParent.replaceRemovedChild(srcChild, originalChild);\n          srcChild \u003d originalChild;\n        }\n        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        addLastINodeNoQuotaCheck(dstIIP, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "1096917649fd951be633e5619518764f23cca645": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4611. Update FSImage for INodeReference.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1463332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/04/13 4:24 PM",
      "commitName": "1096917649fd951be633e5619518764f23cca645",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "28/03/13 9:18 AM",
      "commitNameOld": "25aab4203c465403ae0c4ad62ec948094e023489",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 4.3,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,191 +1,192 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     boolean undoRemoveSrc \u003d true;\n     final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n+      //TODO: setLocalName breaks created/deleted lists\n       srcChild.setLocalName(dstIIP.getLastLocalName());\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, srcChild)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d removedDst.cleanSubtree(null,\n               dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n \n         if (srcIIP.getLatestSnapshot() !\u003d null) {\n           createReferences4Rename(srcChild, srcChildName,\n               (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n               dstParent.asDirectory());\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         srcChild.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcIIP, srcChild);\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         addLastINodeNoQuotaCheck(dstIIP, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      //TODO: setLocalName breaks created/deleted lists\n      srcChild.setLocalName(dstIIP.getLastLocalName());\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, srcChild)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (srcIIP.getLatestSnapshot() !\u003d null) {\n          createReferences4Rename(srcChild, srcChildName,\n              (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n              dstParent.asDirectory());\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        addLastINodeNoQuotaCheck(dstIIP, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "25aab4203c465403ae0c4ad62ec948094e023489": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4636. Update quota usage when deleting files/dirs that were created after taking the latest snapshot. Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1462192 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/03/13 9:18 AM",
      "commitName": "25aab4203c465403ae0c4ad62ec948094e023489",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "25/03/13 3:21 AM",
      "commitNameOld": "cc2f96f655d0fd4121125fc801056571f4a20a2a",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.25,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,191 +1,191 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n \n     INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n \n     boolean undoRemoveSrc \u003d true;\n-    final int removedSrc \u003d removeLastINode(srcIIP);\n+    final long removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final INode srcChild \u003d srcIIP.getLastINode();\n     final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n \n     boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         if (removeLastINode(dstIIP) !\u003d -1) {\n           removedDst \u003d dstIIP.getLastINode();\n           undoRemoveDst \u003d true;\n         }\n       }\n       srcChild.setLocalName(dstIIP.getLastLocalName());\n \n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, srcChild)) {\n         undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d removedDst.cleanSubtree(null,\n               dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n \n         if (srcIIP.getLatestSnapshot() !\u003d null) {\n           createReferences4Rename(srcChild, srcChildName,\n               (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n               dstParent.asDirectory());\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (undoRemoveSrc) {\n         // Rename failed - restore src\n         srcChild.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcIIP, srcChild);\n       }\n       if (undoRemoveDst) {\n         // Rename failed - restore dst\n         addLastINodeNoQuotaCheck(dstIIP, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    boolean undoRemoveSrc \u003d true;\n    final long removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      srcChild.setLocalName(dstIIP.getLastLocalName());\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, srcChild)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (srcIIP.getLatestSnapshot() !\u003d null) {\n          createReferences4Rename(srcChild, srcChildName,\n              (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n              dstParent.asDirectory());\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        addLastINodeNoQuotaCheck(dstIIP, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "9701555899315c94584b24d8717c1d7540a4a491": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4534. Add INodeReference in order to support rename with snapshots.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1458164 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/03/13 11:27 PM",
      "commitName": "9701555899315c94584b24d8717c1d7540a4a491",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "11/03/13 7:41 PM",
      "commitNameOld": "3b3ea5c4220e674064c7603a449f63904c10bac1",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 7.16,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,180 +1,191 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n \n-    final INode dstParent \u003d dstIIP.getINode(-2);\n+    INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n-    INode removedSrc \u003d removeLastINode(srcIIP);\n-    if (removedSrc \u003d\u003d null) {\n+\n+    boolean undoRemoveSrc \u003d true;\n+    final int removedSrc \u003d removeLastINode(srcIIP);\n+    if (removedSrc \u003d\u003d -1) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n-    final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n-    byte[] dstChildName \u003d null;\n+    final INode srcChild \u003d srcIIP.getLastINode();\n+    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n+\n+    boolean undoRemoveDst \u003d false;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        removedDst \u003d removeLastINode(dstIIP);\n-        dstChildName \u003d removedDst.getLocalNameBytes();\n+        if (removeLastINode(dstIIP) !\u003d -1) {\n+          removedDst \u003d dstIIP.getLastINode();\n+          undoRemoveDst \u003d true;\n+        }\n       }\n+      srcChild.setLocalName(dstIIP.getLastLocalName());\n \n-      removedSrc.setLocalName(dstIIP.getLastLocalName());\n       // add src as dst to complete rename\n-      if (addLastINodeNoQuotaCheck(dstIIP, removedSrc)) {\n-        removedSrc \u003d null;\n+      if (addLastINodeNoQuotaCheck(dstIIP, srcChild)) {\n+        undoRemoveSrc \u003d false;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n+        dstParent \u003d dstIIP.getINode(-2);\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n-          INode rmdst \u003d removedDst;\n-          removedDst \u003d null;\n+          undoRemoveDst \u003d false;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-          filesDeleted \u003d rmdst.cleanSubtree(null, dstIIP.getLatestSnapshot(),\n-              collectedBlocks).get(Quota.NAMESPACE);\n+          filesDeleted \u003d removedDst.cleanSubtree(null,\n+              dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n \n+        if (srcIIP.getLatestSnapshot() !\u003d null) {\n+          createReferences4Rename(srcChild, srcChildName,\n+              (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n+              dstParent.asDirectory());\n+        }\n+\n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n-      if (removedSrc !\u003d null) {\n+      if (undoRemoveSrc) {\n         // Rename failed - restore src\n-        removedSrc.setLocalName(srcChildName);\n-        addLastINodeNoQuotaCheck(srcIIP, removedSrc);\n+        srcChild.setLocalName(srcChildName);\n+        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n       }\n-      if (removedDst !\u003d null) {\n+      if (undoRemoveDst) {\n         // Rename failed - restore dst\n-        removedDst.setLocalName(dstChildName);\n         addLastINodeNoQuotaCheck(dstIIP, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n\n    INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n\n    boolean undoRemoveSrc \u003d true;\n    final int removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d -1) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INode srcChild \u003d srcIIP.getLastINode();\n    final byte[] srcChildName \u003d srcChild.getLocalNameBytes();\n\n    boolean undoRemoveDst \u003d false;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        if (removeLastINode(dstIIP) !\u003d -1) {\n          removedDst \u003d dstIIP.getLastINode();\n          undoRemoveDst \u003d true;\n        }\n      }\n      srcChild.setLocalName(dstIIP.getLastLocalName());\n\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, srcChild)) {\n        undoRemoveSrc \u003d false;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent \u003d dstIIP.getINode(-2);\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          undoRemoveDst \u003d false;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d removedDst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks).get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (srcIIP.getLatestSnapshot() !\u003d null) {\n          createReferences4Rename(srcChild, srcChildName,\n              (INodeDirectoryWithSnapshot)srcParent.asDirectory(),\n              dstParent.asDirectory());\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (undoRemoveSrc) {\n        // Rename failed - restore src\n        srcChild.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcIIP, srcChild);\n      }\n      if (undoRemoveDst) {\n        // Rename failed - restore dst\n        addLastINodeNoQuotaCheck(dstIIP, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "3b3ea5c4220e674064c7603a449f63904c10bac1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4563. Update namespace/diskspace usage after deleting snapshots.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1455396 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/03/13 7:41 PM",
      "commitName": "3b3ea5c4220e674064c7603a449f63904c10bac1",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "10/03/13 8:45 PM",
      "commitNameOld": "43f8d0b9c9e209eb503451613c2f8d3fed07c203",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,180 +1,180 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n \n     final INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     INode removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n     byte[] dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeLastINode(dstIIP);\n         dstChildName \u003d removedDst.getLocalNameBytes();\n       }\n \n       removedSrc.setLocalName(dstIIP.getLastLocalName());\n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, removedSrc)) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n-        int filesDeleted \u003d -1;\n+        long filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-          filesDeleted \u003d rmdst.cleanSubtree(null,\n-              dstIIP.getLatestSnapshot(), collectedBlocks);\n+          filesDeleted \u003d rmdst.cleanSubtree(null, dstIIP.getLatestSnapshot(),\n+              collectedBlocks).get(Quota.NAMESPACE);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcIIP, removedSrc);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addLastINodeNoQuotaCheck(dstIIP, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n\n    final INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    INode removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n    byte[] dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeLastINode(dstIIP);\n        dstChildName \u003d removedDst.getLocalNameBytes();\n      }\n\n      removedSrc.setLocalName(dstIIP.getLastLocalName());\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, removedSrc)) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        long filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.cleanSubtree(null, dstIIP.getLatestSnapshot(),\n              collectedBlocks).get(Quota.NAMESPACE);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcIIP, removedSrc);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addLastINodeNoQuotaCheck(dstIIP, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "8d95784bf1a7fcf473fd5a9fed0140521a92a968": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4557. Fix FSDirectory#delete when INode#cleanSubtree returns 0.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1454138 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/03/13 2:34 PM",
      "commitName": "8d95784bf1a7fcf473fd5a9fed0140521a92a968",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "04/03/13 6:23 PM",
      "commitNameOld": "b1333e5b561d01a010e2e1311e8501879f377bdc",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 2.84,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,180 +1,180 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n     final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n     if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n \n     final INode dstInode \u003d dstIIP.getLastINode();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n             .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n \n     final INode dstParent \u003d dstIIP.getINode(-2);\n     if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n     INode removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n     byte[] dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeLastINode(dstIIP);\n         dstChildName \u003d removedDst.getLocalNameBytes();\n       }\n \n       removedSrc.setLocalName(dstIIP.getLastLocalName());\n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstIIP, removedSrc)) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n \n         final INode srcParent \u003d srcIIP.getINode(-2);\n         srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n         dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n-        int filesDeleted \u003d 0;\n+        int filesDeleted \u003d -1;\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.cleanSubtree(null,\n               dstIIP.getLatestSnapshot(), collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n-        return filesDeleted \u003e0;\n+        return filesDeleted \u003e\u003d 0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcIIP, removedSrc);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addLastINodeNoQuotaCheck(dstIIP, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n\n    final INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    INode removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n    byte[] dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeLastINode(dstIIP);\n        dstChildName \u003d removedDst.getLocalNameBytes();\n      }\n\n      removedSrc.setLocalName(dstIIP.getLastLocalName());\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, removedSrc)) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        int filesDeleted \u003d -1;\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e\u003d 0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcIIP, removedSrc);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addLastINodeNoQuotaCheck(dstIIP, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "b1333e5b561d01a010e2e1311e8501879f377bdc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4545. With snapshots, FSDirectory.unprotectedSetReplication(..) always changes file replication but it may or may not changes block replication.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1452636 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/03/13 6:23 PM",
      "commitName": "b1333e5b561d01a010e2e1311e8501879f377bdc",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "27/02/13 7:08 PM",
      "commitNameOld": "c7cf85ccb4ff2f58839e113f1baf903a468b606d",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 4.97,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,181 +1,180 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n-    final INodesInPath srcInodesInPath \u003d rootDir.getINodesInPath4Write(src,\n-        false);\n-    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n-    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n+    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n+    final INode srcInode \u003d srcIIP.getLastINode();\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n-    if (srcInodes.length \u003d\u003d 1) {\n+    if (srcIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n-        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n+        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n-    final INodesInPath dstInodesInPath \u003d rootDir.getINodesInPath4Write(\n-        dst, false);\n-    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n-    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n-    if (dstInodes.length \u003d\u003d 1) {\n+    final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n+    if (dstIIP.getINodes().length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n+\n+    final INode dstInode \u003d dstIIP.getLastINode();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n-        final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n-            ).getChildrenList(dstInodesInPath.getPathSnapshot());\n+        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n+            .getChildrenList(null);\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n-    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n+\n+    final INode dstParent \u003d dstIIP.getINode(-2);\n+    if (dstParent \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n-    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n+    if (!dstParent.isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n-    verifyQuotaForRename(srcInodes, dstInodes);\n-    INode removedSrc \u003d removeLastINode(srcInodesInPath);\n+    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n+    INode removedSrc \u003d removeLastINode(srcIIP);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n     byte[] dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        removedDst \u003d removeLastINode(dstInodesInPath);\n+        removedDst \u003d removeLastINode(dstIIP);\n         dstChildName \u003d removedDst.getLocalNameBytes();\n       }\n \n-      removedSrc.setLocalName(dstInodesInPath.getLastLocalName());\n+      removedSrc.setLocalName(dstIIP.getLastLocalName());\n       // add src as dst to complete rename\n-      if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n+      if (addLastINodeNoQuotaCheck(dstIIP, removedSrc)) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n-        srcInodes[srcInodes.length - 2].updateModificationTime(timestamp,\n-            srcInodesInPath.getLatestSnapshot());\n-        dstInodes[dstInodes.length - 2].updateModificationTime(timestamp,\n-            dstInodesInPath.getLatestSnapshot());\n+\n+        final INode srcParent \u003d srcIIP.getINode(-2);\n+        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n+        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         int filesDeleted \u003d 0;\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.cleanSubtree(null,\n-              dstInodesInPath.getLatestSnapshot(), collectedBlocks);\n+              dstIIP.getLatestSnapshot(), collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n-        addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n+        addLastINodeNoQuotaCheck(srcIIP, removedSrc);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n-        addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n+        addLastINodeNoQuotaCheck(dstIIP, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcIIP \u003d rootDir.getINodesInPath4Write(src, false);\n    final INode srcInode \u003d srcIIP.getLastINode();\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(srcInode.asSymlink().getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INodesInPath dstIIP \u003d rootDir.getINodesInPath4Write(dst, false);\n    if (dstIIP.getINodes().length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n\n    final INode dstInode \u003d dstIIP.getLastINode();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d dstInode.asDirectory()\n            .getChildrenList(null);\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n\n    final INode dstParent \u003d dstIIP.getINode(-2);\n    if (dstParent \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstParent.isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcIIP.getINodes(), dstIIP.getINodes());\n    INode removedSrc \u003d removeLastINode(srcIIP);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n    byte[] dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeLastINode(dstIIP);\n        dstChildName \u003d removedDst.getLocalNameBytes();\n      }\n\n      removedSrc.setLocalName(dstIIP.getLastLocalName());\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstIIP, removedSrc)) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n\n        final INode srcParent \u003d srcIIP.getINode(-2);\n        srcParent.updateModificationTime(timestamp, srcIIP.getLatestSnapshot());\n        dstParent.updateModificationTime(timestamp, dstIIP.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        int filesDeleted \u003d 0;\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.cleanSubtree(null,\n              dstIIP.getLatestSnapshot(), collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcIIP, removedSrc);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addLastINodeNoQuotaCheck(dstIIP, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "f29fa9e820e25730d00a1a00c51c6f11028fb5a7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4499. Fix file/directory/snapshot deletion for file diff.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1448504 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/02/13 7:27 PM",
      "commitName": "f29fa9e820e25730d00a1a00c51c6f11028fb5a7",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "20/02/13 12:02 PM",
      "commitNameOld": "fac3883188d9c4f1fe188d98f88cb3c83b243bbd",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.31,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,181 +1,181 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcInodesInPath \u003d rootDir.getINodesInPath4Write(src,\n         false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final INodesInPath dstInodesInPath \u003d rootDir.getINodesInPath4Write(\n         dst, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n             ).getChildrenList(dstInodesInPath.getPathSnapshot());\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeLastINode(srcInodesInPath);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n     byte[] dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeLastINode(dstInodesInPath);\n         dstChildName \u003d removedDst.getLocalNameBytes();\n       }\n \n       removedSrc.setLocalName(dstInodesInPath.getLastLocalName());\n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].updateModificationTime(timestamp,\n             srcInodesInPath.getLatestSnapshot());\n         dstInodes[dstInodes.length - 2].updateModificationTime(timestamp,\n             dstInodesInPath.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         int filesDeleted \u003d 0;\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-          filesDeleted \u003d rmdst.destroySubtreeAndCollectBlocks(\n-              null, collectedBlocks);\n+          filesDeleted \u003d rmdst.cleanSubtree(null,\n+              dstInodesInPath.getLatestSnapshot(), collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getINodesInPath4Write(src,\n        false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INodesInPath dstInodesInPath \u003d rootDir.getINodesInPath4Write(\n        dst, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n            ).getChildrenList(dstInodesInPath.getPathSnapshot());\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeLastINode(srcInodesInPath);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n    byte[] dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeLastINode(dstInodesInPath);\n        dstChildName \u003d removedDst.getLocalNameBytes();\n      }\n\n      removedSrc.setLocalName(dstInodesInPath.getLastLocalName());\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].updateModificationTime(timestamp,\n            srcInodesInPath.getLatestSnapshot());\n        dstInodes[dstInodes.length - 2].updateModificationTime(timestamp,\n            dstInodesInPath.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        int filesDeleted \u003d 0;\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.cleanSubtree(null,\n              dstInodesInPath.getLatestSnapshot(), collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "e7db60fbfcc222b32d610ffd912683494674ad2f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4464. Combine collectSubtreeBlocksAndClear with deleteDiffsForSnapshot and rename it to destroySubtreeAndCollectBlocks.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1441680 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/02/13 5:53 PM",
      "commitName": "e7db60fbfcc222b32d610ffd912683494674ad2f",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "31/01/13 1:13 PM",
      "commitNameOld": "2372e394dd99d69d396327d5a5e172953a8b8c6a",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 1.19,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,180 +1,180 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcInodesInPath \u003d rootDir.getINodesInPath4Write(src,\n         false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final INodesInPath dstInodesInPath \u003d rootDir.getINodesInPath4Write(\n         dst, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n             ).getChildrenList(dstInodesInPath.getPathSnapshot());\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeLastINode(srcInodesInPath);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n     byte[] dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeLastINode(dstInodesInPath);\n         dstChildName \u003d removedDst.getLocalNameBytes();\n       }\n \n       removedSrc.setLocalName(dstInodesInPath.getLastLocalName());\n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].updateModificationTime(timestamp,\n             srcInodesInPath.getLatestSnapshot());\n         dstInodes[dstInodes.length - 2].updateModificationTime(timestamp,\n             dstInodesInPath.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         int filesDeleted \u003d 0;\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n-          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n+          filesDeleted \u003d rmdst.destroySubtreeAndCollectBlocks(null, collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getINodesInPath4Write(src,\n        false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INodesInPath dstInodesInPath \u003d rootDir.getINodesInPath4Write(\n        dst, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n            ).getChildrenList(dstInodesInPath.getPathSnapshot());\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeLastINode(srcInodesInPath);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n    byte[] dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeLastINode(dstInodesInPath);\n        dstChildName \u003d removedDst.getLocalNameBytes();\n      }\n\n      removedSrc.setLocalName(dstInodesInPath.getLastLocalName());\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].updateModificationTime(timestamp,\n            srcInodesInPath.getLatestSnapshot());\n        dstInodes[dstInodes.length - 2].updateModificationTime(timestamp,\n            dstInodesInPath.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        int filesDeleted \u003d 0;\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.destroySubtreeAndCollectBlocks(null, collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "2372e394dd99d69d396327d5a5e172953a8b8c6a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4189. Renames the getMutableXxx methods to getXxx4Write and fix a bug that some getExistingPathINodes calls should be getINodesInPath4Write.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1441193 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/01/13 1:13 PM",
      "commitName": "2372e394dd99d69d396327d5a5e172953a8b8c6a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "25/01/13 4:01 PM",
      "commitNameOld": "a3bf2083867db5d848ea14f145d120f02b820af2",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 5.88,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,181 +1,180 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n-    final INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src,\n+    final INodesInPath srcInodesInPath \u003d rootDir.getINodesInPath4Write(src,\n         false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n-    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n-    final INodesInPath dstInodesInPath \u003d rootDir.getMutableINodesInPath(\n-        dstComponents, false);\n+    final INodesInPath dstInodesInPath \u003d rootDir.getINodesInPath4Write(\n+        dst, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n         new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n             ).getChildrenList(dstInodesInPath.getPathSnapshot());\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeLastINode(srcInodesInPath);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n     byte[] dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeLastINode(dstInodesInPath);\n         dstChildName \u003d removedDst.getLocalNameBytes();\n       }\n \n-      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n+      removedSrc.setLocalName(dstInodesInPath.getLastLocalName());\n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].updateModificationTime(timestamp,\n             srcInodesInPath.getLatestSnapshot());\n         dstInodes[dstInodes.length - 2].updateModificationTime(timestamp,\n             dstInodesInPath.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         int filesDeleted \u003d 0;\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n \n         if (snapshottableDirs.size() \u003e 0) {\n           // There are snapshottable directories (without snapshots) to be\n           // deleted. Need to update the SnapshotManager.\n           namesystem.removeSnapshottableDirs(snapshottableDirs);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getINodesInPath4Write(src,\n        false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final INodesInPath dstInodesInPath \u003d rootDir.getINodesInPath4Write(\n        dst, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n            ).getChildrenList(dstInodesInPath.getPathSnapshot());\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeLastINode(srcInodesInPath);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n    byte[] dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeLastINode(dstInodesInPath);\n        dstChildName \u003d removedDst.getLocalNameBytes();\n      }\n\n      removedSrc.setLocalName(dstInodesInPath.getLastLocalName());\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].updateModificationTime(timestamp,\n            srcInodesInPath.getLatestSnapshot());\n        dstInodes[dstInodes.length - 2].updateModificationTime(timestamp,\n            dstInodesInPath.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        int filesDeleted \u003d 0;\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "93872b58e50eb6ecf65544cc9e8aea5a4988e19b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4230. Support listing of all the snapshottable directories.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1429643 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/01/13 5:43 PM",
      "commitName": "93872b58e50eb6ecf65544cc9e8aea5a4988e19b",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "04/01/13 2:45 AM",
      "commitNameOld": "f96d0a358529c4a49eadbb21c2423887dceb1141",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 2.62,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,173 +1,181 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src,\n         false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     final INodesInPath dstInodesInPath \u003d rootDir.getMutableINodesInPath(\n         dstComponents, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n+    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n+        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n             ).getChildrenList(dstInodesInPath.getPathSnapshot());\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n-      INode snapshotNode \u003d hasSnapshot(dstInode);\n+      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeLastINode(srcInodesInPath);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n     byte[] dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeLastINode(dstInodesInPath);\n         dstChildName \u003d removedDst.getLocalNameBytes();\n       }\n \n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].updateModificationTime(timestamp,\n             srcInodesInPath.getLatestSnapshot());\n         dstInodes[dstInodes.length - 2].updateModificationTime(timestamp,\n             dstInodesInPath.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         int filesDeleted \u003d 0;\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n+\n+        if (snapshottableDirs.size() \u003e 0) {\n+          // There are snapshottable directories (without snapshots) to be\n+          // deleted. Need to update the SnapshotManager.\n+          namesystem.removeSnapshottableDirs(snapshottableDirs);\n+        }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src,\n        false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INodesInPath dstInodesInPath \u003d rootDir.getMutableINodesInPath(\n        dstComponents, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    List\u003cINodeDirectorySnapshottable\u003e snapshottableDirs \u003d \n        new ArrayList\u003cINodeDirectorySnapshottable\u003e();\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n            ).getChildrenList(dstInodesInPath.getPathSnapshot());\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode, snapshottableDirs);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeLastINode(srcInodesInPath);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n    byte[] dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeLastINode(dstInodesInPath);\n        dstChildName \u003d removedDst.getLocalNameBytes();\n      }\n\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].updateModificationTime(timestamp,\n            srcInodesInPath.getLatestSnapshot());\n        dstInodes[dstInodes.length - 2].updateModificationTime(timestamp,\n            dstInodesInPath.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        int filesDeleted \u003d 0;\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n\n        if (snapshottableDirs.size() \u003e 0) {\n          // There are snapshottable directories (without snapshots) to be\n          // deleted. Need to update the SnapshotManager.\n          namesystem.removeSnapshottableDirs(snapshottableDirs);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "b9f965de120b5278ac84a7e98aecb32aafde4c16": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4103. Support O(1) snapshot creation.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1424782 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/12/12 5:30 PM",
      "commitName": "b9f965de120b5278ac84a7e98aecb32aafde4c16",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "16/12/12 7:40 PM",
      "commitNameOld": "cbbaa93ae09bf5cf643263faf78f99315c4f3a8d",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 3.91,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,171 +1,173 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src,\n         false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     final INodesInPath dstInodesInPath \u003d rootDir.getMutableINodesInPath(\n         dstComponents, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n             ).getChildrenList(dstInodesInPath.getPathSnapshot());\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeLastINode(srcInodesInPath);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n-    final String srcChildName \u003d removedSrc.getLocalName();\n-    String dstChildName \u003d null;\n+    final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n+    byte[] dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeLastINode(dstInodesInPath);\n-        dstChildName \u003d removedDst.getLocalName();\n+        dstChildName \u003d removedDst.getLocalNameBytes();\n       }\n \n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n-        srcInodes[srcInodes.length - 2].updateModificationTime(timestamp);\n-        dstInodes[dstInodes.length - 2].updateModificationTime(timestamp);\n+        srcInodes[srcInodes.length - 2].updateModificationTime(timestamp,\n+            srcInodesInPath.getLatestSnapshot());\n+        dstInodes[dstInodes.length - 2].updateModificationTime(timestamp,\n+            dstInodesInPath.getLatestSnapshot());\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         int filesDeleted \u003d 0;\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src,\n        false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INodesInPath dstInodesInPath \u003d rootDir.getMutableINodesInPath(\n        dstComponents, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n            ).getChildrenList(dstInodesInPath.getPathSnapshot());\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeLastINode(srcInodesInPath);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[] srcChildName \u003d removedSrc.getLocalNameBytes();\n    byte[] dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeLastINode(dstInodesInPath);\n        dstChildName \u003d removedDst.getLocalNameBytes();\n      }\n\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].updateModificationTime(timestamp,\n            srcInodesInPath.getLatestSnapshot());\n        dstInodes[dstInodes.length - 2].updateModificationTime(timestamp,\n            dstInodesInPath.getLatestSnapshot());\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        int filesDeleted \u003d 0;\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "cbbaa93ae09bf5cf643263faf78f99315c4f3a8d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4317. Change INode and its subclasses to support HDFS-4103.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1422748 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/12/12 7:40 PM",
      "commitName": "cbbaa93ae09bf5cf643263faf78f99315c4f3a8d",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "10/12/12 3:54 PM",
      "commitNameOld": "39d25fbac331ede57196f7a2d2d5e26e2fbc1c9f",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 6.16,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,171 +1,171 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src,\n         false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     final INodesInPath dstInodesInPath \u003d rootDir.getMutableINodesInPath(\n         dstComponents, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n             ).getChildrenList(dstInodesInPath.getPathSnapshot());\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeLastINode(srcInodesInPath);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeLastINode(dstInodesInPath);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n-        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n-        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n+        srcInodes[srcInodes.length - 2].updateModificationTime(timestamp);\n+        dstInodes[dstInodes.length - 2].updateModificationTime(timestamp);\n         // update moved lease with new filename\n         getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         int filesDeleted \u003d 0;\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src,\n        false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INodesInPath dstInodesInPath \u003d rootDir.getMutableINodesInPath(\n        dstComponents, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n            ).getChildrenList(dstInodesInPath.getPathSnapshot());\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeLastINode(srcInodesInPath);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeLastINode(dstInodesInPath);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].updateModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].updateModificationTime(timestamp);\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        int filesDeleted \u003d 0;\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "9821af9ce8a56a2c583f1ed938902c20e897048f": {
      "type": "Ybodychange",
      "commitMessage": "Reverting the previous merge r1416603 which committed some extra changes\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1416712 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/12/12 2:43 PM",
      "commitName": "9821af9ce8a56a2c583f1ed938902c20e897048f",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "03/12/12 10:04 AM",
      "commitNameOld": "d500d59cbef51f1b0b0291995893b85a139bcec9",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,171 +1,169 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src,\n         false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     final INodesInPath dstInodesInPath \u003d rootDir.getMutableINodesInPath(\n         dstComponents, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n             ).getChildrenList(dstInodesInPath.getPathSnapshot());\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeLastINode(srcInodesInPath);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeLastINode(dstInodesInPath);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n-        srcInodes[srcInodes.length - 2].updateModificationTime(timestamp);\n-        dstInodes[dstInodes.length - 2].updateModificationTime(timestamp);\n-        // update moved lease with new filename\n-        getFSNamesystem().unprotectedChangeLease(src, dst);\n+        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n+        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         int filesDeleted \u003d 0;\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src,\n        false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INodesInPath dstInodesInPath \u003d rootDir.getMutableINodesInPath(\n        dstComponents, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n            ).getChildrenList(dstInodesInPath.getPathSnapshot());\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeLastINode(srcInodesInPath);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeLastINode(dstInodesInPath);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        int filesDeleted \u003d 0;\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "88eea2157275d4c7e1bf70cac98fe52c326f3585": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4248. Renaming directories may incorrectly remove the paths in leases under the tree.  Contributed by daryn\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1416064 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/12/12 2:29 PM",
      "commitName": "88eea2157275d4c7e1bf70cac98fe52c326f3585",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "27/11/12 2:36 PM",
      "commitNameOld": "9047eb516261b8c9c380d140a43dfdd5d701dee5",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 4.0,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,158 +1,160 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final List\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n             ).getChildrenList();\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeLastINode(srcInodesInPath);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeLastINode(dstInodesInPath);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n+        // update moved lease with new filename\n+        getFSNamesystem().unprotectedChangeLease(src, dst);\n \n         // Collect the blocks and remove the lease for previous dst\n         int filesDeleted \u003d 0;\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final List\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n            ).getChildrenList();\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeLastINode(srcInodesInPath);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeLastINode(dstInodesInPath);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n        // update moved lease with new filename\n        getFSNamesystem().unprotectedChangeLease(src, dst);\n\n        // Collect the blocks and remove the lease for previous dst\n        int filesDeleted \u003d 0;\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "9047eb516261b8c9c380d140a43dfdd5d701dee5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4209. Clean up the addNode/addChild/addChildNoQuotaCheck methods in FSDirectory and INodeDirectory.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1414447 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/12 2:36 PM",
      "commitName": "9047eb516261b8c9c380d140a43dfdd5d701dee5",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "21/11/12 11:27 AM",
      "commitNameOld": "0f1899ee19ab13d5128801063b0ce17612c0e96f",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 6.13,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,158 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final List\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n             ).getChildrenList();\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n-    INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n+    INode removedSrc \u003d removeLastINode(srcInodesInPath);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n+        removedDst \u003d removeLastINode(dstInodesInPath);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n-      INode dstChild \u003d null;\n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n-      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n-          removedSrc, UNKNOWN_DISK_SPACE);\n-\n-      int filesDeleted \u003d 0;\n-      if (dstChild !\u003d null) {\n+      if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n+        int filesDeleted \u003d 0;\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n-        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n-            UNKNOWN_DISK_SPACE);\n+        addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n-        addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n-            UNKNOWN_DISK_SPACE);\n+        addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final List\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n            ).getChildrenList();\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeLastINode(srcInodesInPath);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeLastINode(dstInodesInPath);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      if (addLastINodeNoQuotaCheck(dstInodesInPath, removedSrc)) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        int filesDeleted \u003d 0;\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addLastINodeNoQuotaCheck(srcInodesInPath, removedSrc);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addLastINodeNoQuotaCheck(dstInodesInPath, removedDst);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "d66f9e8269424f588180f2659c8cf132a2a7dfc9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4206. Change the fields in INode and its subclasses to private.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1410996 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/12 2:03 PM",
      "commitName": "d66f9e8269424f588180f2659c8cf132a2a7dfc9",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "14/11/12 11:21 AM",
      "commitNameOld": "59e4199d842d8590d2c73c6dba805a9746e1ef4a",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 4.11,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,163 +1,164 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n-        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n+        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n-      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n-          ((INodeDirectory) dstInode).getChildren() : null;\n-      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n-        error \u003d \"rename cannot overwrite non empty destination directory \"\n-            + dst;\n-        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-            + error);\n-        throw new IOException(error);\n+      if (dstInode.isDirectory()) {\n+        final List\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n+            ).getChildrenList();\n+        if (!children.isEmpty()) {\n+          error \u003d \"rename destination directory is not empty: \" + dst;\n+          NameNode.stateChangeLog.warn(\n+              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n+          throw new IOException(error);\n+        }\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       INode dstChild \u003d null;\n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n           removedSrc, UNKNOWN_DISK_SPACE);\n \n       int filesDeleted \u003d 0;\n       if (dstChild !\u003d null) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n             UNKNOWN_DISK_SPACE);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getSymlinkString())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final List\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n            ).getChildrenList();\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "2116d0520e528c44fa280f2a5b28594c6d6fc28a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4148. Disallow write/modify operations on files and directories in a snapshot. Contributed by Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1409023 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/11/12 3:26 PM",
      "commitName": "2116d0520e528c44fa280f2a5b28594c6d6fc28a",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "13/11/12 11:59 AM",
      "commitNameOld": "099762a0bc960066f8157fdd1e495b6752a6f802",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,174 +1,175 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n-    final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n+    final INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src,\n+        false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n-    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n-        dstComponents.length, false);\n+    final INodesInPath dstInodesInPath \u003d rootDir.getMutableINodesInPath(\n+        dstComponents, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       if (dstInode.isDirectory()) {\n         final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n             ).getChildrenList(dstInodesInPath.getPathSnapshot());\n         if (!children.isEmpty()) {\n           error \u003d \"rename destination directory is not empty: \" + dst;\n           NameNode.stateChangeLog.warn(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n           throw new IOException(error);\n         }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       INode dstChild \u003d null;\n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n           removedSrc, UNKNOWN_DISK_SPACE);\n \n       int filesDeleted \u003d 0;\n       if (dstChild !\u003d null) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n             UNKNOWN_DISK_SPACE);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getMutableINodesInPath(src,\n        false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INodesInPath dstInodesInPath \u003d rootDir.getMutableINodesInPath(\n        dstComponents, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n            ).getChildrenList(dstInodesInPath.getPathSnapshot());\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "099762a0bc960066f8157fdd1e495b6752a6f802": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4177. Add a snapshot parameter to INodeDirectory.getChildrenList() for selecting particular snapshot children list views.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1408923 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/11/12 11:59 AM",
      "commitName": "099762a0bc960066f8157fdd1e495b6752a6f802",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "09/11/12 4:49 PM",
      "commitNameOld": "40fe1ffbaa157afc3515bfb7a630dbfeca856f04",
      "commitAuthorOld": "",
      "daysBetweenCommits": 3.8,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,173 +1,174 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n-      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n-          ((INodeDirectory) dstInode).getChildren() : null;\n-      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n-        error \u003d \"rename cannot overwrite non empty destination directory \"\n-            + dst;\n-        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n-            + error);\n-        throw new IOException(error);\n+      if (dstInode.isDirectory()) {\n+        final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n+            ).getChildrenList(dstInodesInPath.getPathSnapshot());\n+        if (!children.isEmpty()) {\n+          error \u003d \"rename destination directory is not empty: \" + dst;\n+          NameNode.stateChangeLog.warn(\n+              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n+          throw new IOException(error);\n+        }\n       }\n       INode snapshotNode \u003d hasSnapshot(dstInode);\n       if (snapshotNode !\u003d null) {\n         error \u003d \"The direcotry \" + dstInode.getFullPathName()\n             + \" cannot be deleted for renaming since \"\n             + snapshotNode.getFullPathName()\n             + \" is snapshottable and already has snapshots\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       INode dstChild \u003d null;\n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n           removedSrc, UNKNOWN_DISK_SPACE);\n \n       int filesDeleted \u003d 0;\n       if (dstChild !\u003d null) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n             UNKNOWN_DISK_SPACE);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      if (dstInode.isDirectory()) {\n        final ReadOnlyList\u003cINode\u003e children \u003d ((INodeDirectory) dstInode\n            ).getChildrenList(dstInodesInPath.getPathSnapshot());\n        if (!children.isEmpty()) {\n          error \u003d \"rename destination directory is not empty: \" + dst;\n          NameNode.stateChangeLog.warn(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + error);\n          throw new IOException(error);\n        }\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "b94cf83a113564ec07880c44d6b03a461f9fc923": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4159. Rename should fail when the destination directory is snapshottable and has snapshots. Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1406771 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/11/12 11:38 AM",
      "commitName": "b94cf83a113564ec07880c44d6b03a461f9fc923",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "06/11/12 1:11 PM",
      "commitNameOld": "92c440c1158bb3939006d208ad1cda23bd532168",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,163 +1,173 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n           ((INodeDirectory) dstInode).getChildren() : null;\n       if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n         error \u003d \"rename cannot overwrite non empty destination directory \"\n             + dst;\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n+      INode snapshotNode \u003d hasSnapshot(dstInode);\n+      if (snapshotNode !\u003d null) {\n+        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n+            + \" cannot be deleted for renaming since \"\n+            + snapshotNode.getFullPathName()\n+            + \" is snapshottable and already has snapshots\";\n+        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+            + error);\n+        throw new IOException(error);\n+      }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       INode dstChild \u003d null;\n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n           removedSrc, UNKNOWN_DISK_SPACE);\n \n       int filesDeleted \u003d 0;\n       if (dstChild !\u003d null) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n             UNKNOWN_DISK_SPACE);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n          ((INodeDirectory) dstInode).getChildren() : null;\n      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n        error \u003d \"rename cannot overwrite non empty destination directory \"\n            + dst;\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      INode snapshotNode \u003d hasSnapshot(dstInode);\n      if (snapshotNode !\u003d null) {\n        error \u003d \"The direcotry \" + dstInode.getFullPathName()\n            + \" cannot be deleted for renaming since \"\n            + snapshotNode.getFullPathName()\n            + \" is snapshottable and already has snapshots\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "1734215a10fd93e38849ed0235b5e026b7f50f83": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4152. Add a new class BlocksMapUpdateInfo for the parameter in INode.collectSubtreeBlocksAndClear(..). Contributed by Jing Zhao \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1406326 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/11/12 1:04 PM",
      "commitName": "1734215a10fd93e38849ed0235b5e026b7f50f83",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "05/11/12 3:26 PM",
      "commitNameOld": "7ee5ce3176a74d217551b5981f809a56c719424b",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,163 +1,163 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n     final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n           ((INodeDirectory) dstInode).getChildren() : null;\n       if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n         error \u003d \"rename cannot overwrite non empty destination directory \"\n             + dst;\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       INode dstChild \u003d null;\n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n           removedSrc, UNKNOWN_DISK_SPACE);\n \n       int filesDeleted \u003d 0;\n       if (dstChild !\u003d null) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n-          List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n+          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n             UNKNOWN_DISK_SPACE);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n          ((INodeDirectory) dstInode).getChildren() : null;\n      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n        error \u003d \"rename cannot overwrite non empty destination directory \"\n            + dst;\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          BlocksMapUpdateInfo collectedBlocks \u003d new BlocksMapUpdateInfo();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "34413c2000d9262faa37fde88a72939587edc776": {
      "type": "Ybodychange",
      "commitMessage": "svn merge -c 1406006 from trunk for HDFS-4151. Change the methods in FSDirectory to pass INodesInPath instead of INode[] as a parameter.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1406014 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/11/12 3:56 PM",
      "commitName": "34413c2000d9262faa37fde88a72939587edc776",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "04/11/12 5:22 PM",
      "commitNameOld": "b3bc2fb76e1aca8e7327d1d1a6e4c8a013c575de",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.94,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,162 +1,163 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n-    final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n+    final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n+    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n           ((INodeDirectory) dstInode).getChildren() : null;\n       if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n         error \u003d \"rename cannot overwrite non empty destination directory \"\n             + dst;\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n-    INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n+    INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n+        removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       INode dstChild \u003d null;\n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n-      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n+      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n           removedSrc, UNKNOWN_DISK_SPACE);\n \n       int filesDeleted \u003d 0;\n       if (dstChild !\u003d null) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n-        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n+        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n             UNKNOWN_DISK_SPACE);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n-        addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n+        addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n          ((INodeDirectory) dstInode).getChildren() : null;\n      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n        error \u003d \"rename cannot overwrite non empty destination directory \"\n            + dst;\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "7ee5ce3176a74d217551b5981f809a56c719424b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4151. Change the methods in FSDirectory to pass INodesInPath instead of INode[] as a parameter.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1406006 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/11/12 3:26 PM",
      "commitName": "7ee5ce3176a74d217551b5981f809a56c719424b",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "02/11/12 5:20 PM",
      "commitNameOld": "d174f574bafcfefc635c64a47f258b1ce5d5c84e",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 2.96,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,162 +1,163 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n-    final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n+    final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n+    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n           ((INodeDirectory) dstInode).getChildren() : null;\n       if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n         error \u003d \"rename cannot overwrite non empty destination directory \"\n             + dst;\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n-    INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n+    INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n-        removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n+        removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       INode dstChild \u003d null;\n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n-      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n+      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n           removedSrc, UNKNOWN_DISK_SPACE);\n \n       int filesDeleted \u003d 0;\n       if (dstChild !\u003d null) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n-        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n+        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n             UNKNOWN_DISK_SPACE);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n-        addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n+        addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INodesInPath srcInodesInPath \u003d rootDir.getExistingPathINodes(src, false);\n    final INode[] srcInodes \u003d srcInodesInPath.getINodes();\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n          ((INodeDirectory) dstInode).getChildren() : null;\n      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n        error \u003d \"rename cannot overwrite non empty destination directory \"\n            + dst;\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodesInPath, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodesInPath, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodesInPath, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodesInPath, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "d174f574bafcfefc635c64a47f258b1ce5d5c84e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4143. Change blocks to private in INodeFile and renames isLink() to isSymlink() in INode.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1405237 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/11/12 5:20 PM",
      "commitName": "d174f574bafcfefc635c64a47f258b1ce5d5c84e",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "29/10/12 7:11 AM",
      "commitNameOld": "1b3b09d94794622e8336220d897a1f10c4654677",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 4.42,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,162 +1,162 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n-    if (srcInode.isLink() \u0026\u0026 \n+    if (srcInode.isSymlink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n         dstComponents.length, false);\n     final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n           ((INodeDirectory) dstInode).getChildren() : null;\n       if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n         error \u003d \"rename cannot overwrite non empty destination directory \"\n             + dst;\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       INode dstChild \u003d null;\n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n           removedSrc, UNKNOWN_DISK_SPACE);\n \n       int filesDeleted \u003d 0;\n       if (dstChild !\u003d null) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n             UNKNOWN_DISK_SPACE);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isSymlink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n          ((INodeDirectory) dstInode).getChildren() : null;\n      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n        error \u003d \"rename cannot overwrite non empty destination directory \"\n            + dst;\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "1b3b09d94794622e8336220d897a1f10c4654677": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4124. Refactor INodeDirectory#getExistingPathINodes() to enable returningmore than INode array. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1403304 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/10/12 7:11 AM",
      "commitName": "1b3b09d94794622e8336220d897a1f10c4654677",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "28/10/12 4:10 PM",
      "commitNameOld": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.63,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,161 +1,162 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isLink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n-    final INode[] dstInodes \u003d new INode[dstComponents.length];\n-    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n+    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n+        dstComponents.length, false);\n+    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n           ((INodeDirectory) dstInode).getChildren() : null;\n       if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n         error \u003d \"rename cannot overwrite non empty destination directory \"\n             + dst;\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       INode dstChild \u003d null;\n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n           removedSrc, UNKNOWN_DISK_SPACE);\n \n       int filesDeleted \u003d 0;\n       if (dstChild !\u003d null) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n             UNKNOWN_DISK_SPACE);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isLink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    INodesInPath dstInodesInPath \u003d rootDir.getExistingPathINodes(dstComponents,\n        dstComponents.length, false);\n    final INode[] dstInodes \u003d dstInodesInPath.getINodes();\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n          ((INodeDirectory) dstInode).getChildren() : null;\n      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n        error \u003d \"rename cannot overwrite non empty destination directory \"\n            + dst;\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "0e796b61e829c4bf763caf13b0f53cb1bcefdeee": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4112. A few improvements on INodeDirectory include adding a utility method for casting; avoiding creation of new empty lists; cleaning up some code and rewriting some javadoc.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1402599 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/10/12 11:08 AM",
      "commitName": "0e796b61e829c4bf763caf13b0f53cb1bcefdeee",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "25/10/12 11:44 AM",
      "commitNameOld": "ba2ee1d7fb91462c861169224d250d2d90bec3a6",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.97,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,161 +1,161 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isLink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     final INode[] dstInodes \u003d new INode[dstComponents.length];\n     rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n-          ((INodeDirectory) dstInode).getChildrenRaw() : null;\n+          ((INodeDirectory) dstInode).getChildren() : null;\n       if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n         error \u003d \"rename cannot overwrite non empty destination directory \"\n             + dst;\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       INode dstChild \u003d null;\n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n           removedSrc, UNKNOWN_DISK_SPACE);\n \n       int filesDeleted \u003d 0;\n       if (dstChild !\u003d null) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n             UNKNOWN_DISK_SPACE);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n             UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isLink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INode[] dstInodes \u003d new INode[dstComponents.length];\n    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n          ((INodeDirectory) dstInode).getChildren() : null;\n      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n        error \u003d \"rename cannot overwrite non empty destination directory \"\n            + dst;\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "10dc6b09272dbf2022907681e134104e7d418021": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1869. mkdirs should use the supplied permission for all of the created directories.  Contributed by Daryn Sharp\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189546 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/10/11 5:02 PM",
      "commitName": "10dc6b09272dbf2022907681e134104e7d418021",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "22/09/11 1:25 AM",
      "commitNameOld": "d773bf0fb57bf6fb77dbdd52e1c186833c17361c",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 34.65,
      "commitsBetweenForRepo": 266,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,161 +1,161 @@\n   boolean unprotectedRenameTo(String src, String dst, long timestamp,\n       Options.Rename... options) throws FileAlreadyExistsException,\n       FileNotFoundException, ParentNotDirectoryException,\n       QuotaExceededException, UnresolvedLinkException, IOException {\n     assert hasWriteLock();\n     boolean overwrite \u003d false;\n     if (null !\u003d options) {\n       for (Rename option : options) {\n         if (option \u003d\u003d Rename.OVERWRITE) {\n           overwrite \u003d true;\n         }\n       }\n     }\n     String error \u003d null;\n     final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n     final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n     // validate source\n     if (srcInode \u003d\u003d null) {\n       error \u003d \"rename source \" + src + \" is not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (srcInodes.length \u003d\u003d 1) {\n       error \u003d \"rename source cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n \n     // validate the destination\n     if (dst.equals(src)) {\n       throw new FileAlreadyExistsException(\n           \"The source \"+src+\" and destination \"+dst+\" are the same\");\n     }\n     if (srcInode.isLink() \u0026\u0026 \n         dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n       throw new FileAlreadyExistsException(\n           \"Cannot rename symlink \"+src+\" to its target \"+dst);\n     }\n     // dst cannot be a directory or a file under src\n     if (dst.startsWith(src) \u0026\u0026 \n         dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n       error \u003d \"Rename destination \" + dst\n           + \" is a directory or file under source \" + src;\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n     final INode[] dstInodes \u003d new INode[dstComponents.length];\n     rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n     INode dstInode \u003d dstInodes[dstInodes.length - 1];\n     if (dstInodes.length \u003d\u003d 1) {\n       error \u003d \"rename destination cannot be the root\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     if (dstInode !\u003d null) { // Destination exists\n       // It\u0027s OK to rename a file to a symlink and vice versa\n       if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n         error \u003d \"Source \" + src + \" and destination \" + dst\n             + \" must both be directories\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n       if (!overwrite) { // If destination exists, overwrite flag must be true\n         error \u003d \"rename destination \" + dst + \" already exists\";\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new FileAlreadyExistsException(error);\n       }\n       List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n           ((INodeDirectory) dstInode).getChildrenRaw() : null;\n       if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n         error \u003d \"rename cannot overwrite non empty destination directory \"\n             + dst;\n         NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n             + error);\n         throw new IOException(error);\n       }\n     }\n     if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n       error \u003d \"rename destination parent \" + dst + \" not found.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new FileNotFoundException(error);\n     }\n     if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n       error \u003d \"rename destination parent \" + dst + \" is a file.\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new ParentNotDirectoryException(error);\n     }\n \n     // Ensure dst has quota to accommodate rename\n     verifyQuotaForRename(srcInodes, dstInodes);\n     INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n     if (removedSrc \u003d\u003d null) {\n       error \u003d \"Failed to rename \" + src + \" to \" + dst\n           + \" because the source can not be removed\";\n       NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n           + error);\n       throw new IOException(error);\n     }\n     final String srcChildName \u003d removedSrc.getLocalName();\n     String dstChildName \u003d null;\n     INode removedDst \u003d null;\n     try {\n       if (dstInode !\u003d null) { // dst exists remove it\n         removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n         dstChildName \u003d removedDst.getLocalName();\n       }\n \n       INode dstChild \u003d null;\n       removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n       // add src as dst to complete rename\n       dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n-          removedSrc, UNKNOWN_DISK_SPACE, false);\n+          removedSrc, UNKNOWN_DISK_SPACE);\n \n       int filesDeleted \u003d 0;\n       if (dstChild !\u003d null) {\n         removedSrc \u003d null;\n         if (NameNode.stateChangeLog.isDebugEnabled()) {\n           NameNode.stateChangeLog.debug(\n               \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n               + \" is renamed to \" + dst);\n         }\n         srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n         dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n \n         // Collect the blocks and remove the lease for previous dst\n         if (removedDst !\u003d null) {\n           INode rmdst \u003d removedDst;\n           removedDst \u003d null;\n           List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n           filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n           getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n         }\n         return filesDeleted \u003e0;\n       }\n     } finally {\n       if (removedSrc !\u003d null) {\n         // Rename failed - restore src\n         removedSrc.setLocalName(srcChildName);\n         addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n-            UNKNOWN_DISK_SPACE, false);\n+            UNKNOWN_DISK_SPACE);\n       }\n       if (removedDst !\u003d null) {\n         // Rename failed - restore dst\n         removedDst.setLocalName(dstChildName);\n         addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n-            UNKNOWN_DISK_SPACE, false);\n+            UNKNOWN_DISK_SPACE);\n       }\n     }\n     NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n         + \"failed to rename \" + src + \" to \" + dst);\n     throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isLink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INode[] dstInodes \u003d new INode[dstComponents.length];\n    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n          ((INodeDirectory) dstInode).getChildrenRaw() : null;\n      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n        error \u003d \"rename cannot overwrite non empty destination directory \"\n            + dst;\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isLink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INode[] dstInodes \u003d new INode[dstComponents.length];\n    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n          ((INodeDirectory) dstInode).getChildrenRaw() : null;\n      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n        error \u003d \"rename cannot overwrite non empty destination directory \"\n            + dst;\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE, false);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE, false);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE, false);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isLink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INode[] dstInodes \u003d new INode[dstComponents.length];\n    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n          ((INodeDirectory) dstInode).getChildrenRaw() : null;\n      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n        error \u003d \"rename cannot overwrite non empty destination directory \"\n            + dst;\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE, false);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE, false);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE, false);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,161 @@\n+  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n+      Options.Rename... options) throws FileAlreadyExistsException,\n+      FileNotFoundException, ParentNotDirectoryException,\n+      QuotaExceededException, UnresolvedLinkException, IOException {\n+    assert hasWriteLock();\n+    boolean overwrite \u003d false;\n+    if (null !\u003d options) {\n+      for (Rename option : options) {\n+        if (option \u003d\u003d Rename.OVERWRITE) {\n+          overwrite \u003d true;\n+        }\n+      }\n+    }\n+    String error \u003d null;\n+    final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n+    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n+    // validate source\n+    if (srcInode \u003d\u003d null) {\n+      error \u003d \"rename source \" + src + \" is not found.\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + error);\n+      throw new FileNotFoundException(error);\n+    }\n+    if (srcInodes.length \u003d\u003d 1) {\n+      error \u003d \"rename source cannot be the root\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + error);\n+      throw new IOException(error);\n+    }\n+\n+    // validate the destination\n+    if (dst.equals(src)) {\n+      throw new FileAlreadyExistsException(\n+          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n+    }\n+    if (srcInode.isLink() \u0026\u0026 \n+        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n+      throw new FileAlreadyExistsException(\n+          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n+    }\n+    // dst cannot be a directory or a file under src\n+    if (dst.startsWith(src) \u0026\u0026 \n+        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n+      error \u003d \"Rename destination \" + dst\n+          + \" is a directory or file under source \" + src;\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + error);\n+      throw new IOException(error);\n+    }\n+    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n+    final INode[] dstInodes \u003d new INode[dstComponents.length];\n+    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n+    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n+    if (dstInodes.length \u003d\u003d 1) {\n+      error \u003d \"rename destination cannot be the root\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + error);\n+      throw new IOException(error);\n+    }\n+    if (dstInode !\u003d null) { // Destination exists\n+      // It\u0027s OK to rename a file to a symlink and vice versa\n+      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n+        error \u003d \"Source \" + src + \" and destination \" + dst\n+            + \" must both be directories\";\n+        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+            + error);\n+        throw new IOException(error);\n+      }\n+      if (!overwrite) { // If destination exists, overwrite flag must be true\n+        error \u003d \"rename destination \" + dst + \" already exists\";\n+        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+            + error);\n+        throw new FileAlreadyExistsException(error);\n+      }\n+      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n+          ((INodeDirectory) dstInode).getChildrenRaw() : null;\n+      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n+        error \u003d \"rename cannot overwrite non empty destination directory \"\n+            + dst;\n+        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+            + error);\n+        throw new IOException(error);\n+      }\n+    }\n+    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n+      error \u003d \"rename destination parent \" + dst + \" not found.\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + error);\n+      throw new FileNotFoundException(error);\n+    }\n+    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n+      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + error);\n+      throw new ParentNotDirectoryException(error);\n+    }\n+\n+    // Ensure dst has quota to accommodate rename\n+    verifyQuotaForRename(srcInodes, dstInodes);\n+    INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n+    if (removedSrc \u003d\u003d null) {\n+      error \u003d \"Failed to rename \" + src + \" to \" + dst\n+          + \" because the source can not be removed\";\n+      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+          + error);\n+      throw new IOException(error);\n+    }\n+    final String srcChildName \u003d removedSrc.getLocalName();\n+    String dstChildName \u003d null;\n+    INode removedDst \u003d null;\n+    try {\n+      if (dstInode !\u003d null) { // dst exists remove it\n+        removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n+        dstChildName \u003d removedDst.getLocalName();\n+      }\n+\n+      INode dstChild \u003d null;\n+      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n+      // add src as dst to complete rename\n+      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n+          removedSrc, UNKNOWN_DISK_SPACE, false);\n+\n+      int filesDeleted \u003d 0;\n+      if (dstChild !\u003d null) {\n+        removedSrc \u003d null;\n+        if (NameNode.stateChangeLog.isDebugEnabled()) {\n+          NameNode.stateChangeLog.debug(\n+              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n+              + \" is renamed to \" + dst);\n+        }\n+        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n+        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n+\n+        // Collect the blocks and remove the lease for previous dst\n+        if (removedDst !\u003d null) {\n+          INode rmdst \u003d removedDst;\n+          removedDst \u003d null;\n+          List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n+          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n+          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n+        }\n+        return filesDeleted \u003e0;\n+      }\n+    } finally {\n+      if (removedSrc !\u003d null) {\n+        // Rename failed - restore src\n+        removedSrc.setLocalName(srcChildName);\n+        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n+            UNKNOWN_DISK_SPACE, false);\n+      }\n+      if (removedDst !\u003d null) {\n+        // Rename failed - restore dst\n+        removedDst.setLocalName(dstChildName);\n+        addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n+            UNKNOWN_DISK_SPACE, false);\n+      }\n+    }\n+    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n+        + \"failed to rename \" + src + \" to \" + dst);\n+    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  boolean unprotectedRenameTo(String src, String dst, long timestamp,\n      Options.Rename... options) throws FileAlreadyExistsException,\n      FileNotFoundException, ParentNotDirectoryException,\n      QuotaExceededException, UnresolvedLinkException, IOException {\n    assert hasWriteLock();\n    boolean overwrite \u003d false;\n    if (null !\u003d options) {\n      for (Rename option : options) {\n        if (option \u003d\u003d Rename.OVERWRITE) {\n          overwrite \u003d true;\n        }\n      }\n    }\n    String error \u003d null;\n    final INode[] srcInodes \u003d rootDir.getExistingPathINodes(src, false);\n    final INode srcInode \u003d srcInodes[srcInodes.length - 1];\n    // validate source\n    if (srcInode \u003d\u003d null) {\n      error \u003d \"rename source \" + src + \" is not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (srcInodes.length \u003d\u003d 1) {\n      error \u003d \"rename source cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n\n    // validate the destination\n    if (dst.equals(src)) {\n      throw new FileAlreadyExistsException(\n          \"The source \"+src+\" and destination \"+dst+\" are the same\");\n    }\n    if (srcInode.isLink() \u0026\u0026 \n        dst.equals(((INodeSymlink)srcInode).getLinkValue())) {\n      throw new FileAlreadyExistsException(\n          \"Cannot rename symlink \"+src+\" to its target \"+dst);\n    }\n    // dst cannot be a directory or a file under src\n    if (dst.startsWith(src) \u0026\u0026 \n        dst.charAt(src.length()) \u003d\u003d Path.SEPARATOR_CHAR) {\n      error \u003d \"Rename destination \" + dst\n          + \" is a directory or file under source \" + src;\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final byte[][] dstComponents \u003d INode.getPathComponents(dst);\n    final INode[] dstInodes \u003d new INode[dstComponents.length];\n    rootDir.getExistingPathINodes(dstComponents, dstInodes, false);\n    INode dstInode \u003d dstInodes[dstInodes.length - 1];\n    if (dstInodes.length \u003d\u003d 1) {\n      error \u003d \"rename destination cannot be the root\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    if (dstInode !\u003d null) { // Destination exists\n      // It\u0027s OK to rename a file to a symlink and vice versa\n      if (dstInode.isDirectory() !\u003d srcInode.isDirectory()) {\n        error \u003d \"Source \" + src + \" and destination \" + dst\n            + \" must both be directories\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n      if (!overwrite) { // If destination exists, overwrite flag must be true\n        error \u003d \"rename destination \" + dst + \" already exists\";\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new FileAlreadyExistsException(error);\n      }\n      List\u003cINode\u003e children \u003d dstInode.isDirectory() ? \n          ((INodeDirectory) dstInode).getChildrenRaw() : null;\n      if (children !\u003d null \u0026\u0026 children.size() !\u003d 0) {\n        error \u003d \"rename cannot overwrite non empty destination directory \"\n            + dst;\n        NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n            + error);\n        throw new IOException(error);\n      }\n    }\n    if (dstInodes[dstInodes.length - 2] \u003d\u003d null) {\n      error \u003d \"rename destination parent \" + dst + \" not found.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new FileNotFoundException(error);\n    }\n    if (!dstInodes[dstInodes.length - 2].isDirectory()) {\n      error \u003d \"rename destination parent \" + dst + \" is a file.\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new ParentNotDirectoryException(error);\n    }\n\n    // Ensure dst has quota to accommodate rename\n    verifyQuotaForRename(srcInodes, dstInodes);\n    INode removedSrc \u003d removeChild(srcInodes, srcInodes.length - 1);\n    if (removedSrc \u003d\u003d null) {\n      error \u003d \"Failed to rename \" + src + \" to \" + dst\n          + \" because the source can not be removed\";\n      NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n          + error);\n      throw new IOException(error);\n    }\n    final String srcChildName \u003d removedSrc.getLocalName();\n    String dstChildName \u003d null;\n    INode removedDst \u003d null;\n    try {\n      if (dstInode !\u003d null) { // dst exists remove it\n        removedDst \u003d removeChild(dstInodes, dstInodes.length - 1);\n        dstChildName \u003d removedDst.getLocalName();\n      }\n\n      INode dstChild \u003d null;\n      removedSrc.setLocalName(dstComponents[dstInodes.length - 1]);\n      // add src as dst to complete rename\n      dstChild \u003d addChildNoQuotaCheck(dstInodes, dstInodes.length - 1,\n          removedSrc, UNKNOWN_DISK_SPACE, false);\n\n      int filesDeleted \u003d 0;\n      if (dstChild !\u003d null) {\n        removedSrc \u003d null;\n        if (NameNode.stateChangeLog.isDebugEnabled()) {\n          NameNode.stateChangeLog.debug(\n              \"DIR* FSDirectory.unprotectedRenameTo: \" + src\n              + \" is renamed to \" + dst);\n        }\n        srcInodes[srcInodes.length - 2].setModificationTime(timestamp);\n        dstInodes[dstInodes.length - 2].setModificationTime(timestamp);\n\n        // Collect the blocks and remove the lease for previous dst\n        if (removedDst !\u003d null) {\n          INode rmdst \u003d removedDst;\n          removedDst \u003d null;\n          List\u003cBlock\u003e collectedBlocks \u003d new ArrayList\u003cBlock\u003e();\n          filesDeleted \u003d rmdst.collectSubtreeBlocksAndClear(collectedBlocks);\n          getFSNamesystem().removePathAndBlocks(src, collectedBlocks);\n        }\n        return filesDeleted \u003e0;\n      }\n    } finally {\n      if (removedSrc !\u003d null) {\n        // Rename failed - restore src\n        removedSrc.setLocalName(srcChildName);\n        addChildNoQuotaCheck(srcInodes, srcInodes.length - 1, removedSrc, \n            UNKNOWN_DISK_SPACE, false);\n      }\n      if (removedDst !\u003d null) {\n        // Rename failed - restore dst\n        removedDst.setLocalName(dstChildName);\n        addChildNoQuotaCheck(dstInodes, dstInodes.length - 1, removedDst, \n            UNKNOWN_DISK_SPACE, false);\n      }\n    }\n    NameNode.stateChangeLog.warn(\"DIR* FSDirectory.unprotectedRenameTo: \"\n        + \"failed to rename \" + src + \" to \" + dst);\n    throw new IOException(\"rename from \" + src + \" to \" + dst + \" failed.\");\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java"
    }
  }
}