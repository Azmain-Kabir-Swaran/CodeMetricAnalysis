{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractCSQueue.java",
  "functionName": "getCurrentLimitResource",
  "functionId": "getCurrentLimitResource___nodePartition-String__clusterResource-Resource__currentResourceLimits-ResourceLimits__schedulingMode-SchedulingMode",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
  "functionStartLine": 1005,
  "functionEndLine": 1027,
  "numCommitsSeen": 101,
  "timeTaken": 6008,
  "changeHistory": [
    "5e798b1a0ddceeaf54703b94052501867156e979",
    "ec06957941367930c855b5e05e6a84ba676fd46a",
    "ae14e5d07f1b6702a5160637438028bb03d9387e",
    "fa7a43529d529f0006c8033c2003f15b9b93f103",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
    "487374b7fe0c92fc7eb1406c568952722b5d5b15",
    "14dd647c556016d351f425ee956ccf800ccb9ce2"
  ],
  "changeHistoryShort": {
    "5e798b1a0ddceeaf54703b94052501867156e979": "Ybodychange",
    "ec06957941367930c855b5e05e6a84ba676fd46a": "Ybodychange",
    "ae14e5d07f1b6702a5160637438028bb03d9387e": "Ybodychange",
    "fa7a43529d529f0006c8033c2003f15b9b93f103": "Ybodychange",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": "Ybodychange",
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5": "Ymultichange(Yparameterchange,Ybodychange)",
    "487374b7fe0c92fc7eb1406c568952722b5d5b15": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
    "14dd647c556016d351f425ee956ccf800ccb9ce2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5e798b1a0ddceeaf54703b94052501867156e979": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6471. Support to add min/max resource configuration for a queue. (Sunil G via wangda)\n\nChange-Id: I9213f5297a6841fab5c573e85ee4c4e5f4a0b7ff\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/11/17 11:25 AM",
      "commitNameOld": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 21.31,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n   private Resource getCurrentLimitResource(String nodePartition,\n       Resource clusterResource, ResourceLimits currentResourceLimits,\n       SchedulingMode schedulingMode) {\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       /*\n        * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n        * (TODO, this part need update when we support labeled-limit) For\n        * non-labeled resource: limit \u003d min(queue-max-resource,\n        * limit-set-by-parent)\n        */\n       Resource queueMaxResource \u003d\n-          getQueueMaxResource(nodePartition, clusterResource);\n+          getQueueMaxResource(nodePartition);\n \n       return Resources.min(resourceCalculator, clusterResource,\n           queueMaxResource, currentResourceLimits.getLimit());\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // When we doing non-exclusive resource allocation, maximum capacity of\n       // all queues on this label equals to total resource with the label.\n       return labelManager.getResourceByLabel(nodePartition, clusterResource);\n     }\n     \n     return Resources.none();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource getCurrentLimitResource(String nodePartition,\n      Resource clusterResource, ResourceLimits currentResourceLimits,\n      SchedulingMode schedulingMode) {\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      /*\n       * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n       * (TODO, this part need update when we support labeled-limit) For\n       * non-labeled resource: limit \u003d min(queue-max-resource,\n       * limit-set-by-parent)\n       */\n      Resource queueMaxResource \u003d\n          getQueueMaxResource(nodePartition);\n\n      return Resources.min(resourceCalculator, clusterResource,\n          queueMaxResource, currentResourceLimits.getLimit());\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // When we doing non-exclusive resource allocation, maximum capacity of\n      // all queues on this label equals to total resource with the label.\n      return labelManager.getResourceByLabel(nodePartition, clusterResource);\n    }\n    \n    return Resources.none();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "ec06957941367930c855b5e05e6a84ba676fd46a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3215. Respect labels in CapacityScheduler when computing headroom. (Naganarasimha G R via wangda)\n",
      "commitDate": "08/04/16 3:33 PM",
      "commitName": "ec06957941367930c855b5e05e6a84ba676fd46a",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "05/04/16 4:24 PM",
      "commitNameOld": "21eb4284487d6f8e4beedb8a0c3168e952f224fc",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 2.96,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,23 @@\n   private Resource getCurrentLimitResource(String nodePartition,\n       Resource clusterResource, ResourceLimits currentResourceLimits,\n       SchedulingMode schedulingMode) {\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       /*\n        * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n        * (TODO, this part need update when we support labeled-limit) For\n        * non-labeled resource: limit \u003d min(queue-max-resource,\n        * limit-set-by-parent)\n        */\n       Resource queueMaxResource \u003d\n-          Resources.multiplyAndNormalizeDown(resourceCalculator,\n-              labelManager.getResourceByLabel(nodePartition, clusterResource),\n-              queueCapacities.getAbsoluteMaximumCapacity(nodePartition), minimumAllocation);\n+          getQueueMaxResource(nodePartition, clusterResource);\n+\n       return Resources.min(resourceCalculator, clusterResource,\n           queueMaxResource, currentResourceLimits.getLimit());\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // When we doing non-exclusive resource allocation, maximum capacity of\n       // all queues on this label equals to total resource with the label.\n       return labelManager.getResourceByLabel(nodePartition, clusterResource);\n     }\n     \n     return Resources.none();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource getCurrentLimitResource(String nodePartition,\n      Resource clusterResource, ResourceLimits currentResourceLimits,\n      SchedulingMode schedulingMode) {\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      /*\n       * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n       * (TODO, this part need update when we support labeled-limit) For\n       * non-labeled resource: limit \u003d min(queue-max-resource,\n       * limit-set-by-parent)\n       */\n      Resource queueMaxResource \u003d\n          getQueueMaxResource(nodePartition, clusterResource);\n\n      return Resources.min(resourceCalculator, clusterResource,\n          queueMaxResource, currentResourceLimits.getLimit());\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // When we doing non-exclusive resource allocation, maximum capacity of\n      // all queues on this label equals to total resource with the label.\n      return labelManager.getResourceByLabel(nodePartition, clusterResource);\n    }\n    \n    return Resources.none();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "ae14e5d07f1b6702a5160637438028bb03d9387e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4108. CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n\n(cherry picked from commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913)\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 5:02 PM",
      "commitNameOld": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,24 @@\n   private Resource getCurrentLimitResource(String nodePartition,\n       Resource clusterResource, ResourceLimits currentResourceLimits,\n       SchedulingMode schedulingMode) {\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       /*\n        * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n        * (TODO, this part need update when we support labeled-limit) For\n        * non-labeled resource: limit \u003d min(queue-max-resource,\n        * limit-set-by-parent)\n        */\n       Resource queueMaxResource \u003d\n           Resources.multiplyAndNormalizeDown(resourceCalculator,\n               labelManager.getResourceByLabel(nodePartition, clusterResource),\n               queueCapacities.getAbsoluteMaximumCapacity(nodePartition), minimumAllocation);\n-      if (nodePartition.equals(RMNodeLabelsManager.NO_LABEL)) {\n-        return Resources.min(resourceCalculator, clusterResource,\n-            queueMaxResource, currentResourceLimits.getLimit());\n-      }\n-      return queueMaxResource;  \n+      return Resources.min(resourceCalculator, clusterResource,\n+          queueMaxResource, currentResourceLimits.getLimit());\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // When we doing non-exclusive resource allocation, maximum capacity of\n       // all queues on this label equals to total resource with the label.\n       return labelManager.getResourceByLabel(nodePartition, clusterResource);\n     }\n     \n     return Resources.none();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource getCurrentLimitResource(String nodePartition,\n      Resource clusterResource, ResourceLimits currentResourceLimits,\n      SchedulingMode schedulingMode) {\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      /*\n       * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n       * (TODO, this part need update when we support labeled-limit) For\n       * non-labeled resource: limit \u003d min(queue-max-resource,\n       * limit-set-by-parent)\n       */\n      Resource queueMaxResource \u003d\n          Resources.multiplyAndNormalizeDown(resourceCalculator,\n              labelManager.getResourceByLabel(nodePartition, clusterResource),\n              queueCapacities.getAbsoluteMaximumCapacity(nodePartition), minimumAllocation);\n      return Resources.min(resourceCalculator, clusterResource,\n          queueMaxResource, currentResourceLimits.getLimit());\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // When we doing non-exclusive resource allocation, maximum capacity of\n      // all queues on this label equals to total resource with the label.\n      return labelManager.getResourceByLabel(nodePartition, clusterResource);\n    }\n    \n    return Resources.none();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "fa7a43529d529f0006c8033c2003f15b9b93f103": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\"\n\nThis reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 4:59 PM",
      "commitNameOld": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,27 @@\n   private Resource getCurrentLimitResource(String nodePartition,\n       Resource clusterResource, ResourceLimits currentResourceLimits,\n       SchedulingMode schedulingMode) {\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       /*\n        * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n        * (TODO, this part need update when we support labeled-limit) For\n        * non-labeled resource: limit \u003d min(queue-max-resource,\n        * limit-set-by-parent)\n        */\n       Resource queueMaxResource \u003d\n           Resources.multiplyAndNormalizeDown(resourceCalculator,\n               labelManager.getResourceByLabel(nodePartition, clusterResource),\n               queueCapacities.getAbsoluteMaximumCapacity(nodePartition), minimumAllocation);\n-      return Resources.min(resourceCalculator, clusterResource,\n-          queueMaxResource, currentResourceLimits.getLimit());\n+      if (nodePartition.equals(RMNodeLabelsManager.NO_LABEL)) {\n+        return Resources.min(resourceCalculator, clusterResource,\n+            queueMaxResource, currentResourceLimits.getLimit());\n+      }\n+      return queueMaxResource;  \n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // When we doing non-exclusive resource allocation, maximum capacity of\n       // all queues on this label equals to total resource with the label.\n       return labelManager.getResourceByLabel(nodePartition, clusterResource);\n     }\n     \n     return Resources.none();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource getCurrentLimitResource(String nodePartition,\n      Resource clusterResource, ResourceLimits currentResourceLimits,\n      SchedulingMode schedulingMode) {\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      /*\n       * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n       * (TODO, this part need update when we support labeled-limit) For\n       * non-labeled resource: limit \u003d min(queue-max-resource,\n       * limit-set-by-parent)\n       */\n      Resource queueMaxResource \u003d\n          Resources.multiplyAndNormalizeDown(resourceCalculator,\n              labelManager.getResourceByLabel(nodePartition, clusterResource),\n              queueCapacities.getAbsoluteMaximumCapacity(nodePartition), minimumAllocation);\n      if (nodePartition.equals(RMNodeLabelsManager.NO_LABEL)) {\n        return Resources.min(resourceCalculator, clusterResource,\n            queueMaxResource, currentResourceLimits.getLimit());\n      }\n      return queueMaxResource;  \n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // When we doing non-exclusive resource allocation, maximum capacity of\n      // all queues on this label equals to total resource with the label.\n      return labelManager.getResourceByLabel(nodePartition, clusterResource);\n    }\n    \n    return Resources.none();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": {
      "type": "Ybodychange",
      "commitMessage": "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n",
      "commitDate": "16/03/16 4:59 PM",
      "commitName": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/01/16 7:11 PM",
      "commitNameOld": "b08ecf5c7589b055e93b2907413213f36097724d",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 58.87,
      "commitsBetweenForRepo": 402,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,24 @@\n   private Resource getCurrentLimitResource(String nodePartition,\n       Resource clusterResource, ResourceLimits currentResourceLimits,\n       SchedulingMode schedulingMode) {\n     if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n       /*\n        * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n        * (TODO, this part need update when we support labeled-limit) For\n        * non-labeled resource: limit \u003d min(queue-max-resource,\n        * limit-set-by-parent)\n        */\n       Resource queueMaxResource \u003d\n           Resources.multiplyAndNormalizeDown(resourceCalculator,\n               labelManager.getResourceByLabel(nodePartition, clusterResource),\n               queueCapacities.getAbsoluteMaximumCapacity(nodePartition), minimumAllocation);\n-      if (nodePartition.equals(RMNodeLabelsManager.NO_LABEL)) {\n-        return Resources.min(resourceCalculator, clusterResource,\n-            queueMaxResource, currentResourceLimits.getLimit());\n-      }\n-      return queueMaxResource;  \n+      return Resources.min(resourceCalculator, clusterResource,\n+          queueMaxResource, currentResourceLimits.getLimit());\n     } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // When we doing non-exclusive resource allocation, maximum capacity of\n       // all queues on this label equals to total resource with the label.\n       return labelManager.getResourceByLabel(nodePartition, clusterResource);\n     }\n     \n     return Resources.none();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Resource getCurrentLimitResource(String nodePartition,\n      Resource clusterResource, ResourceLimits currentResourceLimits,\n      SchedulingMode schedulingMode) {\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      /*\n       * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n       * (TODO, this part need update when we support labeled-limit) For\n       * non-labeled resource: limit \u003d min(queue-max-resource,\n       * limit-set-by-parent)\n       */\n      Resource queueMaxResource \u003d\n          Resources.multiplyAndNormalizeDown(resourceCalculator,\n              labelManager.getResourceByLabel(nodePartition, clusterResource),\n              queueCapacities.getAbsoluteMaximumCapacity(nodePartition), minimumAllocation);\n      return Resources.min(resourceCalculator, clusterResource,\n          queueMaxResource, currentResourceLimits.getLimit());\n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // When we doing non-exclusive resource allocation, maximum capacity of\n      // all queues on this label equals to total resource with the label.\n      return labelManager.getResourceByLabel(nodePartition, clusterResource);\n    }\n    \n    return Resources.none();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
      "extendedDetails": {}
    },
    "0fefda645bca935b87b6bb8ca63e6f18340d59f5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
      "commitDate": "14/04/15 11:45 AM",
      "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
          "commitDate": "14/04/15 11:45 AM",
          "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
          "commitAuthor": "Jian He",
          "commitDateOld": "10/04/15 9:57 AM",
          "commitNameOld": "577d755e4bf72d6adedeba51be01ff5f3f028de0",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 4.08,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,18 +1,27 @@\n-  private Resource getCurrentLimitResource(String nodeLabel,\n-      Resource clusterResource, ResourceLimits currentResourceLimits) {\n-    /*\n-     * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n-     * (TODO, this part need update when we support labeled-limit) For\n-     * non-labeled resource: limit \u003d min(queue-max-resource,\n-     * limit-set-by-parent)\n-     */\n-    Resource queueMaxResource \u003d\n-        Resources.multiplyAndNormalizeDown(resourceCalculator,\n-            labelManager.getResourceByLabel(nodeLabel, clusterResource),\n-            queueCapacities.getAbsoluteMaximumCapacity(nodeLabel), minimumAllocation);\n-    if (nodeLabel.equals(RMNodeLabelsManager.NO_LABEL)) {\n-      return Resources.min(resourceCalculator, clusterResource,\n-          queueMaxResource, currentResourceLimits.getLimit());\n+  private Resource getCurrentLimitResource(String nodePartition,\n+      Resource clusterResource, ResourceLimits currentResourceLimits,\n+      SchedulingMode schedulingMode) {\n+    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n+      /*\n+       * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n+       * (TODO, this part need update when we support labeled-limit) For\n+       * non-labeled resource: limit \u003d min(queue-max-resource,\n+       * limit-set-by-parent)\n+       */\n+      Resource queueMaxResource \u003d\n+          Resources.multiplyAndNormalizeDown(resourceCalculator,\n+              labelManager.getResourceByLabel(nodePartition, clusterResource),\n+              queueCapacities.getAbsoluteMaximumCapacity(nodePartition), minimumAllocation);\n+      if (nodePartition.equals(RMNodeLabelsManager.NO_LABEL)) {\n+        return Resources.min(resourceCalculator, clusterResource,\n+            queueMaxResource, currentResourceLimits.getLimit());\n+      }\n+      return queueMaxResource;  \n+    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n+      // When we doing non-exclusive resource allocation, maximum capacity of\n+      // all queues on this label equals to total resource with the label.\n+      return labelManager.getResourceByLabel(nodePartition, clusterResource);\n     }\n-    return queueMaxResource;\n+    \n+    return Resources.none();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource getCurrentLimitResource(String nodePartition,\n      Resource clusterResource, ResourceLimits currentResourceLimits,\n      SchedulingMode schedulingMode) {\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      /*\n       * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n       * (TODO, this part need update when we support labeled-limit) For\n       * non-labeled resource: limit \u003d min(queue-max-resource,\n       * limit-set-by-parent)\n       */\n      Resource queueMaxResource \u003d\n          Resources.multiplyAndNormalizeDown(resourceCalculator,\n              labelManager.getResourceByLabel(nodePartition, clusterResource),\n              queueCapacities.getAbsoluteMaximumCapacity(nodePartition), minimumAllocation);\n      if (nodePartition.equals(RMNodeLabelsManager.NO_LABEL)) {\n        return Resources.min(resourceCalculator, clusterResource,\n            queueMaxResource, currentResourceLimits.getLimit());\n      }\n      return queueMaxResource;  \n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // When we doing non-exclusive resource allocation, maximum capacity of\n      // all queues on this label equals to total resource with the label.\n      return labelManager.getResourceByLabel(nodePartition, clusterResource);\n    }\n    \n    return Resources.none();\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
          "extendedDetails": {
            "oldValue": "[nodeLabel-String, clusterResource-Resource, currentResourceLimits-ResourceLimits]",
            "newValue": "[nodePartition-String, clusterResource-Resource, currentResourceLimits-ResourceLimits, schedulingMode-SchedulingMode]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3361. CapacityScheduler side changes to support non-exclusive node labels. Contributed by Wangda Tan\n",
          "commitDate": "14/04/15 11:45 AM",
          "commitName": "0fefda645bca935b87b6bb8ca63e6f18340d59f5",
          "commitAuthor": "Jian He",
          "commitDateOld": "10/04/15 9:57 AM",
          "commitNameOld": "577d755e4bf72d6adedeba51be01ff5f3f028de0",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 4.08,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,18 +1,27 @@\n-  private Resource getCurrentLimitResource(String nodeLabel,\n-      Resource clusterResource, ResourceLimits currentResourceLimits) {\n-    /*\n-     * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n-     * (TODO, this part need update when we support labeled-limit) For\n-     * non-labeled resource: limit \u003d min(queue-max-resource,\n-     * limit-set-by-parent)\n-     */\n-    Resource queueMaxResource \u003d\n-        Resources.multiplyAndNormalizeDown(resourceCalculator,\n-            labelManager.getResourceByLabel(nodeLabel, clusterResource),\n-            queueCapacities.getAbsoluteMaximumCapacity(nodeLabel), minimumAllocation);\n-    if (nodeLabel.equals(RMNodeLabelsManager.NO_LABEL)) {\n-      return Resources.min(resourceCalculator, clusterResource,\n-          queueMaxResource, currentResourceLimits.getLimit());\n+  private Resource getCurrentLimitResource(String nodePartition,\n+      Resource clusterResource, ResourceLimits currentResourceLimits,\n+      SchedulingMode schedulingMode) {\n+    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n+      /*\n+       * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n+       * (TODO, this part need update when we support labeled-limit) For\n+       * non-labeled resource: limit \u003d min(queue-max-resource,\n+       * limit-set-by-parent)\n+       */\n+      Resource queueMaxResource \u003d\n+          Resources.multiplyAndNormalizeDown(resourceCalculator,\n+              labelManager.getResourceByLabel(nodePartition, clusterResource),\n+              queueCapacities.getAbsoluteMaximumCapacity(nodePartition), minimumAllocation);\n+      if (nodePartition.equals(RMNodeLabelsManager.NO_LABEL)) {\n+        return Resources.min(resourceCalculator, clusterResource,\n+            queueMaxResource, currentResourceLimits.getLimit());\n+      }\n+      return queueMaxResource;  \n+    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n+      // When we doing non-exclusive resource allocation, maximum capacity of\n+      // all queues on this label equals to total resource with the label.\n+      return labelManager.getResourceByLabel(nodePartition, clusterResource);\n     }\n-    return queueMaxResource;\n+    \n+    return Resources.none();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource getCurrentLimitResource(String nodePartition,\n      Resource clusterResource, ResourceLimits currentResourceLimits,\n      SchedulingMode schedulingMode) {\n    if (schedulingMode \u003d\u003d SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      /*\n       * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n       * (TODO, this part need update when we support labeled-limit) For\n       * non-labeled resource: limit \u003d min(queue-max-resource,\n       * limit-set-by-parent)\n       */\n      Resource queueMaxResource \u003d\n          Resources.multiplyAndNormalizeDown(resourceCalculator,\n              labelManager.getResourceByLabel(nodePartition, clusterResource),\n              queueCapacities.getAbsoluteMaximumCapacity(nodePartition), minimumAllocation);\n      if (nodePartition.equals(RMNodeLabelsManager.NO_LABEL)) {\n        return Resources.min(resourceCalculator, clusterResource,\n            queueMaxResource, currentResourceLimits.getLimit());\n      }\n      return queueMaxResource;  \n    } else if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // When we doing non-exclusive resource allocation, maximum capacity of\n      // all queues on this label equals to total resource with the label.\n      return labelManager.getResourceByLabel(nodePartition, clusterResource);\n    }\n    \n    return Resources.none();\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "487374b7fe0c92fc7eb1406c568952722b5d5b15": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
      "commitDate": "17/03/15 10:24 AM",
      "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
          "commitDate": "17/03/15 10:24 AM",
          "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
          "commitAuthor": "Jian He",
          "commitDateOld": "02/03/15 5:52 PM",
          "commitNameOld": "14dd647c556016d351f425ee956ccf800ccb9ce2",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.65,
          "commitsBetweenForRepo": 118,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,17 +1,18 @@\n-  protected Resource getCurrentResourceLimit(Resource clusterResource,\n-      ResourceLimits currentResourceLimits) {\n+  private Resource getCurrentLimitResource(String nodeLabel,\n+      Resource clusterResource, ResourceLimits currentResourceLimits) {\n     /*\n-     * Queue\u0027s max available resource \u003d min(my.max, my.limit)\n-     * my.limit is set by my parent, considered used resource of my siblings\n+     * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n+     * (TODO, this part need update when we support labeled-limit) For\n+     * non-labeled resource: limit \u003d min(queue-max-resource,\n+     * limit-set-by-parent)\n      */\n     Resource queueMaxResource \u003d\n-        Resources.multiplyAndNormalizeDown(resourceCalculator, clusterResource,\n-            queueCapacities.getAbsoluteMaximumCapacity(), minimumAllocation);\n-    Resource queueCurrentResourceLimit \u003d\n-        Resources.min(resourceCalculator, clusterResource, queueMaxResource,\n-            currentResourceLimits.getLimit());\n-    queueCurrentResourceLimit \u003d\n-        Resources.roundDown(resourceCalculator, queueCurrentResourceLimit,\n-            minimumAllocation);\n-    return queueCurrentResourceLimit;\n+        Resources.multiplyAndNormalizeDown(resourceCalculator,\n+            labelManager.getResourceByLabel(nodeLabel, clusterResource),\n+            queueCapacities.getAbsoluteMaximumCapacity(nodeLabel), minimumAllocation);\n+    if (nodeLabel.equals(RMNodeLabelsManager.NO_LABEL)) {\n+      return Resources.min(resourceCalculator, clusterResource,\n+          queueMaxResource, currentResourceLimits.getLimit());\n+    }\n+    return queueMaxResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource getCurrentLimitResource(String nodeLabel,\n      Resource clusterResource, ResourceLimits currentResourceLimits) {\n    /*\n     * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n     * (TODO, this part need update when we support labeled-limit) For\n     * non-labeled resource: limit \u003d min(queue-max-resource,\n     * limit-set-by-parent)\n     */\n    Resource queueMaxResource \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator,\n            labelManager.getResourceByLabel(nodeLabel, clusterResource),\n            queueCapacities.getAbsoluteMaximumCapacity(nodeLabel), minimumAllocation);\n    if (nodeLabel.equals(RMNodeLabelsManager.NO_LABEL)) {\n      return Resources.min(resourceCalculator, clusterResource,\n          queueMaxResource, currentResourceLimits.getLimit());\n    }\n    return queueMaxResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
          "extendedDetails": {
            "oldValue": "getCurrentResourceLimit",
            "newValue": "getCurrentLimitResource"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
          "commitDate": "17/03/15 10:24 AM",
          "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
          "commitAuthor": "Jian He",
          "commitDateOld": "02/03/15 5:52 PM",
          "commitNameOld": "14dd647c556016d351f425ee956ccf800ccb9ce2",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.65,
          "commitsBetweenForRepo": 118,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,17 +1,18 @@\n-  protected Resource getCurrentResourceLimit(Resource clusterResource,\n-      ResourceLimits currentResourceLimits) {\n+  private Resource getCurrentLimitResource(String nodeLabel,\n+      Resource clusterResource, ResourceLimits currentResourceLimits) {\n     /*\n-     * Queue\u0027s max available resource \u003d min(my.max, my.limit)\n-     * my.limit is set by my parent, considered used resource of my siblings\n+     * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n+     * (TODO, this part need update when we support labeled-limit) For\n+     * non-labeled resource: limit \u003d min(queue-max-resource,\n+     * limit-set-by-parent)\n      */\n     Resource queueMaxResource \u003d\n-        Resources.multiplyAndNormalizeDown(resourceCalculator, clusterResource,\n-            queueCapacities.getAbsoluteMaximumCapacity(), minimumAllocation);\n-    Resource queueCurrentResourceLimit \u003d\n-        Resources.min(resourceCalculator, clusterResource, queueMaxResource,\n-            currentResourceLimits.getLimit());\n-    queueCurrentResourceLimit \u003d\n-        Resources.roundDown(resourceCalculator, queueCurrentResourceLimit,\n-            minimumAllocation);\n-    return queueCurrentResourceLimit;\n+        Resources.multiplyAndNormalizeDown(resourceCalculator,\n+            labelManager.getResourceByLabel(nodeLabel, clusterResource),\n+            queueCapacities.getAbsoluteMaximumCapacity(nodeLabel), minimumAllocation);\n+    if (nodeLabel.equals(RMNodeLabelsManager.NO_LABEL)) {\n+      return Resources.min(resourceCalculator, clusterResource,\n+          queueMaxResource, currentResourceLimits.getLimit());\n+    }\n+    return queueMaxResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource getCurrentLimitResource(String nodeLabel,\n      Resource clusterResource, ResourceLimits currentResourceLimits) {\n    /*\n     * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n     * (TODO, this part need update when we support labeled-limit) For\n     * non-labeled resource: limit \u003d min(queue-max-resource,\n     * limit-set-by-parent)\n     */\n    Resource queueMaxResource \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator,\n            labelManager.getResourceByLabel(nodeLabel, clusterResource),\n            queueCapacities.getAbsoluteMaximumCapacity(nodeLabel), minimumAllocation);\n    if (nodeLabel.equals(RMNodeLabelsManager.NO_LABEL)) {\n      return Resources.min(resourceCalculator, clusterResource,\n          queueMaxResource, currentResourceLimits.getLimit());\n    }\n    return queueMaxResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, currentResourceLimits-ResourceLimits]",
            "newValue": "[nodeLabel-String, clusterResource-Resource, currentResourceLimits-ResourceLimits]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
          "commitDate": "17/03/15 10:24 AM",
          "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
          "commitAuthor": "Jian He",
          "commitDateOld": "02/03/15 5:52 PM",
          "commitNameOld": "14dd647c556016d351f425ee956ccf800ccb9ce2",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.65,
          "commitsBetweenForRepo": 118,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,17 +1,18 @@\n-  protected Resource getCurrentResourceLimit(Resource clusterResource,\n-      ResourceLimits currentResourceLimits) {\n+  private Resource getCurrentLimitResource(String nodeLabel,\n+      Resource clusterResource, ResourceLimits currentResourceLimits) {\n     /*\n-     * Queue\u0027s max available resource \u003d min(my.max, my.limit)\n-     * my.limit is set by my parent, considered used resource of my siblings\n+     * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n+     * (TODO, this part need update when we support labeled-limit) For\n+     * non-labeled resource: limit \u003d min(queue-max-resource,\n+     * limit-set-by-parent)\n      */\n     Resource queueMaxResource \u003d\n-        Resources.multiplyAndNormalizeDown(resourceCalculator, clusterResource,\n-            queueCapacities.getAbsoluteMaximumCapacity(), minimumAllocation);\n-    Resource queueCurrentResourceLimit \u003d\n-        Resources.min(resourceCalculator, clusterResource, queueMaxResource,\n-            currentResourceLimits.getLimit());\n-    queueCurrentResourceLimit \u003d\n-        Resources.roundDown(resourceCalculator, queueCurrentResourceLimit,\n-            minimumAllocation);\n-    return queueCurrentResourceLimit;\n+        Resources.multiplyAndNormalizeDown(resourceCalculator,\n+            labelManager.getResourceByLabel(nodeLabel, clusterResource),\n+            queueCapacities.getAbsoluteMaximumCapacity(nodeLabel), minimumAllocation);\n+    if (nodeLabel.equals(RMNodeLabelsManager.NO_LABEL)) {\n+      return Resources.min(resourceCalculator, clusterResource,\n+          queueMaxResource, currentResourceLimits.getLimit());\n+    }\n+    return queueMaxResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource getCurrentLimitResource(String nodeLabel,\n      Resource clusterResource, ResourceLimits currentResourceLimits) {\n    /*\n     * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n     * (TODO, this part need update when we support labeled-limit) For\n     * non-labeled resource: limit \u003d min(queue-max-resource,\n     * limit-set-by-parent)\n     */\n    Resource queueMaxResource \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator,\n            labelManager.getResourceByLabel(nodeLabel, clusterResource),\n            queueCapacities.getAbsoluteMaximumCapacity(nodeLabel), minimumAllocation);\n    if (nodeLabel.equals(RMNodeLabelsManager.NO_LABEL)) {\n      return Resources.min(resourceCalculator, clusterResource,\n          queueMaxResource, currentResourceLimits.getLimit());\n    }\n    return queueMaxResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
          "commitDate": "17/03/15 10:24 AM",
          "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
          "commitAuthor": "Jian He",
          "commitDateOld": "02/03/15 5:52 PM",
          "commitNameOld": "14dd647c556016d351f425ee956ccf800ccb9ce2",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 14.65,
          "commitsBetweenForRepo": 118,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,17 +1,18 @@\n-  protected Resource getCurrentResourceLimit(Resource clusterResource,\n-      ResourceLimits currentResourceLimits) {\n+  private Resource getCurrentLimitResource(String nodeLabel,\n+      Resource clusterResource, ResourceLimits currentResourceLimits) {\n     /*\n-     * Queue\u0027s max available resource \u003d min(my.max, my.limit)\n-     * my.limit is set by my parent, considered used resource of my siblings\n+     * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n+     * (TODO, this part need update when we support labeled-limit) For\n+     * non-labeled resource: limit \u003d min(queue-max-resource,\n+     * limit-set-by-parent)\n      */\n     Resource queueMaxResource \u003d\n-        Resources.multiplyAndNormalizeDown(resourceCalculator, clusterResource,\n-            queueCapacities.getAbsoluteMaximumCapacity(), minimumAllocation);\n-    Resource queueCurrentResourceLimit \u003d\n-        Resources.min(resourceCalculator, clusterResource, queueMaxResource,\n-            currentResourceLimits.getLimit());\n-    queueCurrentResourceLimit \u003d\n-        Resources.roundDown(resourceCalculator, queueCurrentResourceLimit,\n-            minimumAllocation);\n-    return queueCurrentResourceLimit;\n+        Resources.multiplyAndNormalizeDown(resourceCalculator,\n+            labelManager.getResourceByLabel(nodeLabel, clusterResource),\n+            queueCapacities.getAbsoluteMaximumCapacity(nodeLabel), minimumAllocation);\n+    if (nodeLabel.equals(RMNodeLabelsManager.NO_LABEL)) {\n+      return Resources.min(resourceCalculator, clusterResource,\n+          queueMaxResource, currentResourceLimits.getLimit());\n+    }\n+    return queueMaxResource;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Resource getCurrentLimitResource(String nodeLabel,\n      Resource clusterResource, ResourceLimits currentResourceLimits) {\n    /*\n     * Current limit resource: For labeled resource: limit \u003d queue-max-resource\n     * (TODO, this part need update when we support labeled-limit) For\n     * non-labeled resource: limit \u003d min(queue-max-resource,\n     * limit-set-by-parent)\n     */\n    Resource queueMaxResource \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator,\n            labelManager.getResourceByLabel(nodeLabel, clusterResource),\n            queueCapacities.getAbsoluteMaximumCapacity(nodeLabel), minimumAllocation);\n    if (nodeLabel.equals(RMNodeLabelsManager.NO_LABEL)) {\n      return Resources.min(resourceCalculator, clusterResource,\n          queueMaxResource, currentResourceLimits.getLimit());\n    }\n    return queueMaxResource;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "14dd647c556016d351f425ee956ccf800ccb9ce2": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3265. Fixed a deadlock in CapacityScheduler by always passing a queue\u0027s available resource-limit from the parent queue. Contributed by Wangda Tan.\n",
      "commitDate": "02/03/15 5:52 PM",
      "commitName": "14dd647c556016d351f425ee956ccf800ccb9ce2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,17 @@\n+  protected Resource getCurrentResourceLimit(Resource clusterResource,\n+      ResourceLimits currentResourceLimits) {\n+    /*\n+     * Queue\u0027s max available resource \u003d min(my.max, my.limit)\n+     * my.limit is set by my parent, considered used resource of my siblings\n+     */\n+    Resource queueMaxResource \u003d\n+        Resources.multiplyAndNormalizeDown(resourceCalculator, clusterResource,\n+            queueCapacities.getAbsoluteMaximumCapacity(), minimumAllocation);\n+    Resource queueCurrentResourceLimit \u003d\n+        Resources.min(resourceCalculator, clusterResource, queueMaxResource,\n+            currentResourceLimits.getLimit());\n+    queueCurrentResourceLimit \u003d\n+        Resources.roundDown(resourceCalculator, queueCurrentResourceLimit,\n+            minimumAllocation);\n+    return queueCurrentResourceLimit;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected Resource getCurrentResourceLimit(Resource clusterResource,\n      ResourceLimits currentResourceLimits) {\n    /*\n     * Queue\u0027s max available resource \u003d min(my.max, my.limit)\n     * my.limit is set by my parent, considered used resource of my siblings\n     */\n    Resource queueMaxResource \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator, clusterResource,\n            queueCapacities.getAbsoluteMaximumCapacity(), minimumAllocation);\n    Resource queueCurrentResourceLimit \u003d\n        Resources.min(resourceCalculator, clusterResource, queueMaxResource,\n            currentResourceLimits.getLimit());\n    queueCurrentResourceLimit \u003d\n        Resources.roundDown(resourceCalculator, queueCurrentResourceLimit,\n            minimumAllocation);\n    return queueCurrentResourceLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/AbstractCSQueue.java"
    }
  }
}