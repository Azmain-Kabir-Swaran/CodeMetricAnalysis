{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "create",
  "functionId": "create___f-Path__permission-FsPermission__overwrite-boolean__bufferSize-int__replication-short__blockSize-long__progress-Progressable",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 1653,
  "functionEndLine": 1659,
  "numCommitsSeen": 66,
  "timeTaken": 2747,
  "changeHistory": [
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
    "0d91576ec31f63402f2db6107a04155368e2632d",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82"
  ],
  "changeHistoryShort": {
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": "Ybodychange",
    "0d91576ec31f63402f2db6107a04155368e2632d": "Ybodychange",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
      "commitDate": "08/10/14 2:20 PM",
      "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
      "commitAuthor": "cnauroth",
      "commitDateOld": "19/09/14 11:33 AM",
      "commitNameOld": "9f03a7c018bb2c497cd0ef758f1a3e08e8163d06",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 19.12,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,7 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n-\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Creating file: \" + f.toString());\n-    }\n-\n-    if (containsColon(f)) {\n-      throw new IOException(\"Cannot create file \" + f\n-          + \" through WASB that has colons in the name\");\n-    }\n-\n-    Path absolutePath \u003d makeAbsolute(f);\n-    String key \u003d pathToKey(absolutePath);\n-\n-    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n-    if (existingMetadata !\u003d null) {\n-      if (existingMetadata.isDir()) {\n-        throw new IOException(\"Cannot create file \" + f\n-            + \"; already exists as a directory.\");\n-      }\n-      if (!overwrite) {\n-        throw new IOException(\"File already exists:\" + f);\n-      }\n-    }\n-\n-    Path parentFolder \u003d absolutePath.getParent();\n-    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n-      // Update the parent folder last modified time if the parent folder\n-      // already exists.\n-      String parentKey \u003d pathToKey(parentFolder);\n-      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n-      if (parentMetadata !\u003d null\n-          \u0026\u0026 parentMetadata.isDir()\n-          \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n-        store.updateFolderLastModifiedTime(parentKey);\n-      } else {\n-        // Make sure that the parent folder exists.\n-        mkdirs(parentFolder, permission);\n-      }\n-    }\n-\n-    // Open the output blob stream based on the encoded key.\n-    String keyEncoded \u003d encodeKey(key);\n-\n-    // Mask the permission first (with the default permission mask as well).\n-    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n-    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n-\n-    // First create a blob at the real key, pointing back to the temporary file\n-    // This accomplishes a few things:\n-    // 1. Makes sure we can create a file there.\n-    // 2. Makes it visible to other concurrent threads/processes/nodes what\n-    // we\u0027re\n-    // doing.\n-    // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n-    store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n-\n-    // The key is encoded to point to a common container at the storage server.\n-    // This reduces the number of splits on the server side when load balancing.\n-    // Ingress to Azure storage can take advantage of earlier splits. We remove\n-    // the root path to the key and prefix a random GUID to the tail (or leaf\n-    // filename) of the key. Keys are thus broadly and randomly distributed over\n-    // a single container to ease load balancing on the storage server. When the\n-    // blob is committed it is renamed to its earlier key. Uncommitted blocks\n-    // are not cleaned up and we leave it to Azure storage to garbage collect\n-    // these\n-    // blocks.\n-    OutputStream bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n-        keyEncoded, permissionStatus), key, keyEncoded);\n-\n-    // Construct the data output stream from the buffered output stream.\n-    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n-\n-    \n-    // Increment the counter\n-    instrumentation.fileCreated();\n-    \n-    // Return data output stream to caller.\n-    return fsOut;\n+    return create(f, permission, overwrite, true,\n+        bufferSize, replication, blockSize, progress,\n+        (SelfRenewingLease) null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    return create(f, permission, overwrite, true,\n        bufferSize, replication, blockSize, progress,\n        (SelfRenewingLease) null);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "0d91576ec31f63402f2db6107a04155368e2632d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10728. Metrics system for Windows Azure Storage Filesystem. Contributed by Dexter Bradshaw, Mostafa Elhemali, Xi Fang, Johannes Klein, David Lao, Mike Liddell, Chuan Liu, Lengning Liu, Ivan Mitic, Michael Rys, Alexander Stojanovic, Brian Swan, and Min Wei.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605187 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/06/14 1:52 PM",
      "commitName": "0d91576ec31f63402f2db6107a04155368e2632d",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "20/06/14 11:36 AM",
      "commitNameOld": "61bf9f779919206296d2ce84a8a6b2d912709a59",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 4.09,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,82 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Creating file: \" + f.toString());\n     }\n \n     if (containsColon(f)) {\n       throw new IOException(\"Cannot create file \" + f\n           + \" through WASB that has colons in the name\");\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n     if (existingMetadata !\u003d null) {\n       if (existingMetadata.isDir()) {\n         throw new IOException(\"Cannot create file \" + f\n             + \"; already exists as a directory.\");\n       }\n       if (!overwrite) {\n         throw new IOException(\"File already exists:\" + f);\n       }\n     }\n \n     Path parentFolder \u003d absolutePath.getParent();\n     if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n       // Update the parent folder last modified time if the parent folder\n       // already exists.\n       String parentKey \u003d pathToKey(parentFolder);\n       FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n       if (parentMetadata !\u003d null\n           \u0026\u0026 parentMetadata.isDir()\n           \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n         store.updateFolderLastModifiedTime(parentKey);\n       } else {\n         // Make sure that the parent folder exists.\n         mkdirs(parentFolder, permission);\n       }\n     }\n \n     // Open the output blob stream based on the encoded key.\n     String keyEncoded \u003d encodeKey(key);\n \n     // Mask the permission first (with the default permission mask as well).\n     FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n     PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n \n     // First create a blob at the real key, pointing back to the temporary file\n     // This accomplishes a few things:\n     // 1. Makes sure we can create a file there.\n     // 2. Makes it visible to other concurrent threads/processes/nodes what\n     // we\u0027re\n     // doing.\n     // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n     store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n \n     // The key is encoded to point to a common container at the storage server.\n     // This reduces the number of splits on the server side when load balancing.\n     // Ingress to Azure storage can take advantage of earlier splits. We remove\n     // the root path to the key and prefix a random GUID to the tail (or leaf\n     // filename) of the key. Keys are thus broadly and randomly distributed over\n     // a single container to ease load balancing on the storage server. When the\n     // blob is committed it is renamed to its earlier key. Uncommitted blocks\n     // are not cleaned up and we leave it to Azure storage to garbage collect\n     // these\n     // blocks.\n     OutputStream bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n         keyEncoded, permissionStatus), key, keyEncoded);\n \n     // Construct the data output stream from the buffered output stream.\n     FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n \n+    \n+    // Increment the counter\n+    instrumentation.fileCreated();\n+    \n     // Return data output stream to caller.\n     return fsOut;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Creating file: \" + f.toString());\n    }\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new IOException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new IOException(\"File already exists:\" + f);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null\n          \u0026\u0026 parentMetadata.isDir()\n          \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        store.updateFolderLastModifiedTime(parentKey);\n      } else {\n        // Make sure that the parent folder exists.\n        mkdirs(parentFolder, permission);\n      }\n    }\n\n    // Open the output blob stream based on the encoded key.\n    String keyEncoded \u003d encodeKey(key);\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    // First create a blob at the real key, pointing back to the temporary file\n    // This accomplishes a few things:\n    // 1. Makes sure we can create a file there.\n    // 2. Makes it visible to other concurrent threads/processes/nodes what\n    // we\u0027re\n    // doing.\n    // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n    store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n    // The key is encoded to point to a common container at the storage server.\n    // This reduces the number of splits on the server side when load balancing.\n    // Ingress to Azure storage can take advantage of earlier splits. We remove\n    // the root path to the key and prefix a random GUID to the tail (or leaf\n    // filename) of the key. Keys are thus broadly and randomly distributed over\n    // a single container to ease load balancing on the storage server. When the\n    // blob is committed it is renamed to its earlier key. Uncommitted blocks\n    // are not cleaned up and we leave it to Azure storage to garbage collect\n    // these\n    // blocks.\n    OutputStream bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n        keyEncoded, permissionStatus), key, keyEncoded);\n\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n    \n    // Increment the counter\n    instrumentation.fileCreated();\n    \n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9629. Support Windows Azure Storage - Blob as a file system in Hadoop. Contributed by Dexter Bradshaw, Mostafa Elhemali, Xi Fang, Johannes Klein, David Lao, Mike Liddell, Chuan Liu, Lengning Liu, Ivan Mitic, Michael Rys, Alexander Stojanovic, Brian Swan, and Min Wei.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601781 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/06/14 3:26 PM",
      "commitName": "81bc395deb3ba00567dc067d6ca71bacf9e3bc82",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,78 @@\n+  public FSDataOutputStream create(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize, short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Creating file: \" + f.toString());\n+    }\n+\n+    if (containsColon(f)) {\n+      throw new IOException(\"Cannot create file \" + f\n+          + \" through WASB that has colons in the name\");\n+    }\n+\n+    Path absolutePath \u003d makeAbsolute(f);\n+    String key \u003d pathToKey(absolutePath);\n+\n+    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n+    if (existingMetadata !\u003d null) {\n+      if (existingMetadata.isDir()) {\n+        throw new IOException(\"Cannot create file \" + f\n+            + \"; already exists as a directory.\");\n+      }\n+      if (!overwrite) {\n+        throw new IOException(\"File already exists:\" + f);\n+      }\n+    }\n+\n+    Path parentFolder \u003d absolutePath.getParent();\n+    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n+      // Update the parent folder last modified time if the parent folder\n+      // already exists.\n+      String parentKey \u003d pathToKey(parentFolder);\n+      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n+      if (parentMetadata !\u003d null\n+          \u0026\u0026 parentMetadata.isDir()\n+          \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n+        store.updateFolderLastModifiedTime(parentKey);\n+      } else {\n+        // Make sure that the parent folder exists.\n+        mkdirs(parentFolder, permission);\n+      }\n+    }\n+\n+    // Open the output blob stream based on the encoded key.\n+    String keyEncoded \u003d encodeKey(key);\n+\n+    // Mask the permission first (with the default permission mask as well).\n+    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n+    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n+\n+    // First create a blob at the real key, pointing back to the temporary file\n+    // This accomplishes a few things:\n+    // 1. Makes sure we can create a file there.\n+    // 2. Makes it visible to other concurrent threads/processes/nodes what\n+    // we\u0027re\n+    // doing.\n+    // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n+    store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n+\n+    // The key is encoded to point to a common container at the storage server.\n+    // This reduces the number of splits on the server side when load balancing.\n+    // Ingress to Azure storage can take advantage of earlier splits. We remove\n+    // the root path to the key and prefix a random GUID to the tail (or leaf\n+    // filename) of the key. Keys are thus broadly and randomly distributed over\n+    // a single container to ease load balancing on the storage server. When the\n+    // blob is committed it is renamed to its earlier key. Uncommitted blocks\n+    // are not cleaned up and we leave it to Azure storage to garbage collect\n+    // these\n+    // blocks.\n+    OutputStream bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n+        keyEncoded, permissionStatus), key, keyEncoded);\n+\n+    // Construct the data output stream from the buffered output stream.\n+    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n+\n+    // Return data output stream to caller.\n+    return fsOut;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Creating file: \" + f.toString());\n    }\n\n    if (containsColon(f)) {\n      throw new IOException(\"Cannot create file \" + f\n          + \" through WASB that has colons in the name\");\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata existingMetadata \u003d store.retrieveMetadata(key);\n    if (existingMetadata !\u003d null) {\n      if (existingMetadata.isDir()) {\n        throw new IOException(\"Cannot create file \" + f\n            + \"; already exists as a directory.\");\n      }\n      if (!overwrite) {\n        throw new IOException(\"File already exists:\" + f);\n      }\n    }\n\n    Path parentFolder \u003d absolutePath.getParent();\n    if (parentFolder !\u003d null \u0026\u0026 parentFolder.getParent() !\u003d null) { // skip root\n      // Update the parent folder last modified time if the parent folder\n      // already exists.\n      String parentKey \u003d pathToKey(parentFolder);\n      FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n      if (parentMetadata !\u003d null\n          \u0026\u0026 parentMetadata.isDir()\n          \u0026\u0026 parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Explicit) {\n        store.updateFolderLastModifiedTime(parentKey);\n      } else {\n        // Make sure that the parent folder exists.\n        mkdirs(parentFolder, permission);\n      }\n    }\n\n    // Open the output blob stream based on the encoded key.\n    String keyEncoded \u003d encodeKey(key);\n\n    // Mask the permission first (with the default permission mask as well).\n    FsPermission masked \u003d applyUMask(permission, UMaskApplyMode.NewFile);\n    PermissionStatus permissionStatus \u003d createPermissionStatus(masked);\n\n    // First create a blob at the real key, pointing back to the temporary file\n    // This accomplishes a few things:\n    // 1. Makes sure we can create a file there.\n    // 2. Makes it visible to other concurrent threads/processes/nodes what\n    // we\u0027re\n    // doing.\n    // 3. Makes it easier to restore/cleanup data in the event of us crashing.\n    store.storeEmptyLinkFile(key, keyEncoded, permissionStatus);\n\n    // The key is encoded to point to a common container at the storage server.\n    // This reduces the number of splits on the server side when load balancing.\n    // Ingress to Azure storage can take advantage of earlier splits. We remove\n    // the root path to the key and prefix a random GUID to the tail (or leaf\n    // filename) of the key. Keys are thus broadly and randomly distributed over\n    // a single container to ease load balancing on the storage server. When the\n    // blob is committed it is renamed to its earlier key. Uncommitted blocks\n    // are not cleaned up and we leave it to Azure storage to garbage collect\n    // these\n    // blocks.\n    OutputStream bufOutStream \u003d new NativeAzureFsOutputStream(store.storefile(\n        keyEncoded, permissionStatus), key, keyEncoded);\n\n    // Construct the data output stream from the buffered output stream.\n    FSDataOutputStream fsOut \u003d new FSDataOutputStream(bufOutStream, statistics);\n\n    // Return data output stream to caller.\n    return fsOut;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}