{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NMLogAggregationStatusTracker.java",
  "functionName": "updateLogAggregationStatus",
  "functionId": "updateLogAggregationStatus___appId-ApplicationId__logAggregationStatus-LogAggregationStatus__updateTime-long__diagnosis-String__finalized-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/logaggregation/tracker/NMLogAggregationStatusTracker.java",
  "functionStartLine": 109,
  "functionEndLine": 162,
  "numCommitsSeen": 2,
  "timeTaken": 1465,
  "changeHistory": [
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
    "4bf622043f034835d65ff2a4785b9b06d0ef1fd2"
  ],
  "changeHistoryShort": {
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": "Ybodychange",
    "4bf622043f034835d65ff2a4785b9b06d0ef1fd2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8584. Several typos in Log Aggregation related classes. Contributed by Szilard Nemeth.\n",
      "commitDate": "30/07/18 10:55 AM",
      "commitName": "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "15/03/18 1:26 PM",
      "commitNameOld": "4bf622043f034835d65ff2a4785b9b06d0ef1fd2",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 136.89,
      "commitsBetweenForRepo": 1564,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   public void updateLogAggregationStatus(ApplicationId appId,\n       LogAggregationStatus logAggregationStatus, long updateTime,\n       String diagnosis, boolean finalized) {\n     if (disabled) {\n-      LOG.warn(\"The log aggregation is diabled. No need to update \"\n+      LOG.warn(\"The log aggregation is disabled. No need to update \"\n           + \"the log aggregation status\");\n     }\n     // In NM, each application has exactly one appLogAggregator thread\n     // to handle the log aggregation. So, it is fine which multiple\n     // appLogAggregator thread to update log aggregation status for its\n     // own application. This is why we are using readLocker here.\n     this.readLocker.lock();\n     try {\n       AppLogAggregationStatusForRMRecovery tracker \u003d recoveryStatuses\n           .get(appId);\n       if (tracker \u003d\u003d null) {\n         Application application \u003d this.nmContext.getApplications().get(appId);\n         if (application \u003d\u003d null) {\n           LOG.warn(\"The application:\" + appId + \" has already finished,\"\n               + \" and has been removed from NodeManager, we should not \"\n               + \"receive the log aggregation status update for \"\n               + \"this application.\");\n           return;\n         }\n         AppLogAggregationStatusForRMRecovery newTracker \u003d\n             new AppLogAggregationStatusForRMRecovery(logAggregationStatus,\n                 diagnosis);\n         newTracker.setLastModifiedTime(updateTime);\n         newTracker.setFinalized(finalized);\n         recoveryStatuses.put(appId, newTracker);\n       } else {\n         if (tracker.isFinalized()) {\n           LOG.warn(\"Ignore the log aggregation status update request \"\n               + \"for the application:\" + appId + \". The cached log aggregation \"\n               + \"status is \" + tracker.getLogAggregationStatus() + \".\");\n         } else {\n           if (tracker.getLastModifiedTime() \u003e updateTime) {\n             LOG.warn(\"Ignore the log aggregation status update request \"\n                 + \"for the application:\" + appId + \". The request log \"\n                 + \"aggregation status update is older than the cached \"\n                 + \"log aggregation status.\");\n           } else {\n             tracker.setLogAggregationStatus(logAggregationStatus);\n             tracker.setDiagnosis(diagnosis);\n             tracker.setLastModifiedTime(updateTime);\n             tracker.setFinalized(finalized);\n             recoveryStatuses.put(appId, tracker);\n           }\n         }\n       }\n     } finally {\n       this.readLocker.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateLogAggregationStatus(ApplicationId appId,\n      LogAggregationStatus logAggregationStatus, long updateTime,\n      String diagnosis, boolean finalized) {\n    if (disabled) {\n      LOG.warn(\"The log aggregation is disabled. No need to update \"\n          + \"the log aggregation status\");\n    }\n    // In NM, each application has exactly one appLogAggregator thread\n    // to handle the log aggregation. So, it is fine which multiple\n    // appLogAggregator thread to update log aggregation status for its\n    // own application. This is why we are using readLocker here.\n    this.readLocker.lock();\n    try {\n      AppLogAggregationStatusForRMRecovery tracker \u003d recoveryStatuses\n          .get(appId);\n      if (tracker \u003d\u003d null) {\n        Application application \u003d this.nmContext.getApplications().get(appId);\n        if (application \u003d\u003d null) {\n          LOG.warn(\"The application:\" + appId + \" has already finished,\"\n              + \" and has been removed from NodeManager, we should not \"\n              + \"receive the log aggregation status update for \"\n              + \"this application.\");\n          return;\n        }\n        AppLogAggregationStatusForRMRecovery newTracker \u003d\n            new AppLogAggregationStatusForRMRecovery(logAggregationStatus,\n                diagnosis);\n        newTracker.setLastModifiedTime(updateTime);\n        newTracker.setFinalized(finalized);\n        recoveryStatuses.put(appId, newTracker);\n      } else {\n        if (tracker.isFinalized()) {\n          LOG.warn(\"Ignore the log aggregation status update request \"\n              + \"for the application:\" + appId + \". The cached log aggregation \"\n              + \"status is \" + tracker.getLogAggregationStatus() + \".\");\n        } else {\n          if (tracker.getLastModifiedTime() \u003e updateTime) {\n            LOG.warn(\"Ignore the log aggregation status update request \"\n                + \"for the application:\" + appId + \". The request log \"\n                + \"aggregation status update is older than the cached \"\n                + \"log aggregation status.\");\n          } else {\n            tracker.setLogAggregationStatus(logAggregationStatus);\n            tracker.setDiagnosis(diagnosis);\n            tracker.setLastModifiedTime(updateTime);\n            tracker.setFinalized(finalized);\n            recoveryStatuses.put(appId, tracker);\n          }\n        }\n      }\n    } finally {\n      this.readLocker.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/logaggregation/tracker/NMLogAggregationStatusTracker.java",
      "extendedDetails": {}
    },
    "4bf622043f034835d65ff2a4785b9b06d0ef1fd2": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7952. RM should be able to recover log aggregation status after restart/fail-over. (Xuan Gong via wangda)\n\nChange-Id: I725c9afe64831eda0aa6b0bebdbc79d2dd165707\n",
      "commitDate": "15/03/18 1:26 PM",
      "commitName": "4bf622043f034835d65ff2a4785b9b06d0ef1fd2",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,54 @@\n+  public void updateLogAggregationStatus(ApplicationId appId,\n+      LogAggregationStatus logAggregationStatus, long updateTime,\n+      String diagnosis, boolean finalized) {\n+    if (disabled) {\n+      LOG.warn(\"The log aggregation is diabled. No need to update \"\n+          + \"the log aggregation status\");\n+    }\n+    // In NM, each application has exactly one appLogAggregator thread\n+    // to handle the log aggregation. So, it is fine which multiple\n+    // appLogAggregator thread to update log aggregation status for its\n+    // own application. This is why we are using readLocker here.\n+    this.readLocker.lock();\n+    try {\n+      AppLogAggregationStatusForRMRecovery tracker \u003d recoveryStatuses\n+          .get(appId);\n+      if (tracker \u003d\u003d null) {\n+        Application application \u003d this.nmContext.getApplications().get(appId);\n+        if (application \u003d\u003d null) {\n+          LOG.warn(\"The application:\" + appId + \" has already finished,\"\n+              + \" and has been removed from NodeManager, we should not \"\n+              + \"receive the log aggregation status update for \"\n+              + \"this application.\");\n+          return;\n+        }\n+        AppLogAggregationStatusForRMRecovery newTracker \u003d\n+            new AppLogAggregationStatusForRMRecovery(logAggregationStatus,\n+                diagnosis);\n+        newTracker.setLastModifiedTime(updateTime);\n+        newTracker.setFinalized(finalized);\n+        recoveryStatuses.put(appId, newTracker);\n+      } else {\n+        if (tracker.isFinalized()) {\n+          LOG.warn(\"Ignore the log aggregation status update request \"\n+              + \"for the application:\" + appId + \". The cached log aggregation \"\n+              + \"status is \" + tracker.getLogAggregationStatus() + \".\");\n+        } else {\n+          if (tracker.getLastModifiedTime() \u003e updateTime) {\n+            LOG.warn(\"Ignore the log aggregation status update request \"\n+                + \"for the application:\" + appId + \". The request log \"\n+                + \"aggregation status update is older than the cached \"\n+                + \"log aggregation status.\");\n+          } else {\n+            tracker.setLogAggregationStatus(logAggregationStatus);\n+            tracker.setDiagnosis(diagnosis);\n+            tracker.setLastModifiedTime(updateTime);\n+            tracker.setFinalized(finalized);\n+            recoveryStatuses.put(appId, tracker);\n+          }\n+        }\n+      }\n+    } finally {\n+      this.readLocker.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateLogAggregationStatus(ApplicationId appId,\n      LogAggregationStatus logAggregationStatus, long updateTime,\n      String diagnosis, boolean finalized) {\n    if (disabled) {\n      LOG.warn(\"The log aggregation is diabled. No need to update \"\n          + \"the log aggregation status\");\n    }\n    // In NM, each application has exactly one appLogAggregator thread\n    // to handle the log aggregation. So, it is fine which multiple\n    // appLogAggregator thread to update log aggregation status for its\n    // own application. This is why we are using readLocker here.\n    this.readLocker.lock();\n    try {\n      AppLogAggregationStatusForRMRecovery tracker \u003d recoveryStatuses\n          .get(appId);\n      if (tracker \u003d\u003d null) {\n        Application application \u003d this.nmContext.getApplications().get(appId);\n        if (application \u003d\u003d null) {\n          LOG.warn(\"The application:\" + appId + \" has already finished,\"\n              + \" and has been removed from NodeManager, we should not \"\n              + \"receive the log aggregation status update for \"\n              + \"this application.\");\n          return;\n        }\n        AppLogAggregationStatusForRMRecovery newTracker \u003d\n            new AppLogAggregationStatusForRMRecovery(logAggregationStatus,\n                diagnosis);\n        newTracker.setLastModifiedTime(updateTime);\n        newTracker.setFinalized(finalized);\n        recoveryStatuses.put(appId, newTracker);\n      } else {\n        if (tracker.isFinalized()) {\n          LOG.warn(\"Ignore the log aggregation status update request \"\n              + \"for the application:\" + appId + \". The cached log aggregation \"\n              + \"status is \" + tracker.getLogAggregationStatus() + \".\");\n        } else {\n          if (tracker.getLastModifiedTime() \u003e updateTime) {\n            LOG.warn(\"Ignore the log aggregation status update request \"\n                + \"for the application:\" + appId + \". The request log \"\n                + \"aggregation status update is older than the cached \"\n                + \"log aggregation status.\");\n          } else {\n            tracker.setLogAggregationStatus(logAggregationStatus);\n            tracker.setDiagnosis(diagnosis);\n            tracker.setLastModifiedTime(updateTime);\n            tracker.setFinalized(finalized);\n            recoveryStatuses.put(appId, tracker);\n          }\n        }\n      }\n    } finally {\n      this.readLocker.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/logaggregation/tracker/NMLogAggregationStatusTracker.java"
    }
  }
}