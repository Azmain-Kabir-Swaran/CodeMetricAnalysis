{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ReduceContextImpl.java",
  "functionName": "next",
  "functionId": "next",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java",
  "functionStartLine": 203,
  "functionEndLine": 247,
  "numCommitsSeen": 7,
  "timeTaken": 4693,
  "changeHistory": [
    "98ecd4ffef333cb6703e922de3f1d8512cacefed",
    "c19633da5b0cc190cc64e812ee89c38f28d5a670",
    "53e7aaa6dd61538ac045a5c3a5898a3729938464",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "98ecd4ffef333cb6703e922de3f1d8512cacefed": "Ybodychange",
    "c19633da5b0cc190cc64e812ee89c38f28d5a670": "Ybodychange",
    "53e7aaa6dd61538ac045a5c3a5898a3729938464": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "98ecd4ffef333cb6703e922de3f1d8512cacefed": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5028. Fixed a bug in MapTask that was causing mappers to fail when a large value of io.sort.mb is set. Contributed by Karthik Kambatla.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1576170 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/03/14 6:29 PM",
      "commitName": "98ecd4ffef333cb6703e922de3f1d8512cacefed",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "19/03/13 10:56 AM",
      "commitNameOld": "c19633da5b0cc190cc64e812ee89c38f28d5a670",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 356.31,
      "commitsBetweenForRepo": 2362,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,45 @@\n     public VALUEIN next() {\n       if (inReset) {\n         try {\n           if (backupStore.hasNext()) {\n             backupStore.next();\n             DataInputBuffer next \u003d backupStore.nextValue();\n-            buffer.reset(next.getData(), next.getPosition(), next.getLength());\n+            buffer.reset(next.getData(), next.getPosition(), next.getLength()\n+                - next.getPosition());\n             value \u003d valueDeserializer.deserialize(value);\n             return value;\n           } else {\n             inReset \u003d false;\n             backupStore.exitResetMode();\n             if (clearMarkFlag) {\n               clearMarkFlag \u003d false;\n               isMarked \u003d false;\n             }\n           }\n         } catch (IOException e) {\n           e.printStackTrace();\n           throw new RuntimeException(\"next value iterator failed\", e);\n         }\n       } \n \n       // if this is the first record, we don\u0027t need to advance\n       if (firstValue) {\n         firstValue \u003d false;\n         return value;\n       }\n       // if this isn\u0027t the first record and the next key is different, they\n       // can\u0027t advance it here.\n       if (!nextKeyIsSame) {\n         throw new NoSuchElementException(\"iterate past last value\");\n       }\n       // otherwise, go to the next key/value pair\n       try {\n         nextKeyValue();\n         return value;\n       } catch (IOException ie) {\n         throw new RuntimeException(\"next value iterator failed\", ie);\n       } catch (InterruptedException ie) {\n         // this is bad, but we can\u0027t modify the exception list of java.util\n         throw new RuntimeException(\"next value iterator interrupted\", ie);        \n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public VALUEIN next() {\n      if (inReset) {\n        try {\n          if (backupStore.hasNext()) {\n            backupStore.next();\n            DataInputBuffer next \u003d backupStore.nextValue();\n            buffer.reset(next.getData(), next.getPosition(), next.getLength()\n                - next.getPosition());\n            value \u003d valueDeserializer.deserialize(value);\n            return value;\n          } else {\n            inReset \u003d false;\n            backupStore.exitResetMode();\n            if (clearMarkFlag) {\n              clearMarkFlag \u003d false;\n              isMarked \u003d false;\n            }\n          }\n        } catch (IOException e) {\n          e.printStackTrace();\n          throw new RuntimeException(\"next value iterator failed\", e);\n        }\n      } \n\n      // if this is the first record, we don\u0027t need to advance\n      if (firstValue) {\n        firstValue \u003d false;\n        return value;\n      }\n      // if this isn\u0027t the first record and the next key is different, they\n      // can\u0027t advance it here.\n      if (!nextKeyIsSame) {\n        throw new NoSuchElementException(\"iterate past last value\");\n      }\n      // otherwise, go to the next key/value pair\n      try {\n        nextKeyValue();\n        return value;\n      } catch (IOException ie) {\n        throw new RuntimeException(\"next value iterator failed\", ie);\n      } catch (InterruptedException ie) {\n        // this is bad, but we can\u0027t modify the exception list of java.util\n        throw new RuntimeException(\"next value iterator interrupted\", ie);        \n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java",
      "extendedDetails": {}
    },
    "c19633da5b0cc190cc64e812ee89c38f28d5a670": {
      "type": "Ybodychange",
      "commitMessage": "Reverting MAPREDUCE-5028 (commit 1457918)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1458433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/03/13 10:56 AM",
      "commitName": "c19633da5b0cc190cc64e812ee89c38f28d5a670",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "18/03/13 11:56 AM",
      "commitNameOld": "53e7aaa6dd61538ac045a5c3a5898a3729938464",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,44 @@\n     public VALUEIN next() {\n       if (inReset) {\n         try {\n           if (backupStore.hasNext()) {\n             backupStore.next();\n             DataInputBuffer next \u003d backupStore.nextValue();\n-            buffer.reset(next.getData(), next.getPosition(), next.getLength()\n-                - next.getPosition());\n+            buffer.reset(next.getData(), next.getPosition(), next.getLength());\n             value \u003d valueDeserializer.deserialize(value);\n             return value;\n           } else {\n             inReset \u003d false;\n             backupStore.exitResetMode();\n             if (clearMarkFlag) {\n               clearMarkFlag \u003d false;\n               isMarked \u003d false;\n             }\n           }\n         } catch (IOException e) {\n           e.printStackTrace();\n           throw new RuntimeException(\"next value iterator failed\", e);\n         }\n       } \n \n       // if this is the first record, we don\u0027t need to advance\n       if (firstValue) {\n         firstValue \u003d false;\n         return value;\n       }\n       // if this isn\u0027t the first record and the next key is different, they\n       // can\u0027t advance it here.\n       if (!nextKeyIsSame) {\n         throw new NoSuchElementException(\"iterate past last value\");\n       }\n       // otherwise, go to the next key/value pair\n       try {\n         nextKeyValue();\n         return value;\n       } catch (IOException ie) {\n         throw new RuntimeException(\"next value iterator failed\", ie);\n       } catch (InterruptedException ie) {\n         // this is bad, but we can\u0027t modify the exception list of java.util\n         throw new RuntimeException(\"next value iterator interrupted\", ie);        \n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public VALUEIN next() {\n      if (inReset) {\n        try {\n          if (backupStore.hasNext()) {\n            backupStore.next();\n            DataInputBuffer next \u003d backupStore.nextValue();\n            buffer.reset(next.getData(), next.getPosition(), next.getLength());\n            value \u003d valueDeserializer.deserialize(value);\n            return value;\n          } else {\n            inReset \u003d false;\n            backupStore.exitResetMode();\n            if (clearMarkFlag) {\n              clearMarkFlag \u003d false;\n              isMarked \u003d false;\n            }\n          }\n        } catch (IOException e) {\n          e.printStackTrace();\n          throw new RuntimeException(\"next value iterator failed\", e);\n        }\n      } \n\n      // if this is the first record, we don\u0027t need to advance\n      if (firstValue) {\n        firstValue \u003d false;\n        return value;\n      }\n      // if this isn\u0027t the first record and the next key is different, they\n      // can\u0027t advance it here.\n      if (!nextKeyIsSame) {\n        throw new NoSuchElementException(\"iterate past last value\");\n      }\n      // otherwise, go to the next key/value pair\n      try {\n        nextKeyValue();\n        return value;\n      } catch (IOException ie) {\n        throw new RuntimeException(\"next value iterator failed\", ie);\n      } catch (InterruptedException ie) {\n        // this is bad, but we can\u0027t modify the exception list of java.util\n        throw new RuntimeException(\"next value iterator interrupted\", ie);        \n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java",
      "extendedDetails": {}
    },
    "53e7aaa6dd61538ac045a5c3a5898a3729938464": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5028. Maps fail when io.sort.mb is set to high value. (kkambatl via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1457918 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/03/13 11:56 AM",
      "commitName": "53e7aaa6dd61538ac045a5c3a5898a3729938464",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "20/10/11 10:20 PM",
      "commitNameOld": "5945a05eee63ae8c85593232c2450a5cf259ff36",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 514.57,
      "commitsBetweenForRepo": 3060,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,45 @@\n     public VALUEIN next() {\n       if (inReset) {\n         try {\n           if (backupStore.hasNext()) {\n             backupStore.next();\n             DataInputBuffer next \u003d backupStore.nextValue();\n-            buffer.reset(next.getData(), next.getPosition(), next.getLength());\n+            buffer.reset(next.getData(), next.getPosition(), next.getLength()\n+                - next.getPosition());\n             value \u003d valueDeserializer.deserialize(value);\n             return value;\n           } else {\n             inReset \u003d false;\n             backupStore.exitResetMode();\n             if (clearMarkFlag) {\n               clearMarkFlag \u003d false;\n               isMarked \u003d false;\n             }\n           }\n         } catch (IOException e) {\n           e.printStackTrace();\n           throw new RuntimeException(\"next value iterator failed\", e);\n         }\n       } \n \n       // if this is the first record, we don\u0027t need to advance\n       if (firstValue) {\n         firstValue \u003d false;\n         return value;\n       }\n       // if this isn\u0027t the first record and the next key is different, they\n       // can\u0027t advance it here.\n       if (!nextKeyIsSame) {\n         throw new NoSuchElementException(\"iterate past last value\");\n       }\n       // otherwise, go to the next key/value pair\n       try {\n         nextKeyValue();\n         return value;\n       } catch (IOException ie) {\n         throw new RuntimeException(\"next value iterator failed\", ie);\n       } catch (InterruptedException ie) {\n         // this is bad, but we can\u0027t modify the exception list of java.util\n         throw new RuntimeException(\"next value iterator interrupted\", ie);        \n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public VALUEIN next() {\n      if (inReset) {\n        try {\n          if (backupStore.hasNext()) {\n            backupStore.next();\n            DataInputBuffer next \u003d backupStore.nextValue();\n            buffer.reset(next.getData(), next.getPosition(), next.getLength()\n                - next.getPosition());\n            value \u003d valueDeserializer.deserialize(value);\n            return value;\n          } else {\n            inReset \u003d false;\n            backupStore.exitResetMode();\n            if (clearMarkFlag) {\n              clearMarkFlag \u003d false;\n              isMarked \u003d false;\n            }\n          }\n        } catch (IOException e) {\n          e.printStackTrace();\n          throw new RuntimeException(\"next value iterator failed\", e);\n        }\n      } \n\n      // if this is the first record, we don\u0027t need to advance\n      if (firstValue) {\n        firstValue \u003d false;\n        return value;\n      }\n      // if this isn\u0027t the first record and the next key is different, they\n      // can\u0027t advance it here.\n      if (!nextKeyIsSame) {\n        throw new NoSuchElementException(\"iterate past last value\");\n      }\n      // otherwise, go to the next key/value pair\n      try {\n        nextKeyValue();\n        return value;\n      } catch (IOException ie) {\n        throw new RuntimeException(\"next value iterator failed\", ie);\n      } catch (InterruptedException ie) {\n        // this is bad, but we can\u0027t modify the exception list of java.util\n        throw new RuntimeException(\"next value iterator interrupted\", ie);        \n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public VALUEIN next() {\n      if (inReset) {\n        try {\n          if (backupStore.hasNext()) {\n            backupStore.next();\n            DataInputBuffer next \u003d backupStore.nextValue();\n            buffer.reset(next.getData(), next.getPosition(), next.getLength());\n            value \u003d valueDeserializer.deserialize(value);\n            return value;\n          } else {\n            inReset \u003d false;\n            backupStore.exitResetMode();\n            if (clearMarkFlag) {\n              clearMarkFlag \u003d false;\n              isMarked \u003d false;\n            }\n          }\n        } catch (IOException e) {\n          e.printStackTrace();\n          throw new RuntimeException(\"next value iterator failed\", e);\n        }\n      } \n\n      // if this is the first record, we don\u0027t need to advance\n      if (firstValue) {\n        firstValue \u003d false;\n        return value;\n      }\n      // if this isn\u0027t the first record and the next key is different, they\n      // can\u0027t advance it here.\n      if (!nextKeyIsSame) {\n        throw new NoSuchElementException(\"iterate past last value\");\n      }\n      // otherwise, go to the next key/value pair\n      try {\n        nextKeyValue();\n        return value;\n      } catch (IOException ie) {\n        throw new RuntimeException(\"next value iterator failed\", ie);\n      } catch (InterruptedException ie) {\n        // this is bad, but we can\u0027t modify the exception list of java.util\n        throw new RuntimeException(\"next value iterator interrupted\", ie);        \n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yfilerename",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/08/11 8:02 PM",
      "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public VALUEIN next() {\n      if (inReset) {\n        try {\n          if (backupStore.hasNext()) {\n            backupStore.next();\n            DataInputBuffer next \u003d backupStore.nextValue();\n            buffer.reset(next.getData(), next.getPosition(), next.getLength());\n            value \u003d valueDeserializer.deserialize(value);\n            return value;\n          } else {\n            inReset \u003d false;\n            backupStore.exitResetMode();\n            if (clearMarkFlag) {\n              clearMarkFlag \u003d false;\n              isMarked \u003d false;\n            }\n          }\n        } catch (IOException e) {\n          e.printStackTrace();\n          throw new RuntimeException(\"next value iterator failed\", e);\n        }\n      } \n\n      // if this is the first record, we don\u0027t need to advance\n      if (firstValue) {\n        firstValue \u003d false;\n        return value;\n      }\n      // if this isn\u0027t the first record and the next key is different, they\n      // can\u0027t advance it here.\n      if (!nextKeyIsSame) {\n        throw new NoSuchElementException(\"iterate past last value\");\n      }\n      // otherwise, go to the next key/value pair\n      try {\n        nextKeyValue();\n        return value;\n      } catch (IOException ie) {\n        throw new RuntimeException(\"next value iterator failed\", ie);\n      } catch (InterruptedException ie) {\n        // this is bad, but we can\u0027t modify the exception list of java.util\n        throw new RuntimeException(\"next value iterator interrupted\", ie);        \n      }\n    }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java",
      "extendedDetails": {
        "oldPath": "mapreduce/src/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java",
        "newPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,44 @@\n+    public VALUEIN next() {\n+      if (inReset) {\n+        try {\n+          if (backupStore.hasNext()) {\n+            backupStore.next();\n+            DataInputBuffer next \u003d backupStore.nextValue();\n+            buffer.reset(next.getData(), next.getPosition(), next.getLength());\n+            value \u003d valueDeserializer.deserialize(value);\n+            return value;\n+          } else {\n+            inReset \u003d false;\n+            backupStore.exitResetMode();\n+            if (clearMarkFlag) {\n+              clearMarkFlag \u003d false;\n+              isMarked \u003d false;\n+            }\n+          }\n+        } catch (IOException e) {\n+          e.printStackTrace();\n+          throw new RuntimeException(\"next value iterator failed\", e);\n+        }\n+      } \n+\n+      // if this is the first record, we don\u0027t need to advance\n+      if (firstValue) {\n+        firstValue \u003d false;\n+        return value;\n+      }\n+      // if this isn\u0027t the first record and the next key is different, they\n+      // can\u0027t advance it here.\n+      if (!nextKeyIsSame) {\n+        throw new NoSuchElementException(\"iterate past last value\");\n+      }\n+      // otherwise, go to the next key/value pair\n+      try {\n+        nextKeyValue();\n+        return value;\n+      } catch (IOException ie) {\n+        throw new RuntimeException(\"next value iterator failed\", ie);\n+      } catch (InterruptedException ie) {\n+        // this is bad, but we can\u0027t modify the exception list of java.util\n+        throw new RuntimeException(\"next value iterator interrupted\", ie);        \n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public VALUEIN next() {\n      if (inReset) {\n        try {\n          if (backupStore.hasNext()) {\n            backupStore.next();\n            DataInputBuffer next \u003d backupStore.nextValue();\n            buffer.reset(next.getData(), next.getPosition(), next.getLength());\n            value \u003d valueDeserializer.deserialize(value);\n            return value;\n          } else {\n            inReset \u003d false;\n            backupStore.exitResetMode();\n            if (clearMarkFlag) {\n              clearMarkFlag \u003d false;\n              isMarked \u003d false;\n            }\n          }\n        } catch (IOException e) {\n          e.printStackTrace();\n          throw new RuntimeException(\"next value iterator failed\", e);\n        }\n      } \n\n      // if this is the first record, we don\u0027t need to advance\n      if (firstValue) {\n        firstValue \u003d false;\n        return value;\n      }\n      // if this isn\u0027t the first record and the next key is different, they\n      // can\u0027t advance it here.\n      if (!nextKeyIsSame) {\n        throw new NoSuchElementException(\"iterate past last value\");\n      }\n      // otherwise, go to the next key/value pair\n      try {\n        nextKeyValue();\n        return value;\n      } catch (IOException ie) {\n        throw new RuntimeException(\"next value iterator failed\", ie);\n      } catch (InterruptedException ie) {\n        // this is bad, but we can\u0027t modify the exception list of java.util\n        throw new RuntimeException(\"next value iterator interrupted\", ie);        \n      }\n    }",
      "path": "mapreduce/src/java/org/apache/hadoop/mapreduce/task/ReduceContextImpl.java"
    }
  }
}