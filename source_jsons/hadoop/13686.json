{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockPlacementPolicyDefault.java",
  "functionName": "chooseLocalRack",
  "functionId": "chooseLocalRack___localMachine-Node__excludedNodes-Set__Node____blocksize-long__maxNodesPerRack-int__results-List__DatanodeStorageInfo____avoidStaleNodes-boolean__storageTypes-EnumMap__StorageType,Integer__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
  "functionStartLine": 675,
  "functionEndLine": 716,
  "numCommitsSeen": 141,
  "timeTaken": 3523,
  "changeHistory": [
    "f5ecc0bc080cb8a64c6d4632fc1c121f93d95c5e",
    "3a3566e1d1ab5f78cfb734796b41802fe039196d",
    "22a41dce4af4d5b533ba875b322551db1c152878",
    "e08701ec71f7c10d8f15122d90c35f9f22e40837"
  ],
  "changeHistoryShort": {
    "f5ecc0bc080cb8a64c6d4632fc1c121f93d95c5e": "Ybodychange",
    "3a3566e1d1ab5f78cfb734796b41802fe039196d": "Ybodychange",
    "22a41dce4af4d5b533ba875b322551db1c152878": "Ybodychange",
    "e08701ec71f7c10d8f15122d90c35f9f22e40837": "Ymultichange(Yparameterchange,Ybodychange)"
  },
  "changeHistoryDetails": {
    "f5ecc0bc080cb8a64c6d4632fc1c121f93d95c5e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14103. Review Logging of BlockPlacementPolicyDefault. Contributed by David Mollitor.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "19/06/19 10:06 AM",
      "commitName": "f5ecc0bc080cb8a64c6d4632fc1c121f93d95c5e",
      "commitAuthor": "David Mollitor",
      "commitDateOld": "06/06/19 10:20 AM",
      "commitNameOld": "944adc61b1830388d520d4052fc7eb6c7ba2790d",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 12.99,
      "commitsBetweenForRepo": 103,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,42 @@\n   protected DatanodeStorageInfo chooseLocalRack(Node localMachine,\n                                                 Set\u003cNode\u003e excludedNodes,\n                                                 long blocksize,\n                                                 int maxNodesPerRack,\n                                                 List\u003cDatanodeStorageInfo\u003e results,\n                                                 boolean avoidStaleNodes,\n                                                 EnumMap\u003cStorageType, Integer\u003e storageTypes)\n       throws NotEnoughReplicasException {\n     // no local machine, so choose a random machine\n     if (localMachine \u003d\u003d null) {\n       return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n           maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     }\n     final String localRack \u003d localMachine.getNetworkLocation();\n       \n     try {\n       // choose one from the local rack\n       return chooseRandom(localRack, excludedNodes,\n           blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     } catch (NotEnoughReplicasException e) {\n       // find the next replica and retry with its rack\n       for(DatanodeStorageInfo resultStorage : results) {\n         DatanodeDescriptor nextNode \u003d resultStorage.getDatanodeDescriptor();\n         if (nextNode !\u003d localMachine) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Failed to choose from local rack (location \u003d \" + localRack\n                 + \"), retry with the rack of the next replica (location \u003d \"\n                 + nextNode.getNetworkLocation() + \")\", e);\n           }\n           return chooseFromNextRack(nextNode, excludedNodes, blocksize,\n               maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n         }\n       }\n \n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Failed to choose from local rack (location \u003d \" + localRack\n-            + \"); the second replica is not found, retry choosing randomly\", e);\n-      }\n+      LOG.debug(\"Failed to choose from local rack (location \u003d {}); the second\"\n+          + \" replica is not found, retry choosing randomly\", localRack, e);\n+\n       //the second replica is not found, randomly choose one from the network\n       return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n           maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected DatanodeStorageInfo chooseLocalRack(Node localMachine,\n                                                Set\u003cNode\u003e excludedNodes,\n                                                long blocksize,\n                                                int maxNodesPerRack,\n                                                List\u003cDatanodeStorageInfo\u003e results,\n                                                boolean avoidStaleNodes,\n                                                EnumMap\u003cStorageType, Integer\u003e storageTypes)\n      throws NotEnoughReplicasException {\n    // no local machine, so choose a random machine\n    if (localMachine \u003d\u003d null) {\n      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    }\n    final String localRack \u003d localMachine.getNetworkLocation();\n      \n    try {\n      // choose one from the local rack\n      return chooseRandom(localRack, excludedNodes,\n          blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    } catch (NotEnoughReplicasException e) {\n      // find the next replica and retry with its rack\n      for(DatanodeStorageInfo resultStorage : results) {\n        DatanodeDescriptor nextNode \u003d resultStorage.getDatanodeDescriptor();\n        if (nextNode !\u003d localMachine) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Failed to choose from local rack (location \u003d \" + localRack\n                + \"), retry with the rack of the next replica (location \u003d \"\n                + nextNode.getNetworkLocation() + \")\", e);\n          }\n          return chooseFromNextRack(nextNode, excludedNodes, blocksize,\n              maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n        }\n      }\n\n      LOG.debug(\"Failed to choose from local rack (location \u003d {}); the second\"\n          + \" replica is not found, retry choosing randomly\", localRack, e);\n\n      //the second replica is not found, randomly choose one from the network\n      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "3a3566e1d1ab5f78cfb734796b41802fe039196d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12732. Correct spellings of ramdomly to randomly in log. Contributed by hu xiaodong.\n",
      "commitDate": "08/11/17 10:14 PM",
      "commitName": "3a3566e1d1ab5f78cfb734796b41802fe039196d",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "16/05/17 7:51 PM",
      "commitNameOld": "ec21ce425f4e5637be716406f9d0e038921550d7",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 176.14,
      "commitsBetweenForRepo": 1326,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   protected DatanodeStorageInfo chooseLocalRack(Node localMachine,\n                                                 Set\u003cNode\u003e excludedNodes,\n                                                 long blocksize,\n                                                 int maxNodesPerRack,\n                                                 List\u003cDatanodeStorageInfo\u003e results,\n                                                 boolean avoidStaleNodes,\n                                                 EnumMap\u003cStorageType, Integer\u003e storageTypes)\n       throws NotEnoughReplicasException {\n     // no local machine, so choose a random machine\n     if (localMachine \u003d\u003d null) {\n       return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n           maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     }\n     final String localRack \u003d localMachine.getNetworkLocation();\n       \n     try {\n       // choose one from the local rack\n       return chooseRandom(localRack, excludedNodes,\n           blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     } catch (NotEnoughReplicasException e) {\n       // find the next replica and retry with its rack\n       for(DatanodeStorageInfo resultStorage : results) {\n         DatanodeDescriptor nextNode \u003d resultStorage.getDatanodeDescriptor();\n         if (nextNode !\u003d localMachine) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Failed to choose from local rack (location \u003d \" + localRack\n                 + \"), retry with the rack of the next replica (location \u003d \"\n                 + nextNode.getNetworkLocation() + \")\", e);\n           }\n           return chooseFromNextRack(nextNode, excludedNodes, blocksize,\n               maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n         }\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Failed to choose from local rack (location \u003d \" + localRack\n-            + \"); the second replica is not found, retry choosing ramdomly\", e);\n+            + \"); the second replica is not found, retry choosing randomly\", e);\n       }\n       //the second replica is not found, randomly choose one from the network\n       return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n           maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected DatanodeStorageInfo chooseLocalRack(Node localMachine,\n                                                Set\u003cNode\u003e excludedNodes,\n                                                long blocksize,\n                                                int maxNodesPerRack,\n                                                List\u003cDatanodeStorageInfo\u003e results,\n                                                boolean avoidStaleNodes,\n                                                EnumMap\u003cStorageType, Integer\u003e storageTypes)\n      throws NotEnoughReplicasException {\n    // no local machine, so choose a random machine\n    if (localMachine \u003d\u003d null) {\n      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    }\n    final String localRack \u003d localMachine.getNetworkLocation();\n      \n    try {\n      // choose one from the local rack\n      return chooseRandom(localRack, excludedNodes,\n          blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    } catch (NotEnoughReplicasException e) {\n      // find the next replica and retry with its rack\n      for(DatanodeStorageInfo resultStorage : results) {\n        DatanodeDescriptor nextNode \u003d resultStorage.getDatanodeDescriptor();\n        if (nextNode !\u003d localMachine) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Failed to choose from local rack (location \u003d \" + localRack\n                + \"), retry with the rack of the next replica (location \u003d \"\n                + nextNode.getNetworkLocation() + \")\", e);\n          }\n          return chooseFromNextRack(nextNode, excludedNodes, blocksize,\n              maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Failed to choose from local rack (location \u003d \" + localRack\n            + \"); the second replica is not found, retry choosing randomly\", e);\n      }\n      //the second replica is not found, randomly choose one from the network\n      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "22a41dce4af4d5b533ba875b322551db1c152878": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6997: add more tests for data migration and replicaion.\n",
      "commitDate": "06/09/14 4:44 PM",
      "commitName": "22a41dce4af4d5b533ba875b322551db1c152878",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "04/09/14 2:19 PM",
      "commitNameOld": "e08701ec71f7c10d8f15122d90c35f9f22e40837",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.1,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,43 @@\n   protected DatanodeStorageInfo chooseLocalRack(Node localMachine,\n                                                 Set\u003cNode\u003e excludedNodes,\n                                                 long blocksize,\n                                                 int maxNodesPerRack,\n                                                 List\u003cDatanodeStorageInfo\u003e results,\n                                                 boolean avoidStaleNodes,\n                                                 EnumMap\u003cStorageType, Integer\u003e storageTypes)\n       throws NotEnoughReplicasException {\n     // no local machine, so choose a random machine\n     if (localMachine \u003d\u003d null) {\n       return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n           maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     }\n+    final String localRack \u003d localMachine.getNetworkLocation();\n       \n-    // choose one from the local rack\n     try {\n-      return chooseRandom(localMachine.getNetworkLocation(), excludedNodes,\n+      // choose one from the local rack\n+      return chooseRandom(localRack, excludedNodes,\n           blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n-    } catch (NotEnoughReplicasException e1) {\n-      // find the second replica\n-      DatanodeDescriptor newLocal\u003dnull;\n+    } catch (NotEnoughReplicasException e) {\n+      // find the next replica and retry with its rack\n       for(DatanodeStorageInfo resultStorage : results) {\n         DatanodeDescriptor nextNode \u003d resultStorage.getDatanodeDescriptor();\n         if (nextNode !\u003d localMachine) {\n-          newLocal \u003d nextNode;\n-          break;\n-        }\n-      }\n-      if (newLocal !\u003d null) {\n-        try {\n-          return chooseRandom(newLocal.getNetworkLocation(), excludedNodes,\n-              blocksize, maxNodesPerRack, results, avoidStaleNodes,\n-              storageTypes);\n-        } catch(NotEnoughReplicasException e2) {\n-          //otherwise randomly choose one from the network\n-          return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Failed to choose from local rack (location \u003d \" + localRack\n+                + \"), retry with the rack of the next replica (location \u003d \"\n+                + nextNode.getNetworkLocation() + \")\", e);\n+          }\n+          return chooseFromNextRack(nextNode, excludedNodes, blocksize,\n               maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n         }\n-      } else {\n-        //otherwise randomly choose one from the network\n-        return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n-            maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n       }\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Failed to choose from local rack (location \u003d \" + localRack\n+            + \"); the second replica is not found, retry choosing ramdomly\", e);\n+      }\n+      //the second replica is not found, randomly choose one from the network\n+      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n+          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected DatanodeStorageInfo chooseLocalRack(Node localMachine,\n                                                Set\u003cNode\u003e excludedNodes,\n                                                long blocksize,\n                                                int maxNodesPerRack,\n                                                List\u003cDatanodeStorageInfo\u003e results,\n                                                boolean avoidStaleNodes,\n                                                EnumMap\u003cStorageType, Integer\u003e storageTypes)\n      throws NotEnoughReplicasException {\n    // no local machine, so choose a random machine\n    if (localMachine \u003d\u003d null) {\n      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    }\n    final String localRack \u003d localMachine.getNetworkLocation();\n      \n    try {\n      // choose one from the local rack\n      return chooseRandom(localRack, excludedNodes,\n          blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    } catch (NotEnoughReplicasException e) {\n      // find the next replica and retry with its rack\n      for(DatanodeStorageInfo resultStorage : results) {\n        DatanodeDescriptor nextNode \u003d resultStorage.getDatanodeDescriptor();\n        if (nextNode !\u003d localMachine) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Failed to choose from local rack (location \u003d \" + localRack\n                + \"), retry with the rack of the next replica (location \u003d \"\n                + nextNode.getNetworkLocation() + \")\", e);\n          }\n          return chooseFromNextRack(nextNode, excludedNodes, blocksize,\n              maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n        }\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Failed to choose from local rack (location \u003d \" + localRack\n            + \"); the second replica is not found, retry choosing ramdomly\", e);\n      }\n      //the second replica is not found, randomly choose one from the network\n      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "e08701ec71f7c10d8f15122d90c35f9f22e40837": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6961. Archival Storage: BlockPlacementPolicy#chooseTarget should check each valid storage type in each choosing round.\n",
      "commitDate": "04/09/14 2:19 PM",
      "commitName": "e08701ec71f7c10d8f15122d90c35f9f22e40837",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6961. Archival Storage: BlockPlacementPolicy#chooseTarget should check each valid storage type in each choosing round.\n",
          "commitDate": "04/09/14 2:19 PM",
          "commitName": "e08701ec71f7c10d8f15122d90c35f9f22e40837",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "27/08/14 2:08 PM",
          "commitNameOld": "b7ded466b00db0fe273058b844d56d810e0f8cc2",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 8.01,
          "commitsBetweenForRepo": 50,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,45 @@\n   protected DatanodeStorageInfo chooseLocalRack(Node localMachine,\n-                                             Set\u003cNode\u003e excludedNodes,\n-                                             long blocksize,\n-                                             int maxNodesPerRack,\n-                                             List\u003cDatanodeStorageInfo\u003e results,\n-                                             boolean avoidStaleNodes,\n-                                             StorageType storageType)\n+                                                Set\u003cNode\u003e excludedNodes,\n+                                                long blocksize,\n+                                                int maxNodesPerRack,\n+                                                List\u003cDatanodeStorageInfo\u003e results,\n+                                                boolean avoidStaleNodes,\n+                                                EnumMap\u003cStorageType, Integer\u003e storageTypes)\n       throws NotEnoughReplicasException {\n     // no local machine, so choose a random machine\n     if (localMachine \u003d\u003d null) {\n       return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n-          maxNodesPerRack, results, avoidStaleNodes, storageType);\n+          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     }\n       \n     // choose one from the local rack\n     try {\n       return chooseRandom(localMachine.getNetworkLocation(), excludedNodes,\n-          blocksize, maxNodesPerRack, results, avoidStaleNodes, storageType);\n+          blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     } catch (NotEnoughReplicasException e1) {\n       // find the second replica\n       DatanodeDescriptor newLocal\u003dnull;\n       for(DatanodeStorageInfo resultStorage : results) {\n         DatanodeDescriptor nextNode \u003d resultStorage.getDatanodeDescriptor();\n         if (nextNode !\u003d localMachine) {\n           newLocal \u003d nextNode;\n           break;\n         }\n       }\n       if (newLocal !\u003d null) {\n         try {\n           return chooseRandom(newLocal.getNetworkLocation(), excludedNodes,\n-              blocksize, maxNodesPerRack, results, avoidStaleNodes, storageType);\n+              blocksize, maxNodesPerRack, results, avoidStaleNodes,\n+              storageTypes);\n         } catch(NotEnoughReplicasException e2) {\n           //otherwise randomly choose one from the network\n           return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n-              maxNodesPerRack, results, avoidStaleNodes, storageType);\n+              maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n         }\n       } else {\n         //otherwise randomly choose one from the network\n         return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n-            maxNodesPerRack, results, avoidStaleNodes, storageType);\n+            maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected DatanodeStorageInfo chooseLocalRack(Node localMachine,\n                                                Set\u003cNode\u003e excludedNodes,\n                                                long blocksize,\n                                                int maxNodesPerRack,\n                                                List\u003cDatanodeStorageInfo\u003e results,\n                                                boolean avoidStaleNodes,\n                                                EnumMap\u003cStorageType, Integer\u003e storageTypes)\n      throws NotEnoughReplicasException {\n    // no local machine, so choose a random machine\n    if (localMachine \u003d\u003d null) {\n      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    }\n      \n    // choose one from the local rack\n    try {\n      return chooseRandom(localMachine.getNetworkLocation(), excludedNodes,\n          blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    } catch (NotEnoughReplicasException e1) {\n      // find the second replica\n      DatanodeDescriptor newLocal\u003dnull;\n      for(DatanodeStorageInfo resultStorage : results) {\n        DatanodeDescriptor nextNode \u003d resultStorage.getDatanodeDescriptor();\n        if (nextNode !\u003d localMachine) {\n          newLocal \u003d nextNode;\n          break;\n        }\n      }\n      if (newLocal !\u003d null) {\n        try {\n          return chooseRandom(newLocal.getNetworkLocation(), excludedNodes,\n              blocksize, maxNodesPerRack, results, avoidStaleNodes,\n              storageTypes);\n        } catch(NotEnoughReplicasException e2) {\n          //otherwise randomly choose one from the network\n          return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n              maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n        }\n      } else {\n        //otherwise randomly choose one from the network\n        return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n            maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "[localMachine-Node, excludedNodes-Set\u003cNode\u003e, blocksize-long, maxNodesPerRack-int, results-List\u003cDatanodeStorageInfo\u003e, avoidStaleNodes-boolean, storageType-StorageType]",
            "newValue": "[localMachine-Node, excludedNodes-Set\u003cNode\u003e, blocksize-long, maxNodesPerRack-int, results-List\u003cDatanodeStorageInfo\u003e, avoidStaleNodes-boolean, storageTypes-EnumMap\u003cStorageType,Integer\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6961. Archival Storage: BlockPlacementPolicy#chooseTarget should check each valid storage type in each choosing round.\n",
          "commitDate": "04/09/14 2:19 PM",
          "commitName": "e08701ec71f7c10d8f15122d90c35f9f22e40837",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "27/08/14 2:08 PM",
          "commitNameOld": "b7ded466b00db0fe273058b844d56d810e0f8cc2",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 8.01,
          "commitsBetweenForRepo": 50,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,45 @@\n   protected DatanodeStorageInfo chooseLocalRack(Node localMachine,\n-                                             Set\u003cNode\u003e excludedNodes,\n-                                             long blocksize,\n-                                             int maxNodesPerRack,\n-                                             List\u003cDatanodeStorageInfo\u003e results,\n-                                             boolean avoidStaleNodes,\n-                                             StorageType storageType)\n+                                                Set\u003cNode\u003e excludedNodes,\n+                                                long blocksize,\n+                                                int maxNodesPerRack,\n+                                                List\u003cDatanodeStorageInfo\u003e results,\n+                                                boolean avoidStaleNodes,\n+                                                EnumMap\u003cStorageType, Integer\u003e storageTypes)\n       throws NotEnoughReplicasException {\n     // no local machine, so choose a random machine\n     if (localMachine \u003d\u003d null) {\n       return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n-          maxNodesPerRack, results, avoidStaleNodes, storageType);\n+          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     }\n       \n     // choose one from the local rack\n     try {\n       return chooseRandom(localMachine.getNetworkLocation(), excludedNodes,\n-          blocksize, maxNodesPerRack, results, avoidStaleNodes, storageType);\n+          blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n     } catch (NotEnoughReplicasException e1) {\n       // find the second replica\n       DatanodeDescriptor newLocal\u003dnull;\n       for(DatanodeStorageInfo resultStorage : results) {\n         DatanodeDescriptor nextNode \u003d resultStorage.getDatanodeDescriptor();\n         if (nextNode !\u003d localMachine) {\n           newLocal \u003d nextNode;\n           break;\n         }\n       }\n       if (newLocal !\u003d null) {\n         try {\n           return chooseRandom(newLocal.getNetworkLocation(), excludedNodes,\n-              blocksize, maxNodesPerRack, results, avoidStaleNodes, storageType);\n+              blocksize, maxNodesPerRack, results, avoidStaleNodes,\n+              storageTypes);\n         } catch(NotEnoughReplicasException e2) {\n           //otherwise randomly choose one from the network\n           return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n-              maxNodesPerRack, results, avoidStaleNodes, storageType);\n+              maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n         }\n       } else {\n         //otherwise randomly choose one from the network\n         return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n-            maxNodesPerRack, results, avoidStaleNodes, storageType);\n+            maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected DatanodeStorageInfo chooseLocalRack(Node localMachine,\n                                                Set\u003cNode\u003e excludedNodes,\n                                                long blocksize,\n                                                int maxNodesPerRack,\n                                                List\u003cDatanodeStorageInfo\u003e results,\n                                                boolean avoidStaleNodes,\n                                                EnumMap\u003cStorageType, Integer\u003e storageTypes)\n      throws NotEnoughReplicasException {\n    // no local machine, so choose a random machine\n    if (localMachine \u003d\u003d null) {\n      return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n          maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    }\n      \n    // choose one from the local rack\n    try {\n      return chooseRandom(localMachine.getNetworkLocation(), excludedNodes,\n          blocksize, maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n    } catch (NotEnoughReplicasException e1) {\n      // find the second replica\n      DatanodeDescriptor newLocal\u003dnull;\n      for(DatanodeStorageInfo resultStorage : results) {\n        DatanodeDescriptor nextNode \u003d resultStorage.getDatanodeDescriptor();\n        if (nextNode !\u003d localMachine) {\n          newLocal \u003d nextNode;\n          break;\n        }\n      }\n      if (newLocal !\u003d null) {\n        try {\n          return chooseRandom(newLocal.getNetworkLocation(), excludedNodes,\n              blocksize, maxNodesPerRack, results, avoidStaleNodes,\n              storageTypes);\n        } catch(NotEnoughReplicasException e2) {\n          //otherwise randomly choose one from the network\n          return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n              maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n        }\n      } else {\n        //otherwise randomly choose one from the network\n        return chooseRandom(NodeBase.ROOT, excludedNodes, blocksize,\n            maxNodesPerRack, results, avoidStaleNodes, storageTypes);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {}
        }
      ]
    }
  }
}