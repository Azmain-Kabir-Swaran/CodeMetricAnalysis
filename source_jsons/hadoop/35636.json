{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TimelineServiceV1Publisher.java",
  "functionName": "appFinished",
  "functionId": "appFinished___app-RMApp__state-RMAppState__finishedTime-long",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/metrics/TimelineServiceV1Publisher.java",
  "functionStartLine": 138,
  "functionEndLine": 172,
  "numCommitsSeen": 14,
  "timeTaken": 1712,
  "changeHistory": [
    "6307962b932e0ee69ba61f5796388c175d79195a",
    "93eeb13164707d0e3556c2bf737bd2ee09a335c6",
    "960af7d4717b8a8949d0b2e43949e7daab45aa88",
    "10ec5586fba20d80dd91d8d0ddb442c66d39a0d4"
  ],
  "changeHistoryShort": {
    "6307962b932e0ee69ba61f5796388c175d79195a": "Ybodychange",
    "93eeb13164707d0e3556c2bf737bd2ee09a335c6": "Ybodychange",
    "960af7d4717b8a8949d0b2e43949e7daab45aa88": "Ybodychange",
    "10ec5586fba20d80dd91d8d0ddb442c66d39a0d4": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6307962b932e0ee69ba61f5796388c175d79195a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8404. Timeline event publish need to be async to avoid Dispatcher thread leak in case ATS is down. Contributed by Rohith Sharma K S\n",
      "commitDate": "13/06/18 3:39 AM",
      "commitName": "6307962b932e0ee69ba61f5796388c175d79195a",
      "commitAuthor": "Sunil G",
      "commitDateOld": "26/04/18 9:56 PM",
      "commitNameOld": "1634de0fc1430d86b7688d16259a81462fba482f",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 47.24,
      "commitsBetweenForRepo": 377,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   public void appFinished(RMApp app, RMAppState state, long finishedTime) {\n     TimelineEntity entity \u003d createApplicationEntity(app.getApplicationId());\n \n     TimelineEvent tEvent \u003d new TimelineEvent();\n     tEvent.setEventType(ApplicationMetricsConstants.FINISHED_EVENT_TYPE);\n     tEvent.setTimestamp(finishedTime);\n     Map\u003cString, Object\u003e eventInfo \u003d new HashMap\u003cString, Object\u003e();\n     eventInfo.put(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO,\n         app.getDiagnostics().toString());\n     eventInfo.put(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO,\n         app.getFinalApplicationStatus().toString());\n     eventInfo.put(ApplicationMetricsConstants.STATE_EVENT_INFO,\n         RMServerUtils.createApplicationState(state).toString());\n     String latestApplicationAttemptId \u003d app.getCurrentAppAttempt() \u003d\u003d null\n         ? null : app.getCurrentAppAttempt().getAppAttemptId().toString();\n     if (latestApplicationAttemptId !\u003d null) {\n       eventInfo.put(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO,\n           latestApplicationAttemptId);\n     }\n     RMAppMetrics appMetrics \u003d app.getRMAppMetrics();\n     entity.addOtherInfo(ApplicationMetricsConstants.APP_CPU_METRICS,\n         appMetrics.getVcoreSeconds());\n     entity.addOtherInfo(ApplicationMetricsConstants.APP_MEM_METRICS,\n         appMetrics.getMemorySeconds());\n     entity.addOtherInfo(ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS,\n             appMetrics.getPreemptedMemorySeconds());\n     entity.addOtherInfo(ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS,\n             appMetrics.getPreemptedVcoreSeconds());\n     tEvent.setEventInfo(eventInfo);\n \n     entity.addEvent(tEvent);\n-    // sync sending of finish event to avoid possibility of saving application\n-    // finished state in RMStateStore save without publishing in ATS.\n-    putEntity(entity); // sync event so that ATS update is done without fail.\n+\n+    getDispatcher().getEventHandler().handle(new TimelineV1PublishEvent(\n+        SystemMetricsEventType.PUBLISH_ENTITY, entity, app.getApplicationId()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void appFinished(RMApp app, RMAppState state, long finishedTime) {\n    TimelineEntity entity \u003d createApplicationEntity(app.getApplicationId());\n\n    TimelineEvent tEvent \u003d new TimelineEvent();\n    tEvent.setEventType(ApplicationMetricsConstants.FINISHED_EVENT_TYPE);\n    tEvent.setTimestamp(finishedTime);\n    Map\u003cString, Object\u003e eventInfo \u003d new HashMap\u003cString, Object\u003e();\n    eventInfo.put(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO,\n        app.getDiagnostics().toString());\n    eventInfo.put(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO,\n        app.getFinalApplicationStatus().toString());\n    eventInfo.put(ApplicationMetricsConstants.STATE_EVENT_INFO,\n        RMServerUtils.createApplicationState(state).toString());\n    String latestApplicationAttemptId \u003d app.getCurrentAppAttempt() \u003d\u003d null\n        ? null : app.getCurrentAppAttempt().getAppAttemptId().toString();\n    if (latestApplicationAttemptId !\u003d null) {\n      eventInfo.put(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO,\n          latestApplicationAttemptId);\n    }\n    RMAppMetrics appMetrics \u003d app.getRMAppMetrics();\n    entity.addOtherInfo(ApplicationMetricsConstants.APP_CPU_METRICS,\n        appMetrics.getVcoreSeconds());\n    entity.addOtherInfo(ApplicationMetricsConstants.APP_MEM_METRICS,\n        appMetrics.getMemorySeconds());\n    entity.addOtherInfo(ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS,\n            appMetrics.getPreemptedMemorySeconds());\n    entity.addOtherInfo(ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS,\n            appMetrics.getPreemptedVcoreSeconds());\n    tEvent.setEventInfo(eventInfo);\n\n    entity.addEvent(tEvent);\n\n    getDispatcher().getEventHandler().handle(new TimelineV1PublishEvent(\n        SystemMetricsEventType.PUBLISH_ENTITY, entity, app.getApplicationId()));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/metrics/TimelineServiceV1Publisher.java",
      "extendedDetails": {}
    },
    "93eeb13164707d0e3556c2bf737bd2ee09a335c6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4218. Metric for resource*time that was preempted. Contributed by Chang Li.\n",
      "commitDate": "10/11/16 2:35 PM",
      "commitName": "93eeb13164707d0e3556c2bf737bd2ee09a335c6",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "15/10/16 1:54 PM",
      "commitNameOld": "1f304b0c7f261369dd68839507bb609a949965ad",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 26.07,
      "commitsBetweenForRepo": 264,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,35 @@\n   public void appFinished(RMApp app, RMAppState state, long finishedTime) {\n     TimelineEntity entity \u003d createApplicationEntity(app.getApplicationId());\n \n     TimelineEvent tEvent \u003d new TimelineEvent();\n     tEvent.setEventType(ApplicationMetricsConstants.FINISHED_EVENT_TYPE);\n     tEvent.setTimestamp(finishedTime);\n     Map\u003cString, Object\u003e eventInfo \u003d new HashMap\u003cString, Object\u003e();\n     eventInfo.put(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO,\n         app.getDiagnostics().toString());\n     eventInfo.put(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO,\n         app.getFinalApplicationStatus().toString());\n     eventInfo.put(ApplicationMetricsConstants.STATE_EVENT_INFO,\n         RMServerUtils.createApplicationState(state).toString());\n     String latestApplicationAttemptId \u003d app.getCurrentAppAttempt() \u003d\u003d null\n         ? null : app.getCurrentAppAttempt().getAppAttemptId().toString();\n     if (latestApplicationAttemptId !\u003d null) {\n       eventInfo.put(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO,\n           latestApplicationAttemptId);\n     }\n     RMAppMetrics appMetrics \u003d app.getRMAppMetrics();\n     entity.addOtherInfo(ApplicationMetricsConstants.APP_CPU_METRICS,\n         appMetrics.getVcoreSeconds());\n     entity.addOtherInfo(ApplicationMetricsConstants.APP_MEM_METRICS,\n         appMetrics.getMemorySeconds());\n+    entity.addOtherInfo(ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS,\n+            appMetrics.getPreemptedMemorySeconds());\n+    entity.addOtherInfo(ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS,\n+            appMetrics.getPreemptedVcoreSeconds());\n     tEvent.setEventInfo(eventInfo);\n \n     entity.addEvent(tEvent);\n     // sync sending of finish event to avoid possibility of saving application\n     // finished state in RMStateStore save without publishing in ATS.\n     putEntity(entity); // sync event so that ATS update is done without fail.\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void appFinished(RMApp app, RMAppState state, long finishedTime) {\n    TimelineEntity entity \u003d createApplicationEntity(app.getApplicationId());\n\n    TimelineEvent tEvent \u003d new TimelineEvent();\n    tEvent.setEventType(ApplicationMetricsConstants.FINISHED_EVENT_TYPE);\n    tEvent.setTimestamp(finishedTime);\n    Map\u003cString, Object\u003e eventInfo \u003d new HashMap\u003cString, Object\u003e();\n    eventInfo.put(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO,\n        app.getDiagnostics().toString());\n    eventInfo.put(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO,\n        app.getFinalApplicationStatus().toString());\n    eventInfo.put(ApplicationMetricsConstants.STATE_EVENT_INFO,\n        RMServerUtils.createApplicationState(state).toString());\n    String latestApplicationAttemptId \u003d app.getCurrentAppAttempt() \u003d\u003d null\n        ? null : app.getCurrentAppAttempt().getAppAttemptId().toString();\n    if (latestApplicationAttemptId !\u003d null) {\n      eventInfo.put(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO,\n          latestApplicationAttemptId);\n    }\n    RMAppMetrics appMetrics \u003d app.getRMAppMetrics();\n    entity.addOtherInfo(ApplicationMetricsConstants.APP_CPU_METRICS,\n        appMetrics.getVcoreSeconds());\n    entity.addOtherInfo(ApplicationMetricsConstants.APP_MEM_METRICS,\n        appMetrics.getMemorySeconds());\n    entity.addOtherInfo(ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS,\n            appMetrics.getPreemptedMemorySeconds());\n    entity.addOtherInfo(ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS,\n            appMetrics.getPreemptedVcoreSeconds());\n    tEvent.setEventInfo(eventInfo);\n\n    entity.addEvent(tEvent);\n    // sync sending of finish event to avoid possibility of saving application\n    // finished state in RMStateStore save without publishing in ATS.\n    putEntity(entity); // sync event so that ATS update is done without fail.\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/metrics/TimelineServiceV1Publisher.java",
      "extendedDetails": {}
    },
    "960af7d4717b8a8949d0b2e43949e7daab45aa88": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4409. Fix javadoc and checkstyle issues in timelineservice code (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "960af7d4717b8a8949d0b2e43949e7daab45aa88",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "34f02f07d5bf9fbfa1d07d1b219225c298539105",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n   public void appFinished(RMApp app, RMAppState state, long finishedTime) {\n     TimelineEntity entity \u003d createApplicationEntity(app.getApplicationId());\n \n     TimelineEvent tEvent \u003d new TimelineEvent();\n     tEvent.setEventType(ApplicationMetricsConstants.FINISHED_EVENT_TYPE);\n     tEvent.setTimestamp(finishedTime);\n     Map\u003cString, Object\u003e eventInfo \u003d new HashMap\u003cString, Object\u003e();\n     eventInfo.put(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO,\n         app.getDiagnostics().toString());\n     eventInfo.put(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO,\n         app.getFinalApplicationStatus().toString());\n     eventInfo.put(ApplicationMetricsConstants.STATE_EVENT_INFO,\n         RMServerUtils.createApplicationState(state).toString());\n     String latestApplicationAttemptId \u003d app.getCurrentAppAttempt() \u003d\u003d null\n         ? null : app.getCurrentAppAttempt().getAppAttemptId().toString();\n     if (latestApplicationAttemptId !\u003d null) {\n       eventInfo.put(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO,\n           latestApplicationAttemptId);\n     }\n     RMAppMetrics appMetrics \u003d app.getRMAppMetrics();\n     entity.addOtherInfo(ApplicationMetricsConstants.APP_CPU_METRICS,\n         appMetrics.getVcoreSeconds());\n     entity.addOtherInfo(ApplicationMetricsConstants.APP_MEM_METRICS,\n         appMetrics.getMemorySeconds());\n     tEvent.setEventInfo(eventInfo);\n \n     entity.addEvent(tEvent);\n     // sync sending of finish event to avoid possibility of saving application\n-    // finished state in RMStateStore save without publishing in ATS\n-    putEntity(entity);// sync event so that ATS update is done without fail\n+    // finished state in RMStateStore save without publishing in ATS.\n+    putEntity(entity); // sync event so that ATS update is done without fail.\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void appFinished(RMApp app, RMAppState state, long finishedTime) {\n    TimelineEntity entity \u003d createApplicationEntity(app.getApplicationId());\n\n    TimelineEvent tEvent \u003d new TimelineEvent();\n    tEvent.setEventType(ApplicationMetricsConstants.FINISHED_EVENT_TYPE);\n    tEvent.setTimestamp(finishedTime);\n    Map\u003cString, Object\u003e eventInfo \u003d new HashMap\u003cString, Object\u003e();\n    eventInfo.put(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO,\n        app.getDiagnostics().toString());\n    eventInfo.put(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO,\n        app.getFinalApplicationStatus().toString());\n    eventInfo.put(ApplicationMetricsConstants.STATE_EVENT_INFO,\n        RMServerUtils.createApplicationState(state).toString());\n    String latestApplicationAttemptId \u003d app.getCurrentAppAttempt() \u003d\u003d null\n        ? null : app.getCurrentAppAttempt().getAppAttemptId().toString();\n    if (latestApplicationAttemptId !\u003d null) {\n      eventInfo.put(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO,\n          latestApplicationAttemptId);\n    }\n    RMAppMetrics appMetrics \u003d app.getRMAppMetrics();\n    entity.addOtherInfo(ApplicationMetricsConstants.APP_CPU_METRICS,\n        appMetrics.getVcoreSeconds());\n    entity.addOtherInfo(ApplicationMetricsConstants.APP_MEM_METRICS,\n        appMetrics.getMemorySeconds());\n    tEvent.setEventInfo(eventInfo);\n\n    entity.addEvent(tEvent);\n    // sync sending of finish event to avoid possibility of saving application\n    // finished state in RMStateStore save without publishing in ATS.\n    putEntity(entity); // sync event so that ATS update is done without fail.\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/metrics/TimelineServiceV1Publisher.java",
      "extendedDetails": {}
    },
    "10ec5586fba20d80dd91d8d0ddb442c66d39a0d4": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4129. Refactor the SystemMetricPublisher in RM to better support newer events (Naganarasimha G R via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "10ec5586fba20d80dd91d8d0ddb442c66d39a0d4",
      "commitAuthor": "Sangjin Lee",
      "diff": "@@ -0,0 +1,31 @@\n+  public void appFinished(RMApp app, RMAppState state, long finishedTime) {\n+    TimelineEntity entity \u003d createApplicationEntity(app.getApplicationId());\n+\n+    TimelineEvent tEvent \u003d new TimelineEvent();\n+    tEvent.setEventType(ApplicationMetricsConstants.FINISHED_EVENT_TYPE);\n+    tEvent.setTimestamp(finishedTime);\n+    Map\u003cString, Object\u003e eventInfo \u003d new HashMap\u003cString, Object\u003e();\n+    eventInfo.put(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO,\n+        app.getDiagnostics().toString());\n+    eventInfo.put(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO,\n+        app.getFinalApplicationStatus().toString());\n+    eventInfo.put(ApplicationMetricsConstants.STATE_EVENT_INFO,\n+        RMServerUtils.createApplicationState(state).toString());\n+    String latestApplicationAttemptId \u003d app.getCurrentAppAttempt() \u003d\u003d null\n+        ? null : app.getCurrentAppAttempt().getAppAttemptId().toString();\n+    if (latestApplicationAttemptId !\u003d null) {\n+      eventInfo.put(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO,\n+          latestApplicationAttemptId);\n+    }\n+    RMAppMetrics appMetrics \u003d app.getRMAppMetrics();\n+    entity.addOtherInfo(ApplicationMetricsConstants.APP_CPU_METRICS,\n+        appMetrics.getVcoreSeconds());\n+    entity.addOtherInfo(ApplicationMetricsConstants.APP_MEM_METRICS,\n+        appMetrics.getMemorySeconds());\n+    tEvent.setEventInfo(eventInfo);\n+\n+    entity.addEvent(tEvent);\n+    // sync sending of finish event to avoid possibility of saving application\n+    // finished state in RMStateStore save without publishing in ATS\n+    putEntity(entity);// sync event so that ATS update is done without fail\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void appFinished(RMApp app, RMAppState state, long finishedTime) {\n    TimelineEntity entity \u003d createApplicationEntity(app.getApplicationId());\n\n    TimelineEvent tEvent \u003d new TimelineEvent();\n    tEvent.setEventType(ApplicationMetricsConstants.FINISHED_EVENT_TYPE);\n    tEvent.setTimestamp(finishedTime);\n    Map\u003cString, Object\u003e eventInfo \u003d new HashMap\u003cString, Object\u003e();\n    eventInfo.put(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO,\n        app.getDiagnostics().toString());\n    eventInfo.put(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO,\n        app.getFinalApplicationStatus().toString());\n    eventInfo.put(ApplicationMetricsConstants.STATE_EVENT_INFO,\n        RMServerUtils.createApplicationState(state).toString());\n    String latestApplicationAttemptId \u003d app.getCurrentAppAttempt() \u003d\u003d null\n        ? null : app.getCurrentAppAttempt().getAppAttemptId().toString();\n    if (latestApplicationAttemptId !\u003d null) {\n      eventInfo.put(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO,\n          latestApplicationAttemptId);\n    }\n    RMAppMetrics appMetrics \u003d app.getRMAppMetrics();\n    entity.addOtherInfo(ApplicationMetricsConstants.APP_CPU_METRICS,\n        appMetrics.getVcoreSeconds());\n    entity.addOtherInfo(ApplicationMetricsConstants.APP_MEM_METRICS,\n        appMetrics.getMemorySeconds());\n    tEvent.setEventInfo(eventInfo);\n\n    entity.addEvent(tEvent);\n    // sync sending of finish event to avoid possibility of saving application\n    // finished state in RMStateStore save without publishing in ATS\n    putEntity(entity);// sync event so that ATS update is done without fail\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/metrics/TimelineServiceV1Publisher.java"
    }
  }
}