{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TaskAttemptImpl.java",
  "functionName": "recover",
  "functionId": "recover___taInfo-TaskAttemptInfo__committer-OutputCommitter__recoverOutput-boolean",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java",
  "functionStartLine": 1436,
  "functionEndLine": 1532,
  "numCommitsSeen": 108,
  "timeTaken": 3145,
  "changeHistory": [
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "b16c5638b5190c56f9d854d873589cb5c11c8b32",
    "643155cbee54809e1a7febd96cbb7d8111689b38",
    "fbb55784d93e1a819daf55d936e864d344579cbf",
    "cb78a65a152a4f576a3255df3676c3b788c84eb5",
    "6a1c41111edcdc58c846fc50e53554fbba230171"
  ],
  "changeHistoryShort": {
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "b16c5638b5190c56f9d854d873589cb5c11c8b32": "Ybodychange",
    "643155cbee54809e1a7febd96cbb7d8111689b38": "Ybodychange",
    "fbb55784d93e1a819daf55d936e864d344579cbf": "Ybodychange",
    "cb78a65a152a4f576a3255df3676c3b788c84eb5": "Ybodychange",
    "6a1c41111edcdc58c846fc50e53554fbba230171": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "06/06/16 2:30 PM",
      "commitNameOld": "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 8.02,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,97 @@\n   public TaskAttemptStateInternal recover(TaskAttemptInfo taInfo,\n       OutputCommitter committer, boolean recoverOutput) {\n     ContainerId containerId \u003d taInfo.getContainerId();\n-    NodeId containerNodeId \u003d ConverterUtils.toNodeId(taInfo.getHostname() + \":\"\n-        + taInfo.getPort());\n+    NodeId containerNodeId \u003d NodeId.fromString(\n+        taInfo.getHostname() + \":\" + taInfo.getPort());\n     String nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n         + taInfo.getHttpPort());\n     // Resource/Priority/Tokens are only needed while launching the container on\n     // an NM, these are already completed tasks, so setting them to null\n     container \u003d\n         Container.newInstance(containerId, containerNodeId,\n           nodeHttpAddress, null, null, null);\n     computeRackAndLocality();\n     launchTime \u003d taInfo.getStartTime();\n     finishTime \u003d (taInfo.getFinishTime() !\u003d -1) ?\n         taInfo.getFinishTime() : clock.getTime();\n     shufflePort \u003d taInfo.getShufflePort();\n     trackerName \u003d taInfo.getHostname();\n     httpPort \u003d taInfo.getHttpPort();\n     sendLaunchedEvents();\n \n     reportedStatus.id \u003d attemptId;\n     reportedStatus.progress \u003d 1.0f;\n     reportedStatus.counters \u003d taInfo.getCounters();\n     reportedStatus.stateString \u003d taInfo.getState();\n     reportedStatus.phase \u003d Phase.CLEANUP;\n     reportedStatus.mapFinishTime \u003d taInfo.getMapFinishTime();\n     reportedStatus.shuffleFinishTime \u003d taInfo.getShuffleFinishTime();\n     reportedStatus.sortFinishTime \u003d taInfo.getSortFinishTime();\n     addDiagnosticInfo(taInfo.getError());\n \n     boolean needToClean \u003d false;\n     String recoveredState \u003d taInfo.getTaskStatus();\n     if (recoverOutput\n         \u0026\u0026 TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n       TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n           TypeConverter.fromYarn(attemptId));\n       try {\n         committer.recoverTask(tac);\n         LOG.info(\"Recovered output from task attempt \" + attemptId);\n       } catch (Exception e) {\n         LOG.error(\"Unable to recover task attempt \" + attemptId, e);\n         LOG.info(\"Task attempt \" + attemptId + \" will be recovered as KILLED\");\n         recoveredState \u003d TaskAttemptState.KILLED.toString();\n         needToClean \u003d true;\n       }\n     }\n \n     TaskAttemptStateInternal attemptState;\n     if (TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n       attemptState \u003d TaskAttemptStateInternal.SUCCEEDED;\n       reportedStatus.taskState \u003d TaskAttemptState.SUCCEEDED;\n       eventHandler.handle(createJobCounterUpdateEventTASucceeded(this));\n       logAttemptFinishedEvent(attemptState);\n     } else if (TaskAttemptState.FAILED.toString().equals(recoveredState)) {\n       attemptState \u003d TaskAttemptStateInternal.FAILED;\n       reportedStatus.taskState \u003d TaskAttemptState.FAILED;\n       eventHandler.handle(createJobCounterUpdateEventTAFailed(this, false));\n       TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n           createTaskAttemptUnsuccessfulCompletionEvent(this,\n               TaskAttemptStateInternal.FAILED);\n       eventHandler.handle(\n           new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n     } else {\n       if (!TaskAttemptState.KILLED.toString().equals(recoveredState)) {\n         if (String.valueOf(recoveredState).isEmpty()) {\n           LOG.info(\"TaskAttempt\" + attemptId\n               + \" had not completed, recovering as KILLED\");\n         } else {\n           LOG.warn(\"TaskAttempt \" + attemptId + \" found in unexpected state \"\n               + recoveredState + \", recovering as KILLED\");\n         }\n         addDiagnosticInfo(\"Killed during application recovery\");\n         needToClean \u003d true;\n       }\n       attemptState \u003d TaskAttemptStateInternal.KILLED;\n       reportedStatus.taskState \u003d TaskAttemptState.KILLED;\n       eventHandler.handle(createJobCounterUpdateEventTAKilled(this, false));\n       TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n           createTaskAttemptUnsuccessfulCompletionEvent(this,\n               TaskAttemptStateInternal.KILLED);\n       eventHandler.handle(\n           new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n     }\n \n     if (needToClean) {\n       TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n           TypeConverter.fromYarn(attemptId));\n       try {\n         committer.abortTask(tac);\n       } catch (Exception e) {\n         LOG.warn(\"Task cleanup failed for attempt \" + attemptId, e);\n       }\n     }\n \n     return attemptState;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TaskAttemptStateInternal recover(TaskAttemptInfo taInfo,\n      OutputCommitter committer, boolean recoverOutput) {\n    ContainerId containerId \u003d taInfo.getContainerId();\n    NodeId containerNodeId \u003d NodeId.fromString(\n        taInfo.getHostname() + \":\" + taInfo.getPort());\n    String nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n        + taInfo.getHttpPort());\n    // Resource/Priority/Tokens are only needed while launching the container on\n    // an NM, these are already completed tasks, so setting them to null\n    container \u003d\n        Container.newInstance(containerId, containerNodeId,\n          nodeHttpAddress, null, null, null);\n    computeRackAndLocality();\n    launchTime \u003d taInfo.getStartTime();\n    finishTime \u003d (taInfo.getFinishTime() !\u003d -1) ?\n        taInfo.getFinishTime() : clock.getTime();\n    shufflePort \u003d taInfo.getShufflePort();\n    trackerName \u003d taInfo.getHostname();\n    httpPort \u003d taInfo.getHttpPort();\n    sendLaunchedEvents();\n\n    reportedStatus.id \u003d attemptId;\n    reportedStatus.progress \u003d 1.0f;\n    reportedStatus.counters \u003d taInfo.getCounters();\n    reportedStatus.stateString \u003d taInfo.getState();\n    reportedStatus.phase \u003d Phase.CLEANUP;\n    reportedStatus.mapFinishTime \u003d taInfo.getMapFinishTime();\n    reportedStatus.shuffleFinishTime \u003d taInfo.getShuffleFinishTime();\n    reportedStatus.sortFinishTime \u003d taInfo.getSortFinishTime();\n    addDiagnosticInfo(taInfo.getError());\n\n    boolean needToClean \u003d false;\n    String recoveredState \u003d taInfo.getTaskStatus();\n    if (recoverOutput\n        \u0026\u0026 TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n          TypeConverter.fromYarn(attemptId));\n      try {\n        committer.recoverTask(tac);\n        LOG.info(\"Recovered output from task attempt \" + attemptId);\n      } catch (Exception e) {\n        LOG.error(\"Unable to recover task attempt \" + attemptId, e);\n        LOG.info(\"Task attempt \" + attemptId + \" will be recovered as KILLED\");\n        recoveredState \u003d TaskAttemptState.KILLED.toString();\n        needToClean \u003d true;\n      }\n    }\n\n    TaskAttemptStateInternal attemptState;\n    if (TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n      attemptState \u003d TaskAttemptStateInternal.SUCCEEDED;\n      reportedStatus.taskState \u003d TaskAttemptState.SUCCEEDED;\n      eventHandler.handle(createJobCounterUpdateEventTASucceeded(this));\n      logAttemptFinishedEvent(attemptState);\n    } else if (TaskAttemptState.FAILED.toString().equals(recoveredState)) {\n      attemptState \u003d TaskAttemptStateInternal.FAILED;\n      reportedStatus.taskState \u003d TaskAttemptState.FAILED;\n      eventHandler.handle(createJobCounterUpdateEventTAFailed(this, false));\n      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n          createTaskAttemptUnsuccessfulCompletionEvent(this,\n              TaskAttemptStateInternal.FAILED);\n      eventHandler.handle(\n          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n    } else {\n      if (!TaskAttemptState.KILLED.toString().equals(recoveredState)) {\n        if (String.valueOf(recoveredState).isEmpty()) {\n          LOG.info(\"TaskAttempt\" + attemptId\n              + \" had not completed, recovering as KILLED\");\n        } else {\n          LOG.warn(\"TaskAttempt \" + attemptId + \" found in unexpected state \"\n              + recoveredState + \", recovering as KILLED\");\n        }\n        addDiagnosticInfo(\"Killed during application recovery\");\n        needToClean \u003d true;\n      }\n      attemptState \u003d TaskAttemptStateInternal.KILLED;\n      reportedStatus.taskState \u003d TaskAttemptState.KILLED;\n      eventHandler.handle(createJobCounterUpdateEventTAKilled(this, false));\n      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n          createTaskAttemptUnsuccessfulCompletionEvent(this,\n              TaskAttemptStateInternal.KILLED);\n      eventHandler.handle(\n          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n    }\n\n    if (needToClean) {\n      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n          TypeConverter.fromYarn(attemptId));\n      try {\n        committer.abortTask(tac);\n      } catch (Exception e) {\n        LOG.warn(\"Task cleanup failed for attempt \" + attemptId, e);\n      }\n    }\n\n    return attemptState;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java",
      "extendedDetails": {}
    },
    "b16c5638b5190c56f9d854d873589cb5c11c8b32": {
      "type": "Ybodychange",
      "commitMessage": "YARN-719. Move RMIdentifier from Container to ContainerTokenIdentifier. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1487741 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/05/13 9:59 PM",
      "commitName": "b16c5638b5190c56f9d854d873589cb5c11c8b32",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "24/05/13 6:46 PM",
      "commitNameOld": "643155cbee54809e1a7febd96cbb7d8111689b38",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.13,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,97 @@\n   public TaskAttemptStateInternal recover(TaskAttemptInfo taInfo,\n       OutputCommitter committer, boolean recoverOutput) {\n     ContainerId containerId \u003d taInfo.getContainerId();\n     NodeId containerNodeId \u003d ConverterUtils.toNodeId(taInfo.getHostname() + \":\"\n         + taInfo.getPort());\n     String nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n         + taInfo.getHttpPort());\n-    // Resource/Priority/Tokens and RMIdentifier are only needed while\n-    // launching the container on an NM, these are already completed tasks, so\n-    // setting them to null and RMIdentifier as 0\n+    // Resource/Priority/Tokens are only needed while launching the container on\n+    // an NM, these are already completed tasks, so setting them to null\n     container \u003d\n         Container.newInstance(containerId, containerNodeId,\n-          nodeHttpAddress, null, null, null, 0);\n+          nodeHttpAddress, null, null, null);\n     computeRackAndLocality();\n     launchTime \u003d taInfo.getStartTime();\n     finishTime \u003d (taInfo.getFinishTime() !\u003d -1) ?\n         taInfo.getFinishTime() : clock.getTime();\n     shufflePort \u003d taInfo.getShufflePort();\n     trackerName \u003d taInfo.getHostname();\n     httpPort \u003d taInfo.getHttpPort();\n     sendLaunchedEvents();\n \n     reportedStatus.id \u003d attemptId;\n     reportedStatus.progress \u003d 1.0f;\n     reportedStatus.counters \u003d taInfo.getCounters();\n     reportedStatus.stateString \u003d taInfo.getState();\n     reportedStatus.phase \u003d Phase.CLEANUP;\n     reportedStatus.mapFinishTime \u003d taInfo.getMapFinishTime();\n     reportedStatus.shuffleFinishTime \u003d taInfo.getShuffleFinishTime();\n     reportedStatus.sortFinishTime \u003d taInfo.getSortFinishTime();\n     addDiagnosticInfo(taInfo.getError());\n \n     boolean needToClean \u003d false;\n     String recoveredState \u003d taInfo.getTaskStatus();\n     if (recoverOutput\n         \u0026\u0026 TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n       TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n           TypeConverter.fromYarn(attemptId));\n       try {\n         committer.recoverTask(tac);\n         LOG.info(\"Recovered output from task attempt \" + attemptId);\n       } catch (Exception e) {\n         LOG.error(\"Unable to recover task attempt \" + attemptId, e);\n         LOG.info(\"Task attempt \" + attemptId + \" will be recovered as KILLED\");\n         recoveredState \u003d TaskAttemptState.KILLED.toString();\n         needToClean \u003d true;\n       }\n     }\n \n     TaskAttemptStateInternal attemptState;\n     if (TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n       attemptState \u003d TaskAttemptStateInternal.SUCCEEDED;\n       reportedStatus.taskState \u003d TaskAttemptState.SUCCEEDED;\n       eventHandler.handle(createJobCounterUpdateEventTASucceeded(this));\n       logAttemptFinishedEvent(attemptState);\n     } else if (TaskAttemptState.FAILED.toString().equals(recoveredState)) {\n       attemptState \u003d TaskAttemptStateInternal.FAILED;\n       reportedStatus.taskState \u003d TaskAttemptState.FAILED;\n       eventHandler.handle(createJobCounterUpdateEventTAFailed(this, false));\n       TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n           createTaskAttemptUnsuccessfulCompletionEvent(this,\n               TaskAttemptStateInternal.FAILED);\n       eventHandler.handle(\n           new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n     } else {\n       if (!TaskAttemptState.KILLED.toString().equals(recoveredState)) {\n         if (String.valueOf(recoveredState).isEmpty()) {\n           LOG.info(\"TaskAttempt\" + attemptId\n               + \" had not completed, recovering as KILLED\");\n         } else {\n           LOG.warn(\"TaskAttempt \" + attemptId + \" found in unexpected state \"\n               + recoveredState + \", recovering as KILLED\");\n         }\n         addDiagnosticInfo(\"Killed during application recovery\");\n         needToClean \u003d true;\n       }\n       attemptState \u003d TaskAttemptStateInternal.KILLED;\n       reportedStatus.taskState \u003d TaskAttemptState.KILLED;\n       eventHandler.handle(createJobCounterUpdateEventTAKilled(this, false));\n       TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n           createTaskAttemptUnsuccessfulCompletionEvent(this,\n               TaskAttemptStateInternal.KILLED);\n       eventHandler.handle(\n           new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n     }\n \n     if (needToClean) {\n       TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n           TypeConverter.fromYarn(attemptId));\n       try {\n         committer.abortTask(tac);\n       } catch (Exception e) {\n         LOG.warn(\"Task cleanup failed for attempt \" + attemptId, e);\n       }\n     }\n \n     return attemptState;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TaskAttemptStateInternal recover(TaskAttemptInfo taInfo,\n      OutputCommitter committer, boolean recoverOutput) {\n    ContainerId containerId \u003d taInfo.getContainerId();\n    NodeId containerNodeId \u003d ConverterUtils.toNodeId(taInfo.getHostname() + \":\"\n        + taInfo.getPort());\n    String nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n        + taInfo.getHttpPort());\n    // Resource/Priority/Tokens are only needed while launching the container on\n    // an NM, these are already completed tasks, so setting them to null\n    container \u003d\n        Container.newInstance(containerId, containerNodeId,\n          nodeHttpAddress, null, null, null);\n    computeRackAndLocality();\n    launchTime \u003d taInfo.getStartTime();\n    finishTime \u003d (taInfo.getFinishTime() !\u003d -1) ?\n        taInfo.getFinishTime() : clock.getTime();\n    shufflePort \u003d taInfo.getShufflePort();\n    trackerName \u003d taInfo.getHostname();\n    httpPort \u003d taInfo.getHttpPort();\n    sendLaunchedEvents();\n\n    reportedStatus.id \u003d attemptId;\n    reportedStatus.progress \u003d 1.0f;\n    reportedStatus.counters \u003d taInfo.getCounters();\n    reportedStatus.stateString \u003d taInfo.getState();\n    reportedStatus.phase \u003d Phase.CLEANUP;\n    reportedStatus.mapFinishTime \u003d taInfo.getMapFinishTime();\n    reportedStatus.shuffleFinishTime \u003d taInfo.getShuffleFinishTime();\n    reportedStatus.sortFinishTime \u003d taInfo.getSortFinishTime();\n    addDiagnosticInfo(taInfo.getError());\n\n    boolean needToClean \u003d false;\n    String recoveredState \u003d taInfo.getTaskStatus();\n    if (recoverOutput\n        \u0026\u0026 TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n          TypeConverter.fromYarn(attemptId));\n      try {\n        committer.recoverTask(tac);\n        LOG.info(\"Recovered output from task attempt \" + attemptId);\n      } catch (Exception e) {\n        LOG.error(\"Unable to recover task attempt \" + attemptId, e);\n        LOG.info(\"Task attempt \" + attemptId + \" will be recovered as KILLED\");\n        recoveredState \u003d TaskAttemptState.KILLED.toString();\n        needToClean \u003d true;\n      }\n    }\n\n    TaskAttemptStateInternal attemptState;\n    if (TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n      attemptState \u003d TaskAttemptStateInternal.SUCCEEDED;\n      reportedStatus.taskState \u003d TaskAttemptState.SUCCEEDED;\n      eventHandler.handle(createJobCounterUpdateEventTASucceeded(this));\n      logAttemptFinishedEvent(attemptState);\n    } else if (TaskAttemptState.FAILED.toString().equals(recoveredState)) {\n      attemptState \u003d TaskAttemptStateInternal.FAILED;\n      reportedStatus.taskState \u003d TaskAttemptState.FAILED;\n      eventHandler.handle(createJobCounterUpdateEventTAFailed(this, false));\n      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n          createTaskAttemptUnsuccessfulCompletionEvent(this,\n              TaskAttemptStateInternal.FAILED);\n      eventHandler.handle(\n          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n    } else {\n      if (!TaskAttemptState.KILLED.toString().equals(recoveredState)) {\n        if (String.valueOf(recoveredState).isEmpty()) {\n          LOG.info(\"TaskAttempt\" + attemptId\n              + \" had not completed, recovering as KILLED\");\n        } else {\n          LOG.warn(\"TaskAttempt \" + attemptId + \" found in unexpected state \"\n              + recoveredState + \", recovering as KILLED\");\n        }\n        addDiagnosticInfo(\"Killed during application recovery\");\n        needToClean \u003d true;\n      }\n      attemptState \u003d TaskAttemptStateInternal.KILLED;\n      reportedStatus.taskState \u003d TaskAttemptState.KILLED;\n      eventHandler.handle(createJobCounterUpdateEventTAKilled(this, false));\n      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n          createTaskAttemptUnsuccessfulCompletionEvent(this,\n              TaskAttemptStateInternal.KILLED);\n      eventHandler.handle(\n          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n    }\n\n    if (needToClean) {\n      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n          TypeConverter.fromYarn(attemptId));\n      try {\n        committer.abortTask(tac);\n      } catch (Exception e) {\n        LOG.warn(\"Task cleanup failed for attempt \" + attemptId, e);\n      }\n    }\n\n    return attemptState;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java",
      "extendedDetails": {}
    },
    "643155cbee54809e1a7febd96cbb7d8111689b38": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5270. Migrated MR app from using BuilderUtil factory methods to individual record factory methods. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1486271 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/05/13 6:46 PM",
      "commitName": "643155cbee54809e1a7febd96cbb7d8111689b38",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "23/05/13 8:22 PM",
      "commitNameOld": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n   public TaskAttemptStateInternal recover(TaskAttemptInfo taInfo,\n       OutputCommitter committer, boolean recoverOutput) {\n     ContainerId containerId \u003d taInfo.getContainerId();\n     NodeId containerNodeId \u003d ConverterUtils.toNodeId(taInfo.getHostname() + \":\"\n         + taInfo.getPort());\n     String nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n         + taInfo.getHttpPort());\n     // Resource/Priority/Tokens and RMIdentifier are only needed while\n     // launching the container on an NM, these are already completed tasks, so\n     // setting them to null and RMIdentifier as 0\n     container \u003d\n-        BuilderUtils.newContainer(containerId, containerNodeId,\n+        Container.newInstance(containerId, containerNodeId,\n           nodeHttpAddress, null, null, null, 0);\n     computeRackAndLocality();\n     launchTime \u003d taInfo.getStartTime();\n     finishTime \u003d (taInfo.getFinishTime() !\u003d -1) ?\n         taInfo.getFinishTime() : clock.getTime();\n     shufflePort \u003d taInfo.getShufflePort();\n     trackerName \u003d taInfo.getHostname();\n     httpPort \u003d taInfo.getHttpPort();\n     sendLaunchedEvents();\n \n     reportedStatus.id \u003d attemptId;\n     reportedStatus.progress \u003d 1.0f;\n     reportedStatus.counters \u003d taInfo.getCounters();\n     reportedStatus.stateString \u003d taInfo.getState();\n     reportedStatus.phase \u003d Phase.CLEANUP;\n     reportedStatus.mapFinishTime \u003d taInfo.getMapFinishTime();\n     reportedStatus.shuffleFinishTime \u003d taInfo.getShuffleFinishTime();\n     reportedStatus.sortFinishTime \u003d taInfo.getSortFinishTime();\n     addDiagnosticInfo(taInfo.getError());\n \n     boolean needToClean \u003d false;\n     String recoveredState \u003d taInfo.getTaskStatus();\n     if (recoverOutput\n         \u0026\u0026 TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n       TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n           TypeConverter.fromYarn(attemptId));\n       try {\n         committer.recoverTask(tac);\n         LOG.info(\"Recovered output from task attempt \" + attemptId);\n       } catch (Exception e) {\n         LOG.error(\"Unable to recover task attempt \" + attemptId, e);\n         LOG.info(\"Task attempt \" + attemptId + \" will be recovered as KILLED\");\n         recoveredState \u003d TaskAttemptState.KILLED.toString();\n         needToClean \u003d true;\n       }\n     }\n \n     TaskAttemptStateInternal attemptState;\n     if (TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n       attemptState \u003d TaskAttemptStateInternal.SUCCEEDED;\n       reportedStatus.taskState \u003d TaskAttemptState.SUCCEEDED;\n       eventHandler.handle(createJobCounterUpdateEventTASucceeded(this));\n       logAttemptFinishedEvent(attemptState);\n     } else if (TaskAttemptState.FAILED.toString().equals(recoveredState)) {\n       attemptState \u003d TaskAttemptStateInternal.FAILED;\n       reportedStatus.taskState \u003d TaskAttemptState.FAILED;\n       eventHandler.handle(createJobCounterUpdateEventTAFailed(this, false));\n       TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n           createTaskAttemptUnsuccessfulCompletionEvent(this,\n               TaskAttemptStateInternal.FAILED);\n       eventHandler.handle(\n           new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n     } else {\n       if (!TaskAttemptState.KILLED.toString().equals(recoveredState)) {\n         if (String.valueOf(recoveredState).isEmpty()) {\n           LOG.info(\"TaskAttempt\" + attemptId\n               + \" had not completed, recovering as KILLED\");\n         } else {\n           LOG.warn(\"TaskAttempt \" + attemptId + \" found in unexpected state \"\n               + recoveredState + \", recovering as KILLED\");\n         }\n         addDiagnosticInfo(\"Killed during application recovery\");\n         needToClean \u003d true;\n       }\n       attemptState \u003d TaskAttemptStateInternal.KILLED;\n       reportedStatus.taskState \u003d TaskAttemptState.KILLED;\n       eventHandler.handle(createJobCounterUpdateEventTAKilled(this, false));\n       TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n           createTaskAttemptUnsuccessfulCompletionEvent(this,\n               TaskAttemptStateInternal.KILLED);\n       eventHandler.handle(\n           new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n     }\n \n     if (needToClean) {\n       TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n           TypeConverter.fromYarn(attemptId));\n       try {\n         committer.abortTask(tac);\n       } catch (Exception e) {\n         LOG.warn(\"Task cleanup failed for attempt \" + attemptId, e);\n       }\n     }\n \n     return attemptState;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TaskAttemptStateInternal recover(TaskAttemptInfo taInfo,\n      OutputCommitter committer, boolean recoverOutput) {\n    ContainerId containerId \u003d taInfo.getContainerId();\n    NodeId containerNodeId \u003d ConverterUtils.toNodeId(taInfo.getHostname() + \":\"\n        + taInfo.getPort());\n    String nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n        + taInfo.getHttpPort());\n    // Resource/Priority/Tokens and RMIdentifier are only needed while\n    // launching the container on an NM, these are already completed tasks, so\n    // setting them to null and RMIdentifier as 0\n    container \u003d\n        Container.newInstance(containerId, containerNodeId,\n          nodeHttpAddress, null, null, null, 0);\n    computeRackAndLocality();\n    launchTime \u003d taInfo.getStartTime();\n    finishTime \u003d (taInfo.getFinishTime() !\u003d -1) ?\n        taInfo.getFinishTime() : clock.getTime();\n    shufflePort \u003d taInfo.getShufflePort();\n    trackerName \u003d taInfo.getHostname();\n    httpPort \u003d taInfo.getHttpPort();\n    sendLaunchedEvents();\n\n    reportedStatus.id \u003d attemptId;\n    reportedStatus.progress \u003d 1.0f;\n    reportedStatus.counters \u003d taInfo.getCounters();\n    reportedStatus.stateString \u003d taInfo.getState();\n    reportedStatus.phase \u003d Phase.CLEANUP;\n    reportedStatus.mapFinishTime \u003d taInfo.getMapFinishTime();\n    reportedStatus.shuffleFinishTime \u003d taInfo.getShuffleFinishTime();\n    reportedStatus.sortFinishTime \u003d taInfo.getSortFinishTime();\n    addDiagnosticInfo(taInfo.getError());\n\n    boolean needToClean \u003d false;\n    String recoveredState \u003d taInfo.getTaskStatus();\n    if (recoverOutput\n        \u0026\u0026 TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n          TypeConverter.fromYarn(attemptId));\n      try {\n        committer.recoverTask(tac);\n        LOG.info(\"Recovered output from task attempt \" + attemptId);\n      } catch (Exception e) {\n        LOG.error(\"Unable to recover task attempt \" + attemptId, e);\n        LOG.info(\"Task attempt \" + attemptId + \" will be recovered as KILLED\");\n        recoveredState \u003d TaskAttemptState.KILLED.toString();\n        needToClean \u003d true;\n      }\n    }\n\n    TaskAttemptStateInternal attemptState;\n    if (TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n      attemptState \u003d TaskAttemptStateInternal.SUCCEEDED;\n      reportedStatus.taskState \u003d TaskAttemptState.SUCCEEDED;\n      eventHandler.handle(createJobCounterUpdateEventTASucceeded(this));\n      logAttemptFinishedEvent(attemptState);\n    } else if (TaskAttemptState.FAILED.toString().equals(recoveredState)) {\n      attemptState \u003d TaskAttemptStateInternal.FAILED;\n      reportedStatus.taskState \u003d TaskAttemptState.FAILED;\n      eventHandler.handle(createJobCounterUpdateEventTAFailed(this, false));\n      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n          createTaskAttemptUnsuccessfulCompletionEvent(this,\n              TaskAttemptStateInternal.FAILED);\n      eventHandler.handle(\n          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n    } else {\n      if (!TaskAttemptState.KILLED.toString().equals(recoveredState)) {\n        if (String.valueOf(recoveredState).isEmpty()) {\n          LOG.info(\"TaskAttempt\" + attemptId\n              + \" had not completed, recovering as KILLED\");\n        } else {\n          LOG.warn(\"TaskAttempt \" + attemptId + \" found in unexpected state \"\n              + recoveredState + \", recovering as KILLED\");\n        }\n        addDiagnosticInfo(\"Killed during application recovery\");\n        needToClean \u003d true;\n      }\n      attemptState \u003d TaskAttemptStateInternal.KILLED;\n      reportedStatus.taskState \u003d TaskAttemptState.KILLED;\n      eventHandler.handle(createJobCounterUpdateEventTAKilled(this, false));\n      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n          createTaskAttemptUnsuccessfulCompletionEvent(this,\n              TaskAttemptStateInternal.KILLED);\n      eventHandler.handle(\n          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n    }\n\n    if (needToClean) {\n      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n          TypeConverter.fromYarn(attemptId));\n      try {\n        committer.abortTask(tac);\n      } catch (Exception e) {\n        LOG.warn(\"Task cleanup failed for attempt \" + attemptId, e);\n      }\n    }\n\n    return attemptState;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java",
      "extendedDetails": {}
    },
    "fbb55784d93e1a819daf55d936e864d344579cbf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-562. Modified NM to reject any containers allocated by a previous ResourceManager. Contributed by Jian He.\nMAPREDUCE-5167. Update MR App after YARN-562 to use the new builder API for the container. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1476034 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/04/13 8:50 PM",
      "commitName": "fbb55784d93e1a819daf55d936e864d344579cbf",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/04/13 1:13 PM",
      "commitNameOld": "cb78a65a152a4f576a3255df3676c3b788c84eb5",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.32,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n   public TaskAttemptStateInternal recover(TaskAttemptInfo taInfo,\n       OutputCommitter committer, boolean recoverOutput) {\n     ContainerId containerId \u003d taInfo.getContainerId();\n     NodeId containerNodeId \u003d ConverterUtils.toNodeId(taInfo.getHostname() + \":\"\n         + taInfo.getPort());\n     String nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n         + taInfo.getHttpPort());\n-    // Resource/Priority/Tokens are only needed while launching the\n-    // container on an NM, these are already completed tasks, so setting them to\n-    // null\n+    // Resource/Priority/Tokens and RMIdentifier are only needed while\n+    // launching the container on an NM, these are already completed tasks, so\n+    // setting them to null and RMIdentifier as 0\n     container \u003d\n         BuilderUtils.newContainer(containerId, containerNodeId,\n-          nodeHttpAddress, null, null, null);\n+          nodeHttpAddress, null, null, null, 0);\n     computeRackAndLocality();\n     launchTime \u003d taInfo.getStartTime();\n     finishTime \u003d (taInfo.getFinishTime() !\u003d -1) ?\n         taInfo.getFinishTime() : clock.getTime();\n     shufflePort \u003d taInfo.getShufflePort();\n     trackerName \u003d taInfo.getHostname();\n     httpPort \u003d taInfo.getHttpPort();\n     sendLaunchedEvents();\n \n     reportedStatus.id \u003d attemptId;\n     reportedStatus.progress \u003d 1.0f;\n     reportedStatus.counters \u003d taInfo.getCounters();\n     reportedStatus.stateString \u003d taInfo.getState();\n     reportedStatus.phase \u003d Phase.CLEANUP;\n     reportedStatus.mapFinishTime \u003d taInfo.getMapFinishTime();\n     reportedStatus.shuffleFinishTime \u003d taInfo.getShuffleFinishTime();\n     reportedStatus.sortFinishTime \u003d taInfo.getSortFinishTime();\n     addDiagnosticInfo(taInfo.getError());\n \n     boolean needToClean \u003d false;\n     String recoveredState \u003d taInfo.getTaskStatus();\n     if (recoverOutput\n         \u0026\u0026 TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n       TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n           TypeConverter.fromYarn(attemptId));\n       try {\n         committer.recoverTask(tac);\n         LOG.info(\"Recovered output from task attempt \" + attemptId);\n       } catch (Exception e) {\n         LOG.error(\"Unable to recover task attempt \" + attemptId, e);\n         LOG.info(\"Task attempt \" + attemptId + \" will be recovered as KILLED\");\n         recoveredState \u003d TaskAttemptState.KILLED.toString();\n         needToClean \u003d true;\n       }\n     }\n \n     TaskAttemptStateInternal attemptState;\n     if (TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n       attemptState \u003d TaskAttemptStateInternal.SUCCEEDED;\n       reportedStatus.taskState \u003d TaskAttemptState.SUCCEEDED;\n       eventHandler.handle(createJobCounterUpdateEventTASucceeded(this));\n       logAttemptFinishedEvent(attemptState);\n     } else if (TaskAttemptState.FAILED.toString().equals(recoveredState)) {\n       attemptState \u003d TaskAttemptStateInternal.FAILED;\n       reportedStatus.taskState \u003d TaskAttemptState.FAILED;\n       eventHandler.handle(createJobCounterUpdateEventTAFailed(this, false));\n       TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n           createTaskAttemptUnsuccessfulCompletionEvent(this,\n               TaskAttemptStateInternal.FAILED);\n       eventHandler.handle(\n           new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n     } else {\n       if (!TaskAttemptState.KILLED.toString().equals(recoveredState)) {\n         if (String.valueOf(recoveredState).isEmpty()) {\n           LOG.info(\"TaskAttempt\" + attemptId\n               + \" had not completed, recovering as KILLED\");\n         } else {\n           LOG.warn(\"TaskAttempt \" + attemptId + \" found in unexpected state \"\n               + recoveredState + \", recovering as KILLED\");\n         }\n         addDiagnosticInfo(\"Killed during application recovery\");\n         needToClean \u003d true;\n       }\n       attemptState \u003d TaskAttemptStateInternal.KILLED;\n       reportedStatus.taskState \u003d TaskAttemptState.KILLED;\n       eventHandler.handle(createJobCounterUpdateEventTAKilled(this, false));\n       TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n           createTaskAttemptUnsuccessfulCompletionEvent(this,\n               TaskAttemptStateInternal.KILLED);\n       eventHandler.handle(\n           new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n     }\n \n     if (needToClean) {\n       TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n           TypeConverter.fromYarn(attemptId));\n       try {\n         committer.abortTask(tac);\n       } catch (Exception e) {\n         LOG.warn(\"Task cleanup failed for attempt \" + attemptId, e);\n       }\n     }\n \n     return attemptState;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TaskAttemptStateInternal recover(TaskAttemptInfo taInfo,\n      OutputCommitter committer, boolean recoverOutput) {\n    ContainerId containerId \u003d taInfo.getContainerId();\n    NodeId containerNodeId \u003d ConverterUtils.toNodeId(taInfo.getHostname() + \":\"\n        + taInfo.getPort());\n    String nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n        + taInfo.getHttpPort());\n    // Resource/Priority/Tokens and RMIdentifier are only needed while\n    // launching the container on an NM, these are already completed tasks, so\n    // setting them to null and RMIdentifier as 0\n    container \u003d\n        BuilderUtils.newContainer(containerId, containerNodeId,\n          nodeHttpAddress, null, null, null, 0);\n    computeRackAndLocality();\n    launchTime \u003d taInfo.getStartTime();\n    finishTime \u003d (taInfo.getFinishTime() !\u003d -1) ?\n        taInfo.getFinishTime() : clock.getTime();\n    shufflePort \u003d taInfo.getShufflePort();\n    trackerName \u003d taInfo.getHostname();\n    httpPort \u003d taInfo.getHttpPort();\n    sendLaunchedEvents();\n\n    reportedStatus.id \u003d attemptId;\n    reportedStatus.progress \u003d 1.0f;\n    reportedStatus.counters \u003d taInfo.getCounters();\n    reportedStatus.stateString \u003d taInfo.getState();\n    reportedStatus.phase \u003d Phase.CLEANUP;\n    reportedStatus.mapFinishTime \u003d taInfo.getMapFinishTime();\n    reportedStatus.shuffleFinishTime \u003d taInfo.getShuffleFinishTime();\n    reportedStatus.sortFinishTime \u003d taInfo.getSortFinishTime();\n    addDiagnosticInfo(taInfo.getError());\n\n    boolean needToClean \u003d false;\n    String recoveredState \u003d taInfo.getTaskStatus();\n    if (recoverOutput\n        \u0026\u0026 TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n          TypeConverter.fromYarn(attemptId));\n      try {\n        committer.recoverTask(tac);\n        LOG.info(\"Recovered output from task attempt \" + attemptId);\n      } catch (Exception e) {\n        LOG.error(\"Unable to recover task attempt \" + attemptId, e);\n        LOG.info(\"Task attempt \" + attemptId + \" will be recovered as KILLED\");\n        recoveredState \u003d TaskAttemptState.KILLED.toString();\n        needToClean \u003d true;\n      }\n    }\n\n    TaskAttemptStateInternal attemptState;\n    if (TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n      attemptState \u003d TaskAttemptStateInternal.SUCCEEDED;\n      reportedStatus.taskState \u003d TaskAttemptState.SUCCEEDED;\n      eventHandler.handle(createJobCounterUpdateEventTASucceeded(this));\n      logAttemptFinishedEvent(attemptState);\n    } else if (TaskAttemptState.FAILED.toString().equals(recoveredState)) {\n      attemptState \u003d TaskAttemptStateInternal.FAILED;\n      reportedStatus.taskState \u003d TaskAttemptState.FAILED;\n      eventHandler.handle(createJobCounterUpdateEventTAFailed(this, false));\n      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n          createTaskAttemptUnsuccessfulCompletionEvent(this,\n              TaskAttemptStateInternal.FAILED);\n      eventHandler.handle(\n          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n    } else {\n      if (!TaskAttemptState.KILLED.toString().equals(recoveredState)) {\n        if (String.valueOf(recoveredState).isEmpty()) {\n          LOG.info(\"TaskAttempt\" + attemptId\n              + \" had not completed, recovering as KILLED\");\n        } else {\n          LOG.warn(\"TaskAttempt \" + attemptId + \" found in unexpected state \"\n              + recoveredState + \", recovering as KILLED\");\n        }\n        addDiagnosticInfo(\"Killed during application recovery\");\n        needToClean \u003d true;\n      }\n      attemptState \u003d TaskAttemptStateInternal.KILLED;\n      reportedStatus.taskState \u003d TaskAttemptState.KILLED;\n      eventHandler.handle(createJobCounterUpdateEventTAKilled(this, false));\n      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n          createTaskAttemptUnsuccessfulCompletionEvent(this,\n              TaskAttemptStateInternal.KILLED);\n      eventHandler.handle(\n          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n    }\n\n    if (needToClean) {\n      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n          TypeConverter.fromYarn(attemptId));\n      try {\n        committer.abortTask(tac);\n      } catch (Exception e) {\n        LOG.warn(\"Task cleanup failed for attempt \" + attemptId, e);\n      }\n    }\n\n    return attemptState;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java",
      "extendedDetails": {}
    },
    "cb78a65a152a4f576a3255df3676c3b788c84eb5": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5152. Make MR App to simply pass through the container from RM instead of extracting and populating information itself to start any container. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469544 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/04/13 1:13 PM",
      "commitName": "cb78a65a152a4f576a3255df3676c3b788c84eb5",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/04/13 12:28 PM",
      "commitNameOld": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.03,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,98 @@\n   public TaskAttemptStateInternal recover(TaskAttemptInfo taInfo,\n       OutputCommitter committer, boolean recoverOutput) {\n-    containerID \u003d taInfo.getContainerId();\n-    containerNodeId \u003d ConverterUtils.toNodeId(taInfo.getHostname() + \":\"\n+    ContainerId containerId \u003d taInfo.getContainerId();\n+    NodeId containerNodeId \u003d ConverterUtils.toNodeId(taInfo.getHostname() + \":\"\n         + taInfo.getPort());\n-    containerMgrAddress \u003d StringInterner.weakIntern(\n-        containerNodeId.toString());\n-    nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n+    String nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n         + taInfo.getHttpPort());\n+    // Resource/Priority/Tokens are only needed while launching the\n+    // container on an NM, these are already completed tasks, so setting them to\n+    // null\n+    container \u003d\n+        BuilderUtils.newContainer(containerId, containerNodeId,\n+          nodeHttpAddress, null, null, null);\n     computeRackAndLocality();\n     launchTime \u003d taInfo.getStartTime();\n     finishTime \u003d (taInfo.getFinishTime() !\u003d -1) ?\n         taInfo.getFinishTime() : clock.getTime();\n     shufflePort \u003d taInfo.getShufflePort();\n     trackerName \u003d taInfo.getHostname();\n     httpPort \u003d taInfo.getHttpPort();\n     sendLaunchedEvents();\n \n     reportedStatus.id \u003d attemptId;\n     reportedStatus.progress \u003d 1.0f;\n     reportedStatus.counters \u003d taInfo.getCounters();\n     reportedStatus.stateString \u003d taInfo.getState();\n     reportedStatus.phase \u003d Phase.CLEANUP;\n     reportedStatus.mapFinishTime \u003d taInfo.getMapFinishTime();\n     reportedStatus.shuffleFinishTime \u003d taInfo.getShuffleFinishTime();\n     reportedStatus.sortFinishTime \u003d taInfo.getSortFinishTime();\n     addDiagnosticInfo(taInfo.getError());\n \n     boolean needToClean \u003d false;\n     String recoveredState \u003d taInfo.getTaskStatus();\n     if (recoverOutput\n         \u0026\u0026 TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n       TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n           TypeConverter.fromYarn(attemptId));\n       try {\n         committer.recoverTask(tac);\n         LOG.info(\"Recovered output from task attempt \" + attemptId);\n       } catch (Exception e) {\n         LOG.error(\"Unable to recover task attempt \" + attemptId, e);\n         LOG.info(\"Task attempt \" + attemptId + \" will be recovered as KILLED\");\n         recoveredState \u003d TaskAttemptState.KILLED.toString();\n         needToClean \u003d true;\n       }\n     }\n \n     TaskAttemptStateInternal attemptState;\n     if (TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n       attemptState \u003d TaskAttemptStateInternal.SUCCEEDED;\n       reportedStatus.taskState \u003d TaskAttemptState.SUCCEEDED;\n       eventHandler.handle(createJobCounterUpdateEventTASucceeded(this));\n       logAttemptFinishedEvent(attemptState);\n     } else if (TaskAttemptState.FAILED.toString().equals(recoveredState)) {\n       attemptState \u003d TaskAttemptStateInternal.FAILED;\n       reportedStatus.taskState \u003d TaskAttemptState.FAILED;\n       eventHandler.handle(createJobCounterUpdateEventTAFailed(this, false));\n       TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n           createTaskAttemptUnsuccessfulCompletionEvent(this,\n               TaskAttemptStateInternal.FAILED);\n       eventHandler.handle(\n           new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n     } else {\n       if (!TaskAttemptState.KILLED.toString().equals(recoveredState)) {\n         if (String.valueOf(recoveredState).isEmpty()) {\n           LOG.info(\"TaskAttempt\" + attemptId\n               + \" had not completed, recovering as KILLED\");\n         } else {\n           LOG.warn(\"TaskAttempt \" + attemptId + \" found in unexpected state \"\n               + recoveredState + \", recovering as KILLED\");\n         }\n         addDiagnosticInfo(\"Killed during application recovery\");\n         needToClean \u003d true;\n       }\n       attemptState \u003d TaskAttemptStateInternal.KILLED;\n       reportedStatus.taskState \u003d TaskAttemptState.KILLED;\n       eventHandler.handle(createJobCounterUpdateEventTAKilled(this, false));\n       TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n           createTaskAttemptUnsuccessfulCompletionEvent(this,\n               TaskAttemptStateInternal.KILLED);\n       eventHandler.handle(\n           new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n     }\n \n     if (needToClean) {\n       TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n           TypeConverter.fromYarn(attemptId));\n       try {\n         committer.abortTask(tac);\n       } catch (Exception e) {\n         LOG.warn(\"Task cleanup failed for attempt \" + attemptId, e);\n       }\n     }\n \n     return attemptState;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TaskAttemptStateInternal recover(TaskAttemptInfo taInfo,\n      OutputCommitter committer, boolean recoverOutput) {\n    ContainerId containerId \u003d taInfo.getContainerId();\n    NodeId containerNodeId \u003d ConverterUtils.toNodeId(taInfo.getHostname() + \":\"\n        + taInfo.getPort());\n    String nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n        + taInfo.getHttpPort());\n    // Resource/Priority/Tokens are only needed while launching the\n    // container on an NM, these are already completed tasks, so setting them to\n    // null\n    container \u003d\n        BuilderUtils.newContainer(containerId, containerNodeId,\n          nodeHttpAddress, null, null, null);\n    computeRackAndLocality();\n    launchTime \u003d taInfo.getStartTime();\n    finishTime \u003d (taInfo.getFinishTime() !\u003d -1) ?\n        taInfo.getFinishTime() : clock.getTime();\n    shufflePort \u003d taInfo.getShufflePort();\n    trackerName \u003d taInfo.getHostname();\n    httpPort \u003d taInfo.getHttpPort();\n    sendLaunchedEvents();\n\n    reportedStatus.id \u003d attemptId;\n    reportedStatus.progress \u003d 1.0f;\n    reportedStatus.counters \u003d taInfo.getCounters();\n    reportedStatus.stateString \u003d taInfo.getState();\n    reportedStatus.phase \u003d Phase.CLEANUP;\n    reportedStatus.mapFinishTime \u003d taInfo.getMapFinishTime();\n    reportedStatus.shuffleFinishTime \u003d taInfo.getShuffleFinishTime();\n    reportedStatus.sortFinishTime \u003d taInfo.getSortFinishTime();\n    addDiagnosticInfo(taInfo.getError());\n\n    boolean needToClean \u003d false;\n    String recoveredState \u003d taInfo.getTaskStatus();\n    if (recoverOutput\n        \u0026\u0026 TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n          TypeConverter.fromYarn(attemptId));\n      try {\n        committer.recoverTask(tac);\n        LOG.info(\"Recovered output from task attempt \" + attemptId);\n      } catch (Exception e) {\n        LOG.error(\"Unable to recover task attempt \" + attemptId, e);\n        LOG.info(\"Task attempt \" + attemptId + \" will be recovered as KILLED\");\n        recoveredState \u003d TaskAttemptState.KILLED.toString();\n        needToClean \u003d true;\n      }\n    }\n\n    TaskAttemptStateInternal attemptState;\n    if (TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n      attemptState \u003d TaskAttemptStateInternal.SUCCEEDED;\n      reportedStatus.taskState \u003d TaskAttemptState.SUCCEEDED;\n      eventHandler.handle(createJobCounterUpdateEventTASucceeded(this));\n      logAttemptFinishedEvent(attemptState);\n    } else if (TaskAttemptState.FAILED.toString().equals(recoveredState)) {\n      attemptState \u003d TaskAttemptStateInternal.FAILED;\n      reportedStatus.taskState \u003d TaskAttemptState.FAILED;\n      eventHandler.handle(createJobCounterUpdateEventTAFailed(this, false));\n      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n          createTaskAttemptUnsuccessfulCompletionEvent(this,\n              TaskAttemptStateInternal.FAILED);\n      eventHandler.handle(\n          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n    } else {\n      if (!TaskAttemptState.KILLED.toString().equals(recoveredState)) {\n        if (String.valueOf(recoveredState).isEmpty()) {\n          LOG.info(\"TaskAttempt\" + attemptId\n              + \" had not completed, recovering as KILLED\");\n        } else {\n          LOG.warn(\"TaskAttempt \" + attemptId + \" found in unexpected state \"\n              + recoveredState + \", recovering as KILLED\");\n        }\n        addDiagnosticInfo(\"Killed during application recovery\");\n        needToClean \u003d true;\n      }\n      attemptState \u003d TaskAttemptStateInternal.KILLED;\n      reportedStatus.taskState \u003d TaskAttemptState.KILLED;\n      eventHandler.handle(createJobCounterUpdateEventTAKilled(this, false));\n      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n          createTaskAttemptUnsuccessfulCompletionEvent(this,\n              TaskAttemptStateInternal.KILLED);\n      eventHandler.handle(\n          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n    }\n\n    if (needToClean) {\n      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n          TypeConverter.fromYarn(attemptId));\n      try {\n        committer.abortTask(tac);\n      } catch (Exception e) {\n        LOG.warn(\"Task cleanup failed for attempt \" + attemptId, e);\n      }\n    }\n\n    return attemptState;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java",
      "extendedDetails": {}
    },
    "6a1c41111edcdc58c846fc50e53554fbba230171": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-5079. Changes job recovery to restore state directly from job history, instaed of simulating state machine events. Contributed by Jason Lowe and Robert Parker.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1466767 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/04/13 9:52 PM",
      "commitName": "6a1c41111edcdc58c846fc50e53554fbba230171",
      "commitAuthor": "Siddharth Seth",
      "diff": "@@ -0,0 +1,94 @@\n+  public TaskAttemptStateInternal recover(TaskAttemptInfo taInfo,\n+      OutputCommitter committer, boolean recoverOutput) {\n+    containerID \u003d taInfo.getContainerId();\n+    containerNodeId \u003d ConverterUtils.toNodeId(taInfo.getHostname() + \":\"\n+        + taInfo.getPort());\n+    containerMgrAddress \u003d StringInterner.weakIntern(\n+        containerNodeId.toString());\n+    nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n+        + taInfo.getHttpPort());\n+    computeRackAndLocality();\n+    launchTime \u003d taInfo.getStartTime();\n+    finishTime \u003d (taInfo.getFinishTime() !\u003d -1) ?\n+        taInfo.getFinishTime() : clock.getTime();\n+    shufflePort \u003d taInfo.getShufflePort();\n+    trackerName \u003d taInfo.getHostname();\n+    httpPort \u003d taInfo.getHttpPort();\n+    sendLaunchedEvents();\n+\n+    reportedStatus.id \u003d attemptId;\n+    reportedStatus.progress \u003d 1.0f;\n+    reportedStatus.counters \u003d taInfo.getCounters();\n+    reportedStatus.stateString \u003d taInfo.getState();\n+    reportedStatus.phase \u003d Phase.CLEANUP;\n+    reportedStatus.mapFinishTime \u003d taInfo.getMapFinishTime();\n+    reportedStatus.shuffleFinishTime \u003d taInfo.getShuffleFinishTime();\n+    reportedStatus.sortFinishTime \u003d taInfo.getSortFinishTime();\n+    addDiagnosticInfo(taInfo.getError());\n+\n+    boolean needToClean \u003d false;\n+    String recoveredState \u003d taInfo.getTaskStatus();\n+    if (recoverOutput\n+        \u0026\u0026 TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n+      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n+          TypeConverter.fromYarn(attemptId));\n+      try {\n+        committer.recoverTask(tac);\n+        LOG.info(\"Recovered output from task attempt \" + attemptId);\n+      } catch (Exception e) {\n+        LOG.error(\"Unable to recover task attempt \" + attemptId, e);\n+        LOG.info(\"Task attempt \" + attemptId + \" will be recovered as KILLED\");\n+        recoveredState \u003d TaskAttemptState.KILLED.toString();\n+        needToClean \u003d true;\n+      }\n+    }\n+\n+    TaskAttemptStateInternal attemptState;\n+    if (TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n+      attemptState \u003d TaskAttemptStateInternal.SUCCEEDED;\n+      reportedStatus.taskState \u003d TaskAttemptState.SUCCEEDED;\n+      eventHandler.handle(createJobCounterUpdateEventTASucceeded(this));\n+      logAttemptFinishedEvent(attemptState);\n+    } else if (TaskAttemptState.FAILED.toString().equals(recoveredState)) {\n+      attemptState \u003d TaskAttemptStateInternal.FAILED;\n+      reportedStatus.taskState \u003d TaskAttemptState.FAILED;\n+      eventHandler.handle(createJobCounterUpdateEventTAFailed(this, false));\n+      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n+          createTaskAttemptUnsuccessfulCompletionEvent(this,\n+              TaskAttemptStateInternal.FAILED);\n+      eventHandler.handle(\n+          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n+    } else {\n+      if (!TaskAttemptState.KILLED.toString().equals(recoveredState)) {\n+        if (String.valueOf(recoveredState).isEmpty()) {\n+          LOG.info(\"TaskAttempt\" + attemptId\n+              + \" had not completed, recovering as KILLED\");\n+        } else {\n+          LOG.warn(\"TaskAttempt \" + attemptId + \" found in unexpected state \"\n+              + recoveredState + \", recovering as KILLED\");\n+        }\n+        addDiagnosticInfo(\"Killed during application recovery\");\n+        needToClean \u003d true;\n+      }\n+      attemptState \u003d TaskAttemptStateInternal.KILLED;\n+      reportedStatus.taskState \u003d TaskAttemptState.KILLED;\n+      eventHandler.handle(createJobCounterUpdateEventTAKilled(this, false));\n+      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n+          createTaskAttemptUnsuccessfulCompletionEvent(this,\n+              TaskAttemptStateInternal.KILLED);\n+      eventHandler.handle(\n+          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n+    }\n+\n+    if (needToClean) {\n+      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n+          TypeConverter.fromYarn(attemptId));\n+      try {\n+        committer.abortTask(tac);\n+      } catch (Exception e) {\n+        LOG.warn(\"Task cleanup failed for attempt \" + attemptId, e);\n+      }\n+    }\n+\n+    return attemptState;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public TaskAttemptStateInternal recover(TaskAttemptInfo taInfo,\n      OutputCommitter committer, boolean recoverOutput) {\n    containerID \u003d taInfo.getContainerId();\n    containerNodeId \u003d ConverterUtils.toNodeId(taInfo.getHostname() + \":\"\n        + taInfo.getPort());\n    containerMgrAddress \u003d StringInterner.weakIntern(\n        containerNodeId.toString());\n    nodeHttpAddress \u003d StringInterner.weakIntern(taInfo.getHostname() + \":\"\n        + taInfo.getHttpPort());\n    computeRackAndLocality();\n    launchTime \u003d taInfo.getStartTime();\n    finishTime \u003d (taInfo.getFinishTime() !\u003d -1) ?\n        taInfo.getFinishTime() : clock.getTime();\n    shufflePort \u003d taInfo.getShufflePort();\n    trackerName \u003d taInfo.getHostname();\n    httpPort \u003d taInfo.getHttpPort();\n    sendLaunchedEvents();\n\n    reportedStatus.id \u003d attemptId;\n    reportedStatus.progress \u003d 1.0f;\n    reportedStatus.counters \u003d taInfo.getCounters();\n    reportedStatus.stateString \u003d taInfo.getState();\n    reportedStatus.phase \u003d Phase.CLEANUP;\n    reportedStatus.mapFinishTime \u003d taInfo.getMapFinishTime();\n    reportedStatus.shuffleFinishTime \u003d taInfo.getShuffleFinishTime();\n    reportedStatus.sortFinishTime \u003d taInfo.getSortFinishTime();\n    addDiagnosticInfo(taInfo.getError());\n\n    boolean needToClean \u003d false;\n    String recoveredState \u003d taInfo.getTaskStatus();\n    if (recoverOutput\n        \u0026\u0026 TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n          TypeConverter.fromYarn(attemptId));\n      try {\n        committer.recoverTask(tac);\n        LOG.info(\"Recovered output from task attempt \" + attemptId);\n      } catch (Exception e) {\n        LOG.error(\"Unable to recover task attempt \" + attemptId, e);\n        LOG.info(\"Task attempt \" + attemptId + \" will be recovered as KILLED\");\n        recoveredState \u003d TaskAttemptState.KILLED.toString();\n        needToClean \u003d true;\n      }\n    }\n\n    TaskAttemptStateInternal attemptState;\n    if (TaskAttemptState.SUCCEEDED.toString().equals(recoveredState)) {\n      attemptState \u003d TaskAttemptStateInternal.SUCCEEDED;\n      reportedStatus.taskState \u003d TaskAttemptState.SUCCEEDED;\n      eventHandler.handle(createJobCounterUpdateEventTASucceeded(this));\n      logAttemptFinishedEvent(attemptState);\n    } else if (TaskAttemptState.FAILED.toString().equals(recoveredState)) {\n      attemptState \u003d TaskAttemptStateInternal.FAILED;\n      reportedStatus.taskState \u003d TaskAttemptState.FAILED;\n      eventHandler.handle(createJobCounterUpdateEventTAFailed(this, false));\n      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n          createTaskAttemptUnsuccessfulCompletionEvent(this,\n              TaskAttemptStateInternal.FAILED);\n      eventHandler.handle(\n          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n    } else {\n      if (!TaskAttemptState.KILLED.toString().equals(recoveredState)) {\n        if (String.valueOf(recoveredState).isEmpty()) {\n          LOG.info(\"TaskAttempt\" + attemptId\n              + \" had not completed, recovering as KILLED\");\n        } else {\n          LOG.warn(\"TaskAttempt \" + attemptId + \" found in unexpected state \"\n              + recoveredState + \", recovering as KILLED\");\n        }\n        addDiagnosticInfo(\"Killed during application recovery\");\n        needToClean \u003d true;\n      }\n      attemptState \u003d TaskAttemptStateInternal.KILLED;\n      reportedStatus.taskState \u003d TaskAttemptState.KILLED;\n      eventHandler.handle(createJobCounterUpdateEventTAKilled(this, false));\n      TaskAttemptUnsuccessfulCompletionEvent tauce \u003d\n          createTaskAttemptUnsuccessfulCompletionEvent(this,\n              TaskAttemptStateInternal.KILLED);\n      eventHandler.handle(\n          new JobHistoryEvent(attemptId.getTaskId().getJobId(), tauce));\n    }\n\n    if (needToClean) {\n      TaskAttemptContext tac \u003d new TaskAttemptContextImpl(conf,\n          TypeConverter.fromYarn(attemptId));\n      try {\n        committer.abortTask(tac);\n      } catch (Exception e) {\n        LOG.warn(\"Task cleanup failed for attempt \" + attemptId, e);\n      }\n    }\n\n    return attemptState;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java"
    }
  }
}