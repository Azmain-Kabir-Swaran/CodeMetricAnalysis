{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FsDatasetImpl.java",
  "functionName": "updateReplicaUnderRecovery",
  "functionId": "updateReplicaUnderRecovery___oldBlock-ExtendedBlock(modifiers-final)__recoveryId-long(modifiers-final)__newBlockId-long(modifiers-final)__newlength-long(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
  "functionStartLine": 2760,
  "functionEndLine": 2829,
  "numCommitsSeen": 303,
  "timeTaken": 13082,
  "changeHistory": [
    "d3b595157256e198c4340d555e14ad6144f2eaa1",
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
    "86c9862bec0248d671e657aa56094a2919b8ac14",
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
    "d1d4e16690cc85f7f22fbead9cf596260819b561",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
    "bc13dfb1426944ce45293cb8f444239a7406762c",
    "6326605acb5a5bf48d994278c9d3a39733679e81",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "d3b595157256e198c4340d555e14ad6144f2eaa1": "Ybodychange",
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8": "Ybodychange",
    "86c9862bec0248d671e657aa56094a2919b8ac14": "Ybodychange",
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c": "Ymultichange(Ymodifierchange,Ybodychange)",
    "d1d4e16690cc85f7f22fbead9cf596260819b561": "Ymultichange(Yreturntypechange,Ybodychange)",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": "Ymultichange(Yparameterchange,Ybodychange)",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": "Ybodychange",
    "bc13dfb1426944ce45293cb8f444239a7406762c": "Ymultichange(Ymovefromfile,Ybodychange)",
    "6326605acb5a5bf48d994278c9d3a39733679e81": "Ymultichange(Yreturntypechange,Ybodychange)",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d3b595157256e198c4340d555e14ad6144f2eaa1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15242. Add metrics for operations hold lock times of FsDatasetImpl. Contributed by Xiaoqiao He.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\nReviewed-by: Inigo Goiri \u003cinigoiri@apache.org\u003e\n",
      "commitDate": "01/04/20 4:36 PM",
      "commitName": "d3b595157256e198c4340d555e14ad6144f2eaa1",
      "commitAuthor": "He Xiaoqiao",
      "commitDateOld": "11/02/20 8:00 AM",
      "commitNameOld": "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
      "commitAuthorOld": "Stephen O\u0027Donnell",
      "daysBetweenCommits": 50.32,
      "commitsBetweenForRepo": 174,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,70 @@\n   public Replica updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n                                     final long newBlockId,\n                                     final long newlength) throws IOException {\n+    long startTimeMs \u003d Time.monotonicNow();\n     try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n       //get replica\n       final String bpid \u003d oldBlock.getBlockPoolId();\n       final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n       LOG.info(\"updateReplica: \" + oldBlock\n           + \", recoveryId\u003d\" + recoveryId\n           + \", length\u003d\" + newlength\n           + \", replica\u003d\" + replica);\n \n       //check replica\n       if (replica \u003d\u003d null) {\n         throw new ReplicaNotFoundException(oldBlock);\n       }\n \n       //check replica state\n       if (replica.getState() !\u003d ReplicaState.RUR) {\n         throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n             + \", replica\u003d\" + replica);\n       }\n \n       //check replica\u0027s byte on disk\n       if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n         throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n             + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n             + oldBlock + \", replica\u003d\" + replica);\n       }\n \n       //check replica files before update\n       checkReplicaFiles(replica);\n \n       //update replica\n       final ReplicaInfo finalized \u003d updateReplicaUnderRecovery(oldBlock\n           .getBlockPoolId(), replica, recoveryId,\n           newBlockId, newlength);\n \n       boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n       if (!copyTruncate) {\n         assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n             \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n             \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n             : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n             + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n             + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n       } else {\n         assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n             \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n             \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n             : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n             + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n             + \", len\u003d\" + oldBlock.getNumBytes()\n             + \", finalized\u003d\" + finalized;\n       }\n       //check replica files after update\n       checkReplicaFiles(finalized);\n \n       return finalized;\n+    } finally {\n+      if (dataNodeMetrics !\u003d null) {\n+        long updateReplicaUnderRecoveryMs \u003d Time.monotonicNow() - startTimeMs;\n+        dataNodeMetrics.addUpdateReplicaUnderRecoveryOp(\n+            updateReplicaUnderRecoveryMs);\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Replica updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newBlockId,\n                                    final long newlength) throws IOException {\n    long startTimeMs \u003d Time.monotonicNow();\n    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n      //get replica\n      final String bpid \u003d oldBlock.getBlockPoolId();\n      final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n      LOG.info(\"updateReplica: \" + oldBlock\n          + \", recoveryId\u003d\" + recoveryId\n          + \", length\u003d\" + newlength\n          + \", replica\u003d\" + replica);\n\n      //check replica\n      if (replica \u003d\u003d null) {\n        throw new ReplicaNotFoundException(oldBlock);\n      }\n\n      //check replica state\n      if (replica.getState() !\u003d ReplicaState.RUR) {\n        throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n            + \", replica\u003d\" + replica);\n      }\n\n      //check replica\u0027s byte on disk\n      if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n        throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n            + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n            + oldBlock + \", replica\u003d\" + replica);\n      }\n\n      //check replica files before update\n      checkReplicaFiles(replica);\n\n      //update replica\n      final ReplicaInfo finalized \u003d updateReplicaUnderRecovery(oldBlock\n          .getBlockPoolId(), replica, recoveryId,\n          newBlockId, newlength);\n\n      boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n      if (!copyTruncate) {\n        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n            \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n            : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n            + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n      } else {\n        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n            \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n            : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n            + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n            + \", len\u003d\" + oldBlock.getNumBytes()\n            + \", finalized\u003d\" + finalized;\n      }\n      //check replica files after update\n      checkReplicaFiles(finalized);\n\n      return finalized;\n    } finally {\n      if (dataNodeMetrics !\u003d null) {\n        long updateReplicaUnderRecoveryMs \u003d Time.monotonicNow() - startTimeMs;\n        dataNodeMetrics.addUpdateReplicaUnderRecoveryOp(\n            updateReplicaUnderRecoveryMs);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15150. Introduce read write lock to Datanode. Contributed Stephen O\u0027Donnell.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "11/02/20 8:00 AM",
      "commitName": "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
      "commitAuthor": "Stephen O\u0027Donnell",
      "commitDateOld": "28/01/20 10:10 AM",
      "commitNameOld": "1839c467f60cbb8592d446694ec3d7710cda5142",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 13.91,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   public Replica updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n                                     final long newBlockId,\n                                     final long newlength) throws IOException {\n-    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n+    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n       //get replica\n       final String bpid \u003d oldBlock.getBlockPoolId();\n       final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n       LOG.info(\"updateReplica: \" + oldBlock\n           + \", recoveryId\u003d\" + recoveryId\n           + \", length\u003d\" + newlength\n           + \", replica\u003d\" + replica);\n \n       //check replica\n       if (replica \u003d\u003d null) {\n         throw new ReplicaNotFoundException(oldBlock);\n       }\n \n       //check replica state\n       if (replica.getState() !\u003d ReplicaState.RUR) {\n         throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n             + \", replica\u003d\" + replica);\n       }\n \n       //check replica\u0027s byte on disk\n       if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n         throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n             + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n             + oldBlock + \", replica\u003d\" + replica);\n       }\n \n       //check replica files before update\n       checkReplicaFiles(replica);\n \n       //update replica\n       final ReplicaInfo finalized \u003d updateReplicaUnderRecovery(oldBlock\n           .getBlockPoolId(), replica, recoveryId,\n           newBlockId, newlength);\n \n       boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n       if (!copyTruncate) {\n         assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n             \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n             \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n             : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n             + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n             + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n       } else {\n         assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n             \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n             \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n             : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n             + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n             + \", len\u003d\" + oldBlock.getNumBytes()\n             + \", finalized\u003d\" + finalized;\n       }\n       //check replica files after update\n       checkReplicaFiles(finalized);\n \n       return finalized;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Replica updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newBlockId,\n                                    final long newlength) throws IOException {\n    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n      //get replica\n      final String bpid \u003d oldBlock.getBlockPoolId();\n      final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n      LOG.info(\"updateReplica: \" + oldBlock\n          + \", recoveryId\u003d\" + recoveryId\n          + \", length\u003d\" + newlength\n          + \", replica\u003d\" + replica);\n\n      //check replica\n      if (replica \u003d\u003d null) {\n        throw new ReplicaNotFoundException(oldBlock);\n      }\n\n      //check replica state\n      if (replica.getState() !\u003d ReplicaState.RUR) {\n        throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n            + \", replica\u003d\" + replica);\n      }\n\n      //check replica\u0027s byte on disk\n      if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n        throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n            + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n            + oldBlock + \", replica\u003d\" + replica);\n      }\n\n      //check replica files before update\n      checkReplicaFiles(replica);\n\n      //update replica\n      final ReplicaInfo finalized \u003d updateReplicaUnderRecovery(oldBlock\n          .getBlockPoolId(), replica, recoveryId,\n          newBlockId, newlength);\n\n      boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n      if (!copyTruncate) {\n        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n            \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n            : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n            + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n      } else {\n        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n            \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n            : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n            + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n            + \", len\u003d\" + oldBlock.getNumBytes()\n            + \", finalized\u003d\" + finalized;\n      }\n      //check replica files after update\n      checkReplicaFiles(finalized);\n\n      return finalized;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "86c9862bec0248d671e657aa56094a2919b8ac14": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10636. Modify ReplicaInfo to remove the assumption that replica metadata and data are stored in java.io.File. (Virajith Jalaparti via lei)\n",
      "commitDate": "13/09/16 12:54 PM",
      "commitName": "86c9862bec0248d671e657aa56094a2919b8ac14",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "10/09/16 6:22 PM",
      "commitNameOld": "a99bf26a0899bcc4307c3a242c8414eaef555aa7",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 2.77,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,63 @@\n   public Replica updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n                                     final long newBlockId,\n                                     final long newlength) throws IOException {\n     try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       //get replica\n       final String bpid \u003d oldBlock.getBlockPoolId();\n       final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n       LOG.info(\"updateReplica: \" + oldBlock\n           + \", recoveryId\u003d\" + recoveryId\n           + \", length\u003d\" + newlength\n           + \", replica\u003d\" + replica);\n \n       //check replica\n       if (replica \u003d\u003d null) {\n         throw new ReplicaNotFoundException(oldBlock);\n       }\n \n       //check replica state\n       if (replica.getState() !\u003d ReplicaState.RUR) {\n         throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n             + \", replica\u003d\" + replica);\n       }\n \n       //check replica\u0027s byte on disk\n       if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n         throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n             + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n             + oldBlock + \", replica\u003d\" + replica);\n       }\n \n       //check replica files before update\n       checkReplicaFiles(replica);\n \n       //update replica\n-      final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n-              .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n+      final ReplicaInfo finalized \u003d updateReplicaUnderRecovery(oldBlock\n+          .getBlockPoolId(), replica, recoveryId,\n           newBlockId, newlength);\n \n       boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n       if (!copyTruncate) {\n         assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n             \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n             \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n             : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n             + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n             + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n       } else {\n         assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n             \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n             \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n             : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n             + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n             + \", len\u003d\" + oldBlock.getNumBytes()\n             + \", finalized\u003d\" + finalized;\n       }\n-\n       //check replica files after update\n       checkReplicaFiles(finalized);\n \n       return finalized;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Replica updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newBlockId,\n                                    final long newlength) throws IOException {\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      //get replica\n      final String bpid \u003d oldBlock.getBlockPoolId();\n      final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n      LOG.info(\"updateReplica: \" + oldBlock\n          + \", recoveryId\u003d\" + recoveryId\n          + \", length\u003d\" + newlength\n          + \", replica\u003d\" + replica);\n\n      //check replica\n      if (replica \u003d\u003d null) {\n        throw new ReplicaNotFoundException(oldBlock);\n      }\n\n      //check replica state\n      if (replica.getState() !\u003d ReplicaState.RUR) {\n        throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n            + \", replica\u003d\" + replica);\n      }\n\n      //check replica\u0027s byte on disk\n      if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n        throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n            + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n            + oldBlock + \", replica\u003d\" + replica);\n      }\n\n      //check replica files before update\n      checkReplicaFiles(replica);\n\n      //update replica\n      final ReplicaInfo finalized \u003d updateReplicaUnderRecovery(oldBlock\n          .getBlockPoolId(), replica, recoveryId,\n          newBlockId, newlength);\n\n      boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n      if (!copyTruncate) {\n        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n            \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n            : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n            + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n      } else {\n        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n            \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n            : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n            + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n            + \", len\u003d\" + oldBlock.getNumBytes()\n            + \", finalized\u003d\" + finalized;\n      }\n      //check replica files after update\n      checkReplicaFiles(finalized);\n\n      return finalized;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HADOOP-10682. Replace FsDatasetImpl object lock with a separate lock object. (Chen Liang)\n",
      "commitDate": "08/08/16 12:02 PM",
      "commitName": "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
      "commitAuthor": "Arpit Agarwal",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HADOOP-10682. Replace FsDatasetImpl object lock with a separate lock object. (Chen Liang)\n",
          "commitDate": "08/08/16 12:02 PM",
          "commitName": "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "08/07/16 7:40 PM",
          "commitNameOld": "da6f1b88dd47e22b24d44f6fc8bbee73e85746f7",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 30.68,
          "commitsBetweenForRepo": 320,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,64 @@\n-  public synchronized Replica updateReplicaUnderRecovery(\n+  public Replica updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n                                     final long newBlockId,\n                                     final long newlength) throws IOException {\n-    //get replica\n-    final String bpid \u003d oldBlock.getBlockPoolId();\n-    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n-    LOG.info(\"updateReplica: \" + oldBlock\n-                 + \", recoveryId\u003d\" + recoveryId\n-                 + \", length\u003d\" + newlength\n-                 + \", replica\u003d\" + replica);\n-\n-    //check replica\n-    if (replica \u003d\u003d null) {\n-      throw new ReplicaNotFoundException(oldBlock);\n-    }\n-\n-    //check replica state\n-    if (replica.getState() !\u003d ReplicaState.RUR) {\n-      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n+    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n+      //get replica\n+      final String bpid \u003d oldBlock.getBlockPoolId();\n+      final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n+      LOG.info(\"updateReplica: \" + oldBlock\n+          + \", recoveryId\u003d\" + recoveryId\n+          + \", length\u003d\" + newlength\n           + \", replica\u003d\" + replica);\n+\n+      //check replica\n+      if (replica \u003d\u003d null) {\n+        throw new ReplicaNotFoundException(oldBlock);\n+      }\n+\n+      //check replica state\n+      if (replica.getState() !\u003d ReplicaState.RUR) {\n+        throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n+            + \", replica\u003d\" + replica);\n+      }\n+\n+      //check replica\u0027s byte on disk\n+      if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n+        throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n+            + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n+            + oldBlock + \", replica\u003d\" + replica);\n+      }\n+\n+      //check replica files before update\n+      checkReplicaFiles(replica);\n+\n+      //update replica\n+      final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n+              .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n+          newBlockId, newlength);\n+\n+      boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n+      if (!copyTruncate) {\n+        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n+            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n+            \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n+            : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n+            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n+            + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n+      } else {\n+        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n+            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n+            \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n+            : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n+            + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n+            + \", len\u003d\" + oldBlock.getNumBytes()\n+            + \", finalized\u003d\" + finalized;\n+      }\n+\n+      //check replica files after update\n+      checkReplicaFiles(finalized);\n+\n+      return finalized;\n     }\n-\n-    //check replica\u0027s byte on disk\n-    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n-      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n-          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n-          + oldBlock + \", replica\u003d\" + replica);\n-    }\n-\n-    //check replica files before update\n-    checkReplicaFiles(replica);\n-\n-    //update replica\n-    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n-        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n-        newBlockId, newlength);\n-\n-    boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n-    if(!copyTruncate) {\n-      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n-          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n-          \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n-          : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n-              + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n-              + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n-    } else {\n-      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n-          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n-          \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n-          : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n-              + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n-              + \", len\u003d\" + oldBlock.getNumBytes()\n-              + \", finalized\u003d\" + finalized;\n-    }\n-\n-    //check replica files after update\n-    checkReplicaFiles(finalized);\n-\n-    return finalized;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Replica updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newBlockId,\n                                    final long newlength) throws IOException {\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      //get replica\n      final String bpid \u003d oldBlock.getBlockPoolId();\n      final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n      LOG.info(\"updateReplica: \" + oldBlock\n          + \", recoveryId\u003d\" + recoveryId\n          + \", length\u003d\" + newlength\n          + \", replica\u003d\" + replica);\n\n      //check replica\n      if (replica \u003d\u003d null) {\n        throw new ReplicaNotFoundException(oldBlock);\n      }\n\n      //check replica state\n      if (replica.getState() !\u003d ReplicaState.RUR) {\n        throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n            + \", replica\u003d\" + replica);\n      }\n\n      //check replica\u0027s byte on disk\n      if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n        throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n            + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n            + oldBlock + \", replica\u003d\" + replica);\n      }\n\n      //check replica files before update\n      checkReplicaFiles(replica);\n\n      //update replica\n      final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n              .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n          newBlockId, newlength);\n\n      boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n      if (!copyTruncate) {\n        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n            \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n            : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n            + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n      } else {\n        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n            \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n            : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n            + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n            + \", len\u003d\" + oldBlock.getNumBytes()\n            + \", finalized\u003d\" + finalized;\n      }\n\n      //check replica files after update\n      checkReplicaFiles(finalized);\n\n      return finalized;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-10682. Replace FsDatasetImpl object lock with a separate lock object. (Chen Liang)\n",
          "commitDate": "08/08/16 12:02 PM",
          "commitName": "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "08/07/16 7:40 PM",
          "commitNameOld": "da6f1b88dd47e22b24d44f6fc8bbee73e85746f7",
          "commitAuthorOld": "Yongjun Zhang",
          "daysBetweenCommits": 30.68,
          "commitsBetweenForRepo": 320,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,64 @@\n-  public synchronized Replica updateReplicaUnderRecovery(\n+  public Replica updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n                                     final long newBlockId,\n                                     final long newlength) throws IOException {\n-    //get replica\n-    final String bpid \u003d oldBlock.getBlockPoolId();\n-    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n-    LOG.info(\"updateReplica: \" + oldBlock\n-                 + \", recoveryId\u003d\" + recoveryId\n-                 + \", length\u003d\" + newlength\n-                 + \", replica\u003d\" + replica);\n-\n-    //check replica\n-    if (replica \u003d\u003d null) {\n-      throw new ReplicaNotFoundException(oldBlock);\n-    }\n-\n-    //check replica state\n-    if (replica.getState() !\u003d ReplicaState.RUR) {\n-      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n+    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n+      //get replica\n+      final String bpid \u003d oldBlock.getBlockPoolId();\n+      final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n+      LOG.info(\"updateReplica: \" + oldBlock\n+          + \", recoveryId\u003d\" + recoveryId\n+          + \", length\u003d\" + newlength\n           + \", replica\u003d\" + replica);\n+\n+      //check replica\n+      if (replica \u003d\u003d null) {\n+        throw new ReplicaNotFoundException(oldBlock);\n+      }\n+\n+      //check replica state\n+      if (replica.getState() !\u003d ReplicaState.RUR) {\n+        throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n+            + \", replica\u003d\" + replica);\n+      }\n+\n+      //check replica\u0027s byte on disk\n+      if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n+        throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n+            + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n+            + oldBlock + \", replica\u003d\" + replica);\n+      }\n+\n+      //check replica files before update\n+      checkReplicaFiles(replica);\n+\n+      //update replica\n+      final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n+              .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n+          newBlockId, newlength);\n+\n+      boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n+      if (!copyTruncate) {\n+        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n+            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n+            \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n+            : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n+            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n+            + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n+      } else {\n+        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n+            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n+            \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n+            : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n+            + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n+            + \", len\u003d\" + oldBlock.getNumBytes()\n+            + \", finalized\u003d\" + finalized;\n+      }\n+\n+      //check replica files after update\n+      checkReplicaFiles(finalized);\n+\n+      return finalized;\n     }\n-\n-    //check replica\u0027s byte on disk\n-    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n-      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n-          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n-          + oldBlock + \", replica\u003d\" + replica);\n-    }\n-\n-    //check replica files before update\n-    checkReplicaFiles(replica);\n-\n-    //update replica\n-    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n-        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n-        newBlockId, newlength);\n-\n-    boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n-    if(!copyTruncate) {\n-      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n-          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n-          \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n-          : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n-              + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n-              + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n-    } else {\n-      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n-          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n-          \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n-          : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n-              + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n-              + \", len\u003d\" + oldBlock.getNumBytes()\n-              + \", finalized\u003d\" + finalized;\n-    }\n-\n-    //check replica files after update\n-    checkReplicaFiles(finalized);\n-\n-    return finalized;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Replica updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newBlockId,\n                                    final long newlength) throws IOException {\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      //get replica\n      final String bpid \u003d oldBlock.getBlockPoolId();\n      final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n      LOG.info(\"updateReplica: \" + oldBlock\n          + \", recoveryId\u003d\" + recoveryId\n          + \", length\u003d\" + newlength\n          + \", replica\u003d\" + replica);\n\n      //check replica\n      if (replica \u003d\u003d null) {\n        throw new ReplicaNotFoundException(oldBlock);\n      }\n\n      //check replica state\n      if (replica.getState() !\u003d ReplicaState.RUR) {\n        throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n            + \", replica\u003d\" + replica);\n      }\n\n      //check replica\u0027s byte on disk\n      if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n        throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n            + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n            + oldBlock + \", replica\u003d\" + replica);\n      }\n\n      //check replica files before update\n      checkReplicaFiles(replica);\n\n      //update replica\n      final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n              .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n          newBlockId, newlength);\n\n      boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n      if (!copyTruncate) {\n        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n            \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n            : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n            + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n      } else {\n        assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n            \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n            \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n            : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n            + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n            + \", len\u003d\" + oldBlock.getNumBytes()\n            + \", finalized\u003d\" + finalized;\n      }\n\n      //check replica files after update\n      checkReplicaFiles(finalized);\n\n      return finalized;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "d1d4e16690cc85f7f22fbead9cf596260819b561": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-9710. DN can be configured to send block receipt IBRs in batches.\n",
      "commitDate": "26/02/16 3:32 PM",
      "commitName": "d1d4e16690cc85f7f22fbead9cf596260819b561",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-9710. DN can be configured to send block receipt IBRs in batches.\n",
          "commitDate": "26/02/16 3:32 PM",
          "commitName": "d1d4e16690cc85f7f22fbead9cf596260819b561",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "21/02/16 7:59 PM",
          "commitNameOld": "342c9572bf6a623287f34c5cc0bc3be6038c191a",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 4.81,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,63 +1,62 @@\n-  public synchronized String updateReplicaUnderRecovery(\n+  public synchronized Replica updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n                                     final long newBlockId,\n                                     final long newlength) throws IOException {\n     //get replica\n     final String bpid \u003d oldBlock.getBlockPoolId();\n     final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n     LOG.info(\"updateReplica: \" + oldBlock\n                  + \", recoveryId\u003d\" + recoveryId\n                  + \", length\u003d\" + newlength\n                  + \", replica\u003d\" + replica);\n \n     //check replica\n     if (replica \u003d\u003d null) {\n       throw new ReplicaNotFoundException(oldBlock);\n     }\n \n     //check replica state\n     if (replica.getState() !\u003d ReplicaState.RUR) {\n       throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n           + \", replica\u003d\" + replica);\n     }\n \n     //check replica\u0027s byte on disk\n     if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n       throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n           + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n           + oldBlock + \", replica\u003d\" + replica);\n     }\n \n     //check replica files before update\n     checkReplicaFiles(replica);\n \n     //update replica\n     final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n         .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n         newBlockId, newlength);\n \n     boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n     if(!copyTruncate) {\n       assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n           \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n           \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n           : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n               + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n               + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n     } else {\n       assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n           \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n           \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n           : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n               + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n               + \", len\u003d\" + oldBlock.getNumBytes()\n               + \", finalized\u003d\" + finalized;\n     }\n \n     //check replica files after update\n     checkReplicaFiles(finalized);\n \n-    //return storage ID\n-    return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n+    return finalized;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized Replica updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newBlockId,\n                                    final long newlength) throws IOException {\n    //get replica\n    final String bpid \u003d oldBlock.getBlockPoolId();\n    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n    LOG.info(\"updateReplica: \" + oldBlock\n                 + \", recoveryId\u003d\" + recoveryId\n                 + \", length\u003d\" + newlength\n                 + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      throw new ReplicaNotFoundException(oldBlock);\n    }\n\n    //check replica state\n    if (replica.getState() !\u003d ReplicaState.RUR) {\n      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n          + \", replica\u003d\" + replica);\n    }\n\n    //check replica\u0027s byte on disk\n    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n          + oldBlock + \", replica\u003d\" + replica);\n    }\n\n    //check replica files before update\n    checkReplicaFiles(replica);\n\n    //update replica\n    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n        newBlockId, newlength);\n\n    boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n    if(!copyTruncate) {\n      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n          \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n          : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n              + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n              + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n    } else {\n      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n          \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n          : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n              + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n              + \", len\u003d\" + oldBlock.getNumBytes()\n              + \", finalized\u003d\" + finalized;\n    }\n\n    //check replica files after update\n    checkReplicaFiles(finalized);\n\n    return finalized;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldValue": "String",
            "newValue": "Replica"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9710. DN can be configured to send block receipt IBRs in batches.\n",
          "commitDate": "26/02/16 3:32 PM",
          "commitName": "d1d4e16690cc85f7f22fbead9cf596260819b561",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "21/02/16 7:59 PM",
          "commitNameOld": "342c9572bf6a623287f34c5cc0bc3be6038c191a",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 4.81,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,63 +1,62 @@\n-  public synchronized String updateReplicaUnderRecovery(\n+  public synchronized Replica updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n                                     final long newBlockId,\n                                     final long newlength) throws IOException {\n     //get replica\n     final String bpid \u003d oldBlock.getBlockPoolId();\n     final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n     LOG.info(\"updateReplica: \" + oldBlock\n                  + \", recoveryId\u003d\" + recoveryId\n                  + \", length\u003d\" + newlength\n                  + \", replica\u003d\" + replica);\n \n     //check replica\n     if (replica \u003d\u003d null) {\n       throw new ReplicaNotFoundException(oldBlock);\n     }\n \n     //check replica state\n     if (replica.getState() !\u003d ReplicaState.RUR) {\n       throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n           + \", replica\u003d\" + replica);\n     }\n \n     //check replica\u0027s byte on disk\n     if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n       throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n           + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n           + oldBlock + \", replica\u003d\" + replica);\n     }\n \n     //check replica files before update\n     checkReplicaFiles(replica);\n \n     //update replica\n     final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n         .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n         newBlockId, newlength);\n \n     boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n     if(!copyTruncate) {\n       assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n           \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n           \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n           : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n               + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n               + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n     } else {\n       assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n           \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n           \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n           : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n               + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n               + \", len\u003d\" + oldBlock.getNumBytes()\n               + \", finalized\u003d\" + finalized;\n     }\n \n     //check replica files after update\n     checkReplicaFiles(finalized);\n \n-    //return storage ID\n-    return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n+    return finalized;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized Replica updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newBlockId,\n                                    final long newlength) throws IOException {\n    //get replica\n    final String bpid \u003d oldBlock.getBlockPoolId();\n    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n    LOG.info(\"updateReplica: \" + oldBlock\n                 + \", recoveryId\u003d\" + recoveryId\n                 + \", length\u003d\" + newlength\n                 + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      throw new ReplicaNotFoundException(oldBlock);\n    }\n\n    //check replica state\n    if (replica.getState() !\u003d ReplicaState.RUR) {\n      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n          + \", replica\u003d\" + replica);\n    }\n\n    //check replica\u0027s byte on disk\n    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n          + oldBlock + \", replica\u003d\" + replica);\n    }\n\n    //check replica files before update\n    checkReplicaFiles(replica);\n\n    //update replica\n    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n        newBlockId, newlength);\n\n    boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n    if(!copyTruncate) {\n      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n          \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n          : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n              + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n              + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n    } else {\n      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n          \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n          : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n              + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n              + \", len\u003d\" + oldBlock.getNumBytes()\n              + \", finalized\u003d\" + finalized;\n    }\n\n    //check replica files after update\n    checkReplicaFiles(finalized);\n\n    return finalized;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7056. Snapshot support for truncate. Contributed by Konstantin Shvachko and Plamen Jeliazkov.",
      "commitDate": "13/01/15 12:24 AM",
      "commitName": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
      "commitAuthor": "Konstantin V Shvachko",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7056. Snapshot support for truncate. Contributed by Konstantin Shvachko and Plamen Jeliazkov.",
          "commitDate": "13/01/15 12:24 AM",
          "commitName": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
          "commitAuthor": "Konstantin V Shvachko",
          "commitDateOld": "17/12/14 4:41 PM",
          "commitNameOld": "3b173d95171d01ab55042b1162569d1cf14a8d43",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 26.32,
          "commitsBetweenForRepo": 116,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,63 @@\n   public synchronized String updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n+                                    final long newBlockId,\n                                     final long newlength) throws IOException {\n     //get replica\n     final String bpid \u003d oldBlock.getBlockPoolId();\n     final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n     LOG.info(\"updateReplica: \" + oldBlock\n                  + \", recoveryId\u003d\" + recoveryId\n                  + \", length\u003d\" + newlength\n                  + \", replica\u003d\" + replica);\n \n     //check replica\n     if (replica \u003d\u003d null) {\n       throw new ReplicaNotFoundException(oldBlock);\n     }\n \n     //check replica state\n     if (replica.getState() !\u003d ReplicaState.RUR) {\n       throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n           + \", replica\u003d\" + replica);\n     }\n \n     //check replica\u0027s byte on disk\n     if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n       throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n           + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n           + oldBlock + \", replica\u003d\" + replica);\n     }\n \n     //check replica files before update\n     checkReplicaFiles(replica);\n \n     //update replica\n     final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n-        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n-    assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n-        \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n-        \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n-        : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n-            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n-            + \", finalized\u003d\" + finalized;\n+        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n+        newBlockId, newlength);\n+\n+    boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n+    if(!copyTruncate) {\n+      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n+          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n+          \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n+          : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n+              + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n+              + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n+    } else {\n+      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n+          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n+          \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n+          : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n+              + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n+              + \", len\u003d\" + oldBlock.getNumBytes()\n+              + \", finalized\u003d\" + finalized;\n+    }\n \n     //check replica files after update\n     checkReplicaFiles(finalized);\n \n     //return storage ID\n     return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized String updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newBlockId,\n                                    final long newlength) throws IOException {\n    //get replica\n    final String bpid \u003d oldBlock.getBlockPoolId();\n    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n    LOG.info(\"updateReplica: \" + oldBlock\n                 + \", recoveryId\u003d\" + recoveryId\n                 + \", length\u003d\" + newlength\n                 + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      throw new ReplicaNotFoundException(oldBlock);\n    }\n\n    //check replica state\n    if (replica.getState() !\u003d ReplicaState.RUR) {\n      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n          + \", replica\u003d\" + replica);\n    }\n\n    //check replica\u0027s byte on disk\n    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n          + oldBlock + \", replica\u003d\" + replica);\n    }\n\n    //check replica files before update\n    checkReplicaFiles(replica);\n\n    //update replica\n    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n        newBlockId, newlength);\n\n    boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n    if(!copyTruncate) {\n      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n          \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n          : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n              + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n              + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n    } else {\n      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n          \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n          : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n              + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n              + \", len\u003d\" + oldBlock.getNumBytes()\n              + \", finalized\u003d\" + finalized;\n    }\n\n    //check replica files after update\n    checkReplicaFiles(finalized);\n\n    //return storage ID\n    return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldValue": "[oldBlock-ExtendedBlock(modifiers-final), recoveryId-long(modifiers-final), newlength-long(modifiers-final)]",
            "newValue": "[oldBlock-ExtendedBlock(modifiers-final), recoveryId-long(modifiers-final), newBlockId-long(modifiers-final), newlength-long(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7056. Snapshot support for truncate. Contributed by Konstantin Shvachko and Plamen Jeliazkov.",
          "commitDate": "13/01/15 12:24 AM",
          "commitName": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
          "commitAuthor": "Konstantin V Shvachko",
          "commitDateOld": "17/12/14 4:41 PM",
          "commitNameOld": "3b173d95171d01ab55042b1162569d1cf14a8d43",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 26.32,
          "commitsBetweenForRepo": 116,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,63 @@\n   public synchronized String updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n+                                    final long newBlockId,\n                                     final long newlength) throws IOException {\n     //get replica\n     final String bpid \u003d oldBlock.getBlockPoolId();\n     final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n     LOG.info(\"updateReplica: \" + oldBlock\n                  + \", recoveryId\u003d\" + recoveryId\n                  + \", length\u003d\" + newlength\n                  + \", replica\u003d\" + replica);\n \n     //check replica\n     if (replica \u003d\u003d null) {\n       throw new ReplicaNotFoundException(oldBlock);\n     }\n \n     //check replica state\n     if (replica.getState() !\u003d ReplicaState.RUR) {\n       throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n           + \", replica\u003d\" + replica);\n     }\n \n     //check replica\u0027s byte on disk\n     if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n       throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n           + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n           + oldBlock + \", replica\u003d\" + replica);\n     }\n \n     //check replica files before update\n     checkReplicaFiles(replica);\n \n     //update replica\n     final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n-        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n-    assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n-        \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n-        \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n-        : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n-            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n-            + \", finalized\u003d\" + finalized;\n+        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n+        newBlockId, newlength);\n+\n+    boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n+    if(!copyTruncate) {\n+      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n+          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n+          \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n+          : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n+              + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n+              + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n+    } else {\n+      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n+          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n+          \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n+          : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n+              + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n+              + \", len\u003d\" + oldBlock.getNumBytes()\n+              + \", finalized\u003d\" + finalized;\n+    }\n \n     //check replica files after update\n     checkReplicaFiles(finalized);\n \n     //return storage ID\n     return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized String updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newBlockId,\n                                    final long newlength) throws IOException {\n    //get replica\n    final String bpid \u003d oldBlock.getBlockPoolId();\n    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n    LOG.info(\"updateReplica: \" + oldBlock\n                 + \", recoveryId\u003d\" + recoveryId\n                 + \", length\u003d\" + newlength\n                 + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      throw new ReplicaNotFoundException(oldBlock);\n    }\n\n    //check replica state\n    if (replica.getState() !\u003d ReplicaState.RUR) {\n      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n          + \", replica\u003d\" + replica);\n    }\n\n    //check replica\u0027s byte on disk\n    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n          + oldBlock + \", replica\u003d\" + replica);\n    }\n\n    //check replica files before update\n    checkReplicaFiles(replica);\n\n    //update replica\n    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId,\n        newBlockId, newlength);\n\n    boolean copyTruncate \u003d newBlockId !\u003d oldBlock.getBlockId();\n    if(!copyTruncate) {\n      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n          \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n          : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n              + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n              + \", newBlockId\u003d\" + newBlockId + \", finalized\u003d\" + finalized;\n    } else {\n      assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n          \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d oldBlock.getGenerationStamp()\n          \u0026\u0026 finalized.getNumBytes() \u003d\u003d oldBlock.getNumBytes()\n          : \"Finalized and old information mismatched: oldBlock\u003d\" + oldBlock\n              + \", genStamp\u003d\" + oldBlock.getGenerationStamp()\n              + \", len\u003d\" + oldBlock.getNumBytes()\n              + \", finalized\u003d\" + finalized;\n    }\n\n    //check replica files after update\n    checkReplicaFiles(finalized);\n\n    //return storage ID\n    return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4122. Cleanup HDFS logs and reduce the size of logged messages. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1403120 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/12 4:10 PM",
      "commitName": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "13/09/12 4:48 PM",
      "commitNameOld": "86635168feaaf9a8f20d01b5fd6c1b6fbe98c1ea",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 44.97,
      "commitsBetweenForRepo": 247,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n   public synchronized String updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n                                     final long newlength) throws IOException {\n     //get replica\n     final String bpid \u003d oldBlock.getBlockPoolId();\n     final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n-    LOG.info(\"updateReplica: block\u003d\" + oldBlock\n+    LOG.info(\"updateReplica: \" + oldBlock\n         + \", recoveryId\u003d\" + recoveryId\n         + \", length\u003d\" + newlength\n         + \", replica\u003d\" + replica);\n \n     //check replica\n     if (replica \u003d\u003d null) {\n       throw new ReplicaNotFoundException(oldBlock);\n     }\n \n     //check replica state\n     if (replica.getState() !\u003d ReplicaState.RUR) {\n       throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n           + \", replica\u003d\" + replica);\n     }\n \n     //check replica\u0027s byte on disk\n     if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n       throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n           + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n           + oldBlock + \", replica\u003d\" + replica);\n     }\n \n     //check replica files before update\n     checkReplicaFiles(replica);\n \n     //update replica\n     final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n         .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n     assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n         \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n         \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n         : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n             + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n             + \", finalized\u003d\" + finalized;\n \n     //check replica files after update\n     checkReplicaFiles(finalized);\n \n     //return storage ID\n     return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized String updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newlength) throws IOException {\n    //get replica\n    final String bpid \u003d oldBlock.getBlockPoolId();\n    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n    LOG.info(\"updateReplica: \" + oldBlock\n        + \", recoveryId\u003d\" + recoveryId\n        + \", length\u003d\" + newlength\n        + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      throw new ReplicaNotFoundException(oldBlock);\n    }\n\n    //check replica state\n    if (replica.getState() !\u003d ReplicaState.RUR) {\n      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n          + \", replica\u003d\" + replica);\n    }\n\n    //check replica\u0027s byte on disk\n    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n          + oldBlock + \", replica\u003d\" + replica);\n    }\n\n    //check replica files before update\n    checkReplicaFiles(replica);\n\n    //update replica\n    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n    assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n        \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n        \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n        : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n            + \", finalized\u003d\" + finalized;\n\n    //check replica files after update\n    checkReplicaFiles(finalized);\n\n    //return storage ID\n    return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "bc13dfb1426944ce45293cb8f444239a7406762c": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "HDFS-3130. Move fsdataset implementation to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308437 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/04/12 10:38 AM",
      "commitName": "bc13dfb1426944ce45293cb8f444239a7406762c",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-3130. Move fsdataset implementation to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308437 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/04/12 10:38 AM",
          "commitName": "bc13dfb1426944ce45293cb8f444239a7406762c",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "01/04/12 8:48 PM",
          "commitNameOld": "a4ccb8f504e79802f1b3c69acbcbb00b2343c529",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.58,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,49 @@\n   public synchronized String updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n                                     final long newlength) throws IOException {\n     //get replica\n     final String bpid \u003d oldBlock.getBlockPoolId();\n     final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n-    DataNode.LOG.info(\"updateReplica: block\u003d\" + oldBlock\n+    LOG.info(\"updateReplica: block\u003d\" + oldBlock\n         + \", recoveryId\u003d\" + recoveryId\n         + \", length\u003d\" + newlength\n         + \", replica\u003d\" + replica);\n \n     //check replica\n     if (replica \u003d\u003d null) {\n       throw new ReplicaNotFoundException(oldBlock);\n     }\n \n     //check replica state\n     if (replica.getState() !\u003d ReplicaState.RUR) {\n       throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n           + \", replica\u003d\" + replica);\n     }\n \n     //check replica\u0027s byte on disk\n     if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n       throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n           + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n           + oldBlock + \", replica\u003d\" + replica);\n     }\n \n     //check replica files before update\n     checkReplicaFiles(replica);\n \n     //update replica\n     final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n         .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n     assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n         \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n         \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n         : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n             + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n             + \", finalized\u003d\" + finalized;\n \n     //check replica files after update\n     checkReplicaFiles(finalized);\n \n     //return storage ID\n     return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized String updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newlength) throws IOException {\n    //get replica\n    final String bpid \u003d oldBlock.getBlockPoolId();\n    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n    LOG.info(\"updateReplica: block\u003d\" + oldBlock\n        + \", recoveryId\u003d\" + recoveryId\n        + \", length\u003d\" + newlength\n        + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      throw new ReplicaNotFoundException(oldBlock);\n    }\n\n    //check replica state\n    if (replica.getState() !\u003d ReplicaState.RUR) {\n      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n          + \", replica\u003d\" + replica);\n    }\n\n    //check replica\u0027s byte on disk\n    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n          + oldBlock + \", replica\u003d\" + replica);\n    }\n\n    //check replica files before update\n    checkReplicaFiles(replica);\n\n    //update replica\n    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n    assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n        \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n        \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n        : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n            + \", finalized\u003d\" + finalized;\n\n    //check replica files after update\n    checkReplicaFiles(finalized);\n\n    //return storage ID\n    return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
            "oldMethodName": "updateReplicaUnderRecovery",
            "newMethodName": "updateReplicaUnderRecovery"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3130. Move fsdataset implementation to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308437 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/04/12 10:38 AM",
          "commitName": "bc13dfb1426944ce45293cb8f444239a7406762c",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "01/04/12 8:48 PM",
          "commitNameOld": "a4ccb8f504e79802f1b3c69acbcbb00b2343c529",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.58,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,49 @@\n   public synchronized String updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n                                     final long newlength) throws IOException {\n     //get replica\n     final String bpid \u003d oldBlock.getBlockPoolId();\n     final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n-    DataNode.LOG.info(\"updateReplica: block\u003d\" + oldBlock\n+    LOG.info(\"updateReplica: block\u003d\" + oldBlock\n         + \", recoveryId\u003d\" + recoveryId\n         + \", length\u003d\" + newlength\n         + \", replica\u003d\" + replica);\n \n     //check replica\n     if (replica \u003d\u003d null) {\n       throw new ReplicaNotFoundException(oldBlock);\n     }\n \n     //check replica state\n     if (replica.getState() !\u003d ReplicaState.RUR) {\n       throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n           + \", replica\u003d\" + replica);\n     }\n \n     //check replica\u0027s byte on disk\n     if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n       throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n           + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n           + oldBlock + \", replica\u003d\" + replica);\n     }\n \n     //check replica files before update\n     checkReplicaFiles(replica);\n \n     //update replica\n     final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n         .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n     assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n         \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n         \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n         : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n             + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n             + \", finalized\u003d\" + finalized;\n \n     //check replica files after update\n     checkReplicaFiles(finalized);\n \n     //return storage ID\n     return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized String updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newlength) throws IOException {\n    //get replica\n    final String bpid \u003d oldBlock.getBlockPoolId();\n    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n    LOG.info(\"updateReplica: block\u003d\" + oldBlock\n        + \", recoveryId\u003d\" + recoveryId\n        + \", length\u003d\" + newlength\n        + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      throw new ReplicaNotFoundException(oldBlock);\n    }\n\n    //check replica state\n    if (replica.getState() !\u003d ReplicaState.RUR) {\n      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n          + \", replica\u003d\" + replica);\n    }\n\n    //check replica\u0027s byte on disk\n    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n          + oldBlock + \", replica\u003d\" + replica);\n    }\n\n    //check replica files before update\n    checkReplicaFiles(replica);\n\n    //update replica\n    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n    assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n        \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n        \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n        : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n            + \", finalized\u003d\" + finalized;\n\n    //check replica files after update\n    checkReplicaFiles(finalized);\n\n    //return storage ID\n    return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "6326605acb5a5bf48d994278c9d3a39733679e81": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-3105.  Add DatanodeStorage information to block recovery.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1302683 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/03/12 3:09 PM",
      "commitName": "6326605acb5a5bf48d994278c9d3a39733679e81",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-3105.  Add DatanodeStorage information to block recovery.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1302683 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/03/12 3:09 PM",
          "commitName": "6326605acb5a5bf48d994278c9d3a39733679e81",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "16/03/12 10:32 AM",
          "commitNameOld": "662b1887af4e39f3eadd7dda4953c7f2529b43bc",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 3.19,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,49 @@\n-  public synchronized ReplicaInfo updateReplicaUnderRecovery(\n+  public synchronized String updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n                                     final long newlength) throws IOException {\n     //get replica\n-    final ReplicaInfo replica \u003d volumeMap.get(oldBlock.getBlockPoolId(), \n-        oldBlock.getBlockId());\n+    final String bpid \u003d oldBlock.getBlockPoolId();\n+    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n     DataNode.LOG.info(\"updateReplica: block\u003d\" + oldBlock\n         + \", recoveryId\u003d\" + recoveryId\n         + \", length\u003d\" + newlength\n         + \", replica\u003d\" + replica);\n \n     //check replica\n     if (replica \u003d\u003d null) {\n       throw new ReplicaNotFoundException(oldBlock);\n     }\n \n     //check replica state\n     if (replica.getState() !\u003d ReplicaState.RUR) {\n       throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n           + \", replica\u003d\" + replica);\n     }\n \n     //check replica\u0027s byte on disk\n     if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n       throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n           + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n           + oldBlock + \", replica\u003d\" + replica);\n     }\n \n     //check replica files before update\n     checkReplicaFiles(replica);\n \n     //update replica\n     final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n         .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n+    assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n+        \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n+        \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n+        : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n+            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n+            + \", finalized\u003d\" + finalized;\n \n     //check replica files after update\n     checkReplicaFiles(finalized);\n-    return finalized;\n+\n+    //return storage ID\n+    return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized String updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newlength) throws IOException {\n    //get replica\n    final String bpid \u003d oldBlock.getBlockPoolId();\n    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n    DataNode.LOG.info(\"updateReplica: block\u003d\" + oldBlock\n        + \", recoveryId\u003d\" + recoveryId\n        + \", length\u003d\" + newlength\n        + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      throw new ReplicaNotFoundException(oldBlock);\n    }\n\n    //check replica state\n    if (replica.getState() !\u003d ReplicaState.RUR) {\n      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n          + \", replica\u003d\" + replica);\n    }\n\n    //check replica\u0027s byte on disk\n    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n          + oldBlock + \", replica\u003d\" + replica);\n    }\n\n    //check replica files before update\n    checkReplicaFiles(replica);\n\n    //update replica\n    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n    assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n        \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n        \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n        : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n            + \", finalized\u003d\" + finalized;\n\n    //check replica files after update\n    checkReplicaFiles(finalized);\n\n    //return storage ID\n    return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
          "extendedDetails": {
            "oldValue": "ReplicaInfo",
            "newValue": "String"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3105.  Add DatanodeStorage information to block recovery.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1302683 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/03/12 3:09 PM",
          "commitName": "6326605acb5a5bf48d994278c9d3a39733679e81",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "16/03/12 10:32 AM",
          "commitNameOld": "662b1887af4e39f3eadd7dda4953c7f2529b43bc",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 3.19,
          "commitsBetweenForRepo": 12,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,49 @@\n-  public synchronized ReplicaInfo updateReplicaUnderRecovery(\n+  public synchronized String updateReplicaUnderRecovery(\n                                     final ExtendedBlock oldBlock,\n                                     final long recoveryId,\n                                     final long newlength) throws IOException {\n     //get replica\n-    final ReplicaInfo replica \u003d volumeMap.get(oldBlock.getBlockPoolId(), \n-        oldBlock.getBlockId());\n+    final String bpid \u003d oldBlock.getBlockPoolId();\n+    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n     DataNode.LOG.info(\"updateReplica: block\u003d\" + oldBlock\n         + \", recoveryId\u003d\" + recoveryId\n         + \", length\u003d\" + newlength\n         + \", replica\u003d\" + replica);\n \n     //check replica\n     if (replica \u003d\u003d null) {\n       throw new ReplicaNotFoundException(oldBlock);\n     }\n \n     //check replica state\n     if (replica.getState() !\u003d ReplicaState.RUR) {\n       throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n           + \", replica\u003d\" + replica);\n     }\n \n     //check replica\u0027s byte on disk\n     if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n       throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n           + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n           + oldBlock + \", replica\u003d\" + replica);\n     }\n \n     //check replica files before update\n     checkReplicaFiles(replica);\n \n     //update replica\n     final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n         .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n+    assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n+        \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n+        \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n+        : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n+            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n+            + \", finalized\u003d\" + finalized;\n \n     //check replica files after update\n     checkReplicaFiles(finalized);\n-    return finalized;\n+\n+    //return storage ID\n+    return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized String updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newlength) throws IOException {\n    //get replica\n    final String bpid \u003d oldBlock.getBlockPoolId();\n    final ReplicaInfo replica \u003d volumeMap.get(bpid, oldBlock.getBlockId());\n    DataNode.LOG.info(\"updateReplica: block\u003d\" + oldBlock\n        + \", recoveryId\u003d\" + recoveryId\n        + \", length\u003d\" + newlength\n        + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      throw new ReplicaNotFoundException(oldBlock);\n    }\n\n    //check replica state\n    if (replica.getState() !\u003d ReplicaState.RUR) {\n      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n          + \", replica\u003d\" + replica);\n    }\n\n    //check replica\u0027s byte on disk\n    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n          + oldBlock + \", replica\u003d\" + replica);\n    }\n\n    //check replica files before update\n    checkReplicaFiles(replica);\n\n    //update replica\n    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n    assert finalized.getBlockId() \u003d\u003d oldBlock.getBlockId()\n        \u0026\u0026 finalized.getGenerationStamp() \u003d\u003d recoveryId\n        \u0026\u0026 finalized.getNumBytes() \u003d\u003d newlength\n        : \"Replica information mismatched: oldBlock\u003d\" + oldBlock\n            + \", recoveryId\u003d\" + recoveryId + \", newlength\u003d\" + newlength\n            + \", finalized\u003d\" + finalized;\n\n    //check replica files after update\n    checkReplicaFiles(finalized);\n\n    //return storage ID\n    return getVolume(new ExtendedBlock(bpid, finalized)).getStorageID();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
          "extendedDetails": {}
        }
      ]
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public synchronized ReplicaInfo updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newlength) throws IOException {\n    //get replica\n    final ReplicaInfo replica \u003d volumeMap.get(oldBlock.getBlockPoolId(), \n        oldBlock.getBlockId());\n    DataNode.LOG.info(\"updateReplica: block\u003d\" + oldBlock\n        + \", recoveryId\u003d\" + recoveryId\n        + \", length\u003d\" + newlength\n        + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      throw new ReplicaNotFoundException(oldBlock);\n    }\n\n    //check replica state\n    if (replica.getState() !\u003d ReplicaState.RUR) {\n      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n          + \", replica\u003d\" + replica);\n    }\n\n    //check replica\u0027s byte on disk\n    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n          + oldBlock + \", replica\u003d\" + replica);\n    }\n\n    //check replica files before update\n    checkReplicaFiles(replica);\n\n    //update replica\n    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n\n    //check replica files after update\n    checkReplicaFiles(finalized);\n    return finalized;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public synchronized ReplicaInfo updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newlength) throws IOException {\n    //get replica\n    final ReplicaInfo replica \u003d volumeMap.get(oldBlock.getBlockPoolId(), \n        oldBlock.getBlockId());\n    DataNode.LOG.info(\"updateReplica: block\u003d\" + oldBlock\n        + \", recoveryId\u003d\" + recoveryId\n        + \", length\u003d\" + newlength\n        + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      throw new ReplicaNotFoundException(oldBlock);\n    }\n\n    //check replica state\n    if (replica.getState() !\u003d ReplicaState.RUR) {\n      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n          + \", replica\u003d\" + replica);\n    }\n\n    //check replica\u0027s byte on disk\n    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n          + oldBlock + \", replica\u003d\" + replica);\n    }\n\n    //check replica files before update\n    checkReplicaFiles(replica);\n\n    //update replica\n    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n\n    //check replica files after update\n    checkReplicaFiles(finalized);\n    return finalized;\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,41 @@\n+  public synchronized ReplicaInfo updateReplicaUnderRecovery(\n+                                    final ExtendedBlock oldBlock,\n+                                    final long recoveryId,\n+                                    final long newlength) throws IOException {\n+    //get replica\n+    final ReplicaInfo replica \u003d volumeMap.get(oldBlock.getBlockPoolId(), \n+        oldBlock.getBlockId());\n+    DataNode.LOG.info(\"updateReplica: block\u003d\" + oldBlock\n+        + \", recoveryId\u003d\" + recoveryId\n+        + \", length\u003d\" + newlength\n+        + \", replica\u003d\" + replica);\n+\n+    //check replica\n+    if (replica \u003d\u003d null) {\n+      throw new ReplicaNotFoundException(oldBlock);\n+    }\n+\n+    //check replica state\n+    if (replica.getState() !\u003d ReplicaState.RUR) {\n+      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n+          + \", replica\u003d\" + replica);\n+    }\n+\n+    //check replica\u0027s byte on disk\n+    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n+      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n+          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n+          + oldBlock + \", replica\u003d\" + replica);\n+    }\n+\n+    //check replica files before update\n+    checkReplicaFiles(replica);\n+\n+    //update replica\n+    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n+        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n+\n+    //check replica files after update\n+    checkReplicaFiles(finalized);\n+    return finalized;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ReplicaInfo updateReplicaUnderRecovery(\n                                    final ExtendedBlock oldBlock,\n                                    final long recoveryId,\n                                    final long newlength) throws IOException {\n    //get replica\n    final ReplicaInfo replica \u003d volumeMap.get(oldBlock.getBlockPoolId(), \n        oldBlock.getBlockId());\n    DataNode.LOG.info(\"updateReplica: block\u003d\" + oldBlock\n        + \", recoveryId\u003d\" + recoveryId\n        + \", length\u003d\" + newlength\n        + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      throw new ReplicaNotFoundException(oldBlock);\n    }\n\n    //check replica state\n    if (replica.getState() !\u003d ReplicaState.RUR) {\n      throw new IOException(\"replica.getState() !\u003d \" + ReplicaState.RUR\n          + \", replica\u003d\" + replica);\n    }\n\n    //check replica\u0027s byte on disk\n    if (replica.getBytesOnDisk() !\u003d oldBlock.getNumBytes()) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getBytesOnDisk() !\u003d block.getNumBytes(), block\u003d\"\n          + oldBlock + \", replica\u003d\" + replica);\n    }\n\n    //check replica files before update\n    checkReplicaFiles(replica);\n\n    //update replica\n    final FinalizedReplica finalized \u003d updateReplicaUnderRecovery(oldBlock\n        .getBlockPoolId(), (ReplicaUnderRecovery) replica, recoveryId, newlength);\n\n    //check replica files after update\n    checkReplicaFiles(finalized);\n    return finalized;\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java"
    }
  }
}