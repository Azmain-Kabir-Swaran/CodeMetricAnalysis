{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ResourceTrackerService.java",
  "functionName": "updateAppCollectorsMap",
  "functionId": "updateAppCollectorsMap___request-NodeHeartbeatRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
  "functionStartLine": 788,
  "functionEndLine": 831,
  "numCommitsSeen": 163,
  "timeTaken": 4042,
  "changeHistory": [
    "91d3443806555d336d27cf8cc9250a0fb85b03a9",
    "78b7e070d8009c78665a2baa64fe888788f53e69",
    "7311015ace498e03aad88bcbe1581916803ceaba",
    "dc1f306fdc83749f9675b89326e26c73b9ff8f86",
    "2188a07e5bea1da26bf679ca0ece26ab596d3438",
    "9b5636408005676ae580f8d929f8e912c27828e7"
  ],
  "changeHistoryShort": {
    "91d3443806555d336d27cf8cc9250a0fb85b03a9": "Ybodychange",
    "78b7e070d8009c78665a2baa64fe888788f53e69": "Ybodychange",
    "7311015ace498e03aad88bcbe1581916803ceaba": "Ybodychange",
    "dc1f306fdc83749f9675b89326e26c73b9ff8f86": "Ybodychange",
    "2188a07e5bea1da26bf679ca0ece26ab596d3438": "Ymultichange(Yrename,Ybodychange)",
    "9b5636408005676ae580f8d929f8e912c27828e7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "91d3443806555d336d27cf8cc9250a0fb85b03a9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3359. Recover collector list when RM fails over (Li Lu via Varun Saxena)\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "91d3443806555d336d27cf8cc9250a0fb85b03a9",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "78b7e070d8009c78665a2baa64fe888788f53e69",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,44 @@\n   private void updateAppCollectorsMap(NodeHeartbeatRequest request) {\n     Map\u003cApplicationId, AppCollectorData\u003e registeringCollectorsMap \u003d\n         request.getRegisteringCollectors();\n     if (registeringCollectorsMap !\u003d null\n         \u0026\u0026 !registeringCollectorsMap.isEmpty()) {\n       Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n       for (Map.Entry\u003cApplicationId, AppCollectorData\u003e entry:\n           registeringCollectorsMap.entrySet()) {\n         ApplicationId appId \u003d entry.getKey();\n         AppCollectorData collectorData \u003d entry.getValue();\n         if (collectorData !\u003d null) {\n           if (!collectorData.isStamped()) {\n             // Stamp the collector if we have not done so\n             collectorData.setRMIdentifier(\n                 ResourceManager.getClusterTimeStamp());\n             collectorData.setVersion(\n                 timelineCollectorVersion.getAndIncrement());\n           }\n           RMApp rmApp \u003d rmApps.get(appId);\n           if (rmApp \u003d\u003d null) {\n             LOG.warn(\"Cannot update collector info because application ID: \" +\n                 appId + \" is not found in RMContext!\");\n           } else {\n-            AppCollectorData previousCollectorData \u003d rmApp.getCollectorData();\n-            if (AppCollectorData.happensBefore(previousCollectorData,\n-                collectorData)) {\n-              // Sending collector update event.\n-              // Note: RM has to store the newly received collector data\n-              // synchronously. Otherwise, the RM may send out stale collector\n-              // data before this update is done, and the RM then crashes, the\n-              // newly updated collector data will get lost.\n-              LOG.info(\"Update collector information for application \" + appId\n-                  + \" with new address: \" + collectorData.getCollectorAddr());\n-              ((RMAppImpl) rmApp).setCollectorData(collectorData);\n+            synchronized (rmApp) {\n+              AppCollectorData previousCollectorData \u003d rmApp.getCollectorData();\n+              if (AppCollectorData.happensBefore(previousCollectorData,\n+                  collectorData)) {\n+                // Sending collector update event.\n+                // Note: RM has to store the newly received collector data\n+                // synchronously. Otherwise, the RM may send out stale collector\n+                // data before this update is done, and the RM then crashes, the\n+                // newly updated collector data will get lost.\n+                LOG.info(\"Update collector information for application \" + appId\n+                    + \" with new address: \" + collectorData.getCollectorAddr()\n+                    + \" timestamp: \" + collectorData.getRMIdentifier()\n+                    + \", \" + collectorData.getVersion());\n+                ((RMAppImpl) rmApp).setCollectorData(collectorData);\n+              }\n             }\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateAppCollectorsMap(NodeHeartbeatRequest request) {\n    Map\u003cApplicationId, AppCollectorData\u003e registeringCollectorsMap \u003d\n        request.getRegisteringCollectors();\n    if (registeringCollectorsMap !\u003d null\n        \u0026\u0026 !registeringCollectorsMap.isEmpty()) {\n      Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n      for (Map.Entry\u003cApplicationId, AppCollectorData\u003e entry:\n          registeringCollectorsMap.entrySet()) {\n        ApplicationId appId \u003d entry.getKey();\n        AppCollectorData collectorData \u003d entry.getValue();\n        if (collectorData !\u003d null) {\n          if (!collectorData.isStamped()) {\n            // Stamp the collector if we have not done so\n            collectorData.setRMIdentifier(\n                ResourceManager.getClusterTimeStamp());\n            collectorData.setVersion(\n                timelineCollectorVersion.getAndIncrement());\n          }\n          RMApp rmApp \u003d rmApps.get(appId);\n          if (rmApp \u003d\u003d null) {\n            LOG.warn(\"Cannot update collector info because application ID: \" +\n                appId + \" is not found in RMContext!\");\n          } else {\n            synchronized (rmApp) {\n              AppCollectorData previousCollectorData \u003d rmApp.getCollectorData();\n              if (AppCollectorData.happensBefore(previousCollectorData,\n                  collectorData)) {\n                // Sending collector update event.\n                // Note: RM has to store the newly received collector data\n                // synchronously. Otherwise, the RM may send out stale collector\n                // data before this update is done, and the RM then crashes, the\n                // newly updated collector data will get lost.\n                LOG.info(\"Update collector information for application \" + appId\n                    + \" with new address: \" + collectorData.getCollectorAddr()\n                    + \" timestamp: \" + collectorData.getRMIdentifier()\n                    + \", \" + collectorData.getVersion());\n                ((RMAppImpl) rmApp).setCollectorData(collectorData);\n              }\n            }\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "78b7e070d8009c78665a2baa64fe888788f53e69": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5638. Introduce a collector timestamp to uniquely identify collectors creation order in collector discovery. Contributed by Li Lu.\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "78b7e070d8009c78665a2baa64fe888788f53e69",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "20/08/17 7:54 AM",
      "commitNameOld": "8410d862d3a72740f461ef91dddb5325955e1ca5",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 9.63,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,40 @@\n   private void updateAppCollectorsMap(NodeHeartbeatRequest request) {\n-    Map\u003cApplicationId, String\u003e registeredCollectorsMap \u003d\n-        request.getRegisteredCollectors();\n-    if (registeredCollectorsMap !\u003d null\n-        \u0026\u0026 !registeredCollectorsMap.isEmpty()) {\n+    Map\u003cApplicationId, AppCollectorData\u003e registeringCollectorsMap \u003d\n+        request.getRegisteringCollectors();\n+    if (registeringCollectorsMap !\u003d null\n+        \u0026\u0026 !registeringCollectorsMap.isEmpty()) {\n       Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n-      for (Map.Entry\u003cApplicationId, String\u003e entry:\n-          registeredCollectorsMap.entrySet()) {\n+      for (Map.Entry\u003cApplicationId, AppCollectorData\u003e entry:\n+          registeringCollectorsMap.entrySet()) {\n         ApplicationId appId \u003d entry.getKey();\n-        String collectorAddr \u003d entry.getValue();\n-        if (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) {\n+        AppCollectorData collectorData \u003d entry.getValue();\n+        if (collectorData !\u003d null) {\n+          if (!collectorData.isStamped()) {\n+            // Stamp the collector if we have not done so\n+            collectorData.setRMIdentifier(\n+                ResourceManager.getClusterTimeStamp());\n+            collectorData.setVersion(\n+                timelineCollectorVersion.getAndIncrement());\n+          }\n           RMApp rmApp \u003d rmApps.get(appId);\n           if (rmApp \u003d\u003d null) {\n             LOG.warn(\"Cannot update collector info because application ID: \" +\n                 appId + \" is not found in RMContext!\");\n           } else {\n-            String previousCollectorAddr \u003d rmApp.getCollectorAddr();\n-            if (previousCollectorAddr \u003d\u003d null\n-                || !previousCollectorAddr.equals(collectorAddr)) {\n-              rmApp.setCollectorAddr(collectorAddr);\n+            AppCollectorData previousCollectorData \u003d rmApp.getCollectorData();\n+            if (AppCollectorData.happensBefore(previousCollectorData,\n+                collectorData)) {\n+              // Sending collector update event.\n+              // Note: RM has to store the newly received collector data\n+              // synchronously. Otherwise, the RM may send out stale collector\n+              // data before this update is done, and the RM then crashes, the\n+              // newly updated collector data will get lost.\n+              LOG.info(\"Update collector information for application \" + appId\n+                  + \" with new address: \" + collectorData.getCollectorAddr());\n+              ((RMAppImpl) rmApp).setCollectorData(collectorData);\n             }\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateAppCollectorsMap(NodeHeartbeatRequest request) {\n    Map\u003cApplicationId, AppCollectorData\u003e registeringCollectorsMap \u003d\n        request.getRegisteringCollectors();\n    if (registeringCollectorsMap !\u003d null\n        \u0026\u0026 !registeringCollectorsMap.isEmpty()) {\n      Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n      for (Map.Entry\u003cApplicationId, AppCollectorData\u003e entry:\n          registeringCollectorsMap.entrySet()) {\n        ApplicationId appId \u003d entry.getKey();\n        AppCollectorData collectorData \u003d entry.getValue();\n        if (collectorData !\u003d null) {\n          if (!collectorData.isStamped()) {\n            // Stamp the collector if we have not done so\n            collectorData.setRMIdentifier(\n                ResourceManager.getClusterTimeStamp());\n            collectorData.setVersion(\n                timelineCollectorVersion.getAndIncrement());\n          }\n          RMApp rmApp \u003d rmApps.get(appId);\n          if (rmApp \u003d\u003d null) {\n            LOG.warn(\"Cannot update collector info because application ID: \" +\n                appId + \" is not found in RMContext!\");\n          } else {\n            AppCollectorData previousCollectorData \u003d rmApp.getCollectorData();\n            if (AppCollectorData.happensBefore(previousCollectorData,\n                collectorData)) {\n              // Sending collector update event.\n              // Note: RM has to store the newly received collector data\n              // synchronously. Otherwise, the RM may send out stale collector\n              // data before this update is done, and the RM then crashes, the\n              // newly updated collector data will get lost.\n              LOG.info(\"Update collector information for application \" + appId\n                  + \" with new address: \" + collectorData.getCollectorAddr());\n              ((RMAppImpl) rmApp).setCollectorData(collectorData);\n            }\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "7311015ace498e03aad88bcbe1581916803ceaba": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6683. Invalid event: COLLECTOR_UPDATE at KILLED.  Contributed by Rohith Sharma K S\n",
      "commitDate": "05/06/17 1:16 PM",
      "commitName": "7311015ace498e03aad88bcbe1581916803ceaba",
      "commitAuthor": "Jian He",
      "commitDateOld": "08/11/16 2:01 PM",
      "commitNameOld": "3f93ac0733058238a2c8f23960c986c71dca0e02",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 208.93,
      "commitsBetweenForRepo": 1132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,26 @@\n   private void updateAppCollectorsMap(NodeHeartbeatRequest request) {\n     Map\u003cApplicationId, String\u003e registeredCollectorsMap \u003d\n         request.getRegisteredCollectors();\n     if (registeredCollectorsMap !\u003d null\n         \u0026\u0026 !registeredCollectorsMap.isEmpty()) {\n       Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n       for (Map.Entry\u003cApplicationId, String\u003e entry:\n           registeredCollectorsMap.entrySet()) {\n         ApplicationId appId \u003d entry.getKey();\n         String collectorAddr \u003d entry.getValue();\n         if (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) {\n           RMApp rmApp \u003d rmApps.get(appId);\n           if (rmApp \u003d\u003d null) {\n             LOG.warn(\"Cannot update collector info because application ID: \" +\n                 appId + \" is not found in RMContext!\");\n           } else {\n             String previousCollectorAddr \u003d rmApp.getCollectorAddr();\n             if (previousCollectorAddr \u003d\u003d null\n                 || !previousCollectorAddr.equals(collectorAddr)) {\n-              // sending collector update event.\n-              RMAppCollectorUpdateEvent event \u003d\n-                  new RMAppCollectorUpdateEvent(appId, collectorAddr);\n-              rmContext.getDispatcher().getEventHandler().handle(event);\n+              rmApp.setCollectorAddr(collectorAddr);\n             }\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateAppCollectorsMap(NodeHeartbeatRequest request) {\n    Map\u003cApplicationId, String\u003e registeredCollectorsMap \u003d\n        request.getRegisteredCollectors();\n    if (registeredCollectorsMap !\u003d null\n        \u0026\u0026 !registeredCollectorsMap.isEmpty()) {\n      Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n      for (Map.Entry\u003cApplicationId, String\u003e entry:\n          registeredCollectorsMap.entrySet()) {\n        ApplicationId appId \u003d entry.getKey();\n        String collectorAddr \u003d entry.getValue();\n        if (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) {\n          RMApp rmApp \u003d rmApps.get(appId);\n          if (rmApp \u003d\u003d null) {\n            LOG.warn(\"Cannot update collector info because application ID: \" +\n                appId + \" is not found in RMContext!\");\n          } else {\n            String previousCollectorAddr \u003d rmApp.getCollectorAddr();\n            if (previousCollectorAddr \u003d\u003d null\n                || !previousCollectorAddr.equals(collectorAddr)) {\n              rmApp.setCollectorAddr(collectorAddr);\n            }\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "dc1f306fdc83749f9675b89326e26c73b9ff8f86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3562. unit tests failures and issues found from findbug from earlier ATS checkins (Naganarasimha G R via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "dc1f306fdc83749f9675b89326e26c73b9ff8f86",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "5712b8f9fd1859fe046b482889239bd164ed7dab",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   private void updateAppCollectorsMap(NodeHeartbeatRequest request) {\n     Map\u003cApplicationId, String\u003e registeredCollectorsMap \u003d\n         request.getRegisteredCollectors();\n     if (registeredCollectorsMap !\u003d null\n         \u0026\u0026 !registeredCollectorsMap.isEmpty()) {\n       Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n       for (Map.Entry\u003cApplicationId, String\u003e entry:\n           registeredCollectorsMap.entrySet()) {\n         ApplicationId appId \u003d entry.getKey();\n         String collectorAddr \u003d entry.getValue();\n         if (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) {\n           RMApp rmApp \u003d rmApps.get(appId);\n           if (rmApp \u003d\u003d null) {\n             LOG.warn(\"Cannot update collector info because application ID: \" +\n                 appId + \" is not found in RMContext!\");\n           } else {\n             String previousCollectorAddr \u003d rmApp.getCollectorAddr();\n-            if (previousCollectorAddr \u003d\u003d null ||\n-                previousCollectorAddr !\u003d collectorAddr) {\n+            if (previousCollectorAddr \u003d\u003d null\n+                || !previousCollectorAddr.equals(collectorAddr)) {\n               // sending collector update event.\n               RMAppCollectorUpdateEvent event \u003d\n                   new RMAppCollectorUpdateEvent(appId, collectorAddr);\n               rmContext.getDispatcher().getEventHandler().handle(event);\n             }\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateAppCollectorsMap(NodeHeartbeatRequest request) {\n    Map\u003cApplicationId, String\u003e registeredCollectorsMap \u003d\n        request.getRegisteredCollectors();\n    if (registeredCollectorsMap !\u003d null\n        \u0026\u0026 !registeredCollectorsMap.isEmpty()) {\n      Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n      for (Map.Entry\u003cApplicationId, String\u003e entry:\n          registeredCollectorsMap.entrySet()) {\n        ApplicationId appId \u003d entry.getKey();\n        String collectorAddr \u003d entry.getValue();\n        if (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) {\n          RMApp rmApp \u003d rmApps.get(appId);\n          if (rmApp \u003d\u003d null) {\n            LOG.warn(\"Cannot update collector info because application ID: \" +\n                appId + \" is not found in RMContext!\");\n          } else {\n            String previousCollectorAddr \u003d rmApp.getCollectorAddr();\n            if (previousCollectorAddr \u003d\u003d null\n                || !previousCollectorAddr.equals(collectorAddr)) {\n              // sending collector update event.\n              RMAppCollectorUpdateEvent event \u003d\n                  new RMAppCollectorUpdateEvent(appId, collectorAddr);\n              rmContext.getDispatcher().getEventHandler().handle(event);\n            }\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "2188a07e5bea1da26bf679ca0ece26ab596d3438": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "YARN-3333. Rename TimelineAggregator etc. to TimelineCollector. Contributed by Sangjin Lee\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-3333. Rename TimelineAggregator etc. to TimelineCollector. Contributed by Sangjin Lee\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
          "commitAuthor": "Junping Du",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "9b5636408005676ae580f8d929f8e912c27828e7",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n-  private void updateAppAggregatorsMap(NodeHeartbeatRequest request) {\n-    Map\u003cApplicationId, String\u003e registeredAggregatorsMap \u003d \n-        request.getRegisteredAggregators();\n-    if (registeredAggregatorsMap !\u003d null \n-        \u0026\u0026 !registeredAggregatorsMap.isEmpty()) {\n+  private void updateAppCollectorsMap(NodeHeartbeatRequest request) {\n+    Map\u003cApplicationId, String\u003e registeredCollectorsMap \u003d\n+        request.getRegisteredCollectors();\n+    if (registeredCollectorsMap !\u003d null\n+        \u0026\u0026 !registeredCollectorsMap.isEmpty()) {\n       Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n-      for (Map.Entry\u003cApplicationId, String\u003e entry: \n-          registeredAggregatorsMap.entrySet()) {\n+      for (Map.Entry\u003cApplicationId, String\u003e entry:\n+          registeredCollectorsMap.entrySet()) {\n         ApplicationId appId \u003d entry.getKey();\n-        String aggregatorAddr \u003d entry.getValue();\n-        if (aggregatorAddr !\u003d null \u0026\u0026 !aggregatorAddr.isEmpty()) {\n+        String collectorAddr \u003d entry.getValue();\n+        if (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) {\n           RMApp rmApp \u003d rmApps.get(appId);\n           if (rmApp \u003d\u003d null) {\n-            LOG.warn(\"Cannot update aggregator info because application ID: \" + \n+            LOG.warn(\"Cannot update collector info because application ID: \" +\n                 appId + \" is not found in RMContext!\");\n           } else {\n-            String previousAggregatorAddr \u003d rmApp.getAggregatorAddr();\n-            if (previousAggregatorAddr \u003d\u003d null || \n-                previousAggregatorAddr !\u003d aggregatorAddr) {\n-              // sending aggregator update event.\n-              RMAppAggregatorUpdateEvent event \u003d\n-                  new RMAppAggregatorUpdateEvent(appId, aggregatorAddr);\n+            String previousCollectorAddr \u003d rmApp.getCollectorAddr();\n+            if (previousCollectorAddr \u003d\u003d null ||\n+                previousCollectorAddr !\u003d collectorAddr) {\n+              // sending collector update event.\n+              RMAppCollectorUpdateEvent event \u003d\n+                  new RMAppCollectorUpdateEvent(appId, collectorAddr);\n               rmContext.getDispatcher().getEventHandler().handle(event);\n             }\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void updateAppCollectorsMap(NodeHeartbeatRequest request) {\n    Map\u003cApplicationId, String\u003e registeredCollectorsMap \u003d\n        request.getRegisteredCollectors();\n    if (registeredCollectorsMap !\u003d null\n        \u0026\u0026 !registeredCollectorsMap.isEmpty()) {\n      Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n      for (Map.Entry\u003cApplicationId, String\u003e entry:\n          registeredCollectorsMap.entrySet()) {\n        ApplicationId appId \u003d entry.getKey();\n        String collectorAddr \u003d entry.getValue();\n        if (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) {\n          RMApp rmApp \u003d rmApps.get(appId);\n          if (rmApp \u003d\u003d null) {\n            LOG.warn(\"Cannot update collector info because application ID: \" +\n                appId + \" is not found in RMContext!\");\n          } else {\n            String previousCollectorAddr \u003d rmApp.getCollectorAddr();\n            if (previousCollectorAddr \u003d\u003d null ||\n                previousCollectorAddr !\u003d collectorAddr) {\n              // sending collector update event.\n              RMAppCollectorUpdateEvent event \u003d\n                  new RMAppCollectorUpdateEvent(appId, collectorAddr);\n              rmContext.getDispatcher().getEventHandler().handle(event);\n            }\n          }\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
          "extendedDetails": {
            "oldValue": "updateAppAggregatorsMap",
            "newValue": "updateAppCollectorsMap"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3333. Rename TimelineAggregator etc. to TimelineCollector. Contributed by Sangjin Lee\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
          "commitAuthor": "Junping Du",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "9b5636408005676ae580f8d929f8e912c27828e7",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n-  private void updateAppAggregatorsMap(NodeHeartbeatRequest request) {\n-    Map\u003cApplicationId, String\u003e registeredAggregatorsMap \u003d \n-        request.getRegisteredAggregators();\n-    if (registeredAggregatorsMap !\u003d null \n-        \u0026\u0026 !registeredAggregatorsMap.isEmpty()) {\n+  private void updateAppCollectorsMap(NodeHeartbeatRequest request) {\n+    Map\u003cApplicationId, String\u003e registeredCollectorsMap \u003d\n+        request.getRegisteredCollectors();\n+    if (registeredCollectorsMap !\u003d null\n+        \u0026\u0026 !registeredCollectorsMap.isEmpty()) {\n       Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n-      for (Map.Entry\u003cApplicationId, String\u003e entry: \n-          registeredAggregatorsMap.entrySet()) {\n+      for (Map.Entry\u003cApplicationId, String\u003e entry:\n+          registeredCollectorsMap.entrySet()) {\n         ApplicationId appId \u003d entry.getKey();\n-        String aggregatorAddr \u003d entry.getValue();\n-        if (aggregatorAddr !\u003d null \u0026\u0026 !aggregatorAddr.isEmpty()) {\n+        String collectorAddr \u003d entry.getValue();\n+        if (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) {\n           RMApp rmApp \u003d rmApps.get(appId);\n           if (rmApp \u003d\u003d null) {\n-            LOG.warn(\"Cannot update aggregator info because application ID: \" + \n+            LOG.warn(\"Cannot update collector info because application ID: \" +\n                 appId + \" is not found in RMContext!\");\n           } else {\n-            String previousAggregatorAddr \u003d rmApp.getAggregatorAddr();\n-            if (previousAggregatorAddr \u003d\u003d null || \n-                previousAggregatorAddr !\u003d aggregatorAddr) {\n-              // sending aggregator update event.\n-              RMAppAggregatorUpdateEvent event \u003d\n-                  new RMAppAggregatorUpdateEvent(appId, aggregatorAddr);\n+            String previousCollectorAddr \u003d rmApp.getCollectorAddr();\n+            if (previousCollectorAddr \u003d\u003d null ||\n+                previousCollectorAddr !\u003d collectorAddr) {\n+              // sending collector update event.\n+              RMAppCollectorUpdateEvent event \u003d\n+                  new RMAppCollectorUpdateEvent(appId, collectorAddr);\n               rmContext.getDispatcher().getEventHandler().handle(event);\n             }\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void updateAppCollectorsMap(NodeHeartbeatRequest request) {\n    Map\u003cApplicationId, String\u003e registeredCollectorsMap \u003d\n        request.getRegisteredCollectors();\n    if (registeredCollectorsMap !\u003d null\n        \u0026\u0026 !registeredCollectorsMap.isEmpty()) {\n      Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n      for (Map.Entry\u003cApplicationId, String\u003e entry:\n          registeredCollectorsMap.entrySet()) {\n        ApplicationId appId \u003d entry.getKey();\n        String collectorAddr \u003d entry.getValue();\n        if (collectorAddr !\u003d null \u0026\u0026 !collectorAddr.isEmpty()) {\n          RMApp rmApp \u003d rmApps.get(appId);\n          if (rmApp \u003d\u003d null) {\n            LOG.warn(\"Cannot update collector info because application ID: \" +\n                appId + \" is not found in RMContext!\");\n          } else {\n            String previousCollectorAddr \u003d rmApp.getCollectorAddr();\n            if (previousCollectorAddr \u003d\u003d null ||\n                previousCollectorAddr !\u003d collectorAddr) {\n              // sending collector update event.\n              RMAppCollectorUpdateEvent event \u003d\n                  new RMAppCollectorUpdateEvent(appId, collectorAddr);\n              rmContext.getDispatcher().getEventHandler().handle(event);\n            }\n          }\n        }\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
          "extendedDetails": {}
        }
      ]
    },
    "9b5636408005676ae580f8d929f8e912c27828e7": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3039. Implemented the app-level timeline aggregator discovery service. Contributed by Junping Du.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "9b5636408005676ae580f8d929f8e912c27828e7",
      "commitAuthor": "Zhijie Shen",
      "diff": "@@ -0,0 +1,29 @@\n+  private void updateAppAggregatorsMap(NodeHeartbeatRequest request) {\n+    Map\u003cApplicationId, String\u003e registeredAggregatorsMap \u003d \n+        request.getRegisteredAggregators();\n+    if (registeredAggregatorsMap !\u003d null \n+        \u0026\u0026 !registeredAggregatorsMap.isEmpty()) {\n+      Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n+      for (Map.Entry\u003cApplicationId, String\u003e entry: \n+          registeredAggregatorsMap.entrySet()) {\n+        ApplicationId appId \u003d entry.getKey();\n+        String aggregatorAddr \u003d entry.getValue();\n+        if (aggregatorAddr !\u003d null \u0026\u0026 !aggregatorAddr.isEmpty()) {\n+          RMApp rmApp \u003d rmApps.get(appId);\n+          if (rmApp \u003d\u003d null) {\n+            LOG.warn(\"Cannot update aggregator info because application ID: \" + \n+                appId + \" is not found in RMContext!\");\n+          } else {\n+            String previousAggregatorAddr \u003d rmApp.getAggregatorAddr();\n+            if (previousAggregatorAddr \u003d\u003d null || \n+                previousAggregatorAddr !\u003d aggregatorAddr) {\n+              // sending aggregator update event.\n+              RMAppAggregatorUpdateEvent event \u003d\n+                  new RMAppAggregatorUpdateEvent(appId, aggregatorAddr);\n+              rmContext.getDispatcher().getEventHandler().handle(event);\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateAppAggregatorsMap(NodeHeartbeatRequest request) {\n    Map\u003cApplicationId, String\u003e registeredAggregatorsMap \u003d \n        request.getRegisteredAggregators();\n    if (registeredAggregatorsMap !\u003d null \n        \u0026\u0026 !registeredAggregatorsMap.isEmpty()) {\n      Map\u003cApplicationId, RMApp\u003e rmApps \u003d rmContext.getRMApps();\n      for (Map.Entry\u003cApplicationId, String\u003e entry: \n          registeredAggregatorsMap.entrySet()) {\n        ApplicationId appId \u003d entry.getKey();\n        String aggregatorAddr \u003d entry.getValue();\n        if (aggregatorAddr !\u003d null \u0026\u0026 !aggregatorAddr.isEmpty()) {\n          RMApp rmApp \u003d rmApps.get(appId);\n          if (rmApp \u003d\u003d null) {\n            LOG.warn(\"Cannot update aggregator info because application ID: \" + \n                appId + \" is not found in RMContext!\");\n          } else {\n            String previousAggregatorAddr \u003d rmApp.getAggregatorAddr();\n            if (previousAggregatorAddr \u003d\u003d null || \n                previousAggregatorAddr !\u003d aggregatorAddr) {\n              // sending aggregator update event.\n              RMAppAggregatorUpdateEvent event \u003d\n                  new RMAppAggregatorUpdateEvent(appId, aggregatorAddr);\n              rmContext.getDispatcher().getEventHandler().handle(event);\n            }\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java"
    }
  }
}