{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LogAggregationIndexedFileController.java",
  "functionName": "initializeWriterInRolling",
  "functionId": "initializeWriterInRolling___remoteLogFile-Path(modifiers-final)__appId-ApplicationId(modifiers-final)__nodeId-String(modifiers-final)",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
  "functionStartLine": 253,
  "functionEndLine": 350,
  "numCommitsSeen": 18,
  "timeTaken": 2471,
  "changeHistory": [
    "6d52bbbfcfd7750b7e547abdcd0d14632d6ed9b6",
    "d4c98579e36df7eeb788352d7b76cd2c7448c511",
    "280080fad01304c85a9ede4d4f7b707eb36c0155"
  ],
  "changeHistoryShort": {
    "6d52bbbfcfd7750b7e547abdcd0d14632d6ed9b6": "Ymultichange(Yreturntypechange,Ybodychange)",
    "d4c98579e36df7eeb788352d7b76cd2c7448c511": "Ybodychange",
    "280080fad01304c85a9ede4d4f7b707eb36c0155": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6d52bbbfcfd7750b7e547abdcd0d14632d6ed9b6": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-9525. IFile format is not working against s3a remote folder. Contributed by Adam Antal\n",
      "commitDate": "20/01/20 3:36 AM",
      "commitName": "6d52bbbfcfd7750b7e547abdcd0d14632d6ed9b6",
      "commitAuthor": "Szilard Nemeth",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-9525. IFile format is not working against s3a remote folder. Contributed by Adam Antal\n",
          "commitDate": "20/01/20 3:36 AM",
          "commitName": "6d52bbbfcfd7750b7e547abdcd0d14632d6ed9b6",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "05/12/19 12:49 PM",
          "commitNameOld": "4f758dd4c682bacbb110c51a96079a6c5d103c95",
          "commitAuthorOld": "Szilard Nemeth",
          "daysBetweenCommits": 45.62,
          "commitsBetweenForRepo": 149,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,89 +1,98 @@\n-  private Path initializeWriterInRolling(final Path remoteLogFile,\n-      final ApplicationId appId, final String nodeId) throws Exception {\n+  private Pair\u003cPath, Boolean\u003e initializeWriterInRolling(\n+      final Path remoteLogFile, final ApplicationId appId,\n+      final String nodeId) throws Exception {\n+    boolean createdNew \u003d false;\n     Path aggregatedLogFile \u003d null;\n     // check uuid\n     // if we can not find uuid, we would load the uuid\n     // from previous aggregated log files, and at the same\n     // time, we would delete any aggregated log files which\n     // has invalid uuid.\n     if (uuid \u003d\u003d null) {\n       uuid \u003d loadUUIDFromLogFile(fc, remoteLogFile.getParent(),\n             appId, nodeId);\n     }\n     Path currentRemoteLogFile \u003d getCurrentRemoteLogFile(\n         fc, remoteLogFile.getParent(), nodeId);\n     // check checksum file\n     boolean overwriteCheckSum \u003d true;\n     remoteLogCheckSumFile \u003d new Path(remoteLogFile.getParent(),\n         (remoteLogFile.getName() + CHECK_SUM_FILE_SUFFIX));\n     if(fc.util().exists(remoteLogCheckSumFile)) {\n       // if the checksum file exists, we should reset cached\n       // indexedLogsMeta.\n       indexedLogsMeta.getLogMetas().clear();\n       if (currentRemoteLogFile !\u003d null) {\n         FSDataInputStream checksumFileInputStream \u003d null;\n         try {\n           checksumFileInputStream \u003d fc.open(remoteLogCheckSumFile);\n           int nameLength \u003d checksumFileInputStream.readInt();\n           byte[] b \u003d new byte[nameLength];\n           int actualLength \u003d checksumFileInputStream.read(b);\n           if (actualLength \u003d\u003d nameLength) {\n             String recoveredLogFile \u003d new String(\n                 b, Charset.forName(\"UTF-8\"));\n             if (recoveredLogFile.equals(\n                 currentRemoteLogFile.getName())) {\n               overwriteCheckSum \u003d false;\n               long endIndex \u003d checksumFileInputStream.readLong();\n               IndexedLogsMeta recoveredLogsMeta \u003d loadIndexedLogsMeta(\n                   currentRemoteLogFile, endIndex, appId);\n               if (recoveredLogsMeta !\u003d null) {\n                 indexedLogsMeta \u003d recoveredLogsMeta;\n               }\n             }\n           }\n         } finally {\n           IOUtils.cleanupWithLogger(LOG, checksumFileInputStream);\n         }\n       }\n     }\n     // check whether we need roll over old logs\n     if (currentRemoteLogFile \u003d\u003d null || isRollover(\n         fc, currentRemoteLogFile)) {\n       indexedLogsMeta.getLogMetas().clear();\n       overwriteCheckSum \u003d true;\n       aggregatedLogFile \u003d new Path(remoteLogFile.getParent(),\n           remoteLogFile.getName() + \"_\" + sysClock.getTime());\n       fsDataOStream \u003d fc.create(aggregatedLogFile,\n           EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n           new Options.CreateOpts[] {});\n       // writes the uuid\n       fsDataOStream.write(uuid);\n       fsDataOStream.flush();\n+      createdNew \u003d true;\n     } else {\n       aggregatedLogFile \u003d currentRemoteLogFile;\n       fsDataOStream \u003d fc.create(currentRemoteLogFile,\n           EnumSet.of(CreateFlag.CREATE, CreateFlag.APPEND),\n           new Options.CreateOpts[] {});\n     }\n     // recreate checksum file if needed before aggregate the logs\n     if (overwriteCheckSum) {\n-      final long currentAggregatedLogFileLength \u003d fc\n-          .getFileStatus(aggregatedLogFile).getLen();\n+      long currentAggregatedLogFileLength;\n+      if (createdNew) {\n+        currentAggregatedLogFileLength \u003d 0;\n+      } else {\n+        currentAggregatedLogFileLength \u003d fc\n+            .getFileStatus(aggregatedLogFile).getLen();\n+      }\n       FSDataOutputStream checksumFileOutputStream \u003d null;\n       try {\n         checksumFileOutputStream \u003d fc.create(remoteLogCheckSumFile,\n             EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n             new Options.CreateOpts[] {});\n         String fileName \u003d aggregatedLogFile.getName();\n         checksumFileOutputStream.writeInt(fileName.length());\n         checksumFileOutputStream.write(fileName.getBytes(\n             Charset.forName(\"UTF-8\")));\n         checksumFileOutputStream.writeLong(\n             currentAggregatedLogFileLength);\n         checksumFileOutputStream.flush();\n       } finally {\n         IOUtils.cleanupWithLogger(LOG, checksumFileOutputStream);\n       }\n     }\n-    return aggregatedLogFile;\n+\n+    return Pair.of(aggregatedLogFile, createdNew);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Pair\u003cPath, Boolean\u003e initializeWriterInRolling(\n      final Path remoteLogFile, final ApplicationId appId,\n      final String nodeId) throws Exception {\n    boolean createdNew \u003d false;\n    Path aggregatedLogFile \u003d null;\n    // check uuid\n    // if we can not find uuid, we would load the uuid\n    // from previous aggregated log files, and at the same\n    // time, we would delete any aggregated log files which\n    // has invalid uuid.\n    if (uuid \u003d\u003d null) {\n      uuid \u003d loadUUIDFromLogFile(fc, remoteLogFile.getParent(),\n            appId, nodeId);\n    }\n    Path currentRemoteLogFile \u003d getCurrentRemoteLogFile(\n        fc, remoteLogFile.getParent(), nodeId);\n    // check checksum file\n    boolean overwriteCheckSum \u003d true;\n    remoteLogCheckSumFile \u003d new Path(remoteLogFile.getParent(),\n        (remoteLogFile.getName() + CHECK_SUM_FILE_SUFFIX));\n    if(fc.util().exists(remoteLogCheckSumFile)) {\n      // if the checksum file exists, we should reset cached\n      // indexedLogsMeta.\n      indexedLogsMeta.getLogMetas().clear();\n      if (currentRemoteLogFile !\u003d null) {\n        FSDataInputStream checksumFileInputStream \u003d null;\n        try {\n          checksumFileInputStream \u003d fc.open(remoteLogCheckSumFile);\n          int nameLength \u003d checksumFileInputStream.readInt();\n          byte[] b \u003d new byte[nameLength];\n          int actualLength \u003d checksumFileInputStream.read(b);\n          if (actualLength \u003d\u003d nameLength) {\n            String recoveredLogFile \u003d new String(\n                b, Charset.forName(\"UTF-8\"));\n            if (recoveredLogFile.equals(\n                currentRemoteLogFile.getName())) {\n              overwriteCheckSum \u003d false;\n              long endIndex \u003d checksumFileInputStream.readLong();\n              IndexedLogsMeta recoveredLogsMeta \u003d loadIndexedLogsMeta(\n                  currentRemoteLogFile, endIndex, appId);\n              if (recoveredLogsMeta !\u003d null) {\n                indexedLogsMeta \u003d recoveredLogsMeta;\n              }\n            }\n          }\n        } finally {\n          IOUtils.cleanupWithLogger(LOG, checksumFileInputStream);\n        }\n      }\n    }\n    // check whether we need roll over old logs\n    if (currentRemoteLogFile \u003d\u003d null || isRollover(\n        fc, currentRemoteLogFile)) {\n      indexedLogsMeta.getLogMetas().clear();\n      overwriteCheckSum \u003d true;\n      aggregatedLogFile \u003d new Path(remoteLogFile.getParent(),\n          remoteLogFile.getName() + \"_\" + sysClock.getTime());\n      fsDataOStream \u003d fc.create(aggregatedLogFile,\n          EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n          new Options.CreateOpts[] {});\n      // writes the uuid\n      fsDataOStream.write(uuid);\n      fsDataOStream.flush();\n      createdNew \u003d true;\n    } else {\n      aggregatedLogFile \u003d currentRemoteLogFile;\n      fsDataOStream \u003d fc.create(currentRemoteLogFile,\n          EnumSet.of(CreateFlag.CREATE, CreateFlag.APPEND),\n          new Options.CreateOpts[] {});\n    }\n    // recreate checksum file if needed before aggregate the logs\n    if (overwriteCheckSum) {\n      long currentAggregatedLogFileLength;\n      if (createdNew) {\n        currentAggregatedLogFileLength \u003d 0;\n      } else {\n        currentAggregatedLogFileLength \u003d fc\n            .getFileStatus(aggregatedLogFile).getLen();\n      }\n      FSDataOutputStream checksumFileOutputStream \u003d null;\n      try {\n        checksumFileOutputStream \u003d fc.create(remoteLogCheckSumFile,\n            EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n            new Options.CreateOpts[] {});\n        String fileName \u003d aggregatedLogFile.getName();\n        checksumFileOutputStream.writeInt(fileName.length());\n        checksumFileOutputStream.write(fileName.getBytes(\n            Charset.forName(\"UTF-8\")));\n        checksumFileOutputStream.writeLong(\n            currentAggregatedLogFileLength);\n        checksumFileOutputStream.flush();\n      } finally {\n        IOUtils.cleanupWithLogger(LOG, checksumFileOutputStream);\n      }\n    }\n\n    return Pair.of(aggregatedLogFile, createdNew);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
          "extendedDetails": {
            "oldValue": "Path",
            "newValue": "Pair\u003cPath,Boolean\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9525. IFile format is not working against s3a remote folder. Contributed by Adam Antal\n",
          "commitDate": "20/01/20 3:36 AM",
          "commitName": "6d52bbbfcfd7750b7e547abdcd0d14632d6ed9b6",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "05/12/19 12:49 PM",
          "commitNameOld": "4f758dd4c682bacbb110c51a96079a6c5d103c95",
          "commitAuthorOld": "Szilard Nemeth",
          "daysBetweenCommits": 45.62,
          "commitsBetweenForRepo": 149,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,89 +1,98 @@\n-  private Path initializeWriterInRolling(final Path remoteLogFile,\n-      final ApplicationId appId, final String nodeId) throws Exception {\n+  private Pair\u003cPath, Boolean\u003e initializeWriterInRolling(\n+      final Path remoteLogFile, final ApplicationId appId,\n+      final String nodeId) throws Exception {\n+    boolean createdNew \u003d false;\n     Path aggregatedLogFile \u003d null;\n     // check uuid\n     // if we can not find uuid, we would load the uuid\n     // from previous aggregated log files, and at the same\n     // time, we would delete any aggregated log files which\n     // has invalid uuid.\n     if (uuid \u003d\u003d null) {\n       uuid \u003d loadUUIDFromLogFile(fc, remoteLogFile.getParent(),\n             appId, nodeId);\n     }\n     Path currentRemoteLogFile \u003d getCurrentRemoteLogFile(\n         fc, remoteLogFile.getParent(), nodeId);\n     // check checksum file\n     boolean overwriteCheckSum \u003d true;\n     remoteLogCheckSumFile \u003d new Path(remoteLogFile.getParent(),\n         (remoteLogFile.getName() + CHECK_SUM_FILE_SUFFIX));\n     if(fc.util().exists(remoteLogCheckSumFile)) {\n       // if the checksum file exists, we should reset cached\n       // indexedLogsMeta.\n       indexedLogsMeta.getLogMetas().clear();\n       if (currentRemoteLogFile !\u003d null) {\n         FSDataInputStream checksumFileInputStream \u003d null;\n         try {\n           checksumFileInputStream \u003d fc.open(remoteLogCheckSumFile);\n           int nameLength \u003d checksumFileInputStream.readInt();\n           byte[] b \u003d new byte[nameLength];\n           int actualLength \u003d checksumFileInputStream.read(b);\n           if (actualLength \u003d\u003d nameLength) {\n             String recoveredLogFile \u003d new String(\n                 b, Charset.forName(\"UTF-8\"));\n             if (recoveredLogFile.equals(\n                 currentRemoteLogFile.getName())) {\n               overwriteCheckSum \u003d false;\n               long endIndex \u003d checksumFileInputStream.readLong();\n               IndexedLogsMeta recoveredLogsMeta \u003d loadIndexedLogsMeta(\n                   currentRemoteLogFile, endIndex, appId);\n               if (recoveredLogsMeta !\u003d null) {\n                 indexedLogsMeta \u003d recoveredLogsMeta;\n               }\n             }\n           }\n         } finally {\n           IOUtils.cleanupWithLogger(LOG, checksumFileInputStream);\n         }\n       }\n     }\n     // check whether we need roll over old logs\n     if (currentRemoteLogFile \u003d\u003d null || isRollover(\n         fc, currentRemoteLogFile)) {\n       indexedLogsMeta.getLogMetas().clear();\n       overwriteCheckSum \u003d true;\n       aggregatedLogFile \u003d new Path(remoteLogFile.getParent(),\n           remoteLogFile.getName() + \"_\" + sysClock.getTime());\n       fsDataOStream \u003d fc.create(aggregatedLogFile,\n           EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n           new Options.CreateOpts[] {});\n       // writes the uuid\n       fsDataOStream.write(uuid);\n       fsDataOStream.flush();\n+      createdNew \u003d true;\n     } else {\n       aggregatedLogFile \u003d currentRemoteLogFile;\n       fsDataOStream \u003d fc.create(currentRemoteLogFile,\n           EnumSet.of(CreateFlag.CREATE, CreateFlag.APPEND),\n           new Options.CreateOpts[] {});\n     }\n     // recreate checksum file if needed before aggregate the logs\n     if (overwriteCheckSum) {\n-      final long currentAggregatedLogFileLength \u003d fc\n-          .getFileStatus(aggregatedLogFile).getLen();\n+      long currentAggregatedLogFileLength;\n+      if (createdNew) {\n+        currentAggregatedLogFileLength \u003d 0;\n+      } else {\n+        currentAggregatedLogFileLength \u003d fc\n+            .getFileStatus(aggregatedLogFile).getLen();\n+      }\n       FSDataOutputStream checksumFileOutputStream \u003d null;\n       try {\n         checksumFileOutputStream \u003d fc.create(remoteLogCheckSumFile,\n             EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n             new Options.CreateOpts[] {});\n         String fileName \u003d aggregatedLogFile.getName();\n         checksumFileOutputStream.writeInt(fileName.length());\n         checksumFileOutputStream.write(fileName.getBytes(\n             Charset.forName(\"UTF-8\")));\n         checksumFileOutputStream.writeLong(\n             currentAggregatedLogFileLength);\n         checksumFileOutputStream.flush();\n       } finally {\n         IOUtils.cleanupWithLogger(LOG, checksumFileOutputStream);\n       }\n     }\n-    return aggregatedLogFile;\n+\n+    return Pair.of(aggregatedLogFile, createdNew);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Pair\u003cPath, Boolean\u003e initializeWriterInRolling(\n      final Path remoteLogFile, final ApplicationId appId,\n      final String nodeId) throws Exception {\n    boolean createdNew \u003d false;\n    Path aggregatedLogFile \u003d null;\n    // check uuid\n    // if we can not find uuid, we would load the uuid\n    // from previous aggregated log files, and at the same\n    // time, we would delete any aggregated log files which\n    // has invalid uuid.\n    if (uuid \u003d\u003d null) {\n      uuid \u003d loadUUIDFromLogFile(fc, remoteLogFile.getParent(),\n            appId, nodeId);\n    }\n    Path currentRemoteLogFile \u003d getCurrentRemoteLogFile(\n        fc, remoteLogFile.getParent(), nodeId);\n    // check checksum file\n    boolean overwriteCheckSum \u003d true;\n    remoteLogCheckSumFile \u003d new Path(remoteLogFile.getParent(),\n        (remoteLogFile.getName() + CHECK_SUM_FILE_SUFFIX));\n    if(fc.util().exists(remoteLogCheckSumFile)) {\n      // if the checksum file exists, we should reset cached\n      // indexedLogsMeta.\n      indexedLogsMeta.getLogMetas().clear();\n      if (currentRemoteLogFile !\u003d null) {\n        FSDataInputStream checksumFileInputStream \u003d null;\n        try {\n          checksumFileInputStream \u003d fc.open(remoteLogCheckSumFile);\n          int nameLength \u003d checksumFileInputStream.readInt();\n          byte[] b \u003d new byte[nameLength];\n          int actualLength \u003d checksumFileInputStream.read(b);\n          if (actualLength \u003d\u003d nameLength) {\n            String recoveredLogFile \u003d new String(\n                b, Charset.forName(\"UTF-8\"));\n            if (recoveredLogFile.equals(\n                currentRemoteLogFile.getName())) {\n              overwriteCheckSum \u003d false;\n              long endIndex \u003d checksumFileInputStream.readLong();\n              IndexedLogsMeta recoveredLogsMeta \u003d loadIndexedLogsMeta(\n                  currentRemoteLogFile, endIndex, appId);\n              if (recoveredLogsMeta !\u003d null) {\n                indexedLogsMeta \u003d recoveredLogsMeta;\n              }\n            }\n          }\n        } finally {\n          IOUtils.cleanupWithLogger(LOG, checksumFileInputStream);\n        }\n      }\n    }\n    // check whether we need roll over old logs\n    if (currentRemoteLogFile \u003d\u003d null || isRollover(\n        fc, currentRemoteLogFile)) {\n      indexedLogsMeta.getLogMetas().clear();\n      overwriteCheckSum \u003d true;\n      aggregatedLogFile \u003d new Path(remoteLogFile.getParent(),\n          remoteLogFile.getName() + \"_\" + sysClock.getTime());\n      fsDataOStream \u003d fc.create(aggregatedLogFile,\n          EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n          new Options.CreateOpts[] {});\n      // writes the uuid\n      fsDataOStream.write(uuid);\n      fsDataOStream.flush();\n      createdNew \u003d true;\n    } else {\n      aggregatedLogFile \u003d currentRemoteLogFile;\n      fsDataOStream \u003d fc.create(currentRemoteLogFile,\n          EnumSet.of(CreateFlag.CREATE, CreateFlag.APPEND),\n          new Options.CreateOpts[] {});\n    }\n    // recreate checksum file if needed before aggregate the logs\n    if (overwriteCheckSum) {\n      long currentAggregatedLogFileLength;\n      if (createdNew) {\n        currentAggregatedLogFileLength \u003d 0;\n      } else {\n        currentAggregatedLogFileLength \u003d fc\n            .getFileStatus(aggregatedLogFile).getLen();\n      }\n      FSDataOutputStream checksumFileOutputStream \u003d null;\n      try {\n        checksumFileOutputStream \u003d fc.create(remoteLogCheckSumFile,\n            EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n            new Options.CreateOpts[] {});\n        String fileName \u003d aggregatedLogFile.getName();\n        checksumFileOutputStream.writeInt(fileName.length());\n        checksumFileOutputStream.write(fileName.getBytes(\n            Charset.forName(\"UTF-8\")));\n        checksumFileOutputStream.writeLong(\n            currentAggregatedLogFileLength);\n        checksumFileOutputStream.flush();\n      } finally {\n        IOUtils.cleanupWithLogger(LOG, checksumFileOutputStream);\n      }\n    }\n\n    return Pair.of(aggregatedLogFile, createdNew);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
          "extendedDetails": {}
        }
      ]
    },
    "d4c98579e36df7eeb788352d7b76cd2c7448c511": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7697. NM goes down with OOM due to leak in log-aggregation. (Xuan Gong via wangda)\n\nChange-Id: Ie4fc7979d834e25f37a033c314f3efceeb8f4a9e\n",
      "commitDate": "11/02/18 6:28 PM",
      "commitName": "d4c98579e36df7eeb788352d7b76cd2c7448c511",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "02/10/17 3:30 PM",
      "commitNameOld": "280080fad01304c85a9ede4d4f7b707eb36c0155",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 132.17,
      "commitsBetweenForRepo": 906,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,89 @@\n   private Path initializeWriterInRolling(final Path remoteLogFile,\n       final ApplicationId appId, final String nodeId) throws Exception {\n     Path aggregatedLogFile \u003d null;\n     // check uuid\n     // if we can not find uuid, we would load the uuid\n     // from previous aggregated log files, and at the same\n     // time, we would delete any aggregated log files which\n     // has invalid uuid.\n     if (uuid \u003d\u003d null) {\n       uuid \u003d loadUUIDFromLogFile(fc, remoteLogFile.getParent(),\n             appId, nodeId);\n     }\n     Path currentRemoteLogFile \u003d getCurrentRemoteLogFile(\n         fc, remoteLogFile.getParent(), nodeId);\n     // check checksum file\n     boolean overwriteCheckSum \u003d true;\n     remoteLogCheckSumFile \u003d new Path(remoteLogFile.getParent(),\n         (remoteLogFile.getName() + CHECK_SUM_FILE_SUFFIX));\n     if(fc.util().exists(remoteLogCheckSumFile)) {\n       // if the checksum file exists, we should reset cached\n       // indexedLogsMeta.\n       indexedLogsMeta.getLogMetas().clear();\n       if (currentRemoteLogFile !\u003d null) {\n         FSDataInputStream checksumFileInputStream \u003d null;\n         try {\n           checksumFileInputStream \u003d fc.open(remoteLogCheckSumFile);\n           int nameLength \u003d checksumFileInputStream.readInt();\n           byte[] b \u003d new byte[nameLength];\n           int actualLength \u003d checksumFileInputStream.read(b);\n           if (actualLength \u003d\u003d nameLength) {\n             String recoveredLogFile \u003d new String(\n                 b, Charset.forName(\"UTF-8\"));\n             if (recoveredLogFile.equals(\n                 currentRemoteLogFile.getName())) {\n               overwriteCheckSum \u003d false;\n               long endIndex \u003d checksumFileInputStream.readLong();\n-              IndexedLogsMeta recoveredLogsMeta \u003d null;\n-              try {\n-                truncateFileWithRetries(fc, currentRemoteLogFile,\n-                    endIndex);\n-                recoveredLogsMeta \u003d loadIndexedLogsMeta(\n-                    currentRemoteLogFile);\n-              } catch (Exception ex) {\n-                recoveredLogsMeta \u003d loadIndexedLogsMeta(\n-                    currentRemoteLogFile, endIndex);\n-              }\n+              IndexedLogsMeta recoveredLogsMeta \u003d loadIndexedLogsMeta(\n+                  currentRemoteLogFile, endIndex, appId);\n               if (recoveredLogsMeta !\u003d null) {\n                 indexedLogsMeta \u003d recoveredLogsMeta;\n               }\n             }\n           }\n         } finally {\n           IOUtils.cleanupWithLogger(LOG, checksumFileInputStream);\n         }\n       }\n     }\n     // check whether we need roll over old logs\n     if (currentRemoteLogFile \u003d\u003d null || isRollover(\n         fc, currentRemoteLogFile)) {\n       indexedLogsMeta.getLogMetas().clear();\n       overwriteCheckSum \u003d true;\n       aggregatedLogFile \u003d new Path(remoteLogFile.getParent(),\n           remoteLogFile.getName() + \"_\" + sysClock.getTime());\n       fsDataOStream \u003d fc.create(aggregatedLogFile,\n           EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n           new Options.CreateOpts[] {});\n       // writes the uuid\n       fsDataOStream.write(uuid);\n       fsDataOStream.flush();\n     } else {\n       aggregatedLogFile \u003d currentRemoteLogFile;\n       fsDataOStream \u003d fc.create(currentRemoteLogFile,\n           EnumSet.of(CreateFlag.CREATE, CreateFlag.APPEND),\n           new Options.CreateOpts[] {});\n     }\n     // recreate checksum file if needed before aggregate the logs\n     if (overwriteCheckSum) {\n       final long currentAggregatedLogFileLength \u003d fc\n           .getFileStatus(aggregatedLogFile).getLen();\n       FSDataOutputStream checksumFileOutputStream \u003d null;\n       try {\n         checksumFileOutputStream \u003d fc.create(remoteLogCheckSumFile,\n             EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n             new Options.CreateOpts[] {});\n         String fileName \u003d aggregatedLogFile.getName();\n         checksumFileOutputStream.writeInt(fileName.length());\n         checksumFileOutputStream.write(fileName.getBytes(\n             Charset.forName(\"UTF-8\")));\n         checksumFileOutputStream.writeLong(\n             currentAggregatedLogFileLength);\n         checksumFileOutputStream.flush();\n       } finally {\n         IOUtils.cleanupWithLogger(LOG, checksumFileOutputStream);\n       }\n     }\n     return aggregatedLogFile;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Path initializeWriterInRolling(final Path remoteLogFile,\n      final ApplicationId appId, final String nodeId) throws Exception {\n    Path aggregatedLogFile \u003d null;\n    // check uuid\n    // if we can not find uuid, we would load the uuid\n    // from previous aggregated log files, and at the same\n    // time, we would delete any aggregated log files which\n    // has invalid uuid.\n    if (uuid \u003d\u003d null) {\n      uuid \u003d loadUUIDFromLogFile(fc, remoteLogFile.getParent(),\n            appId, nodeId);\n    }\n    Path currentRemoteLogFile \u003d getCurrentRemoteLogFile(\n        fc, remoteLogFile.getParent(), nodeId);\n    // check checksum file\n    boolean overwriteCheckSum \u003d true;\n    remoteLogCheckSumFile \u003d new Path(remoteLogFile.getParent(),\n        (remoteLogFile.getName() + CHECK_SUM_FILE_SUFFIX));\n    if(fc.util().exists(remoteLogCheckSumFile)) {\n      // if the checksum file exists, we should reset cached\n      // indexedLogsMeta.\n      indexedLogsMeta.getLogMetas().clear();\n      if (currentRemoteLogFile !\u003d null) {\n        FSDataInputStream checksumFileInputStream \u003d null;\n        try {\n          checksumFileInputStream \u003d fc.open(remoteLogCheckSumFile);\n          int nameLength \u003d checksumFileInputStream.readInt();\n          byte[] b \u003d new byte[nameLength];\n          int actualLength \u003d checksumFileInputStream.read(b);\n          if (actualLength \u003d\u003d nameLength) {\n            String recoveredLogFile \u003d new String(\n                b, Charset.forName(\"UTF-8\"));\n            if (recoveredLogFile.equals(\n                currentRemoteLogFile.getName())) {\n              overwriteCheckSum \u003d false;\n              long endIndex \u003d checksumFileInputStream.readLong();\n              IndexedLogsMeta recoveredLogsMeta \u003d loadIndexedLogsMeta(\n                  currentRemoteLogFile, endIndex, appId);\n              if (recoveredLogsMeta !\u003d null) {\n                indexedLogsMeta \u003d recoveredLogsMeta;\n              }\n            }\n          }\n        } finally {\n          IOUtils.cleanupWithLogger(LOG, checksumFileInputStream);\n        }\n      }\n    }\n    // check whether we need roll over old logs\n    if (currentRemoteLogFile \u003d\u003d null || isRollover(\n        fc, currentRemoteLogFile)) {\n      indexedLogsMeta.getLogMetas().clear();\n      overwriteCheckSum \u003d true;\n      aggregatedLogFile \u003d new Path(remoteLogFile.getParent(),\n          remoteLogFile.getName() + \"_\" + sysClock.getTime());\n      fsDataOStream \u003d fc.create(aggregatedLogFile,\n          EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n          new Options.CreateOpts[] {});\n      // writes the uuid\n      fsDataOStream.write(uuid);\n      fsDataOStream.flush();\n    } else {\n      aggregatedLogFile \u003d currentRemoteLogFile;\n      fsDataOStream \u003d fc.create(currentRemoteLogFile,\n          EnumSet.of(CreateFlag.CREATE, CreateFlag.APPEND),\n          new Options.CreateOpts[] {});\n    }\n    // recreate checksum file if needed before aggregate the logs\n    if (overwriteCheckSum) {\n      final long currentAggregatedLogFileLength \u003d fc\n          .getFileStatus(aggregatedLogFile).getLen();\n      FSDataOutputStream checksumFileOutputStream \u003d null;\n      try {\n        checksumFileOutputStream \u003d fc.create(remoteLogCheckSumFile,\n            EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n            new Options.CreateOpts[] {});\n        String fileName \u003d aggregatedLogFile.getName();\n        checksumFileOutputStream.writeInt(fileName.length());\n        checksumFileOutputStream.write(fileName.getBytes(\n            Charset.forName(\"UTF-8\")));\n        checksumFileOutputStream.writeLong(\n            currentAggregatedLogFileLength);\n        checksumFileOutputStream.flush();\n      } finally {\n        IOUtils.cleanupWithLogger(LOG, checksumFileOutputStream);\n      }\n    }\n    return aggregatedLogFile;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "280080fad01304c85a9ede4d4f7b707eb36c0155": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7259. Add size-based rolling policy to LogAggregationIndexedFileController. (xgong via wangda)\n\nChange-Id: Ifaf82c0aee6b73b9b6ebf103aa72e131e3942f31\n",
      "commitDate": "02/10/17 3:30 PM",
      "commitName": "280080fad01304c85a9ede4d4f7b707eb36c0155",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,97 @@\n+  private Path initializeWriterInRolling(final Path remoteLogFile,\n+      final ApplicationId appId, final String nodeId) throws Exception {\n+    Path aggregatedLogFile \u003d null;\n+    // check uuid\n+    // if we can not find uuid, we would load the uuid\n+    // from previous aggregated log files, and at the same\n+    // time, we would delete any aggregated log files which\n+    // has invalid uuid.\n+    if (uuid \u003d\u003d null) {\n+      uuid \u003d loadUUIDFromLogFile(fc, remoteLogFile.getParent(),\n+            appId, nodeId);\n+    }\n+    Path currentRemoteLogFile \u003d getCurrentRemoteLogFile(\n+        fc, remoteLogFile.getParent(), nodeId);\n+    // check checksum file\n+    boolean overwriteCheckSum \u003d true;\n+    remoteLogCheckSumFile \u003d new Path(remoteLogFile.getParent(),\n+        (remoteLogFile.getName() + CHECK_SUM_FILE_SUFFIX));\n+    if(fc.util().exists(remoteLogCheckSumFile)) {\n+      // if the checksum file exists, we should reset cached\n+      // indexedLogsMeta.\n+      indexedLogsMeta.getLogMetas().clear();\n+      if (currentRemoteLogFile !\u003d null) {\n+        FSDataInputStream checksumFileInputStream \u003d null;\n+        try {\n+          checksumFileInputStream \u003d fc.open(remoteLogCheckSumFile);\n+          int nameLength \u003d checksumFileInputStream.readInt();\n+          byte[] b \u003d new byte[nameLength];\n+          int actualLength \u003d checksumFileInputStream.read(b);\n+          if (actualLength \u003d\u003d nameLength) {\n+            String recoveredLogFile \u003d new String(\n+                b, Charset.forName(\"UTF-8\"));\n+            if (recoveredLogFile.equals(\n+                currentRemoteLogFile.getName())) {\n+              overwriteCheckSum \u003d false;\n+              long endIndex \u003d checksumFileInputStream.readLong();\n+              IndexedLogsMeta recoveredLogsMeta \u003d null;\n+              try {\n+                truncateFileWithRetries(fc, currentRemoteLogFile,\n+                    endIndex);\n+                recoveredLogsMeta \u003d loadIndexedLogsMeta(\n+                    currentRemoteLogFile);\n+              } catch (Exception ex) {\n+                recoveredLogsMeta \u003d loadIndexedLogsMeta(\n+                    currentRemoteLogFile, endIndex);\n+              }\n+              if (recoveredLogsMeta !\u003d null) {\n+                indexedLogsMeta \u003d recoveredLogsMeta;\n+              }\n+            }\n+          }\n+        } finally {\n+          IOUtils.cleanupWithLogger(LOG, checksumFileInputStream);\n+        }\n+      }\n+    }\n+    // check whether we need roll over old logs\n+    if (currentRemoteLogFile \u003d\u003d null || isRollover(\n+        fc, currentRemoteLogFile)) {\n+      indexedLogsMeta.getLogMetas().clear();\n+      overwriteCheckSum \u003d true;\n+      aggregatedLogFile \u003d new Path(remoteLogFile.getParent(),\n+          remoteLogFile.getName() + \"_\" + sysClock.getTime());\n+      fsDataOStream \u003d fc.create(aggregatedLogFile,\n+          EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n+          new Options.CreateOpts[] {});\n+      // writes the uuid\n+      fsDataOStream.write(uuid);\n+      fsDataOStream.flush();\n+    } else {\n+      aggregatedLogFile \u003d currentRemoteLogFile;\n+      fsDataOStream \u003d fc.create(currentRemoteLogFile,\n+          EnumSet.of(CreateFlag.CREATE, CreateFlag.APPEND),\n+          new Options.CreateOpts[] {});\n+    }\n+    // recreate checksum file if needed before aggregate the logs\n+    if (overwriteCheckSum) {\n+      final long currentAggregatedLogFileLength \u003d fc\n+          .getFileStatus(aggregatedLogFile).getLen();\n+      FSDataOutputStream checksumFileOutputStream \u003d null;\n+      try {\n+        checksumFileOutputStream \u003d fc.create(remoteLogCheckSumFile,\n+            EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n+            new Options.CreateOpts[] {});\n+        String fileName \u003d aggregatedLogFile.getName();\n+        checksumFileOutputStream.writeInt(fileName.length());\n+        checksumFileOutputStream.write(fileName.getBytes(\n+            Charset.forName(\"UTF-8\")));\n+        checksumFileOutputStream.writeLong(\n+            currentAggregatedLogFileLength);\n+        checksumFileOutputStream.flush();\n+      } finally {\n+        IOUtils.cleanupWithLogger(LOG, checksumFileOutputStream);\n+      }\n+    }\n+    return aggregatedLogFile;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Path initializeWriterInRolling(final Path remoteLogFile,\n      final ApplicationId appId, final String nodeId) throws Exception {\n    Path aggregatedLogFile \u003d null;\n    // check uuid\n    // if we can not find uuid, we would load the uuid\n    // from previous aggregated log files, and at the same\n    // time, we would delete any aggregated log files which\n    // has invalid uuid.\n    if (uuid \u003d\u003d null) {\n      uuid \u003d loadUUIDFromLogFile(fc, remoteLogFile.getParent(),\n            appId, nodeId);\n    }\n    Path currentRemoteLogFile \u003d getCurrentRemoteLogFile(\n        fc, remoteLogFile.getParent(), nodeId);\n    // check checksum file\n    boolean overwriteCheckSum \u003d true;\n    remoteLogCheckSumFile \u003d new Path(remoteLogFile.getParent(),\n        (remoteLogFile.getName() + CHECK_SUM_FILE_SUFFIX));\n    if(fc.util().exists(remoteLogCheckSumFile)) {\n      // if the checksum file exists, we should reset cached\n      // indexedLogsMeta.\n      indexedLogsMeta.getLogMetas().clear();\n      if (currentRemoteLogFile !\u003d null) {\n        FSDataInputStream checksumFileInputStream \u003d null;\n        try {\n          checksumFileInputStream \u003d fc.open(remoteLogCheckSumFile);\n          int nameLength \u003d checksumFileInputStream.readInt();\n          byte[] b \u003d new byte[nameLength];\n          int actualLength \u003d checksumFileInputStream.read(b);\n          if (actualLength \u003d\u003d nameLength) {\n            String recoveredLogFile \u003d new String(\n                b, Charset.forName(\"UTF-8\"));\n            if (recoveredLogFile.equals(\n                currentRemoteLogFile.getName())) {\n              overwriteCheckSum \u003d false;\n              long endIndex \u003d checksumFileInputStream.readLong();\n              IndexedLogsMeta recoveredLogsMeta \u003d null;\n              try {\n                truncateFileWithRetries(fc, currentRemoteLogFile,\n                    endIndex);\n                recoveredLogsMeta \u003d loadIndexedLogsMeta(\n                    currentRemoteLogFile);\n              } catch (Exception ex) {\n                recoveredLogsMeta \u003d loadIndexedLogsMeta(\n                    currentRemoteLogFile, endIndex);\n              }\n              if (recoveredLogsMeta !\u003d null) {\n                indexedLogsMeta \u003d recoveredLogsMeta;\n              }\n            }\n          }\n        } finally {\n          IOUtils.cleanupWithLogger(LOG, checksumFileInputStream);\n        }\n      }\n    }\n    // check whether we need roll over old logs\n    if (currentRemoteLogFile \u003d\u003d null || isRollover(\n        fc, currentRemoteLogFile)) {\n      indexedLogsMeta.getLogMetas().clear();\n      overwriteCheckSum \u003d true;\n      aggregatedLogFile \u003d new Path(remoteLogFile.getParent(),\n          remoteLogFile.getName() + \"_\" + sysClock.getTime());\n      fsDataOStream \u003d fc.create(aggregatedLogFile,\n          EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n          new Options.CreateOpts[] {});\n      // writes the uuid\n      fsDataOStream.write(uuid);\n      fsDataOStream.flush();\n    } else {\n      aggregatedLogFile \u003d currentRemoteLogFile;\n      fsDataOStream \u003d fc.create(currentRemoteLogFile,\n          EnumSet.of(CreateFlag.CREATE, CreateFlag.APPEND),\n          new Options.CreateOpts[] {});\n    }\n    // recreate checksum file if needed before aggregate the logs\n    if (overwriteCheckSum) {\n      final long currentAggregatedLogFileLength \u003d fc\n          .getFileStatus(aggregatedLogFile).getLen();\n      FSDataOutputStream checksumFileOutputStream \u003d null;\n      try {\n        checksumFileOutputStream \u003d fc.create(remoteLogCheckSumFile,\n            EnumSet.of(CreateFlag.CREATE, CreateFlag.OVERWRITE),\n            new Options.CreateOpts[] {});\n        String fileName \u003d aggregatedLogFile.getName();\n        checksumFileOutputStream.writeInt(fileName.length());\n        checksumFileOutputStream.write(fileName.getBytes(\n            Charset.forName(\"UTF-8\")));\n        checksumFileOutputStream.writeLong(\n            currentAggregatedLogFileLength);\n        checksumFileOutputStream.flush();\n      } finally {\n        IOUtils.cleanupWithLogger(LOG, checksumFileOutputStream);\n      }\n    }\n    return aggregatedLogFile;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java"
    }
  }
}