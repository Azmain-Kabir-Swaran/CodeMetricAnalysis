{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AclTransformation.java",
  "functionName": "calculateMasks",
  "functionId": "calculateMasks___aclBuilder-List__AclEntry____providedMask-EnumMap__AclEntryScope,AclEntry____maskDirty-EnumSet__AclEntryScope____scopeDirty-EnumSet__AclEntryScope__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclTransformation.java",
  "functionStartLine": 355,
  "functionEndLine": 401,
  "numCommitsSeen": 8,
  "timeTaken": 1932,
  "changeHistory": [
    "543aac9f281871a40473e83061f6deadc0bbdab7",
    "84ddedc0b2d58257d45c16ee5e83b15f94a7ba3a",
    "1fe2bd55341297db698c2b4d03511cdff07c439c",
    "5300294fbe9e235ce42253d6bcd69d8154d8f198",
    "c6585675710aa800317ad35e6fdf95c50c559d68"
  ],
  "changeHistoryShort": {
    "543aac9f281871a40473e83061f6deadc0bbdab7": "Ybodychange",
    "84ddedc0b2d58257d45c16ee5e83b15f94a7ba3a": "Ybodychange",
    "1fe2bd55341297db698c2b4d03511cdff07c439c": "Ybodychange",
    "5300294fbe9e235ce42253d6bcd69d8154d8f198": "Ybodychange",
    "c6585675710aa800317ad35e6fdf95c50c559d68": "Yintroduced"
  },
  "changeHistoryDetails": {
    "543aac9f281871a40473e83061f6deadc0bbdab7": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14386. Rewind trunk from Guava 21.0 back to Guava 11.0.2.\n",
      "commitDate": "09/05/17 9:22 AM",
      "commitName": "543aac9f281871a40473e83061f6deadc0bbdab7",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "24/03/17 6:06 PM",
      "commitNameOld": "84ddedc0b2d58257d45c16ee5e83b15f94a7ba3a",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 45.64,
      "commitsBetweenForRepo": 254,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,47 @@\n   private static void calculateMasks(List\u003cAclEntry\u003e aclBuilder,\n       EnumMap\u003cAclEntryScope, AclEntry\u003e providedMask,\n       EnumSet\u003cAclEntryScope\u003e maskDirty, EnumSet\u003cAclEntryScope\u003e scopeDirty)\n       throws AclException {\n     EnumSet\u003cAclEntryScope\u003e scopeFound \u003d EnumSet.noneOf(AclEntryScope.class);\n     EnumMap\u003cAclEntryScope, FsAction\u003e unionPerms \u003d\n       Maps.newEnumMap(AclEntryScope.class);\n     EnumSet\u003cAclEntryScope\u003e maskNeeded \u003d EnumSet.noneOf(AclEntryScope.class);\n     // Determine which scopes are present, which scopes need a mask, and the\n     // union of group class permissions in each scope.\n     for (AclEntry entry: aclBuilder) {\n       scopeFound.add(entry.getScope());\n       if (entry.getType() \u003d\u003d GROUP || entry.getName() !\u003d null) {\n-        FsAction scopeUnionPerms \u003d MoreObjects.firstNonNull(\n-          unionPerms.get(entry.getScope()), FsAction.NONE);\n+        FsAction scopeUnionPerms \u003d unionPerms.get(entry.getScope());\n+        if (scopeUnionPerms \u003d\u003d null) {\n+          scopeUnionPerms \u003d FsAction.NONE;\n+        }\n         unionPerms.put(entry.getScope(),\n           scopeUnionPerms.or(entry.getPermission()));\n       }\n       if (entry.getName() !\u003d null) {\n         maskNeeded.add(entry.getScope());\n       }\n     }\n     // Add mask entry if needed in each scope.\n     for (AclEntryScope scope: scopeFound) {\n       if (!providedMask.containsKey(scope) \u0026\u0026 maskNeeded.contains(scope) \u0026\u0026\n           maskDirty.contains(scope)) {\n         // Caller explicitly removed mask entry, but it\u0027s required.\n         throw new AclException(\n           \"Invalid ACL: mask is required and cannot be deleted.\");\n       } else if (providedMask.containsKey(scope) \u0026\u0026\n           (!scopeDirty.contains(scope) || maskDirty.contains(scope))) {\n         // Caller explicitly provided new mask, or we are preserving the existing\n         // mask in an unchanged scope.\n         aclBuilder.add(providedMask.get(scope));\n       } else if (maskNeeded.contains(scope) || providedMask.containsKey(scope)) {\n         // Otherwise, if there are maskable entries present, or the ACL\n         // previously had a mask, then recalculate a mask automatically.\n         aclBuilder.add(new AclEntry.Builder()\n           .setScope(scope)\n           .setType(MASK)\n           .setPermission(unionPerms.get(scope))\n           .build());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void calculateMasks(List\u003cAclEntry\u003e aclBuilder,\n      EnumMap\u003cAclEntryScope, AclEntry\u003e providedMask,\n      EnumSet\u003cAclEntryScope\u003e maskDirty, EnumSet\u003cAclEntryScope\u003e scopeDirty)\n      throws AclException {\n    EnumSet\u003cAclEntryScope\u003e scopeFound \u003d EnumSet.noneOf(AclEntryScope.class);\n    EnumMap\u003cAclEntryScope, FsAction\u003e unionPerms \u003d\n      Maps.newEnumMap(AclEntryScope.class);\n    EnumSet\u003cAclEntryScope\u003e maskNeeded \u003d EnumSet.noneOf(AclEntryScope.class);\n    // Determine which scopes are present, which scopes need a mask, and the\n    // union of group class permissions in each scope.\n    for (AclEntry entry: aclBuilder) {\n      scopeFound.add(entry.getScope());\n      if (entry.getType() \u003d\u003d GROUP || entry.getName() !\u003d null) {\n        FsAction scopeUnionPerms \u003d unionPerms.get(entry.getScope());\n        if (scopeUnionPerms \u003d\u003d null) {\n          scopeUnionPerms \u003d FsAction.NONE;\n        }\n        unionPerms.put(entry.getScope(),\n          scopeUnionPerms.or(entry.getPermission()));\n      }\n      if (entry.getName() !\u003d null) {\n        maskNeeded.add(entry.getScope());\n      }\n    }\n    // Add mask entry if needed in each scope.\n    for (AclEntryScope scope: scopeFound) {\n      if (!providedMask.containsKey(scope) \u0026\u0026 maskNeeded.contains(scope) \u0026\u0026\n          maskDirty.contains(scope)) {\n        // Caller explicitly removed mask entry, but it\u0027s required.\n        throw new AclException(\n          \"Invalid ACL: mask is required and cannot be deleted.\");\n      } else if (providedMask.containsKey(scope) \u0026\u0026\n          (!scopeDirty.contains(scope) || maskDirty.contains(scope))) {\n        // Caller explicitly provided new mask, or we are preserving the existing\n        // mask in an unchanged scope.\n        aclBuilder.add(providedMask.get(scope));\n      } else if (maskNeeded.contains(scope) || providedMask.containsKey(scope)) {\n        // Otherwise, if there are maskable entries present, or the ACL\n        // previously had a mask, then recalculate a mask automatically.\n        aclBuilder.add(new AclEntry.Builder()\n          .setScope(scope)\n          .setType(MASK)\n          .setPermission(unionPerms.get(scope))\n          .build());\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclTransformation.java",
      "extendedDetails": {}
    },
    "84ddedc0b2d58257d45c16ee5e83b15f94a7ba3a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10101. Update guava dependency to the latest version. (ozawa)\n",
      "commitDate": "24/03/17 6:06 PM",
      "commitName": "84ddedc0b2d58257d45c16ee5e83b15f94a7ba3a",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "21/07/15 2:46 AM",
      "commitNameOld": "29cf887b226f4ab3c336a6e681db5e8e70699d66",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 612.64,
      "commitsBetweenForRepo": 4098,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n   private static void calculateMasks(List\u003cAclEntry\u003e aclBuilder,\n       EnumMap\u003cAclEntryScope, AclEntry\u003e providedMask,\n       EnumSet\u003cAclEntryScope\u003e maskDirty, EnumSet\u003cAclEntryScope\u003e scopeDirty)\n       throws AclException {\n     EnumSet\u003cAclEntryScope\u003e scopeFound \u003d EnumSet.noneOf(AclEntryScope.class);\n     EnumMap\u003cAclEntryScope, FsAction\u003e unionPerms \u003d\n       Maps.newEnumMap(AclEntryScope.class);\n     EnumSet\u003cAclEntryScope\u003e maskNeeded \u003d EnumSet.noneOf(AclEntryScope.class);\n     // Determine which scopes are present, which scopes need a mask, and the\n     // union of group class permissions in each scope.\n     for (AclEntry entry: aclBuilder) {\n       scopeFound.add(entry.getScope());\n       if (entry.getType() \u003d\u003d GROUP || entry.getName() !\u003d null) {\n-        FsAction scopeUnionPerms \u003d Objects.firstNonNull(\n+        FsAction scopeUnionPerms \u003d MoreObjects.firstNonNull(\n           unionPerms.get(entry.getScope()), FsAction.NONE);\n         unionPerms.put(entry.getScope(),\n           scopeUnionPerms.or(entry.getPermission()));\n       }\n       if (entry.getName() !\u003d null) {\n         maskNeeded.add(entry.getScope());\n       }\n     }\n     // Add mask entry if needed in each scope.\n     for (AclEntryScope scope: scopeFound) {\n       if (!providedMask.containsKey(scope) \u0026\u0026 maskNeeded.contains(scope) \u0026\u0026\n           maskDirty.contains(scope)) {\n         // Caller explicitly removed mask entry, but it\u0027s required.\n         throw new AclException(\n           \"Invalid ACL: mask is required and cannot be deleted.\");\n       } else if (providedMask.containsKey(scope) \u0026\u0026\n           (!scopeDirty.contains(scope) || maskDirty.contains(scope))) {\n         // Caller explicitly provided new mask, or we are preserving the existing\n         // mask in an unchanged scope.\n         aclBuilder.add(providedMask.get(scope));\n       } else if (maskNeeded.contains(scope) || providedMask.containsKey(scope)) {\n         // Otherwise, if there are maskable entries present, or the ACL\n         // previously had a mask, then recalculate a mask automatically.\n         aclBuilder.add(new AclEntry.Builder()\n           .setScope(scope)\n           .setType(MASK)\n           .setPermission(unionPerms.get(scope))\n           .build());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void calculateMasks(List\u003cAclEntry\u003e aclBuilder,\n      EnumMap\u003cAclEntryScope, AclEntry\u003e providedMask,\n      EnumSet\u003cAclEntryScope\u003e maskDirty, EnumSet\u003cAclEntryScope\u003e scopeDirty)\n      throws AclException {\n    EnumSet\u003cAclEntryScope\u003e scopeFound \u003d EnumSet.noneOf(AclEntryScope.class);\n    EnumMap\u003cAclEntryScope, FsAction\u003e unionPerms \u003d\n      Maps.newEnumMap(AclEntryScope.class);\n    EnumSet\u003cAclEntryScope\u003e maskNeeded \u003d EnumSet.noneOf(AclEntryScope.class);\n    // Determine which scopes are present, which scopes need a mask, and the\n    // union of group class permissions in each scope.\n    for (AclEntry entry: aclBuilder) {\n      scopeFound.add(entry.getScope());\n      if (entry.getType() \u003d\u003d GROUP || entry.getName() !\u003d null) {\n        FsAction scopeUnionPerms \u003d MoreObjects.firstNonNull(\n          unionPerms.get(entry.getScope()), FsAction.NONE);\n        unionPerms.put(entry.getScope(),\n          scopeUnionPerms.or(entry.getPermission()));\n      }\n      if (entry.getName() !\u003d null) {\n        maskNeeded.add(entry.getScope());\n      }\n    }\n    // Add mask entry if needed in each scope.\n    for (AclEntryScope scope: scopeFound) {\n      if (!providedMask.containsKey(scope) \u0026\u0026 maskNeeded.contains(scope) \u0026\u0026\n          maskDirty.contains(scope)) {\n        // Caller explicitly removed mask entry, but it\u0027s required.\n        throw new AclException(\n          \"Invalid ACL: mask is required and cannot be deleted.\");\n      } else if (providedMask.containsKey(scope) \u0026\u0026\n          (!scopeDirty.contains(scope) || maskDirty.contains(scope))) {\n        // Caller explicitly provided new mask, or we are preserving the existing\n        // mask in an unchanged scope.\n        aclBuilder.add(providedMask.get(scope));\n      } else if (maskNeeded.contains(scope) || providedMask.containsKey(scope)) {\n        // Otherwise, if there are maskable entries present, or the ACL\n        // previously had a mask, then recalculate a mask automatically.\n        aclBuilder.add(new AclEntry.Builder()\n          .setScope(scope)\n          .setType(MASK)\n          .setPermission(unionPerms.get(scope))\n          .build());\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclTransformation.java",
      "extendedDetails": {}
    },
    "1fe2bd55341297db698c2b4d03511cdff07c439c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6028. Print clearer error message when user attempts to delete required mask entry from ACL. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1572753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/02/14 2:12 PM",
      "commitName": "1fe2bd55341297db698c2b4d03511cdff07c439c",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "17/01/14 2:05 PM",
      "commitNameOld": "5300294fbe9e235ce42253d6bcd69d8154d8f198",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 41.0,
      "commitsBetweenForRepo": 316,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n   private static void calculateMasks(List\u003cAclEntry\u003e aclBuilder,\n       EnumMap\u003cAclEntryScope, AclEntry\u003e providedMask,\n       EnumSet\u003cAclEntryScope\u003e maskDirty, EnumSet\u003cAclEntryScope\u003e scopeDirty)\n       throws AclException {\n     EnumSet\u003cAclEntryScope\u003e scopeFound \u003d EnumSet.noneOf(AclEntryScope.class);\n     EnumMap\u003cAclEntryScope, FsAction\u003e unionPerms \u003d\n       Maps.newEnumMap(AclEntryScope.class);\n     EnumSet\u003cAclEntryScope\u003e maskNeeded \u003d EnumSet.noneOf(AclEntryScope.class);\n     // Determine which scopes are present, which scopes need a mask, and the\n     // union of group class permissions in each scope.\n     for (AclEntry entry: aclBuilder) {\n       scopeFound.add(entry.getScope());\n       if (entry.getType() \u003d\u003d GROUP || entry.getName() !\u003d null) {\n         FsAction scopeUnionPerms \u003d Objects.firstNonNull(\n           unionPerms.get(entry.getScope()), FsAction.NONE);\n         unionPerms.put(entry.getScope(),\n           scopeUnionPerms.or(entry.getPermission()));\n       }\n       if (entry.getName() !\u003d null) {\n         maskNeeded.add(entry.getScope());\n       }\n     }\n     // Add mask entry if needed in each scope.\n     for (AclEntryScope scope: scopeFound) {\n       if (!providedMask.containsKey(scope) \u0026\u0026 maskNeeded.contains(scope) \u0026\u0026\n           maskDirty.contains(scope)) {\n         // Caller explicitly removed mask entry, but it\u0027s required.\n         throw new AclException(\n-          \"Invalid ACL: mask is required, but it was deleted.\");\n+          \"Invalid ACL: mask is required and cannot be deleted.\");\n       } else if (providedMask.containsKey(scope) \u0026\u0026\n           (!scopeDirty.contains(scope) || maskDirty.contains(scope))) {\n         // Caller explicitly provided new mask, or we are preserving the existing\n         // mask in an unchanged scope.\n         aclBuilder.add(providedMask.get(scope));\n       } else if (maskNeeded.contains(scope) || providedMask.containsKey(scope)) {\n         // Otherwise, if there are maskable entries present, or the ACL\n         // previously had a mask, then recalculate a mask automatically.\n         aclBuilder.add(new AclEntry.Builder()\n           .setScope(scope)\n           .setType(MASK)\n           .setPermission(unionPerms.get(scope))\n           .build());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void calculateMasks(List\u003cAclEntry\u003e aclBuilder,\n      EnumMap\u003cAclEntryScope, AclEntry\u003e providedMask,\n      EnumSet\u003cAclEntryScope\u003e maskDirty, EnumSet\u003cAclEntryScope\u003e scopeDirty)\n      throws AclException {\n    EnumSet\u003cAclEntryScope\u003e scopeFound \u003d EnumSet.noneOf(AclEntryScope.class);\n    EnumMap\u003cAclEntryScope, FsAction\u003e unionPerms \u003d\n      Maps.newEnumMap(AclEntryScope.class);\n    EnumSet\u003cAclEntryScope\u003e maskNeeded \u003d EnumSet.noneOf(AclEntryScope.class);\n    // Determine which scopes are present, which scopes need a mask, and the\n    // union of group class permissions in each scope.\n    for (AclEntry entry: aclBuilder) {\n      scopeFound.add(entry.getScope());\n      if (entry.getType() \u003d\u003d GROUP || entry.getName() !\u003d null) {\n        FsAction scopeUnionPerms \u003d Objects.firstNonNull(\n          unionPerms.get(entry.getScope()), FsAction.NONE);\n        unionPerms.put(entry.getScope(),\n          scopeUnionPerms.or(entry.getPermission()));\n      }\n      if (entry.getName() !\u003d null) {\n        maskNeeded.add(entry.getScope());\n      }\n    }\n    // Add mask entry if needed in each scope.\n    for (AclEntryScope scope: scopeFound) {\n      if (!providedMask.containsKey(scope) \u0026\u0026 maskNeeded.contains(scope) \u0026\u0026\n          maskDirty.contains(scope)) {\n        // Caller explicitly removed mask entry, but it\u0027s required.\n        throw new AclException(\n          \"Invalid ACL: mask is required and cannot be deleted.\");\n      } else if (providedMask.containsKey(scope) \u0026\u0026\n          (!scopeDirty.contains(scope) || maskDirty.contains(scope))) {\n        // Caller explicitly provided new mask, or we are preserving the existing\n        // mask in an unchanged scope.\n        aclBuilder.add(providedMask.get(scope));\n      } else if (maskNeeded.contains(scope) || providedMask.containsKey(scope)) {\n        // Otherwise, if there are maskable entries present, or the ACL\n        // previously had a mask, then recalculate a mask automatically.\n        aclBuilder.add(new AclEntry.Builder()\n          .setScope(scope)\n          .setType(MASK)\n          .setPermission(unionPerms.get(scope))\n          .build());\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclTransformation.java",
      "extendedDetails": {}
    },
    "5300294fbe9e235ce42253d6bcd69d8154d8f198": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5758. NameNode: complete implementation of inode modifications for ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1559267 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/01/14 2:05 PM",
      "commitName": "5300294fbe9e235ce42253d6bcd69d8154d8f198",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "08/01/14 2:02 PM",
      "commitNameOld": "023c11ec7eae9bb21598f3d3ad0cd5b07b2b737e",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 9.0,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,45 @@\n   private static void calculateMasks(List\u003cAclEntry\u003e aclBuilder,\n       EnumMap\u003cAclEntryScope, AclEntry\u003e providedMask,\n       EnumSet\u003cAclEntryScope\u003e maskDirty, EnumSet\u003cAclEntryScope\u003e scopeDirty)\n       throws AclException {\n     EnumSet\u003cAclEntryScope\u003e scopeFound \u003d EnumSet.noneOf(AclEntryScope.class);\n     EnumMap\u003cAclEntryScope, FsAction\u003e unionPerms \u003d\n       Maps.newEnumMap(AclEntryScope.class);\n     EnumSet\u003cAclEntryScope\u003e maskNeeded \u003d EnumSet.noneOf(AclEntryScope.class);\n     // Determine which scopes are present, which scopes need a mask, and the\n     // union of group class permissions in each scope.\n     for (AclEntry entry: aclBuilder) {\n       scopeFound.add(entry.getScope());\n       if (entry.getType() \u003d\u003d GROUP || entry.getName() !\u003d null) {\n         FsAction scopeUnionPerms \u003d Objects.firstNonNull(\n           unionPerms.get(entry.getScope()), FsAction.NONE);\n         unionPerms.put(entry.getScope(),\n           scopeUnionPerms.or(entry.getPermission()));\n       }\n       if (entry.getName() !\u003d null) {\n         maskNeeded.add(entry.getScope());\n       }\n     }\n     // Add mask entry if needed in each scope.\n     for (AclEntryScope scope: scopeFound) {\n       if (!providedMask.containsKey(scope) \u0026\u0026 maskNeeded.contains(scope) \u0026\u0026\n           maskDirty.contains(scope)) {\n+        // Caller explicitly removed mask entry, but it\u0027s required.\n         throw new AclException(\n           \"Invalid ACL: mask is required, but it was deleted.\");\n       } else if (providedMask.containsKey(scope) \u0026\u0026\n           (!scopeDirty.contains(scope) || maskDirty.contains(scope))) {\n+        // Caller explicitly provided new mask, or we are preserving the existing\n+        // mask in an unchanged scope.\n         aclBuilder.add(providedMask.get(scope));\n-      } else if (maskNeeded.contains(scope)) {\n+      } else if (maskNeeded.contains(scope) || providedMask.containsKey(scope)) {\n+        // Otherwise, if there are maskable entries present, or the ACL\n+        // previously had a mask, then recalculate a mask automatically.\n         aclBuilder.add(new AclEntry.Builder()\n           .setScope(scope)\n           .setType(MASK)\n           .setPermission(unionPerms.get(scope))\n           .build());\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static void calculateMasks(List\u003cAclEntry\u003e aclBuilder,\n      EnumMap\u003cAclEntryScope, AclEntry\u003e providedMask,\n      EnumSet\u003cAclEntryScope\u003e maskDirty, EnumSet\u003cAclEntryScope\u003e scopeDirty)\n      throws AclException {\n    EnumSet\u003cAclEntryScope\u003e scopeFound \u003d EnumSet.noneOf(AclEntryScope.class);\n    EnumMap\u003cAclEntryScope, FsAction\u003e unionPerms \u003d\n      Maps.newEnumMap(AclEntryScope.class);\n    EnumSet\u003cAclEntryScope\u003e maskNeeded \u003d EnumSet.noneOf(AclEntryScope.class);\n    // Determine which scopes are present, which scopes need a mask, and the\n    // union of group class permissions in each scope.\n    for (AclEntry entry: aclBuilder) {\n      scopeFound.add(entry.getScope());\n      if (entry.getType() \u003d\u003d GROUP || entry.getName() !\u003d null) {\n        FsAction scopeUnionPerms \u003d Objects.firstNonNull(\n          unionPerms.get(entry.getScope()), FsAction.NONE);\n        unionPerms.put(entry.getScope(),\n          scopeUnionPerms.or(entry.getPermission()));\n      }\n      if (entry.getName() !\u003d null) {\n        maskNeeded.add(entry.getScope());\n      }\n    }\n    // Add mask entry if needed in each scope.\n    for (AclEntryScope scope: scopeFound) {\n      if (!providedMask.containsKey(scope) \u0026\u0026 maskNeeded.contains(scope) \u0026\u0026\n          maskDirty.contains(scope)) {\n        // Caller explicitly removed mask entry, but it\u0027s required.\n        throw new AclException(\n          \"Invalid ACL: mask is required, but it was deleted.\");\n      } else if (providedMask.containsKey(scope) \u0026\u0026\n          (!scopeDirty.contains(scope) || maskDirty.contains(scope))) {\n        // Caller explicitly provided new mask, or we are preserving the existing\n        // mask in an unchanged scope.\n        aclBuilder.add(providedMask.get(scope));\n      } else if (maskNeeded.contains(scope) || providedMask.containsKey(scope)) {\n        // Otherwise, if there are maskable entries present, or the ACL\n        // previously had a mask, then recalculate a mask automatically.\n        aclBuilder.add(new AclEntry.Builder()\n          .setScope(scope)\n          .setType(MASK)\n          .setPermission(unionPerms.get(scope))\n          .build());\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclTransformation.java",
      "extendedDetails": {}
    },
    "c6585675710aa800317ad35e6fdf95c50c559d68": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5673. Implement logic for modification of ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1556090 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/01/14 4:47 PM",
      "commitName": "c6585675710aa800317ad35e6fdf95c50c559d68",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,40 @@\n+  private static void calculateMasks(List\u003cAclEntry\u003e aclBuilder,\n+      EnumMap\u003cAclEntryScope, AclEntry\u003e providedMask,\n+      EnumSet\u003cAclEntryScope\u003e maskDirty, EnumSet\u003cAclEntryScope\u003e scopeDirty)\n+      throws AclException {\n+    EnumSet\u003cAclEntryScope\u003e scopeFound \u003d EnumSet.noneOf(AclEntryScope.class);\n+    EnumMap\u003cAclEntryScope, FsAction\u003e unionPerms \u003d\n+      Maps.newEnumMap(AclEntryScope.class);\n+    EnumSet\u003cAclEntryScope\u003e maskNeeded \u003d EnumSet.noneOf(AclEntryScope.class);\n+    // Determine which scopes are present, which scopes need a mask, and the\n+    // union of group class permissions in each scope.\n+    for (AclEntry entry: aclBuilder) {\n+      scopeFound.add(entry.getScope());\n+      if (entry.getType() \u003d\u003d GROUP || entry.getName() !\u003d null) {\n+        FsAction scopeUnionPerms \u003d Objects.firstNonNull(\n+          unionPerms.get(entry.getScope()), FsAction.NONE);\n+        unionPerms.put(entry.getScope(),\n+          scopeUnionPerms.or(entry.getPermission()));\n+      }\n+      if (entry.getName() !\u003d null) {\n+        maskNeeded.add(entry.getScope());\n+      }\n+    }\n+    // Add mask entry if needed in each scope.\n+    for (AclEntryScope scope: scopeFound) {\n+      if (!providedMask.containsKey(scope) \u0026\u0026 maskNeeded.contains(scope) \u0026\u0026\n+          maskDirty.contains(scope)) {\n+        throw new AclException(\n+          \"Invalid ACL: mask is required, but it was deleted.\");\n+      } else if (providedMask.containsKey(scope) \u0026\u0026\n+          (!scopeDirty.contains(scope) || maskDirty.contains(scope))) {\n+        aclBuilder.add(providedMask.get(scope));\n+      } else if (maskNeeded.contains(scope)) {\n+        aclBuilder.add(new AclEntry.Builder()\n+          .setScope(scope)\n+          .setType(MASK)\n+          .setPermission(unionPerms.get(scope))\n+          .build());\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static void calculateMasks(List\u003cAclEntry\u003e aclBuilder,\n      EnumMap\u003cAclEntryScope, AclEntry\u003e providedMask,\n      EnumSet\u003cAclEntryScope\u003e maskDirty, EnumSet\u003cAclEntryScope\u003e scopeDirty)\n      throws AclException {\n    EnumSet\u003cAclEntryScope\u003e scopeFound \u003d EnumSet.noneOf(AclEntryScope.class);\n    EnumMap\u003cAclEntryScope, FsAction\u003e unionPerms \u003d\n      Maps.newEnumMap(AclEntryScope.class);\n    EnumSet\u003cAclEntryScope\u003e maskNeeded \u003d EnumSet.noneOf(AclEntryScope.class);\n    // Determine which scopes are present, which scopes need a mask, and the\n    // union of group class permissions in each scope.\n    for (AclEntry entry: aclBuilder) {\n      scopeFound.add(entry.getScope());\n      if (entry.getType() \u003d\u003d GROUP || entry.getName() !\u003d null) {\n        FsAction scopeUnionPerms \u003d Objects.firstNonNull(\n          unionPerms.get(entry.getScope()), FsAction.NONE);\n        unionPerms.put(entry.getScope(),\n          scopeUnionPerms.or(entry.getPermission()));\n      }\n      if (entry.getName() !\u003d null) {\n        maskNeeded.add(entry.getScope());\n      }\n    }\n    // Add mask entry if needed in each scope.\n    for (AclEntryScope scope: scopeFound) {\n      if (!providedMask.containsKey(scope) \u0026\u0026 maskNeeded.contains(scope) \u0026\u0026\n          maskDirty.contains(scope)) {\n        throw new AclException(\n          \"Invalid ACL: mask is required, but it was deleted.\");\n      } else if (providedMask.containsKey(scope) \u0026\u0026\n          (!scopeDirty.contains(scope) || maskDirty.contains(scope))) {\n        aclBuilder.add(providedMask.get(scope));\n      } else if (maskNeeded.contains(scope)) {\n        aclBuilder.add(new AclEntry.Builder()\n          .setScope(scope)\n          .setType(MASK)\n          .setPermission(unionPerms.get(scope))\n          .build());\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclTransformation.java"
    }
  }
}