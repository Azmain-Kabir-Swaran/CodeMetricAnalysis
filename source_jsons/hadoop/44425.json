{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Client.java",
  "functionName": "init",
  "functionId": "init___args-String[]",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
  "functionStartLine": 434,
  "functionEndLine": 661,
  "numCommitsSeen": 83,
  "timeTaken": 8795,
  "changeHistory": [
    "649666e118a7cf92b676eaa56a8be318176c443e",
    "f738b397ae021c9be900e4ec51ab55cd69b075e0",
    "fb55e5201e5b2ff40e1b757a9c5bf23c5d8aec93",
    "431076f63751f855ab6036ff85825a8552257b93",
    "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde",
    "eb2449d5398e9ac869bc088e10d838a7f13deac0",
    "e60f51299dba360d13aa39f9ab714fdfc666b532",
    "01f3f2167ec20b52a18bc2cf250fb4229cfd2c14",
    "928964102029e96406f5482e8900802f38164501",
    "40b0045ebe0752cd3d1d09be00acbabdea983799",
    "7805deed4896e470ebd2f6bbd1ba9962947c63cd",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "22e7ae57715cedb1dcba736e357e8daaf5133e5c",
    "47f35a30bb4d99349593e9d6e1c9e76e71341c40",
    "d67c9bdb4db2b075484a779802ecf3296bad5cd4",
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
    "9bdb5bebea1183ec2f697ee3e55392df4fe697bb",
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
    "f6b963fdfc517429149165e4bb6fb947be6e3c99",
    "1d4612f5ad9678c952b416e798dccd20c88f96ef",
    "8e5d6713cf16473d791c028cecc274fd2c7fd10b",
    "aa0c489a28dbbe8fae0be6a48edb122537784b1d",
    "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f",
    "c4bdddeab56287c8a8ae314fac238cbbc6c1bcf4",
    "33a8234040959ecd0d0202162e1b18c990effabe",
    "735d8b27f78ea8be839008650a3e88db37dc507d",
    "bca57d471f4cc67bd5b73589cb941e868e0ca840",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "db31b6c0e4aa1f6cd2d655a48195fdfb76bc5329",
    "daa28cc6ce23ef5c8db8b9f896f342cb770dd092",
    "fad230a49d0d4cdbb2062b10c3dea6c755737db5"
  ],
  "changeHistoryShort": {
    "649666e118a7cf92b676eaa56a8be318176c443e": "Ybodychange",
    "f738b397ae021c9be900e4ec51ab55cd69b075e0": "Ybodychange",
    "fb55e5201e5b2ff40e1b757a9c5bf23c5d8aec93": "Ybodychange",
    "431076f63751f855ab6036ff85825a8552257b93": "Ybodychange",
    "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde": "Ybodychange",
    "eb2449d5398e9ac869bc088e10d838a7f13deac0": "Ybodychange",
    "e60f51299dba360d13aa39f9ab714fdfc666b532": "Ybodychange",
    "01f3f2167ec20b52a18bc2cf250fb4229cfd2c14": "Ybodychange",
    "928964102029e96406f5482e8900802f38164501": "Ybodychange",
    "40b0045ebe0752cd3d1d09be00acbabdea983799": "Ybodychange",
    "7805deed4896e470ebd2f6bbd1ba9962947c63cd": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "22e7ae57715cedb1dcba736e357e8daaf5133e5c": "Ybodychange",
    "47f35a30bb4d99349593e9d6e1c9e76e71341c40": "Ybodychange",
    "d67c9bdb4db2b075484a779802ecf3296bad5cd4": "Ybodychange",
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c": "Ybodychange",
    "9bdb5bebea1183ec2f697ee3e55392df4fe697bb": "Ybodychange",
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f": "Ybodychange",
    "f6b963fdfc517429149165e4bb6fb947be6e3c99": "Ybodychange",
    "1d4612f5ad9678c952b416e798dccd20c88f96ef": "Ybodychange",
    "8e5d6713cf16473d791c028cecc274fd2c7fd10b": "Ybodychange",
    "aa0c489a28dbbe8fae0be6a48edb122537784b1d": "Ybodychange",
    "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f": "Ybodychange",
    "c4bdddeab56287c8a8ae314fac238cbbc6c1bcf4": "Ybodychange",
    "33a8234040959ecd0d0202162e1b18c990effabe": "Ybodychange",
    "735d8b27f78ea8be839008650a3e88db37dc507d": "Ybodychange",
    "bca57d471f4cc67bd5b73589cb941e868e0ca840": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "db31b6c0e4aa1f6cd2d655a48195fdfb76bc5329": "Ybodychange",
    "daa28cc6ce23ef5c8db8b9f896f342cb770dd092": "Ybodychange",
    "fad230a49d0d4cdbb2062b10c3dea6c755737db5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "649666e118a7cf92b676eaa56a8be318176c443e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9573. DistributedShell cannot specify LogAggregationContext. Contributed by Adam Antal.\n",
      "commitDate": "06/06/19 2:21 AM",
      "commitName": "649666e118a7cf92b676eaa56a8be318176c443e",
      "commitAuthor": "Sunil G",
      "commitDateOld": "30/05/19 10:02 AM",
      "commitNameOld": "30c6dd92e1d4075d143adc891dc8ec536dddc0d9",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 6.68,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,224 +1,228 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n+    if (cliParser.hasOption(\"rolling_log_pattern\")) {\n+      rollingFilesPattern \u003d cliParser.getOptionValue(\"rolling_log_pattern\");\n+    }\n+\n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     if (cliParser.hasOption(\"placement_spec\")) {\n       placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n       // Check if it is parsable\n       PlacementSpec.parse(this.placementSpec);\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n     amVCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"master_resources\")) {\n       Map\u003cString, Long\u003e masterResources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           amMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           amVCores \u003d entry.getValue().intValue();\n         } else {\n           amResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n-    }\t\t\n+    }\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n           .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     if (cliParser.hasOption(\"enforce_execution_type\")) {\n       enforceExecType \u003d true;\n     }\n     containerMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n     containerVirtualCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           containerMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           containerVirtualCores \u003d entry.getValue().intValue();\n         } else {\n           containerResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numContainers \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n           + \" exiting. Specified numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n     if (cliParser.hasOption(\"container_failures_validity_interval\")) {\n       containerRetryOptions.add(\"--container_failures_validity_interval \"\n           + cliParser.getOptionValue(\"container_failures_validity_interval\"));\n     }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n         flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n     if (cliParser.hasOption(\"docker_client_config\")) {\n       dockerClientConfig \u003d cliParser.getOptionValue(\"docker_client_config\");\n     }\n \n     if (cliParser.hasOption(\"application_tags\")) {\n       String applicationTagsStr \u003d cliParser.getOptionValue(\"application_tags\");\n       String[] appTags \u003d applicationTagsStr.split(\",\");\n       for (String appTag : appTags) {\n         this.applicationTags.add(appTag.trim());\n       }\n     }\n \n     if (cliParser.hasOption(\"localize_files\")) {\n       String filesStr \u003d cliParser.getOptionValue(\"localize_files\");\n       if (filesStr.contains(\",\")) {\n         String[] files \u003d filesStr.split(\",\");\n         filesToLocalize \u003d Arrays.asList(files);\n       } else {\n         filesToLocalize.add(filesStr);\n       }\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"rolling_log_pattern\")) {\n      rollingFilesPattern \u003d cliParser.getOptionValue(\"rolling_log_pattern\");\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      // Check if it is parsable\n      PlacementSpec.parse(this.placementSpec);\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n    amVCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"master_resources\")) {\n      Map\u003cString, Long\u003e masterResources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          amMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          amVCores \u003d entry.getValue().intValue();\n        } else {\n          amResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n          .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    if (cliParser.hasOption(\"enforce_execution_type\")) {\n      enforceExecType \u003d true;\n    }\n    containerMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n    containerVirtualCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          containerMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          containerVirtualCores \u003d entry.getValue().intValue();\n        } else {\n          containerResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numContainers \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n          + \" exiting. Specified numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n    if (cliParser.hasOption(\"container_failures_validity_interval\")) {\n      containerRetryOptions.add(\"--container_failures_validity_interval \"\n          + cliParser.getOptionValue(\"container_failures_validity_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    if (cliParser.hasOption(\"docker_client_config\")) {\n      dockerClientConfig \u003d cliParser.getOptionValue(\"docker_client_config\");\n    }\n\n    if (cliParser.hasOption(\"application_tags\")) {\n      String applicationTagsStr \u003d cliParser.getOptionValue(\"application_tags\");\n      String[] appTags \u003d applicationTagsStr.split(\",\");\n      for (String appTag : appTags) {\n        this.applicationTags.add(appTag.trim());\n      }\n    }\n\n    if (cliParser.hasOption(\"localize_files\")) {\n      String filesStr \u003d cliParser.getOptionValue(\"localize_files\");\n      if (filesStr.contains(\",\")) {\n        String[] files \u003d filesStr.split(\",\");\n        filesToLocalize \u003d Arrays.asList(files);\n      } else {\n        filesToLocalize.add(filesStr);\n      }\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "f738b397ae021c9be900e4ec51ab55cd69b075e0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9191. Add cli option in DS to support enforceExecutionType in resource requests. Contributed by Abhishek Modi.\n",
      "commitDate": "31/01/19 11:24 AM",
      "commitName": "f738b397ae021c9be900e4ec51ab55cd69b075e0",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "11/12/18 2:13 PM",
      "commitNameOld": "fb55e5201e5b2ff40e1b757a9c5bf23c5d8aec93",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 50.88,
      "commitsBetweenForRepo": 338,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,221 +1,224 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     if (cliParser.hasOption(\"placement_spec\")) {\n       placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n       // Check if it is parsable\n       PlacementSpec.parse(this.placementSpec);\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n     amVCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"master_resources\")) {\n       Map\u003cString, Long\u003e masterResources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           amMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           amVCores \u003d entry.getValue().intValue();\n         } else {\n           amResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n           .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n+    if (cliParser.hasOption(\"enforce_execution_type\")) {\n+      enforceExecType \u003d true;\n+    }\n     containerMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n     containerVirtualCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           containerMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           containerVirtualCores \u003d entry.getValue().intValue();\n         } else {\n           containerResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numContainers \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n           + \" exiting. Specified numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n     if (cliParser.hasOption(\"container_failures_validity_interval\")) {\n       containerRetryOptions.add(\"--container_failures_validity_interval \"\n           + cliParser.getOptionValue(\"container_failures_validity_interval\"));\n     }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n         flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n     if (cliParser.hasOption(\"docker_client_config\")) {\n       dockerClientConfig \u003d cliParser.getOptionValue(\"docker_client_config\");\n     }\n \n     if (cliParser.hasOption(\"application_tags\")) {\n       String applicationTagsStr \u003d cliParser.getOptionValue(\"application_tags\");\n       String[] appTags \u003d applicationTagsStr.split(\",\");\n       for (String appTag : appTags) {\n         this.applicationTags.add(appTag.trim());\n       }\n     }\n \n     if (cliParser.hasOption(\"localize_files\")) {\n       String filesStr \u003d cliParser.getOptionValue(\"localize_files\");\n       if (filesStr.contains(\",\")) {\n         String[] files \u003d filesStr.split(\",\");\n         filesToLocalize \u003d Arrays.asList(files);\n       } else {\n         filesToLocalize.add(filesStr);\n       }\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      // Check if it is parsable\n      PlacementSpec.parse(this.placementSpec);\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n    amVCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"master_resources\")) {\n      Map\u003cString, Long\u003e masterResources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          amMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          amVCores \u003d entry.getValue().intValue();\n        } else {\n          amResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n          .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    if (cliParser.hasOption(\"enforce_execution_type\")) {\n      enforceExecType \u003d true;\n    }\n    containerMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n    containerVirtualCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          containerMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          containerVirtualCores \u003d entry.getValue().intValue();\n        } else {\n          containerResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numContainers \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n          + \" exiting. Specified numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n    if (cliParser.hasOption(\"container_failures_validity_interval\")) {\n      containerRetryOptions.add(\"--container_failures_validity_interval \"\n          + cliParser.getOptionValue(\"container_failures_validity_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    if (cliParser.hasOption(\"docker_client_config\")) {\n      dockerClientConfig \u003d cliParser.getOptionValue(\"docker_client_config\");\n    }\n\n    if (cliParser.hasOption(\"application_tags\")) {\n      String applicationTagsStr \u003d cliParser.getOptionValue(\"application_tags\");\n      String[] appTags \u003d applicationTagsStr.split(\",\");\n      for (String appTag : appTags) {\n        this.applicationTags.add(appTag.trim());\n      }\n    }\n\n    if (cliParser.hasOption(\"localize_files\")) {\n      String filesStr \u003d cliParser.getOptionValue(\"localize_files\");\n      if (filesStr.contains(\",\")) {\n        String[] files \u003d filesStr.split(\",\");\n        filesToLocalize \u003d Arrays.asList(files);\n      } else {\n        filesToLocalize.add(filesStr);\n      }\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "fb55e5201e5b2ff40e1b757a9c5bf23c5d8aec93": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9008. Extend YARN distributed shell with file localization feature. (Contributed by Peter Bacsko)\n",
      "commitDate": "11/12/18 2:13 PM",
      "commitName": "fb55e5201e5b2ff40e1b757a9c5bf23c5d8aec93",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 90.49,
      "commitsBetweenForRepo": 785,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,210 +1,221 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     if (cliParser.hasOption(\"placement_spec\")) {\n       placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n       // Check if it is parsable\n       PlacementSpec.parse(this.placementSpec);\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n     amVCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"master_resources\")) {\n       Map\u003cString, Long\u003e masterResources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           amMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           amVCores \u003d entry.getValue().intValue();\n         } else {\n           amResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n           .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n     containerVirtualCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           containerMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           containerVirtualCores \u003d entry.getValue().intValue();\n         } else {\n           containerResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numContainers \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n           + \" exiting. Specified numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n     if (cliParser.hasOption(\"container_failures_validity_interval\")) {\n       containerRetryOptions.add(\"--container_failures_validity_interval \"\n           + cliParser.getOptionValue(\"container_failures_validity_interval\"));\n     }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n         flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n     if (cliParser.hasOption(\"docker_client_config\")) {\n       dockerClientConfig \u003d cliParser.getOptionValue(\"docker_client_config\");\n     }\n \n     if (cliParser.hasOption(\"application_tags\")) {\n       String applicationTagsStr \u003d cliParser.getOptionValue(\"application_tags\");\n       String[] appTags \u003d applicationTagsStr.split(\",\");\n       for (String appTag : appTags) {\n         this.applicationTags.add(appTag.trim());\n       }\n     }\n+\n+    if (cliParser.hasOption(\"localize_files\")) {\n+      String filesStr \u003d cliParser.getOptionValue(\"localize_files\");\n+      if (filesStr.contains(\",\")) {\n+        String[] files \u003d filesStr.split(\",\");\n+        filesToLocalize \u003d Arrays.asList(files);\n+      } else {\n+        filesToLocalize.add(filesStr);\n+      }\n+    }\n+\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      // Check if it is parsable\n      PlacementSpec.parse(this.placementSpec);\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n    amVCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"master_resources\")) {\n      Map\u003cString, Long\u003e masterResources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          amMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          amVCores \u003d entry.getValue().intValue();\n        } else {\n          amResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n          .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n    containerVirtualCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          containerMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          containerVirtualCores \u003d entry.getValue().intValue();\n        } else {\n          containerResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numContainers \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n          + \" exiting. Specified numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n    if (cliParser.hasOption(\"container_failures_validity_interval\")) {\n      containerRetryOptions.add(\"--container_failures_validity_interval \"\n          + cliParser.getOptionValue(\"container_failures_validity_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    if (cliParser.hasOption(\"docker_client_config\")) {\n      dockerClientConfig \u003d cliParser.getOptionValue(\"docker_client_config\");\n    }\n\n    if (cliParser.hasOption(\"application_tags\")) {\n      String applicationTagsStr \u003d cliParser.getOptionValue(\"application_tags\");\n      String[] appTags \u003d applicationTagsStr.split(\",\");\n      for (String appTag : appTags) {\n        this.applicationTags.add(appTag.trim());\n      }\n    }\n\n    if (cliParser.hasOption(\"localize_files\")) {\n      String filesStr \u003d cliParser.getOptionValue(\"localize_files\");\n      if (filesStr.contains(\",\")) {\n        String[] files \u003d filesStr.split(\",\");\n        filesToLocalize \u003d Arrays.asList(files);\n      } else {\n        filesToLocalize.add(filesStr);\n      }\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "431076f63751f855ab6036ff85825a8552257b93": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8076. Support to specify application tags in distributed shell. Contributed by Weiwei Yang.\n",
      "commitDate": "29/03/18 3:25 AM",
      "commitName": "431076f63751f855ab6036ff85825a8552257b93",
      "commitAuthor": "Sunil G",
      "commitDateOld": "13/03/18 5:55 PM",
      "commitNameOld": "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 15.4,
      "commitsBetweenForRepo": 234,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,201 +1,209 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     if (cliParser.hasOption(\"placement_spec\")) {\n       placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n       // Check if it is parsable\n       PlacementSpec.parse(this.placementSpec);\n     }\n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n     amVCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"master_resources\")) {\n       Map\u003cString, Long\u003e masterResources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           amMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           amVCores \u003d entry.getValue().intValue();\n         } else {\n           amResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n           .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n     containerVirtualCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           containerMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           containerVirtualCores \u003d entry.getValue().intValue();\n         } else {\n           containerResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numContainers \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n           + \" exiting. Specified numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n     if (cliParser.hasOption(\"container_failures_validity_interval\")) {\n       containerRetryOptions.add(\"--container_failures_validity_interval \"\n           + cliParser.getOptionValue(\"container_failures_validity_interval\"));\n     }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n         flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n     if (cliParser.hasOption(\"docker_client_config\")) {\n       dockerClientConfig \u003d cliParser.getOptionValue(\"docker_client_config\");\n     }\n+\n+    if (cliParser.hasOption(\"application_tags\")) {\n+      String applicationTagsStr \u003d cliParser.getOptionValue(\"application_tags\");\n+      String[] appTags \u003d applicationTagsStr.split(\",\");\n+      for (String appTag : appTags) {\n+        this.applicationTags.add(appTag.trim());\n+      }\n+    }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      // Check if it is parsable\n      PlacementSpec.parse(this.placementSpec);\n    }\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n    amVCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"master_resources\")) {\n      Map\u003cString, Long\u003e masterResources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          amMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          amVCores \u003d entry.getValue().intValue();\n        } else {\n          amResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n          .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n    containerVirtualCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          containerMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          containerVirtualCores \u003d entry.getValue().intValue();\n        } else {\n          containerResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numContainers \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n          + \" exiting. Specified numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n    if (cliParser.hasOption(\"container_failures_validity_interval\")) {\n      containerRetryOptions.add(\"--container_failures_validity_interval \"\n          + cliParser.getOptionValue(\"container_failures_validity_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    if (cliParser.hasOption(\"docker_client_config\")) {\n      dockerClientConfig \u003d cliParser.getOptionValue(\"docker_client_config\");\n    }\n\n    if (cliParser.hasOption(\"application_tags\")) {\n      String applicationTagsStr \u003d cliParser.getOptionValue(\"application_tags\");\n      String[] appTags \u003d applicationTagsStr.split(\",\");\n      for (String appTag : appTags) {\n        this.applicationTags.add(appTag.trim());\n      }\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5015. Support sliding window retry capability for container restart. (Chandni Singh via wangda)\n\nChange-Id: I07addd3e4ba8d98456ee2ff1d5c540a38fe61dea\n",
      "commitDate": "13/03/18 5:55 PM",
      "commitName": "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "15/02/18 11:07 PM",
      "commitNameOld": "aae629913cee0157c945a2c7384c7bf398f10616",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 25.74,
      "commitsBetweenForRepo": 178,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,197 +1,201 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     if (cliParser.hasOption(\"placement_spec\")) {\n       placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n       // Check if it is parsable\n       PlacementSpec.parse(this.placementSpec);\n     }\n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n     amVCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"master_resources\")) {\n       Map\u003cString, Long\u003e masterResources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           amMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           amVCores \u003d entry.getValue().intValue();\n         } else {\n           amResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n           .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n     containerVirtualCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           containerMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           containerVirtualCores \u003d entry.getValue().intValue();\n         } else {\n           containerResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numContainers \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n           + \" exiting. Specified numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n+    if (cliParser.hasOption(\"container_failures_validity_interval\")) {\n+      containerRetryOptions.add(\"--container_failures_validity_interval \"\n+          + cliParser.getOptionValue(\"container_failures_validity_interval\"));\n+    }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n         flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n     if (cliParser.hasOption(\"docker_client_config\")) {\n       dockerClientConfig \u003d cliParser.getOptionValue(\"docker_client_config\");\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      // Check if it is parsable\n      PlacementSpec.parse(this.placementSpec);\n    }\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n    amVCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"master_resources\")) {\n      Map\u003cString, Long\u003e masterResources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          amMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          amVCores \u003d entry.getValue().intValue();\n        } else {\n          amResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n          .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n    containerVirtualCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          containerMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          containerVirtualCores \u003d entry.getValue().intValue();\n        } else {\n          containerResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numContainers \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n          + \" exiting. Specified numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n    if (cliParser.hasOption(\"container_failures_validity_interval\")) {\n      containerRetryOptions.add(\"--container_failures_validity_interval \"\n          + cliParser.getOptionValue(\"container_failures_validity_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    if (cliParser.hasOption(\"docker_client_config\")) {\n      dockerClientConfig \u003d cliParser.getOptionValue(\"docker_client_config\");\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "eb2449d5398e9ac869bc088e10d838a7f13deac0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5428. Allow for specifying the docker client configuration directory. Contributed by Shane Kumpf\n",
      "commitDate": "08/02/18 11:35 AM",
      "commitName": "eb2449d5398e9ac869bc088e10d838a7f13deac0",
      "commitAuthor": "Jian He",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "e60f51299dba360d13aa39f9ab714fdfc666b532",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 8.42,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,194 +1,197 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     if (cliParser.hasOption(\"placement_spec\")) {\n       placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n       // Check if it is parsable\n       PlacementSpec.parse(this.placementSpec);\n     }\n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n     amVCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"master_resources\")) {\n       Map\u003cString, Long\u003e masterResources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           amMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           amVCores \u003d entry.getValue().intValue();\n         } else {\n           amResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n           .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n     containerVirtualCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           containerMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           containerVirtualCores \u003d entry.getValue().intValue();\n         } else {\n           containerResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numContainers \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n           + \" exiting. Specified numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n         flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n+    if (cliParser.hasOption(\"docker_client_config\")) {\n+      dockerClientConfig \u003d cliParser.getOptionValue(\"docker_client_config\");\n+    }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      // Check if it is parsable\n      PlacementSpec.parse(this.placementSpec);\n    }\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n    amVCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"master_resources\")) {\n      Map\u003cString, Long\u003e masterResources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          amMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          amVCores \u003d entry.getValue().intValue();\n        } else {\n          amResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n          .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n    containerVirtualCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          containerMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          containerVirtualCores \u003d entry.getValue().intValue();\n        } else {\n          containerResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numContainers \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n          + \" exiting. Specified numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    if (cliParser.hasOption(\"docker_client_config\")) {\n      dockerClientConfig \u003d cliParser.getOptionValue(\"docker_client_config\");\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "e60f51299dba360d13aa39f9ab714fdfc666b532": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7745. Allow DistributedShell to take a placement specification for containers it wants to launch. (Arun Suresh via wangda)\n\nChange-Id: Ided146d662e944a8a4692e5d6885f23fd9bbcad5\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "e60f51299dba360d13aa39f9ab714fdfc666b532",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/01/18 10:29 PM",
      "commitNameOld": "01f3f2167ec20b52a18bc2cf250fb4229cfd2c14",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 23.13,
      "commitsBetweenForRepo": 147,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,189 +1,194 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n+    if (cliParser.hasOption(\"placement_spec\")) {\n+      placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n+      // Check if it is parsable\n+      PlacementSpec.parse(this.placementSpec);\n+    }\n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n     amVCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"master_resources\")) {\n       Map\u003cString, Long\u003e masterResources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           amMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           amVCores \u003d entry.getValue().intValue();\n         } else {\n           amResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n           .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n     containerVirtualCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n     if (cliParser.hasOption(\"container_resources\")) {\n       Map\u003cString, Long\u003e resources \u003d\n           parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n       for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n         if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n           containerMemory \u003d entry.getValue();\n         } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n           containerVirtualCores \u003d entry.getValue().intValue();\n         } else {\n           containerResources.put(entry.getKey(), entry.getValue());\n         }\n       }\n     }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numContainers \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n           + \" exiting. Specified numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n         flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    if (cliParser.hasOption(\"placement_spec\")) {\n      placementSpec \u003d cliParser.getOptionValue(\"placement_spec\");\n      // Check if it is parsable\n      PlacementSpec.parse(this.placementSpec);\n    }\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n    amVCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"master_resources\")) {\n      Map\u003cString, Long\u003e masterResources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          amMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          amVCores \u003d entry.getValue().intValue();\n        } else {\n          amResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n          .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n    containerVirtualCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          containerMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          containerVirtualCores \u003d entry.getValue().intValue();\n        } else {\n          containerResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numContainers \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n          + \" exiting. Specified numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "01f3f2167ec20b52a18bc2cf250fb4229cfd2c14": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7242. Support to specify values of different resource types in DistributedShell for easier testing. Contributed by Gergely Novák.\n",
      "commitDate": "07/01/18 10:29 PM",
      "commitName": "01f3f2167ec20b52a18bc2cf250fb4229cfd2c14",
      "commitAuthor": "Sunil G",
      "commitDateOld": "17/12/17 6:07 PM",
      "commitNameOld": "928964102029e96406f5482e8900802f38164501",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 21.18,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,163 +1,189 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n     amVCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n+    if (cliParser.hasOption(\"master_resources\")) {\n+      Map\u003cString, Long\u003e masterResources \u003d\n+          parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n+      for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n+        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n+          amMemory \u003d entry.getValue();\n+        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n+          amVCores \u003d entry.getValue().intValue();\n+        } else {\n+          amResources.put(entry.getKey(), entry.getValue());\n+        }\n+      }\n+    }\n     amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n           .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n     if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n       autoPromoteContainers \u003d true;\n     }\n     containerMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n     containerVirtualCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n+    if (cliParser.hasOption(\"container_resources\")) {\n+      Map\u003cString, Long\u003e resources \u003d\n+          parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n+      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n+        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n+          containerMemory \u003d entry.getValue();\n+        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n+          containerVirtualCores \u003d entry.getValue().intValue();\n+        } else {\n+          containerResources.put(entry.getKey(), entry.getValue());\n+        }\n+      }\n+    }\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numContainers \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n           + \" exiting. Specified numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n         flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n    amVCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"master_resources\")) {\n      Map\u003cString, Long\u003e masterResources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"master_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : masterResources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          amMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          amVCores \u003d entry.getValue().intValue();\n        } else {\n          amResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n          .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n    containerVirtualCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n    if (cliParser.hasOption(\"container_resources\")) {\n      Map\u003cString, Long\u003e resources \u003d\n          parseResourcesString(cliParser.getOptionValue(\"container_resources\"));\n      for (Map.Entry\u003cString, Long\u003e entry : resources.entrySet()) {\n        if (entry.getKey().equals(ResourceInformation.MEMORY_URI)) {\n          containerMemory \u003d entry.getValue();\n        } else if (entry.getKey().equals(ResourceInformation.VCORES_URI)) {\n          containerVirtualCores \u003d entry.getValue().intValue();\n        } else {\n          containerResources.put(entry.getKey(), entry.getValue());\n        }\n      }\n    }\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numContainers \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n          + \" exiting. Specified numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "928964102029e96406f5482e8900802f38164501": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7617. Add a flag in distributed shell to automatically PROMOTE opportunistic containers to guaranteed once they are started. Contributed by Weiwei Yang.\n",
      "commitDate": "17/12/17 6:07 PM",
      "commitName": "928964102029e96406f5482e8900802f38164501",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "06/12/17 1:52 AM",
      "commitNameOld": "40b0045ebe0752cd3d1d09be00acbabdea983799",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 11.68,
      "commitsBetweenForRepo": 113,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,160 +1,163 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n     amVCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n     amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     if (cliParser.hasOption(\"container_type\")) {\n       String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n       if (Arrays.stream(ExecutionType.values()).noneMatch(\n           executionType -\u003e executionType.toString()\n           .equals(containerTypeStr))) {\n         throw new IllegalArgumentException(\"Invalid container_type: \"\n             + containerTypeStr);\n       }\n       containerType \u003d ExecutionType.valueOf(containerTypeStr);\n     }\n+    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n+      autoPromoteContainers \u003d true;\n+    }\n     containerMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n     containerVirtualCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numContainers \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n           + \" exiting. Specified numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n         flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n    amVCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n    amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n          .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    if (cliParser.hasOption(\"promote_opportunistic_after_start\")) {\n      autoPromoteContainers \u003d true;\n    }\n    containerMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n    containerVirtualCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numContainers \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n          + \" exiting. Specified numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "40b0045ebe0752cd3d1d09be00acbabdea983799": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7610. Extend Distributed Shell to support launching job with opportunistic containers. Contributed by Weiwei Yang.\n",
      "commitDate": "06/12/17 1:52 AM",
      "commitName": "40b0045ebe0752cd3d1d09be00acbabdea983799",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "31/10/17 12:36 AM",
      "commitNameOld": "785f1b0d11a3bf0af9851c080ff0acc34539f17b",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 36.09,
      "commitsBetweenForRepo": 295,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,160 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n     amVCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n     amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n+    if (cliParser.hasOption(\"container_type\")) {\n+      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n+      if (Arrays.stream(ExecutionType.values()).noneMatch(\n+          executionType -\u003e executionType.toString()\n+          .equals(containerTypeStr))) {\n+        throw new IllegalArgumentException(\"Invalid container_type: \"\n+            + containerTypeStr);\n+      }\n+      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n+    }\n     containerMemory \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n     containerVirtualCores \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n     containerResourceProfile \u003d\n         cliParser.getOptionValue(\"container_resource_profile\", \"\");\n     numContainers \u003d\n         Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n           + \" exiting. Specified numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n         flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n    amVCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n    amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    if (cliParser.hasOption(\"container_type\")) {\n      String containerTypeStr \u003d cliParser.getOptionValue(\"container_type\");\n      if (Arrays.stream(ExecutionType.values()).noneMatch(\n          executionType -\u003e executionType.toString()\n          .equals(containerTypeStr))) {\n        throw new IllegalArgumentException(\"Invalid container_type: \"\n            + containerTypeStr);\n      }\n      containerType \u003d ExecutionType.valueOf(containerTypeStr);\n    }\n    containerMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n    containerVirtualCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numContainers \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n          + \" exiting. Specified numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "7805deed4896e470ebd2f6bbd1ba9962947c63cd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5588. [YARN-3926] Add support for resource profiles in distributed shell. Contributed by Varun Vasudev.\n",
      "commitDate": "12/09/17 9:19 AM",
      "commitName": "7805deed4896e470ebd2f6bbd1ba9962947c63cd",
      "commitAuthor": "Sunil G",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 429.02,
      "commitsBetweenForRepo": 2752,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,155 +1,150 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n-    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n-    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n-\n-    if (amMemory \u003c 0) {\n-      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n-          + \" Specified memory\u003d\" + amMemory);\n-    }\n-    if (amVCores \u003c 0) {\n-      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n-          + \" Specified virtual cores\u003d\" + amVCores);\n-    }\n+    amMemory \u003d\n+        Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n+    amVCores \u003d\n+        Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n+    amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n-    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n-    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n-    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n-    \n+    containerMemory \u003d\n+        Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n+    containerVirtualCores \u003d\n+        Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n+    containerResourceProfile \u003d\n+        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n+    numContainers \u003d\n+        Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n-    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n-      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n-          + \" exiting.\"\n-          + \" Specified containerMemory\u003d\" + containerMemory\n-          + \", containerVirtualCores\u003d\" + containerVirtualCores\n-          + \", numContainer\u003d\" + numContainers);\n+    if (numContainers \u003c 1) {\n+      throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n+          + \" exiting. Specified numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n         flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"-1\"));\n    amVCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"-1\"));\n    amResourceProfile \u003d cliParser.getOptionValue(\"master_resource_profile\", \"\");\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"-1\"));\n    containerVirtualCores \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"-1\"));\n    containerResourceProfile \u003d\n        cliParser.getOptionValue(\"container_resource_profile\", \"\");\n    numContainers \u003d\n        Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers specified,\"\n          + \" exiting. Specified numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "22e7ae57715cedb1dcba736e357e8daaf5133e5c",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,165 +1,155 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n-    if (cliParser.hasOption(\"timeline_service_version\")) {\n-      timelineServiceVersion \u003d\n-        cliParser.getOptionValue(\"timeline_service_version\", \"v1\");\n-      if (! (timelineServiceVersion.trim().equalsIgnoreCase(\"v1\") ||\n-          timelineServiceVersion.trim().equalsIgnoreCase(\"v2\"))) {\n-        throw new IllegalArgumentException(\n-              \"timeline_service_version is not set properly, should be \u0027v1\u0027 or \u0027v2\u0027\");\n-      }\n-    }\n-\n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n     \n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n         flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n    \n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "22e7ae57715cedb1dcba736e357e8daaf5133e5c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3792. Test case failures in TestDistributedShell and some issue fixes related to ATSV2 (Naganarasimha G R via sjlee)\n\n(cherry picked from commit 84f37f1c7eefec6d139cbf091c50d6c06f734323)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "22e7ae57715cedb1dcba736e357e8daaf5133e5c",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "47f35a30bb4d99349593e9d6e1c9e76e71341c40",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,165 +1,165 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n     if (cliParser.hasOption(\"timeline_service_version\")) {\n       timelineServiceVersion \u003d\n         cliParser.getOptionValue(\"timeline_service_version\", \"v1\");\n       if (! (timelineServiceVersion.trim().equalsIgnoreCase(\"v1\") ||\n           timelineServiceVersion.trim().equalsIgnoreCase(\"v2\"))) {\n         throw new IllegalArgumentException(\n               \"timeline_service_version is not set properly, should be \u0027v1\u0027 or \u0027v2\u0027\");\n       }\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n     \n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n \n     if (cliParser.hasOption(\"flow_name\")) {\n       flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n     if (cliParser.hasOption(\"flow_version\")) {\n       flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n     }\n     if (cliParser.hasOption(\"flow_run_id\")) {\n       try {\n-        flowRunId \u003d Long.valueOf(cliParser.getOptionValue(\"flow_run_id\"));\n+        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Flow run is not a valid long value\", e);\n       }\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (cliParser.hasOption(\"timeline_service_version\")) {\n      timelineServiceVersion \u003d\n        cliParser.getOptionValue(\"timeline_service_version\", \"v1\");\n      if (! (timelineServiceVersion.trim().equalsIgnoreCase(\"v1\") ||\n          timelineServiceVersion.trim().equalsIgnoreCase(\"v2\"))) {\n        throw new IllegalArgumentException(\n              \"timeline_service_version is not set properly, should be \u0027v1\u0027 or \u0027v2\u0027\");\n      }\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n    \n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.parseLong(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "47f35a30bb4d99349593e9d6e1c9e76e71341c40": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3391. Clearly define flow ID/ flow run / flow version in API and storage. Contributed by Zhijie Shen\n\n(cherry picked from commit 68c6232f8423e55b4d152ef3d1d66aeb2d6a555e)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "47f35a30bb4d99349593e9d6e1c9e76e71341c40",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "d67c9bdb4db2b075484a779802ecf3296bad5cd4",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,157 +1,165 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n     if (cliParser.hasOption(\"timeline_service_version\")) {\n       timelineServiceVersion \u003d\n         cliParser.getOptionValue(\"timeline_service_version\", \"v1\");\n       if (! (timelineServiceVersion.trim().equalsIgnoreCase(\"v1\") ||\n           timelineServiceVersion.trim().equalsIgnoreCase(\"v2\"))) {\n         throw new IllegalArgumentException(\n               \"timeline_service_version is not set properly, should be \u0027v1\u0027 or \u0027v2\u0027\");\n       }\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n     \n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n \n-    if (cliParser.hasOption(\"flow\")) {\n-      flowId \u003d cliParser.getOptionValue(\"flow\");\n+    if (cliParser.hasOption(\"flow_name\")) {\n+      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n     }\n-    if (cliParser.hasOption(\"flow_run\")) {\n-      flowRunId \u003d cliParser.getOptionValue(\"flow_run\");\n+    if (cliParser.hasOption(\"flow_version\")) {\n+      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n+    }\n+    if (cliParser.hasOption(\"flow_run_id\")) {\n+      try {\n+        flowRunId \u003d Long.valueOf(cliParser.getOptionValue(\"flow_run_id\"));\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(\n+            \"Flow run is not a valid long value\", e);\n+      }\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (cliParser.hasOption(\"timeline_service_version\")) {\n      timelineServiceVersion \u003d\n        cliParser.getOptionValue(\"timeline_service_version\", \"v1\");\n      if (! (timelineServiceVersion.trim().equalsIgnoreCase(\"v1\") ||\n          timelineServiceVersion.trim().equalsIgnoreCase(\"v2\"))) {\n        throw new IllegalArgumentException(\n              \"timeline_service_version is not set properly, should be \u0027v1\u0027 or \u0027v2\u0027\");\n      }\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n    \n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow_name\")) {\n      flowName \u003d cliParser.getOptionValue(\"flow_name\");\n    }\n    if (cliParser.hasOption(\"flow_version\")) {\n      flowVersion \u003d cliParser.getOptionValue(\"flow_version\");\n    }\n    if (cliParser.hasOption(\"flow_run_id\")) {\n      try {\n        flowRunId \u003d Long.valueOf(cliParser.getOptionValue(\"flow_run_id\"));\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Flow run is not a valid long value\", e);\n      }\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "d67c9bdb4db2b075484a779802ecf3296bad5cd4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3040. Make putEntities operation be aware of the app\u0027s context. Contributed by Zhijie Shen\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "d67c9bdb4db2b075484a779802ecf3296bad5cd4",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,157 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n     if (cliParser.hasOption(\"timeline_service_version\")) {\n       timelineServiceVersion \u003d\n         cliParser.getOptionValue(\"timeline_service_version\", \"v1\");\n       if (! (timelineServiceVersion.trim().equalsIgnoreCase(\"v1\") ||\n           timelineServiceVersion.trim().equalsIgnoreCase(\"v2\"))) {\n         throw new IllegalArgumentException(\n               \"timeline_service_version is not set properly, should be \u0027v1\u0027 or \u0027v2\u0027\");\n       }\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n     \n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n \n+    if (cliParser.hasOption(\"flow\")) {\n+      flowId \u003d cliParser.getOptionValue(\"flow\");\n+    }\n+    if (cliParser.hasOption(\"flow_run\")) {\n+      flowRunId \u003d cliParser.getOptionValue(\"flow_run\");\n+    }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (cliParser.hasOption(\"timeline_service_version\")) {\n      timelineServiceVersion \u003d\n        cliParser.getOptionValue(\"timeline_service_version\", \"v1\");\n      if (! (timelineServiceVersion.trim().equalsIgnoreCase(\"v1\") ||\n          timelineServiceVersion.trim().equalsIgnoreCase(\"v2\"))) {\n        throw new IllegalArgumentException(\n              \"timeline_service_version is not set properly, should be \u0027v1\u0027 or \u0027v2\u0027\");\n      }\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n    \n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    if (cliParser.hasOption(\"flow\")) {\n      flowId \u003d cliParser.getOptionValue(\"flow\");\n    }\n    if (cliParser.hasOption(\"flow_run\")) {\n      flowRunId \u003d cliParser.getOptionValue(\"flow_run\");\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3125. Made the distributed shell use timeline service next gen and add an integration test for it. Contributed by Junping Du and Li Lu.\n\n(cherry picked from commit bf08f7f0ed4900ce52f98137297dd1a47ba2a536)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "09/07/16 5:09 AM",
      "commitNameOld": "9bdb5bebea1183ec2f697ee3e55392df4fe697bb",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 1.15,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,151 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n+    \n+    if (cliParser.hasOption(\"timeline_service_version\")) {\n+      timelineServiceVersion \u003d \n+        cliParser.getOptionValue(\"timeline_service_version\", \"v1\");\n+      if (! (timelineServiceVersion.trim().equalsIgnoreCase(\"v1\") || \n+          timelineServiceVersion.trim().equalsIgnoreCase(\"v2\"))) {\n+        throw new IllegalArgumentException(\n+              \"timeline_service_version is not set properly, should be \u0027v1\u0027 or \u0027v2\u0027\");\n+      }\n+    }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n     \n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n    \n    if (cliParser.hasOption(\"timeline_service_version\")) {\n      timelineServiceVersion \u003d \n        cliParser.getOptionValue(\"timeline_service_version\", \"v1\");\n      if (! (timelineServiceVersion.trim().equalsIgnoreCase(\"v1\") || \n          timelineServiceVersion.trim().equalsIgnoreCase(\"v2\"))) {\n        throw new IllegalArgumentException(\n              \"timeline_service_version is not set properly, should be \u0027v1\u0027 or \u0027v2\u0027\");\n      }\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n    \n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "9bdb5bebea1183ec2f697ee3e55392df4fe697bb": {
      "type": "Ybodychange",
      "commitMessage": "Fix OOM issue in DistributedShell. Contributed by Jian He.\n",
      "commitDate": "09/07/16 5:09 AM",
      "commitName": "9bdb5bebea1183ec2f697ee3e55392df4fe697bb",
      "commitAuthor": "Junping Du",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 24.59,
      "commitsBetweenForRepo": 174,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,141 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n-    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n+    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n     \n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     // Get container retry options\n     if (cliParser.hasOption(\"container_retry_policy\")) {\n       containerRetryOptions.add(\"--container_retry_policy \"\n           + cliParser.getOptionValue(\"container_retry_policy\"));\n     }\n     if (cliParser.hasOption(\"container_retry_error_codes\")) {\n       containerRetryOptions.add(\"--container_retry_error_codes \"\n           + cliParser.getOptionValue(\"container_retry_error_codes\"));\n     }\n     if (cliParser.hasOption(\"container_max_retries\")) {\n       containerRetryOptions.add(\"--container_max_retries \"\n           + cliParser.getOptionValue(\"container_max_retries\"));\n     }\n     if (cliParser.hasOption(\"container_retry_interval\")) {\n       containerRetryOptions.add(\"--container_retry_interval \"\n           + cliParser.getOptionValue(\"container_retry_interval\"));\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"100\"));\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n    \n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3998. Add support in the NodeManager to re-launch containers. Contributed by Jun Gong.\n",
      "commitDate": "29/04/16 3:39 AM",
      "commitName": "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "10/02/16 5:01 AM",
      "commitNameOld": "e9a622606f69dc926a950d4dd61fe3f16f378509",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 78.9,
      "commitsBetweenForRepo": 496,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,141 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n     \n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n     \n     nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n+    // Get container retry options\n+    if (cliParser.hasOption(\"container_retry_policy\")) {\n+      containerRetryOptions.add(\"--container_retry_policy \"\n+          + cliParser.getOptionValue(\"container_retry_policy\"));\n+    }\n+    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n+      containerRetryOptions.add(\"--container_retry_error_codes \"\n+          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n+    }\n+    if (cliParser.hasOption(\"container_max_retries\")) {\n+      containerRetryOptions.add(\"--container_max_retries \"\n+          + cliParser.getOptionValue(\"container_max_retries\"));\n+    }\n+    if (cliParser.hasOption(\"container_retry_interval\")) {\n+      containerRetryOptions.add(\"--container_retry_interval \"\n+          + cliParser.getOptionValue(\"container_retry_interval\"));\n+    }\n+\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n    \n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    // Get container retry options\n    if (cliParser.hasOption(\"container_retry_policy\")) {\n      containerRetryOptions.add(\"--container_retry_policy \"\n          + cliParser.getOptionValue(\"container_retry_policy\"));\n    }\n    if (cliParser.hasOption(\"container_retry_error_codes\")) {\n      containerRetryOptions.add(\"--container_retry_error_codes \"\n          + cliParser.getOptionValue(\"container_retry_error_codes\"));\n    }\n    if (cliParser.hasOption(\"container_max_retries\")) {\n      containerRetryOptions.add(\"--container_max_retries \"\n          + cliParser.getOptionValue(\"container_max_retries\"));\n    }\n    if (cliParser.hasOption(\"container_retry_interval\")) {\n      containerRetryOptions.add(\"--container_retry_interval \"\n          + cliParser.getOptionValue(\"container_retry_interval\"));\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "f6b963fdfc517429149165e4bb6fb947be6e3c99": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2502. Changed DistributedShell to support node labels. Contributed by Wangda Tan\n",
      "commitDate": "27/10/14 8:13 PM",
      "commitName": "f6b963fdfc517429149165e4bb6fb947be6e3c99",
      "commitAuthor": "Jian He",
      "commitDateOld": "09/10/14 12:59 PM",
      "commitNameOld": "1d4612f5ad9678c952b416e798dccd20c88f96ef",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 18.3,
      "commitsBetweenForRepo": 145,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,123 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n+    \n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n+    \n+    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     // Get timeline domain options\n     if (cliParser.hasOption(\"domain\")) {\n       domainId \u003d cliParser.getOptionValue(\"domain\");\n       toCreateDomain \u003d cliParser.hasOption(\"create\");\n       if (cliParser.hasOption(\"view_acls\")) {\n         viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n       }\n       if (cliParser.hasOption(\"modify_acls\")) {\n         modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n       }\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n    \n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n    \n    nodeLabelExpression \u003d cliParser.getOptionValue(\"node_label_expression\", null);\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "1d4612f5ad9678c952b416e798dccd20c88f96ef": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2629. Made the distributed shell use the domain-based timeline ACLs. Contributed by Zhijie Shen.\n",
      "commitDate": "09/10/14 12:59 PM",
      "commitName": "1d4612f5ad9678c952b416e798dccd20c88f96ef",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "16/09/14 10:58 AM",
      "commitNameOld": "8e5d6713cf16473d791c028cecc274fd2c7fd10b",
      "commitAuthorOld": "XuanGong",
      "daysBetweenCommits": 23.08,
      "commitsBetweenForRepo": 276,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,120 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     attemptFailuresValidityInterval \u003d\n         Long.parseLong(cliParser.getOptionValue(\n           \"attempt_failures_validity_interval\", \"-1\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n+    // Get timeline domain options\n+    if (cliParser.hasOption(\"domain\")) {\n+      domainId \u003d cliParser.getOptionValue(\"domain\");\n+      toCreateDomain \u003d cliParser.hasOption(\"create\");\n+      if (cliParser.hasOption(\"view_acls\")) {\n+        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n+      }\n+      if (cliParser.hasOption(\"modify_acls\")) {\n+        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n+      }\n+    }\n+\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    // Get timeline domain options\n    if (cliParser.hasOption(\"domain\")) {\n      domainId \u003d cliParser.getOptionValue(\"domain\");\n      toCreateDomain \u003d cliParser.hasOption(\"create\");\n      if (cliParser.hasOption(\"view_acls\")) {\n        viewACLs \u003d cliParser.getOptionValue(\"view_acls\");\n      }\n      if (cliParser.hasOption(\"modify_acls\")) {\n        modifyACLs \u003d cliParser.getOptionValue(\"modify_acls\");\n      }\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "8e5d6713cf16473d791c028cecc274fd2c7fd10b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2557. Add a parameter \"attempt_Failures_Validity_Interval\" into\nDistributedShell. Contributed by Xuan Gong\n",
      "commitDate": "16/09/14 10:58 AM",
      "commitName": "8e5d6713cf16473d791c028cecc274fd2c7fd10b",
      "commitAuthor": "XuanGong",
      "commitDateOld": "29/08/14 11:16 AM",
      "commitNameOld": "3de66011c2e80d7c458a67f80042af986fcc677d",
      "commitAuthorOld": "Hitesh Shah",
      "daysBetweenCommits": 17.99,
      "commitsBetweenForRepo": 144,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,108 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n       LOG.info(\"keep_containers_across_application_attempts\");\n       keepContainers \u003d true;\n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n+    attemptFailuresValidityInterval \u003d\n+        Long.parseLong(cliParser.getOptionValue(\n+          \"attempt_failures_validity_interval\", \"-1\"));\n+\n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    attemptFailuresValidityInterval \u003d\n        Long.parseLong(cliParser.getOptionValue(\n          \"attempt_failures_validity_interval\", \"-1\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "aa0c489a28dbbe8fae0be6a48edb122537784b1d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1566. Changed Distributed Shell to retain containers across application attempts. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 11:42 PM",
      "commitName": "aa0c489a28dbbe8fae0be6a48edb122537784b1d",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/12/13 6:00 PM",
      "commitNameOld": "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 28.24,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,104 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n+    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n+      LOG.info(\"keep_containers_across_application_attempts\");\n+      keepContainers \u003d true;\n+    }\n+\n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n-    \n+\n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\n           \"No shell command or shell script specified to be executed by application master\");\n     } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n       throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n           \"and shell_script option at the same time\");\n     } else if (cliParser.hasOption(\"shell_command\")) {\n       shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n     } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    if (cliParser.hasOption(\"keep_containers_across_application_attempts\")) {\n      LOG.info(\"keep_containers_across_application_attempts\");\n      keepContainers \u003d true;\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1435. Modified Distributed Shell to accept either the command or the custom script. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550867 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/13 6:00 PM",
      "commitName": "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "25/11/13 5:10 PM",
      "commitNameOld": "c4bdddeab56287c8a8ae314fac238cbbc6c1bcf4",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 18.03,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,99 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n     \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n-    if (!cliParser.hasOption(\"shell_command\")) {\n-      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n-    }\n-    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n-\n-    if (cliParser.hasOption(\"shell_script\")) {\n+    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n+      throw new IllegalArgumentException(\n+          \"No shell command or shell script specified to be executed by application master\");\n+    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n+      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n+          \"and shell_script option at the same time\");\n+    } else if (cliParser.hasOption(\"shell_command\")) {\n+      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n+    } else {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n    \n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\") \u0026\u0026 !cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\n          \"No shell command or shell script specified to be executed by application master\");\n    } else if (cliParser.hasOption(\"shell_command\") \u0026\u0026 cliParser.hasOption(\"shell_script\")) {\n      throw new IllegalArgumentException(\"Can not specify shell_command option \" +\n          \"and shell_script option at the same time\");\n    } else if (cliParser.hasOption(\"shell_command\")) {\n      shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n    } else {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "c4bdddeab56287c8a8ae314fac238cbbc6c1bcf4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1314. Fixed DistributedShell to not fail with multiple arguments for a shell command separated by spaces. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1545486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/11/13 5:10 PM",
      "commitName": "c4bdddeab56287c8a8ae314fac238cbbc6c1bcf4",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "21/11/13 3:16 PM",
      "commitNameOld": "33a8234040959ecd0d0202162e1b18c990effabe",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.08,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,96 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\n \n     if (cliParser.hasOption(\"log_properties\")) {\n       String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n       try {\n         Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n       } catch (Exception e) {\n         LOG.warn(\"Can not set up custom log4j properties. \" + e);\n       }\n     }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n     \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_script\")) {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n-      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n+      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n    \n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_script\")) {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValues(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "33a8234040959ecd0d0202162e1b18c990effabe": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1320. Fixed Distributed Shell application to respect custom log4j properties file. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544364 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/11/13 3:16 PM",
      "commitName": "33a8234040959ecd0d0202162e1b18c990effabe",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "20/11/13 8:09 PM",
      "commitNameOld": "a802ef4a5f2e71eed2cbdc053258ae2f66af4755",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.8,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,96 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n-    }\t\t\n+    }\n+\n+    if (cliParser.hasOption(\"log_properties\")) {\n+      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n+      try {\n+        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n+      } catch (Exception e) {\n+        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n+      }\n+    }\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n     amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n     \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n     if (amVCores \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n           + \" Specified virtual cores\u003d\" + amVCores);\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_script\")) {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n           + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\n\n    if (cliParser.hasOption(\"log_properties\")) {\n      String log4jPath \u003d cliParser.getOptionValue(\"log_properties\");\n      try {\n        Log4jPropertyHelper.updateLog4jConfiguration(Client.class, log4jPath);\n      } catch (Exception e) {\n        LOG.warn(\"Can not set up custom log4j properties. \" + e);\n      }\n    }\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n    \n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_script\")) {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "735d8b27f78ea8be839008650a3e88db37dc507d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7. Support CPU resource for DistributedShell. (Junping Du via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1531222 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/10/13 1:18 AM",
      "commitName": "735d8b27f78ea8be839008650a3e88db37dc507d",
      "commitAuthor": "Luke Lu",
      "commitDateOld": "04/10/13 11:08 PM",
      "commitNameOld": "be3edccf0acf55e710b0ec8ab8ce8418da74c615",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.09,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,87 @@\n   public boolean init(String[] args) throws ParseException {\n \n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\t\t\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n-\n+    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n+    \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n+    if (amVCores \u003c 0) {\n+      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n+          + \" Specified virtual cores\u003d\" + amVCores);\n+    }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_script\")) {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n+    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n-    if (containerMemory \u003c 0 || numContainers \u003c 1) {\n-      throw new IllegalArgumentException(\"Invalid no. of containers or container memory specified, exiting.\"\n+    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n+      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n+          + \" exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n+          + \", containerVirtualCores\u003d\" + containerVirtualCores\n           + \", numContainer\u003d\" + numContainers);\n     }\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\t\t\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n    amVCores \u003d Integer.parseInt(cliParser.getOptionValue(\"master_vcores\", \"1\"));\n    \n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n    if (amVCores \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid virtual cores specified for application master, exiting.\"\n          + \" Specified virtual cores\u003d\" + amVCores);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_script\")) {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    containerVirtualCores \u003d Integer.parseInt(cliParser.getOptionValue(\"container_vcores\", \"1\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (containerMemory \u003c 0 || containerVirtualCores \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory/vcores specified,\"\n          + \" exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", containerVirtualCores\u003d\" + containerVirtualCores\n          + \", numContainer\u003d\" + numContainers);\n    }\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "bca57d471f4cc67bd5b73589cb941e868e0ca840": {
      "type": "Ybodychange",
      "commitMessage": "YARN-94. Modify DistributedShell to point to main-class by default, clean up the help message, and hard-code the AM class. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1396226 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/10/12 12:40 PM",
      "commitName": "bca57d471f4cc67bd5b73589cb941e868e0ca840",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "05/09/12 10:54 AM",
      "commitNameOld": "87c5d243db050ac9ce0c53e0905930573132221e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 34.07,
      "commitsBetweenForRepo": 182,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,79 @@\n   public boolean init(String[] args) throws ParseException {\n \n-    Options opts \u003d new Options();\n-    opts.addOption(\"appname\", true, \"Application Name. Default value - DistributedShell\");\n-    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n-    opts.addOption(\"queue\", true, \"RM Queue in which this application is to be submitted\");\n-    opts.addOption(\"timeout\", true, \"Application timeout in milliseconds\");\n-    opts.addOption(\"master_memory\", true, \"Amount of memory in MB to be requested to run the application master\");\n-    opts.addOption(\"jar\", true, \"Jar file containing the application master\");\n-    opts.addOption(\"class\", true, \"Main class to  be run for the Application Master.\");\n-    opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n-    opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n-    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n-    opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n-    opts.addOption(\"shell_cmd_priority\", true, \"Priority for the shell command containers\");\t\t\n-    opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n-    opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n-    opts.addOption(\"log_properties\", true, \"log4j.properties file\");\n-    opts.addOption(\"debug\", false, \"Dump out debug information\");\n-    opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n-      printUsage(opts);\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\t\t\n \n     if (cliParser.hasOption(\"help\")) {\n-      printUsage(opts);\n+      printUsage();\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n-    appMasterMainClass \u003d cliParser.getOptionValue(\"class\",\n-        \"org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster\");\t\t\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_script\")) {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (containerMemory \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory specified, exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", numContainer\u003d\" + numContainers);\n     }\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\t\t\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage();\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_script\")) {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (containerMemory \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory specified, exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", numContainer\u003d\" + numContainers);\n    }\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"appname\", true, \"Application Name. Default value - DistributedShell\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"queue\", true, \"RM Queue in which this application is to be submitted\");\n    opts.addOption(\"timeout\", true, \"Application timeout in milliseconds\");\n    opts.addOption(\"master_memory\", true, \"Amount of memory in MB to be requested to run the application master\");\n    opts.addOption(\"jar\", true, \"Jar file containing the application master\");\n    opts.addOption(\"class\", true, \"Main class to  be run for the Application Master.\");\n    opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"shell_cmd_priority\", true, \"Priority for the shell command containers\");\t\t\n    opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"log_properties\", true, \"log4j.properties file\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\t\t\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n    appMasterMainClass \u003d cliParser.getOptionValue(\"class\",\n        \"org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster\");\t\t\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_script\")) {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (containerMemory \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory specified, exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", numContainer\u003d\" + numContainers);\n    }\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java"
      }
    },
    "db31b6c0e4aa1f6cd2d655a48195fdfb76bc5329": {
      "type": "Ybodychange",
      "commitMessage": " MAPREDUCE-4336. Distributed Shell fails when used with the CapacityScheduler (ahmed via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1353625 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/06/12 8:58 AM",
      "commitName": "db31b6c0e4aa1f6cd2d655a48195fdfb76bc5329",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "19/06/12 3:00 PM",
      "commitNameOld": "daa28cc6ce23ef5c8db8b9f896f342cb770dd092",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 5.75,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,100 @@\n   public boolean init(String[] args) throws ParseException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"appname\", true, \"Application Name. Default value - DistributedShell\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"queue\", true, \"RM Queue in which this application is to be submitted\");\n     opts.addOption(\"timeout\", true, \"Application timeout in milliseconds\");\n     opts.addOption(\"master_memory\", true, \"Amount of memory in MB to be requested to run the application master\");\n     opts.addOption(\"jar\", true, \"Jar file containing the application master\");\n     opts.addOption(\"class\", true, \"Main class to  be run for the Application Master.\");\n     opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n     opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n     opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"shell_cmd_priority\", true, \"Priority for the shell command containers\");\t\t\n     opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"log_properties\", true, \"log4j.properties file\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\t\t\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n-    amQueue \u003d cliParser.getOptionValue(\"queue\", \"\");\n+    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n     appMasterMainClass \u003d cliParser.getOptionValue(\"class\",\n         \"org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster\");\t\t\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_script\")) {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (containerMemory \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory specified, exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", numContainer\u003d\" + numContainers);\n     }\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"appname\", true, \"Application Name. Default value - DistributedShell\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"queue\", true, \"RM Queue in which this application is to be submitted\");\n    opts.addOption(\"timeout\", true, \"Application timeout in milliseconds\");\n    opts.addOption(\"master_memory\", true, \"Amount of memory in MB to be requested to run the application master\");\n    opts.addOption(\"jar\", true, \"Jar file containing the application master\");\n    opts.addOption(\"class\", true, \"Main class to  be run for the Application Master.\");\n    opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"shell_cmd_priority\", true, \"Priority for the shell command containers\");\t\t\n    opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"log_properties\", true, \"log4j.properties file\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\t\t\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"default\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n    appMasterMainClass \u003d cliParser.getOptionValue(\"class\",\n        \"org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster\");\t\t\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_script\")) {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (containerMemory \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory specified, exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", numContainer\u003d\" + numContainers);\n    }\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    return true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "daa28cc6ce23ef5c8db8b9f896f342cb770dd092": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4306. Fix distributed shell to work with users other than the one running the daemons. (Contributed by Ahmed Radwan)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1351876 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/06/12 3:00 PM",
      "commitName": "daa28cc6ce23ef5c8db8b9f896f342cb770dd092",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "19/04/12 1:33 PM",
      "commitNameOld": "df654cca49c12ab3fa8ec1e626da1bb562bbb6c1",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 61.06,
      "commitsBetweenForRepo": 319,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,100 @@\n   public boolean init(String[] args) throws ParseException {\n \n     Options opts \u003d new Options();\n     opts.addOption(\"appname\", true, \"Application Name. Default value - DistributedShell\");\n     opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n     opts.addOption(\"queue\", true, \"RM Queue in which this application is to be submitted\");\n-    opts.addOption(\"user\", true, \"User to run the application as\");\n     opts.addOption(\"timeout\", true, \"Application timeout in milliseconds\");\n     opts.addOption(\"master_memory\", true, \"Amount of memory in MB to be requested to run the application master\");\n     opts.addOption(\"jar\", true, \"Jar file containing the application master\");\n     opts.addOption(\"class\", true, \"Main class to  be run for the Application Master.\");\n     opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n     opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n     opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n     opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n     opts.addOption(\"shell_cmd_priority\", true, \"Priority for the shell command containers\");\t\t\n     opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n     opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n     opts.addOption(\"log_properties\", true, \"log4j.properties file\");\n     opts.addOption(\"debug\", false, \"Dump out debug information\");\n     opts.addOption(\"help\", false, \"Print usage\");\n     CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n \n     if (args.length \u003d\u003d 0) {\n       printUsage(opts);\n       throw new IllegalArgumentException(\"No args specified for client to initialize\");\n     }\t\t\n \n     if (cliParser.hasOption(\"help\")) {\n       printUsage(opts);\n       return false;\n     }\n \n     if (cliParser.hasOption(\"debug\")) {\n       debugFlag \u003d true;\n \n     }\n \n     appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n     amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n     amQueue \u003d cliParser.getOptionValue(\"queue\", \"\");\n-    amUser \u003d cliParser.getOptionValue(\"user\", \"\");\n     amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n \n     if (amMemory \u003c 0) {\n       throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n           + \" Specified memory\u003d\" + amMemory);\n     }\n \n     if (!cliParser.hasOption(\"jar\")) {\n       throw new IllegalArgumentException(\"No jar file specified for application master\");\n     }\t\t\n \n     appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n     appMasterMainClass \u003d cliParser.getOptionValue(\"class\",\n         \"org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster\");\t\t\n \n     if (!cliParser.hasOption(\"shell_command\")) {\n       throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n     }\n     shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n \n     if (cliParser.hasOption(\"shell_script\")) {\n       shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n     }\n     if (cliParser.hasOption(\"shell_args\")) {\n       shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n     }\n     if (cliParser.hasOption(\"shell_env\")) { \n       String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n       for (String env : envs) {\n         env \u003d env.trim();\n         int index \u003d env.indexOf(\u0027\u003d\u0027);\n         if (index \u003d\u003d -1) {\n           shellEnv.put(env, \"\");\n           continue;\n         }\n         String key \u003d env.substring(0, index);\n         String val \u003d \"\";\n         if (index \u003c (env.length()-1)) {\n           val \u003d env.substring(index+1);\n         }\n         shellEnv.put(key, val);\n       }\n     }\n     shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n \n     containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n     numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n \n     if (containerMemory \u003c 0 || numContainers \u003c 1) {\n       throw new IllegalArgumentException(\"Invalid no. of containers or container memory specified, exiting.\"\n           + \" Specified containerMemory\u003d\" + containerMemory\n           + \", numContainer\u003d\" + numContainers);\n     }\n \n     clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n \n     log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"appname\", true, \"Application Name. Default value - DistributedShell\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"queue\", true, \"RM Queue in which this application is to be submitted\");\n    opts.addOption(\"timeout\", true, \"Application timeout in milliseconds\");\n    opts.addOption(\"master_memory\", true, \"Amount of memory in MB to be requested to run the application master\");\n    opts.addOption(\"jar\", true, \"Jar file containing the application master\");\n    opts.addOption(\"class\", true, \"Main class to  be run for the Application Master.\");\n    opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"shell_cmd_priority\", true, \"Priority for the shell command containers\");\t\t\n    opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"log_properties\", true, \"log4j.properties file\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\t\t\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n    appMasterMainClass \u003d cliParser.getOptionValue(\"class\",\n        \"org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster\");\t\t\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_script\")) {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (containerMemory \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory specified, exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", numContainer\u003d\" + numContainers);\n    }\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    return true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java",
      "extendedDetails": {}
    },
    "fad230a49d0d4cdbb2062b10c3dea6c755737db5": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2719. Add a simple, DistributedShell, application to illustrate alternate frameworks on YARN. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1177864 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/09/11 3:25 PM",
      "commitName": "fad230a49d0d4cdbb2062b10c3dea6c755737db5",
      "commitAuthor": "Arun Murthy",
      "diff": "@@ -0,0 +1,102 @@\n+  public boolean init(String[] args) throws ParseException {\n+\n+    Options opts \u003d new Options();\n+    opts.addOption(\"appname\", true, \"Application Name. Default value - DistributedShell\");\n+    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n+    opts.addOption(\"queue\", true, \"RM Queue in which this application is to be submitted\");\n+    opts.addOption(\"user\", true, \"User to run the application as\");\n+    opts.addOption(\"timeout\", true, \"Application timeout in milliseconds\");\n+    opts.addOption(\"master_memory\", true, \"Amount of memory in MB to be requested to run the application master\");\n+    opts.addOption(\"jar\", true, \"Jar file containing the application master\");\n+    opts.addOption(\"class\", true, \"Main class to  be run for the Application Master.\");\n+    opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n+    opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n+    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n+    opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n+    opts.addOption(\"shell_cmd_priority\", true, \"Priority for the shell command containers\");\t\t\n+    opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n+    opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n+    opts.addOption(\"log_properties\", true, \"log4j.properties file\");\n+    opts.addOption(\"debug\", false, \"Dump out debug information\");\n+    opts.addOption(\"help\", false, \"Print usage\");\n+    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n+\n+    if (args.length \u003d\u003d 0) {\n+      printUsage(opts);\n+      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n+    }\t\t\n+\n+    if (cliParser.hasOption(\"help\")) {\n+      printUsage(opts);\n+      return false;\n+    }\n+\n+    if (cliParser.hasOption(\"debug\")) {\n+      debugFlag \u003d true;\n+\n+    }\n+\n+    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n+    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n+    amQueue \u003d cliParser.getOptionValue(\"queue\", \"\");\n+    amUser \u003d cliParser.getOptionValue(\"user\", \"\");\n+    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n+\n+    if (amMemory \u003c 0) {\n+      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n+          + \" Specified memory\u003d\" + amMemory);\n+    }\n+\n+    if (!cliParser.hasOption(\"jar\")) {\n+      throw new IllegalArgumentException(\"No jar file specified for application master\");\n+    }\t\t\n+\n+    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n+    appMasterMainClass \u003d cliParser.getOptionValue(\"class\",\n+        \"org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster\");\t\t\n+\n+    if (!cliParser.hasOption(\"shell_command\")) {\n+      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n+    }\n+    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n+\n+    if (cliParser.hasOption(\"shell_script\")) {\n+      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n+    }\n+    if (cliParser.hasOption(\"shell_args\")) {\n+      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n+    }\n+    if (cliParser.hasOption(\"shell_env\")) { \n+      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n+      for (String env : envs) {\n+        env \u003d env.trim();\n+        int index \u003d env.indexOf(\u0027\u003d\u0027);\n+        if (index \u003d\u003d -1) {\n+          shellEnv.put(env, \"\");\n+          continue;\n+        }\n+        String key \u003d env.substring(0, index);\n+        String val \u003d \"\";\n+        if (index \u003c (env.length()-1)) {\n+          val \u003d env.substring(index+1);\n+        }\n+        shellEnv.put(key, val);\n+      }\n+    }\n+    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n+\n+    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n+    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n+\n+    if (containerMemory \u003c 0 || numContainers \u003c 1) {\n+      throw new IllegalArgumentException(\"Invalid no. of containers or container memory specified, exiting.\"\n+          + \" Specified containerMemory\u003d\" + containerMemory\n+          + \", numContainer\u003d\" + numContainers);\n+    }\n+\n+    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n+\n+    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n+\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean init(String[] args) throws ParseException {\n\n    Options opts \u003d new Options();\n    opts.addOption(\"appname\", true, \"Application Name. Default value - DistributedShell\");\n    opts.addOption(\"priority\", true, \"Application Priority. Default 0\");\n    opts.addOption(\"queue\", true, \"RM Queue in which this application is to be submitted\");\n    opts.addOption(\"user\", true, \"User to run the application as\");\n    opts.addOption(\"timeout\", true, \"Application timeout in milliseconds\");\n    opts.addOption(\"master_memory\", true, \"Amount of memory in MB to be requested to run the application master\");\n    opts.addOption(\"jar\", true, \"Jar file containing the application master\");\n    opts.addOption(\"class\", true, \"Main class to  be run for the Application Master.\");\n    opts.addOption(\"shell_command\", true, \"Shell command to be executed by the Application Master\");\n    opts.addOption(\"shell_script\", true, \"Location of the shell script to be executed\");\n    opts.addOption(\"shell_args\", true, \"Command line args for the shell script\");\n    opts.addOption(\"shell_env\", true, \"Environment for shell script. Specified as env_key\u003denv_val pairs\");\n    opts.addOption(\"shell_cmd_priority\", true, \"Priority for the shell command containers\");\t\t\n    opts.addOption(\"container_memory\", true, \"Amount of memory in MB to be requested to run the shell command\");\n    opts.addOption(\"num_containers\", true, \"No. of containers on which the shell command needs to be executed\");\n    opts.addOption(\"log_properties\", true, \"log4j.properties file\");\n    opts.addOption(\"debug\", false, \"Dump out debug information\");\n    opts.addOption(\"help\", false, \"Print usage\");\n    CommandLine cliParser \u003d new GnuParser().parse(opts, args);\n\n    if (args.length \u003d\u003d 0) {\n      printUsage(opts);\n      throw new IllegalArgumentException(\"No args specified for client to initialize\");\n    }\t\t\n\n    if (cliParser.hasOption(\"help\")) {\n      printUsage(opts);\n      return false;\n    }\n\n    if (cliParser.hasOption(\"debug\")) {\n      debugFlag \u003d true;\n\n    }\n\n    appName \u003d cliParser.getOptionValue(\"appname\", \"DistributedShell\");\n    amPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"priority\", \"0\"));\n    amQueue \u003d cliParser.getOptionValue(\"queue\", \"\");\n    amUser \u003d cliParser.getOptionValue(\"user\", \"\");\n    amMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"master_memory\", \"10\"));\t\t\n\n    if (amMemory \u003c 0) {\n      throw new IllegalArgumentException(\"Invalid memory specified for application master, exiting.\"\n          + \" Specified memory\u003d\" + amMemory);\n    }\n\n    if (!cliParser.hasOption(\"jar\")) {\n      throw new IllegalArgumentException(\"No jar file specified for application master\");\n    }\t\t\n\n    appMasterJar \u003d cliParser.getOptionValue(\"jar\");\n    appMasterMainClass \u003d cliParser.getOptionValue(\"class\",\n        \"org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster\");\t\t\n\n    if (!cliParser.hasOption(\"shell_command\")) {\n      throw new IllegalArgumentException(\"No shell command specified to be executed by application master\");\n    }\n    shellCommand \u003d cliParser.getOptionValue(\"shell_command\");\n\n    if (cliParser.hasOption(\"shell_script\")) {\n      shellScriptPath \u003d cliParser.getOptionValue(\"shell_script\");\n    }\n    if (cliParser.hasOption(\"shell_args\")) {\n      shellArgs \u003d cliParser.getOptionValue(\"shell_args\");\n    }\n    if (cliParser.hasOption(\"shell_env\")) { \n      String envs[] \u003d cliParser.getOptionValues(\"shell_env\");\n      for (String env : envs) {\n        env \u003d env.trim();\n        int index \u003d env.indexOf(\u0027\u003d\u0027);\n        if (index \u003d\u003d -1) {\n          shellEnv.put(env, \"\");\n          continue;\n        }\n        String key \u003d env.substring(0, index);\n        String val \u003d \"\";\n        if (index \u003c (env.length()-1)) {\n          val \u003d env.substring(index+1);\n        }\n        shellEnv.put(key, val);\n      }\n    }\n    shellCmdPriority \u003d Integer.parseInt(cliParser.getOptionValue(\"shell_cmd_priority\", \"0\"));\n\n    containerMemory \u003d Integer.parseInt(cliParser.getOptionValue(\"container_memory\", \"10\"));\n    numContainers \u003d Integer.parseInt(cliParser.getOptionValue(\"num_containers\", \"1\"));\n\n    if (containerMemory \u003c 0 || numContainers \u003c 1) {\n      throw new IllegalArgumentException(\"Invalid no. of containers or container memory specified, exiting.\"\n          + \" Specified containerMemory\u003d\" + containerMemory\n          + \", numContainer\u003d\" + numContainers);\n    }\n\n    clientTimeout \u003d Integer.parseInt(cliParser.getOptionValue(\"timeout\", \"600000\"));\n\n    log4jPropFile \u003d cliParser.getOptionValue(\"log_properties\", \"\");\n\n    return true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/Client.java"
    }
  }
}