{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "OptionsParser.java",
  "functionName": "parse",
  "functionId": "parse___args-String[]",
  "sourceFilePath": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
  "functionStartLine": 84,
  "functionEndLine": 239,
  "numCommitsSeen": 29,
  "timeTaken": 6566,
  "changeHistory": [
    "4486220bb2f6ba670cea0dbce314d816ba4c4c7f",
    "19a001826f6ab9ac2caa92b66864f62218557beb",
    "ee3115f488ce8e44bffac15af9c646190bf67b88",
    "de804e53b9d20a2df75a4c7252bf83ed52011488",
    "1976e0066e9ae8852715fa69d8aea3769330e933",
    "63720ef574df6d79a9bab0628edb915d1e3a7c30",
    "dd65eea74b1f9dde858ff34df8111e5340115511",
    "b4adc8392c1314d6d6fbdd00f2afb306ef20a650",
    "26172a94d6431e70d7fe15d66be9a7e195f79f60",
    "bf3fb585aaf2b179836e139c041fc87920a3c886",
    "144f1cf76527e6c75aec77ef683a898580f3cc8d",
    "064c8b25eca9bc825dc07a54d9147d65c9290a03",
    "8650cc84f20e7d8c32dcdcd91c94372d476e2276",
    "0bc6d37f3c1e7c2a8682dffa95461a884bd6ba17",
    "412c4c9a342b73bf1c1a7f43ea91245cbf94d02d",
    "03788d3015c962eac1a35fa5df39356e8b84731c",
    "18c7e582839ea0b550463569b18b5827d23f8849",
    "0790275f058b0cf41780ad337c9150a1e8ebebc6",
    "cfba355052df15f8eb6cc9b8e90e2d8492bec7d7",
    "ed70fa142cabdbc1065e4dbbc95e99c8850c4751",
    "3671a5e16fbddbe5a0516289ce98e1305e02291c",
    "6ba9ff9177b928054f11033e8323743767d7358c",
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67"
  ],
  "changeHistoryShort": {
    "4486220bb2f6ba670cea0dbce314d816ba4c4c7f": "Ybodychange",
    "19a001826f6ab9ac2caa92b66864f62218557beb": "Ybodychange",
    "ee3115f488ce8e44bffac15af9c646190bf67b88": "Ybodychange",
    "de804e53b9d20a2df75a4c7252bf83ed52011488": "Ybodychange",
    "1976e0066e9ae8852715fa69d8aea3769330e933": "Ybodychange",
    "63720ef574df6d79a9bab0628edb915d1e3a7c30": "Ybodychange",
    "dd65eea74b1f9dde858ff34df8111e5340115511": "Ybodychange",
    "b4adc8392c1314d6d6fbdd00f2afb306ef20a650": "Ybodychange",
    "26172a94d6431e70d7fe15d66be9a7e195f79f60": "Ybodychange",
    "bf3fb585aaf2b179836e139c041fc87920a3c886": "Ybodychange",
    "144f1cf76527e6c75aec77ef683a898580f3cc8d": "Ybodychange",
    "064c8b25eca9bc825dc07a54d9147d65c9290a03": "Ybodychange",
    "8650cc84f20e7d8c32dcdcd91c94372d476e2276": "Ybodychange",
    "0bc6d37f3c1e7c2a8682dffa95461a884bd6ba17": "Ybodychange",
    "412c4c9a342b73bf1c1a7f43ea91245cbf94d02d": "Ybodychange",
    "03788d3015c962eac1a35fa5df39356e8b84731c": "Ybodychange",
    "18c7e582839ea0b550463569b18b5827d23f8849": "Ybodychange",
    "0790275f058b0cf41780ad337c9150a1e8ebebc6": "Ybodychange",
    "cfba355052df15f8eb6cc9b8e90e2d8492bec7d7": "Ybodychange",
    "ed70fa142cabdbc1065e4dbbc95e99c8850c4751": "Ybodychange",
    "3671a5e16fbddbe5a0516289ce98e1305e02291c": "Ybodychange",
    "6ba9ff9177b928054f11033e8323743767d7358c": "Ybodychange",
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4486220bb2f6ba670cea0dbce314d816ba4c4c7f": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-8143. Change distcp to have -pb on by default.\"\n\nThis reverts commit dd65eea74b1f9dde858ff34df8111e5340115511.\n\nChange-Id: I74180cf59d5bbad8c9f66cb331535addcbea863e\n",
      "commitDate": "14/05/20 11:03 AM",
      "commitName": "4486220bb2f6ba670cea0dbce314d816ba4c4c7f",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/07/19 5:13 AM",
      "commitNameOld": "19a001826f6ab9ac2caa92b66864f62218557beb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 302.24,
      "commitsBetweenForRepo": 1510,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,159 +1,156 @@\n   public static DistCpOptions parse(String[] args)\n       throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n     builder\n         .withAtomicCommit(\n             command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n         .withSyncFolder(\n             command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n         .withDeleteMissing(\n             command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n         .withIgnoreFailures(\n             command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n         .withOverwrite(\n             command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n         .withAppend(\n             command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n         .withCRC(\n             command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n         .withBlocking(\n             !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()))\n         .withVerboseLog(\n             command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()))\n         .withDirectWrite(\n             command.hasOption(DistCpOptionSwitch.DIRECT_WRITE.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.DIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseDiff(snapshots[0], snapshots[1]);\n     }\n     if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.RDIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       builder.withFiltersFile(\n           getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       builder.withLogPath(\n           new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       final String workPath \u003d getVal(command,\n           DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         builder.withAtomicWorkPath(new Path(workPath));\n       }\n     }\n     if (command.hasOption(DistCpOptionSwitch.TRACK_MISSING.getSwitch())) {\n       builder.withTrackMissing(\n           new Path(getVal(\n               command,\n               DistCpOptionSwitch.TRACK_MISSING.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n       try {\n         final Float mapBandwidth \u003d Float.parseFloat(\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n         builder.withMapBandwidth(mapBandwidth);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(\n         DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n       try {\n         final Integer numThreads \u003d Integer.parseInt(getVal(command,\n             DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n         builder.withNumListstatusThreads(numThreads);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Number of liststatus threads is invalid: \" + getVal(command,\n                 DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n       try {\n         final Integer maps \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n         builder.maxMaps(maps);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       builder.withCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n       builder.preserve(\n           getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n-    } else {\n-      // No \"preserve\" settings specified. Preserve block-size.\n-      builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n       final String chunkSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n       try {\n         int csize \u003d Integer.parseInt(chunkSizeStr);\n         csize \u003d csize \u003e 0 ? csize : 0;\n         LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n         builder.withBlocksPerChunk(csize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n             + chunkSizeStr, e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n       final String copyBufferSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n       try {\n         int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n         builder.withCopyBufferSize(copyBufferSize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n             + copyBufferSizeStr, e);\n       }\n     }\n \n     return builder.build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n    builder\n        .withAtomicCommit(\n            command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n        .withSyncFolder(\n            command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n        .withDeleteMissing(\n            command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n        .withIgnoreFailures(\n            command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n        .withOverwrite(\n            command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n        .withAppend(\n            command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n        .withCRC(\n            command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n        .withBlocking(\n            !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()))\n        .withVerboseLog(\n            command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()))\n        .withDirectWrite(\n            command.hasOption(DistCpOptionSwitch.DIRECT_WRITE.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      builder.withFiltersFile(\n          getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      builder.withLogPath(\n          new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      final String workPath \u003d getVal(command,\n          DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        builder.withAtomicWorkPath(new Path(workPath));\n      }\n    }\n    if (command.hasOption(DistCpOptionSwitch.TRACK_MISSING.getSwitch())) {\n      builder.withTrackMissing(\n          new Path(getVal(\n              command,\n              DistCpOptionSwitch.TRACK_MISSING.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        final Float mapBandwidth \u003d Float.parseFloat(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n        builder.withMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(\n        DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n      try {\n        final Integer numThreads \u003d Integer.parseInt(getVal(command,\n            DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n        builder.withNumListstatusThreads(numThreads);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Number of liststatus threads is invalid: \" + getVal(command,\n                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        final Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n        builder.maxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      builder.withCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      builder.preserve(\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n      final String chunkSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n      try {\n        int csize \u003d Integer.parseInt(chunkSizeStr);\n        csize \u003d csize \u003e 0 ? csize : 0;\n        LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n        builder.withBlocksPerChunk(csize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n            + chunkSizeStr, e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n      final String copyBufferSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n      try {\n        int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n        builder.withCopyBufferSize(copyBufferSize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n            + copyBufferSizeStr, e);\n      }\n    }\n\n    return builder.build();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "19a001826f6ab9ac2caa92b66864f62218557beb": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9913. DistCp to add -useTrash to move deleted files to Trash.\"\n\nReverting due to test failures if ~/.Trash not present during test setup.\n\nThis reverts commit ee3115f488ce8e44bffac15af9c646190bf67b88.\n\nChange-Id: Icbeeb261570b9131ff99d765ac0945c335b26658\n",
      "commitDate": "17/07/19 5:13 AM",
      "commitName": "19a001826f6ab9ac2caa92b66864f62218557beb",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/07/19 3:50 AM",
      "commitNameOld": "ee3115f488ce8e44bffac15af9c646190bf67b88",
      "commitAuthorOld": "Shen Yinjie",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,159 @@\n   public static DistCpOptions parse(String[] args)\n       throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n     builder\n         .withAtomicCommit(\n             command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n         .withSyncFolder(\n             command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n         .withDeleteMissing(\n             command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n-        .withDeleteUseTrash(\n-            command.hasOption(DistCpOptionSwitch.DELETE_USETRASH.getSwitch()))\n         .withIgnoreFailures(\n             command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n         .withOverwrite(\n             command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n         .withAppend(\n             command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n         .withCRC(\n             command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n         .withBlocking(\n             !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()))\n         .withVerboseLog(\n             command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()))\n         .withDirectWrite(\n             command.hasOption(DistCpOptionSwitch.DIRECT_WRITE.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.DIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseDiff(snapshots[0], snapshots[1]);\n     }\n     if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.RDIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       builder.withFiltersFile(\n           getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       builder.withLogPath(\n           new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       final String workPath \u003d getVal(command,\n           DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         builder.withAtomicWorkPath(new Path(workPath));\n       }\n     }\n     if (command.hasOption(DistCpOptionSwitch.TRACK_MISSING.getSwitch())) {\n       builder.withTrackMissing(\n           new Path(getVal(\n               command,\n               DistCpOptionSwitch.TRACK_MISSING.getSwitch())));\n     }\n-    if (command.hasOption(DistCpOptionSwitch.DELETE_USETRASH.getSwitch())) {\n-      builder.withDeleteUseTrash(true);\n-    }\n \n     if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n       try {\n         final Float mapBandwidth \u003d Float.parseFloat(\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n         builder.withMapBandwidth(mapBandwidth);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(\n         DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n       try {\n         final Integer numThreads \u003d Integer.parseInt(getVal(command,\n             DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n         builder.withNumListstatusThreads(numThreads);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Number of liststatus threads is invalid: \" + getVal(command,\n                 DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n       try {\n         final Integer maps \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n         builder.maxMaps(maps);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       builder.withCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n       builder.preserve(\n           getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n     } else {\n       // No \"preserve\" settings specified. Preserve block-size.\n       builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n       final String chunkSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n       try {\n         int csize \u003d Integer.parseInt(chunkSizeStr);\n         csize \u003d csize \u003e 0 ? csize : 0;\n         LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n         builder.withBlocksPerChunk(csize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n             + chunkSizeStr, e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n       final String copyBufferSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n       try {\n         int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n         builder.withCopyBufferSize(copyBufferSize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n             + copyBufferSizeStr, e);\n       }\n     }\n \n     return builder.build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n    builder\n        .withAtomicCommit(\n            command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n        .withSyncFolder(\n            command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n        .withDeleteMissing(\n            command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n        .withIgnoreFailures(\n            command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n        .withOverwrite(\n            command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n        .withAppend(\n            command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n        .withCRC(\n            command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n        .withBlocking(\n            !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()))\n        .withVerboseLog(\n            command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()))\n        .withDirectWrite(\n            command.hasOption(DistCpOptionSwitch.DIRECT_WRITE.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      builder.withFiltersFile(\n          getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      builder.withLogPath(\n          new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      final String workPath \u003d getVal(command,\n          DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        builder.withAtomicWorkPath(new Path(workPath));\n      }\n    }\n    if (command.hasOption(DistCpOptionSwitch.TRACK_MISSING.getSwitch())) {\n      builder.withTrackMissing(\n          new Path(getVal(\n              command,\n              DistCpOptionSwitch.TRACK_MISSING.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        final Float mapBandwidth \u003d Float.parseFloat(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n        builder.withMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(\n        DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n      try {\n        final Integer numThreads \u003d Integer.parseInt(getVal(command,\n            DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n        builder.withNumListstatusThreads(numThreads);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Number of liststatus threads is invalid: \" + getVal(command,\n                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        final Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n        builder.maxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      builder.withCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      builder.preserve(\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n    } else {\n      // No \"preserve\" settings specified. Preserve block-size.\n      builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n      final String chunkSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n      try {\n        int csize \u003d Integer.parseInt(chunkSizeStr);\n        csize \u003d csize \u003e 0 ? csize : 0;\n        LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n        builder.withBlocksPerChunk(csize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n            + chunkSizeStr, e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n      final String copyBufferSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n      try {\n        int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n        builder.withCopyBufferSize(copyBufferSize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n            + copyBufferSizeStr, e);\n      }\n    }\n\n    return builder.build();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "ee3115f488ce8e44bffac15af9c646190bf67b88": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9913. DistCp to add -useTrash to move deleted files to Trash.\n\nContributed by Shen Yinjie.\n\nChange-Id: I03ac7d22ab1054f8e5de4aa7552909c734438f4a\n",
      "commitDate": "17/07/19 3:50 AM",
      "commitName": "ee3115f488ce8e44bffac15af9c646190bf67b88",
      "commitAuthor": "Shen Yinjie",
      "commitDateOld": "07/02/19 2:07 AM",
      "commitNameOld": "de804e53b9d20a2df75a4c7252bf83ed52011488",
      "commitAuthorOld": "Andrew Olson",
      "daysBetweenCommits": 160.03,
      "commitsBetweenForRepo": 1184,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,159 +1,164 @@\n   public static DistCpOptions parse(String[] args)\n       throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n     builder\n         .withAtomicCommit(\n             command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n         .withSyncFolder(\n             command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n         .withDeleteMissing(\n             command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n+        .withDeleteUseTrash(\n+            command.hasOption(DistCpOptionSwitch.DELETE_USETRASH.getSwitch()))\n         .withIgnoreFailures(\n             command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n         .withOverwrite(\n             command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n         .withAppend(\n             command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n         .withCRC(\n             command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n         .withBlocking(\n             !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()))\n         .withVerboseLog(\n             command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()))\n         .withDirectWrite(\n             command.hasOption(DistCpOptionSwitch.DIRECT_WRITE.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.DIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseDiff(snapshots[0], snapshots[1]);\n     }\n     if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.RDIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       builder.withFiltersFile(\n           getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       builder.withLogPath(\n           new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       final String workPath \u003d getVal(command,\n           DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         builder.withAtomicWorkPath(new Path(workPath));\n       }\n     }\n     if (command.hasOption(DistCpOptionSwitch.TRACK_MISSING.getSwitch())) {\n       builder.withTrackMissing(\n           new Path(getVal(\n               command,\n               DistCpOptionSwitch.TRACK_MISSING.getSwitch())));\n     }\n+    if (command.hasOption(DistCpOptionSwitch.DELETE_USETRASH.getSwitch())) {\n+      builder.withDeleteUseTrash(true);\n+    }\n \n     if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n       try {\n         final Float mapBandwidth \u003d Float.parseFloat(\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n         builder.withMapBandwidth(mapBandwidth);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(\n         DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n       try {\n         final Integer numThreads \u003d Integer.parseInt(getVal(command,\n             DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n         builder.withNumListstatusThreads(numThreads);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Number of liststatus threads is invalid: \" + getVal(command,\n                 DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n       try {\n         final Integer maps \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n         builder.maxMaps(maps);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       builder.withCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n       builder.preserve(\n           getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n     } else {\n       // No \"preserve\" settings specified. Preserve block-size.\n       builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n       final String chunkSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n       try {\n         int csize \u003d Integer.parseInt(chunkSizeStr);\n         csize \u003d csize \u003e 0 ? csize : 0;\n         LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n         builder.withBlocksPerChunk(csize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n             + chunkSizeStr, e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n       final String copyBufferSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n       try {\n         int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n         builder.withCopyBufferSize(copyBufferSize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n             + copyBufferSizeStr, e);\n       }\n     }\n \n     return builder.build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n    builder\n        .withAtomicCommit(\n            command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n        .withSyncFolder(\n            command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n        .withDeleteMissing(\n            command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n        .withDeleteUseTrash(\n            command.hasOption(DistCpOptionSwitch.DELETE_USETRASH.getSwitch()))\n        .withIgnoreFailures(\n            command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n        .withOverwrite(\n            command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n        .withAppend(\n            command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n        .withCRC(\n            command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n        .withBlocking(\n            !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()))\n        .withVerboseLog(\n            command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()))\n        .withDirectWrite(\n            command.hasOption(DistCpOptionSwitch.DIRECT_WRITE.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      builder.withFiltersFile(\n          getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      builder.withLogPath(\n          new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      final String workPath \u003d getVal(command,\n          DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        builder.withAtomicWorkPath(new Path(workPath));\n      }\n    }\n    if (command.hasOption(DistCpOptionSwitch.TRACK_MISSING.getSwitch())) {\n      builder.withTrackMissing(\n          new Path(getVal(\n              command,\n              DistCpOptionSwitch.TRACK_MISSING.getSwitch())));\n    }\n    if (command.hasOption(DistCpOptionSwitch.DELETE_USETRASH.getSwitch())) {\n      builder.withDeleteUseTrash(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        final Float mapBandwidth \u003d Float.parseFloat(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n        builder.withMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(\n        DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n      try {\n        final Integer numThreads \u003d Integer.parseInt(getVal(command,\n            DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n        builder.withNumListstatusThreads(numThreads);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Number of liststatus threads is invalid: \" + getVal(command,\n                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        final Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n        builder.maxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      builder.withCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      builder.preserve(\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n    } else {\n      // No \"preserve\" settings specified. Preserve block-size.\n      builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n      final String chunkSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n      try {\n        int csize \u003d Integer.parseInt(chunkSizeStr);\n        csize \u003d csize \u003e 0 ? csize : 0;\n        LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n        builder.withBlocksPerChunk(csize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n            + chunkSizeStr, e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n      final String copyBufferSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n      try {\n        int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n        builder.withCopyBufferSize(copyBufferSize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n            + copyBufferSizeStr, e);\n      }\n    }\n\n    return builder.build();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "de804e53b9d20a2df75a4c7252bf83ed52011488": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15281. Distcp to add no-rename copy option.\n\nContributed by Andrew Olson.\n",
      "commitDate": "07/02/19 2:07 AM",
      "commitName": "de804e53b9d20a2df75a4c7252bf83ed52011488",
      "commitAuthor": "Andrew Olson",
      "commitDateOld": "15/08/18 8:31 AM",
      "commitNameOld": "3e3963b035911703c61e6d9a2939eb894da5644c",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 175.77,
      "commitsBetweenForRepo": 1362,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,157 +1,159 @@\n   public static DistCpOptions parse(String[] args)\n       throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n     builder\n         .withAtomicCommit(\n             command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n         .withSyncFolder(\n             command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n         .withDeleteMissing(\n             command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n         .withIgnoreFailures(\n             command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n         .withOverwrite(\n             command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n         .withAppend(\n             command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n         .withCRC(\n             command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n         .withBlocking(\n             !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()))\n         .withVerboseLog(\n-            command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()));\n+            command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()))\n+        .withDirectWrite(\n+            command.hasOption(DistCpOptionSwitch.DIRECT_WRITE.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.DIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseDiff(snapshots[0], snapshots[1]);\n     }\n     if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.RDIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       builder.withFiltersFile(\n           getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       builder.withLogPath(\n           new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       final String workPath \u003d getVal(command,\n           DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         builder.withAtomicWorkPath(new Path(workPath));\n       }\n     }\n     if (command.hasOption(DistCpOptionSwitch.TRACK_MISSING.getSwitch())) {\n       builder.withTrackMissing(\n           new Path(getVal(\n               command,\n               DistCpOptionSwitch.TRACK_MISSING.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n       try {\n         final Float mapBandwidth \u003d Float.parseFloat(\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n         builder.withMapBandwidth(mapBandwidth);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(\n         DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n       try {\n         final Integer numThreads \u003d Integer.parseInt(getVal(command,\n             DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n         builder.withNumListstatusThreads(numThreads);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Number of liststatus threads is invalid: \" + getVal(command,\n                 DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n       try {\n         final Integer maps \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n         builder.maxMaps(maps);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       builder.withCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n       builder.preserve(\n           getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n     } else {\n       // No \"preserve\" settings specified. Preserve block-size.\n       builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n       final String chunkSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n       try {\n         int csize \u003d Integer.parseInt(chunkSizeStr);\n         csize \u003d csize \u003e 0 ? csize : 0;\n         LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n         builder.withBlocksPerChunk(csize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n             + chunkSizeStr, e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n       final String copyBufferSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n       try {\n         int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n         builder.withCopyBufferSize(copyBufferSize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n             + copyBufferSizeStr, e);\n       }\n     }\n \n     return builder.build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n    builder\n        .withAtomicCommit(\n            command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n        .withSyncFolder(\n            command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n        .withDeleteMissing(\n            command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n        .withIgnoreFailures(\n            command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n        .withOverwrite(\n            command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n        .withAppend(\n            command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n        .withCRC(\n            command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n        .withBlocking(\n            !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()))\n        .withVerboseLog(\n            command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()))\n        .withDirectWrite(\n            command.hasOption(DistCpOptionSwitch.DIRECT_WRITE.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      builder.withFiltersFile(\n          getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      builder.withLogPath(\n          new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      final String workPath \u003d getVal(command,\n          DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        builder.withAtomicWorkPath(new Path(workPath));\n      }\n    }\n    if (command.hasOption(DistCpOptionSwitch.TRACK_MISSING.getSwitch())) {\n      builder.withTrackMissing(\n          new Path(getVal(\n              command,\n              DistCpOptionSwitch.TRACK_MISSING.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        final Float mapBandwidth \u003d Float.parseFloat(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n        builder.withMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(\n        DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n      try {\n        final Integer numThreads \u003d Integer.parseInt(getVal(command,\n            DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n        builder.withNumListstatusThreads(numThreads);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Number of liststatus threads is invalid: \" + getVal(command,\n                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        final Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n        builder.maxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      builder.withCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      builder.preserve(\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n    } else {\n      // No \"preserve\" settings specified. Preserve block-size.\n      builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n      final String chunkSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n      try {\n        int csize \u003d Integer.parseInt(chunkSizeStr);\n        csize \u003d csize \u003e 0 ? csize : 0;\n        LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n        builder.withBlocksPerChunk(csize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n            + chunkSizeStr, e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n      final String copyBufferSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n      try {\n        int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n        builder.withCopyBufferSize(copyBufferSize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n            + copyBufferSizeStr, e);\n      }\n    }\n\n    return builder.build();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "1976e0066e9ae8852715fa69d8aea3769330e933": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15209. DistCp to eliminate needless deletion of files under already-deleted directories.\nContributed by Steve Loughran.\n",
      "commitDate": "15/03/18 11:05 AM",
      "commitName": "1976e0066e9ae8852715fa69d8aea3769330e933",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/09/17 11:34 PM",
      "commitNameOld": "63720ef574df6d79a9bab0628edb915d1e3a7c30",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 190.48,
      "commitsBetweenForRepo": 1385,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,157 @@\n   public static DistCpOptions parse(String[] args)\n       throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n     builder\n         .withAtomicCommit(\n             command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n         .withSyncFolder(\n             command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n         .withDeleteMissing(\n             command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n         .withIgnoreFailures(\n             command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n         .withOverwrite(\n             command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n         .withAppend(\n             command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n         .withCRC(\n             command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n         .withBlocking(\n             !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()))\n         .withVerboseLog(\n             command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.DIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseDiff(snapshots[0], snapshots[1]);\n     }\n     if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.RDIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       builder.withFiltersFile(\n           getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       builder.withLogPath(\n           new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       final String workPath \u003d getVal(command,\n           DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         builder.withAtomicWorkPath(new Path(workPath));\n       }\n     }\n+    if (command.hasOption(DistCpOptionSwitch.TRACK_MISSING.getSwitch())) {\n+      builder.withTrackMissing(\n+          new Path(getVal(\n+              command,\n+              DistCpOptionSwitch.TRACK_MISSING.getSwitch())));\n+    }\n \n     if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n       try {\n         final Float mapBandwidth \u003d Float.parseFloat(\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n         builder.withMapBandwidth(mapBandwidth);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(\n         DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n       try {\n         final Integer numThreads \u003d Integer.parseInt(getVal(command,\n             DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n         builder.withNumListstatusThreads(numThreads);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Number of liststatus threads is invalid: \" + getVal(command,\n                 DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n       try {\n         final Integer maps \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n         builder.maxMaps(maps);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       builder.withCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n       builder.preserve(\n           getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n     } else {\n       // No \"preserve\" settings specified. Preserve block-size.\n       builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n       final String chunkSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n       try {\n         int csize \u003d Integer.parseInt(chunkSizeStr);\n         csize \u003d csize \u003e 0 ? csize : 0;\n         LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n         builder.withBlocksPerChunk(csize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n             + chunkSizeStr, e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n       final String copyBufferSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n       try {\n         int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n         builder.withCopyBufferSize(copyBufferSize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n             + copyBufferSizeStr, e);\n       }\n     }\n \n     return builder.build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n    builder\n        .withAtomicCommit(\n            command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n        .withSyncFolder(\n            command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n        .withDeleteMissing(\n            command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n        .withIgnoreFailures(\n            command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n        .withOverwrite(\n            command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n        .withAppend(\n            command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n        .withCRC(\n            command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n        .withBlocking(\n            !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()))\n        .withVerboseLog(\n            command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      builder.withFiltersFile(\n          getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      builder.withLogPath(\n          new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      final String workPath \u003d getVal(command,\n          DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        builder.withAtomicWorkPath(new Path(workPath));\n      }\n    }\n    if (command.hasOption(DistCpOptionSwitch.TRACK_MISSING.getSwitch())) {\n      builder.withTrackMissing(\n          new Path(getVal(\n              command,\n              DistCpOptionSwitch.TRACK_MISSING.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        final Float mapBandwidth \u003d Float.parseFloat(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n        builder.withMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(\n        DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n      try {\n        final Integer numThreads \u003d Integer.parseInt(getVal(command,\n            DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n        builder.withNumListstatusThreads(numThreads);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Number of liststatus threads is invalid: \" + getVal(command,\n                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        final Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n        builder.maxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      builder.withCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      builder.preserve(\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n    } else {\n      // No \"preserve\" settings specified. Preserve block-size.\n      builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n      final String chunkSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n      try {\n        int csize \u003d Integer.parseInt(chunkSizeStr);\n        csize \u003d csize \u003e 0 ? csize : 0;\n        LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n        builder.withBlocksPerChunk(csize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n            + chunkSizeStr, e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n      final String copyBufferSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n      try {\n        int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n        builder.withCopyBufferSize(copyBufferSize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n            + copyBufferSizeStr, e);\n      }\n    }\n\n    return builder.build();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "63720ef574df6d79a9bab0628edb915d1e3a7c30": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14839. DistCp log output should contain copied and deleted files and directories. Contributed by Yiqun Lin.\n",
      "commitDate": "05/09/17 11:34 PM",
      "commitName": "63720ef574df6d79a9bab0628edb915d1e3a7c30",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "20/06/17 7:53 AM",
      "commitNameOld": "dd65eea74b1f9dde858ff34df8111e5340115511",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 77.65,
      "commitsBetweenForRepo": 539,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,151 @@\n   public static DistCpOptions parse(String[] args)\n       throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n     builder\n         .withAtomicCommit(\n             command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n         .withSyncFolder(\n             command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n         .withDeleteMissing(\n             command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n         .withIgnoreFailures(\n             command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n         .withOverwrite(\n             command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n         .withAppend(\n             command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n         .withCRC(\n             command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n         .withBlocking(\n-            !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()));\n+            !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()))\n+        .withVerboseLog(\n+            command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.DIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseDiff(snapshots[0], snapshots[1]);\n     }\n     if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.RDIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       builder.withFiltersFile(\n           getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       builder.withLogPath(\n           new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       final String workPath \u003d getVal(command,\n           DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         builder.withAtomicWorkPath(new Path(workPath));\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n       try {\n         final Float mapBandwidth \u003d Float.parseFloat(\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n         builder.withMapBandwidth(mapBandwidth);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(\n         DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n       try {\n         final Integer numThreads \u003d Integer.parseInt(getVal(command,\n             DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n         builder.withNumListstatusThreads(numThreads);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Number of liststatus threads is invalid: \" + getVal(command,\n                 DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n       try {\n         final Integer maps \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n         builder.maxMaps(maps);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       builder.withCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n       builder.preserve(\n           getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n     } else {\n       // No \"preserve\" settings specified. Preserve block-size.\n       builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n       final String chunkSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n       try {\n         int csize \u003d Integer.parseInt(chunkSizeStr);\n         csize \u003d csize \u003e 0 ? csize : 0;\n         LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n         builder.withBlocksPerChunk(csize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n             + chunkSizeStr, e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n       final String copyBufferSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n       try {\n         int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n         builder.withCopyBufferSize(copyBufferSize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n             + copyBufferSizeStr, e);\n       }\n     }\n \n     return builder.build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n    builder\n        .withAtomicCommit(\n            command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n        .withSyncFolder(\n            command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n        .withDeleteMissing(\n            command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n        .withIgnoreFailures(\n            command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n        .withOverwrite(\n            command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n        .withAppend(\n            command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n        .withCRC(\n            command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n        .withBlocking(\n            !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()))\n        .withVerboseLog(\n            command.hasOption(DistCpOptionSwitch.VERBOSE_LOG.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      builder.withFiltersFile(\n          getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      builder.withLogPath(\n          new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      final String workPath \u003d getVal(command,\n          DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        builder.withAtomicWorkPath(new Path(workPath));\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        final Float mapBandwidth \u003d Float.parseFloat(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n        builder.withMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(\n        DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n      try {\n        final Integer numThreads \u003d Integer.parseInt(getVal(command,\n            DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n        builder.withNumListstatusThreads(numThreads);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Number of liststatus threads is invalid: \" + getVal(command,\n                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        final Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n        builder.maxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      builder.withCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      builder.preserve(\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n    } else {\n      // No \"preserve\" settings specified. Preserve block-size.\n      builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n      final String chunkSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n      try {\n        int csize \u003d Integer.parseInt(chunkSizeStr);\n        csize \u003d csize \u003e 0 ? csize : 0;\n        LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n        builder.withBlocksPerChunk(csize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n            + chunkSizeStr, e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n      final String copyBufferSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n      try {\n        int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n        builder.withCopyBufferSize(copyBufferSize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n            + copyBufferSizeStr, e);\n      }\n    }\n\n    return builder.build();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "dd65eea74b1f9dde858ff34df8111e5340115511": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8143. Change distcp to have -pb on by default. Contributed by Mithun Radhakrishnan\n",
      "commitDate": "20/06/17 7:53 AM",
      "commitName": "dd65eea74b1f9dde858ff34df8111e5340115511",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "18/05/17 3:35 PM",
      "commitNameOld": "b4adc8392c1314d6d6fbdd00f2afb306ef20a650",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 32.68,
      "commitsBetweenForRepo": 153,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,149 @@\n   public static DistCpOptions parse(String[] args)\n       throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n     builder\n         .withAtomicCommit(\n             command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n         .withSyncFolder(\n             command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n         .withDeleteMissing(\n             command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n         .withIgnoreFailures(\n             command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n         .withOverwrite(\n             command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n         .withAppend(\n             command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n         .withCRC(\n             command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n         .withBlocking(\n             !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.DIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseDiff(snapshots[0], snapshots[1]);\n     }\n     if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.RDIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       builder.withFiltersFile(\n           getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       builder.withLogPath(\n           new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       final String workPath \u003d getVal(command,\n           DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         builder.withAtomicWorkPath(new Path(workPath));\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n       try {\n         final Float mapBandwidth \u003d Float.parseFloat(\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n         builder.withMapBandwidth(mapBandwidth);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(\n         DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n       try {\n         final Integer numThreads \u003d Integer.parseInt(getVal(command,\n             DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n         builder.withNumListstatusThreads(numThreads);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Number of liststatus threads is invalid: \" + getVal(command,\n                 DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n       try {\n         final Integer maps \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n         builder.maxMaps(maps);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       builder.withCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n       builder.preserve(\n           getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n+    } else {\n+      // No \"preserve\" settings specified. Preserve block-size.\n+      builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n       final String chunkSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n       try {\n         int csize \u003d Integer.parseInt(chunkSizeStr);\n         csize \u003d csize \u003e 0 ? csize : 0;\n         LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n         builder.withBlocksPerChunk(csize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n             + chunkSizeStr, e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n       final String copyBufferSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n       try {\n         int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n         builder.withCopyBufferSize(copyBufferSize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n             + copyBufferSizeStr, e);\n       }\n     }\n \n     return builder.build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n    builder\n        .withAtomicCommit(\n            command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n        .withSyncFolder(\n            command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n        .withDeleteMissing(\n            command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n        .withIgnoreFailures(\n            command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n        .withOverwrite(\n            command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n        .withAppend(\n            command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n        .withCRC(\n            command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n        .withBlocking(\n            !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      builder.withFiltersFile(\n          getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      builder.withLogPath(\n          new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      final String workPath \u003d getVal(command,\n          DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        builder.withAtomicWorkPath(new Path(workPath));\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        final Float mapBandwidth \u003d Float.parseFloat(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n        builder.withMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(\n        DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n      try {\n        final Integer numThreads \u003d Integer.parseInt(getVal(command,\n            DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n        builder.withNumListstatusThreads(numThreads);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Number of liststatus threads is invalid: \" + getVal(command,\n                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        final Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n        builder.maxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      builder.withCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      builder.preserve(\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n    } else {\n      // No \"preserve\" settings specified. Preserve block-size.\n      builder.preserve(DistCpOptions.FileAttribute.BLOCKSIZE);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n      final String chunkSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n      try {\n        int csize \u003d Integer.parseInt(chunkSizeStr);\n        csize \u003d csize \u003e 0 ? csize : 0;\n        LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n        builder.withBlocksPerChunk(csize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n            + chunkSizeStr, e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n      final String copyBufferSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n      try {\n        int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n        builder.withCopyBufferSize(copyBufferSize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n            + copyBufferSizeStr, e);\n      }\n    }\n\n    return builder.build();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "b4adc8392c1314d6d6fbdd00f2afb306ef20a650": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14407. DistCp - Introduce a configurable copy buffer size. (Omkar Aradhya K S via Yongjun Zhang)\n",
      "commitDate": "18/05/17 3:35 PM",
      "commitName": "b4adc8392c1314d6d6fbdd00f2afb306ef20a650",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "31/03/17 8:04 PM",
      "commitNameOld": "26172a94d6431e70d7fe15d66be9a7e195f79f60",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 47.81,
      "commitsBetweenForRepo": 260,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,146 @@\n   public static DistCpOptions parse(String[] args)\n       throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n     builder\n         .withAtomicCommit(\n             command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n         .withSyncFolder(\n             command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n         .withDeleteMissing(\n             command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n         .withIgnoreFailures(\n             command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n         .withOverwrite(\n             command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n         .withAppend(\n             command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n         .withCRC(\n             command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n         .withBlocking(\n             !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.DIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseDiff(snapshots[0], snapshots[1]);\n     }\n     if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.RDIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       builder.withUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       builder.withFiltersFile(\n           getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       builder.withLogPath(\n           new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       final String workPath \u003d getVal(command,\n           DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         builder.withAtomicWorkPath(new Path(workPath));\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n       try {\n         final Float mapBandwidth \u003d Float.parseFloat(\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n         builder.withMapBandwidth(mapBandwidth);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(\n         DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n       try {\n         final Integer numThreads \u003d Integer.parseInt(getVal(command,\n             DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n         builder.withNumListstatusThreads(numThreads);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\n             \"Number of liststatus threads is invalid: \" + getVal(command,\n                 DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n       try {\n         final Integer maps \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n         builder.maxMaps(maps);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       builder.withCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n       builder.preserve(\n           getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n       LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n           \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n       final String chunkSizeStr \u003d getVal(command,\n           DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n       try {\n         int csize \u003d Integer.parseInt(chunkSizeStr);\n         csize \u003d csize \u003e 0 ? csize : 0;\n         LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n         builder.withBlocksPerChunk(csize);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n             + chunkSizeStr, e);\n       }\n     }\n \n+    if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n+      final String copyBufferSizeStr \u003d getVal(command,\n+          DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n+      try {\n+        int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n+        builder.withCopyBufferSize(copyBufferSize);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n+            + copyBufferSizeStr, e);\n+      }\n+    }\n+\n     return builder.build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n    builder\n        .withAtomicCommit(\n            command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n        .withSyncFolder(\n            command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n        .withDeleteMissing(\n            command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n        .withIgnoreFailures(\n            command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n        .withOverwrite(\n            command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n        .withAppend(\n            command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n        .withCRC(\n            command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n        .withBlocking(\n            !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      builder.withFiltersFile(\n          getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      builder.withLogPath(\n          new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      final String workPath \u003d getVal(command,\n          DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        builder.withAtomicWorkPath(new Path(workPath));\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        final Float mapBandwidth \u003d Float.parseFloat(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n        builder.withMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(\n        DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n      try {\n        final Integer numThreads \u003d Integer.parseInt(getVal(command,\n            DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n        builder.withNumListstatusThreads(numThreads);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Number of liststatus threads is invalid: \" + getVal(command,\n                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        final Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n        builder.maxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      builder.withCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      builder.preserve(\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n      final String chunkSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n      try {\n        int csize \u003d Integer.parseInt(chunkSizeStr);\n        csize \u003d csize \u003e 0 ? csize : 0;\n        LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n        builder.withBlocksPerChunk(csize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n            + chunkSizeStr, e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch())) {\n      final String copyBufferSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.COPY_BUFFER_SIZE.getSwitch().trim());\n      try {\n        int copyBufferSize \u003d Integer.parseInt(copyBufferSizeStr);\n        builder.withCopyBufferSize(copyBufferSize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"copyBufferSize is invalid: \"\n            + copyBufferSizeStr, e);\n      }\n    }\n\n    return builder.build();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "26172a94d6431e70d7fe15d66be9a7e195f79f60": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14267. Make DistCpOptions immutable. Contributed by Mingliang Liu\n",
      "commitDate": "31/03/17 8:04 PM",
      "commitName": "26172a94d6431e70d7fe15d66be9a7e195f79f60",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "30/03/17 5:38 PM",
      "commitNameOld": "bf3fb585aaf2b179836e139c041fc87920a3c886",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 1.1,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,134 @@\n   public static DistCpOptions parse(String[] args)\n       throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n-    DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n-\n-    option.setIgnoreFailures(\n-        command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n-\n-    option.setAtomicCommit(\n-        command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n-\n-    option.setSyncFolder(\n-        command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n-\n-    option.setOverwrite(\n-        command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n-\n-    option.setAppend(\n-        command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n-\n-    option.setDeleteMissing(\n-        command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n-\n-    option.setSkipCRC(\n-        command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n-\n-    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n-        option.shouldAtomicCommit()) {\n-      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n-      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n-        option.setAtomicWorkPath(new Path(workPath));\n-      }\n-    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n-      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n-    }\n-\n-    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n-      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n-    }\n-\n-\n-    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n-      option.setBlocking(false);\n-    }\n-\n-    parseBandwidth(command, option);\n-\n-    parseNumListStatusThreads(command, option);\n-\n-    parseMaxMaps(command, option);\n-\n-    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n-      option.setCopyStrategy(\n-            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n-    }\n-\n-    parsePreserveStatus(command, option);\n+    DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n+    builder\n+        .withAtomicCommit(\n+            command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n+        .withSyncFolder(\n+            command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n+        .withDeleteMissing(\n+            command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n+        .withIgnoreFailures(\n+            command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n+        .withOverwrite(\n+            command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n+        .withAppend(\n+            command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n+        .withCRC(\n+            command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n+        .withBlocking(\n+            !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.DIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n-      option.setUseDiff(snapshots[0], snapshots[1]);\n+      builder.withUseDiff(snapshots[0], snapshots[1]);\n     }\n     if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.RDIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n-      option.setUseRdiff(snapshots[0], snapshots[1]);\n+      builder.withUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n-    parseFileLimit(command);\n-\n-    parseSizeLimit(command);\n-\n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n-      option.setFiltersFile(getVal(command,\n-          DistCpOptionSwitch.FILTERS.getSwitch()));\n+      builder.withFiltersFile(\n+          getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n-    parseBlocksPerChunk(command, option);\n+    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n+      builder.withLogPath(\n+          new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n+    }\n \n-    option.validate();\n+    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n+      final String workPath \u003d getVal(command,\n+          DistCpOptionSwitch.WORK_PATH.getSwitch());\n+      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n+        builder.withAtomicWorkPath(new Path(workPath));\n+      }\n+    }\n \n-    return option;\n+    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n+      try {\n+        final Float mapBandwidth \u003d Float.parseFloat(\n+            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n+        builder.withMapBandwidth(mapBandwidth);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n+            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n+      }\n+    }\n+\n+    if (command.hasOption(\n+        DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n+      try {\n+        final Integer numThreads \u003d Integer.parseInt(getVal(command,\n+            DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n+        builder.withNumListstatusThreads(numThreads);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(\n+            \"Number of liststatus threads is invalid: \" + getVal(command,\n+                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n+      }\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n+      try {\n+        final Integer maps \u003d Integer.parseInt(\n+            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n+        builder.maxMaps(maps);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n+            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n+      }\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n+      builder.withCopyStrategy(\n+            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n+      builder.preserve(\n+          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n+      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n+          \" option. Ignoring.\");\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n+      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n+          \" option. Ignoring.\");\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n+      final String chunkSizeStr \u003d getVal(command,\n+          DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n+      try {\n+        int csize \u003d Integer.parseInt(chunkSizeStr);\n+        csize \u003d csize \u003e 0 ? csize : 0;\n+        LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n+        builder.withBlocksPerChunk(csize);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n+            + chunkSizeStr, e);\n+      }\n+    }\n+\n+    return builder.build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions.Builder builder \u003d parseSourceAndTargetPaths(command);\n    builder\n        .withAtomicCommit(\n            command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()))\n        .withSyncFolder(\n            command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()))\n        .withDeleteMissing(\n            command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()))\n        .withIgnoreFailures(\n            command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()))\n        .withOverwrite(\n            command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()))\n        .withAppend(\n            command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()))\n        .withCRC(\n            command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()))\n        .withBlocking(\n            !command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      builder.withUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      builder.withFiltersFile(\n          getVal(command, DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      builder.withLogPath(\n          new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      final String workPath \u003d getVal(command,\n          DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        builder.withAtomicWorkPath(new Path(workPath));\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        final Float mapBandwidth \u003d Float.parseFloat(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()));\n        builder.withMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(\n        DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n      try {\n        final Integer numThreads \u003d Integer.parseInt(getVal(command,\n            DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()));\n        builder.withNumListstatusThreads(numThreads);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Number of liststatus threads is invalid: \" + getVal(command,\n                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        final Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()));\n        builder.maxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      builder.withCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      builder.preserve(\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n          \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch())) {\n      final String chunkSizeStr \u003d getVal(command,\n          DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch().trim());\n      try {\n        int csize \u003d Integer.parseInt(chunkSizeStr);\n        csize \u003d csize \u003e 0 ? csize : 0;\n        LOG.info(\"Set distcp blocksPerChunk to \" + csize);\n        builder.withBlocksPerChunk(csize);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"blocksPerChunk is invalid: \"\n            + chunkSizeStr, e);\n      }\n    }\n\n    return builder.build();\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "bf3fb585aaf2b179836e139c041fc87920a3c886": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11794. Enable distcp to copy blocks in parallel. Contributed by Yongjun Zhang, Wei-Chiu Chuang, Xiao Chen, Rosie Li.\n",
      "commitDate": "30/03/17 5:38 PM",
      "commitName": "bf3fb585aaf2b179836e139c041fc87920a3c886",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "30/03/17 5:38 PM",
      "commitNameOld": "144f1cf76527e6c75aec77ef683a898580f3cc8d",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,96 @@\n   public static DistCpOptions parse(String[] args)\n       throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n \n     option.setIgnoreFailures(\n         command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n \n     option.setAtomicCommit(\n         command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n \n     option.setSyncFolder(\n         command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n \n     option.setOverwrite(\n         command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n \n     option.setAppend(\n         command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n \n     option.setDeleteMissing(\n         command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n \n     option.setSkipCRC(\n         command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n     parseBandwidth(command, option);\n \n     parseNumListStatusThreads(command, option);\n \n     parseMaxMaps(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     parsePreserveStatus(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.DIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       option.setUseDiff(snapshots[0], snapshots[1]);\n     }\n     if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.RDIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       option.setUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     parseFileLimit(command);\n \n     parseSizeLimit(command);\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       option.setFiltersFile(getVal(command,\n           DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n+    parseBlocksPerChunk(command, option);\n+\n     option.validate();\n \n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n\n    option.setIgnoreFailures(\n        command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n\n    option.setAtomicCommit(\n        command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n\n    option.setSyncFolder(\n        command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n\n    option.setOverwrite(\n        command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n\n    option.setAppend(\n        command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n\n    option.setDeleteMissing(\n        command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n\n    option.setSkipCRC(\n        command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    parseBandwidth(command, option);\n\n    parseNumListStatusThreads(command, option);\n\n    parseMaxMaps(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    parsePreserveStatus(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      option.setUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      option.setUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    parseFileLimit(command);\n\n    parseSizeLimit(command);\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      option.setFiltersFile(getVal(command,\n          DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    parseBlocksPerChunk(command, option);\n\n    option.validate();\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "144f1cf76527e6c75aec77ef683a898580f3cc8d": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-11794. Enable distcp to copy blocks in parallel. Contributed by Yongjun Zhang, Wei-Chiu Chuang, Xiao Chen.\"\n\nThis reverts commit 064c8b25eca9bc825dc07a54d9147d65c9290a03.\n",
      "commitDate": "30/03/17 5:38 PM",
      "commitName": "144f1cf76527e6c75aec77ef683a898580f3cc8d",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "30/03/17 5:01 PM",
      "commitNameOld": "064c8b25eca9bc825dc07a54d9147d65c9290a03",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,94 @@\n   public static DistCpOptions parse(String[] args)\n       throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n \n     option.setIgnoreFailures(\n         command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n \n     option.setAtomicCommit(\n         command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n \n     option.setSyncFolder(\n         command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n \n     option.setOverwrite(\n         command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n \n     option.setAppend(\n         command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n \n     option.setDeleteMissing(\n         command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n \n     option.setSkipCRC(\n         command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n     parseBandwidth(command, option);\n \n     parseNumListStatusThreads(command, option);\n \n     parseMaxMaps(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     parsePreserveStatus(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.DIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       option.setUseDiff(snapshots[0], snapshots[1]);\n     }\n     if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.RDIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       option.setUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     parseFileLimit(command);\n \n     parseSizeLimit(command);\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       option.setFiltersFile(getVal(command,\n           DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n-    parseBlocksPerChunk(command, option);\n-\n     option.validate();\n \n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n\n    option.setIgnoreFailures(\n        command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n\n    option.setAtomicCommit(\n        command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n\n    option.setSyncFolder(\n        command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n\n    option.setOverwrite(\n        command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n\n    option.setAppend(\n        command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n\n    option.setDeleteMissing(\n        command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n\n    option.setSkipCRC(\n        command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    parseBandwidth(command, option);\n\n    parseNumListStatusThreads(command, option);\n\n    parseMaxMaps(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    parsePreserveStatus(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      option.setUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      option.setUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    parseFileLimit(command);\n\n    parseSizeLimit(command);\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      option.setFiltersFile(getVal(command,\n          DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    option.validate();\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "064c8b25eca9bc825dc07a54d9147d65c9290a03": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11794. Enable distcp to copy blocks in parallel. Contributed by Yongjun Zhang, Wei-Chiu Chuang, Xiao Chen.\n",
      "commitDate": "30/03/17 5:01 PM",
      "commitName": "064c8b25eca9bc825dc07a54d9147d65c9290a03",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "19/10/16 5:37 PM",
      "commitNameOld": "8650cc84f20e7d8c32dcdcd91c94372d476e2276",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 161.97,
      "commitsBetweenForRepo": 997,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,96 @@\n   public static DistCpOptions parse(String[] args)\n       throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n \n     option.setIgnoreFailures(\n         command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n \n     option.setAtomicCommit(\n         command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n \n     option.setSyncFolder(\n         command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n \n     option.setOverwrite(\n         command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n \n     option.setAppend(\n         command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n \n     option.setDeleteMissing(\n         command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n \n     option.setSkipCRC(\n         command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n     parseBandwidth(command, option);\n \n     parseNumListStatusThreads(command, option);\n \n     parseMaxMaps(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     parsePreserveStatus(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.DIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       option.setUseDiff(snapshots[0], snapshots[1]);\n     }\n     if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command,\n           DistCpOptionSwitch.RDIFF.getSwitch());\n       checkSnapshotsArgs(snapshots);\n       option.setUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     parseFileLimit(command);\n \n     parseSizeLimit(command);\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       option.setFiltersFile(getVal(command,\n           DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n+    parseBlocksPerChunk(command, option);\n+\n     option.validate();\n \n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n\n    option.setIgnoreFailures(\n        command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n\n    option.setAtomicCommit(\n        command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n\n    option.setSyncFolder(\n        command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n\n    option.setOverwrite(\n        command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n\n    option.setAppend(\n        command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n\n    option.setDeleteMissing(\n        command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n\n    option.setSkipCRC(\n        command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    parseBandwidth(command, option);\n\n    parseNumListStatusThreads(command, option);\n\n    parseMaxMaps(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    parsePreserveStatus(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      option.setUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      option.setUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    parseFileLimit(command);\n\n    parseSizeLimit(command);\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      option.setFiltersFile(getVal(command,\n          DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    parseBlocksPerChunk(command, option);\n\n    option.validate();\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "8650cc84f20e7d8c32dcdcd91c94372d476e2276": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9820. Improve distcp to support efficient restore to an earlier snapshot. Contributed by Yongjun Zhang.\n",
      "commitDate": "19/10/16 5:37 PM",
      "commitName": "8650cc84f20e7d8c32dcdcd91c94372d476e2276",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "17/10/16 10:47 PM",
      "commitNameOld": "0bc6d37f3c1e7c2a8682dffa95461a884bd6ba17",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 1.78,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,94 @@\n-  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n+  public static DistCpOptions parse(String[] args)\n+      throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n \n     option.setIgnoreFailures(\n         command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n \n     option.setAtomicCommit(\n         command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n \n     option.setSyncFolder(\n         command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n \n     option.setOverwrite(\n         command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n \n     option.setAppend(\n         command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n \n     option.setDeleteMissing(\n         command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n \n     option.setSkipCRC(\n         command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n     parseBandwidth(command, option);\n \n     parseNumListStatusThreads(command, option);\n \n     parseMaxMaps(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     parsePreserveStatus(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n-      String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n-      Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n-          \"Must provide both the starting and ending snapshot names\");\n-      option.setUseDiff(true, snapshots[0], snapshots[1]);\n+      String[] snapshots \u003d getVals(command,\n+          DistCpOptionSwitch.DIFF.getSwitch());\n+      checkSnapshotsArgs(snapshots);\n+      option.setUseDiff(snapshots[0], snapshots[1]);\n+    }\n+    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n+      String[] snapshots \u003d getVals(command,\n+          DistCpOptionSwitch.RDIFF.getSwitch());\n+      checkSnapshotsArgs(snapshots);\n+      option.setUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     parseFileLimit(command);\n \n     parseSizeLimit(command);\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       option.setFiltersFile(getVal(command,\n           DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     option.validate();\n \n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n\n    option.setIgnoreFailures(\n        command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n\n    option.setAtomicCommit(\n        command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n\n    option.setSyncFolder(\n        command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n\n    option.setOverwrite(\n        command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n\n    option.setAppend(\n        command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n\n    option.setDeleteMissing(\n        command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n\n    option.setSkipCRC(\n        command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    parseBandwidth(command, option);\n\n    parseNumListStatusThreads(command, option);\n\n    parseMaxMaps(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    parsePreserveStatus(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      option.setUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      option.setUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    parseFileLimit(command);\n\n    parseSizeLimit(command);\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      option.setFiltersFile(getVal(command,\n          DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    option.validate();\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "0bc6d37f3c1e7c2a8682dffa95461a884bd6ba17": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9820. Improve distcp to support efficient restore to an earlier snapshot. Contributed by Yongjun Zhang.\"\n\nThis reverts commit 412c4c9a342b73bf1c1a7f43ea91245cbf94d02d.\n",
      "commitDate": "17/10/16 10:47 PM",
      "commitName": "0bc6d37f3c1e7c2a8682dffa95461a884bd6ba17",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "17/10/16 11:04 AM",
      "commitNameOld": "412c4c9a342b73bf1c1a7f43ea91245cbf94d02d",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 0.49,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,87 @@\n-  public static DistCpOptions parse(String[] args)\n-      throws IllegalArgumentException {\n+  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n \n     option.setIgnoreFailures(\n         command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n \n     option.setAtomicCommit(\n         command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n \n     option.setSyncFolder(\n         command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n \n     option.setOverwrite(\n         command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n \n     option.setAppend(\n         command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n \n     option.setDeleteMissing(\n         command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n \n     option.setSkipCRC(\n         command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n     parseBandwidth(command, option);\n \n     parseNumListStatusThreads(command, option);\n \n     parseMaxMaps(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     parsePreserveStatus(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n-      String[] snapshots \u003d getVals(command,\n-          DistCpOptionSwitch.DIFF.getSwitch());\n-      checkSnapshotsArgs(snapshots);\n-      option.setUseDiff(snapshots[0], snapshots[1]);\n-    }\n-    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n-      String[] snapshots \u003d getVals(command,\n-          DistCpOptionSwitch.RDIFF.getSwitch());\n-      checkSnapshotsArgs(snapshots);\n-      option.setUseRdiff(snapshots[0], snapshots[1]);\n+      String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n+      Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n+          \"Must provide both the starting and ending snapshot names\");\n+      option.setUseDiff(true, snapshots[0], snapshots[1]);\n     }\n \n     parseFileLimit(command);\n \n     parseSizeLimit(command);\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       option.setFiltersFile(getVal(command,\n           DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     option.validate();\n \n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n\n    option.setIgnoreFailures(\n        command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n\n    option.setAtomicCommit(\n        command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n\n    option.setSyncFolder(\n        command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n\n    option.setOverwrite(\n        command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n\n    option.setAppend(\n        command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n\n    option.setDeleteMissing(\n        command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n\n    option.setSkipCRC(\n        command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    parseBandwidth(command, option);\n\n    parseNumListStatusThreads(command, option);\n\n    parseMaxMaps(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    parsePreserveStatus(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n      Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n          \"Must provide both the starting and ending snapshot names\");\n      option.setUseDiff(true, snapshots[0], snapshots[1]);\n    }\n\n    parseFileLimit(command);\n\n    parseSizeLimit(command);\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      option.setFiltersFile(getVal(command,\n          DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    option.validate();\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "412c4c9a342b73bf1c1a7f43ea91245cbf94d02d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9820. Improve distcp to support efficient restore to an earlier snapshot. Contributed by Yongjun Zhang.\n",
      "commitDate": "17/10/16 11:04 AM",
      "commitName": "412c4c9a342b73bf1c1a7f43ea91245cbf94d02d",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "17/05/16 3:46 PM",
      "commitNameOld": "03788d3015c962eac1a35fa5df39356e8b84731c",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 152.8,
      "commitsBetweenForRepo": 1134,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,94 @@\n-  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n+  public static DistCpOptions parse(String[] args)\n+      throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n \n     option.setIgnoreFailures(\n         command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n \n     option.setAtomicCommit(\n         command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n \n     option.setSyncFolder(\n         command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n \n     option.setOverwrite(\n         command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n \n     option.setAppend(\n         command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n \n     option.setDeleteMissing(\n         command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n \n     option.setSkipCRC(\n         command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n     parseBandwidth(command, option);\n \n     parseNumListStatusThreads(command, option);\n \n     parseMaxMaps(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     parsePreserveStatus(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n-      String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n-      Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n-          \"Must provide both the starting and ending snapshot names\");\n-      option.setUseDiff(true, snapshots[0], snapshots[1]);\n+      String[] snapshots \u003d getVals(command,\n+          DistCpOptionSwitch.DIFF.getSwitch());\n+      checkSnapshotsArgs(snapshots);\n+      option.setUseDiff(snapshots[0], snapshots[1]);\n+    }\n+    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n+      String[] snapshots \u003d getVals(command,\n+          DistCpOptionSwitch.RDIFF.getSwitch());\n+      checkSnapshotsArgs(snapshots);\n+      option.setUseRdiff(snapshots[0], snapshots[1]);\n     }\n \n     parseFileLimit(command);\n \n     parseSizeLimit(command);\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       option.setFiltersFile(getVal(command,\n           DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     option.validate();\n \n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String[] args)\n      throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n\n    option.setIgnoreFailures(\n        command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n\n    option.setAtomicCommit(\n        command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n\n    option.setSyncFolder(\n        command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n\n    option.setOverwrite(\n        command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n\n    option.setAppend(\n        command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n\n    option.setDeleteMissing(\n        command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n\n    option.setSkipCRC(\n        command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    parseBandwidth(command, option);\n\n    parseNumListStatusThreads(command, option);\n\n    parseMaxMaps(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    parsePreserveStatus(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.DIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      option.setUseDiff(snapshots[0], snapshots[1]);\n    }\n    if (command.hasOption(DistCpOptionSwitch.RDIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command,\n          DistCpOptionSwitch.RDIFF.getSwitch());\n      checkSnapshotsArgs(snapshots);\n      option.setUseRdiff(snapshots[0], snapshots[1]);\n    }\n\n    parseFileLimit(command);\n\n    parseSizeLimit(command);\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      option.setFiltersFile(getVal(command,\n          DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    option.validate();\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "03788d3015c962eac1a35fa5df39356e8b84731c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10397. Distcp should ignore -delete option if -diff option is provided instead of exiting. Contributed by Mingliang Liu.\n",
      "commitDate": "17/05/16 3:46 PM",
      "commitName": "03788d3015c962eac1a35fa5df39356e8b84731c",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "27/03/16 11:32 PM",
      "commitNameOld": "18c7e582839ea0b550463569b18b5827d23f8849",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 50.68,
      "commitsBetweenForRepo": 336,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,87 @@\n   public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n \n-    //Process all the other option switches and set options appropriately\n-    if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n-      option.setIgnoreFailures(true);\n-    }\n+    option.setIgnoreFailures(\n+        command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n \n-    if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n-      option.setAtomicCommit(true);\n-    }\n+    option.setAtomicCommit(\n+        command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n+\n+    option.setSyncFolder(\n+        command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n+\n+    option.setOverwrite(\n+        command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n+\n+    option.setAppend(\n+        command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n+\n+    option.setDeleteMissing(\n+        command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n+\n+    option.setSkipCRC(\n+        command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n-    if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n-      option.setSyncFolder(true);\n-    }\n-\n-    if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n-      option.setOverwrite(true);\n-    }\n-\n-    if (command.hasOption(DistCpOptionSwitch.APPEND.getSwitch())) {\n-      option.setAppend(true);\n-    }\n-\n-    if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n-      option.setDeleteMissing(true);\n-    }\n-\n-    if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n-      option.setSkipCRC(true);\n-    }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n     parseBandwidth(command, option);\n \n     parseNumListStatusThreads(command, option);\n \n     parseMaxMaps(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     parsePreserveStatus(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n       Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n           \"Must provide both the starting and ending snapshot names\");\n       option.setUseDiff(true, snapshots[0], snapshots[1]);\n     }\n \n     parseFileLimit(command);\n \n     parseSizeLimit(command);\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       option.setFiltersFile(getVal(command,\n           DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n+    option.validate();\n+\n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n\n    option.setIgnoreFailures(\n        command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch()));\n\n    option.setAtomicCommit(\n        command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch()));\n\n    option.setSyncFolder(\n        command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch()));\n\n    option.setOverwrite(\n        command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch()));\n\n    option.setAppend(\n        command.hasOption(DistCpOptionSwitch.APPEND.getSwitch()));\n\n    option.setDeleteMissing(\n        command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch()));\n\n    option.setSkipCRC(\n        command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch()));\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    parseBandwidth(command, option);\n\n    parseNumListStatusThreads(command, option);\n\n    parseMaxMaps(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    parsePreserveStatus(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n      Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n          \"Must provide both the starting and ending snapshot names\");\n      option.setUseDiff(true, snapshots[0], snapshots[1]);\n    }\n\n    parseFileLimit(command);\n\n    parseSizeLimit(command);\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      option.setFiltersFile(getVal(command,\n          DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    option.validate();\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "18c7e582839ea0b550463569b18b5827d23f8849": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9640. Remove hsftp from DistCp in trunk. Contributed by Wei-Chiu Chuang.\n",
      "commitDate": "27/03/16 11:32 PM",
      "commitName": "18c7e582839ea0b550463569b18b5827d23f8849",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "25/06/15 9:22 PM",
      "commitNameOld": "8ef07f767f0421b006b0fc77e5daf36c7b06abf1",
      "commitAuthorOld": "Amareshwari Sriramadasu",
      "daysBetweenCommits": 276.09,
      "commitsBetweenForRepo": 1818,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,92 @@\n   public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n \n     //Process all the other option switches and set options appropriately\n     if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n       option.setIgnoreFailures(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n       option.setAtomicCommit(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n       option.setSyncFolder(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n       option.setOverwrite(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.APPEND.getSwitch())) {\n       option.setAppend(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n       option.setDeleteMissing(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n       option.setSkipCRC(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n     parseBandwidth(command, option);\n \n-    if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n-      option.setSslConfigurationFile(command.\n-          getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n-    }\n-\n     parseNumListStatusThreads(command, option);\n \n     parseMaxMaps(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     parsePreserveStatus(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n       Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n           \"Must provide both the starting and ending snapshot names\");\n       option.setUseDiff(true, snapshots[0], snapshots[1]);\n     }\n \n     parseFileLimit(command);\n \n     parseSizeLimit(command);\n \n     if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n       option.setFiltersFile(getVal(command,\n           DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n\n    //Process all the other option switches and set options appropriately\n    if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n      option.setIgnoreFailures(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n      option.setAtomicCommit(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n      option.setSyncFolder(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n      option.setOverwrite(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.APPEND.getSwitch())) {\n      option.setAppend(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n      option.setDeleteMissing(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n      option.setSkipCRC(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    parseBandwidth(command, option);\n\n    parseNumListStatusThreads(command, option);\n\n    parseMaxMaps(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    parsePreserveStatus(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n      Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n          \"Must provide both the starting and ending snapshot names\");\n      option.setUseDiff(true, snapshots[0], snapshots[1]);\n    }\n\n    parseFileLimit(command);\n\n    parseSizeLimit(command);\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      option.setFiltersFile(getVal(command,\n          DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "0790275f058b0cf41780ad337c9150a1e8ebebc6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-1540. Support file exclusion list in distcp. Contributed by Rich Haase.\n",
      "commitDate": "18/05/15 1:24 PM",
      "commitName": "0790275f058b0cf41780ad337c9150a1e8ebebc6",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "21/04/15 4:49 PM",
      "commitNameOld": "cfba355052df15f8eb6cc9b8e90e2d8492bec7d7",
      "commitAuthorOld": "Ravi Prakash",
      "daysBetweenCommits": 26.86,
      "commitsBetweenForRepo": 321,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,191 +1,97 @@\n   public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n-    DistCpOptions option;\n-    Path targetPath;\n-    List\u003cPath\u003e sourcePaths \u003d new ArrayList\u003cPath\u003e();\n-\n-    String leftOverArgs[] \u003d command.getArgs();\n-    if (leftOverArgs \u003d\u003d null || leftOverArgs.length \u003c 1) {\n-      throw new IllegalArgumentException(\"Target path not specified\");\n-    }\n-\n-    //Last Argument is the target path\n-    targetPath \u003d new Path(leftOverArgs[leftOverArgs.length -1].trim());\n-\n-    //Copy any source paths in the arguments to the list\n-    for (int index \u003d 0; index \u003c leftOverArgs.length - 1; index++) {\n-      sourcePaths.add(new Path(leftOverArgs[index].trim()));\n-    }\n-\n-    /* If command has source file listing, use it else, fall back on source paths in args\n-       If both are present, throw exception and bail */\n-    if (command.hasOption(DistCpOptionSwitch.SOURCE_FILE_LISTING.getSwitch())) {\n-      if (!sourcePaths.isEmpty()) {\n-        throw new IllegalArgumentException(\"Both source file listing and source paths present\");\n-      }\n-      option \u003d new DistCpOptions(new Path(getVal(command, DistCpOptionSwitch.\n-              SOURCE_FILE_LISTING.getSwitch())), targetPath);\n-    } else {\n-      if (sourcePaths.isEmpty()) {\n-        throw new IllegalArgumentException(\"Neither source file listing nor source paths present\");\n-      }\n-      option \u003d new DistCpOptions(sourcePaths, targetPath);\n-    }\n+    DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n \n     //Process all the other option switches and set options appropriately\n     if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n       option.setIgnoreFailures(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n       option.setAtomicCommit(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n       option.setSyncFolder(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n       option.setOverwrite(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.APPEND.getSwitch())) {\n       option.setAppend(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n       option.setDeleteMissing(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n       option.setSkipCRC(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n-    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n-      try {\n-        Integer mapBandwidth \u003d Integer.parseInt(\n-            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()).trim());\n-        if (mapBandwidth.intValue() \u003c\u003d 0) {\n-          throw new IllegalArgumentException(\"Bandwidth specified is not positive: \" +\n-              mapBandwidth);\n-        }\n-        option.setMapBandwidth(mapBandwidth);\n-      } catch (NumberFormatException e) {\n-        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n-            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n-      }\n-    }\n+    parseBandwidth(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n       option.setSslConfigurationFile(command.\n           getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n     }\n \n-    if (command.hasOption(DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n-      try {\n-        Integer numThreads \u003d Integer.parseInt(getVal(command,\n-              DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()).trim());\n-        option.setNumListstatusThreads(numThreads);\n-      } catch (NumberFormatException e) {\n-        throw new IllegalArgumentException(\n-            \"Number of liststatus threads is invalid: \" + getVal(command,\n-                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n-      }\n-    }\n+    parseNumListStatusThreads(command, option);\n \n-    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n-      try {\n-        Integer maps \u003d Integer.parseInt(\n-            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()).trim());\n-        option.setMaxMaps(maps);\n-      } catch (NumberFormatException e) {\n-        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n-            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n-      }\n-    }\n+    parseMaxMaps(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n-    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n-      String attributes \u003d\n-          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch());\n-      if (attributes \u003d\u003d null || attributes.isEmpty()) {\n-        for (FileAttribute attribute : FileAttribute.values()) {\n-          option.preserve(attribute);\n-        }\n-      } else {\n-        for (int index \u003d 0; index \u003c attributes.length(); index++) {\n-          option.preserve(FileAttribute.\n-              getAttribute(attributes.charAt(index)));\n-        }\n-      }\n-    }\n+    parsePreserveStatus(command, option);\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n       Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n           \"Must provide both the starting and ending snapshot names\");\n       option.setUseDiff(true, snapshots[0], snapshots[1]);\n     }\n \n-    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n-      String fileLimitString \u003d getVal(command,\n-                              DistCpOptionSwitch.FILE_LIMIT.getSwitch().trim());\n-      try {\n-        Integer.parseInt(fileLimitString);\n-      }\n-      catch (NumberFormatException e) {\n-        throw new IllegalArgumentException(\"File-limit is invalid: \"\n-                                            + fileLimitString, e);\n-      }\n-      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n-              \" option. Ignoring.\");\n-    }\n+    parseFileLimit(command);\n \n-    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n-      String sizeLimitString \u003d getVal(command,\n-                              DistCpOptionSwitch.SIZE_LIMIT.getSwitch().trim());\n-      try {\n-        Long.parseLong(sizeLimitString);\n-      }\n-      catch (NumberFormatException e) {\n-        throw new IllegalArgumentException(\"Size-limit is invalid: \"\n-                                            + sizeLimitString, e);\n-      }\n-      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n-              \" option. Ignoring.\");\n+    parseSizeLimit(command);\n+\n+    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n+      option.setFiltersFile(getVal(command,\n+          DistCpOptionSwitch.FILTERS.getSwitch()));\n     }\n \n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option \u003d parseSourceAndTargetPaths(command);\n\n    //Process all the other option switches and set options appropriately\n    if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n      option.setIgnoreFailures(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n      option.setAtomicCommit(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n      option.setSyncFolder(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n      option.setOverwrite(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.APPEND.getSwitch())) {\n      option.setAppend(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n      option.setDeleteMissing(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n      option.setSkipCRC(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    parseBandwidth(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n      option.setSslConfigurationFile(command.\n          getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n    }\n\n    parseNumListStatusThreads(command, option);\n\n    parseMaxMaps(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    parsePreserveStatus(command, option);\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n      Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n          \"Must provide both the starting and ending snapshot names\");\n      option.setUseDiff(true, snapshots[0], snapshots[1]);\n    }\n\n    parseFileLimit(command);\n\n    parseSizeLimit(command);\n\n    if (command.hasOption(DistCpOptionSwitch.FILTERS.getSwitch())) {\n      option.setFiltersFile(getVal(command,\n          DistCpOptionSwitch.FILTERS.getSwitch()));\n    }\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "cfba355052df15f8eb6cc9b8e90e2d8492bec7d7": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11827. Speed-up distcp buildListing() using threadpool (Zoran Dimitrijevic via raviprak)\n",
      "commitDate": "21/04/15 4:49 PM",
      "commitName": "cfba355052df15f8eb6cc9b8e90e2d8492bec7d7",
      "commitAuthor": "Ravi Prakash",
      "commitDateOld": "04/03/15 10:30 AM",
      "commitNameOld": "ed70fa142cabdbc1065e4dbbc95e99c8850c4751",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 48.22,
      "commitsBetweenForRepo": 409,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,179 +1,191 @@\n   public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions option;\n     Path targetPath;\n     List\u003cPath\u003e sourcePaths \u003d new ArrayList\u003cPath\u003e();\n \n     String leftOverArgs[] \u003d command.getArgs();\n     if (leftOverArgs \u003d\u003d null || leftOverArgs.length \u003c 1) {\n       throw new IllegalArgumentException(\"Target path not specified\");\n     }\n \n     //Last Argument is the target path\n     targetPath \u003d new Path(leftOverArgs[leftOverArgs.length -1].trim());\n \n     //Copy any source paths in the arguments to the list\n     for (int index \u003d 0; index \u003c leftOverArgs.length - 1; index++) {\n       sourcePaths.add(new Path(leftOverArgs[index].trim()));\n     }\n \n     /* If command has source file listing, use it else, fall back on source paths in args\n        If both are present, throw exception and bail */\n     if (command.hasOption(DistCpOptionSwitch.SOURCE_FILE_LISTING.getSwitch())) {\n       if (!sourcePaths.isEmpty()) {\n         throw new IllegalArgumentException(\"Both source file listing and source paths present\");\n       }\n       option \u003d new DistCpOptions(new Path(getVal(command, DistCpOptionSwitch.\n               SOURCE_FILE_LISTING.getSwitch())), targetPath);\n     } else {\n       if (sourcePaths.isEmpty()) {\n         throw new IllegalArgumentException(\"Neither source file listing nor source paths present\");\n       }\n       option \u003d new DistCpOptions(sourcePaths, targetPath);\n     }\n \n     //Process all the other option switches and set options appropriately\n     if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n       option.setIgnoreFailures(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n       option.setAtomicCommit(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n       option.setSyncFolder(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n       option.setOverwrite(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.APPEND.getSwitch())) {\n       option.setAppend(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n       option.setDeleteMissing(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n       option.setSkipCRC(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n       try {\n         Integer mapBandwidth \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()).trim());\n         if (mapBandwidth.intValue() \u003c\u003d 0) {\n           throw new IllegalArgumentException(\"Bandwidth specified is not positive: \" +\n               mapBandwidth);\n         }\n         option.setMapBandwidth(mapBandwidth);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n       option.setSslConfigurationFile(command.\n           getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n     }\n \n+    if (command.hasOption(DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n+      try {\n+        Integer numThreads \u003d Integer.parseInt(getVal(command,\n+              DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()).trim());\n+        option.setNumListstatusThreads(numThreads);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(\n+            \"Number of liststatus threads is invalid: \" + getVal(command,\n+                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n+      }\n+    }\n+\n     if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n       try {\n         Integer maps \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()).trim());\n         option.setMaxMaps(maps);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n       String attributes \u003d\n           getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch());\n       if (attributes \u003d\u003d null || attributes.isEmpty()) {\n         for (FileAttribute attribute : FileAttribute.values()) {\n           option.preserve(attribute);\n         }\n       } else {\n         for (int index \u003d 0; index \u003c attributes.length(); index++) {\n           option.preserve(FileAttribute.\n               getAttribute(attributes.charAt(index)));\n         }\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n       String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n       Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n           \"Must provide both the starting and ending snapshot names\");\n       option.setUseDiff(true, snapshots[0], snapshots[1]);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n       String fileLimitString \u003d getVal(command,\n                               DistCpOptionSwitch.FILE_LIMIT.getSwitch().trim());\n       try {\n         Integer.parseInt(fileLimitString);\n       }\n       catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"File-limit is invalid: \"\n                                             + fileLimitString, e);\n       }\n       LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n               \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n       String sizeLimitString \u003d getVal(command,\n                               DistCpOptionSwitch.SIZE_LIMIT.getSwitch().trim());\n       try {\n         Long.parseLong(sizeLimitString);\n       }\n       catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Size-limit is invalid: \"\n                                             + sizeLimitString, e);\n       }\n       LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n               \" option. Ignoring.\");\n     }\n \n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option;\n    Path targetPath;\n    List\u003cPath\u003e sourcePaths \u003d new ArrayList\u003cPath\u003e();\n\n    String leftOverArgs[] \u003d command.getArgs();\n    if (leftOverArgs \u003d\u003d null || leftOverArgs.length \u003c 1) {\n      throw new IllegalArgumentException(\"Target path not specified\");\n    }\n\n    //Last Argument is the target path\n    targetPath \u003d new Path(leftOverArgs[leftOverArgs.length -1].trim());\n\n    //Copy any source paths in the arguments to the list\n    for (int index \u003d 0; index \u003c leftOverArgs.length - 1; index++) {\n      sourcePaths.add(new Path(leftOverArgs[index].trim()));\n    }\n\n    /* If command has source file listing, use it else, fall back on source paths in args\n       If both are present, throw exception and bail */\n    if (command.hasOption(DistCpOptionSwitch.SOURCE_FILE_LISTING.getSwitch())) {\n      if (!sourcePaths.isEmpty()) {\n        throw new IllegalArgumentException(\"Both source file listing and source paths present\");\n      }\n      option \u003d new DistCpOptions(new Path(getVal(command, DistCpOptionSwitch.\n              SOURCE_FILE_LISTING.getSwitch())), targetPath);\n    } else {\n      if (sourcePaths.isEmpty()) {\n        throw new IllegalArgumentException(\"Neither source file listing nor source paths present\");\n      }\n      option \u003d new DistCpOptions(sourcePaths, targetPath);\n    }\n\n    //Process all the other option switches and set options appropriately\n    if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n      option.setIgnoreFailures(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n      option.setAtomicCommit(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n      option.setSyncFolder(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n      option.setOverwrite(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.APPEND.getSwitch())) {\n      option.setAppend(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n      option.setDeleteMissing(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n      option.setSkipCRC(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        Integer mapBandwidth \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()).trim());\n        if (mapBandwidth.intValue() \u003c\u003d 0) {\n          throw new IllegalArgumentException(\"Bandwidth specified is not positive: \" +\n              mapBandwidth);\n        }\n        option.setMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n      option.setSslConfigurationFile(command.\n          getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch())) {\n      try {\n        Integer numThreads \u003d Integer.parseInt(getVal(command,\n              DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()).trim());\n        option.setNumListstatusThreads(numThreads);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\n            \"Number of liststatus threads is invalid: \" + getVal(command,\n                DistCpOptionSwitch.NUM_LISTSTATUS_THREADS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()).trim());\n        option.setMaxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      String attributes \u003d\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch());\n      if (attributes \u003d\u003d null || attributes.isEmpty()) {\n        for (FileAttribute attribute : FileAttribute.values()) {\n          option.preserve(attribute);\n        }\n      } else {\n        for (int index \u003d 0; index \u003c attributes.length(); index++) {\n          option.preserve(FileAttribute.\n              getAttribute(attributes.charAt(index)));\n        }\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n      Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n          \"Must provide both the starting and ending snapshot names\");\n      option.setUseDiff(true, snapshots[0], snapshots[1]);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      String fileLimitString \u003d getVal(command,\n                              DistCpOptionSwitch.FILE_LIMIT.getSwitch().trim());\n      try {\n        Integer.parseInt(fileLimitString);\n      }\n      catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"File-limit is invalid: \"\n                                            + fileLimitString, e);\n      }\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n              \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      String sizeLimitString \u003d getVal(command,\n                              DistCpOptionSwitch.SIZE_LIMIT.getSwitch().trim());\n      try {\n        Long.parseLong(sizeLimitString);\n      }\n      catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Size-limit is invalid: \"\n                                            + sizeLimitString, e);\n      }\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n              \" option. Ignoring.\");\n    }\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "ed70fa142cabdbc1065e4dbbc95e99c8850c4751": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7535. Utilize Snapshot diff report for distcp. Contributed by Jing Zhao.\n",
      "commitDate": "04/03/15 10:30 AM",
      "commitName": "ed70fa142cabdbc1065e4dbbc95e99c8850c4751",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "03/03/15 1:06 AM",
      "commitNameOld": "9ae7f9eb7baeb244e1b95aabc93ad8124870b9a9",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 1.39,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,172 +1,179 @@\n   public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions option;\n     Path targetPath;\n     List\u003cPath\u003e sourcePaths \u003d new ArrayList\u003cPath\u003e();\n \n     String leftOverArgs[] \u003d command.getArgs();\n     if (leftOverArgs \u003d\u003d null || leftOverArgs.length \u003c 1) {\n       throw new IllegalArgumentException(\"Target path not specified\");\n     }\n \n     //Last Argument is the target path\n     targetPath \u003d new Path(leftOverArgs[leftOverArgs.length -1].trim());\n \n     //Copy any source paths in the arguments to the list\n     for (int index \u003d 0; index \u003c leftOverArgs.length - 1; index++) {\n       sourcePaths.add(new Path(leftOverArgs[index].trim()));\n     }\n \n     /* If command has source file listing, use it else, fall back on source paths in args\n        If both are present, throw exception and bail */\n     if (command.hasOption(DistCpOptionSwitch.SOURCE_FILE_LISTING.getSwitch())) {\n       if (!sourcePaths.isEmpty()) {\n         throw new IllegalArgumentException(\"Both source file listing and source paths present\");\n       }\n       option \u003d new DistCpOptions(new Path(getVal(command, DistCpOptionSwitch.\n               SOURCE_FILE_LISTING.getSwitch())), targetPath);\n     } else {\n       if (sourcePaths.isEmpty()) {\n         throw new IllegalArgumentException(\"Neither source file listing nor source paths present\");\n       }\n       option \u003d new DistCpOptions(sourcePaths, targetPath);\n     }\n \n     //Process all the other option switches and set options appropriately\n     if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n       option.setIgnoreFailures(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n       option.setAtomicCommit(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n       option.setSyncFolder(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n       option.setOverwrite(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.APPEND.getSwitch())) {\n       option.setAppend(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n       option.setDeleteMissing(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n       option.setSkipCRC(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n       try {\n         Integer mapBandwidth \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()).trim());\n         if (mapBandwidth.intValue() \u003c\u003d 0) {\n           throw new IllegalArgumentException(\"Bandwidth specified is not positive: \" +\n               mapBandwidth);\n         }\n         option.setMapBandwidth(mapBandwidth);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n       option.setSslConfigurationFile(command.\n           getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n       try {\n         Integer maps \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()).trim());\n         option.setMaxMaps(maps);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n       String attributes \u003d\n           getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch());\n       if (attributes \u003d\u003d null || attributes.isEmpty()) {\n         for (FileAttribute attribute : FileAttribute.values()) {\n           option.preserve(attribute);\n         }\n       } else {\n         for (int index \u003d 0; index \u003c attributes.length(); index++) {\n           option.preserve(FileAttribute.\n               getAttribute(attributes.charAt(index)));\n         }\n       }\n     }\n \n+    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n+      String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n+      Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n+          \"Must provide both the starting and ending snapshot names\");\n+      option.setUseDiff(true, snapshots[0], snapshots[1]);\n+    }\n+\n     if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n       String fileLimitString \u003d getVal(command,\n                               DistCpOptionSwitch.FILE_LIMIT.getSwitch().trim());\n       try {\n         Integer.parseInt(fileLimitString);\n       }\n       catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"File-limit is invalid: \"\n                                             + fileLimitString, e);\n       }\n       LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n               \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n       String sizeLimitString \u003d getVal(command,\n                               DistCpOptionSwitch.SIZE_LIMIT.getSwitch().trim());\n       try {\n         Long.parseLong(sizeLimitString);\n       }\n       catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Size-limit is invalid: \"\n                                             + sizeLimitString, e);\n       }\n       LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n               \" option. Ignoring.\");\n     }\n \n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option;\n    Path targetPath;\n    List\u003cPath\u003e sourcePaths \u003d new ArrayList\u003cPath\u003e();\n\n    String leftOverArgs[] \u003d command.getArgs();\n    if (leftOverArgs \u003d\u003d null || leftOverArgs.length \u003c 1) {\n      throw new IllegalArgumentException(\"Target path not specified\");\n    }\n\n    //Last Argument is the target path\n    targetPath \u003d new Path(leftOverArgs[leftOverArgs.length -1].trim());\n\n    //Copy any source paths in the arguments to the list\n    for (int index \u003d 0; index \u003c leftOverArgs.length - 1; index++) {\n      sourcePaths.add(new Path(leftOverArgs[index].trim()));\n    }\n\n    /* If command has source file listing, use it else, fall back on source paths in args\n       If both are present, throw exception and bail */\n    if (command.hasOption(DistCpOptionSwitch.SOURCE_FILE_LISTING.getSwitch())) {\n      if (!sourcePaths.isEmpty()) {\n        throw new IllegalArgumentException(\"Both source file listing and source paths present\");\n      }\n      option \u003d new DistCpOptions(new Path(getVal(command, DistCpOptionSwitch.\n              SOURCE_FILE_LISTING.getSwitch())), targetPath);\n    } else {\n      if (sourcePaths.isEmpty()) {\n        throw new IllegalArgumentException(\"Neither source file listing nor source paths present\");\n      }\n      option \u003d new DistCpOptions(sourcePaths, targetPath);\n    }\n\n    //Process all the other option switches and set options appropriately\n    if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n      option.setIgnoreFailures(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n      option.setAtomicCommit(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n      option.setSyncFolder(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n      option.setOverwrite(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.APPEND.getSwitch())) {\n      option.setAppend(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n      option.setDeleteMissing(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n      option.setSkipCRC(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        Integer mapBandwidth \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()).trim());\n        if (mapBandwidth.intValue() \u003c\u003d 0) {\n          throw new IllegalArgumentException(\"Bandwidth specified is not positive: \" +\n              mapBandwidth);\n        }\n        option.setMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n      option.setSslConfigurationFile(command.\n          getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()).trim());\n        option.setMaxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      String attributes \u003d\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch());\n      if (attributes \u003d\u003d null || attributes.isEmpty()) {\n        for (FileAttribute attribute : FileAttribute.values()) {\n          option.preserve(attribute);\n        }\n      } else {\n        for (int index \u003d 0; index \u003c attributes.length(); index++) {\n          option.preserve(FileAttribute.\n              getAttribute(attributes.charAt(index)));\n        }\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.DIFF.getSwitch())) {\n      String[] snapshots \u003d getVals(command, DistCpOptionSwitch.DIFF.getSwitch());\n      Preconditions.checkArgument(snapshots !\u003d null \u0026\u0026 snapshots.length \u003d\u003d 2,\n          \"Must provide both the starting and ending snapshot names\");\n      option.setUseDiff(true, snapshots[0], snapshots[1]);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      String fileLimitString \u003d getVal(command,\n                              DistCpOptionSwitch.FILE_LIMIT.getSwitch().trim());\n      try {\n        Integer.parseInt(fileLimitString);\n      }\n      catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"File-limit is invalid: \"\n                                            + fileLimitString, e);\n      }\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n              \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      String sizeLimitString \u003d getVal(command,\n                              DistCpOptionSwitch.SIZE_LIMIT.getSwitch().trim());\n      try {\n        Long.parseLong(sizeLimitString);\n      }\n      catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Size-limit is invalid: \"\n                                            + sizeLimitString, e);\n      }\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n              \" option. Ignoring.\");\n    }\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "3671a5e16fbddbe5a0516289ce98e1305e02291c": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5899. Support incremental data copy in DistCp. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596931 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/05/14 11:17 AM",
      "commitName": "3671a5e16fbddbe5a0516289ce98e1305e02291c",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "30/01/14 3:53 PM",
      "commitNameOld": "067d52b98c1d17a73b142bb53acc8aaa9c041f38",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 111.77,
      "commitsBetweenForRepo": 836,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,168 +1,172 @@\n   public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions option;\n     Path targetPath;\n     List\u003cPath\u003e sourcePaths \u003d new ArrayList\u003cPath\u003e();\n \n     String leftOverArgs[] \u003d command.getArgs();\n     if (leftOverArgs \u003d\u003d null || leftOverArgs.length \u003c 1) {\n       throw new IllegalArgumentException(\"Target path not specified\");\n     }\n \n     //Last Argument is the target path\n     targetPath \u003d new Path(leftOverArgs[leftOverArgs.length -1].trim());\n \n     //Copy any source paths in the arguments to the list\n     for (int index \u003d 0; index \u003c leftOverArgs.length - 1; index++) {\n       sourcePaths.add(new Path(leftOverArgs[index].trim()));\n     }\n \n     /* If command has source file listing, use it else, fall back on source paths in args\n        If both are present, throw exception and bail */\n     if (command.hasOption(DistCpOptionSwitch.SOURCE_FILE_LISTING.getSwitch())) {\n       if (!sourcePaths.isEmpty()) {\n         throw new IllegalArgumentException(\"Both source file listing and source paths present\");\n       }\n       option \u003d new DistCpOptions(new Path(getVal(command, DistCpOptionSwitch.\n               SOURCE_FILE_LISTING.getSwitch())), targetPath);\n     } else {\n       if (sourcePaths.isEmpty()) {\n         throw new IllegalArgumentException(\"Neither source file listing nor source paths present\");\n       }\n       option \u003d new DistCpOptions(sourcePaths, targetPath);\n     }\n \n     //Process all the other option switches and set options appropriately\n     if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n       option.setIgnoreFailures(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n       option.setAtomicCommit(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n       option.setSyncFolder(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n       option.setOverwrite(true);\n     }\n \n+    if (command.hasOption(DistCpOptionSwitch.APPEND.getSwitch())) {\n+      option.setAppend(true);\n+    }\n+\n     if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n       option.setDeleteMissing(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n       option.setSkipCRC(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n       try {\n         Integer mapBandwidth \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()).trim());\n         if (mapBandwidth.intValue() \u003c\u003d 0) {\n           throw new IllegalArgumentException(\"Bandwidth specified is not positive: \" +\n               mapBandwidth);\n         }\n         option.setMapBandwidth(mapBandwidth);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n       option.setSslConfigurationFile(command.\n           getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n       try {\n         Integer maps \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()).trim());\n         option.setMaxMaps(maps);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n       String attributes \u003d\n           getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch());\n       if (attributes \u003d\u003d null || attributes.isEmpty()) {\n         for (FileAttribute attribute : FileAttribute.values()) {\n           option.preserve(attribute);\n         }\n       } else {\n         for (int index \u003d 0; index \u003c attributes.length(); index++) {\n           option.preserve(FileAttribute.\n               getAttribute(attributes.charAt(index)));\n         }\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n       String fileLimitString \u003d getVal(command,\n                               DistCpOptionSwitch.FILE_LIMIT.getSwitch().trim());\n       try {\n         Integer.parseInt(fileLimitString);\n       }\n       catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"File-limit is invalid: \"\n                                             + fileLimitString, e);\n       }\n       LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n               \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n       String sizeLimitString \u003d getVal(command,\n                               DistCpOptionSwitch.SIZE_LIMIT.getSwitch().trim());\n       try {\n         Long.parseLong(sizeLimitString);\n       }\n       catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Size-limit is invalid: \"\n                                             + sizeLimitString, e);\n       }\n       LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n               \" option. Ignoring.\");\n     }\n \n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option;\n    Path targetPath;\n    List\u003cPath\u003e sourcePaths \u003d new ArrayList\u003cPath\u003e();\n\n    String leftOverArgs[] \u003d command.getArgs();\n    if (leftOverArgs \u003d\u003d null || leftOverArgs.length \u003c 1) {\n      throw new IllegalArgumentException(\"Target path not specified\");\n    }\n\n    //Last Argument is the target path\n    targetPath \u003d new Path(leftOverArgs[leftOverArgs.length -1].trim());\n\n    //Copy any source paths in the arguments to the list\n    for (int index \u003d 0; index \u003c leftOverArgs.length - 1; index++) {\n      sourcePaths.add(new Path(leftOverArgs[index].trim()));\n    }\n\n    /* If command has source file listing, use it else, fall back on source paths in args\n       If both are present, throw exception and bail */\n    if (command.hasOption(DistCpOptionSwitch.SOURCE_FILE_LISTING.getSwitch())) {\n      if (!sourcePaths.isEmpty()) {\n        throw new IllegalArgumentException(\"Both source file listing and source paths present\");\n      }\n      option \u003d new DistCpOptions(new Path(getVal(command, DistCpOptionSwitch.\n              SOURCE_FILE_LISTING.getSwitch())), targetPath);\n    } else {\n      if (sourcePaths.isEmpty()) {\n        throw new IllegalArgumentException(\"Neither source file listing nor source paths present\");\n      }\n      option \u003d new DistCpOptions(sourcePaths, targetPath);\n    }\n\n    //Process all the other option switches and set options appropriately\n    if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n      option.setIgnoreFailures(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n      option.setAtomicCommit(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n      option.setSyncFolder(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n      option.setOverwrite(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.APPEND.getSwitch())) {\n      option.setAppend(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n      option.setDeleteMissing(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n      option.setSkipCRC(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        Integer mapBandwidth \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()).trim());\n        if (mapBandwidth.intValue() \u003c\u003d 0) {\n          throw new IllegalArgumentException(\"Bandwidth specified is not positive: \" +\n              mapBandwidth);\n        }\n        option.setMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n      option.setSslConfigurationFile(command.\n          getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()).trim());\n        option.setMaxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      String attributes \u003d\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch());\n      if (attributes \u003d\u003d null || attributes.isEmpty()) {\n        for (FileAttribute attribute : FileAttribute.values()) {\n          option.preserve(attribute);\n        }\n      } else {\n        for (int index \u003d 0; index \u003c attributes.length(); index++) {\n          option.preserve(FileAttribute.\n              getAttribute(attributes.charAt(index)));\n        }\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      String fileLimitString \u003d getVal(command,\n                              DistCpOptionSwitch.FILE_LIMIT.getSwitch().trim());\n      try {\n        Integer.parseInt(fileLimitString);\n      }\n      catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"File-limit is invalid: \"\n                                            + fileLimitString, e);\n      }\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n              \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      String sizeLimitString \u003d getVal(command,\n                              DistCpOptionSwitch.SIZE_LIMIT.getSwitch().trim());\n      try {\n        Long.parseLong(sizeLimitString);\n      }\n      catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Size-limit is invalid: \"\n                                            + sizeLimitString, e);\n      }\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n              \" option. Ignoring.\");\n    }\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "6ba9ff9177b928054f11033e8323743767d7358c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8775. MR2 distcp permits non-positive value to -bandwidth option which causes job never to complete. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1382119 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/09/12 11:40 AM",
      "commitName": "6ba9ff9177b928054f11033e8323743767d7358c",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "25/01/12 10:36 PM",
      "commitNameOld": "d06948002fb0cabf72cc0d46bf2fa67d45370f67",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 225.5,
      "commitsBetweenForRepo": 1493,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,168 @@\n   public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n \n     CommandLineParser parser \u003d new CustomParser();\n \n     CommandLine command;\n     try {\n       command \u003d parser.parse(cliOptions, args, true);\n     } catch (ParseException e) {\n       throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n         Arrays.toString(args), e);\n     }\n \n     DistCpOptions option;\n     Path targetPath;\n     List\u003cPath\u003e sourcePaths \u003d new ArrayList\u003cPath\u003e();\n \n     String leftOverArgs[] \u003d command.getArgs();\n     if (leftOverArgs \u003d\u003d null || leftOverArgs.length \u003c 1) {\n       throw new IllegalArgumentException(\"Target path not specified\");\n     }\n \n     //Last Argument is the target path\n     targetPath \u003d new Path(leftOverArgs[leftOverArgs.length -1].trim());\n \n     //Copy any source paths in the arguments to the list\n     for (int index \u003d 0; index \u003c leftOverArgs.length - 1; index++) {\n       sourcePaths.add(new Path(leftOverArgs[index].trim()));\n     }\n \n     /* If command has source file listing, use it else, fall back on source paths in args\n        If both are present, throw exception and bail */\n     if (command.hasOption(DistCpOptionSwitch.SOURCE_FILE_LISTING.getSwitch())) {\n       if (!sourcePaths.isEmpty()) {\n         throw new IllegalArgumentException(\"Both source file listing and source paths present\");\n       }\n       option \u003d new DistCpOptions(new Path(getVal(command, DistCpOptionSwitch.\n               SOURCE_FILE_LISTING.getSwitch())), targetPath);\n     } else {\n       if (sourcePaths.isEmpty()) {\n         throw new IllegalArgumentException(\"Neither source file listing nor source paths present\");\n       }\n       option \u003d new DistCpOptions(sourcePaths, targetPath);\n     }\n \n     //Process all the other option switches and set options appropriately\n     if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n       option.setIgnoreFailures(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n       option.setAtomicCommit(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n         option.shouldAtomicCommit()) {\n       String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n       if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n         option.setAtomicWorkPath(new Path(workPath));\n       }\n     } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n       throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");      \n     }\n \n     if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n       option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n       option.setSyncFolder(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n       option.setOverwrite(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n       option.setDeleteMissing(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n       option.setSkipCRC(true);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n       option.setBlocking(false);\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n       try {\n         Integer mapBandwidth \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()).trim());\n+        if (mapBandwidth.intValue() \u003c\u003d 0) {\n+          throw new IllegalArgumentException(\"Bandwidth specified is not positive: \" +\n+              mapBandwidth);\n+        }\n         option.setMapBandwidth(mapBandwidth);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n             getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n       option.setSslConfigurationFile(command.\n           getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n       try {\n         Integer maps \u003d Integer.parseInt(\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()).trim());\n         option.setMaxMaps(maps);\n       } catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n             getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n       option.setCopyStrategy(\n             getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n       String attributes \u003d\n           getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch());\n       if (attributes \u003d\u003d null || attributes.isEmpty()) {\n         for (FileAttribute attribute : FileAttribute.values()) {\n           option.preserve(attribute);\n         }\n       } else {\n         for (int index \u003d 0; index \u003c attributes.length(); index++) {\n           option.preserve(FileAttribute.\n               getAttribute(attributes.charAt(index)));\n         }\n       }\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n       String fileLimitString \u003d getVal(command,\n                               DistCpOptionSwitch.FILE_LIMIT.getSwitch().trim());\n       try {\n         Integer.parseInt(fileLimitString);\n       }\n       catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"File-limit is invalid: \"\n                                             + fileLimitString, e);\n       }\n       LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n               \" option. Ignoring.\");\n     }\n \n     if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n       String sizeLimitString \u003d getVal(command,\n                               DistCpOptionSwitch.SIZE_LIMIT.getSwitch().trim());\n       try {\n         Long.parseLong(sizeLimitString);\n       }\n       catch (NumberFormatException e) {\n         throw new IllegalArgumentException(\"Size-limit is invalid: \"\n                                             + sizeLimitString, e);\n       }\n       LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n               \" option. Ignoring.\");\n     }\n \n     return option;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option;\n    Path targetPath;\n    List\u003cPath\u003e sourcePaths \u003d new ArrayList\u003cPath\u003e();\n\n    String leftOverArgs[] \u003d command.getArgs();\n    if (leftOverArgs \u003d\u003d null || leftOverArgs.length \u003c 1) {\n      throw new IllegalArgumentException(\"Target path not specified\");\n    }\n\n    //Last Argument is the target path\n    targetPath \u003d new Path(leftOverArgs[leftOverArgs.length -1].trim());\n\n    //Copy any source paths in the arguments to the list\n    for (int index \u003d 0; index \u003c leftOverArgs.length - 1; index++) {\n      sourcePaths.add(new Path(leftOverArgs[index].trim()));\n    }\n\n    /* If command has source file listing, use it else, fall back on source paths in args\n       If both are present, throw exception and bail */\n    if (command.hasOption(DistCpOptionSwitch.SOURCE_FILE_LISTING.getSwitch())) {\n      if (!sourcePaths.isEmpty()) {\n        throw new IllegalArgumentException(\"Both source file listing and source paths present\");\n      }\n      option \u003d new DistCpOptions(new Path(getVal(command, DistCpOptionSwitch.\n              SOURCE_FILE_LISTING.getSwitch())), targetPath);\n    } else {\n      if (sourcePaths.isEmpty()) {\n        throw new IllegalArgumentException(\"Neither source file listing nor source paths present\");\n      }\n      option \u003d new DistCpOptions(sourcePaths, targetPath);\n    }\n\n    //Process all the other option switches and set options appropriately\n    if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n      option.setIgnoreFailures(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n      option.setAtomicCommit(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");      \n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n      option.setSyncFolder(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n      option.setOverwrite(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n      option.setDeleteMissing(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n      option.setSkipCRC(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        Integer mapBandwidth \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()).trim());\n        if (mapBandwidth.intValue() \u003c\u003d 0) {\n          throw new IllegalArgumentException(\"Bandwidth specified is not positive: \" +\n              mapBandwidth);\n        }\n        option.setMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n      option.setSslConfigurationFile(command.\n          getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()).trim());\n        option.setMaxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      String attributes \u003d\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch());\n      if (attributes \u003d\u003d null || attributes.isEmpty()) {\n        for (FileAttribute attribute : FileAttribute.values()) {\n          option.preserve(attribute);\n        }\n      } else {\n        for (int index \u003d 0; index \u003c attributes.length(); index++) {\n          option.preserve(FileAttribute.\n              getAttribute(attributes.charAt(index)));\n        }\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      String fileLimitString \u003d getVal(command,\n                              DistCpOptionSwitch.FILE_LIMIT.getSwitch().trim());\n      try {\n        Integer.parseInt(fileLimitString);\n      }\n      catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"File-limit is invalid: \"\n                                            + fileLimitString, e);\n      }\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n              \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      String sizeLimitString \u003d getVal(command,\n                              DistCpOptionSwitch.SIZE_LIMIT.getSwitch().trim());\n      try {\n        Long.parseLong(sizeLimitString);\n      }\n      catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Size-limit is invalid: \"\n                                            + sizeLimitString, e);\n      }\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n              \" option. Ignoring.\");\n    }\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java",
      "extendedDetails": {}
    },
    "d06948002fb0cabf72cc0d46bf2fa67d45370f67": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2765. DistCp Rewrite. (Mithun Radhakrishnan via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1236045 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/12 10:36 PM",
      "commitName": "d06948002fb0cabf72cc0d46bf2fa67d45370f67",
      "commitAuthor": "Mahadev Konar",
      "diff": "@@ -0,0 +1,164 @@\n+  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n+\n+    CommandLineParser parser \u003d new CustomParser();\n+\n+    CommandLine command;\n+    try {\n+      command \u003d parser.parse(cliOptions, args, true);\n+    } catch (ParseException e) {\n+      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n+        Arrays.toString(args), e);\n+    }\n+\n+    DistCpOptions option;\n+    Path targetPath;\n+    List\u003cPath\u003e sourcePaths \u003d new ArrayList\u003cPath\u003e();\n+\n+    String leftOverArgs[] \u003d command.getArgs();\n+    if (leftOverArgs \u003d\u003d null || leftOverArgs.length \u003c 1) {\n+      throw new IllegalArgumentException(\"Target path not specified\");\n+    }\n+\n+    //Last Argument is the target path\n+    targetPath \u003d new Path(leftOverArgs[leftOverArgs.length -1].trim());\n+\n+    //Copy any source paths in the arguments to the list\n+    for (int index \u003d 0; index \u003c leftOverArgs.length - 1; index++) {\n+      sourcePaths.add(new Path(leftOverArgs[index].trim()));\n+    }\n+\n+    /* If command has source file listing, use it else, fall back on source paths in args\n+       If both are present, throw exception and bail */\n+    if (command.hasOption(DistCpOptionSwitch.SOURCE_FILE_LISTING.getSwitch())) {\n+      if (!sourcePaths.isEmpty()) {\n+        throw new IllegalArgumentException(\"Both source file listing and source paths present\");\n+      }\n+      option \u003d new DistCpOptions(new Path(getVal(command, DistCpOptionSwitch.\n+              SOURCE_FILE_LISTING.getSwitch())), targetPath);\n+    } else {\n+      if (sourcePaths.isEmpty()) {\n+        throw new IllegalArgumentException(\"Neither source file listing nor source paths present\");\n+      }\n+      option \u003d new DistCpOptions(sourcePaths, targetPath);\n+    }\n+\n+    //Process all the other option switches and set options appropriately\n+    if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n+      option.setIgnoreFailures(true);\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n+      option.setAtomicCommit(true);\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n+        option.shouldAtomicCommit()) {\n+      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n+      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n+        option.setAtomicWorkPath(new Path(workPath));\n+      }\n+    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n+      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");      \n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n+      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n+      option.setSyncFolder(true);\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n+      option.setOverwrite(true);\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n+      option.setDeleteMissing(true);\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n+      option.setSkipCRC(true);\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n+      option.setBlocking(false);\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n+      try {\n+        Integer mapBandwidth \u003d Integer.parseInt(\n+            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()).trim());\n+        option.setMapBandwidth(mapBandwidth);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n+            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n+      }\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n+      option.setSslConfigurationFile(command.\n+          getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n+      try {\n+        Integer maps \u003d Integer.parseInt(\n+            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()).trim());\n+        option.setMaxMaps(maps);\n+      } catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n+            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n+      }\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n+      option.setCopyStrategy(\n+            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n+      String attributes \u003d\n+          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch());\n+      if (attributes \u003d\u003d null || attributes.isEmpty()) {\n+        for (FileAttribute attribute : FileAttribute.values()) {\n+          option.preserve(attribute);\n+        }\n+      } else {\n+        for (int index \u003d 0; index \u003c attributes.length(); index++) {\n+          option.preserve(FileAttribute.\n+              getAttribute(attributes.charAt(index)));\n+        }\n+      }\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n+      String fileLimitString \u003d getVal(command,\n+                              DistCpOptionSwitch.FILE_LIMIT.getSwitch().trim());\n+      try {\n+        Integer.parseInt(fileLimitString);\n+      }\n+      catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(\"File-limit is invalid: \"\n+                                            + fileLimitString, e);\n+      }\n+      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n+              \" option. Ignoring.\");\n+    }\n+\n+    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n+      String sizeLimitString \u003d getVal(command,\n+                              DistCpOptionSwitch.SIZE_LIMIT.getSwitch().trim());\n+      try {\n+        Long.parseLong(sizeLimitString);\n+      }\n+      catch (NumberFormatException e) {\n+        throw new IllegalArgumentException(\"Size-limit is invalid: \"\n+                                            + sizeLimitString, e);\n+      }\n+      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n+              \" option. Ignoring.\");\n+    }\n+\n+    return option;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static DistCpOptions parse(String args[]) throws IllegalArgumentException {\n\n    CommandLineParser parser \u003d new CustomParser();\n\n    CommandLine command;\n    try {\n      command \u003d parser.parse(cliOptions, args, true);\n    } catch (ParseException e) {\n      throw new IllegalArgumentException(\"Unable to parse arguments. \" +\n        Arrays.toString(args), e);\n    }\n\n    DistCpOptions option;\n    Path targetPath;\n    List\u003cPath\u003e sourcePaths \u003d new ArrayList\u003cPath\u003e();\n\n    String leftOverArgs[] \u003d command.getArgs();\n    if (leftOverArgs \u003d\u003d null || leftOverArgs.length \u003c 1) {\n      throw new IllegalArgumentException(\"Target path not specified\");\n    }\n\n    //Last Argument is the target path\n    targetPath \u003d new Path(leftOverArgs[leftOverArgs.length -1].trim());\n\n    //Copy any source paths in the arguments to the list\n    for (int index \u003d 0; index \u003c leftOverArgs.length - 1; index++) {\n      sourcePaths.add(new Path(leftOverArgs[index].trim()));\n    }\n\n    /* If command has source file listing, use it else, fall back on source paths in args\n       If both are present, throw exception and bail */\n    if (command.hasOption(DistCpOptionSwitch.SOURCE_FILE_LISTING.getSwitch())) {\n      if (!sourcePaths.isEmpty()) {\n        throw new IllegalArgumentException(\"Both source file listing and source paths present\");\n      }\n      option \u003d new DistCpOptions(new Path(getVal(command, DistCpOptionSwitch.\n              SOURCE_FILE_LISTING.getSwitch())), targetPath);\n    } else {\n      if (sourcePaths.isEmpty()) {\n        throw new IllegalArgumentException(\"Neither source file listing nor source paths present\");\n      }\n      option \u003d new DistCpOptions(sourcePaths, targetPath);\n    }\n\n    //Process all the other option switches and set options appropriately\n    if (command.hasOption(DistCpOptionSwitch.IGNORE_FAILURES.getSwitch())) {\n      option.setIgnoreFailures(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.ATOMIC_COMMIT.getSwitch())) {\n      option.setAtomicCommit(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch()) \u0026\u0026\n        option.shouldAtomicCommit()) {\n      String workPath \u003d getVal(command, DistCpOptionSwitch.WORK_PATH.getSwitch());\n      if (workPath !\u003d null \u0026\u0026 !workPath.isEmpty()) {\n        option.setAtomicWorkPath(new Path(workPath));\n      }\n    } else if (command.hasOption(DistCpOptionSwitch.WORK_PATH.getSwitch())) {\n      throw new IllegalArgumentException(\"-tmp work-path can only be specified along with -atomic\");      \n    }\n\n    if (command.hasOption(DistCpOptionSwitch.LOG_PATH.getSwitch())) {\n      option.setLogPath(new Path(getVal(command, DistCpOptionSwitch.LOG_PATH.getSwitch())));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SYNC_FOLDERS.getSwitch())) {\n      option.setSyncFolder(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.OVERWRITE.getSwitch())) {\n      option.setOverwrite(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.DELETE_MISSING.getSwitch())) {\n      option.setDeleteMissing(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SKIP_CRC.getSwitch())) {\n      option.setSkipCRC(true);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BLOCKING.getSwitch())) {\n      option.setBlocking(false);\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.BANDWIDTH.getSwitch())) {\n      try {\n        Integer mapBandwidth \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()).trim());\n        option.setMapBandwidth(mapBandwidth);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Bandwidth specified is invalid: \" +\n            getVal(command, DistCpOptionSwitch.BANDWIDTH.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SSL_CONF.getSwitch())) {\n      option.setSslConfigurationFile(command.\n          getOptionValue(DistCpOptionSwitch.SSL_CONF.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.MAX_MAPS.getSwitch())) {\n      try {\n        Integer maps \u003d Integer.parseInt(\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()).trim());\n        option.setMaxMaps(maps);\n      } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Number of maps is invalid: \" +\n            getVal(command, DistCpOptionSwitch.MAX_MAPS.getSwitch()), e);\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.COPY_STRATEGY.getSwitch())) {\n      option.setCopyStrategy(\n            getVal(command, DistCpOptionSwitch.COPY_STRATEGY.getSwitch()));\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.PRESERVE_STATUS.getSwitch())) {\n      String attributes \u003d\n          getVal(command, DistCpOptionSwitch.PRESERVE_STATUS.getSwitch());\n      if (attributes \u003d\u003d null || attributes.isEmpty()) {\n        for (FileAttribute attribute : FileAttribute.values()) {\n          option.preserve(attribute);\n        }\n      } else {\n        for (int index \u003d 0; index \u003c attributes.length(); index++) {\n          option.preserve(FileAttribute.\n              getAttribute(attributes.charAt(index)));\n        }\n      }\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.FILE_LIMIT.getSwitch())) {\n      String fileLimitString \u003d getVal(command,\n                              DistCpOptionSwitch.FILE_LIMIT.getSwitch().trim());\n      try {\n        Integer.parseInt(fileLimitString);\n      }\n      catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"File-limit is invalid: \"\n                                            + fileLimitString, e);\n      }\n      LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + \" is a deprecated\" +\n              \" option. Ignoring.\");\n    }\n\n    if (command.hasOption(DistCpOptionSwitch.SIZE_LIMIT.getSwitch())) {\n      String sizeLimitString \u003d getVal(command,\n                              DistCpOptionSwitch.SIZE_LIMIT.getSwitch().trim());\n      try {\n        Long.parseLong(sizeLimitString);\n      }\n      catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Size-limit is invalid: \"\n                                            + sizeLimitString, e);\n      }\n      LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + \" is a deprecated\" +\n              \" option. Ignoring.\");\n    }\n\n    return option;\n  }",
      "path": "hadoop-tools/hadoop-distcp/src/main/java/org/apache/hadoop/tools/OptionsParser.java"
    }
  }
}