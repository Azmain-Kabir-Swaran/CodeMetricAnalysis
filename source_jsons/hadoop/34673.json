{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerManagerImpl.java",
  "functionName": "updateContainer",
  "functionId": "updateContainer___request-ContainerUpdateRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
  "functionStartLine": 1256,
  "functionEndLine": 1301,
  "numCommitsSeen": 139,
  "timeTaken": 2807,
  "changeHistory": [
    "4d7be1d8575e9254c59d41460960708e3718503a",
    "35dc7829236f92054d5ce6ea78d3a44ca6c8f3d3"
  ],
  "changeHistoryShort": {
    "4d7be1d8575e9254c59d41460960708e3718503a": "Ybodychange",
    "35dc7829236f92054d5ce6ea78d3a44ca6c8f3d3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4d7be1d8575e9254c59d41460960708e3718503a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5978. ContainerScheduler and ContainerManager changes to support ExecType update. (Kartheek Muthyala via asuresh)\n",
      "commitDate": "14/08/17 7:46 PM",
      "commitName": "4d7be1d8575e9254c59d41460960708e3718503a",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "03/08/17 9:15 PM",
      "commitNameOld": "35dc7829236f92054d5ce6ea78d3a44ca6c8f3d3",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 10.94,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,46 @@\n   public ContainerUpdateResponse updateContainer(ContainerUpdateRequest\n       request) throws YarnException, IOException {\n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n     authorizeUser(remoteUgi, nmTokenIdentifier);\n     List\u003cContainerId\u003e successfullyUpdatedContainers\n         \u003d new ArrayList\u003cContainerId\u003e();\n     Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n         new HashMap\u003cContainerId, SerializedException\u003e();\n     // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n     // to avoid race condition during NM-RM resync (due to RM restart) while a\n     // container resource is being increased in NM, in particular when the\n     // increased container has not yet been added to the increasedContainers\n     // map in NMContext.\n     synchronized (this.context) {\n       // Process container resource increase requests\n       for (org.apache.hadoop.yarn.api.records.Token token :\n           request.getContainersToUpdate()) {\n         ContainerId containerId \u003d null;\n         try {\n           if (token.getIdentifier() \u003d\u003d null) {\n             throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n           }\n           ContainerTokenIdentifier containerTokenIdentifier \u003d\n               BuilderUtils.newContainerTokenIdentifier(token);\n           verifyAndGetContainerTokenIdentifier(token,\n               containerTokenIdentifier);\n           authorizeStartAndResourceIncreaseRequest(\n               nmTokenIdentifier, containerTokenIdentifier, false);\n           containerId \u003d containerTokenIdentifier.getContainerID();\n           // Reuse the startContainer logic to update NMToken,\n           // as container resource increase request will have come with\n           // an updated NMToken.\n           updateNMTokenIdentifier(nmTokenIdentifier);\n-          Resource resource \u003d containerTokenIdentifier.getResource();\n-          changeContainerResourceInternal(containerId,\n-              containerTokenIdentifier.getVersion(), resource, true);\n+          updateContainerInternal(containerId, containerTokenIdentifier);\n           successfullyUpdatedContainers.add(containerId);\n         } catch (YarnException | InvalidToken e) {\n           failedContainers.put(containerId, SerializedException.newInstance(e));\n         } catch (IOException e) {\n           throw RPCUtil.getRemoteException(e);\n         }\n       }\n     }\n     return ContainerUpdateResponse.newInstance(\n         successfullyUpdatedContainers, failedContainers);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ContainerUpdateResponse updateContainer(ContainerUpdateRequest\n      request) throws YarnException, IOException {\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi, nmTokenIdentifier);\n    List\u003cContainerId\u003e successfullyUpdatedContainers\n        \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n    // to avoid race condition during NM-RM resync (due to RM restart) while a\n    // container resource is being increased in NM, in particular when the\n    // increased container has not yet been added to the increasedContainers\n    // map in NMContext.\n    synchronized (this.context) {\n      // Process container resource increase requests\n      for (org.apache.hadoop.yarn.api.records.Token token :\n          request.getContainersToUpdate()) {\n        ContainerId containerId \u003d null;\n        try {\n          if (token.getIdentifier() \u003d\u003d null) {\n            throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n          }\n          ContainerTokenIdentifier containerTokenIdentifier \u003d\n              BuilderUtils.newContainerTokenIdentifier(token);\n          verifyAndGetContainerTokenIdentifier(token,\n              containerTokenIdentifier);\n          authorizeStartAndResourceIncreaseRequest(\n              nmTokenIdentifier, containerTokenIdentifier, false);\n          containerId \u003d containerTokenIdentifier.getContainerID();\n          // Reuse the startContainer logic to update NMToken,\n          // as container resource increase request will have come with\n          // an updated NMToken.\n          updateNMTokenIdentifier(nmTokenIdentifier);\n          updateContainerInternal(containerId, containerTokenIdentifier);\n          successfullyUpdatedContainers.add(containerId);\n        } catch (YarnException | InvalidToken e) {\n          failedContainers.put(containerId, SerializedException.newInstance(e));\n        } catch (IOException e) {\n          throw RPCUtil.getRemoteException(e);\n        }\n      }\n    }\n    return ContainerUpdateResponse.newInstance(\n        successfullyUpdatedContainers, failedContainers);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "35dc7829236f92054d5ce6ea78d3a44ca6c8f3d3": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5977. ContainerManagementProtocol changes to support change of container ExecutionType. (Kartheek Muthyala via asuresh)\n",
      "commitDate": "03/08/17 9:15 PM",
      "commitName": "35dc7829236f92054d5ce6ea78d3a44ca6c8f3d3",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,48 @@\n+  public ContainerUpdateResponse updateContainer(ContainerUpdateRequest\n+      request) throws YarnException, IOException {\n+    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n+    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n+    authorizeUser(remoteUgi, nmTokenIdentifier);\n+    List\u003cContainerId\u003e successfullyUpdatedContainers\n+        \u003d new ArrayList\u003cContainerId\u003e();\n+    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n+        new HashMap\u003cContainerId, SerializedException\u003e();\n+    // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n+    // to avoid race condition during NM-RM resync (due to RM restart) while a\n+    // container resource is being increased in NM, in particular when the\n+    // increased container has not yet been added to the increasedContainers\n+    // map in NMContext.\n+    synchronized (this.context) {\n+      // Process container resource increase requests\n+      for (org.apache.hadoop.yarn.api.records.Token token :\n+          request.getContainersToUpdate()) {\n+        ContainerId containerId \u003d null;\n+        try {\n+          if (token.getIdentifier() \u003d\u003d null) {\n+            throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n+          }\n+          ContainerTokenIdentifier containerTokenIdentifier \u003d\n+              BuilderUtils.newContainerTokenIdentifier(token);\n+          verifyAndGetContainerTokenIdentifier(token,\n+              containerTokenIdentifier);\n+          authorizeStartAndResourceIncreaseRequest(\n+              nmTokenIdentifier, containerTokenIdentifier, false);\n+          containerId \u003d containerTokenIdentifier.getContainerID();\n+          // Reuse the startContainer logic to update NMToken,\n+          // as container resource increase request will have come with\n+          // an updated NMToken.\n+          updateNMTokenIdentifier(nmTokenIdentifier);\n+          Resource resource \u003d containerTokenIdentifier.getResource();\n+          changeContainerResourceInternal(containerId,\n+              containerTokenIdentifier.getVersion(), resource, true);\n+          successfullyUpdatedContainers.add(containerId);\n+        } catch (YarnException | InvalidToken e) {\n+          failedContainers.put(containerId, SerializedException.newInstance(e));\n+        } catch (IOException e) {\n+          throw RPCUtil.getRemoteException(e);\n+        }\n+      }\n+    }\n+    return ContainerUpdateResponse.newInstance(\n+        successfullyUpdatedContainers, failedContainers);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public ContainerUpdateResponse updateContainer(ContainerUpdateRequest\n      request) throws YarnException, IOException {\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    authorizeUser(remoteUgi, nmTokenIdentifier);\n    List\u003cContainerId\u003e successfullyUpdatedContainers\n        \u003d new ArrayList\u003cContainerId\u003e();\n    Map\u003cContainerId, SerializedException\u003e failedContainers \u003d\n        new HashMap\u003cContainerId, SerializedException\u003e();\n    // Synchronize with NodeStatusUpdaterImpl#registerWithRM\n    // to avoid race condition during NM-RM resync (due to RM restart) while a\n    // container resource is being increased in NM, in particular when the\n    // increased container has not yet been added to the increasedContainers\n    // map in NMContext.\n    synchronized (this.context) {\n      // Process container resource increase requests\n      for (org.apache.hadoop.yarn.api.records.Token token :\n          request.getContainersToUpdate()) {\n        ContainerId containerId \u003d null;\n        try {\n          if (token.getIdentifier() \u003d\u003d null) {\n            throw new IOException(INVALID_CONTAINERTOKEN_MSG);\n          }\n          ContainerTokenIdentifier containerTokenIdentifier \u003d\n              BuilderUtils.newContainerTokenIdentifier(token);\n          verifyAndGetContainerTokenIdentifier(token,\n              containerTokenIdentifier);\n          authorizeStartAndResourceIncreaseRequest(\n              nmTokenIdentifier, containerTokenIdentifier, false);\n          containerId \u003d containerTokenIdentifier.getContainerID();\n          // Reuse the startContainer logic to update NMToken,\n          // as container resource increase request will have come with\n          // an updated NMToken.\n          updateNMTokenIdentifier(nmTokenIdentifier);\n          Resource resource \u003d containerTokenIdentifier.getResource();\n          changeContainerResourceInternal(containerId,\n              containerTokenIdentifier.getVersion(), resource, true);\n          successfullyUpdatedContainers.add(containerId);\n        } catch (YarnException | InvalidToken e) {\n          failedContainers.put(containerId, SerializedException.newInstance(e));\n        } catch (IOException e) {\n          throw RPCUtil.getRemoteException(e);\n        }\n      }\n    }\n    return ContainerUpdateResponse.newInstance(\n        successfullyUpdatedContainers, failedContainers);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java"
    }
  }
}