{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RegistryAdminService.java",
  "functionName": "purge",
  "functionId": "purge___path-String__selector-NodeSelector__purgePolicy-PurgePolicy__callback-BackgroundCallback",
  "sourceFilePath": "hadoop-common-project/hadoop-registry/src/main/java/org/apache/hadoop/registry/server/services/RegistryAdminService.java",
  "functionStartLine": 388,
  "functionEndLine": 477,
  "numCommitsSeen": 7,
  "timeTaken": 1200,
  "changeHistory": [
    "e2a9fa8448e2aac34c318260e425786a6c8ca2ae",
    "6a326711aa27e84fd4c53937afc5c41a746ec65a"
  ],
  "changeHistoryShort": {
    "e2a9fa8448e2aac34c318260e425786a6c8ca2ae": "Yfilerename",
    "6a326711aa27e84fd4c53937afc5c41a746ec65a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e2a9fa8448e2aac34c318260e425786a6c8ca2ae": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-15821. Move YARN Registry to Hadoop Registry.\n              Contributed by Íñigo Goiri\n",
      "commitDate": "19/10/18 4:46 PM",
      "commitName": "e2a9fa8448e2aac34c318260e425786a6c8ca2ae",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "19/10/18 1:57 PM",
      "commitNameOld": "00254d7b8c714ae2000d0934d260b23458033529",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public int purge(String path,\n      NodeSelector selector,\n      PurgePolicy purgePolicy,\n      BackgroundCallback callback) throws IOException {\n\n\n    boolean toDelete \u003d false;\n    // look at self to see if it has a service record\n    Map\u003cString, RegistryPathStatus\u003e childEntries;\n    Collection\u003cRegistryPathStatus\u003e entries;\n    try {\n      // list this path\u0027s children\n      childEntries \u003d RegistryUtils.statChildren(this, path);\n      entries \u003d childEntries.values();\n    } catch (PathNotFoundException e) {\n      // there\u0027s no record here, it may have been deleted already.\n      // exit\n      return 0;\n    }\n\n    try {\n      RegistryPathStatus registryPathStatus \u003d stat(path);\n      ServiceRecord serviceRecord \u003d resolve(path);\n      // there is now an entry here.\n      toDelete \u003d selector.shouldSelect(path, registryPathStatus, serviceRecord);\n    } catch (EOFException ignored) {\n      // ignore\n    } catch (InvalidRecordException ignored) {\n      // ignore\n    } catch (NoRecordException ignored) {\n      // ignore\n    } catch (PathNotFoundException e) {\n      // there\u0027s no record here, it may have been deleted already.\n      // exit\n      return 0;\n    }\n\n    if (toDelete \u0026\u0026 !entries.isEmpty()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Match on record @ {} with children \", path);\n      }\n      // there\u0027s children\n      switch (purgePolicy) {\n        case SkipOnChildren:\n          // don\u0027t do the deletion... continue to next record\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Skipping deletion\");\n          }\n          toDelete \u003d false;\n          break;\n        case PurgeAll:\n          // mark for deletion\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Scheduling for deletion with children\");\n          }\n          toDelete \u003d true;\n          entries \u003d new ArrayList\u003cRegistryPathStatus\u003e(0);\n          break;\n        case FailOnChildren:\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Failing deletion operation\");\n          }\n          throw new PathIsNotEmptyDirectoryException(path);\n      }\n    }\n\n    int deleteOps \u003d 0;\n    if (toDelete) {\n      try {\n        zkDelete(path, true, callback);\n      } catch (PathNotFoundException e) {\n        // sign that the path was deleted during the operation.\n        // this is a no-op, and all children can be skipped\n        return deleteOps;\n      }\n      deleteOps++;\n    }\n\n    // now go through the children\n    for (RegistryPathStatus status : entries) {\n      String childname \u003d status.path;\n      String childpath \u003d RegistryPathUtils.join(path, childname);\n      deleteOps +\u003d purge(childpath,\n          selector,\n          purgePolicy,\n          callback);\n    }\n\n    return deleteOps;\n  }",
      "path": "hadoop-common-project/hadoop-registry/src/main/java/org/apache/hadoop/registry/server/services/RegistryAdminService.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-registry/src/main/java/org/apache/hadoop/registry/server/services/RegistryAdminService.java",
        "newPath": "hadoop-common-project/hadoop-registry/src/main/java/org/apache/hadoop/registry/server/services/RegistryAdminService.java"
      }
    },
    "6a326711aa27e84fd4c53937afc5c41a746ec65a": {
      "type": "Yintroduced",
      "commitMessage": "YARN-913 service registry: YARN-2652 add hadoop-yarn-registry package under hadoop-yarn\n",
      "commitDate": "08/10/14 1:02 PM",
      "commitName": "6a326711aa27e84fd4c53937afc5c41a746ec65a",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,90 @@\n+  public int purge(String path,\n+      NodeSelector selector,\n+      PurgePolicy purgePolicy,\n+      BackgroundCallback callback) throws IOException {\n+\n+\n+    boolean toDelete \u003d false;\n+    // look at self to see if it has a service record\n+    Map\u003cString, RegistryPathStatus\u003e childEntries;\n+    Collection\u003cRegistryPathStatus\u003e entries;\n+    try {\n+      // list this path\u0027s children\n+      childEntries \u003d RegistryUtils.statChildren(this, path);\n+      entries \u003d childEntries.values();\n+    } catch (PathNotFoundException e) {\n+      // there\u0027s no record here, it may have been deleted already.\n+      // exit\n+      return 0;\n+    }\n+\n+    try {\n+      RegistryPathStatus registryPathStatus \u003d stat(path);\n+      ServiceRecord serviceRecord \u003d resolve(path);\n+      // there is now an entry here.\n+      toDelete \u003d selector.shouldSelect(path, registryPathStatus, serviceRecord);\n+    } catch (EOFException ignored) {\n+      // ignore\n+    } catch (InvalidRecordException ignored) {\n+      // ignore\n+    } catch (NoRecordException ignored) {\n+      // ignore\n+    } catch (PathNotFoundException e) {\n+      // there\u0027s no record here, it may have been deleted already.\n+      // exit\n+      return 0;\n+    }\n+\n+    if (toDelete \u0026\u0026 !entries.isEmpty()) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Match on record @ {} with children \", path);\n+      }\n+      // there\u0027s children\n+      switch (purgePolicy) {\n+        case SkipOnChildren:\n+          // don\u0027t do the deletion... continue to next record\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Skipping deletion\");\n+          }\n+          toDelete \u003d false;\n+          break;\n+        case PurgeAll:\n+          // mark for deletion\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Scheduling for deletion with children\");\n+          }\n+          toDelete \u003d true;\n+          entries \u003d new ArrayList\u003cRegistryPathStatus\u003e(0);\n+          break;\n+        case FailOnChildren:\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Failing deletion operation\");\n+          }\n+          throw new PathIsNotEmptyDirectoryException(path);\n+      }\n+    }\n+\n+    int deleteOps \u003d 0;\n+    if (toDelete) {\n+      try {\n+        zkDelete(path, true, callback);\n+      } catch (PathNotFoundException e) {\n+        // sign that the path was deleted during the operation.\n+        // this is a no-op, and all children can be skipped\n+        return deleteOps;\n+      }\n+      deleteOps++;\n+    }\n+\n+    // now go through the children\n+    for (RegistryPathStatus status : entries) {\n+      String childname \u003d status.path;\n+      String childpath \u003d RegistryPathUtils.join(path, childname);\n+      deleteOps +\u003d purge(childpath,\n+          selector,\n+          purgePolicy,\n+          callback);\n+    }\n+\n+    return deleteOps;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int purge(String path,\n      NodeSelector selector,\n      PurgePolicy purgePolicy,\n      BackgroundCallback callback) throws IOException {\n\n\n    boolean toDelete \u003d false;\n    // look at self to see if it has a service record\n    Map\u003cString, RegistryPathStatus\u003e childEntries;\n    Collection\u003cRegistryPathStatus\u003e entries;\n    try {\n      // list this path\u0027s children\n      childEntries \u003d RegistryUtils.statChildren(this, path);\n      entries \u003d childEntries.values();\n    } catch (PathNotFoundException e) {\n      // there\u0027s no record here, it may have been deleted already.\n      // exit\n      return 0;\n    }\n\n    try {\n      RegistryPathStatus registryPathStatus \u003d stat(path);\n      ServiceRecord serviceRecord \u003d resolve(path);\n      // there is now an entry here.\n      toDelete \u003d selector.shouldSelect(path, registryPathStatus, serviceRecord);\n    } catch (EOFException ignored) {\n      // ignore\n    } catch (InvalidRecordException ignored) {\n      // ignore\n    } catch (NoRecordException ignored) {\n      // ignore\n    } catch (PathNotFoundException e) {\n      // there\u0027s no record here, it may have been deleted already.\n      // exit\n      return 0;\n    }\n\n    if (toDelete \u0026\u0026 !entries.isEmpty()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Match on record @ {} with children \", path);\n      }\n      // there\u0027s children\n      switch (purgePolicy) {\n        case SkipOnChildren:\n          // don\u0027t do the deletion... continue to next record\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Skipping deletion\");\n          }\n          toDelete \u003d false;\n          break;\n        case PurgeAll:\n          // mark for deletion\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Scheduling for deletion with children\");\n          }\n          toDelete \u003d true;\n          entries \u003d new ArrayList\u003cRegistryPathStatus\u003e(0);\n          break;\n        case FailOnChildren:\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Failing deletion operation\");\n          }\n          throw new PathIsNotEmptyDirectoryException(path);\n      }\n    }\n\n    int deleteOps \u003d 0;\n    if (toDelete) {\n      try {\n        zkDelete(path, true, callback);\n      } catch (PathNotFoundException e) {\n        // sign that the path was deleted during the operation.\n        // this is a no-op, and all children can be skipped\n        return deleteOps;\n      }\n      deleteOps++;\n    }\n\n    // now go through the children\n    for (RegistryPathStatus status : entries) {\n      String childname \u003d status.path;\n      String childpath \u003d RegistryPathUtils.join(path, childname);\n      deleteOps +\u003d purge(childpath,\n          selector,\n          purgePolicy,\n          callback);\n    }\n\n    return deleteOps;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-registry/src/main/java/org/apache/hadoop/registry/server/services/RegistryAdminService.java"
    }
  }
}