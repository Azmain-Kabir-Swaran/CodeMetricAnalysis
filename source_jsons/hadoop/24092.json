{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LocalDistributedCacheManager.java",
  "functionName": "setup",
  "functionId": "setup___conf-JobConf__jobId-JobID",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
  "functionStartLine": 86,
  "functionEndLine": 187,
  "numCommitsSeen": 26,
  "timeTaken": 3578,
  "changeHistory": [
    "a2cdffb95acbcb3625ee72ebc8aeb8bf17fa4bc7",
    "edb202e4934be750e43103c047752b97c5eafc94",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "2440671a117f165dcda5056404bc898df3c50803",
    "d50e8f09287deeb51012d08e326a2ed71a6da869",
    "3a54a5653bf1ea0b5b98e223c7500a9606abf04d",
    "050fd3a11744cde3d54c1fff23d8fdeb3803bf92",
    "735b50e8bd23f7fbeff3a08cf8f3fff8cbff7449",
    "e9bf6c56c556a92b72da65ad12fc19a1825b8376",
    "13ad75679642adf120a36199bf9e8df673b9b38f",
    "8b2f6909ec7df5cffb5ef417f5c9cffdee43e38a",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
    "cfb6a9883d2bf02c99f258e9f19ffcd83805d077"
  ],
  "changeHistoryShort": {
    "a2cdffb95acbcb3625ee72ebc8aeb8bf17fa4bc7": "Ymodifierchange",
    "edb202e4934be750e43103c047752b97c5eafc94": "Ymultichange(Yparameterchange,Ybodychange)",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "2440671a117f165dcda5056404bc898df3c50803": "Ybodychange",
    "d50e8f09287deeb51012d08e326a2ed71a6da869": "Ybodychange",
    "3a54a5653bf1ea0b5b98e223c7500a9606abf04d": "Ybodychange",
    "050fd3a11744cde3d54c1fff23d8fdeb3803bf92": "Ybodychange",
    "735b50e8bd23f7fbeff3a08cf8f3fff8cbff7449": "Ybodychange",
    "e9bf6c56c556a92b72da65ad12fc19a1825b8376": "Ybodychange",
    "13ad75679642adf120a36199bf9e8df673b9b38f": "Ybodychange",
    "8b2f6909ec7df5cffb5ef417f5c9cffdee43e38a": "Ybodychange",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": "Ybodychange",
    "cfb6a9883d2bf02c99f258e9f19ffcd83805d077": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a2cdffb95acbcb3625ee72ebc8aeb8bf17fa4bc7": {
      "type": "Ymodifierchange",
      "commitMessage": "MAPREDUCE-7094. LocalDistributedCacheManager leaves classloaders open, which leaks FDs. Contributed by Adam Szita.\n",
      "commitDate": "17/05/18 11:16 AM",
      "commitName": "a2cdffb95acbcb3625ee72ebc8aeb8bf17fa4bc7",
      "commitAuthor": "Miklos Szegedi",
      "commitDateOld": "26/03/18 2:55 PM",
      "commitNameOld": "edb202e4934be750e43103c047752b97c5eafc94",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 51.85,
      "commitsBetweenForRepo": 861,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n-  public void setup(JobConf conf, JobID jobId) throws IOException {\n+  public synchronized void setup(JobConf conf, JobID jobId) throws IOException {\n     File workDir \u003d new File(System.getProperty(\"user.dir\"));\n     \n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n     // Generating unique numbers for FSDownload.\n \n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n     ExecutorService exec \u003d null;\n     try {\n       ThreadFactory tf \u003d new ThreadFactoryBuilder()\n       .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n       .build();\n       exec \u003d HadoopExecutors.newCachedThreadPool(tf);\n       Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n       Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n       for (LocalResource resource : localResources.values()) {\n         Path destPathForDownload \u003d new Path(destPath,\n             jobId.toString() + \"_\" + UUID.randomUUID().toString());\n         Callable\u003cPath\u003e download \u003d\n             new FSDownload(localFSFileContext, ugi, conf, destPathForDownload,\n                 resource);\n         Future\u003cPath\u003e future \u003d exec.submit(download);\n         resourcesToPaths.put(resource, future);\n       }\n       for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n         LocalResource resource \u003d entry.getValue();\n         Path path;\n         try {\n           path \u003d resourcesToPaths.get(resource).get();\n         } catch (InterruptedException e) {\n           throw new IOException(e);\n         } catch (ExecutionException e) {\n           throw new IOException(e);\n         }\n         String pathString \u003d path.toUri().toString();\n         String link \u003d entry.getKey();\n         String target \u003d new File(path.toUri()).getPath();\n         symlink(workDir, target, link);\n         \n         if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n           localArchives.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n           localFiles.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n           //PATTERN is not currently used in local mode\n           throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n           \t\t\"implemented yet. \" + resource.getResource());\n         }\n         Path resourcePath;\n         try {\n           resourcePath \u003d resource.getResource().toPath();\n         } catch (URISyntaxException e) {\n           throw new IOException(e);\n         }\n         LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n         String cp \u003d resourcePath.toUri().getPath();\n         if (classpaths.keySet().contains(cp)) {\n           localClasspaths.add(path.toUri().getPath().toString());\n         }\n       }\n     } finally {\n       if (exec !\u003d null) {\n         exec.shutdown();\n       }\n     }    \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void setup(JobConf conf, JobID jobId) throws IOException {\n    File workDir \u003d new File(System.getProperty(\"user.dir\"));\n    \n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    // Generating unique numbers for FSDownload.\n\n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    ExecutorService exec \u003d null;\n    try {\n      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n      .build();\n      exec \u003d HadoopExecutors.newCachedThreadPool(tf);\n      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Path destPathForDownload \u003d new Path(destPath,\n            jobId.toString() + \"_\" + UUID.randomUUID().toString());\n        Callable\u003cPath\u003e download \u003d\n            new FSDownload(localFSFileContext, ugi, conf, destPathForDownload,\n                resource);\n        Future\u003cPath\u003e future \u003d exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n        LocalResource resource \u003d entry.getValue();\n        Path path;\n        try {\n          path \u003d resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString \u003d path.toUri().toString();\n        String link \u003d entry.getKey();\n        String target \u003d new File(path.toUri()).getPath();\n        symlink(workDir, target, link);\n        \n        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n          //PATTERN is not currently used in local mode\n          throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n          \t\t\"implemented yet. \" + resource.getResource());\n        }\n        Path resourcePath;\n        try {\n          resourcePath \u003d resource.getResource().toPath();\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp \u003d resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec !\u003d null) {\n        exec.shutdown();\n      }\n    }    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    setupCalled \u003d true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[public, synchronized]"
      }
    },
    "edb202e4934be750e43103c047752b97c5eafc94": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-6441. Improve temporary directory name generation in LocalDistributedCacheManager for concurrent processes (wattsinabox, rchiang, haibochen via rkanter)\n",
      "commitDate": "26/03/18 2:55 PM",
      "commitName": "edb202e4934be750e43103c047752b97c5eafc94",
      "commitAuthor": "Robert Kanter",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-6441. Improve temporary directory name generation in LocalDistributedCacheManager for concurrent processes (wattsinabox, rchiang, haibochen via rkanter)\n",
          "commitDate": "26/03/18 2:55 PM",
          "commitName": "edb202e4934be750e43103c047752b97c5eafc94",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "27/10/17 2:45 AM",
          "commitNameOld": "de09716fb8782596ccf44a3cfc90ac3c4f288667",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 150.51,
          "commitsBetweenForRepo": 1139,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,103 +1,102 @@\n-  public void setup(JobConf conf) throws IOException {\n+  public void setup(JobConf conf, JobID jobId) throws IOException {\n     File workDir \u003d new File(System.getProperty(\"user.dir\"));\n     \n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n     // Generating unique numbers for FSDownload.\n-    AtomicLong uniqueNumberGenerator \u003d\n-        new AtomicLong(System.currentTimeMillis());\n-    \n+\n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n     ExecutorService exec \u003d null;\n     try {\n       ThreadFactory tf \u003d new ThreadFactoryBuilder()\n       .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n       .build();\n       exec \u003d HadoopExecutors.newCachedThreadPool(tf);\n       Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n       Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n       for (LocalResource resource : localResources.values()) {\n+        Path destPathForDownload \u003d new Path(destPath,\n+            jobId.toString() + \"_\" + UUID.randomUUID().toString());\n         Callable\u003cPath\u003e download \u003d\n-            new FSDownload(localFSFileContext, ugi, conf, new Path(destPath,\n-                Long.toString(uniqueNumberGenerator.incrementAndGet())),\n+            new FSDownload(localFSFileContext, ugi, conf, destPathForDownload,\n                 resource);\n         Future\u003cPath\u003e future \u003d exec.submit(download);\n         resourcesToPaths.put(resource, future);\n       }\n       for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n         LocalResource resource \u003d entry.getValue();\n         Path path;\n         try {\n           path \u003d resourcesToPaths.get(resource).get();\n         } catch (InterruptedException e) {\n           throw new IOException(e);\n         } catch (ExecutionException e) {\n           throw new IOException(e);\n         }\n         String pathString \u003d path.toUri().toString();\n         String link \u003d entry.getKey();\n         String target \u003d new File(path.toUri()).getPath();\n         symlink(workDir, target, link);\n         \n         if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n           localArchives.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n           localFiles.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n           //PATTERN is not currently used in local mode\n           throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n           \t\t\"implemented yet. \" + resource.getResource());\n         }\n         Path resourcePath;\n         try {\n           resourcePath \u003d resource.getResource().toPath();\n         } catch (URISyntaxException e) {\n           throw new IOException(e);\n         }\n         LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n         String cp \u003d resourcePath.toUri().getPath();\n         if (classpaths.keySet().contains(cp)) {\n           localClasspaths.add(path.toUri().getPath().toString());\n         }\n       }\n     } finally {\n       if (exec !\u003d null) {\n         exec.shutdown();\n       }\n     }    \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void setup(JobConf conf, JobID jobId) throws IOException {\n    File workDir \u003d new File(System.getProperty(\"user.dir\"));\n    \n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    // Generating unique numbers for FSDownload.\n\n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    ExecutorService exec \u003d null;\n    try {\n      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n      .build();\n      exec \u003d HadoopExecutors.newCachedThreadPool(tf);\n      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Path destPathForDownload \u003d new Path(destPath,\n            jobId.toString() + \"_\" + UUID.randomUUID().toString());\n        Callable\u003cPath\u003e download \u003d\n            new FSDownload(localFSFileContext, ugi, conf, destPathForDownload,\n                resource);\n        Future\u003cPath\u003e future \u003d exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n        LocalResource resource \u003d entry.getValue();\n        Path path;\n        try {\n          path \u003d resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString \u003d path.toUri().toString();\n        String link \u003d entry.getKey();\n        String target \u003d new File(path.toUri()).getPath();\n        symlink(workDir, target, link);\n        \n        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n          //PATTERN is not currently used in local mode\n          throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n          \t\t\"implemented yet. \" + resource.getResource());\n        }\n        Path resourcePath;\n        try {\n          resourcePath \u003d resource.getResource().toPath();\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp \u003d resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec !\u003d null) {\n        exec.shutdown();\n      }\n    }    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    setupCalled \u003d true;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
          "extendedDetails": {
            "oldValue": "[conf-JobConf]",
            "newValue": "[conf-JobConf, jobId-JobID]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-6441. Improve temporary directory name generation in LocalDistributedCacheManager for concurrent processes (wattsinabox, rchiang, haibochen via rkanter)\n",
          "commitDate": "26/03/18 2:55 PM",
          "commitName": "edb202e4934be750e43103c047752b97c5eafc94",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "27/10/17 2:45 AM",
          "commitNameOld": "de09716fb8782596ccf44a3cfc90ac3c4f288667",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 150.51,
          "commitsBetweenForRepo": 1139,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,103 +1,102 @@\n-  public void setup(JobConf conf) throws IOException {\n+  public void setup(JobConf conf, JobID jobId) throws IOException {\n     File workDir \u003d new File(System.getProperty(\"user.dir\"));\n     \n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n     // Generating unique numbers for FSDownload.\n-    AtomicLong uniqueNumberGenerator \u003d\n-        new AtomicLong(System.currentTimeMillis());\n-    \n+\n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n     ExecutorService exec \u003d null;\n     try {\n       ThreadFactory tf \u003d new ThreadFactoryBuilder()\n       .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n       .build();\n       exec \u003d HadoopExecutors.newCachedThreadPool(tf);\n       Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n       Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n       for (LocalResource resource : localResources.values()) {\n+        Path destPathForDownload \u003d new Path(destPath,\n+            jobId.toString() + \"_\" + UUID.randomUUID().toString());\n         Callable\u003cPath\u003e download \u003d\n-            new FSDownload(localFSFileContext, ugi, conf, new Path(destPath,\n-                Long.toString(uniqueNumberGenerator.incrementAndGet())),\n+            new FSDownload(localFSFileContext, ugi, conf, destPathForDownload,\n                 resource);\n         Future\u003cPath\u003e future \u003d exec.submit(download);\n         resourcesToPaths.put(resource, future);\n       }\n       for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n         LocalResource resource \u003d entry.getValue();\n         Path path;\n         try {\n           path \u003d resourcesToPaths.get(resource).get();\n         } catch (InterruptedException e) {\n           throw new IOException(e);\n         } catch (ExecutionException e) {\n           throw new IOException(e);\n         }\n         String pathString \u003d path.toUri().toString();\n         String link \u003d entry.getKey();\n         String target \u003d new File(path.toUri()).getPath();\n         symlink(workDir, target, link);\n         \n         if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n           localArchives.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n           localFiles.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n           //PATTERN is not currently used in local mode\n           throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n           \t\t\"implemented yet. \" + resource.getResource());\n         }\n         Path resourcePath;\n         try {\n           resourcePath \u003d resource.getResource().toPath();\n         } catch (URISyntaxException e) {\n           throw new IOException(e);\n         }\n         LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n         String cp \u003d resourcePath.toUri().getPath();\n         if (classpaths.keySet().contains(cp)) {\n           localClasspaths.add(path.toUri().getPath().toString());\n         }\n       }\n     } finally {\n       if (exec !\u003d null) {\n         exec.shutdown();\n       }\n     }    \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void setup(JobConf conf, JobID jobId) throws IOException {\n    File workDir \u003d new File(System.getProperty(\"user.dir\"));\n    \n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    // Generating unique numbers for FSDownload.\n\n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    ExecutorService exec \u003d null;\n    try {\n      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n      .build();\n      exec \u003d HadoopExecutors.newCachedThreadPool(tf);\n      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Path destPathForDownload \u003d new Path(destPath,\n            jobId.toString() + \"_\" + UUID.randomUUID().toString());\n        Callable\u003cPath\u003e download \u003d\n            new FSDownload(localFSFileContext, ugi, conf, destPathForDownload,\n                resource);\n        Future\u003cPath\u003e future \u003d exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n        LocalResource resource \u003d entry.getValue();\n        Path path;\n        try {\n          path \u003d resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString \u003d path.toUri().toString();\n        String link \u003d entry.getKey();\n        String target \u003d new File(path.toUri()).getPath();\n        symlink(workDir, target, link);\n        \n        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n          //PATTERN is not currently used in local mode\n          throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n          \t\t\"implemented yet. \" + resource.getResource());\n        }\n        Path resourcePath;\n        try {\n          resourcePath \u003d resource.getResource().toPath();\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp \u003d resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec !\u003d null) {\n        exec.shutdown();\n      }\n    }    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    setupCalled \u003d true;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/02/16 12:48 AM",
      "commitNameOld": "2440671a117f165dcda5056404bc898df3c50803",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 117.55,
      "commitsBetweenForRepo": 742,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,103 @@\n   public void setup(JobConf conf) throws IOException {\n     File workDir \u003d new File(System.getProperty(\"user.dir\"));\n     \n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n     // Generating unique numbers for FSDownload.\n     AtomicLong uniqueNumberGenerator \u003d\n         new AtomicLong(System.currentTimeMillis());\n     \n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n     ExecutorService exec \u003d null;\n     try {\n       ThreadFactory tf \u003d new ThreadFactoryBuilder()\n       .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n       .build();\n       exec \u003d HadoopExecutors.newCachedThreadPool(tf);\n       Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n       Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n       for (LocalResource resource : localResources.values()) {\n         Callable\u003cPath\u003e download \u003d\n             new FSDownload(localFSFileContext, ugi, conf, new Path(destPath,\n                 Long.toString(uniqueNumberGenerator.incrementAndGet())),\n                 resource);\n         Future\u003cPath\u003e future \u003d exec.submit(download);\n         resourcesToPaths.put(resource, future);\n       }\n       for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n         LocalResource resource \u003d entry.getValue();\n         Path path;\n         try {\n           path \u003d resourcesToPaths.get(resource).get();\n         } catch (InterruptedException e) {\n           throw new IOException(e);\n         } catch (ExecutionException e) {\n           throw new IOException(e);\n         }\n         String pathString \u003d path.toUri().toString();\n         String link \u003d entry.getKey();\n         String target \u003d new File(path.toUri()).getPath();\n         symlink(workDir, target, link);\n         \n         if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n           localArchives.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n           localFiles.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n           //PATTERN is not currently used in local mode\n           throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n           \t\t\"implemented yet. \" + resource.getResource());\n         }\n         Path resourcePath;\n         try {\n-          resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n+          resourcePath \u003d resource.getResource().toPath();\n         } catch (URISyntaxException e) {\n           throw new IOException(e);\n         }\n         LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n         String cp \u003d resourcePath.toUri().getPath();\n         if (classpaths.keySet().contains(cp)) {\n           localClasspaths.add(path.toUri().getPath().toString());\n         }\n       }\n     } finally {\n       if (exec !\u003d null) {\n         exec.shutdown();\n       }\n     }    \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setup(JobConf conf) throws IOException {\n    File workDir \u003d new File(System.getProperty(\"user.dir\"));\n    \n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    // Generating unique numbers for FSDownload.\n    AtomicLong uniqueNumberGenerator \u003d\n        new AtomicLong(System.currentTimeMillis());\n    \n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    ExecutorService exec \u003d null;\n    try {\n      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n      .build();\n      exec \u003d HadoopExecutors.newCachedThreadPool(tf);\n      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Callable\u003cPath\u003e download \u003d\n            new FSDownload(localFSFileContext, ugi, conf, new Path(destPath,\n                Long.toString(uniqueNumberGenerator.incrementAndGet())),\n                resource);\n        Future\u003cPath\u003e future \u003d exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n        LocalResource resource \u003d entry.getValue();\n        Path path;\n        try {\n          path \u003d resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString \u003d path.toUri().toString();\n        String link \u003d entry.getKey();\n        String target \u003d new File(path.toUri()).getPath();\n        symlink(workDir, target, link);\n        \n        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n          //PATTERN is not currently used in local mode\n          throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n          \t\t\"implemented yet. \" + resource.getResource());\n        }\n        Path resourcePath;\n        try {\n          resourcePath \u003d resource.getResource().toPath();\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp \u003d resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec !\u003d null) {\n        exec.shutdown();\n      }\n    }    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    setupCalled \u003d true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
      "extendedDetails": {}
    },
    "2440671a117f165dcda5056404bc898df3c50803": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6634. Log uncaught exceptions/errors in various thread pools in mapreduce. Contributed by Sidharta Seethana.\n",
      "commitDate": "18/02/16 12:48 AM",
      "commitName": "2440671a117f165dcda5056404bc898df3c50803",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "20/04/15 2:14 PM",
      "commitNameOld": "d50e8f09287deeb51012d08e326a2ed71a6da869",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 303.48,
      "commitsBetweenForRepo": 2366,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,103 @@\n   public void setup(JobConf conf) throws IOException {\n     File workDir \u003d new File(System.getProperty(\"user.dir\"));\n     \n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n     // Generating unique numbers for FSDownload.\n     AtomicLong uniqueNumberGenerator \u003d\n         new AtomicLong(System.currentTimeMillis());\n     \n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n     ExecutorService exec \u003d null;\n     try {\n       ThreadFactory tf \u003d new ThreadFactoryBuilder()\n       .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n       .build();\n-      exec \u003d Executors.newCachedThreadPool(tf);\n+      exec \u003d HadoopExecutors.newCachedThreadPool(tf);\n       Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n       Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n       for (LocalResource resource : localResources.values()) {\n         Callable\u003cPath\u003e download \u003d\n             new FSDownload(localFSFileContext, ugi, conf, new Path(destPath,\n                 Long.toString(uniqueNumberGenerator.incrementAndGet())),\n                 resource);\n         Future\u003cPath\u003e future \u003d exec.submit(download);\n         resourcesToPaths.put(resource, future);\n       }\n       for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n         LocalResource resource \u003d entry.getValue();\n         Path path;\n         try {\n           path \u003d resourcesToPaths.get(resource).get();\n         } catch (InterruptedException e) {\n           throw new IOException(e);\n         } catch (ExecutionException e) {\n           throw new IOException(e);\n         }\n         String pathString \u003d path.toUri().toString();\n         String link \u003d entry.getKey();\n         String target \u003d new File(path.toUri()).getPath();\n         symlink(workDir, target, link);\n         \n         if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n           localArchives.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n           localFiles.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n           //PATTERN is not currently used in local mode\n           throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n           \t\t\"implemented yet. \" + resource.getResource());\n         }\n         Path resourcePath;\n         try {\n           resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n         } catch (URISyntaxException e) {\n           throw new IOException(e);\n         }\n         LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n         String cp \u003d resourcePath.toUri().getPath();\n         if (classpaths.keySet().contains(cp)) {\n           localClasspaths.add(path.toUri().getPath().toString());\n         }\n       }\n     } finally {\n       if (exec !\u003d null) {\n         exec.shutdown();\n       }\n     }    \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setup(JobConf conf) throws IOException {\n    File workDir \u003d new File(System.getProperty(\"user.dir\"));\n    \n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    // Generating unique numbers for FSDownload.\n    AtomicLong uniqueNumberGenerator \u003d\n        new AtomicLong(System.currentTimeMillis());\n    \n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    ExecutorService exec \u003d null;\n    try {\n      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n      .build();\n      exec \u003d HadoopExecutors.newCachedThreadPool(tf);\n      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Callable\u003cPath\u003e download \u003d\n            new FSDownload(localFSFileContext, ugi, conf, new Path(destPath,\n                Long.toString(uniqueNumberGenerator.incrementAndGet())),\n                resource);\n        Future\u003cPath\u003e future \u003d exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n        LocalResource resource \u003d entry.getValue();\n        Path path;\n        try {\n          path \u003d resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString \u003d path.toUri().toString();\n        String link \u003d entry.getKey();\n        String target \u003d new File(path.toUri()).getPath();\n        symlink(workDir, target, link);\n        \n        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n          //PATTERN is not currently used in local mode\n          throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n          \t\t\"implemented yet. \" + resource.getResource());\n        }\n        Path resourcePath;\n        try {\n          resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp \u003d resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec !\u003d null) {\n        exec.shutdown();\n      }\n    }    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    setupCalled \u003d true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
      "extendedDetails": {}
    },
    "d50e8f09287deeb51012d08e326a2ed71a6da869": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6238. MR2 can\u0027t run local jobs with -libjars command options which is a regression from MR1 (zxu via rkanter)\n",
      "commitDate": "20/04/15 2:14 PM",
      "commitName": "d50e8f09287deeb51012d08e326a2ed71a6da869",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "09/04/13 12:56 PM",
      "commitNameOld": "3a54a5653bf1ea0b5b98e223c7500a9606abf04d",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 741.05,
      "commitsBetweenForRepo": 5481,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,103 @@\n   public void setup(JobConf conf) throws IOException {\n     File workDir \u003d new File(System.getProperty(\"user.dir\"));\n     \n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n     // Generating unique numbers for FSDownload.\n     AtomicLong uniqueNumberGenerator \u003d\n         new AtomicLong(System.currentTimeMillis());\n     \n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n-        FileSystem remoteFS \u003d p.getFileSystem(conf);\n-        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n-            remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n-        FileSystem remoteFS \u003d p.getFileSystem(conf);\n-        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n-            remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n     ExecutorService exec \u003d null;\n     try {\n       ThreadFactory tf \u003d new ThreadFactoryBuilder()\n       .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n       .build();\n       exec \u003d Executors.newCachedThreadPool(tf);\n       Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n       Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n       for (LocalResource resource : localResources.values()) {\n         Callable\u003cPath\u003e download \u003d\n             new FSDownload(localFSFileContext, ugi, conf, new Path(destPath,\n                 Long.toString(uniqueNumberGenerator.incrementAndGet())),\n                 resource);\n         Future\u003cPath\u003e future \u003d exec.submit(download);\n         resourcesToPaths.put(resource, future);\n       }\n       for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n         LocalResource resource \u003d entry.getValue();\n         Path path;\n         try {\n           path \u003d resourcesToPaths.get(resource).get();\n         } catch (InterruptedException e) {\n           throw new IOException(e);\n         } catch (ExecutionException e) {\n           throw new IOException(e);\n         }\n         String pathString \u003d path.toUri().toString();\n         String link \u003d entry.getKey();\n         String target \u003d new File(path.toUri()).getPath();\n         symlink(workDir, target, link);\n         \n         if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n           localArchives.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n           localFiles.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n           //PATTERN is not currently used in local mode\n           throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n           \t\t\"implemented yet. \" + resource.getResource());\n         }\n         Path resourcePath;\n         try {\n           resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n         } catch (URISyntaxException e) {\n           throw new IOException(e);\n         }\n         LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n         String cp \u003d resourcePath.toUri().getPath();\n         if (classpaths.keySet().contains(cp)) {\n           localClasspaths.add(path.toUri().getPath().toString());\n         }\n       }\n     } finally {\n       if (exec !\u003d null) {\n         exec.shutdown();\n       }\n     }    \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setup(JobConf conf) throws IOException {\n    File workDir \u003d new File(System.getProperty(\"user.dir\"));\n    \n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    // Generating unique numbers for FSDownload.\n    AtomicLong uniqueNumberGenerator \u003d\n        new AtomicLong(System.currentTimeMillis());\n    \n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    ExecutorService exec \u003d null;\n    try {\n      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n      .build();\n      exec \u003d Executors.newCachedThreadPool(tf);\n      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Callable\u003cPath\u003e download \u003d\n            new FSDownload(localFSFileContext, ugi, conf, new Path(destPath,\n                Long.toString(uniqueNumberGenerator.incrementAndGet())),\n                resource);\n        Future\u003cPath\u003e future \u003d exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n        LocalResource resource \u003d entry.getValue();\n        Path path;\n        try {\n          path \u003d resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString \u003d path.toUri().toString();\n        String link \u003d entry.getKey();\n        String target \u003d new File(path.toUri()).getPath();\n        symlink(workDir, target, link);\n        \n        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n          //PATTERN is not currently used in local mode\n          throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n          \t\t\"implemented yet. \" + resource.getResource());\n        }\n        Path resourcePath;\n        try {\n          resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp \u003d resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec !\u003d null) {\n        exec.shutdown();\n      }\n    }    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    setupCalled \u003d true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
      "extendedDetails": {}
    },
    "3a54a5653bf1ea0b5b98e223c7500a9606abf04d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-112. Fixed a race condition during localization that fails containers. Contributed by Omkar Vinit Joshi.\nMAPREDUCE-5138. Fix LocalDistributedCacheManager after YARN-112. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1466196 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/04/13 12:56 PM",
      "commitName": "3a54a5653bf1ea0b5b98e223c7500a9606abf04d",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "26/09/12 8:22 AM",
      "commitNameOld": "050fd3a11744cde3d54c1fff23d8fdeb3803bf92",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 195.19,
      "commitsBetweenForRepo": 935,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,109 @@\n   public void setup(JobConf conf) throws IOException {\n     File workDir \u003d new File(System.getProperty(\"user.dir\"));\n     \n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n+    // Generating unique numbers for FSDownload.\n+    AtomicLong uniqueNumberGenerator \u003d\n+        new AtomicLong(System.currentTimeMillis());\n     \n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n     ExecutorService exec \u003d null;\n     try {\n       ThreadFactory tf \u003d new ThreadFactoryBuilder()\n       .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n       .build();\n       exec \u003d Executors.newCachedThreadPool(tf);\n       Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n       Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n       for (LocalResource resource : localResources.values()) {\n-        Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n-            destPath, resource, new Random());\n+        Callable\u003cPath\u003e download \u003d\n+            new FSDownload(localFSFileContext, ugi, conf, new Path(destPath,\n+                Long.toString(uniqueNumberGenerator.incrementAndGet())),\n+                resource);\n         Future\u003cPath\u003e future \u003d exec.submit(download);\n         resourcesToPaths.put(resource, future);\n       }\n       for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n         LocalResource resource \u003d entry.getValue();\n         Path path;\n         try {\n           path \u003d resourcesToPaths.get(resource).get();\n         } catch (InterruptedException e) {\n           throw new IOException(e);\n         } catch (ExecutionException e) {\n           throw new IOException(e);\n         }\n         String pathString \u003d path.toUri().toString();\n         String link \u003d entry.getKey();\n         String target \u003d new File(path.toUri()).getPath();\n         symlink(workDir, target, link);\n         \n         if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n           localArchives.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n           localFiles.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n           //PATTERN is not currently used in local mode\n           throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n           \t\t\"implemented yet. \" + resource.getResource());\n         }\n         Path resourcePath;\n         try {\n           resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n         } catch (URISyntaxException e) {\n           throw new IOException(e);\n         }\n         LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n         String cp \u003d resourcePath.toUri().getPath();\n         if (classpaths.keySet().contains(cp)) {\n           localClasspaths.add(path.toUri().getPath().toString());\n         }\n       }\n     } finally {\n       if (exec !\u003d null) {\n         exec.shutdown();\n       }\n     }    \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setup(JobConf conf) throws IOException {\n    File workDir \u003d new File(System.getProperty(\"user.dir\"));\n    \n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    // Generating unique numbers for FSDownload.\n    AtomicLong uniqueNumberGenerator \u003d\n        new AtomicLong(System.currentTimeMillis());\n    \n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    ExecutorService exec \u003d null;\n    try {\n      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n      .build();\n      exec \u003d Executors.newCachedThreadPool(tf);\n      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Callable\u003cPath\u003e download \u003d\n            new FSDownload(localFSFileContext, ugi, conf, new Path(destPath,\n                Long.toString(uniqueNumberGenerator.incrementAndGet())),\n                resource);\n        Future\u003cPath\u003e future \u003d exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n        LocalResource resource \u003d entry.getValue();\n        Path path;\n        try {\n          path \u003d resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString \u003d path.toUri().toString();\n        String link \u003d entry.getKey();\n        String target \u003d new File(path.toUri()).getPath();\n        symlink(workDir, target, link);\n        \n        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n          //PATTERN is not currently used in local mode\n          throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n          \t\t\"implemented yet. \" + resource.getResource());\n        }\n        Path resourcePath;\n        try {\n          resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp \u003d resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec !\u003d null) {\n        exec.shutdown();\n      }\n    }    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    setupCalled \u003d true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
      "extendedDetails": {}
    },
    "050fd3a11744cde3d54c1fff23d8fdeb3803bf92": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4647. We should only unjar jobjar if there is a lib directory in it. (Robert Evans via tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1390557 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/09/12 8:22 AM",
      "commitName": "050fd3a11744cde3d54c1fff23d8fdeb3803bf92",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "31/07/12 12:20 PM",
      "commitNameOld": "735b50e8bd23f7fbeff3a08cf8f3fff8cbff7449",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 56.83,
      "commitsBetweenForRepo": 312,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,104 @@\n   public void setup(JobConf conf) throws IOException {\n     File workDir \u003d new File(System.getProperty(\"user.dir\"));\n     \n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n     \n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n     ExecutorService exec \u003d null;\n     try {\n       ThreadFactory tf \u003d new ThreadFactoryBuilder()\n       .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n       .build();\n       exec \u003d Executors.newCachedThreadPool(tf);\n       Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n       Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n       for (LocalResource resource : localResources.values()) {\n         Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n             destPath, resource, new Random());\n         Future\u003cPath\u003e future \u003d exec.submit(download);\n         resourcesToPaths.put(resource, future);\n       }\n       for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n         LocalResource resource \u003d entry.getValue();\n         Path path;\n         try {\n           path \u003d resourcesToPaths.get(resource).get();\n         } catch (InterruptedException e) {\n           throw new IOException(e);\n         } catch (ExecutionException e) {\n           throw new IOException(e);\n         }\n         String pathString \u003d path.toUri().toString();\n         String link \u003d entry.getKey();\n         String target \u003d new File(path.toUri()).getPath();\n         symlink(workDir, target, link);\n         \n         if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n           localArchives.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n           localFiles.add(pathString);\n+        } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n+          //PATTERN is not currently used in local mode\n+          throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n+          \t\t\"implemented yet. \" + resource.getResource());\n         }\n         Path resourcePath;\n         try {\n           resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n         } catch (URISyntaxException e) {\n           throw new IOException(e);\n         }\n         LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n         String cp \u003d resourcePath.toUri().getPath();\n         if (classpaths.keySet().contains(cp)) {\n           localClasspaths.add(path.toUri().getPath().toString());\n         }\n       }\n     } finally {\n       if (exec !\u003d null) {\n         exec.shutdown();\n       }\n     }    \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setup(JobConf conf) throws IOException {\n    File workDir \u003d new File(System.getProperty(\"user.dir\"));\n    \n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    \n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    ExecutorService exec \u003d null;\n    try {\n      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n      .build();\n      exec \u003d Executors.newCachedThreadPool(tf);\n      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n            destPath, resource, new Random());\n        Future\u003cPath\u003e future \u003d exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n        LocalResource resource \u003d entry.getValue();\n        Path path;\n        try {\n          path \u003d resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString \u003d path.toUri().toString();\n        String link \u003d entry.getKey();\n        String target \u003d new File(path.toUri()).getPath();\n        symlink(workDir, target, link);\n        \n        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.PATTERN) {\n          //PATTERN is not currently used in local mode\n          throw new IllegalArgumentException(\"Resource type PATTERN is not \" +\n          \t\t\"implemented yet. \" + resource.getResource());\n        }\n        Path resourcePath;\n        try {\n          resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp \u003d resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec !\u003d null) {\n        exec.shutdown();\n      }\n    }    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    setupCalled \u003d true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
      "extendedDetails": {}
    },
    "735b50e8bd23f7fbeff3a08cf8f3fff8cbff7449": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4493. Distibuted Cache Compatability Issues (Robert Evans via tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1367713 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/07/12 12:20 PM",
      "commitName": "735b50e8bd23f7fbeff3a08cf8f3fff8cbff7449",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "31/07/12 7:46 AM",
      "commitNameOld": "e9bf6c56c556a92b72da65ad12fc19a1825b8376",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,100 @@\n   public void setup(JobConf conf) throws IOException {\n-    boolean mkLinks \u003d DistributedCache.getSymlink(conf);\n     File workDir \u003d new File(System.getProperty(\"user.dir\"));\n     \n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n     \n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n     ExecutorService exec \u003d null;\n     try {\n       ThreadFactory tf \u003d new ThreadFactoryBuilder()\n       .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n       .build();\n       exec \u003d Executors.newCachedThreadPool(tf);\n       Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n       Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n       for (LocalResource resource : localResources.values()) {\n         Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n             destPath, resource, new Random());\n         Future\u003cPath\u003e future \u003d exec.submit(download);\n         resourcesToPaths.put(resource, future);\n       }\n       for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n         LocalResource resource \u003d entry.getValue();\n         Path path;\n         try {\n           path \u003d resourcesToPaths.get(resource).get();\n         } catch (InterruptedException e) {\n           throw new IOException(e);\n         } catch (ExecutionException e) {\n           throw new IOException(e);\n         }\n         String pathString \u003d path.toUri().toString();\n-        if(mkLinks) {\n-          String link \u003d entry.getKey();\n-          String target \u003d new File(path.toUri()).getPath();\n-          symlink(workDir, target, link);\n-        }\n+        String link \u003d entry.getKey();\n+        String target \u003d new File(path.toUri()).getPath();\n+        symlink(workDir, target, link);\n         \n         if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n           localArchives.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n           localFiles.add(pathString);\n         }\n         Path resourcePath;\n         try {\n           resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n         } catch (URISyntaxException e) {\n           throw new IOException(e);\n         }\n         LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n         String cp \u003d resourcePath.toUri().getPath();\n         if (classpaths.keySet().contains(cp)) {\n           localClasspaths.add(path.toUri().getPath().toString());\n         }\n       }\n     } finally {\n       if (exec !\u003d null) {\n         exec.shutdown();\n       }\n     }    \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setup(JobConf conf) throws IOException {\n    File workDir \u003d new File(System.getProperty(\"user.dir\"));\n    \n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    \n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    ExecutorService exec \u003d null;\n    try {\n      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n      .build();\n      exec \u003d Executors.newCachedThreadPool(tf);\n      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n            destPath, resource, new Random());\n        Future\u003cPath\u003e future \u003d exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n        LocalResource resource \u003d entry.getValue();\n        Path path;\n        try {\n          path \u003d resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString \u003d path.toUri().toString();\n        String link \u003d entry.getKey();\n        String target \u003d new File(path.toUri()).getPath();\n        symlink(workDir, target, link);\n        \n        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        }\n        Path resourcePath;\n        try {\n          resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp \u003d resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec !\u003d null) {\n        exec.shutdown();\n      }\n    }    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    setupCalled \u003d true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
      "extendedDetails": {}
    },
    "e9bf6c56c556a92b72da65ad12fc19a1825b8376": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4456. LocalDistributedCacheManager can get an ArrayIndexOutOfBounds when creating symlinks (Robert Evans via tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1367581 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/07/12 7:46 AM",
      "commitName": "e9bf6c56c556a92b72da65ad12fc19a1825b8376",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "11/06/12 1:37 PM",
      "commitNameOld": "13ad75679642adf120a36199bf9e8df673b9b38f",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 49.76,
      "commitsBetweenForRepo": 264,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,103 @@\n   public void setup(JobConf conf) throws IOException {\n+    boolean mkLinks \u003d DistributedCache.getSymlink(conf);\n+    File workDir \u003d new File(System.getProperty(\"user.dir\"));\n+    \n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n     \n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n     ExecutorService exec \u003d null;\n     try {\n       ThreadFactory tf \u003d new ThreadFactoryBuilder()\n       .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n       .build();\n       exec \u003d Executors.newCachedThreadPool(tf);\n       Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n       Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n       for (LocalResource resource : localResources.values()) {\n         Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n             destPath, resource, new Random());\n         Future\u003cPath\u003e future \u003d exec.submit(download);\n         resourcesToPaths.put(resource, future);\n       }\n-      for (LocalResource resource : localResources.values()) {\n+      for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n+        LocalResource resource \u003d entry.getValue();\n         Path path;\n         try {\n           path \u003d resourcesToPaths.get(resource).get();\n         } catch (InterruptedException e) {\n           throw new IOException(e);\n         } catch (ExecutionException e) {\n           throw new IOException(e);\n         }\n         String pathString \u003d path.toUri().toString();\n+        if(mkLinks) {\n+          String link \u003d entry.getKey();\n+          String target \u003d new File(path.toUri()).getPath();\n+          symlink(workDir, target, link);\n+        }\n+        \n         if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n           localArchives.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n           localFiles.add(pathString);\n         }\n         Path resourcePath;\n         try {\n           resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n         } catch (URISyntaxException e) {\n           throw new IOException(e);\n         }\n         LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n         String cp \u003d resourcePath.toUri().getPath();\n         if (classpaths.keySet().contains(cp)) {\n           localClasspaths.add(path.toUri().getPath().toString());\n         }\n       }\n     } finally {\n       if (exec !\u003d null) {\n         exec.shutdown();\n       }\n     }    \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n-    if (DistributedCache.getSymlink(conf)) {\n-      File workDir \u003d new File(System.getProperty(\"user.dir\"));\n-      URI[] archives \u003d DistributedCache.getCacheArchives(conf);\n-      URI[] files \u003d DistributedCache.getCacheFiles(conf);\n-      Path[] localArchives \u003d DistributedCache.getLocalCacheArchives(conf);\n-      Path[] localFiles \u003d DistributedCache.getLocalCacheFiles(conf);\n-      if (archives !\u003d null) {\n-        for (int i \u003d 0; i \u003c archives.length; i++) {\n-          String link \u003d archives[i].getFragment();\n-          String target \u003d new File(localArchives[i].toUri()).getPath();\n-          symlink(workDir, target, link);\n-        }\n-      }\n-      if (files !\u003d null) {\n-        for (int i \u003d 0; i \u003c files.length; i++) {\n-          String link \u003d files[i].getFragment();\n-          String target \u003d new File(localFiles[i].toUri()).getPath();\n-          symlink(workDir, target, link);\n-        }\n-      }\n-    }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setup(JobConf conf) throws IOException {\n    boolean mkLinks \u003d DistributedCache.getSymlink(conf);\n    File workDir \u003d new File(System.getProperty(\"user.dir\"));\n    \n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    \n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    ExecutorService exec \u003d null;\n    try {\n      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n      .build();\n      exec \u003d Executors.newCachedThreadPool(tf);\n      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n            destPath, resource, new Random());\n        Future\u003cPath\u003e future \u003d exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (Entry\u003cString, LocalResource\u003e entry : localResources.entrySet()) {\n        LocalResource resource \u003d entry.getValue();\n        Path path;\n        try {\n          path \u003d resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString \u003d path.toUri().toString();\n        if(mkLinks) {\n          String link \u003d entry.getKey();\n          String target \u003d new File(path.toUri()).getPath();\n          symlink(workDir, target, link);\n        }\n        \n        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        }\n        Path resourcePath;\n        try {\n          resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp \u003d resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec !\u003d null) {\n        exec.shutdown();\n      }\n    }    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    setupCalled \u003d true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
      "extendedDetails": {}
    },
    "13ad75679642adf120a36199bf9e8df673b9b38f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3871. Allow symlinking in LocalJobRunner DistributedCache.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1348997 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/12 1:37 PM",
      "commitName": "13ad75679642adf120a36199bf9e8df673b9b38f",
      "commitAuthor": "Thomas White",
      "commitDateOld": "18/01/12 10:20 AM",
      "commitNameOld": "8b2f6909ec7df5cffb5ef417f5c9cffdee43e38a",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 145.1,
      "commitsBetweenForRepo": 1040,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,114 @@\n   public void setup(JobConf conf) throws IOException {\n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n     \n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n     ExecutorService exec \u003d null;\n     try {\n       ThreadFactory tf \u003d new ThreadFactoryBuilder()\n       .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n       .build();\n       exec \u003d Executors.newCachedThreadPool(tf);\n       Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n       Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n       for (LocalResource resource : localResources.values()) {\n         Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n             destPath, resource, new Random());\n         Future\u003cPath\u003e future \u003d exec.submit(download);\n         resourcesToPaths.put(resource, future);\n       }\n       for (LocalResource resource : localResources.values()) {\n         Path path;\n         try {\n           path \u003d resourcesToPaths.get(resource).get();\n         } catch (InterruptedException e) {\n           throw new IOException(e);\n         } catch (ExecutionException e) {\n           throw new IOException(e);\n         }\n         String pathString \u003d path.toUri().toString();\n         if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n           localArchives.add(pathString);\n         } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n           localFiles.add(pathString);\n         }\n         Path resourcePath;\n         try {\n           resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n         } catch (URISyntaxException e) {\n           throw new IOException(e);\n         }\n         LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n         String cp \u003d resourcePath.toUri().getPath();\n         if (classpaths.keySet().contains(cp)) {\n           localClasspaths.add(path.toUri().getPath().toString());\n         }\n       }\n     } finally {\n       if (exec !\u003d null) {\n         exec.shutdown();\n       }\n     }    \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n     if (DistributedCache.getSymlink(conf)) {\n-      // This is not supported largely because, \n-      // for a Child subprocess, the cwd in LocalJobRunner\n-      // is not a fresh slate, but rather the user\u0027s working directory.\n-      // This is further complicated because the logic in\n-      // setupWorkDir only creates symlinks if there\u0027s a jarfile\n-      // in the configuration.\n-      LOG.warn(\"LocalJobRunner does not support \" +\n-          \"symlinking into current working dir.\");\n+      File workDir \u003d new File(System.getProperty(\"user.dir\"));\n+      URI[] archives \u003d DistributedCache.getCacheArchives(conf);\n+      URI[] files \u003d DistributedCache.getCacheFiles(conf);\n+      Path[] localArchives \u003d DistributedCache.getLocalCacheArchives(conf);\n+      Path[] localFiles \u003d DistributedCache.getLocalCacheFiles(conf);\n+      if (archives !\u003d null) {\n+        for (int i \u003d 0; i \u003c archives.length; i++) {\n+          String link \u003d archives[i].getFragment();\n+          String target \u003d new File(localArchives[i].toUri()).getPath();\n+          symlink(workDir, target, link);\n+        }\n+      }\n+      if (files !\u003d null) {\n+        for (int i \u003d 0; i \u003c files.length; i++) {\n+          String link \u003d files[i].getFragment();\n+          String target \u003d new File(localFiles[i].toUri()).getPath();\n+          symlink(workDir, target, link);\n+        }\n+      }\n     }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setup(JobConf conf) throws IOException {\n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    \n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    ExecutorService exec \u003d null;\n    try {\n      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n      .build();\n      exec \u003d Executors.newCachedThreadPool(tf);\n      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n            destPath, resource, new Random());\n        Future\u003cPath\u003e future \u003d exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (LocalResource resource : localResources.values()) {\n        Path path;\n        try {\n          path \u003d resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString \u003d path.toUri().toString();\n        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        }\n        Path resourcePath;\n        try {\n          resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp \u003d resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec !\u003d null) {\n        exec.shutdown();\n      }\n    }    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    if (DistributedCache.getSymlink(conf)) {\n      File workDir \u003d new File(System.getProperty(\"user.dir\"));\n      URI[] archives \u003d DistributedCache.getCacheArchives(conf);\n      URI[] files \u003d DistributedCache.getCacheFiles(conf);\n      Path[] localArchives \u003d DistributedCache.getLocalCacheArchives(conf);\n      Path[] localFiles \u003d DistributedCache.getLocalCacheFiles(conf);\n      if (archives !\u003d null) {\n        for (int i \u003d 0; i \u003c archives.length; i++) {\n          String link \u003d archives[i].getFragment();\n          String target \u003d new File(localArchives[i].toUri()).getPath();\n          symlink(workDir, target, link);\n        }\n      }\n      if (files !\u003d null) {\n        for (int i \u003d 0; i \u003c files.length; i++) {\n          String link \u003d files[i].getFragment();\n          String target \u003d new File(localFiles[i].toUri()).getPath();\n          symlink(workDir, target, link);\n        }\n      }\n    }\n    setupCalled \u003d true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
      "extendedDetails": {}
    },
    "8b2f6909ec7df5cffb5ef417f5c9cffdee43e38a": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3684. LocalDistributedCacheManager does not shut down its thread pool.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1232981 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/01/12 10:20 AM",
      "commitName": "8b2f6909ec7df5cffb5ef417f5c9cffdee43e38a",
      "commitAuthor": "Thomas White",
      "commitDateOld": "29/11/11 3:17 PM",
      "commitNameOld": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 49.79,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,103 @@\n   public void setup(JobConf conf) throws IOException {\n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n     \n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n-    Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n-    ExecutorService exec \u003d Executors.newCachedThreadPool();\n-    Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n-    for (LocalResource resource : localResources.values()) {\n-      Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n-          destPath, resource, new Random());\n-      Future\u003cPath\u003e future \u003d exec.submit(download);\n-      resourcesToPaths.put(resource, future);\n-    }\n-    for (LocalResource resource : localResources.values()) {\n-      Path path;\n-      try {\n-        path \u003d resourcesToPaths.get(resource).get();\n-      } catch (InterruptedException e) {\n-        throw new IOException(e);\n-      } catch (ExecutionException e) {\n-        throw new IOException(e);\n+    ExecutorService exec \u003d null;\n+    try {\n+      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n+      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n+      .build();\n+      exec \u003d Executors.newCachedThreadPool(tf);\n+      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n+      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n+      for (LocalResource resource : localResources.values()) {\n+        Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n+            destPath, resource, new Random());\n+        Future\u003cPath\u003e future \u003d exec.submit(download);\n+        resourcesToPaths.put(resource, future);\n       }\n-      String pathString \u003d path.toUri().toString();\n-      if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n-        localArchives.add(pathString);\n-      } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n-        localFiles.add(pathString);\n+      for (LocalResource resource : localResources.values()) {\n+        Path path;\n+        try {\n+          path \u003d resourcesToPaths.get(resource).get();\n+        } catch (InterruptedException e) {\n+          throw new IOException(e);\n+        } catch (ExecutionException e) {\n+          throw new IOException(e);\n+        }\n+        String pathString \u003d path.toUri().toString();\n+        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n+          localArchives.add(pathString);\n+        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n+          localFiles.add(pathString);\n+        }\n+        Path resourcePath;\n+        try {\n+          resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n+        } catch (URISyntaxException e) {\n+          throw new IOException(e);\n+        }\n+        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n+        String cp \u003d resourcePath.toUri().getPath();\n+        if (classpaths.keySet().contains(cp)) {\n+          localClasspaths.add(path.toUri().getPath().toString());\n+        }\n       }\n-      Path resourcePath;\n-      try {\n-        resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n-      } catch (URISyntaxException e) {\n-        throw new IOException(e);\n+    } finally {\n+      if (exec !\u003d null) {\n+        exec.shutdown();\n       }\n-      LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n-      String cp \u003d resourcePath.toUri().getPath();\n-      if (classpaths.keySet().contains(cp)) {\n-        localClasspaths.add(path.toUri().getPath().toString());\n-      }\n-    }\n-    \n+    }    \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n     if (DistributedCache.getSymlink(conf)) {\n       // This is not supported largely because, \n       // for a Child subprocess, the cwd in LocalJobRunner\n       // is not a fresh slate, but rather the user\u0027s working directory.\n       // This is further complicated because the logic in\n       // setupWorkDir only creates symlinks if there\u0027s a jarfile\n       // in the configuration.\n       LOG.warn(\"LocalJobRunner does not support \" +\n           \"symlinking into current working dir.\");\n     }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setup(JobConf conf) throws IOException {\n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    \n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    ExecutorService exec \u003d null;\n    try {\n      ThreadFactory tf \u003d new ThreadFactoryBuilder()\n      .setNameFormat(\"LocalDistributedCacheManager Downloader #%d\")\n      .build();\n      exec \u003d Executors.newCachedThreadPool(tf);\n      Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n      Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n      for (LocalResource resource : localResources.values()) {\n        Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n            destPath, resource, new Random());\n        Future\u003cPath\u003e future \u003d exec.submit(download);\n        resourcesToPaths.put(resource, future);\n      }\n      for (LocalResource resource : localResources.values()) {\n        Path path;\n        try {\n          path \u003d resourcesToPaths.get(resource).get();\n        } catch (InterruptedException e) {\n          throw new IOException(e);\n        } catch (ExecutionException e) {\n          throw new IOException(e);\n        }\n        String pathString \u003d path.toUri().toString();\n        if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n          localArchives.add(pathString);\n        } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n          localFiles.add(pathString);\n        }\n        Path resourcePath;\n        try {\n          resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n        } catch (URISyntaxException e) {\n          throw new IOException(e);\n        }\n        LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n        String cp \u003d resourcePath.toUri().getPath();\n        if (classpaths.keySet().contains(cp)) {\n          localClasspaths.add(path.toUri().getPath().toString());\n        }\n      }\n    } finally {\n      if (exec !\u003d null) {\n        exec.shutdown();\n      }\n    }    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    if (DistributedCache.getSymlink(conf)) {\n      // This is not supported largely because, \n      // for a Child subprocess, the cwd in LocalJobRunner\n      // is not a fresh slate, but rather the user\u0027s working directory.\n      // This is further complicated because the logic in\n      // setupWorkDir only creates symlinks if there\u0027s a jarfile\n      // in the configuration.\n      LOG.warn(\"LocalJobRunner does not support \" +\n          \"symlinking into current working dir.\");\n    }\n    setupCalled \u003d true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
      "extendedDetails": {}
    },
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3121. NodeManager should handle disk-failures (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208131 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/11 3:17 PM",
      "commitName": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "31/10/11 8:16 PM",
      "commitNameOld": "cfb6a9883d2bf02c99f258e9f19ffcd83805d077",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 28.83,
      "commitsBetweenForRepo": 145,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,94 @@\n   public void setup(JobConf conf) throws IOException {\n     // Generate YARN local resources objects corresponding to the distributed\n     // cache configuration\n     Map\u003cString, LocalResource\u003e localResources \u003d \n       new LinkedHashMap\u003cString, LocalResource\u003e();\n     MRApps.setupDistributedCache(conf, localResources);\n     \n     // Find which resources are to be put on the local classpath\n     Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n     Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n     if (archiveClassPaths !\u003d null) {\n       for (Path p : archiveClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n     if (fileClassPaths !\u003d null) {\n       for (Path p : fileClassPaths) {\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n         classpaths.put(p.toUri().getPath().toString(), p);\n       }\n     }\n     \n     // Localize the resources\n     LocalDirAllocator localDirAllocator \u003d\n       new LocalDirAllocator(MRConfig.LOCAL_DIR);\n     FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n     \n     Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n     ExecutorService exec \u003d Executors.newCachedThreadPool();\n+    Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n     for (LocalResource resource : localResources.values()) {\n       Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n-          localDirAllocator, resource, new Random());\n+          destPath, resource, new Random());\n       Future\u003cPath\u003e future \u003d exec.submit(download);\n       resourcesToPaths.put(resource, future);\n     }\n     for (LocalResource resource : localResources.values()) {\n       Path path;\n       try {\n         path \u003d resourcesToPaths.get(resource).get();\n       } catch (InterruptedException e) {\n         throw new IOException(e);\n       } catch (ExecutionException e) {\n         throw new IOException(e);\n       }\n       String pathString \u003d path.toUri().toString();\n       if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n         localArchives.add(pathString);\n       } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n         localFiles.add(pathString);\n       }\n       Path resourcePath;\n       try {\n         resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n       } catch (URISyntaxException e) {\n         throw new IOException(e);\n       }\n       LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n       String cp \u003d resourcePath.toUri().getPath();\n       if (classpaths.keySet().contains(cp)) {\n         localClasspaths.add(path.toUri().getPath().toString());\n       }\n     }\n     \n     // Update the configuration object with localized data.\n     if (!localArchives.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n           .arrayToString(localArchives.toArray(new String[localArchives\n               .size()])));\n     }\n     if (!localFiles.isEmpty()) {\n       conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n           .arrayToString(localFiles.toArray(new String[localArchives\n               .size()])));\n     }\n     if (DistributedCache.getSymlink(conf)) {\n       // This is not supported largely because, \n       // for a Child subprocess, the cwd in LocalJobRunner\n       // is not a fresh slate, but rather the user\u0027s working directory.\n       // This is further complicated because the logic in\n       // setupWorkDir only creates symlinks if there\u0027s a jarfile\n       // in the configuration.\n       LOG.warn(\"LocalJobRunner does not support \" +\n           \"symlinking into current working dir.\");\n     }\n     setupCalled \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setup(JobConf conf) throws IOException {\n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    \n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n    ExecutorService exec \u003d Executors.newCachedThreadPool();\n    Path destPath \u003d localDirAllocator.getLocalPathForWrite(\".\", conf);\n    for (LocalResource resource : localResources.values()) {\n      Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n          destPath, resource, new Random());\n      Future\u003cPath\u003e future \u003d exec.submit(download);\n      resourcesToPaths.put(resource, future);\n    }\n    for (LocalResource resource : localResources.values()) {\n      Path path;\n      try {\n        path \u003d resourcesToPaths.get(resource).get();\n      } catch (InterruptedException e) {\n        throw new IOException(e);\n      } catch (ExecutionException e) {\n        throw new IOException(e);\n      }\n      String pathString \u003d path.toUri().toString();\n      if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n        localArchives.add(pathString);\n      } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n        localFiles.add(pathString);\n      }\n      Path resourcePath;\n      try {\n        resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n      } catch (URISyntaxException e) {\n        throw new IOException(e);\n      }\n      LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n      String cp \u003d resourcePath.toUri().getPath();\n      if (classpaths.keySet().contains(cp)) {\n        localClasspaths.add(path.toUri().getPath().toString());\n      }\n    }\n    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    if (DistributedCache.getSymlink(conf)) {\n      // This is not supported largely because, \n      // for a Child subprocess, the cwd in LocalJobRunner\n      // is not a fresh slate, but rather the user\u0027s working directory.\n      // This is further complicated because the logic in\n      // setupWorkDir only creates symlinks if there\u0027s a jarfile\n      // in the configuration.\n      LOG.warn(\"LocalJobRunner does not support \" +\n          \"symlinking into current working dir.\");\n    }\n    setupCalled \u003d true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java",
      "extendedDetails": {}
    },
    "cfb6a9883d2bf02c99f258e9f19ffcd83805d077": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3237. Move LocalJobRunner to hadoop-mapreduce-client-core. Contributed by Tom White.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195792 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/11 8:16 PM",
      "commitName": "cfb6a9883d2bf02c99f258e9f19ffcd83805d077",
      "commitAuthor": "Arun Murthy",
      "diff": "@@ -0,0 +1,93 @@\n+  public void setup(JobConf conf) throws IOException {\n+    // Generate YARN local resources objects corresponding to the distributed\n+    // cache configuration\n+    Map\u003cString, LocalResource\u003e localResources \u003d \n+      new LinkedHashMap\u003cString, LocalResource\u003e();\n+    MRApps.setupDistributedCache(conf, localResources);\n+    \n+    // Find which resources are to be put on the local classpath\n+    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n+    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n+    if (archiveClassPaths !\u003d null) {\n+      for (Path p : archiveClassPaths) {\n+        FileSystem remoteFS \u003d p.getFileSystem(conf);\n+        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n+            remoteFS.getWorkingDirectory()));\n+        classpaths.put(p.toUri().getPath().toString(), p);\n+      }\n+    }\n+    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n+    if (fileClassPaths !\u003d null) {\n+      for (Path p : fileClassPaths) {\n+        FileSystem remoteFS \u003d p.getFileSystem(conf);\n+        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n+            remoteFS.getWorkingDirectory()));\n+        classpaths.put(p.toUri().getPath().toString(), p);\n+      }\n+    }\n+    \n+    // Localize the resources\n+    LocalDirAllocator localDirAllocator \u003d\n+      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n+    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n+    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n+    \n+    Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n+    ExecutorService exec \u003d Executors.newCachedThreadPool();\n+    for (LocalResource resource : localResources.values()) {\n+      Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n+          localDirAllocator, resource, new Random());\n+      Future\u003cPath\u003e future \u003d exec.submit(download);\n+      resourcesToPaths.put(resource, future);\n+    }\n+    for (LocalResource resource : localResources.values()) {\n+      Path path;\n+      try {\n+        path \u003d resourcesToPaths.get(resource).get();\n+      } catch (InterruptedException e) {\n+        throw new IOException(e);\n+      } catch (ExecutionException e) {\n+        throw new IOException(e);\n+      }\n+      String pathString \u003d path.toUri().toString();\n+      if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n+        localArchives.add(pathString);\n+      } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n+        localFiles.add(pathString);\n+      }\n+      Path resourcePath;\n+      try {\n+        resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n+      } catch (URISyntaxException e) {\n+        throw new IOException(e);\n+      }\n+      LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n+      String cp \u003d resourcePath.toUri().getPath();\n+      if (classpaths.keySet().contains(cp)) {\n+        localClasspaths.add(path.toUri().getPath().toString());\n+      }\n+    }\n+    \n+    // Update the configuration object with localized data.\n+    if (!localArchives.isEmpty()) {\n+      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n+          .arrayToString(localArchives.toArray(new String[localArchives\n+              .size()])));\n+    }\n+    if (!localFiles.isEmpty()) {\n+      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n+          .arrayToString(localFiles.toArray(new String[localArchives\n+              .size()])));\n+    }\n+    if (DistributedCache.getSymlink(conf)) {\n+      // This is not supported largely because, \n+      // for a Child subprocess, the cwd in LocalJobRunner\n+      // is not a fresh slate, but rather the user\u0027s working directory.\n+      // This is further complicated because the logic in\n+      // setupWorkDir only creates symlinks if there\u0027s a jarfile\n+      // in the configuration.\n+      LOG.warn(\"LocalJobRunner does not support \" +\n+          \"symlinking into current working dir.\");\n+    }\n+    setupCalled \u003d true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void setup(JobConf conf) throws IOException {\n    // Generate YARN local resources objects corresponding to the distributed\n    // cache configuration\n    Map\u003cString, LocalResource\u003e localResources \u003d \n      new LinkedHashMap\u003cString, LocalResource\u003e();\n    MRApps.setupDistributedCache(conf, localResources);\n    \n    // Find which resources are to be put on the local classpath\n    Map\u003cString, Path\u003e classpaths \u003d new HashMap\u003cString, Path\u003e();\n    Path[] archiveClassPaths \u003d DistributedCache.getArchiveClassPaths(conf);\n    if (archiveClassPaths !\u003d null) {\n      for (Path p : archiveClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    Path[] fileClassPaths \u003d DistributedCache.getFileClassPaths(conf);\n    if (fileClassPaths !\u003d null) {\n      for (Path p : fileClassPaths) {\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n        classpaths.put(p.toUri().getPath().toString(), p);\n      }\n    }\n    \n    // Localize the resources\n    LocalDirAllocator localDirAllocator \u003d\n      new LocalDirAllocator(MRConfig.LOCAL_DIR);\n    FileContext localFSFileContext \u003d FileContext.getLocalFSFileContext();\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n    \n    Map\u003cLocalResource, Future\u003cPath\u003e\u003e resourcesToPaths \u003d Maps.newHashMap();\n    ExecutorService exec \u003d Executors.newCachedThreadPool();\n    for (LocalResource resource : localResources.values()) {\n      Callable\u003cPath\u003e download \u003d new FSDownload(localFSFileContext, ugi, conf,\n          localDirAllocator, resource, new Random());\n      Future\u003cPath\u003e future \u003d exec.submit(download);\n      resourcesToPaths.put(resource, future);\n    }\n    for (LocalResource resource : localResources.values()) {\n      Path path;\n      try {\n        path \u003d resourcesToPaths.get(resource).get();\n      } catch (InterruptedException e) {\n        throw new IOException(e);\n      } catch (ExecutionException e) {\n        throw new IOException(e);\n      }\n      String pathString \u003d path.toUri().toString();\n      if (resource.getType() \u003d\u003d LocalResourceType.ARCHIVE) {\n        localArchives.add(pathString);\n      } else if (resource.getType() \u003d\u003d LocalResourceType.FILE) {\n        localFiles.add(pathString);\n      }\n      Path resourcePath;\n      try {\n        resourcePath \u003d ConverterUtils.getPathFromYarnURL(resource.getResource());\n      } catch (URISyntaxException e) {\n        throw new IOException(e);\n      }\n      LOG.info(String.format(\"Localized %s as %s\", resourcePath, path));\n      String cp \u003d resourcePath.toUri().getPath();\n      if (classpaths.keySet().contains(cp)) {\n        localClasspaths.add(path.toUri().getPath().toString());\n      }\n    }\n    \n    // Update the configuration object with localized data.\n    if (!localArchives.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils\n          .arrayToString(localArchives.toArray(new String[localArchives\n              .size()])));\n    }\n    if (!localFiles.isEmpty()) {\n      conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils\n          .arrayToString(localFiles.toArray(new String[localArchives\n              .size()])));\n    }\n    if (DistributedCache.getSymlink(conf)) {\n      // This is not supported largely because, \n      // for a Child subprocess, the cwd in LocalJobRunner\n      // is not a fresh slate, but rather the user\u0027s working directory.\n      // This is further complicated because the logic in\n      // setupWorkDir only creates symlinks if there\u0027s a jarfile\n      // in the configuration.\n      LOG.warn(\"LocalJobRunner does not support \" +\n          \"symlinking into current working dir.\");\n    }\n    setupCalled \u003d true;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapred/LocalDistributedCacheManager.java"
    }
  }
}