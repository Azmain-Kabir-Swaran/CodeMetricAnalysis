{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DefaultPlacementAlgorithm.java",
  "functionName": "place",
  "functionId": "place___input-ConstraintPlacementAlgorithmInput__collector-ConstraintPlacementAlgorithmOutputCollector",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java",
  "functionStartLine": 96,
  "functionEndLine": 129,
  "numCommitsSeen": 9,
  "timeTaken": 3810,
  "changeHistory": [
    "6e5ba9366fc05719906ff2789b1a0fd26001182b",
    "a4c539fcdba817e313b2375abf2c4c9a1d13a4fd",
    "28fe7f331837b36e78fa34ed990993677dddeaee",
    "a52d11fb8c103f14e42692600a058ba3b56e2ecf",
    "f9af15d659f59fd0cf564fe1ecc8e06c6429ba68"
  ],
  "changeHistoryShort": {
    "6e5ba9366fc05719906ff2789b1a0fd26001182b": "Ybodychange",
    "a4c539fcdba817e313b2375abf2c4c9a1d13a4fd": "Ybodychange",
    "28fe7f331837b36e78fa34ed990993677dddeaee": "Ybodychange",
    "a52d11fb8c103f14e42692600a058ba3b56e2ecf": "Ymultichange(Ymovefromfile,Ybodychange)",
    "f9af15d659f59fd0cf564fe1ecc8e06c6429ba68": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6e5ba9366fc05719906ff2789b1a0fd26001182b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7839. Modify PlacementAlgorithm to Check node capacity before placing request on node. (Panagiotis Garefalakis via asuresh)\n",
      "commitDate": "02/02/18 10:28 AM",
      "commitName": "6e5ba9366fc05719906ff2789b1a0fd26001182b",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "a4c539fcdba817e313b2375abf2c4c9a1d13a4fd",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 2.37,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,34 @@\n   public void place(ConstraintPlacementAlgorithmInput input,\n       ConstraintPlacementAlgorithmOutputCollector collector) {\n     BatchedRequests requests \u003d (BatchedRequests) input;\n+    int placementAttempt \u003d requests.getPlacementAttempt();\n     ConstraintPlacementAlgorithmOutput resp \u003d\n         new ConstraintPlacementAlgorithmOutput(requests.getApplicationId());\n     List\u003cSchedulerNode\u003e allNodes \u003d nodeSelector.selectNodes(null);\n \n     List\u003cSchedulingRequest\u003e rejectedRequests \u003d new ArrayList\u003c\u003e();\n+    Map\u003cNodeId, Resource\u003e availResources \u003d new HashMap\u003c\u003e();\n     int rePlacementCount \u003d RE_ATTEMPT_COUNT;\n     while (rePlacementCount \u003e 0) {\n-      doPlacement(requests, resp, allNodes, rejectedRequests);\n+      doPlacement(requests, resp, allNodes, rejectedRequests, availResources);\n       // Double check if placement constraints are really satisfied\n       validatePlacement(requests.getApplicationId(), resp,\n-          rejectedRequests);\n+          rejectedRequests, availResources);\n       if (rejectedRequests.size() \u003d\u003d 0 || rePlacementCount \u003d\u003d 1) {\n         break;\n       }\n       requests \u003d new BatchedRequests(requests.getIteratorType(),\n           requests.getApplicationId(), rejectedRequests,\n           requests.getPlacementAttempt());\n       rejectedRequests \u003d new ArrayList\u003c\u003e();\n       rePlacementCount--;\n     }\n \n-    resp.getRejectedRequests().addAll(rejectedRequests);\n+    resp.getRejectedRequests().addAll(\n+        rejectedRequests.stream().map(\n+            x -\u003e new SchedulingRequestWithPlacementAttempt(\n+                placementAttempt, x)).collect(Collectors.toList()));\n     collector.collect(resp);\n     // Clean current temp-container tags\n     this.tagsManager.cleanTempContainers(requests.getApplicationId());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void place(ConstraintPlacementAlgorithmInput input,\n      ConstraintPlacementAlgorithmOutputCollector collector) {\n    BatchedRequests requests \u003d (BatchedRequests) input;\n    int placementAttempt \u003d requests.getPlacementAttempt();\n    ConstraintPlacementAlgorithmOutput resp \u003d\n        new ConstraintPlacementAlgorithmOutput(requests.getApplicationId());\n    List\u003cSchedulerNode\u003e allNodes \u003d nodeSelector.selectNodes(null);\n\n    List\u003cSchedulingRequest\u003e rejectedRequests \u003d new ArrayList\u003c\u003e();\n    Map\u003cNodeId, Resource\u003e availResources \u003d new HashMap\u003c\u003e();\n    int rePlacementCount \u003d RE_ATTEMPT_COUNT;\n    while (rePlacementCount \u003e 0) {\n      doPlacement(requests, resp, allNodes, rejectedRequests, availResources);\n      // Double check if placement constraints are really satisfied\n      validatePlacement(requests.getApplicationId(), resp,\n          rejectedRequests, availResources);\n      if (rejectedRequests.size() \u003d\u003d 0 || rePlacementCount \u003d\u003d 1) {\n        break;\n      }\n      requests \u003d new BatchedRequests(requests.getIteratorType(),\n          requests.getApplicationId(), rejectedRequests,\n          requests.getPlacementAttempt());\n      rejectedRequests \u003d new ArrayList\u003c\u003e();\n      rePlacementCount--;\n    }\n\n    resp.getRejectedRequests().addAll(\n        rejectedRequests.stream().map(\n            x -\u003e new SchedulingRequestWithPlacementAttempt(\n                placementAttempt, x)).collect(Collectors.toList()));\n    collector.collect(resp);\n    // Clean current temp-container tags\n    this.tagsManager.cleanTempContainers(requests.getApplicationId());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java",
      "extendedDetails": {}
    },
    "a4c539fcdba817e313b2375abf2c4c9a1d13a4fd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7783. Add validation step to ensure constraints are not violated due to order in which a request is processed. (asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "a4c539fcdba817e313b2375abf2c4c9a1d13a4fd",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "adbe87abf8b2814e0e2988d09ef8a8569190c80e",
      "commitAuthorOld": "Konstantinos Karanasos",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,29 @@\n   public void place(ConstraintPlacementAlgorithmInput input,\n       ConstraintPlacementAlgorithmOutputCollector collector) {\n     BatchedRequests requests \u003d (BatchedRequests) input;\n     ConstraintPlacementAlgorithmOutput resp \u003d\n         new ConstraintPlacementAlgorithmOutput(requests.getApplicationId());\n     List\u003cSchedulerNode\u003e allNodes \u003d nodeSelector.selectNodes(null);\n \n     List\u003cSchedulingRequest\u003e rejectedRequests \u003d new ArrayList\u003c\u003e();\n     int rePlacementCount \u003d RE_ATTEMPT_COUNT;\n     while (rePlacementCount \u003e 0) {\n       doPlacement(requests, resp, allNodes, rejectedRequests);\n+      // Double check if placement constraints are really satisfied\n+      validatePlacement(requests.getApplicationId(), resp,\n+          rejectedRequests);\n       if (rejectedRequests.size() \u003d\u003d 0 || rePlacementCount \u003d\u003d 1) {\n         break;\n       }\n       requests \u003d new BatchedRequests(requests.getIteratorType(),\n           requests.getApplicationId(), rejectedRequests,\n           requests.getPlacementAttempt());\n       rejectedRequests \u003d new ArrayList\u003c\u003e();\n       rePlacementCount--;\n     }\n \n     resp.getRejectedRequests().addAll(rejectedRequests);\n     collector.collect(resp);\n     // Clean current temp-container tags\n     this.tagsManager.cleanTempContainers(requests.getApplicationId());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void place(ConstraintPlacementAlgorithmInput input,\n      ConstraintPlacementAlgorithmOutputCollector collector) {\n    BatchedRequests requests \u003d (BatchedRequests) input;\n    ConstraintPlacementAlgorithmOutput resp \u003d\n        new ConstraintPlacementAlgorithmOutput(requests.getApplicationId());\n    List\u003cSchedulerNode\u003e allNodes \u003d nodeSelector.selectNodes(null);\n\n    List\u003cSchedulingRequest\u003e rejectedRequests \u003d new ArrayList\u003c\u003e();\n    int rePlacementCount \u003d RE_ATTEMPT_COUNT;\n    while (rePlacementCount \u003e 0) {\n      doPlacement(requests, resp, allNodes, rejectedRequests);\n      // Double check if placement constraints are really satisfied\n      validatePlacement(requests.getApplicationId(), resp,\n          rejectedRequests);\n      if (rejectedRequests.size() \u003d\u003d 0 || rePlacementCount \u003d\u003d 1) {\n        break;\n      }\n      requests \u003d new BatchedRequests(requests.getIteratorType(),\n          requests.getApplicationId(), rejectedRequests,\n          requests.getPlacementAttempt());\n      rejectedRequests \u003d new ArrayList\u003c\u003e();\n      rePlacementCount--;\n    }\n\n    resp.getRejectedRequests().addAll(rejectedRequests);\n    collector.collect(resp);\n    // Clean current temp-container tags\n    this.tagsManager.cleanTempContainers(requests.getApplicationId());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java",
      "extendedDetails": {}
    },
    "28fe7f331837b36e78fa34ed990993677dddeaee": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7774. Miscellaneous fixes to the PlacementProcessor. (asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "28fe7f331837b36e78fa34ed990993677dddeaee",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,26 @@\n   public void place(ConstraintPlacementAlgorithmInput input,\n       ConstraintPlacementAlgorithmOutputCollector collector) {\n     BatchedRequests requests \u003d (BatchedRequests) input;\n     ConstraintPlacementAlgorithmOutput resp \u003d\n         new ConstraintPlacementAlgorithmOutput(requests.getApplicationId());\n     List\u003cSchedulerNode\u003e allNodes \u003d nodeSelector.selectNodes(null);\n \n-    Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n-    while (requestIterator.hasNext()) {\n-      SchedulingRequest schedulingRequest \u003d requestIterator.next();\n-      Iterator\u003cSchedulerNode\u003e nodeIter \u003d allNodes.iterator();\n-      int numAllocs \u003d schedulingRequest.getResourceSizing().getNumAllocations();\n-      while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n-        SchedulerNode node \u003d nodeIter.next();\n-        try {\n-          if (attemptPlacementOnNode(requests.getApplicationId(),\n-              schedulingRequest, node)) {\n-            schedulingRequest.getResourceSizing()\n-                .setNumAllocations(--numAllocs);\n-            PlacedSchedulingRequest placedReq \u003d\n-                new PlacedSchedulingRequest(schedulingRequest);\n-            placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n-            placedReq.getNodes().add(node);\n-            resp.getPlacedRequests().add(placedReq);\n-            numAllocs \u003d\n-                schedulingRequest.getResourceSizing().getNumAllocations();\n-            // Add temp-container tags for current placement cycle\n-            this.tagsManager.addTempContainer(node.getNodeID(),\n-                requests.getApplicationId(),\n-                schedulingRequest.getAllocationTags());\n-          }\n-        } catch (InvalidAllocationTagsQueryException e) {\n-          LOG.warn(\"Got exception from TagManager !\", e);\n-        }\n+    List\u003cSchedulingRequest\u003e rejectedRequests \u003d new ArrayList\u003c\u003e();\n+    int rePlacementCount \u003d RE_ATTEMPT_COUNT;\n+    while (rePlacementCount \u003e 0) {\n+      doPlacement(requests, resp, allNodes, rejectedRequests);\n+      if (rejectedRequests.size() \u003d\u003d 0 || rePlacementCount \u003d\u003d 1) {\n+        break;\n       }\n+      requests \u003d new BatchedRequests(requests.getIteratorType(),\n+          requests.getApplicationId(), rejectedRequests,\n+          requests.getPlacementAttempt());\n+      rejectedRequests \u003d new ArrayList\u003c\u003e();\n+      rePlacementCount--;\n     }\n-    // Add all requests whose numAllocations still \u003e 0 to rejected list.\n-    requests.getSchedulingRequests().stream()\n-        .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n-        .forEach(rejReq -\u003e resp.getRejectedRequests().add(rejReq));\n+\n+    resp.getRejectedRequests().addAll(rejectedRequests);\n     collector.collect(resp);\n     // Clean current temp-container tags\n     this.tagsManager.cleanTempContainers(requests.getApplicationId());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void place(ConstraintPlacementAlgorithmInput input,\n      ConstraintPlacementAlgorithmOutputCollector collector) {\n    BatchedRequests requests \u003d (BatchedRequests) input;\n    ConstraintPlacementAlgorithmOutput resp \u003d\n        new ConstraintPlacementAlgorithmOutput(requests.getApplicationId());\n    List\u003cSchedulerNode\u003e allNodes \u003d nodeSelector.selectNodes(null);\n\n    List\u003cSchedulingRequest\u003e rejectedRequests \u003d new ArrayList\u003c\u003e();\n    int rePlacementCount \u003d RE_ATTEMPT_COUNT;\n    while (rePlacementCount \u003e 0) {\n      doPlacement(requests, resp, allNodes, rejectedRequests);\n      if (rejectedRequests.size() \u003d\u003d 0 || rePlacementCount \u003d\u003d 1) {\n        break;\n      }\n      requests \u003d new BatchedRequests(requests.getIteratorType(),\n          requests.getApplicationId(), rejectedRequests,\n          requests.getPlacementAttempt());\n      rejectedRequests \u003d new ArrayList\u003c\u003e();\n      rePlacementCount--;\n    }\n\n    resp.getRejectedRequests().addAll(rejectedRequests);\n    collector.collect(resp);\n    // Clean current temp-container tags\n    this.tagsManager.cleanTempContainers(requests.getApplicationId());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java",
      "extendedDetails": {}
    },
    "a52d11fb8c103f14e42692600a058ba3b56e2ecf": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "YARN-7613. Implement Basic algorithm for constraint based placement. (Panagiotis Garefalakis via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "a52d11fb8c103f14e42692600a058ba3b56e2ecf",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-7613. Implement Basic algorithm for constraint based placement. (Panagiotis Garefalakis via asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "a52d11fb8c103f14e42692600a058ba3b56e2ecf",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "f9af15d659f59fd0cf564fe1ecc8e06c6429ba68",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,44 @@\n   public void place(ConstraintPlacementAlgorithmInput input,\n       ConstraintPlacementAlgorithmOutputCollector collector) {\n-    BatchedRequests requests \u003d (BatchedRequests)input;\n+    BatchedRequests requests \u003d (BatchedRequests) input;\n     ConstraintPlacementAlgorithmOutput resp \u003d\n         new ConstraintPlacementAlgorithmOutput(requests.getApplicationId());\n     List\u003cSchedulerNode\u003e allNodes \u003d nodeSelector.selectNodes(null);\n-    Map\u003cString, List\u003cSchedulingRequest\u003e\u003e tagIndexedRequests \u003d new HashMap\u003c\u003e();\n-    requests.getSchedulingRequests()\n-        .stream()\n-        .filter(r -\u003e r.getAllocationTags() !\u003d null)\n-        .forEach(\n-            req -\u003e req.getAllocationTags().forEach(\n-                tag -\u003e tagIndexedRequests.computeIfAbsent(tag,\n-                    k -\u003e new ArrayList\u003c\u003e()).add(req))\n-        );\n-    for (Map.Entry\u003cString, List\u003cSchedulingRequest\u003e\u003e entry :\n-        tagIndexedRequests.entrySet()) {\n-      String tag \u003d entry.getKey();\n-      PlacementConstraint constraint \u003d\n-          constraintManager.getConstraint(requests.getApplicationId(),\n-              Collections.singleton(tag));\n-      if (constraint !\u003d null) {\n-        // Currently works only for simple anti-affinity\n-        // NODE scope target expressions\n-        SpecializedConstraintTransformer transformer \u003d\n-            new SpecializedConstraintTransformer(constraint);\n-        PlacementConstraint transform \u003d transformer.transform();\n-        TargetConstraint targetConstraint \u003d\n-            (TargetConstraint) transform.getConstraintExpr();\n-        // Assume a single target expression tag;\n-        // The Sample Algorithm assumes a constraint will always be a simple\n-        // Target Constraint with a single entry in the target set.\n-        // As mentioned in the class javadoc - This algorithm should be\n-        // used mostly for testing and validating end-2-end workflow.\n-        String targetTag \u003d\n-            targetConstraint.getTargetExpressions().iterator().next()\n-            .getTargetValues().iterator().next();\n-        // iterate over all nodes\n-        Iterator\u003cSchedulerNode\u003e nodeIter \u003d allNodes.iterator();\n-        List\u003cSchedulingRequest\u003e schedulingRequests \u003d entry.getValue();\n-        Iterator\u003cSchedulingRequest\u003e reqIter \u003d schedulingRequests.iterator();\n-        while (reqIter.hasNext()) {\n-          SchedulingRequest sReq \u003d reqIter.next();\n-          int numAllocs \u003d sReq.getResourceSizing().getNumAllocations();\n-          while (numAllocs \u003e 0 \u0026\u0026 nodeIter.hasNext()) {\n-            SchedulerNode node \u003d nodeIter.next();\n-            long nodeCardinality \u003d 0;\n-            try {\n-              nodeCardinality \u003d tagsManager.getNodeCardinality(\n-                  node.getNodeID(), requests.getApplicationId(),\n-                  targetTag);\n-              if (nodeCardinality \u003d\u003d 0 \u0026\u0026\n-                  !requests.getBlacklist(tag).contains(node.getNodeID())) {\n-                numAllocs--;\n-                sReq.getResourceSizing().setNumAllocations(numAllocs);\n-                PlacedSchedulingRequest placedReq \u003d\n-                    new PlacedSchedulingRequest(sReq);\n-                placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n-                placedReq.getNodes().add(node);\n-                resp.getPlacedRequests().add(placedReq);\n-              }\n-            } catch (InvalidAllocationTagsQueryException e) {\n-              LOG.warn(\"Got exception from TagManager !\", e);\n-            }\n+\n+    Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n+    while (requestIterator.hasNext()) {\n+      SchedulingRequest schedulingRequest \u003d requestIterator.next();\n+      Iterator\u003cSchedulerNode\u003e nodeIter \u003d allNodes.iterator();\n+      int numAllocs \u003d schedulingRequest.getResourceSizing().getNumAllocations();\n+      while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n+        SchedulerNode node \u003d nodeIter.next();\n+        try {\n+          if (attemptPlacementOnNode(requests.getApplicationId(),\n+              schedulingRequest, node)) {\n+            schedulingRequest.getResourceSizing()\n+                .setNumAllocations(--numAllocs);\n+            PlacedSchedulingRequest placedReq \u003d\n+                new PlacedSchedulingRequest(schedulingRequest);\n+            placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n+            placedReq.getNodes().add(node);\n+            resp.getPlacedRequests().add(placedReq);\n+            numAllocs \u003d\n+                schedulingRequest.getResourceSizing().getNumAllocations();\n+            // Add temp-container tags for current placement cycle\n+            this.tagsManager.addTempContainer(node.getNodeID(),\n+                requests.getApplicationId(),\n+                schedulingRequest.getAllocationTags());\n           }\n+        } catch (InvalidAllocationTagsQueryException e) {\n+          LOG.warn(\"Got exception from TagManager !\", e);\n         }\n       }\n     }\n     // Add all requests whose numAllocations still \u003e 0 to rejected list.\n     requests.getSchedulingRequests().stream()\n         .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n         .forEach(rejReq -\u003e resp.getRejectedRequests().add(rejReq));\n     collector.collect(resp);\n+    // Clean current temp-container tags\n+    this.tagsManager.cleanTempContainers(requests.getApplicationId());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void place(ConstraintPlacementAlgorithmInput input,\n      ConstraintPlacementAlgorithmOutputCollector collector) {\n    BatchedRequests requests \u003d (BatchedRequests) input;\n    ConstraintPlacementAlgorithmOutput resp \u003d\n        new ConstraintPlacementAlgorithmOutput(requests.getApplicationId());\n    List\u003cSchedulerNode\u003e allNodes \u003d nodeSelector.selectNodes(null);\n\n    Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n    while (requestIterator.hasNext()) {\n      SchedulingRequest schedulingRequest \u003d requestIterator.next();\n      Iterator\u003cSchedulerNode\u003e nodeIter \u003d allNodes.iterator();\n      int numAllocs \u003d schedulingRequest.getResourceSizing().getNumAllocations();\n      while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n        SchedulerNode node \u003d nodeIter.next();\n        try {\n          if (attemptPlacementOnNode(requests.getApplicationId(),\n              schedulingRequest, node)) {\n            schedulingRequest.getResourceSizing()\n                .setNumAllocations(--numAllocs);\n            PlacedSchedulingRequest placedReq \u003d\n                new PlacedSchedulingRequest(schedulingRequest);\n            placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n            placedReq.getNodes().add(node);\n            resp.getPlacedRequests().add(placedReq);\n            numAllocs \u003d\n                schedulingRequest.getResourceSizing().getNumAllocations();\n            // Add temp-container tags for current placement cycle\n            this.tagsManager.addTempContainer(node.getNodeID(),\n                requests.getApplicationId(),\n                schedulingRequest.getAllocationTags());\n          }\n        } catch (InvalidAllocationTagsQueryException e) {\n          LOG.warn(\"Got exception from TagManager !\", e);\n        }\n      }\n    }\n    // Add all requests whose numAllocations still \u003e 0 to rejected list.\n    requests.getSchedulingRequests().stream()\n        .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n        .forEach(rejReq -\u003e resp.getRejectedRequests().add(rejReq));\n    collector.collect(resp);\n    // Clean current temp-container tags\n    this.tagsManager.cleanTempContainers(requests.getApplicationId());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/processor/SamplePlacementAlgorithm.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java",
            "oldMethodName": "place",
            "newMethodName": "place"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7613. Implement Basic algorithm for constraint based placement. (Panagiotis Garefalakis via asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "a52d11fb8c103f14e42692600a058ba3b56e2ecf",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "f9af15d659f59fd0cf564fe1ecc8e06c6429ba68",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,44 @@\n   public void place(ConstraintPlacementAlgorithmInput input,\n       ConstraintPlacementAlgorithmOutputCollector collector) {\n-    BatchedRequests requests \u003d (BatchedRequests)input;\n+    BatchedRequests requests \u003d (BatchedRequests) input;\n     ConstraintPlacementAlgorithmOutput resp \u003d\n         new ConstraintPlacementAlgorithmOutput(requests.getApplicationId());\n     List\u003cSchedulerNode\u003e allNodes \u003d nodeSelector.selectNodes(null);\n-    Map\u003cString, List\u003cSchedulingRequest\u003e\u003e tagIndexedRequests \u003d new HashMap\u003c\u003e();\n-    requests.getSchedulingRequests()\n-        .stream()\n-        .filter(r -\u003e r.getAllocationTags() !\u003d null)\n-        .forEach(\n-            req -\u003e req.getAllocationTags().forEach(\n-                tag -\u003e tagIndexedRequests.computeIfAbsent(tag,\n-                    k -\u003e new ArrayList\u003c\u003e()).add(req))\n-        );\n-    for (Map.Entry\u003cString, List\u003cSchedulingRequest\u003e\u003e entry :\n-        tagIndexedRequests.entrySet()) {\n-      String tag \u003d entry.getKey();\n-      PlacementConstraint constraint \u003d\n-          constraintManager.getConstraint(requests.getApplicationId(),\n-              Collections.singleton(tag));\n-      if (constraint !\u003d null) {\n-        // Currently works only for simple anti-affinity\n-        // NODE scope target expressions\n-        SpecializedConstraintTransformer transformer \u003d\n-            new SpecializedConstraintTransformer(constraint);\n-        PlacementConstraint transform \u003d transformer.transform();\n-        TargetConstraint targetConstraint \u003d\n-            (TargetConstraint) transform.getConstraintExpr();\n-        // Assume a single target expression tag;\n-        // The Sample Algorithm assumes a constraint will always be a simple\n-        // Target Constraint with a single entry in the target set.\n-        // As mentioned in the class javadoc - This algorithm should be\n-        // used mostly for testing and validating end-2-end workflow.\n-        String targetTag \u003d\n-            targetConstraint.getTargetExpressions().iterator().next()\n-            .getTargetValues().iterator().next();\n-        // iterate over all nodes\n-        Iterator\u003cSchedulerNode\u003e nodeIter \u003d allNodes.iterator();\n-        List\u003cSchedulingRequest\u003e schedulingRequests \u003d entry.getValue();\n-        Iterator\u003cSchedulingRequest\u003e reqIter \u003d schedulingRequests.iterator();\n-        while (reqIter.hasNext()) {\n-          SchedulingRequest sReq \u003d reqIter.next();\n-          int numAllocs \u003d sReq.getResourceSizing().getNumAllocations();\n-          while (numAllocs \u003e 0 \u0026\u0026 nodeIter.hasNext()) {\n-            SchedulerNode node \u003d nodeIter.next();\n-            long nodeCardinality \u003d 0;\n-            try {\n-              nodeCardinality \u003d tagsManager.getNodeCardinality(\n-                  node.getNodeID(), requests.getApplicationId(),\n-                  targetTag);\n-              if (nodeCardinality \u003d\u003d 0 \u0026\u0026\n-                  !requests.getBlacklist(tag).contains(node.getNodeID())) {\n-                numAllocs--;\n-                sReq.getResourceSizing().setNumAllocations(numAllocs);\n-                PlacedSchedulingRequest placedReq \u003d\n-                    new PlacedSchedulingRequest(sReq);\n-                placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n-                placedReq.getNodes().add(node);\n-                resp.getPlacedRequests().add(placedReq);\n-              }\n-            } catch (InvalidAllocationTagsQueryException e) {\n-              LOG.warn(\"Got exception from TagManager !\", e);\n-            }\n+\n+    Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n+    while (requestIterator.hasNext()) {\n+      SchedulingRequest schedulingRequest \u003d requestIterator.next();\n+      Iterator\u003cSchedulerNode\u003e nodeIter \u003d allNodes.iterator();\n+      int numAllocs \u003d schedulingRequest.getResourceSizing().getNumAllocations();\n+      while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n+        SchedulerNode node \u003d nodeIter.next();\n+        try {\n+          if (attemptPlacementOnNode(requests.getApplicationId(),\n+              schedulingRequest, node)) {\n+            schedulingRequest.getResourceSizing()\n+                .setNumAllocations(--numAllocs);\n+            PlacedSchedulingRequest placedReq \u003d\n+                new PlacedSchedulingRequest(schedulingRequest);\n+            placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n+            placedReq.getNodes().add(node);\n+            resp.getPlacedRequests().add(placedReq);\n+            numAllocs \u003d\n+                schedulingRequest.getResourceSizing().getNumAllocations();\n+            // Add temp-container tags for current placement cycle\n+            this.tagsManager.addTempContainer(node.getNodeID(),\n+                requests.getApplicationId(),\n+                schedulingRequest.getAllocationTags());\n           }\n+        } catch (InvalidAllocationTagsQueryException e) {\n+          LOG.warn(\"Got exception from TagManager !\", e);\n         }\n       }\n     }\n     // Add all requests whose numAllocations still \u003e 0 to rejected list.\n     requests.getSchedulingRequests().stream()\n         .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n         .forEach(rejReq -\u003e resp.getRejectedRequests().add(rejReq));\n     collector.collect(resp);\n+    // Clean current temp-container tags\n+    this.tagsManager.cleanTempContainers(requests.getApplicationId());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void place(ConstraintPlacementAlgorithmInput input,\n      ConstraintPlacementAlgorithmOutputCollector collector) {\n    BatchedRequests requests \u003d (BatchedRequests) input;\n    ConstraintPlacementAlgorithmOutput resp \u003d\n        new ConstraintPlacementAlgorithmOutput(requests.getApplicationId());\n    List\u003cSchedulerNode\u003e allNodes \u003d nodeSelector.selectNodes(null);\n\n    Iterator\u003cSchedulingRequest\u003e requestIterator \u003d requests.iterator();\n    while (requestIterator.hasNext()) {\n      SchedulingRequest schedulingRequest \u003d requestIterator.next();\n      Iterator\u003cSchedulerNode\u003e nodeIter \u003d allNodes.iterator();\n      int numAllocs \u003d schedulingRequest.getResourceSizing().getNumAllocations();\n      while (nodeIter.hasNext() \u0026\u0026 numAllocs \u003e 0) {\n        SchedulerNode node \u003d nodeIter.next();\n        try {\n          if (attemptPlacementOnNode(requests.getApplicationId(),\n              schedulingRequest, node)) {\n            schedulingRequest.getResourceSizing()\n                .setNumAllocations(--numAllocs);\n            PlacedSchedulingRequest placedReq \u003d\n                new PlacedSchedulingRequest(schedulingRequest);\n            placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n            placedReq.getNodes().add(node);\n            resp.getPlacedRequests().add(placedReq);\n            numAllocs \u003d\n                schedulingRequest.getResourceSizing().getNumAllocations();\n            // Add temp-container tags for current placement cycle\n            this.tagsManager.addTempContainer(node.getNodeID(),\n                requests.getApplicationId(),\n                schedulingRequest.getAllocationTags());\n          }\n        } catch (InvalidAllocationTagsQueryException e) {\n          LOG.warn(\"Got exception from TagManager !\", e);\n        }\n      }\n    }\n    // Add all requests whose numAllocations still \u003e 0 to rejected list.\n    requests.getSchedulingRequests().stream()\n        .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n        .forEach(rejReq -\u003e resp.getRejectedRequests().add(rejReq));\n    collector.collect(resp);\n    // Clean current temp-container tags\n    this.tagsManager.cleanTempContainers(requests.getApplicationId());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/algorithm/DefaultPlacementAlgorithm.java",
          "extendedDetails": {}
        }
      ]
    },
    "f9af15d659f59fd0cf564fe1ecc8e06c6429ba68": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7612. Add Processor Framework for Rich Placement Constraints. (asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "f9af15d659f59fd0cf564fe1ecc8e06c6429ba68",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,74 @@\n+  public void place(ConstraintPlacementAlgorithmInput input,\n+      ConstraintPlacementAlgorithmOutputCollector collector) {\n+    BatchedRequests requests \u003d (BatchedRequests)input;\n+    ConstraintPlacementAlgorithmOutput resp \u003d\n+        new ConstraintPlacementAlgorithmOutput(requests.getApplicationId());\n+    List\u003cSchedulerNode\u003e allNodes \u003d nodeSelector.selectNodes(null);\n+    Map\u003cString, List\u003cSchedulingRequest\u003e\u003e tagIndexedRequests \u003d new HashMap\u003c\u003e();\n+    requests.getSchedulingRequests()\n+        .stream()\n+        .filter(r -\u003e r.getAllocationTags() !\u003d null)\n+        .forEach(\n+            req -\u003e req.getAllocationTags().forEach(\n+                tag -\u003e tagIndexedRequests.computeIfAbsent(tag,\n+                    k -\u003e new ArrayList\u003c\u003e()).add(req))\n+        );\n+    for (Map.Entry\u003cString, List\u003cSchedulingRequest\u003e\u003e entry :\n+        tagIndexedRequests.entrySet()) {\n+      String tag \u003d entry.getKey();\n+      PlacementConstraint constraint \u003d\n+          constraintManager.getConstraint(requests.getApplicationId(),\n+              Collections.singleton(tag));\n+      if (constraint !\u003d null) {\n+        // Currently works only for simple anti-affinity\n+        // NODE scope target expressions\n+        SpecializedConstraintTransformer transformer \u003d\n+            new SpecializedConstraintTransformer(constraint);\n+        PlacementConstraint transform \u003d transformer.transform();\n+        TargetConstraint targetConstraint \u003d\n+            (TargetConstraint) transform.getConstraintExpr();\n+        // Assume a single target expression tag;\n+        // The Sample Algorithm assumes a constraint will always be a simple\n+        // Target Constraint with a single entry in the target set.\n+        // As mentioned in the class javadoc - This algorithm should be\n+        // used mostly for testing and validating end-2-end workflow.\n+        String targetTag \u003d\n+            targetConstraint.getTargetExpressions().iterator().next()\n+            .getTargetValues().iterator().next();\n+        // iterate over all nodes\n+        Iterator\u003cSchedulerNode\u003e nodeIter \u003d allNodes.iterator();\n+        List\u003cSchedulingRequest\u003e schedulingRequests \u003d entry.getValue();\n+        Iterator\u003cSchedulingRequest\u003e reqIter \u003d schedulingRequests.iterator();\n+        while (reqIter.hasNext()) {\n+          SchedulingRequest sReq \u003d reqIter.next();\n+          int numAllocs \u003d sReq.getResourceSizing().getNumAllocations();\n+          while (numAllocs \u003e 0 \u0026\u0026 nodeIter.hasNext()) {\n+            SchedulerNode node \u003d nodeIter.next();\n+            long nodeCardinality \u003d 0;\n+            try {\n+              nodeCardinality \u003d tagsManager.getNodeCardinality(\n+                  node.getNodeID(), requests.getApplicationId(),\n+                  targetTag);\n+              if (nodeCardinality \u003d\u003d 0 \u0026\u0026\n+                  !requests.getBlacklist(tag).contains(node.getNodeID())) {\n+                numAllocs--;\n+                sReq.getResourceSizing().setNumAllocations(numAllocs);\n+                PlacedSchedulingRequest placedReq \u003d\n+                    new PlacedSchedulingRequest(sReq);\n+                placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n+                placedReq.getNodes().add(node);\n+                resp.getPlacedRequests().add(placedReq);\n+              }\n+            } catch (InvalidAllocationTagsQueryException e) {\n+              LOG.warn(\"Got exception from TagManager !\", e);\n+            }\n+          }\n+        }\n+      }\n+    }\n+    // Add all requests whose numAllocations still \u003e 0 to rejected list.\n+    requests.getSchedulingRequests().stream()\n+        .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n+        .forEach(rejReq -\u003e resp.getRejectedRequests().add(rejReq));\n+    collector.collect(resp);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void place(ConstraintPlacementAlgorithmInput input,\n      ConstraintPlacementAlgorithmOutputCollector collector) {\n    BatchedRequests requests \u003d (BatchedRequests)input;\n    ConstraintPlacementAlgorithmOutput resp \u003d\n        new ConstraintPlacementAlgorithmOutput(requests.getApplicationId());\n    List\u003cSchedulerNode\u003e allNodes \u003d nodeSelector.selectNodes(null);\n    Map\u003cString, List\u003cSchedulingRequest\u003e\u003e tagIndexedRequests \u003d new HashMap\u003c\u003e();\n    requests.getSchedulingRequests()\n        .stream()\n        .filter(r -\u003e r.getAllocationTags() !\u003d null)\n        .forEach(\n            req -\u003e req.getAllocationTags().forEach(\n                tag -\u003e tagIndexedRequests.computeIfAbsent(tag,\n                    k -\u003e new ArrayList\u003c\u003e()).add(req))\n        );\n    for (Map.Entry\u003cString, List\u003cSchedulingRequest\u003e\u003e entry :\n        tagIndexedRequests.entrySet()) {\n      String tag \u003d entry.getKey();\n      PlacementConstraint constraint \u003d\n          constraintManager.getConstraint(requests.getApplicationId(),\n              Collections.singleton(tag));\n      if (constraint !\u003d null) {\n        // Currently works only for simple anti-affinity\n        // NODE scope target expressions\n        SpecializedConstraintTransformer transformer \u003d\n            new SpecializedConstraintTransformer(constraint);\n        PlacementConstraint transform \u003d transformer.transform();\n        TargetConstraint targetConstraint \u003d\n            (TargetConstraint) transform.getConstraintExpr();\n        // Assume a single target expression tag;\n        // The Sample Algorithm assumes a constraint will always be a simple\n        // Target Constraint with a single entry in the target set.\n        // As mentioned in the class javadoc - This algorithm should be\n        // used mostly for testing and validating end-2-end workflow.\n        String targetTag \u003d\n            targetConstraint.getTargetExpressions().iterator().next()\n            .getTargetValues().iterator().next();\n        // iterate over all nodes\n        Iterator\u003cSchedulerNode\u003e nodeIter \u003d allNodes.iterator();\n        List\u003cSchedulingRequest\u003e schedulingRequests \u003d entry.getValue();\n        Iterator\u003cSchedulingRequest\u003e reqIter \u003d schedulingRequests.iterator();\n        while (reqIter.hasNext()) {\n          SchedulingRequest sReq \u003d reqIter.next();\n          int numAllocs \u003d sReq.getResourceSizing().getNumAllocations();\n          while (numAllocs \u003e 0 \u0026\u0026 nodeIter.hasNext()) {\n            SchedulerNode node \u003d nodeIter.next();\n            long nodeCardinality \u003d 0;\n            try {\n              nodeCardinality \u003d tagsManager.getNodeCardinality(\n                  node.getNodeID(), requests.getApplicationId(),\n                  targetTag);\n              if (nodeCardinality \u003d\u003d 0 \u0026\u0026\n                  !requests.getBlacklist(tag).contains(node.getNodeID())) {\n                numAllocs--;\n                sReq.getResourceSizing().setNumAllocations(numAllocs);\n                PlacedSchedulingRequest placedReq \u003d\n                    new PlacedSchedulingRequest(sReq);\n                placedReq.setPlacementAttempt(requests.getPlacementAttempt());\n                placedReq.getNodes().add(node);\n                resp.getPlacedRequests().add(placedReq);\n              }\n            } catch (InvalidAllocationTagsQueryException e) {\n              LOG.warn(\"Got exception from TagManager !\", e);\n            }\n          }\n        }\n      }\n    }\n    // Add all requests whose numAllocations still \u003e 0 to rejected list.\n    requests.getSchedulingRequests().stream()\n        .filter(sReq -\u003e sReq.getResourceSizing().getNumAllocations() \u003e 0)\n        .forEach(rejReq -\u003e resp.getRejectedRequests().add(rejReq));\n    collector.collect(resp);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/processor/SamplePlacementAlgorithm.java"
    }
  }
}