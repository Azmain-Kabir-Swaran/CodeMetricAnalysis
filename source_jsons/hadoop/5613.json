{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CacheManager.java",
  "functionName": "listCacheDirectives",
  "functionId": "listCacheDirectives___prevId-long__filter-CacheDirectiveInfo__pc-FSPermissionChecker",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
  "functionStartLine": 711,
  "functionEndLine": 777,
  "numCommitsSeen": 118,
  "timeTaken": 6544,
  "changeHistory": [
    "8f48760663070529ff09927d1772010fffe5f438",
    "d85c017d0488930d806f267141057fc73e68c728",
    "991c453ca3ac141a3f286f74af8401f83c38b230",
    "13edb391d06c479720202eb5ac81f1c71fe64748",
    "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
    "e3d7ef36ef7dd31b295b1f1d86a1bfa7887ca771",
    "ce35e0950cef9250ce2ceffb3b8bfcff533c6b92",
    "f79b3e6b17450e9d34c483046b7437b09dd72016",
    "d61af9781086073152113d97106f708ea1cf6e8c",
    "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a",
    "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
    "02e0e158a26f81ce8375426ba0ea56db09ee36be",
    "f41f8b8842c3f26d19f7fa928070c7c07f760e4c",
    "d56d0b46e1b82ae068083ddb99872d314684dc82",
    "920b4cc06f1bc15809902bdd1968cc434a694a08"
  ],
  "changeHistoryShort": {
    "8f48760663070529ff09927d1772010fffe5f438": "Ybodychange",
    "d85c017d0488930d806f267141057fc73e68c728": "Ybodychange",
    "991c453ca3ac141a3f286f74af8401f83c38b230": "Ybodychange",
    "13edb391d06c479720202eb5ac81f1c71fe64748": "Ybodychange",
    "f91a45a96c21db9e5d40097c7d3f5d005ae10dde": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
    "e3d7ef36ef7dd31b295b1f1d86a1bfa7887ca771": "Ybodychange",
    "ce35e0950cef9250ce2ceffb3b8bfcff533c6b92": "Ybodychange",
    "f79b3e6b17450e9d34c483046b7437b09dd72016": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
    "d61af9781086073152113d97106f708ea1cf6e8c": "Ybodychange",
    "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a": "Ymultichange(Ymodifierchange,Ybodychange)",
    "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04": "Ymultichange(Yrename,Yreturntypechange,Ybodychange)",
    "02e0e158a26f81ce8375426ba0ea56db09ee36be": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Yexceptionschange,Ybodychange)",
    "f41f8b8842c3f26d19f7fa928070c7c07f760e4c": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "d56d0b46e1b82ae068083ddb99872d314684dc82": "Ymultichange(Yparameterchange,Ybodychange)",
    "920b4cc06f1bc15809902bdd1968cc434a694a08": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8f48760663070529ff09927d1772010fffe5f438": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6345. DFS.listCacheDirectives() should allow filtering based on cache directive ID. (wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595086 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/05/14 6:18 PM",
      "commitName": "8f48760663070529ff09927d1772010fffe5f438",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "13/05/14 6:15 PM",
      "commitNameOld": "97f58955a6045b373ab73653bf26ab5922b00cf3",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 2.0,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,67 @@\n         listCacheDirectives(long prevId,\n             CacheDirectiveInfo filter,\n             FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     String filterPath \u003d null;\n-    if (filter.getId() !\u003d null) {\n-      throw new IOException(\"Filtering by ID is unsupported.\");\n-    }\n     if (filter.getPath() !\u003d null) {\n       filterPath \u003d validatePath(filter);\n     }\n     if (filter.getReplication() !\u003d null) {\n-      throw new IOException(\"Filtering by replication is unsupported.\");\n+      throw new InvalidRequestException(\n+          \"Filtering by replication is unsupported.\");\n     }\n+\n+    // Querying for a single ID\n+    final Long id \u003d filter.getId();\n+    if (id !\u003d null) {\n+      if (!directivesById.containsKey(id)) {\n+        throw new InvalidRequestException(\"Did not find requested id \" + id);\n+      }\n+      // Since we use a tailMap on directivesById, setting prev to id-1 gets\n+      // us the directive with the id (if present)\n+      prevId \u003d id - 1;\n+    }\n+\n     ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n         new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n       directivesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n         return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n       }\n       CacheDirective curDirective \u003d cur.getValue();\n       CacheDirectiveInfo info \u003d cur.getValue().toInfo();\n+\n+      // If the requested ID is present, it should be the first item.\n+      // Hitting this case means the ID is not present, or we\u0027re on the second\n+      // item and should break out.\n+      if (id !\u003d null \u0026\u0026\n+          !(info.getId().equals(id))) {\n+        break;\n+      }\n       if (filter.getPool() !\u003d null \u0026\u0026 \n           !info.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !info.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n       boolean hasPermission \u003d true;\n       if (pc !\u003d null) {\n         try {\n           pc.checkPermission(curDirective.getPool(), FsAction.READ);\n         } catch (AccessControlException e) {\n           hasPermission \u003d false;\n         }\n       }\n       if (hasPermission) {\n         replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n         numReplies++;\n       }\n     }\n     return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "        listCacheDirectives(long prevId,\n            CacheDirectiveInfo filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d validatePath(filter);\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new InvalidRequestException(\n          \"Filtering by replication is unsupported.\");\n    }\n\n    // Querying for a single ID\n    final Long id \u003d filter.getId();\n    if (id !\u003d null) {\n      if (!directivesById.containsKey(id)) {\n        throw new InvalidRequestException(\"Did not find requested id \" + id);\n      }\n      // Since we use a tailMap on directivesById, setting prev to id-1 gets\n      // us the directive with the id (if present)\n      prevId \u003d id - 1;\n    }\n\n    ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n        new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n      directivesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n      }\n      CacheDirective curDirective \u003d cur.getValue();\n      CacheDirectiveInfo info \u003d cur.getValue().toInfo();\n\n      // If the requested ID is present, it should be the first item.\n      // Hitting this case means the ID is not present, or we\u0027re on the second\n      // item and should break out.\n      if (id !\u003d null \u0026\u0026\n          !(info.getId().equals(id))) {\n        break;\n      }\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !info.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !info.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      boolean hasPermission \u003d true;\n      if (pc !\u003d null) {\n        try {\n          pc.checkPermission(curDirective.getPool(), FsAction.READ);\n        } catch (AccessControlException e) {\n          hasPermission \u003d false;\n        }\n      }\n      if (hasPermission) {\n        replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "d85c017d0488930d806f267141057fc73e68c728": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5651. Remove dfs.namenode.caching.enabled and improve CRM locking. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1555002 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/01/14 6:45 PM",
      "commitName": "d85c017d0488930d806f267141057fc73e68c728",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "31/12/13 4:01 PM",
      "commitNameOld": "07e4fb1455abc33584fc666ef745abe256ebd7d1",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 2.11,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,49 @@\n         listCacheDirectives(long prevId,\n             CacheDirectiveInfo filter,\n             FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     String filterPath \u003d null;\n     if (filter.getId() !\u003d null) {\n       throw new IOException(\"Filtering by ID is unsupported.\");\n     }\n     if (filter.getPath() !\u003d null) {\n       filterPath \u003d validatePath(filter);\n     }\n     if (filter.getReplication() !\u003d null) {\n       throw new IOException(\"Filtering by replication is unsupported.\");\n     }\n-    if (monitor !\u003d null) {\n-      monitor.waitForRescanIfNeeded();\n-    }\n     ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n         new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n       directivesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n         return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n       }\n       CacheDirective curDirective \u003d cur.getValue();\n       CacheDirectiveInfo info \u003d cur.getValue().toInfo();\n       if (filter.getPool() !\u003d null \u0026\u0026 \n           !info.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !info.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n       boolean hasPermission \u003d true;\n       if (pc !\u003d null) {\n         try {\n           pc.checkPermission(curDirective.getPool(), FsAction.READ);\n         } catch (AccessControlException e) {\n           hasPermission \u003d false;\n         }\n       }\n       if (hasPermission) {\n         replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n         numReplies++;\n       }\n     }\n     return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "        listCacheDirectives(long prevId,\n            CacheDirectiveInfo filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"Filtering by ID is unsupported.\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d validatePath(filter);\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"Filtering by replication is unsupported.\");\n    }\n    ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n        new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n      directivesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n      }\n      CacheDirective curDirective \u003d cur.getValue();\n      CacheDirectiveInfo info \u003d cur.getValue().toInfo();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !info.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !info.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      boolean hasPermission \u003d true;\n      if (pc !\u003d null) {\n        try {\n          pc.checkPermission(curDirective.getPool(), FsAction.READ);\n        } catch (AccessControlException e) {\n          hasPermission \u003d false;\n        }\n      }\n      if (hasPermission) {\n        replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "991c453ca3ac141a3f286f74af8401f83c38b230": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5431. Support cachepool-based limit management in path-based caching. (awang via cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551651 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/12/13 10:47 AM",
      "commitName": "991c453ca3ac141a3f286f74af8401f83c38b230",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "05/12/13 1:09 PM",
      "commitNameOld": "55e5b0653c34a5f4146ce5a97a5b4a88a976d88a",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 11.9,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,52 @@\n         listCacheDirectives(long prevId,\n             CacheDirectiveInfo filter,\n             FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     String filterPath \u003d null;\n     if (filter.getId() !\u003d null) {\n       throw new IOException(\"Filtering by ID is unsupported.\");\n     }\n     if (filter.getPath() !\u003d null) {\n       filterPath \u003d validatePath(filter);\n     }\n     if (filter.getReplication() !\u003d null) {\n       throw new IOException(\"Filtering by replication is unsupported.\");\n     }\n+    if (monitor !\u003d null) {\n+      monitor.waitForRescanIfNeeded();\n+    }\n     ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n         new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n       directivesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n         return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n       }\n       CacheDirective curDirective \u003d cur.getValue();\n       CacheDirectiveInfo info \u003d cur.getValue().toInfo();\n       if (filter.getPool() !\u003d null \u0026\u0026 \n           !info.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !info.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n       boolean hasPermission \u003d true;\n       if (pc !\u003d null) {\n         try {\n           pc.checkPermission(curDirective.getPool(), FsAction.READ);\n         } catch (AccessControlException e) {\n           hasPermission \u003d false;\n         }\n       }\n       if (hasPermission) {\n         replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n         numReplies++;\n       }\n     }\n     return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "        listCacheDirectives(long prevId,\n            CacheDirectiveInfo filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"Filtering by ID is unsupported.\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d validatePath(filter);\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"Filtering by replication is unsupported.\");\n    }\n    if (monitor !\u003d null) {\n      monitor.waitForRescanIfNeeded();\n    }\n    ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n        new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n      directivesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n      }\n      CacheDirective curDirective \u003d cur.getValue();\n      CacheDirectiveInfo info \u003d cur.getValue().toInfo();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !info.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !info.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      boolean hasPermission \u003d true;\n      if (pc !\u003d null) {\n        try {\n          pc.checkPermission(curDirective.getPool(), FsAction.READ);\n        } catch (AccessControlException e) {\n          hasPermission \u003d false;\n        }\n      }\n      if (hasPermission) {\n        replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "13edb391d06c479720202eb5ac81f1c71fe64748": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5556. Add some more NameNode cache statistics, cache pool stats (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/13 9:55 AM",
      "commitName": "13edb391d06c479720202eb5ac81f1c71fe64748",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "21/11/13 9:12 AM",
      "commitNameOld": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 6.03,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n         listCacheDirectives(long prevId,\n             CacheDirectiveInfo filter,\n             FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     String filterPath \u003d null;\n     if (filter.getId() !\u003d null) {\n       throw new IOException(\"Filtering by ID is unsupported.\");\n     }\n     if (filter.getPath() !\u003d null) {\n       filterPath \u003d validatePath(filter);\n     }\n     if (filter.getReplication() !\u003d null) {\n       throw new IOException(\"Filtering by replication is unsupported.\");\n     }\n     ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n         new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n-      entriesById.tailMap(prevId + 1);\n+      directivesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n         return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n       }\n-      CacheDirective curEntry \u003d cur.getValue();\n-      CacheDirectiveInfo info \u003d cur.getValue().toDirective();\n+      CacheDirective curDirective \u003d cur.getValue();\n+      CacheDirectiveInfo info \u003d cur.getValue().toInfo();\n       if (filter.getPool() !\u003d null \u0026\u0026 \n           !info.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !info.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n       boolean hasPermission \u003d true;\n       if (pc !\u003d null) {\n         try {\n-          pc.checkPermission(curEntry.getPool(), FsAction.READ);\n+          pc.checkPermission(curDirective.getPool(), FsAction.READ);\n         } catch (AccessControlException e) {\n           hasPermission \u003d false;\n         }\n       }\n       if (hasPermission) {\n         replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n         numReplies++;\n       }\n     }\n     return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "        listCacheDirectives(long prevId,\n            CacheDirectiveInfo filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"Filtering by ID is unsupported.\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d validatePath(filter);\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"Filtering by replication is unsupported.\");\n    }\n    ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n        new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n      directivesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n      }\n      CacheDirective curDirective \u003d cur.getValue();\n      CacheDirectiveInfo info \u003d cur.getValue().toInfo();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !info.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !info.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      boolean hasPermission \u003d true;\n      if (pc !\u003d null) {\n        try {\n          pc.checkPermission(curDirective.getPool(), FsAction.READ);\n        } catch (AccessControlException e) {\n          hasPermission \u003d false;\n        }\n      }\n      if (hasPermission) {\n        replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "f91a45a96c21db9e5d40097c7d3f5d005ae10dde": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-5473. Consistent naming of user-visible caching classes and methods (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544252 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/11/13 9:12 AM",
      "commitName": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-5473. Consistent naming of user-visible caching classes and methods (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544252 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/11/13 9:12 AM",
          "commitName": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "18/11/13 6:01 PM",
          "commitNameOld": "4f15d0af4f3633bfa35f7cb7c1cc15ef545597d0",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.63,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,49 @@\n-        listPathBasedCacheDirectives(long prevId,\n-            PathBasedCacheDirective filter,\n+        listCacheDirectives(long prevId,\n+            CacheDirectiveInfo filter,\n             FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     String filterPath \u003d null;\n     if (filter.getId() !\u003d null) {\n       throw new IOException(\"Filtering by ID is unsupported.\");\n     }\n     if (filter.getPath() !\u003d null) {\n       filterPath \u003d validatePath(filter);\n     }\n     if (filter.getReplication() !\u003d null) {\n       throw new IOException(\"Filtering by replication is unsupported.\");\n     }\n-    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n-        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n+        new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n+    SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n       entriesById.tailMap(prevId + 1);\n-    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n+    for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n-        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n+        return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n       }\n-      PathBasedCacheEntry curEntry \u003d cur.getValue();\n-      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n+      CacheDirective curEntry \u003d cur.getValue();\n+      CacheDirectiveInfo info \u003d cur.getValue().toDirective();\n       if (filter.getPool() !\u003d null \u0026\u0026 \n-          !directive.getPool().equals(filter.getPool())) {\n+          !info.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n-          !directive.getPath().toUri().getPath().equals(filterPath)) {\n+          !info.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n       boolean hasPermission \u003d true;\n       if (pc !\u003d null) {\n         try {\n           pc.checkPermission(curEntry.getPool(), FsAction.READ);\n         } catch (AccessControlException e) {\n           hasPermission \u003d false;\n         }\n       }\n       if (hasPermission) {\n-        replies.add(cur.getValue().toDirective());\n+        replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n+    return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listCacheDirectives(long prevId,\n            CacheDirectiveInfo filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"Filtering by ID is unsupported.\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d validatePath(filter);\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"Filtering by replication is unsupported.\");\n    }\n    ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n        new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n      entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n      }\n      CacheDirective curEntry \u003d cur.getValue();\n      CacheDirectiveInfo info \u003d cur.getValue().toDirective();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !info.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !info.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      boolean hasPermission \u003d true;\n      if (pc !\u003d null) {\n        try {\n          pc.checkPermission(curEntry.getPool(), FsAction.READ);\n        } catch (AccessControlException e) {\n          hasPermission \u003d false;\n        }\n      }\n      if (hasPermission) {\n        replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "listPathBasedCacheDirectives",
            "newValue": "listCacheDirectives"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5473. Consistent naming of user-visible caching classes and methods (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544252 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/11/13 9:12 AM",
          "commitName": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "18/11/13 6:01 PM",
          "commitNameOld": "4f15d0af4f3633bfa35f7cb7c1cc15ef545597d0",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.63,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,49 @@\n-        listPathBasedCacheDirectives(long prevId,\n-            PathBasedCacheDirective filter,\n+        listCacheDirectives(long prevId,\n+            CacheDirectiveInfo filter,\n             FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     String filterPath \u003d null;\n     if (filter.getId() !\u003d null) {\n       throw new IOException(\"Filtering by ID is unsupported.\");\n     }\n     if (filter.getPath() !\u003d null) {\n       filterPath \u003d validatePath(filter);\n     }\n     if (filter.getReplication() !\u003d null) {\n       throw new IOException(\"Filtering by replication is unsupported.\");\n     }\n-    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n-        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n+        new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n+    SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n       entriesById.tailMap(prevId + 1);\n-    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n+    for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n-        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n+        return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n       }\n-      PathBasedCacheEntry curEntry \u003d cur.getValue();\n-      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n+      CacheDirective curEntry \u003d cur.getValue();\n+      CacheDirectiveInfo info \u003d cur.getValue().toDirective();\n       if (filter.getPool() !\u003d null \u0026\u0026 \n-          !directive.getPool().equals(filter.getPool())) {\n+          !info.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n-          !directive.getPath().toUri().getPath().equals(filterPath)) {\n+          !info.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n       boolean hasPermission \u003d true;\n       if (pc !\u003d null) {\n         try {\n           pc.checkPermission(curEntry.getPool(), FsAction.READ);\n         } catch (AccessControlException e) {\n           hasPermission \u003d false;\n         }\n       }\n       if (hasPermission) {\n-        replies.add(cur.getValue().toDirective());\n+        replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n+    return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listCacheDirectives(long prevId,\n            CacheDirectiveInfo filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"Filtering by ID is unsupported.\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d validatePath(filter);\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"Filtering by replication is unsupported.\");\n    }\n    ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n        new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n      entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n      }\n      CacheDirective curEntry \u003d cur.getValue();\n      CacheDirectiveInfo info \u003d cur.getValue().toDirective();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !info.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !info.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      boolean hasPermission \u003d true;\n      if (pc !\u003d null) {\n        try {\n          pc.checkPermission(curEntry.getPool(), FsAction.READ);\n        } catch (AccessControlException e) {\n          hasPermission \u003d false;\n        }\n      }\n      if (hasPermission) {\n        replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[prevId-long, filter-PathBasedCacheDirective, pc-FSPermissionChecker]",
            "newValue": "[prevId-long, filter-CacheDirectiveInfo, pc-FSPermissionChecker]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5473. Consistent naming of user-visible caching classes and methods (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544252 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/11/13 9:12 AM",
          "commitName": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "18/11/13 6:01 PM",
          "commitNameOld": "4f15d0af4f3633bfa35f7cb7c1cc15ef545597d0",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.63,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,49 @@\n-        listPathBasedCacheDirectives(long prevId,\n-            PathBasedCacheDirective filter,\n+        listCacheDirectives(long prevId,\n+            CacheDirectiveInfo filter,\n             FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     String filterPath \u003d null;\n     if (filter.getId() !\u003d null) {\n       throw new IOException(\"Filtering by ID is unsupported.\");\n     }\n     if (filter.getPath() !\u003d null) {\n       filterPath \u003d validatePath(filter);\n     }\n     if (filter.getReplication() !\u003d null) {\n       throw new IOException(\"Filtering by replication is unsupported.\");\n     }\n-    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n-        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n+        new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n+    SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n       entriesById.tailMap(prevId + 1);\n-    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n+    for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n-        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n+        return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n       }\n-      PathBasedCacheEntry curEntry \u003d cur.getValue();\n-      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n+      CacheDirective curEntry \u003d cur.getValue();\n+      CacheDirectiveInfo info \u003d cur.getValue().toDirective();\n       if (filter.getPool() !\u003d null \u0026\u0026 \n-          !directive.getPool().equals(filter.getPool())) {\n+          !info.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n-          !directive.getPath().toUri().getPath().equals(filterPath)) {\n+          !info.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n       boolean hasPermission \u003d true;\n       if (pc !\u003d null) {\n         try {\n           pc.checkPermission(curEntry.getPool(), FsAction.READ);\n         } catch (AccessControlException e) {\n           hasPermission \u003d false;\n         }\n       }\n       if (hasPermission) {\n-        replies.add(cur.getValue().toDirective());\n+        replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n+    return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listCacheDirectives(long prevId,\n            CacheDirectiveInfo filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"Filtering by ID is unsupported.\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d validatePath(filter);\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"Filtering by replication is unsupported.\");\n    }\n    ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n        new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n      entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n      }\n      CacheDirective curEntry \u003d cur.getValue();\n      CacheDirectiveInfo info \u003d cur.getValue().toDirective();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !info.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !info.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      boolean hasPermission \u003d true;\n      if (pc !\u003d null) {\n        try {\n          pc.checkPermission(curEntry.getPool(), FsAction.READ);\n        } catch (AccessControlException e) {\n          hasPermission \u003d false;\n        }\n      }\n      if (hasPermission) {\n        replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "BatchedListEntries\u003cPathBasedCacheDirective\u003e",
            "newValue": "BatchedListEntries\u003cCacheDirectiveEntry\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5473. Consistent naming of user-visible caching classes and methods (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1544252 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/11/13 9:12 AM",
          "commitName": "f91a45a96c21db9e5d40097c7d3f5d005ae10dde",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "18/11/13 6:01 PM",
          "commitNameOld": "4f15d0af4f3633bfa35f7cb7c1cc15ef545597d0",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.63,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,49 @@\n-        listPathBasedCacheDirectives(long prevId,\n-            PathBasedCacheDirective filter,\n+        listCacheDirectives(long prevId,\n+            CacheDirectiveInfo filter,\n             FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     String filterPath \u003d null;\n     if (filter.getId() !\u003d null) {\n       throw new IOException(\"Filtering by ID is unsupported.\");\n     }\n     if (filter.getPath() !\u003d null) {\n       filterPath \u003d validatePath(filter);\n     }\n     if (filter.getReplication() !\u003d null) {\n       throw new IOException(\"Filtering by replication is unsupported.\");\n     }\n-    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n-        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n+        new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n+    SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n       entriesById.tailMap(prevId + 1);\n-    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n+    for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n-        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n+        return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n       }\n-      PathBasedCacheEntry curEntry \u003d cur.getValue();\n-      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n+      CacheDirective curEntry \u003d cur.getValue();\n+      CacheDirectiveInfo info \u003d cur.getValue().toDirective();\n       if (filter.getPool() !\u003d null \u0026\u0026 \n-          !directive.getPool().equals(filter.getPool())) {\n+          !info.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n-          !directive.getPath().toUri().getPath().equals(filterPath)) {\n+          !info.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n       boolean hasPermission \u003d true;\n       if (pc !\u003d null) {\n         try {\n           pc.checkPermission(curEntry.getPool(), FsAction.READ);\n         } catch (AccessControlException e) {\n           hasPermission \u003d false;\n         }\n       }\n       if (hasPermission) {\n-        replies.add(cur.getValue().toDirective());\n+        replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n+    return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listCacheDirectives(long prevId,\n            CacheDirectiveInfo filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"Filtering by ID is unsupported.\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d validatePath(filter);\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"Filtering by replication is unsupported.\");\n    }\n    ArrayList\u003cCacheDirectiveEntry\u003e replies \u003d\n        new ArrayList\u003cCacheDirectiveEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, CacheDirective\u003e tailMap \u003d\n      entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, CacheDirective\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, true);\n      }\n      CacheDirective curEntry \u003d cur.getValue();\n      CacheDirectiveInfo info \u003d cur.getValue().toDirective();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !info.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !info.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      boolean hasPermission \u003d true;\n      if (pc !\u003d null) {\n        try {\n          pc.checkPermission(curEntry.getPool(), FsAction.READ);\n        } catch (AccessControlException e) {\n          hasPermission \u003d false;\n        }\n      }\n      if (hasPermission) {\n        replies.add(new CacheDirectiveEntry(info, cur.getValue().toStats()));\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cCacheDirectiveEntry\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "e3d7ef36ef7dd31b295b1f1d86a1bfa7887ca771": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5372. In FSNamesystem, hasReadLock() returns false if the current thread holds the write lock (Contributed by Vinay)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1542887 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/11/13 8:18 PM",
      "commitName": "e3d7ef36ef7dd31b295b1f1d86a1bfa7887ca771",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "12/11/13 3:52 PM",
      "commitNameOld": "ce35e0950cef9250ce2ceffb3b8bfcff533c6b92",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 5.18,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n         listPathBasedCacheDirectives(long prevId,\n             PathBasedCacheDirective filter,\n             FSPermissionChecker pc) throws IOException {\n-    assert namesystem.hasReadOrWriteLock();\n+    assert namesystem.hasReadLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     String filterPath \u003d null;\n     if (filter.getId() !\u003d null) {\n       throw new IOException(\"Filtering by ID is unsupported.\");\n     }\n     if (filter.getPath() !\u003d null) {\n       filterPath \u003d validatePath(filter);\n     }\n     if (filter.getReplication() !\u003d null) {\n       throw new IOException(\"Filtering by replication is unsupported.\");\n     }\n     ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n         new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n       entriesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n         return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n       }\n       PathBasedCacheEntry curEntry \u003d cur.getValue();\n       PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n       if (filter.getPool() !\u003d null \u0026\u0026 \n           !directive.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !directive.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n       boolean hasPermission \u003d true;\n       if (pc !\u003d null) {\n         try {\n           pc.checkPermission(curEntry.getPool(), FsAction.READ);\n         } catch (AccessControlException e) {\n           hasPermission \u003d false;\n         }\n       }\n       if (hasPermission) {\n         replies.add(cur.getValue().toDirective());\n         numReplies++;\n       }\n     }\n     return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "        listPathBasedCacheDirectives(long prevId,\n            PathBasedCacheDirective filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"Filtering by ID is unsupported.\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d validatePath(filter);\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"Filtering by replication is unsupported.\");\n    }\n    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n      entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      boolean hasPermission \u003d true;\n      if (pc !\u003d null) {\n        try {\n          pc.checkPermission(curEntry.getPool(), FsAction.READ);\n        } catch (AccessControlException e) {\n          hasPermission \u003d false;\n        }\n      }\n      if (hasPermission) {\n        replies.add(cur.getValue().toDirective());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "ce35e0950cef9250ce2ceffb3b8bfcff533c6b92": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5471. CacheAdmin -listPools fails when user lacks permissions to view all pools (Andrew Wang via Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1541323 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/11/13 3:52 PM",
      "commitName": "ce35e0950cef9250ce2ceffb3b8bfcff533c6b92",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "07/11/13 2:07 PM",
      "commitNameOld": "f79b3e6b17450e9d34c483046b7437b09dd72016",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 5.07,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,49 @@\n         listPathBasedCacheDirectives(long prevId,\n             PathBasedCacheDirective filter,\n             FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadOrWriteLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     String filterPath \u003d null;\n     if (filter.getId() !\u003d null) {\n-      throw new IOException(\"we currently don\u0027t support filtering by ID\");\n+      throw new IOException(\"Filtering by ID is unsupported.\");\n     }\n     if (filter.getPath() !\u003d null) {\n-      filterPath \u003d filter.getPath().toUri().getPath();\n-      if (!DFSUtil.isValidName(filterPath)) {\n-        throw new IOException(\"listPathBasedCacheDirectives: invalid \" +\n-            \"path name \u0027\" + filterPath + \"\u0027\");\n-      }\n+      filterPath \u003d validatePath(filter);\n     }\n     if (filter.getReplication() !\u003d null) {\n-      throw new IOException(\"we currently don\u0027t support filtering \" +\n-          \"by replication\");\n+      throw new IOException(\"Filtering by replication is unsupported.\");\n     }\n     ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n         new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n       entriesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n         return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n       }\n       PathBasedCacheEntry curEntry \u003d cur.getValue();\n       PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n       if (filter.getPool() !\u003d null \u0026\u0026 \n           !directive.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !directive.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n-      if ((pc \u003d\u003d null) ||\n-          (pc.checkPermission(curEntry.getPool(), FsAction.READ))) {\n+      boolean hasPermission \u003d true;\n+      if (pc !\u003d null) {\n+        try {\n+          pc.checkPermission(curEntry.getPool(), FsAction.READ);\n+        } catch (AccessControlException e) {\n+          hasPermission \u003d false;\n+        }\n+      }\n+      if (hasPermission) {\n         replies.add(cur.getValue().toDirective());\n         numReplies++;\n       }\n     }\n     return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "        listPathBasedCacheDirectives(long prevId,\n            PathBasedCacheDirective filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadOrWriteLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"Filtering by ID is unsupported.\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d validatePath(filter);\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"Filtering by replication is unsupported.\");\n    }\n    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n      entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      boolean hasPermission \u003d true;\n      if (pc !\u003d null) {\n        try {\n          pc.checkPermission(curEntry.getPool(), FsAction.READ);\n        } catch (AccessControlException e) {\n          hasPermission \u003d false;\n        }\n      }\n      if (hasPermission) {\n        replies.add(cur.getValue().toDirective());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "f79b3e6b17450e9d34c483046b7437b09dd72016": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-5326. add modifyDirective to cacheAdmin (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539839 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/11/13 2:07 PM",
      "commitName": "f79b3e6b17450e9d34c483046b7437b09dd72016",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-5326. add modifyDirective to cacheAdmin (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539839 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/11/13 2:07 PM",
          "commitName": "f79b3e6b17450e9d34c483046b7437b09dd72016",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "21/10/13 12:29 PM",
          "commitNameOld": "f9c08d02ebe4a5477cf5d753f0d9d48fc6f9fa48",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 17.11,
          "commitsBetweenForRepo": 76,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,47 @@\n-        listPathBasedCacheDescriptors(long prevId, String filterPool,\n-            String filterPath, FSPermissionChecker pc) throws IOException {\n+        listPathBasedCacheDirectives(long prevId,\n+            PathBasedCacheDirective filter,\n+            FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadOrWriteLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    if (filterPath !\u003d null) {\n+    String filterPath \u003d null;\n+    if (filter.getId() !\u003d null) {\n+      throw new IOException(\"we currently don\u0027t support filtering by ID\");\n+    }\n+    if (filter.getPath() !\u003d null) {\n+      filterPath \u003d filter.getPath().toUri().getPath();\n       if (!DFSUtil.isValidName(filterPath)) {\n-        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n+        throw new IOException(\"listPathBasedCacheDirectives: invalid \" +\n+            \"path name \u0027\" + filterPath + \"\u0027\");\n       }\n     }\n-    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n-        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    if (filter.getReplication() !\u003d null) {\n+      throw new IOException(\"we currently don\u0027t support filtering \" +\n+          \"by replication\");\n+    }\n+    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n+        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n+    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n+      entriesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n-      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n-        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n+      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n+        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n       }\n       PathBasedCacheEntry curEntry \u003d cur.getValue();\n-      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n-      if (filterPool !\u003d null \u0026\u0026 \n-          !directive.getPool().equals(filterPool)) {\n+      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n+      if (filter.getPool() !\u003d null \u0026\u0026 \n+          !directive.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !directive.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n-      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n-        replies.add(cur.getValue().getDescriptor());\n+      if ((pc \u003d\u003d null) ||\n+          (pc.checkPermission(curEntry.getPool(), FsAction.READ))) {\n+        replies.add(cur.getValue().toDirective());\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n+    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheDirectives(long prevId,\n            PathBasedCacheDirective filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadOrWriteLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"we currently don\u0027t support filtering by ID\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d filter.getPath().toUri().getPath();\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"listPathBasedCacheDirectives: invalid \" +\n            \"path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"we currently don\u0027t support filtering \" +\n          \"by replication\");\n    }\n    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n      entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      if ((pc \u003d\u003d null) ||\n          (pc.checkPermission(curEntry.getPool(), FsAction.READ))) {\n        replies.add(cur.getValue().toDirective());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "listPathBasedCacheDescriptors",
            "newValue": "listPathBasedCacheDirectives"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5326. add modifyDirective to cacheAdmin (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539839 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/11/13 2:07 PM",
          "commitName": "f79b3e6b17450e9d34c483046b7437b09dd72016",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "21/10/13 12:29 PM",
          "commitNameOld": "f9c08d02ebe4a5477cf5d753f0d9d48fc6f9fa48",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 17.11,
          "commitsBetweenForRepo": 76,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,47 @@\n-        listPathBasedCacheDescriptors(long prevId, String filterPool,\n-            String filterPath, FSPermissionChecker pc) throws IOException {\n+        listPathBasedCacheDirectives(long prevId,\n+            PathBasedCacheDirective filter,\n+            FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadOrWriteLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    if (filterPath !\u003d null) {\n+    String filterPath \u003d null;\n+    if (filter.getId() !\u003d null) {\n+      throw new IOException(\"we currently don\u0027t support filtering by ID\");\n+    }\n+    if (filter.getPath() !\u003d null) {\n+      filterPath \u003d filter.getPath().toUri().getPath();\n       if (!DFSUtil.isValidName(filterPath)) {\n-        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n+        throw new IOException(\"listPathBasedCacheDirectives: invalid \" +\n+            \"path name \u0027\" + filterPath + \"\u0027\");\n       }\n     }\n-    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n-        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    if (filter.getReplication() !\u003d null) {\n+      throw new IOException(\"we currently don\u0027t support filtering \" +\n+          \"by replication\");\n+    }\n+    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n+        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n+    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n+      entriesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n-      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n-        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n+      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n+        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n       }\n       PathBasedCacheEntry curEntry \u003d cur.getValue();\n-      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n-      if (filterPool !\u003d null \u0026\u0026 \n-          !directive.getPool().equals(filterPool)) {\n+      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n+      if (filter.getPool() !\u003d null \u0026\u0026 \n+          !directive.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !directive.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n-      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n-        replies.add(cur.getValue().getDescriptor());\n+      if ((pc \u003d\u003d null) ||\n+          (pc.checkPermission(curEntry.getPool(), FsAction.READ))) {\n+        replies.add(cur.getValue().toDirective());\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n+    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheDirectives(long prevId,\n            PathBasedCacheDirective filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadOrWriteLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"we currently don\u0027t support filtering by ID\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d filter.getPath().toUri().getPath();\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"listPathBasedCacheDirectives: invalid \" +\n            \"path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"we currently don\u0027t support filtering \" +\n          \"by replication\");\n    }\n    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n      entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      if ((pc \u003d\u003d null) ||\n          (pc.checkPermission(curEntry.getPool(), FsAction.READ))) {\n        replies.add(cur.getValue().toDirective());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[prevId-long, filterPool-String, filterPath-String, pc-FSPermissionChecker]",
            "newValue": "[prevId-long, filter-PathBasedCacheDirective, pc-FSPermissionChecker]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5326. add modifyDirective to cacheAdmin (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539839 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/11/13 2:07 PM",
          "commitName": "f79b3e6b17450e9d34c483046b7437b09dd72016",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "21/10/13 12:29 PM",
          "commitNameOld": "f9c08d02ebe4a5477cf5d753f0d9d48fc6f9fa48",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 17.11,
          "commitsBetweenForRepo": 76,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,47 @@\n-        listPathBasedCacheDescriptors(long prevId, String filterPool,\n-            String filterPath, FSPermissionChecker pc) throws IOException {\n+        listPathBasedCacheDirectives(long prevId,\n+            PathBasedCacheDirective filter,\n+            FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadOrWriteLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    if (filterPath !\u003d null) {\n+    String filterPath \u003d null;\n+    if (filter.getId() !\u003d null) {\n+      throw new IOException(\"we currently don\u0027t support filtering by ID\");\n+    }\n+    if (filter.getPath() !\u003d null) {\n+      filterPath \u003d filter.getPath().toUri().getPath();\n       if (!DFSUtil.isValidName(filterPath)) {\n-        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n+        throw new IOException(\"listPathBasedCacheDirectives: invalid \" +\n+            \"path name \u0027\" + filterPath + \"\u0027\");\n       }\n     }\n-    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n-        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    if (filter.getReplication() !\u003d null) {\n+      throw new IOException(\"we currently don\u0027t support filtering \" +\n+          \"by replication\");\n+    }\n+    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n+        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n+    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n+      entriesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n-      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n-        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n+      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n+        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n       }\n       PathBasedCacheEntry curEntry \u003d cur.getValue();\n-      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n-      if (filterPool !\u003d null \u0026\u0026 \n-          !directive.getPool().equals(filterPool)) {\n+      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n+      if (filter.getPool() !\u003d null \u0026\u0026 \n+          !directive.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !directive.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n-      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n-        replies.add(cur.getValue().getDescriptor());\n+      if ((pc \u003d\u003d null) ||\n+          (pc.checkPermission(curEntry.getPool(), FsAction.READ))) {\n+        replies.add(cur.getValue().toDirective());\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n+    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheDirectives(long prevId,\n            PathBasedCacheDirective filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadOrWriteLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"we currently don\u0027t support filtering by ID\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d filter.getPath().toUri().getPath();\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"listPathBasedCacheDirectives: invalid \" +\n            \"path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"we currently don\u0027t support filtering \" +\n          \"by replication\");\n    }\n    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n      entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      if ((pc \u003d\u003d null) ||\n          (pc.checkPermission(curEntry.getPool(), FsAction.READ))) {\n        replies.add(cur.getValue().toDirective());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "BatchedListEntries\u003cPathBasedCacheDescriptor\u003e",
            "newValue": "BatchedListEntries\u003cPathBasedCacheDirective\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5326. add modifyDirective to cacheAdmin (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539839 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/11/13 2:07 PM",
          "commitName": "f79b3e6b17450e9d34c483046b7437b09dd72016",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "21/10/13 12:29 PM",
          "commitNameOld": "f9c08d02ebe4a5477cf5d753f0d9d48fc6f9fa48",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 17.11,
          "commitsBetweenForRepo": 76,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,47 @@\n-        listPathBasedCacheDescriptors(long prevId, String filterPool,\n-            String filterPath, FSPermissionChecker pc) throws IOException {\n+        listPathBasedCacheDirectives(long prevId,\n+            PathBasedCacheDirective filter,\n+            FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadOrWriteLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    if (filterPath !\u003d null) {\n+    String filterPath \u003d null;\n+    if (filter.getId() !\u003d null) {\n+      throw new IOException(\"we currently don\u0027t support filtering by ID\");\n+    }\n+    if (filter.getPath() !\u003d null) {\n+      filterPath \u003d filter.getPath().toUri().getPath();\n       if (!DFSUtil.isValidName(filterPath)) {\n-        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n+        throw new IOException(\"listPathBasedCacheDirectives: invalid \" +\n+            \"path name \u0027\" + filterPath + \"\u0027\");\n       }\n     }\n-    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n-        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    if (filter.getReplication() !\u003d null) {\n+      throw new IOException(\"we currently don\u0027t support filtering \" +\n+          \"by replication\");\n+    }\n+    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n+        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n+    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n+      entriesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n-      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n-        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n+      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n+        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n       }\n       PathBasedCacheEntry curEntry \u003d cur.getValue();\n-      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n-      if (filterPool !\u003d null \u0026\u0026 \n-          !directive.getPool().equals(filterPool)) {\n+      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n+      if (filter.getPool() !\u003d null \u0026\u0026 \n+          !directive.getPool().equals(filter.getPool())) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !directive.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n-      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n-        replies.add(cur.getValue().getDescriptor());\n+      if ((pc \u003d\u003d null) ||\n+          (pc.checkPermission(curEntry.getPool(), FsAction.READ))) {\n+        replies.add(cur.getValue().toDirective());\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n+    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheDirectives(long prevId,\n            PathBasedCacheDirective filter,\n            FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadOrWriteLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    String filterPath \u003d null;\n    if (filter.getId() !\u003d null) {\n      throw new IOException(\"we currently don\u0027t support filtering by ID\");\n    }\n    if (filter.getPath() !\u003d null) {\n      filterPath \u003d filter.getPath().toUri().getPath();\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"listPathBasedCacheDirectives: invalid \" +\n            \"path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    if (filter.getReplication() !\u003d null) {\n      throw new IOException(\"we currently don\u0027t support filtering \" +\n          \"by replication\");\n    }\n    ArrayList\u003cPathBasedCacheDirective\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheDirective\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d\n      entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesNumResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().toDirective();\n      if (filter.getPool() !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filter.getPool())) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      if ((pc \u003d\u003d null) ||\n          (pc.checkPermission(curEntry.getPool(), FsAction.READ))) {\n        replies.add(cur.getValue().toDirective());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheDirective\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "d61af9781086073152113d97106f708ea1cf6e8c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5203. Concurrent clients that add a cache directive on the same path may prematurely uncache each other.  (Chris Nauroth via Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1533651 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/10/13 3:15 PM",
      "commitName": "d61af9781086073152113d97106f708ea1cf6e8c",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "18/10/13 1:20 PM",
      "commitNameOld": "1d96e3601312d771270567482cb0a051be786a21",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n         listPathBasedCacheDescriptors(long prevId, String filterPool,\n             String filterPath, FSPermissionChecker pc) throws IOException {\n     assert namesystem.hasReadOrWriteLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     if (filterPath !\u003d null) {\n       if (!DFSUtil.isValidName(filterPath)) {\n         throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n       }\n     }\n     ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n         new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n         return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n       }\n       PathBasedCacheEntry curEntry \u003d cur.getValue();\n       PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n       if (filterPool !\u003d null \u0026\u0026 \n           !directive.getPool().equals(filterPool)) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n-          !directive.getPath().equals(filterPath)) {\n+          !directive.getPath().toUri().getPath().equals(filterPath)) {\n         continue;\n       }\n       if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n         replies.add(cur.getValue().getDescriptor());\n         numReplies++;\n       }\n     }\n     return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "        listPathBasedCacheDescriptors(long prevId, String filterPool,\n            String filterPath, FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadOrWriteLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    if (filterPath !\u003d null) {\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n      if (filterPool !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filterPool)) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().toUri().getPath().equals(filterPath)) {\n        continue;\n      }\n      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n        replies.add(cur.getValue().getDescriptor());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
      "extendedDetails": {}
    },
    "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-5096. Automatically cache new data added to a cached path (contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1532924 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/10/13 3:15 PM",
      "commitName": "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-5096. Automatically cache new data added to a cached path (contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1532924 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/10/13 3:15 PM",
          "commitName": "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "14/10/13 3:56 PM",
          "commitNameOld": "efe545b0c219eeba61ac5259aee4d518beb74316",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 1.97,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,34 @@\n         listPathBasedCacheDescriptors(long prevId, String filterPool,\n             String filterPath, FSPermissionChecker pc) throws IOException {\n+    assert namesystem.hasReadOrWriteLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     if (filterPath !\u003d null) {\n       if (!DFSUtil.isValidName(filterPath)) {\n         throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n       }\n     }\n     ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n         new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n         return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n       }\n       PathBasedCacheEntry curEntry \u003d cur.getValue();\n       PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n       if (filterPool !\u003d null \u0026\u0026 \n           !directive.getPool().equals(filterPool)) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !directive.getPath().equals(filterPath)) {\n         continue;\n       }\n       if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n         replies.add(cur.getValue().getDescriptor());\n         numReplies++;\n       }\n     }\n     return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheDescriptors(long prevId, String filterPool,\n            String filterPath, FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadOrWriteLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    if (filterPath !\u003d null) {\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n      if (filterPool !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filterPool)) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().equals(filterPath)) {\n        continue;\n      }\n      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n        replies.add(cur.getValue().getDescriptor());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5096. Automatically cache new data added to a cached path (contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1532924 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/10/13 3:15 PM",
          "commitName": "3cc7a38a53c8ae27ef6b2397cddc5d14a378203a",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "14/10/13 3:56 PM",
          "commitNameOld": "efe545b0c219eeba61ac5259aee4d518beb74316",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 1.97,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,34 @@\n         listPathBasedCacheDescriptors(long prevId, String filterPool,\n             String filterPath, FSPermissionChecker pc) throws IOException {\n+    assert namesystem.hasReadOrWriteLock();\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     if (filterPath !\u003d null) {\n       if (!DFSUtil.isValidName(filterPath)) {\n         throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n       }\n     }\n     ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n         new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n       if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n         return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n       }\n       PathBasedCacheEntry curEntry \u003d cur.getValue();\n       PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n       if (filterPool !\u003d null \u0026\u0026 \n           !directive.getPool().equals(filterPool)) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !directive.getPath().equals(filterPath)) {\n         continue;\n       }\n       if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n         replies.add(cur.getValue().getDescriptor());\n         numReplies++;\n       }\n     }\n     return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheDescriptors(long prevId, String filterPool,\n            String filterPath, FSPermissionChecker pc) throws IOException {\n    assert namesystem.hasReadOrWriteLock();\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    if (filterPath !\u003d null) {\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n      if (filterPool !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filterPool)) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().equals(filterPath)) {\n        continue;\n      }\n      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n        replies.add(cur.getValue().getDescriptor());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04": {
      "type": "Ymultichange(Yrename,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-5213. Separate PathBasedCacheEntry and PathBasedCacheDirectiveWithId. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1524561 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/09/13 1:43 PM",
      "commitName": "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-5213. Separate PathBasedCacheEntry and PathBasedCacheDirectiveWithId. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1524561 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/09/13 1:43 PM",
          "commitName": "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "16/09/13 11:41 AM",
          "commitNameOld": "85c203602993a946fb5f41eadf1cf1484a0ce686",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,33 @@\n-        listPathBasedCacheEntries(long prevId, String filterPool,\n+        listPathBasedCacheDescriptors(long prevId, String filterPool,\n             String filterPath, FSPermissionChecker pc) throws IOException {\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     if (filterPath !\u003d null) {\n       if (!DFSUtil.isValidName(filterPath)) {\n         throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n       }\n     }\n-    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n-        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n+        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n-      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n-        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n+      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n+        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n       }\n       PathBasedCacheEntry curEntry \u003d cur.getValue();\n-      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n+      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n       if (filterPool !\u003d null \u0026\u0026 \n           !directive.getPool().equals(filterPool)) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !directive.getPath().equals(filterPath)) {\n         continue;\n       }\n-      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n-      if (pool \u003d\u003d null) {\n-        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n-        continue;\n-      }\n-      if (pc.checkPermission(pool, FsAction.READ)) {\n-        replies.add(cur.getValue());\n+      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n+        replies.add(cur.getValue().getDescriptor());\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n+    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheDescriptors(long prevId, String filterPool,\n            String filterPath, FSPermissionChecker pc) throws IOException {\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    if (filterPath !\u003d null) {\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n      if (filterPool !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filterPool)) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().equals(filterPath)) {\n        continue;\n      }\n      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n        replies.add(cur.getValue().getDescriptor());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "listPathBasedCacheEntries",
            "newValue": "listPathBasedCacheDescriptors"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5213. Separate PathBasedCacheEntry and PathBasedCacheDirectiveWithId. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1524561 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/09/13 1:43 PM",
          "commitName": "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "16/09/13 11:41 AM",
          "commitNameOld": "85c203602993a946fb5f41eadf1cf1484a0ce686",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,33 @@\n-        listPathBasedCacheEntries(long prevId, String filterPool,\n+        listPathBasedCacheDescriptors(long prevId, String filterPool,\n             String filterPath, FSPermissionChecker pc) throws IOException {\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     if (filterPath !\u003d null) {\n       if (!DFSUtil.isValidName(filterPath)) {\n         throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n       }\n     }\n-    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n-        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n+        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n-      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n-        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n+      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n+        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n       }\n       PathBasedCacheEntry curEntry \u003d cur.getValue();\n-      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n+      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n       if (filterPool !\u003d null \u0026\u0026 \n           !directive.getPool().equals(filterPool)) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !directive.getPath().equals(filterPath)) {\n         continue;\n       }\n-      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n-      if (pool \u003d\u003d null) {\n-        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n-        continue;\n-      }\n-      if (pc.checkPermission(pool, FsAction.READ)) {\n-        replies.add(cur.getValue());\n+      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n+        replies.add(cur.getValue().getDescriptor());\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n+    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheDescriptors(long prevId, String filterPool,\n            String filterPath, FSPermissionChecker pc) throws IOException {\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    if (filterPath !\u003d null) {\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n      if (filterPool !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filterPool)) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().equals(filterPath)) {\n        continue;\n      }\n      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n        replies.add(cur.getValue().getDescriptor());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "BatchedListEntries\u003cPathBasedCacheEntry\u003e",
            "newValue": "BatchedListEntries\u003cPathBasedCacheDescriptor\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5213. Separate PathBasedCacheEntry and PathBasedCacheDirectiveWithId. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1524561 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/09/13 1:43 PM",
          "commitName": "e202d4d1548a0be2f5c61ff82be8b52bd0cfce04",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "16/09/13 11:41 AM",
          "commitNameOld": "85c203602993a946fb5f41eadf1cf1484a0ce686",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,33 @@\n-        listPathBasedCacheEntries(long prevId, String filterPool,\n+        listPathBasedCacheDescriptors(long prevId, String filterPool,\n             String filterPath, FSPermissionChecker pc) throws IOException {\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n     if (filterPath !\u003d null) {\n       if (!DFSUtil.isValidName(filterPath)) {\n         throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n       }\n     }\n-    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n-        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n+        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n     for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n-      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n-        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n+      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n+        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n       }\n       PathBasedCacheEntry curEntry \u003d cur.getValue();\n-      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n+      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n       if (filterPool !\u003d null \u0026\u0026 \n           !directive.getPool().equals(filterPool)) {\n         continue;\n       }\n       if (filterPath !\u003d null \u0026\u0026\n           !directive.getPath().equals(filterPath)) {\n         continue;\n       }\n-      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n-      if (pool \u003d\u003d null) {\n-        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n-        continue;\n-      }\n-      if (pc.checkPermission(pool, FsAction.READ)) {\n-        replies.add(cur.getValue());\n+      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n+        replies.add(cur.getValue().getDescriptor());\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n+    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheDescriptors(long prevId, String filterPool,\n            String filterPath, FSPermissionChecker pc) throws IOException {\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    if (filterPath !\u003d null) {\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    ArrayList\u003cPathBasedCacheDescriptor\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheDescriptor\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDescriptorsResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().getDescriptor();\n      if (filterPool !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filterPool)) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().equals(filterPath)) {\n        continue;\n      }\n      if (pc.checkPermission(curEntry.getPool(), FsAction.READ)) {\n        replies.add(cur.getValue().getDescriptor());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheDescriptor\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "02e0e158a26f81ce8375426ba0ea56db09ee36be": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-5158. Add command-line support for manipulating cache directives\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1522272 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/09/13 8:55 PM",
      "commitName": "02e0e158a26f81ce8375426ba0ea56db09ee36be",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-5158. Add command-line support for manipulating cache directives\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1522272 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/09/13 8:55 PM",
          "commitName": "02e0e158a26f81ce8375426ba0ea56db09ee36be",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "09/09/13 11:53 AM",
          "commitNameOld": "3a9cd79e9ddd5a9499e28633ccccdc9eef22b813",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,38 @@\n-        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {\n+        listPathBasedCacheEntries(long prevId, String filterPool,\n+            String filterPath, FSPermissionChecker pc) throws IOException {\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n-        new ArrayList\u003cPathCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n-    int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n-    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n-      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n-        return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, true);\n+    if (filterPath !\u003d null) {\n+      if (!DFSUtil.isValidName(filterPath)) {\n+        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n       }\n-      PathCacheEntry curEntry \u003d cur.getValue();\n-      if (!filterPool.isEmpty() \u0026\u0026 \n-          !cur.getValue().getDirective().getPool().equals(filterPool)) {\n+    }\n+    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n+        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    int numReplies \u003d 0;\n+    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n+    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n+      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n+        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n+      }\n+      PathBasedCacheEntry curEntry \u003d cur.getValue();\n+      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n+      if (filterPool !\u003d null \u0026\u0026 \n+          !directive.getPool().equals(filterPool)) {\n+        continue;\n+      }\n+      if (filterPath !\u003d null \u0026\u0026\n+          !directive.getPath().equals(filterPath)) {\n         continue;\n       }\n       CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n       if (pool \u003d\u003d null) {\n-        LOG.error(\"invalid pool for PathCacheEntry \" + curEntry);\n+        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n         continue;\n       }\n-      if (pc.checkPermission(pool, FsAction.EXECUTE)) {\n+      if (pc.checkPermission(pool, FsAction.READ)) {\n         replies.add(cur.getValue());\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, false);\n+    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheEntries(long prevId, String filterPool,\n            String filterPath, FSPermissionChecker pc) throws IOException {\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    if (filterPath !\u003d null) {\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n      if (filterPool !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filterPool)) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().equals(filterPath)) {\n        continue;\n      }\n      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n      if (pool \u003d\u003d null) {\n        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n        continue;\n      }\n      if (pc.checkPermission(pool, FsAction.READ)) {\n        replies.add(cur.getValue());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "listPathCacheEntries",
            "newValue": "listPathBasedCacheEntries"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5158. Add command-line support for manipulating cache directives\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1522272 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/09/13 8:55 PM",
          "commitName": "02e0e158a26f81ce8375426ba0ea56db09ee36be",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "09/09/13 11:53 AM",
          "commitNameOld": "3a9cd79e9ddd5a9499e28633ccccdc9eef22b813",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,38 @@\n-        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {\n+        listPathBasedCacheEntries(long prevId, String filterPool,\n+            String filterPath, FSPermissionChecker pc) throws IOException {\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n-        new ArrayList\u003cPathCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n-    int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n-    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n-      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n-        return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, true);\n+    if (filterPath !\u003d null) {\n+      if (!DFSUtil.isValidName(filterPath)) {\n+        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n       }\n-      PathCacheEntry curEntry \u003d cur.getValue();\n-      if (!filterPool.isEmpty() \u0026\u0026 \n-          !cur.getValue().getDirective().getPool().equals(filterPool)) {\n+    }\n+    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n+        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    int numReplies \u003d 0;\n+    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n+    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n+      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n+        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n+      }\n+      PathBasedCacheEntry curEntry \u003d cur.getValue();\n+      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n+      if (filterPool !\u003d null \u0026\u0026 \n+          !directive.getPool().equals(filterPool)) {\n+        continue;\n+      }\n+      if (filterPath !\u003d null \u0026\u0026\n+          !directive.getPath().equals(filterPath)) {\n         continue;\n       }\n       CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n       if (pool \u003d\u003d null) {\n-        LOG.error(\"invalid pool for PathCacheEntry \" + curEntry);\n+        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n         continue;\n       }\n-      if (pc.checkPermission(pool, FsAction.EXECUTE)) {\n+      if (pc.checkPermission(pool, FsAction.READ)) {\n         replies.add(cur.getValue());\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, false);\n+    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheEntries(long prevId, String filterPool,\n            String filterPath, FSPermissionChecker pc) throws IOException {\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    if (filterPath !\u003d null) {\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n      if (filterPool !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filterPool)) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().equals(filterPath)) {\n        continue;\n      }\n      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n      if (pool \u003d\u003d null) {\n        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n        continue;\n      }\n      if (pc.checkPermission(pool, FsAction.READ)) {\n        replies.add(cur.getValue());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[prevId-long, filterPool-String, pc-FSPermissionChecker]",
            "newValue": "[prevId-long, filterPool-String, filterPath-String, pc-FSPermissionChecker]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5158. Add command-line support for manipulating cache directives\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1522272 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/09/13 8:55 PM",
          "commitName": "02e0e158a26f81ce8375426ba0ea56db09ee36be",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "09/09/13 11:53 AM",
          "commitNameOld": "3a9cd79e9ddd5a9499e28633ccccdc9eef22b813",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,38 @@\n-        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {\n+        listPathBasedCacheEntries(long prevId, String filterPool,\n+            String filterPath, FSPermissionChecker pc) throws IOException {\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n-        new ArrayList\u003cPathCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n-    int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n-    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n-      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n-        return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, true);\n+    if (filterPath !\u003d null) {\n+      if (!DFSUtil.isValidName(filterPath)) {\n+        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n       }\n-      PathCacheEntry curEntry \u003d cur.getValue();\n-      if (!filterPool.isEmpty() \u0026\u0026 \n-          !cur.getValue().getDirective().getPool().equals(filterPool)) {\n+    }\n+    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n+        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    int numReplies \u003d 0;\n+    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n+    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n+      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n+        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n+      }\n+      PathBasedCacheEntry curEntry \u003d cur.getValue();\n+      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n+      if (filterPool !\u003d null \u0026\u0026 \n+          !directive.getPool().equals(filterPool)) {\n+        continue;\n+      }\n+      if (filterPath !\u003d null \u0026\u0026\n+          !directive.getPath().equals(filterPath)) {\n         continue;\n       }\n       CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n       if (pool \u003d\u003d null) {\n-        LOG.error(\"invalid pool for PathCacheEntry \" + curEntry);\n+        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n         continue;\n       }\n-      if (pc.checkPermission(pool, FsAction.EXECUTE)) {\n+      if (pc.checkPermission(pool, FsAction.READ)) {\n         replies.add(cur.getValue());\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, false);\n+    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheEntries(long prevId, String filterPool,\n            String filterPath, FSPermissionChecker pc) throws IOException {\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    if (filterPath !\u003d null) {\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n      if (filterPool !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filterPool)) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().equals(filterPath)) {\n        continue;\n      }\n      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n      if (pool \u003d\u003d null) {\n        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n        continue;\n      }\n      if (pc.checkPermission(pool, FsAction.READ)) {\n        replies.add(cur.getValue());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "BatchedListEntries\u003cPathCacheEntry\u003e",
            "newValue": "BatchedListEntries\u003cPathBasedCacheEntry\u003e"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-5158. Add command-line support for manipulating cache directives\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1522272 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/09/13 8:55 PM",
          "commitName": "02e0e158a26f81ce8375426ba0ea56db09ee36be",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "09/09/13 11:53 AM",
          "commitNameOld": "3a9cd79e9ddd5a9499e28633ccccdc9eef22b813",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,38 @@\n-        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {\n+        listPathBasedCacheEntries(long prevId, String filterPool,\n+            String filterPath, FSPermissionChecker pc) throws IOException {\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n-        new ArrayList\u003cPathCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n-    int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n-    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n-      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n-        return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, true);\n+    if (filterPath !\u003d null) {\n+      if (!DFSUtil.isValidName(filterPath)) {\n+        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n       }\n-      PathCacheEntry curEntry \u003d cur.getValue();\n-      if (!filterPool.isEmpty() \u0026\u0026 \n-          !cur.getValue().getDirective().getPool().equals(filterPool)) {\n+    }\n+    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n+        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    int numReplies \u003d 0;\n+    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n+    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n+      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n+        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n+      }\n+      PathBasedCacheEntry curEntry \u003d cur.getValue();\n+      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n+      if (filterPool !\u003d null \u0026\u0026 \n+          !directive.getPool().equals(filterPool)) {\n+        continue;\n+      }\n+      if (filterPath !\u003d null \u0026\u0026\n+          !directive.getPath().equals(filterPath)) {\n         continue;\n       }\n       CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n       if (pool \u003d\u003d null) {\n-        LOG.error(\"invalid pool for PathCacheEntry \" + curEntry);\n+        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n         continue;\n       }\n-      if (pc.checkPermission(pool, FsAction.EXECUTE)) {\n+      if (pc.checkPermission(pool, FsAction.READ)) {\n         replies.add(cur.getValue());\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, false);\n+    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheEntries(long prevId, String filterPool,\n            String filterPath, FSPermissionChecker pc) throws IOException {\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    if (filterPath !\u003d null) {\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n      if (filterPool !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filterPool)) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().equals(filterPath)) {\n        continue;\n      }\n      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n      if (pool \u003d\u003d null) {\n        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n        continue;\n      }\n      if (pc.checkPermission(pool, FsAction.READ)) {\n        replies.add(cur.getValue());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5158. Add command-line support for manipulating cache directives\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1522272 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/09/13 8:55 PM",
          "commitName": "02e0e158a26f81ce8375426ba0ea56db09ee36be",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "09/09/13 11:53 AM",
          "commitNameOld": "3a9cd79e9ddd5a9499e28633ccccdc9eef22b813",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,38 @@\n-        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {\n+        listPathBasedCacheEntries(long prevId, String filterPool,\n+            String filterPath, FSPermissionChecker pc) throws IOException {\n     final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n-        new ArrayList\u003cPathCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n-    int numReplies \u003d 0;\n-    SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n-    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n-      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n-        return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, true);\n+    if (filterPath !\u003d null) {\n+      if (!DFSUtil.isValidName(filterPath)) {\n+        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n       }\n-      PathCacheEntry curEntry \u003d cur.getValue();\n-      if (!filterPool.isEmpty() \u0026\u0026 \n-          !cur.getValue().getDirective().getPool().equals(filterPool)) {\n+    }\n+    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n+        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n+    int numReplies \u003d 0;\n+    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n+    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n+      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n+        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n+      }\n+      PathBasedCacheEntry curEntry \u003d cur.getValue();\n+      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n+      if (filterPool !\u003d null \u0026\u0026 \n+          !directive.getPool().equals(filterPool)) {\n+        continue;\n+      }\n+      if (filterPath !\u003d null \u0026\u0026\n+          !directive.getPath().equals(filterPath)) {\n         continue;\n       }\n       CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n       if (pool \u003d\u003d null) {\n-        LOG.error(\"invalid pool for PathCacheEntry \" + curEntry);\n+        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n         continue;\n       }\n-      if (pc.checkPermission(pool, FsAction.EXECUTE)) {\n+      if (pc.checkPermission(pool, FsAction.READ)) {\n         replies.add(cur.getValue());\n         numReplies++;\n       }\n     }\n-    return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, false);\n+    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathBasedCacheEntries(long prevId, String filterPool,\n            String filterPath, FSPermissionChecker pc) throws IOException {\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    if (filterPath !\u003d null) {\n      if (!DFSUtil.isValidName(filterPath)) {\n        throw new IOException(\"invalid path name \u0027\" + filterPath + \"\u0027\");\n      }\n    }\n    ArrayList\u003cPathBasedCacheEntry\u003e replies \u003d\n        new ArrayList\u003cPathBasedCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathBasedCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathBasedCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n        return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, true);\n      }\n      PathBasedCacheEntry curEntry \u003d cur.getValue();\n      PathBasedCacheDirective directive \u003d cur.getValue().getDirective();\n      if (filterPool !\u003d null \u0026\u0026 \n          !directive.getPool().equals(filterPool)) {\n        continue;\n      }\n      if (filterPath !\u003d null \u0026\u0026\n          !directive.getPath().equals(filterPath)) {\n        continue;\n      }\n      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n      if (pool \u003d\u003d null) {\n        LOG.error(\"invalid pool for PathBasedCacheEntry \" + curEntry);\n        continue;\n      }\n      if (pc.checkPermission(pool, FsAction.READ)) {\n        replies.add(cur.getValue());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathBasedCacheEntry\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "f41f8b8842c3f26d19f7fa928070c7c07f760e4c": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-5163. Miscellaneous cache pool RPC fixes (Contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520665 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/13 11:52 AM",
      "commitName": "f41f8b8842c3f26d19f7fa928070c7c07f760e4c",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5163. Miscellaneous cache pool RPC fixes (Contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520665 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/09/13 11:52 AM",
          "commitName": "f41f8b8842c3f26d19f7fa928070c7c07f760e4c",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "04/09/13 11:23 AM",
          "commitNameOld": "d56d0b46e1b82ae068083ddb99872d314684dc82",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,22 +1,27 @@\n-  public synchronized List\u003cPathCacheEntry\u003e listPathCacheEntries(\n-      FSPermissionChecker pc, long prevId, Long poolId, int maxReplies) {\n-    final int MAX_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    ArrayList\u003cPathCacheEntry\u003e replies \u003d new ArrayList\u003cPathCacheEntry\u003e(\n-        Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));\n+        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {\n+    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n+    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n+        new ArrayList\u003cPathCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n-    for (PathCacheEntry entry : tailMap.values()) {\n-      if (numReplies \u003e\u003d maxReplies) {\n-        return replies;\n+    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n+      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n+        return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, true);\n       }\n-      long entryPoolId \u003d entry.getDirective().getPoolId();\n-      if (poolId \u003d\u003d null || poolId \u003c\u003d 0 || entryPoolId \u003d\u003d poolId) {\n-        if (pc.checkPermission(\n-            cachePoolsById.get(entryPoolId), FsAction.EXECUTE)) {\n-          replies.add(entry);\n-          numReplies++;\n-        }\n+      PathCacheEntry curEntry \u003d cur.getValue();\n+      if (!filterPool.isEmpty() \u0026\u0026 \n+          !cur.getValue().getDirective().getPool().equals(filterPool)) {\n+        continue;\n+      }\n+      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n+      if (pool \u003d\u003d null) {\n+        LOG.error(\"invalid pool for PathCacheEntry \" + curEntry);\n+        continue;\n+      }\n+      if (pc.checkPermission(pool, FsAction.EXECUTE)) {\n+        replies.add(cur.getValue());\n+        numReplies++;\n       }\n     }\n-    return replies;\n+    return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n        new ArrayList\u003cPathCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n        return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, true);\n      }\n      PathCacheEntry curEntry \u003d cur.getValue();\n      if (!filterPool.isEmpty() \u0026\u0026 \n          !cur.getValue().getDirective().getPool().equals(filterPool)) {\n        continue;\n      }\n      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n      if (pool \u003d\u003d null) {\n        LOG.error(\"invalid pool for PathCacheEntry \" + curEntry);\n        continue;\n      }\n      if (pc.checkPermission(pool, FsAction.EXECUTE)) {\n        replies.add(cur.getValue());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[pc-FSPermissionChecker, prevId-long, poolId-Long, maxReplies-int]",
            "newValue": "[prevId-long, filterPool-String, pc-FSPermissionChecker]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5163. Miscellaneous cache pool RPC fixes (Contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520665 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/09/13 11:52 AM",
          "commitName": "f41f8b8842c3f26d19f7fa928070c7c07f760e4c",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "04/09/13 11:23 AM",
          "commitNameOld": "d56d0b46e1b82ae068083ddb99872d314684dc82",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,22 +1,27 @@\n-  public synchronized List\u003cPathCacheEntry\u003e listPathCacheEntries(\n-      FSPermissionChecker pc, long prevId, Long poolId, int maxReplies) {\n-    final int MAX_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    ArrayList\u003cPathCacheEntry\u003e replies \u003d new ArrayList\u003cPathCacheEntry\u003e(\n-        Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));\n+        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {\n+    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n+    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n+        new ArrayList\u003cPathCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n-    for (PathCacheEntry entry : tailMap.values()) {\n-      if (numReplies \u003e\u003d maxReplies) {\n-        return replies;\n+    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n+      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n+        return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, true);\n       }\n-      long entryPoolId \u003d entry.getDirective().getPoolId();\n-      if (poolId \u003d\u003d null || poolId \u003c\u003d 0 || entryPoolId \u003d\u003d poolId) {\n-        if (pc.checkPermission(\n-            cachePoolsById.get(entryPoolId), FsAction.EXECUTE)) {\n-          replies.add(entry);\n-          numReplies++;\n-        }\n+      PathCacheEntry curEntry \u003d cur.getValue();\n+      if (!filterPool.isEmpty() \u0026\u0026 \n+          !cur.getValue().getDirective().getPool().equals(filterPool)) {\n+        continue;\n+      }\n+      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n+      if (pool \u003d\u003d null) {\n+        LOG.error(\"invalid pool for PathCacheEntry \" + curEntry);\n+        continue;\n+      }\n+      if (pc.checkPermission(pool, FsAction.EXECUTE)) {\n+        replies.add(cur.getValue());\n+        numReplies++;\n       }\n     }\n-    return replies;\n+    return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n        new ArrayList\u003cPathCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n        return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, true);\n      }\n      PathCacheEntry curEntry \u003d cur.getValue();\n      if (!filterPool.isEmpty() \u0026\u0026 \n          !cur.getValue().getDirective().getPool().equals(filterPool)) {\n        continue;\n      }\n      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n      if (pool \u003d\u003d null) {\n        LOG.error(\"invalid pool for PathCacheEntry \" + curEntry);\n        continue;\n      }\n      if (pc.checkPermission(pool, FsAction.EXECUTE)) {\n        replies.add(cur.getValue());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "List\u003cPathCacheEntry\u003e",
            "newValue": "BatchedListEntries\u003cPathCacheEntry\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5163. Miscellaneous cache pool RPC fixes (Contributed by Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520665 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/09/13 11:52 AM",
          "commitName": "f41f8b8842c3f26d19f7fa928070c7c07f760e4c",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "04/09/13 11:23 AM",
          "commitNameOld": "d56d0b46e1b82ae068083ddb99872d314684dc82",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 2.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,22 +1,27 @@\n-  public synchronized List\u003cPathCacheEntry\u003e listPathCacheEntries(\n-      FSPermissionChecker pc, long prevId, Long poolId, int maxReplies) {\n-    final int MAX_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    ArrayList\u003cPathCacheEntry\u003e replies \u003d new ArrayList\u003cPathCacheEntry\u003e(\n-        Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));\n+        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {\n+    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n+    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n+        new ArrayList\u003cPathCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n-    for (PathCacheEntry entry : tailMap.values()) {\n-      if (numReplies \u003e\u003d maxReplies) {\n-        return replies;\n+    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n+      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n+        return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, true);\n       }\n-      long entryPoolId \u003d entry.getDirective().getPoolId();\n-      if (poolId \u003d\u003d null || poolId \u003c\u003d 0 || entryPoolId \u003d\u003d poolId) {\n-        if (pc.checkPermission(\n-            cachePoolsById.get(entryPoolId), FsAction.EXECUTE)) {\n-          replies.add(entry);\n-          numReplies++;\n-        }\n+      PathCacheEntry curEntry \u003d cur.getValue();\n+      if (!filterPool.isEmpty() \u0026\u0026 \n+          !cur.getValue().getDirective().getPool().equals(filterPool)) {\n+        continue;\n+      }\n+      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n+      if (pool \u003d\u003d null) {\n+        LOG.error(\"invalid pool for PathCacheEntry \" + curEntry);\n+        continue;\n+      }\n+      if (pc.checkPermission(pool, FsAction.EXECUTE)) {\n+        replies.add(cur.getValue());\n+        numReplies++;\n       }\n     }\n-    return replies;\n+    return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "        listPathCacheEntries(long prevId, String filterPool, FSPermissionChecker pc) {\n    final int NUM_PRE_ALLOCATED_ENTRIES \u003d 16;\n    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n        new ArrayList\u003cPathCacheEntry\u003e(NUM_PRE_ALLOCATED_ENTRIES);\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxListCacheDirectivesResponses) {\n        return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, true);\n      }\n      PathCacheEntry curEntry \u003d cur.getValue();\n      if (!filterPool.isEmpty() \u0026\u0026 \n          !cur.getValue().getDirective().getPool().equals(filterPool)) {\n        continue;\n      }\n      CachePool pool \u003d cachePools.get(curEntry.getDirective().getPool());\n      if (pool \u003d\u003d null) {\n        LOG.error(\"invalid pool for PathCacheEntry \" + curEntry);\n        continue;\n      }\n      if (pc.checkPermission(pool, FsAction.EXECUTE)) {\n        replies.add(cur.getValue());\n        numReplies++;\n      }\n    }\n    return new BatchedListEntries\u003cPathCacheEntry\u003e(replies, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "d56d0b46e1b82ae068083ddb99872d314684dc82": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "commit correct version of HDFS-5121\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520090 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/13 11:23 AM",
      "commitName": "d56d0b46e1b82ae068083ddb99872d314684dc82",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "commit correct version of HDFS-5121\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520090 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/09/13 11:23 AM",
          "commitName": "d56d0b46e1b82ae068083ddb99872d314684dc82",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "03/09/13 1:38 PM",
          "commitNameOld": "97b7267977ef42201e5844df49bc37ec3d10ce16",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 0.91,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,22 @@\n-  public synchronized List\u003cPathCacheEntry\u003e listPathCacheEntries(long prevId,\n-      String pool, int maxReplies) {\n+  public synchronized List\u003cPathCacheEntry\u003e listPathCacheEntries(\n+      FSPermissionChecker pc, long prevId, Long poolId, int maxReplies) {\n     final int MAX_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n-        new ArrayList\u003cPathCacheEntry\u003e(Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));\n+    ArrayList\u003cPathCacheEntry\u003e replies \u003d new ArrayList\u003cPathCacheEntry\u003e(\n+        Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n-    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n+    for (PathCacheEntry entry : tailMap.values()) {\n       if (numReplies \u003e\u003d maxReplies) {\n         return replies;\n       }\n-      if (pool.isEmpty() || cur.getValue().getDirective().\n-            getPool().equals(pool)) {\n-        replies.add(cur.getValue());\n-        numReplies++;\n+      long entryPoolId \u003d entry.getDirective().getPoolId();\n+      if (poolId \u003d\u003d null || poolId \u003c\u003d 0 || entryPoolId \u003d\u003d poolId) {\n+        if (pc.checkPermission(\n+            cachePoolsById.get(entryPoolId), FsAction.EXECUTE)) {\n+          replies.add(entry);\n+          numReplies++;\n+        }\n       }\n     }\n     return replies;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized List\u003cPathCacheEntry\u003e listPathCacheEntries(\n      FSPermissionChecker pc, long prevId, Long poolId, int maxReplies) {\n    final int MAX_PRE_ALLOCATED_ENTRIES \u003d 16;\n    ArrayList\u003cPathCacheEntry\u003e replies \u003d new ArrayList\u003cPathCacheEntry\u003e(\n        Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (PathCacheEntry entry : tailMap.values()) {\n      if (numReplies \u003e\u003d maxReplies) {\n        return replies;\n      }\n      long entryPoolId \u003d entry.getDirective().getPoolId();\n      if (poolId \u003d\u003d null || poolId \u003c\u003d 0 || entryPoolId \u003d\u003d poolId) {\n        if (pc.checkPermission(\n            cachePoolsById.get(entryPoolId), FsAction.EXECUTE)) {\n          replies.add(entry);\n          numReplies++;\n        }\n      }\n    }\n    return replies;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {
            "oldValue": "[prevId-long, pool-String, maxReplies-int]",
            "newValue": "[pc-FSPermissionChecker, prevId-long, poolId-Long, maxReplies-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "commit correct version of HDFS-5121\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1520090 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/09/13 11:23 AM",
          "commitName": "d56d0b46e1b82ae068083ddb99872d314684dc82",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "03/09/13 1:38 PM",
          "commitNameOld": "97b7267977ef42201e5844df49bc37ec3d10ce16",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 0.91,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,22 @@\n-  public synchronized List\u003cPathCacheEntry\u003e listPathCacheEntries(long prevId,\n-      String pool, int maxReplies) {\n+  public synchronized List\u003cPathCacheEntry\u003e listPathCacheEntries(\n+      FSPermissionChecker pc, long prevId, Long poolId, int maxReplies) {\n     final int MAX_PRE_ALLOCATED_ENTRIES \u003d 16;\n-    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n-        new ArrayList\u003cPathCacheEntry\u003e(Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));\n+    ArrayList\u003cPathCacheEntry\u003e replies \u003d new ArrayList\u003cPathCacheEntry\u003e(\n+        Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));\n     int numReplies \u003d 0;\n     SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n-    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n+    for (PathCacheEntry entry : tailMap.values()) {\n       if (numReplies \u003e\u003d maxReplies) {\n         return replies;\n       }\n-      if (pool.isEmpty() || cur.getValue().getDirective().\n-            getPool().equals(pool)) {\n-        replies.add(cur.getValue());\n-        numReplies++;\n+      long entryPoolId \u003d entry.getDirective().getPoolId();\n+      if (poolId \u003d\u003d null || poolId \u003c\u003d 0 || entryPoolId \u003d\u003d poolId) {\n+        if (pc.checkPermission(\n+            cachePoolsById.get(entryPoolId), FsAction.EXECUTE)) {\n+          replies.add(entry);\n+          numReplies++;\n+        }\n       }\n     }\n     return replies;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized List\u003cPathCacheEntry\u003e listPathCacheEntries(\n      FSPermissionChecker pc, long prevId, Long poolId, int maxReplies) {\n    final int MAX_PRE_ALLOCATED_ENTRIES \u003d 16;\n    ArrayList\u003cPathCacheEntry\u003e replies \u003d new ArrayList\u003cPathCacheEntry\u003e(\n        Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (PathCacheEntry entry : tailMap.values()) {\n      if (numReplies \u003e\u003d maxReplies) {\n        return replies;\n      }\n      long entryPoolId \u003d entry.getDirective().getPoolId();\n      if (poolId \u003d\u003d null || poolId \u003c\u003d 0 || entryPoolId \u003d\u003d poolId) {\n        if (pc.checkPermission(\n            cachePoolsById.get(entryPoolId), FsAction.EXECUTE)) {\n          replies.add(entry);\n          numReplies++;\n        }\n      }\n    }\n    return replies;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "920b4cc06f1bc15809902bdd1968cc434a694a08": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5052. Add cacheRequest/uncacheRequest support to NameNode.  (Contributed by Colin Patrick McCabe.)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4949@1516669 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/08/13 4:37 PM",
      "commitName": "920b4cc06f1bc15809902bdd1968cc434a694a08",
      "commitAuthor": "Colin McCabe",
      "diff": "@@ -0,0 +1,19 @@\n+  public synchronized List\u003cPathCacheEntry\u003e listPathCacheEntries(long prevId,\n+      String pool, int maxReplies) {\n+    final int MAX_PRE_ALLOCATED_ENTRIES \u003d 16;\n+    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n+        new ArrayList\u003cPathCacheEntry\u003e(Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));\n+    int numReplies \u003d 0;\n+    SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n+    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n+      if (numReplies \u003e\u003d maxReplies) {\n+        return replies;\n+      }\n+      if (pool.isEmpty() || cur.getValue().getDirective().\n+            getPool().equals(pool)) {\n+        replies.add(cur.getValue());\n+        numReplies++;\n+      }\n+    }\n+    return replies;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003cPathCacheEntry\u003e listPathCacheEntries(long prevId,\n      String pool, int maxReplies) {\n    final int MAX_PRE_ALLOCATED_ENTRIES \u003d 16;\n    ArrayList\u003cPathCacheEntry\u003e replies \u003d\n        new ArrayList\u003cPathCacheEntry\u003e(Math.min(MAX_PRE_ALLOCATED_ENTRIES, maxReplies));\n    int numReplies \u003d 0;\n    SortedMap\u003cLong, PathCacheEntry\u003e tailMap \u003d entriesById.tailMap(prevId + 1);\n    for (Entry\u003cLong, PathCacheEntry\u003e cur : tailMap.entrySet()) {\n      if (numReplies \u003e\u003d maxReplies) {\n        return replies;\n      }\n      if (pool.isEmpty() || cur.getValue().getDirective().\n            getPool().equals(pool)) {\n        replies.add(cur.getValue());\n        numReplies++;\n      }\n    }\n    return replies;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/CacheManager.java"
    }
  }
}