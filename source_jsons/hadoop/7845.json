{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSImageTransactionalStorageInspector.java",
  "functionName": "inspectDirectory",
  "functionId": "inspectDirectory___sd-StorageDirectory",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java",
  "functionStartLine": 75,
  "functionEndLine": 127,
  "numCommitsSeen": 17,
  "timeTaken": 2728,
  "changeHistory": [
    "14556cc5d8fee8f8a846e4f65572828553be386c",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
    "4f9bbaa301194e3d20972a10f51638c7f4d121f0",
    "706394d03992b394e9f907aff2155df493e4ea4e",
    "bdc3720d5b67a1c8fc2dfb29be16e4155c0e7f15",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "23762da4fa17ce6ea7b70722147977123a28a7e6",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63"
  ],
  "changeHistoryShort": {
    "14556cc5d8fee8f8a846e4f65572828553be386c": "Ybodychange",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": "Ybodychange",
    "4f9bbaa301194e3d20972a10f51638c7f4d121f0": "Ybodychange",
    "706394d03992b394e9f907aff2155df493e4ea4e": "Ybodychange",
    "bdc3720d5b67a1c8fc2dfb29be16e4155c0e7f15": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "23762da4fa17ce6ea7b70722147977123a28a7e6": "Ybodychange",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": "Yintroduced"
  },
  "changeHistoryDetails": {
    "14556cc5d8fee8f8a846e4f65572828553be386c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6155. Fix Boxing/unboxing to parse a primitive findbugs warnings. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1582068 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/03/14 2:27 PM",
      "commitName": "14556cc5d8fee8f8a846e4f65572828553be386c",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "24/03/14 4:32 PM",
      "commitNameOld": "c2ef7e239eb0e81cf8a3e971378e9e696202de67",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 1.91,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public void inspectDirectory(StorageDirectory sd) throws IOException {\n     // Was the directory just formatted?\n     if (!sd.getVersionFile().exists()) {\n       LOG.info(\"No version file in \" + sd.getRoot());\n       needToSave |\u003d true;\n       return;\n     }\n     \n     // Check for a seen_txid file, which marks a minimum transaction ID that\n     // must be included in our load plan.\n     try {\n       maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n     } catch (IOException ioe) {\n       LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n       return;\n     }\n \n     File currentDir \u003d sd.getCurrentDir();\n     File filesInStorage[];\n     try {\n       filesInStorage \u003d FileUtil.listFiles(currentDir);\n     } catch (IOException ioe) {\n       LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n           ioe);\n       return;\n     }\n \n     for (File f : filesInStorage) {\n       LOG.debug(\"Checking file \" + f);\n       String name \u003d f.getName();\n       \n       // Check for fsimage_*\n       Matcher imageMatch \u003d this.matchPattern(name);\n       if (imageMatch !\u003d null) {\n         if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n           try {\n-            long txid \u003d Long.valueOf(imageMatch.group(1));\n+            long txid \u003d Long.parseLong(imageMatch.group(1));\n             foundImages.add(new FSImageFile(sd, f, txid));\n           } catch (NumberFormatException nfe) {\n             LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                       \"transaction ID\");\n             // skip\n           }\n         } else {\n           LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                    \"not configured to contain images.\");\n         }\n       }\n     }\n     \n     // set finalized flag\n     isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void inspectDirectory(StorageDirectory sd) throws IOException {\n    // Was the directory just formatted?\n    if (!sd.getVersionFile().exists()) {\n      LOG.info(\"No version file in \" + sd.getRoot());\n      needToSave |\u003d true;\n      return;\n    }\n    \n    // Check for a seen_txid file, which marks a minimum transaction ID that\n    // must be included in our load plan.\n    try {\n      maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n      return;\n    }\n\n    File currentDir \u003d sd.getCurrentDir();\n    File filesInStorage[];\n    try {\n      filesInStorage \u003d FileUtil.listFiles(currentDir);\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n          ioe);\n      return;\n    }\n\n    for (File f : filesInStorage) {\n      LOG.debug(\"Checking file \" + f);\n      String name \u003d f.getName();\n      \n      // Check for fsimage_*\n      Matcher imageMatch \u003d this.matchPattern(name);\n      if (imageMatch !\u003d null) {\n        if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n          try {\n            long txid \u003d Long.parseLong(imageMatch.group(1));\n            foundImages.add(new FSImageFile(sd, f, txid));\n          } catch (NumberFormatException nfe) {\n            LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                      \"transaction ID\");\n            // skip\n          }\n        } else {\n          LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                   \"not configured to contain images.\");\n        }\n      }\n    }\n    \n    // set finalized flag\n    isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java",
      "extendedDetails": {}
    },
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6000. Avoid saving namespace when starting rolling upgrade. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1571840 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/14 1:58 PM",
      "commitName": "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "13/02/14 12:04 AM",
      "commitNameOld": "4f9bbaa301194e3d20972a10f51638c7f4d121f0",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 12.58,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public void inspectDirectory(StorageDirectory sd) throws IOException {\n     // Was the directory just formatted?\n     if (!sd.getVersionFile().exists()) {\n       LOG.info(\"No version file in \" + sd.getRoot());\n       needToSave |\u003d true;\n       return;\n     }\n     \n     // Check for a seen_txid file, which marks a minimum transaction ID that\n     // must be included in our load plan.\n     try {\n       maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n     } catch (IOException ioe) {\n       LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n       return;\n     }\n \n     File currentDir \u003d sd.getCurrentDir();\n     File filesInStorage[];\n     try {\n       filesInStorage \u003d FileUtil.listFiles(currentDir);\n     } catch (IOException ioe) {\n       LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n           ioe);\n       return;\n     }\n \n     for (File f : filesInStorage) {\n       LOG.debug(\"Checking file \" + f);\n       String name \u003d f.getName();\n       \n       // Check for fsimage_*\n-      Matcher imageMatch \u003d namePattern.matcher(name);\n-      if (imageMatch.matches()) {\n+      Matcher imageMatch \u003d this.matchPattern(name);\n+      if (imageMatch !\u003d null) {\n         if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n           try {\n             long txid \u003d Long.valueOf(imageMatch.group(1));\n             foundImages.add(new FSImageFile(sd, f, txid));\n           } catch (NumberFormatException nfe) {\n             LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                       \"transaction ID\");\n             // skip\n           }\n         } else {\n           LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                    \"not configured to contain images.\");\n         }\n       }\n     }\n     \n     // set finalized flag\n     isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void inspectDirectory(StorageDirectory sd) throws IOException {\n    // Was the directory just formatted?\n    if (!sd.getVersionFile().exists()) {\n      LOG.info(\"No version file in \" + sd.getRoot());\n      needToSave |\u003d true;\n      return;\n    }\n    \n    // Check for a seen_txid file, which marks a minimum transaction ID that\n    // must be included in our load plan.\n    try {\n      maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n      return;\n    }\n\n    File currentDir \u003d sd.getCurrentDir();\n    File filesInStorage[];\n    try {\n      filesInStorage \u003d FileUtil.listFiles(currentDir);\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n          ioe);\n      return;\n    }\n\n    for (File f : filesInStorage) {\n      LOG.debug(\"Checking file \" + f);\n      String name \u003d f.getName();\n      \n      // Check for fsimage_*\n      Matcher imageMatch \u003d this.matchPattern(name);\n      if (imageMatch !\u003d null) {\n        if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n          try {\n            long txid \u003d Long.valueOf(imageMatch.group(1));\n            foundImages.add(new FSImageFile(sd, f, txid));\n          } catch (NumberFormatException nfe) {\n            LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                      \"transaction ID\");\n            // skip\n          }\n        } else {\n          LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                   \"not configured to contain images.\");\n        }\n      }\n    }\n    \n    // set finalized flag\n    isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java",
      "extendedDetails": {}
    },
    "4f9bbaa301194e3d20972a10f51638c7f4d121f0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5889. When starting rolling upgrade, create a fs image for rollback so that the standby namenode can create checkpoints during upgrade.  Contributed by szetszwo \u0026 jing9\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1567861 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/02/14 12:04 AM",
      "commitName": "4f9bbaa301194e3d20972a10f51638c7f4d121f0",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "14/03/13 11:04 AM",
      "commitNameOld": "bcabbcdf4cf7b4bcda62d74b06c9736bc55f6fc1",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 335.58,
      "commitsBetweenForRepo": 2053,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public void inspectDirectory(StorageDirectory sd) throws IOException {\n     // Was the directory just formatted?\n     if (!sd.getVersionFile().exists()) {\n       LOG.info(\"No version file in \" + sd.getRoot());\n       needToSave |\u003d true;\n       return;\n     }\n     \n     // Check for a seen_txid file, which marks a minimum transaction ID that\n     // must be included in our load plan.\n     try {\n       maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n     } catch (IOException ioe) {\n       LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n       return;\n     }\n \n     File currentDir \u003d sd.getCurrentDir();\n     File filesInStorage[];\n     try {\n       filesInStorage \u003d FileUtil.listFiles(currentDir);\n     } catch (IOException ioe) {\n       LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n           ioe);\n       return;\n     }\n \n     for (File f : filesInStorage) {\n       LOG.debug(\"Checking file \" + f);\n       String name \u003d f.getName();\n       \n       // Check for fsimage_*\n-      Matcher imageMatch \u003d IMAGE_REGEX.matcher(name);\n+      Matcher imageMatch \u003d namePattern.matcher(name);\n       if (imageMatch.matches()) {\n         if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n           try {\n             long txid \u003d Long.valueOf(imageMatch.group(1));\n             foundImages.add(new FSImageFile(sd, f, txid));\n           } catch (NumberFormatException nfe) {\n             LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                       \"transaction ID\");\n             // skip\n           }\n         } else {\n           LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                    \"not configured to contain images.\");\n         }\n       }\n     }\n     \n     // set finalized flag\n     isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void inspectDirectory(StorageDirectory sd) throws IOException {\n    // Was the directory just formatted?\n    if (!sd.getVersionFile().exists()) {\n      LOG.info(\"No version file in \" + sd.getRoot());\n      needToSave |\u003d true;\n      return;\n    }\n    \n    // Check for a seen_txid file, which marks a minimum transaction ID that\n    // must be included in our load plan.\n    try {\n      maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n      return;\n    }\n\n    File currentDir \u003d sd.getCurrentDir();\n    File filesInStorage[];\n    try {\n      filesInStorage \u003d FileUtil.listFiles(currentDir);\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n          ioe);\n      return;\n    }\n\n    for (File f : filesInStorage) {\n      LOG.debug(\"Checking file \" + f);\n      String name \u003d f.getName();\n      \n      // Check for fsimage_*\n      Matcher imageMatch \u003d namePattern.matcher(name);\n      if (imageMatch.matches()) {\n        if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n          try {\n            long txid \u003d Long.valueOf(imageMatch.group(1));\n            foundImages.add(new FSImageFile(sd, f, txid));\n          } catch (NumberFormatException nfe) {\n            LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                      \"transaction ID\");\n            // skip\n          }\n        } else {\n          LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                   \"not configured to contain images.\");\n        }\n      }\n    }\n    \n    // set finalized flag\n    isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java",
      "extendedDetails": {}
    },
    "706394d03992b394e9f907aff2155df493e4ea4e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3004. Implement Recovery Mode. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1311394 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/04/12 12:39 PM",
      "commitName": "706394d03992b394e9f907aff2155df493e4ea4e",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "19/11/11 7:58 PM",
      "commitNameOld": "b2313021fd03d9803a04b120d97bfd91fcbd4d36",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 141.65,
      "commitsBetweenForRepo": 1014,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,53 @@\n   public void inspectDirectory(StorageDirectory sd) throws IOException {\n     // Was the directory just formatted?\n     if (!sd.getVersionFile().exists()) {\n       LOG.info(\"No version file in \" + sd.getRoot());\n       needToSave |\u003d true;\n       return;\n     }\n     \n-    maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n+    // Check for a seen_txid file, which marks a minimum transaction ID that\n+    // must be included in our load plan.\n+    try {\n+      maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n+    } catch (IOException ioe) {\n+      LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n+      return;\n+    }\n \n     File currentDir \u003d sd.getCurrentDir();\n     File filesInStorage[];\n     try {\n       filesInStorage \u003d FileUtil.listFiles(currentDir);\n     } catch (IOException ioe) {\n       LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n           ioe);\n       return;\n     }\n \n     for (File f : filesInStorage) {\n       LOG.debug(\"Checking file \" + f);\n       String name \u003d f.getName();\n       \n       // Check for fsimage_*\n       Matcher imageMatch \u003d IMAGE_REGEX.matcher(name);\n       if (imageMatch.matches()) {\n         if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n           try {\n             long txid \u003d Long.valueOf(imageMatch.group(1));\n             foundImages.add(new FSImageFile(sd, f, txid));\n           } catch (NumberFormatException nfe) {\n             LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                       \"transaction ID\");\n             // skip\n           }\n         } else {\n           LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                    \"not configured to contain images.\");\n         }\n       }\n     }\n     \n-\n-    // Check for a seen_txid file, which marks a minimum transaction ID that\n-    // must be included in our load plan.\n-    try {\n-      maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n-    } catch (IOException ioe) {\n-      LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n-    }\n-    \n     // set finalized flag\n     isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void inspectDirectory(StorageDirectory sd) throws IOException {\n    // Was the directory just formatted?\n    if (!sd.getVersionFile().exists()) {\n      LOG.info(\"No version file in \" + sd.getRoot());\n      needToSave |\u003d true;\n      return;\n    }\n    \n    // Check for a seen_txid file, which marks a minimum transaction ID that\n    // must be included in our load plan.\n    try {\n      maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n      return;\n    }\n\n    File currentDir \u003d sd.getCurrentDir();\n    File filesInStorage[];\n    try {\n      filesInStorage \u003d FileUtil.listFiles(currentDir);\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n          ioe);\n      return;\n    }\n\n    for (File f : filesInStorage) {\n      LOG.debug(\"Checking file \" + f);\n      String name \u003d f.getName();\n      \n      // Check for fsimage_*\n      Matcher imageMatch \u003d IMAGE_REGEX.matcher(name);\n      if (imageMatch.matches()) {\n        if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n          try {\n            long txid \u003d Long.valueOf(imageMatch.group(1));\n            foundImages.add(new FSImageFile(sd, f, txid));\n          } catch (NumberFormatException nfe) {\n            LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                      \"transaction ID\");\n            // skip\n          }\n        } else {\n          LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                   \"not configured to contain images.\");\n        }\n      }\n    }\n    \n    // set finalized flag\n    isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java",
      "extendedDetails": {}
    },
    "bdc3720d5b67a1c8fc2dfb29be16e4155c0e7f15": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2018. Move all journal stream management code into one place. Contributed by Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165826 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/11 1:27 PM",
      "commitName": "bdc3720d5b67a1c8fc2dfb29be16e4155c0e7f15",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "04/09/11 12:30 PM",
      "commitNameOld": "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 2.04,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,55 @@\n   public void inspectDirectory(StorageDirectory sd) throws IOException {\n     // Was the directory just formatted?\n     if (!sd.getVersionFile().exists()) {\n       LOG.info(\"No version file in \" + sd.getRoot());\n       needToSave |\u003d true;\n       return;\n     }\n     \n+    maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n+\n     File currentDir \u003d sd.getCurrentDir();\n     File filesInStorage[];\n     try {\n       filesInStorage \u003d FileUtil.listFiles(currentDir);\n     } catch (IOException ioe) {\n       LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n           ioe);\n       return;\n     }\n \n     for (File f : filesInStorage) {\n       LOG.debug(\"Checking file \" + f);\n       String name \u003d f.getName();\n       \n       // Check for fsimage_*\n       Matcher imageMatch \u003d IMAGE_REGEX.matcher(name);\n       if (imageMatch.matches()) {\n         if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n           try {\n             long txid \u003d Long.valueOf(imageMatch.group(1));\n             foundImages.add(new FSImageFile(sd, f, txid));\n           } catch (NumberFormatException nfe) {\n             LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                       \"transaction ID\");\n             // skip\n           }\n         } else {\n           LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                    \"not configured to contain images.\");\n         }\n       }\n     }\n     \n \n     // Check for a seen_txid file, which marks a minimum transaction ID that\n     // must be included in our load plan.\n     try {\n       maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n     } catch (IOException ioe) {\n       LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n     }\n     \n-    List\u003cEditLogFile\u003e editLogs \n-      \u003d FileJournalManager.matchEditLogs(filesInStorage);\n-    if (sd.getStorageDirType().isOfType(NameNodeDirType.EDITS)) {\n-      for (EditLogFile log : editLogs) {\n-        addEditLog(log);\n-      }\n-    } else if (!editLogs.isEmpty()){\n-      LOG.warn(\"Found the following edit log file(s) in \" + sd +\n-          \" even though it was not configured to store edits:\\n\" +\n-          \"  \" + Joiner.on(\"\\n  \").join(editLogs));\n-          \n-    }\n-    \n     // set finalized flag\n     isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void inspectDirectory(StorageDirectory sd) throws IOException {\n    // Was the directory just formatted?\n    if (!sd.getVersionFile().exists()) {\n      LOG.info(\"No version file in \" + sd.getRoot());\n      needToSave |\u003d true;\n      return;\n    }\n    \n    maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n\n    File currentDir \u003d sd.getCurrentDir();\n    File filesInStorage[];\n    try {\n      filesInStorage \u003d FileUtil.listFiles(currentDir);\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n          ioe);\n      return;\n    }\n\n    for (File f : filesInStorage) {\n      LOG.debug(\"Checking file \" + f);\n      String name \u003d f.getName();\n      \n      // Check for fsimage_*\n      Matcher imageMatch \u003d IMAGE_REGEX.matcher(name);\n      if (imageMatch.matches()) {\n        if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n          try {\n            long txid \u003d Long.valueOf(imageMatch.group(1));\n            foundImages.add(new FSImageFile(sd, f, txid));\n          } catch (NumberFormatException nfe) {\n            LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                      \"transaction ID\");\n            // skip\n          }\n        } else {\n          LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                   \"not configured to contain images.\");\n        }\n      }\n    }\n    \n\n    // Check for a seen_txid file, which marks a minimum transaction ID that\n    // must be included in our load plan.\n    try {\n      maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n    }\n    \n    // set finalized flag\n    isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void inspectDirectory(StorageDirectory sd) throws IOException {\n    // Was the directory just formatted?\n    if (!sd.getVersionFile().exists()) {\n      LOG.info(\"No version file in \" + sd.getRoot());\n      needToSave |\u003d true;\n      return;\n    }\n    \n    File currentDir \u003d sd.getCurrentDir();\n    File filesInStorage[];\n    try {\n      filesInStorage \u003d FileUtil.listFiles(currentDir);\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n          ioe);\n      return;\n    }\n\n    for (File f : filesInStorage) {\n      LOG.debug(\"Checking file \" + f);\n      String name \u003d f.getName();\n      \n      // Check for fsimage_*\n      Matcher imageMatch \u003d IMAGE_REGEX.matcher(name);\n      if (imageMatch.matches()) {\n        if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n          try {\n            long txid \u003d Long.valueOf(imageMatch.group(1));\n            foundImages.add(new FSImageFile(sd, f, txid));\n          } catch (NumberFormatException nfe) {\n            LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                      \"transaction ID\");\n            // skip\n          }\n        } else {\n          LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                   \"not configured to contain images.\");\n        }\n      }\n    }\n    \n\n    // Check for a seen_txid file, which marks a minimum transaction ID that\n    // must be included in our load plan.\n    try {\n      maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n    }\n    \n    List\u003cEditLogFile\u003e editLogs \n      \u003d FileJournalManager.matchEditLogs(filesInStorage);\n    if (sd.getStorageDirType().isOfType(NameNodeDirType.EDITS)) {\n      for (EditLogFile log : editLogs) {\n        addEditLog(log);\n      }\n    } else if (!editLogs.isEmpty()){\n      LOG.warn(\"Found the following edit log file(s) in \" + sd +\n          \" even though it was not configured to store edits:\\n\" +\n          \"  \" + Joiner.on(\"\\n  \").join(editLogs));\n          \n    }\n    \n    // set finalized flag\n    isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void inspectDirectory(StorageDirectory sd) throws IOException {\n    // Was the directory just formatted?\n    if (!sd.getVersionFile().exists()) {\n      LOG.info(\"No version file in \" + sd.getRoot());\n      needToSave |\u003d true;\n      return;\n    }\n    \n    File currentDir \u003d sd.getCurrentDir();\n    File filesInStorage[];\n    try {\n      filesInStorage \u003d FileUtil.listFiles(currentDir);\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n          ioe);\n      return;\n    }\n\n    for (File f : filesInStorage) {\n      LOG.debug(\"Checking file \" + f);\n      String name \u003d f.getName();\n      \n      // Check for fsimage_*\n      Matcher imageMatch \u003d IMAGE_REGEX.matcher(name);\n      if (imageMatch.matches()) {\n        if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n          try {\n            long txid \u003d Long.valueOf(imageMatch.group(1));\n            foundImages.add(new FSImageFile(sd, f, txid));\n          } catch (NumberFormatException nfe) {\n            LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                      \"transaction ID\");\n            // skip\n          }\n        } else {\n          LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                   \"not configured to contain images.\");\n        }\n      }\n    }\n    \n\n    // Check for a seen_txid file, which marks a minimum transaction ID that\n    // must be included in our load plan.\n    try {\n      maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n    }\n    \n    List\u003cEditLogFile\u003e editLogs \n      \u003d FileJournalManager.matchEditLogs(filesInStorage);\n    if (sd.getStorageDirType().isOfType(NameNodeDirType.EDITS)) {\n      for (EditLogFile log : editLogs) {\n        addEditLog(log);\n      }\n    } else if (!editLogs.isEmpty()){\n      LOG.warn(\"Found the following edit log file(s) in \" + sd +\n          \" even though it was not configured to store edits:\\n\" +\n          \"  \" + Joiner.on(\"\\n  \").join(editLogs));\n          \n    }\n    \n    // set finalized flag\n    isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java"
      }
    },
    "23762da4fa17ce6ea7b70722147977123a28a7e6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2225. Refactor file management so it\u0027s not in classes which should be generic. Contributed by Ivan Kelly.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1154029 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/08/11 2:56 PM",
      "commitName": "23762da4fa17ce6ea7b70722147977123a28a7e6",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "04/08/11 1:22 PM",
      "commitNameOld": "53190cfa1d43762e463bcb957929097742db08ba",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,66 @@\n   public void inspectDirectory(StorageDirectory sd) throws IOException {\n     // Was the directory just formatted?\n     if (!sd.getVersionFile().exists()) {\n       LOG.info(\"No version file in \" + sd.getRoot());\n       needToSave |\u003d true;\n       return;\n     }\n     \n     File currentDir \u003d sd.getCurrentDir();\n     File filesInStorage[];\n     try {\n       filesInStorage \u003d FileUtil.listFiles(currentDir);\n     } catch (IOException ioe) {\n       LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n           ioe);\n       return;\n     }\n \n     for (File f : filesInStorage) {\n       LOG.debug(\"Checking file \" + f);\n       String name \u003d f.getName();\n       \n       // Check for fsimage_*\n       Matcher imageMatch \u003d IMAGE_REGEX.matcher(name);\n       if (imageMatch.matches()) {\n         if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n           try {\n             long txid \u003d Long.valueOf(imageMatch.group(1));\n-            foundImages.add(new FoundFSImage(sd, f, txid));\n+            foundImages.add(new FSImageFile(sd, f, txid));\n           } catch (NumberFormatException nfe) {\n             LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                       \"transaction ID\");\n             // skip\n           }\n         } else {\n           LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                    \"not configured to contain images.\");\n         }\n       }\n     }\n     \n \n     // Check for a seen_txid file, which marks a minimum transaction ID that\n     // must be included in our load plan.\n     try {\n       maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n     } catch (IOException ioe) {\n       LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n     }\n     \n-    List\u003cFoundEditLog\u003e editLogs \u003d matchEditLogs(filesInStorage);\n+    List\u003cEditLogFile\u003e editLogs \n+      \u003d FileJournalManager.matchEditLogs(filesInStorage);\n     if (sd.getStorageDirType().isOfType(NameNodeDirType.EDITS)) {\n-      for (FoundEditLog log : editLogs) {\n+      for (EditLogFile log : editLogs) {\n         addEditLog(log);\n       }\n     } else if (!editLogs.isEmpty()){\n       LOG.warn(\"Found the following edit log file(s) in \" + sd +\n           \" even though it was not configured to store edits:\\n\" +\n           \"  \" + Joiner.on(\"\\n  \").join(editLogs));\n           \n     }\n     \n     // set finalized flag\n     isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void inspectDirectory(StorageDirectory sd) throws IOException {\n    // Was the directory just formatted?\n    if (!sd.getVersionFile().exists()) {\n      LOG.info(\"No version file in \" + sd.getRoot());\n      needToSave |\u003d true;\n      return;\n    }\n    \n    File currentDir \u003d sd.getCurrentDir();\n    File filesInStorage[];\n    try {\n      filesInStorage \u003d FileUtil.listFiles(currentDir);\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n          ioe);\n      return;\n    }\n\n    for (File f : filesInStorage) {\n      LOG.debug(\"Checking file \" + f);\n      String name \u003d f.getName();\n      \n      // Check for fsimage_*\n      Matcher imageMatch \u003d IMAGE_REGEX.matcher(name);\n      if (imageMatch.matches()) {\n        if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n          try {\n            long txid \u003d Long.valueOf(imageMatch.group(1));\n            foundImages.add(new FSImageFile(sd, f, txid));\n          } catch (NumberFormatException nfe) {\n            LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                      \"transaction ID\");\n            // skip\n          }\n        } else {\n          LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                   \"not configured to contain images.\");\n        }\n      }\n    }\n    \n\n    // Check for a seen_txid file, which marks a minimum transaction ID that\n    // must be included in our load plan.\n    try {\n      maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n    }\n    \n    List\u003cEditLogFile\u003e editLogs \n      \u003d FileJournalManager.matchEditLogs(filesInStorage);\n    if (sd.getStorageDirType().isOfType(NameNodeDirType.EDITS)) {\n      for (EditLogFile log : editLogs) {\n        addEditLog(log);\n      }\n    } else if (!editLogs.isEmpty()){\n      LOG.warn(\"Found the following edit log file(s) in \" + sd +\n          \" even though it was not configured to store edits:\\n\" +\n          \"  \" + Joiner.on(\"\\n  \").join(editLogs));\n          \n    }\n    \n    // set finalized flag\n    isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java",
      "extendedDetails": {}
    },
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/11 9:28 AM",
      "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,65 @@\n+  public void inspectDirectory(StorageDirectory sd) throws IOException {\n+    // Was the directory just formatted?\n+    if (!sd.getVersionFile().exists()) {\n+      LOG.info(\"No version file in \" + sd.getRoot());\n+      needToSave |\u003d true;\n+      return;\n+    }\n+    \n+    File currentDir \u003d sd.getCurrentDir();\n+    File filesInStorage[];\n+    try {\n+      filesInStorage \u003d FileUtil.listFiles(currentDir);\n+    } catch (IOException ioe) {\n+      LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n+          ioe);\n+      return;\n+    }\n+\n+    for (File f : filesInStorage) {\n+      LOG.debug(\"Checking file \" + f);\n+      String name \u003d f.getName();\n+      \n+      // Check for fsimage_*\n+      Matcher imageMatch \u003d IMAGE_REGEX.matcher(name);\n+      if (imageMatch.matches()) {\n+        if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n+          try {\n+            long txid \u003d Long.valueOf(imageMatch.group(1));\n+            foundImages.add(new FoundFSImage(sd, f, txid));\n+          } catch (NumberFormatException nfe) {\n+            LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n+                      \"transaction ID\");\n+            // skip\n+          }\n+        } else {\n+          LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n+                   \"not configured to contain images.\");\n+        }\n+      }\n+    }\n+    \n+\n+    // Check for a seen_txid file, which marks a minimum transaction ID that\n+    // must be included in our load plan.\n+    try {\n+      maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n+    } catch (IOException ioe) {\n+      LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n+    }\n+    \n+    List\u003cFoundEditLog\u003e editLogs \u003d matchEditLogs(filesInStorage);\n+    if (sd.getStorageDirType().isOfType(NameNodeDirType.EDITS)) {\n+      for (FoundEditLog log : editLogs) {\n+        addEditLog(log);\n+      }\n+    } else if (!editLogs.isEmpty()){\n+      LOG.warn(\"Found the following edit log file(s) in \" + sd +\n+          \" even though it was not configured to store edits:\\n\" +\n+          \"  \" + Joiner.on(\"\\n  \").join(editLogs));\n+          \n+    }\n+    \n+    // set finalized flag\n+    isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void inspectDirectory(StorageDirectory sd) throws IOException {\n    // Was the directory just formatted?\n    if (!sd.getVersionFile().exists()) {\n      LOG.info(\"No version file in \" + sd.getRoot());\n      needToSave |\u003d true;\n      return;\n    }\n    \n    File currentDir \u003d sd.getCurrentDir();\n    File filesInStorage[];\n    try {\n      filesInStorage \u003d FileUtil.listFiles(currentDir);\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to inspect storage directory \" + currentDir,\n          ioe);\n      return;\n    }\n\n    for (File f : filesInStorage) {\n      LOG.debug(\"Checking file \" + f);\n      String name \u003d f.getName();\n      \n      // Check for fsimage_*\n      Matcher imageMatch \u003d IMAGE_REGEX.matcher(name);\n      if (imageMatch.matches()) {\n        if (sd.getStorageDirType().isOfType(NameNodeDirType.IMAGE)) {\n          try {\n            long txid \u003d Long.valueOf(imageMatch.group(1));\n            foundImages.add(new FoundFSImage(sd, f, txid));\n          } catch (NumberFormatException nfe) {\n            LOG.error(\"Image file \" + f + \" has improperly formatted \" +\n                      \"transaction ID\");\n            // skip\n          }\n        } else {\n          LOG.warn(\"Found image file at \" + f + \" but storage directory is \" +\n                   \"not configured to contain images.\");\n        }\n      }\n    }\n    \n\n    // Check for a seen_txid file, which marks a minimum transaction ID that\n    // must be included in our load plan.\n    try {\n      maxSeenTxId \u003d Math.max(maxSeenTxId, NNStorage.readTransactionIdFile(sd));\n    } catch (IOException ioe) {\n      LOG.warn(\"Unable to determine the max transaction ID seen by \" + sd, ioe);\n    }\n    \n    List\u003cFoundEditLog\u003e editLogs \u003d matchEditLogs(filesInStorage);\n    if (sd.getStorageDirType().isOfType(NameNodeDirType.EDITS)) {\n      for (FoundEditLog log : editLogs) {\n        addEditLog(log);\n      }\n    } else if (!editLogs.isEmpty()){\n      LOG.warn(\"Found the following edit log file(s) in \" + sd +\n          \" even though it was not configured to store edits:\\n\" +\n          \"  \" + Joiner.on(\"\\n  \").join(editLogs));\n          \n    }\n    \n    // set finalized flag\n    isUpgradeFinalized \u003d isUpgradeFinalized \u0026\u0026 !sd.getPreviousDir().exists();\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImageTransactionalStorageInspector.java"
    }
  }
}