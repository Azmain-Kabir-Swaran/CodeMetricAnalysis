{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ShellBasedIdMapping.java",
  "functionName": "parseStaticMap",
  "functionId": "parseStaticMap___staticMapFile-File",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java",
  "functionStartLine": 579,
  "functionEndLine": 621,
  "numCommitsSeen": 27,
  "timeTaken": 2456,
  "changeHistory": [
    "7a3188d054481b9bd563e337901e93476303ce7f",
    "770b5eb2db686275df445be9280e76cc3710ffdc",
    "736eb17a796a1c1ad5f4db2c6a64f6752db7bec3",
    "892b1bb746116e547fb07d46cf1d284e3219d06d",
    "5b9fcedb4d116d91d70aaad6cbf59093eeee36df",
    "72a556d3b0def0ab4e4509528cc513f6df06b084",
    "1ba203e3e0ead72afd9c3351827f44ff2d51b974"
  ],
  "changeHistoryShort": {
    "7a3188d054481b9bd563e337901e93476303ce7f": "Ybodychange",
    "770b5eb2db686275df445be9280e76cc3710ffdc": "Ybodychange",
    "736eb17a796a1c1ad5f4db2c6a64f6752db7bec3": "Ybodychange",
    "892b1bb746116e547fb07d46cf1d284e3219d06d": "Ybodychange",
    "5b9fcedb4d116d91d70aaad6cbf59093eeee36df": "Ybodychange",
    "72a556d3b0def0ab4e4509528cc513f6df06b084": "Yfilerename",
    "1ba203e3e0ead72afd9c3351827f44ff2d51b974": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7a3188d054481b9bd563e337901e93476303ce7f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16282. Avoid FileStream to improve performance. Contributed by Ayush Saxena.\n",
      "commitDate": "02/05/19 12:58 PM",
      "commitName": "7a3188d054481b9bd563e337901e93476303ce7f",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "17/07/17 9:32 PM",
      "commitNameOld": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 653.64,
      "commitsBetweenForRepo": 5524,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   static StaticMapping parseStaticMap(File staticMapFile)\n       throws IOException {\n     \n     Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n     Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n     \n     BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n-        new FileInputStream(staticMapFile), StandardCharsets.UTF_8));\n+        Files.newInputStream(staticMapFile.toPath()), StandardCharsets.UTF_8));\n     \n     try {\n       String line \u003d null;\n       while ((line \u003d in.readLine()) !\u003d null) {\n         // Skip entirely empty and comment lines.\n         if (EMPTY_LINE.matcher(line).matches() ||\n             COMMENT_LINE.matcher(line).matches()) {\n           continue;\n         }\n         \n         Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n         if (!lineMatcher.matches()) {\n           LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n               \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n               \"everything following a \u0027#\u0027 on a line will be ignored.\");\n           continue;\n         }\n         \n         // We know the line is fine to parse without error checking like this\n         // since it matched the regex above.\n         String firstComponent \u003d lineMatcher.group(1);\n         Integer remoteId \u003d parseId(lineMatcher.group(2));\n         Integer localId \u003d parseId(lineMatcher.group(3));\n         if (firstComponent.equals(\"uid\")) {\n           uidMapping.put(localId, remoteId);\n         } else {\n           gidMapping.put(localId, remoteId);\n         }\n       }\n     } finally {\n       in.close();\n     }\n     \n     return new StaticMapping(uidMapping, gidMapping);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static StaticMapping parseStaticMap(File staticMapFile)\n      throws IOException {\n    \n    Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    \n    BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n        Files.newInputStream(staticMapFile.toPath()), StandardCharsets.UTF_8));\n    \n    try {\n      String line \u003d null;\n      while ((line \u003d in.readLine()) !\u003d null) {\n        // Skip entirely empty and comment lines.\n        if (EMPTY_LINE.matcher(line).matches() ||\n            COMMENT_LINE.matcher(line).matches()) {\n          continue;\n        }\n        \n        Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n        if (!lineMatcher.matches()) {\n          LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n              \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n              \"everything following a \u0027#\u0027 on a line will be ignored.\");\n          continue;\n        }\n        \n        // We know the line is fine to parse without error checking like this\n        // since it matched the regex above.\n        String firstComponent \u003d lineMatcher.group(1);\n        Integer remoteId \u003d parseId(lineMatcher.group(2));\n        Integer localId \u003d parseId(lineMatcher.group(3));\n        if (firstComponent.equals(\"uid\")) {\n          uidMapping.put(localId, remoteId);\n        } else {\n          gidMapping.put(localId, remoteId);\n        }\n      }\n    } finally {\n      in.close();\n    }\n    \n    return new StaticMapping(uidMapping, gidMapping);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java",
      "extendedDetails": {}
    },
    "770b5eb2db686275df445be9280e76cc3710ffdc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13444. Replace org.apache.commons.io.Charsets with java.nio.charset.StandardCharsets. Contributed by Vincent Poon.\n",
      "commitDate": "01/08/16 1:35 AM",
      "commitName": "770b5eb2db686275df445be9280e76cc3710ffdc",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "21/05/16 10:00 AM",
      "commitNameOld": "d8c1fd1944160ad5b5d093731ae987d701802321",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 71.65,
      "commitsBetweenForRepo": 585,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   static StaticMapping parseStaticMap(File staticMapFile)\n       throws IOException {\n     \n     Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n     Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n     \n     BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n-        new FileInputStream(staticMapFile), Charsets.UTF_8));\n+        new FileInputStream(staticMapFile), StandardCharsets.UTF_8));\n     \n     try {\n       String line \u003d null;\n       while ((line \u003d in.readLine()) !\u003d null) {\n         // Skip entirely empty and comment lines.\n         if (EMPTY_LINE.matcher(line).matches() ||\n             COMMENT_LINE.matcher(line).matches()) {\n           continue;\n         }\n         \n         Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n         if (!lineMatcher.matches()) {\n           LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n               \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n               \"everything following a \u0027#\u0027 on a line will be ignored.\");\n           continue;\n         }\n         \n         // We know the line is fine to parse without error checking like this\n         // since it matched the regex above.\n         String firstComponent \u003d lineMatcher.group(1);\n         Integer remoteId \u003d parseId(lineMatcher.group(2));\n         Integer localId \u003d parseId(lineMatcher.group(3));\n         if (firstComponent.equals(\"uid\")) {\n           uidMapping.put(localId, remoteId);\n         } else {\n           gidMapping.put(localId, remoteId);\n         }\n       }\n     } finally {\n       in.close();\n     }\n     \n     return new StaticMapping(uidMapping, gidMapping);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static StaticMapping parseStaticMap(File staticMapFile)\n      throws IOException {\n    \n    Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    \n    BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n        new FileInputStream(staticMapFile), StandardCharsets.UTF_8));\n    \n    try {\n      String line \u003d null;\n      while ((line \u003d in.readLine()) !\u003d null) {\n        // Skip entirely empty and comment lines.\n        if (EMPTY_LINE.matcher(line).matches() ||\n            COMMENT_LINE.matcher(line).matches()) {\n          continue;\n        }\n        \n        Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n        if (!lineMatcher.matches()) {\n          LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n              \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n              \"everything following a \u0027#\u0027 on a line will be ignored.\");\n          continue;\n        }\n        \n        // We know the line is fine to parse without error checking like this\n        // since it matched the regex above.\n        String firstComponent \u003d lineMatcher.group(1);\n        Integer remoteId \u003d parseId(lineMatcher.group(2));\n        Integer localId \u003d parseId(lineMatcher.group(3));\n        if (firstComponent.equals(\"uid\")) {\n          uidMapping.put(localId, remoteId);\n        } else {\n          gidMapping.put(localId, remoteId);\n        }\n      }\n    } finally {\n      in.close();\n    }\n    \n    return new StaticMapping(uidMapping, gidMapping);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java",
      "extendedDetails": {}
    },
    "736eb17a796a1c1ad5f4db2c6a64f6752db7bec3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12731. Remove useless boxing/unboxing code. Contributed by Kousuke Saruta.\n",
      "commitDate": "24/01/16 8:47 PM",
      "commitName": "736eb17a796a1c1ad5f4db2c6a64f6752db7bec3",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "06/01/15 4:19 PM",
      "commitNameOld": "788ee35e2bf0f3d445e03e6ea9bd02c40c8fdfe3",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 383.19,
      "commitsBetweenForRepo": 3092,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   static StaticMapping parseStaticMap(File staticMapFile)\n       throws IOException {\n     \n     Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n     Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n     \n     BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n         new FileInputStream(staticMapFile), Charsets.UTF_8));\n     \n     try {\n       String line \u003d null;\n       while ((line \u003d in.readLine()) !\u003d null) {\n         // Skip entirely empty and comment lines.\n         if (EMPTY_LINE.matcher(line).matches() ||\n             COMMENT_LINE.matcher(line).matches()) {\n           continue;\n         }\n         \n         Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n         if (!lineMatcher.matches()) {\n           LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n               \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n               \"everything following a \u0027#\u0027 on a line will be ignored.\");\n           continue;\n         }\n         \n         // We know the line is fine to parse without error checking like this\n         // since it matched the regex above.\n         String firstComponent \u003d lineMatcher.group(1);\n-        int remoteId \u003d parseId(lineMatcher.group(2));\n-        int localId \u003d parseId(lineMatcher.group(3));\n+        Integer remoteId \u003d parseId(lineMatcher.group(2));\n+        Integer localId \u003d parseId(lineMatcher.group(3));\n         if (firstComponent.equals(\"uid\")) {\n           uidMapping.put(localId, remoteId);\n         } else {\n           gidMapping.put(localId, remoteId);\n         }\n       }\n     } finally {\n       in.close();\n     }\n     \n     return new StaticMapping(uidMapping, gidMapping);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static StaticMapping parseStaticMap(File staticMapFile)\n      throws IOException {\n    \n    Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    \n    BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n        new FileInputStream(staticMapFile), Charsets.UTF_8));\n    \n    try {\n      String line \u003d null;\n      while ((line \u003d in.readLine()) !\u003d null) {\n        // Skip entirely empty and comment lines.\n        if (EMPTY_LINE.matcher(line).matches() ||\n            COMMENT_LINE.matcher(line).matches()) {\n          continue;\n        }\n        \n        Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n        if (!lineMatcher.matches()) {\n          LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n              \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n              \"everything following a \u0027#\u0027 on a line will be ignored.\");\n          continue;\n        }\n        \n        // We know the line is fine to parse without error checking like this\n        // since it matched the regex above.\n        String firstComponent \u003d lineMatcher.group(1);\n        Integer remoteId \u003d parseId(lineMatcher.group(2));\n        Integer localId \u003d parseId(lineMatcher.group(3));\n        if (firstComponent.equals(\"uid\")) {\n          uidMapping.put(localId, remoteId);\n        } else {\n          gidMapping.put(localId, remoteId);\n        }\n      }\n    } finally {\n      in.close();\n    }\n    \n    return new StaticMapping(uidMapping, gidMapping);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java",
      "extendedDetails": {}
    },
    "892b1bb746116e547fb07d46cf1d284e3219d06d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7563. NFS gateway parseStaticMap NumberFormatException. Contributed by Yongjun Zhang\n",
      "commitDate": "02/01/15 10:49 AM",
      "commitName": "892b1bb746116e547fb07d46cf1d284e3219d06d",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "11/12/14 4:42 PM",
      "commitNameOld": "5b9fcedb4d116d91d70aaad6cbf59093eeee36df",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 21.75,
      "commitsBetweenForRepo": 104,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   static StaticMapping parseStaticMap(File staticMapFile)\n       throws IOException {\n     \n     Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n     Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n     \n     BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n         new FileInputStream(staticMapFile), Charsets.UTF_8));\n     \n     try {\n       String line \u003d null;\n       while ((line \u003d in.readLine()) !\u003d null) {\n         // Skip entirely empty and comment lines.\n         if (EMPTY_LINE.matcher(line).matches() ||\n             COMMENT_LINE.matcher(line).matches()) {\n           continue;\n         }\n         \n         Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n         if (!lineMatcher.matches()) {\n           LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n               \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n               \"everything following a \u0027#\u0027 on a line will be ignored.\");\n           continue;\n         }\n         \n         // We know the line is fine to parse without error checking like this\n         // since it matched the regex above.\n         String firstComponent \u003d lineMatcher.group(1);\n-        int remoteId \u003d Integer.parseInt(lineMatcher.group(2));\n-        int localId \u003d Integer.parseInt(lineMatcher.group(3));\n+        int remoteId \u003d parseId(lineMatcher.group(2));\n+        int localId \u003d parseId(lineMatcher.group(3));\n         if (firstComponent.equals(\"uid\")) {\n           uidMapping.put(localId, remoteId);\n         } else {\n           gidMapping.put(localId, remoteId);\n         }\n       }\n     } finally {\n       in.close();\n     }\n     \n     return new StaticMapping(uidMapping, gidMapping);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static StaticMapping parseStaticMap(File staticMapFile)\n      throws IOException {\n    \n    Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    \n    BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n        new FileInputStream(staticMapFile), Charsets.UTF_8));\n    \n    try {\n      String line \u003d null;\n      while ((line \u003d in.readLine()) !\u003d null) {\n        // Skip entirely empty and comment lines.\n        if (EMPTY_LINE.matcher(line).matches() ||\n            COMMENT_LINE.matcher(line).matches()) {\n          continue;\n        }\n        \n        Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n        if (!lineMatcher.matches()) {\n          LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n              \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n              \"everything following a \u0027#\u0027 on a line will be ignored.\");\n          continue;\n        }\n        \n        // We know the line is fine to parse without error checking like this\n        // since it matched the regex above.\n        String firstComponent \u003d lineMatcher.group(1);\n        int remoteId \u003d parseId(lineMatcher.group(2));\n        int localId \u003d parseId(lineMatcher.group(3));\n        if (firstComponent.equals(\"uid\")) {\n          uidMapping.put(localId, remoteId);\n        } else {\n          gidMapping.put(localId, remoteId);\n        }\n      }\n    } finally {\n      in.close();\n    }\n    \n    return new StaticMapping(uidMapping, gidMapping);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java",
      "extendedDetails": {}
    },
    "5b9fcedb4d116d91d70aaad6cbf59093eeee36df": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11389. Clean up byte to string encoding issues in hadoop-common. Contributed by Haohui Mai.\n",
      "commitDate": "11/12/14 4:42 PM",
      "commitName": "5b9fcedb4d116d91d70aaad6cbf59093eeee36df",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "10/12/14 2:37 PM",
      "commitNameOld": "84d50003f6e46f9f9ac2b9d7bb937de757be161b",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 1.09,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   static StaticMapping parseStaticMap(File staticMapFile)\n       throws IOException {\n     \n     Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n     Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n     \n     BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n-        new FileInputStream(staticMapFile)));\n+        new FileInputStream(staticMapFile), Charsets.UTF_8));\n     \n     try {\n       String line \u003d null;\n       while ((line \u003d in.readLine()) !\u003d null) {\n         // Skip entirely empty and comment lines.\n         if (EMPTY_LINE.matcher(line).matches() ||\n             COMMENT_LINE.matcher(line).matches()) {\n           continue;\n         }\n         \n         Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n         if (!lineMatcher.matches()) {\n           LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n               \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n               \"everything following a \u0027#\u0027 on a line will be ignored.\");\n           continue;\n         }\n         \n         // We know the line is fine to parse without error checking like this\n         // since it matched the regex above.\n         String firstComponent \u003d lineMatcher.group(1);\n         int remoteId \u003d Integer.parseInt(lineMatcher.group(2));\n         int localId \u003d Integer.parseInt(lineMatcher.group(3));\n         if (firstComponent.equals(\"uid\")) {\n           uidMapping.put(localId, remoteId);\n         } else {\n           gidMapping.put(localId, remoteId);\n         }\n       }\n     } finally {\n       in.close();\n     }\n     \n     return new StaticMapping(uidMapping, gidMapping);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static StaticMapping parseStaticMap(File staticMapFile)\n      throws IOException {\n    \n    Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    \n    BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n        new FileInputStream(staticMapFile), Charsets.UTF_8));\n    \n    try {\n      String line \u003d null;\n      while ((line \u003d in.readLine()) !\u003d null) {\n        // Skip entirely empty and comment lines.\n        if (EMPTY_LINE.matcher(line).matches() ||\n            COMMENT_LINE.matcher(line).matches()) {\n          continue;\n        }\n        \n        Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n        if (!lineMatcher.matches()) {\n          LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n              \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n              \"everything following a \u0027#\u0027 on a line will be ignored.\");\n          continue;\n        }\n        \n        // We know the line is fine to parse without error checking like this\n        // since it matched the regex above.\n        String firstComponent \u003d lineMatcher.group(1);\n        int remoteId \u003d Integer.parseInt(lineMatcher.group(2));\n        int localId \u003d Integer.parseInt(lineMatcher.group(3));\n        if (firstComponent.equals(\"uid\")) {\n          uidMapping.put(localId, remoteId);\n        } else {\n          gidMapping.put(localId, remoteId);\n        }\n      }\n    } finally {\n      in.close();\n    }\n    \n    return new StaticMapping(uidMapping, gidMapping);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java",
      "extendedDetails": {}
    },
    "72a556d3b0def0ab4e4509528cc513f6df06b084": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-11195. Move Id-Name mapping in NFS to the hadoop-common area for better maintenance. Contributed by Yongjun Zhang\n",
      "commitDate": "29/10/14 11:05 AM",
      "commitName": "72a556d3b0def0ab4e4509528cc513f6df06b084",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "29/10/14 10:29 AM",
      "commitNameOld": "b056048114bf4701ef9dd22486db937cb589e81b",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  static StaticMapping parseStaticMap(File staticMapFile)\n      throws IOException {\n    \n    Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    \n    BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n        new FileInputStream(staticMapFile)));\n    \n    try {\n      String line \u003d null;\n      while ((line \u003d in.readLine()) !\u003d null) {\n        // Skip entirely empty and comment lines.\n        if (EMPTY_LINE.matcher(line).matches() ||\n            COMMENT_LINE.matcher(line).matches()) {\n          continue;\n        }\n        \n        Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n        if (!lineMatcher.matches()) {\n          LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n              \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n              \"everything following a \u0027#\u0027 on a line will be ignored.\");\n          continue;\n        }\n        \n        // We know the line is fine to parse without error checking like this\n        // since it matched the regex above.\n        String firstComponent \u003d lineMatcher.group(1);\n        int remoteId \u003d Integer.parseInt(lineMatcher.group(2));\n        int localId \u003d Integer.parseInt(lineMatcher.group(3));\n        if (firstComponent.equals(\"uid\")) {\n          uidMapping.put(localId, remoteId);\n        } else {\n          gidMapping.put(localId, remoteId);\n        }\n      }\n    } finally {\n      in.close();\n    }\n    \n    return new StaticMapping(uidMapping, gidMapping);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java",
      "extendedDetails": {
        "oldPath": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/nfs/nfs3/IdUserGroup.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ShellBasedIdMapping.java"
      }
    },
    "1ba203e3e0ead72afd9c3351827f44ff2d51b974": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-6435. Add support for specifying a static uid/gid mapping for the NFS gateway. (atm via wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596966 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/05/14 1:44 PM",
      "commitName": "1ba203e3e0ead72afd9c3351827f44ff2d51b974",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,43 @@\n+  static StaticMapping parseStaticMap(File staticMapFile)\n+      throws IOException {\n+    \n+    Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n+    Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n+    \n+    BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n+        new FileInputStream(staticMapFile)));\n+    \n+    try {\n+      String line \u003d null;\n+      while ((line \u003d in.readLine()) !\u003d null) {\n+        // Skip entirely empty and comment lines.\n+        if (EMPTY_LINE.matcher(line).matches() ||\n+            COMMENT_LINE.matcher(line).matches()) {\n+          continue;\n+        }\n+        \n+        Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n+        if (!lineMatcher.matches()) {\n+          LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n+              \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n+              \"everything following a \u0027#\u0027 on a line will be ignored.\");\n+          continue;\n+        }\n+        \n+        // We know the line is fine to parse without error checking like this\n+        // since it matched the regex above.\n+        String firstComponent \u003d lineMatcher.group(1);\n+        int remoteId \u003d Integer.parseInt(lineMatcher.group(2));\n+        int localId \u003d Integer.parseInt(lineMatcher.group(3));\n+        if (firstComponent.equals(\"uid\")) {\n+          uidMapping.put(localId, remoteId);\n+        } else {\n+          gidMapping.put(localId, remoteId);\n+        }\n+      }\n+    } finally {\n+      in.close();\n+    }\n+    \n+    return new StaticMapping(uidMapping, gidMapping);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  static StaticMapping parseStaticMap(File staticMapFile)\n      throws IOException {\n    \n    Map\u003cInteger, Integer\u003e uidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    Map\u003cInteger, Integer\u003e gidMapping \u003d new HashMap\u003cInteger, Integer\u003e();\n    \n    BufferedReader in \u003d new BufferedReader(new InputStreamReader(\n        new FileInputStream(staticMapFile)));\n    \n    try {\n      String line \u003d null;\n      while ((line \u003d in.readLine()) !\u003d null) {\n        // Skip entirely empty and comment lines.\n        if (EMPTY_LINE.matcher(line).matches() ||\n            COMMENT_LINE.matcher(line).matches()) {\n          continue;\n        }\n        \n        Matcher lineMatcher \u003d MAPPING_LINE.matcher(line);\n        if (!lineMatcher.matches()) {\n          LOG.warn(\"Could not parse line \u0027\" + line + \"\u0027. Lines should be of \" +\n              \"the form \u0027[uid|gid] [remote id] [local id]\u0027. Blank lines and \" +\n              \"everything following a \u0027#\u0027 on a line will be ignored.\");\n          continue;\n        }\n        \n        // We know the line is fine to parse without error checking like this\n        // since it matched the regex above.\n        String firstComponent \u003d lineMatcher.group(1);\n        int remoteId \u003d Integer.parseInt(lineMatcher.group(2));\n        int localId \u003d Integer.parseInt(lineMatcher.group(3));\n        if (firstComponent.equals(\"uid\")) {\n          uidMapping.put(localId, remoteId);\n        } else {\n          gidMapping.put(localId, remoteId);\n        }\n      }\n    } finally {\n      in.close();\n    }\n    \n    return new StaticMapping(uidMapping, gidMapping);\n  }",
      "path": "hadoop-common-project/hadoop-nfs/src/main/java/org/apache/hadoop/nfs/nfs3/IdUserGroup.java"
    }
  }
}