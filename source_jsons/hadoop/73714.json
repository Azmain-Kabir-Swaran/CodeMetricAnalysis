{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ProtobufRpcEngine.java",
  "functionName": "invoke",
  "functionId": "invoke___proxy-Object__method-Method(modifiers-final)__args-Object[]",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
  "functionStartLine": 194,
  "functionEndLine": 277,
  "numCommitsSeen": 101,
  "timeTaken": 12159,
  "changeHistory": [
    "d1714c20e9309754397588c9b29818b9a74a80d8",
    "1d523279da94e199edafc8d4df23107e9c43da3e",
    "c634589ab2d602bf80ba513f88d44544e9bedcb5",
    "ecdeaa7e6ad43555031aed032e6ba7a14a17d7bc",
    "e880660a204b6fd0e5a0799393a4d36359765a54",
    "2d105a206884b62ccdba61f2de3e2fe65fc43074",
    "8bef4eca28a3466707cc4ea0de0330449319a5eb",
    "ea0c2b8b051a2d14927e8f314245442f30748dc8",
    "d355573f5681f43e760a1bc23ebed553bd35fca5",
    "62a9667136ebd8a048f556b534fcff4fdaf8e2ec",
    "23abb09c1f979d8c18ece81e32630a35ed569399",
    "35f255b03b1bb5c94063ec1818af1d253ceee991",
    "574dcd34c0da1903d25e37dc5757642a584dc3d0",
    "eded3d109e4c5225d8c5cd3c2d82e7ac93841263",
    "106234d873c60fa52cd0d812fb1cdc0c6b998a6d",
    "e4450d47f19131818e1c040b6bd8d85ae8250475",
    "5360da8bd9f720384860f411bee081aef13b4bd4",
    "83f2f78c118a7e52aba5104bd97b0acedc96be7b",
    "93d8a7f2a2d72a1719d02b1ed90678397900b6ed",
    "a6c79f92d503c664f2d109355b719124f29a30e5",
    "42c22f7e3d6e88bf1115f617f6e803288886d1ac",
    "fc94810d3f537e51e826fc21ade7867892b9d8dc",
    "892ade689f9bcce76daae8f66fc00a49bee8548e",
    "a9431425d1aff657fc1ea501c706235f2ebc518f",
    "5b56ac4c72d69d1b3d6feec9d96c9d62eb02d28c",
    "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5",
    "6962510f729717f776929708813f99a28e582f34",
    "3eb61be352589491117ac2781bb18f55988a8084",
    "357472001725e786f28b27560bac8aca54c3c983",
    "ead90cc1a8cd7a0f3ae28d9860ff2e3c108f1172",
    "461e614a3aa11372d18537028aa217a9d79527af",
    "aa4fe26a01d2ca881cb458d49032ce419351bed1",
    "2f478ac89cb592165ab462cd52235814507df9fe",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e",
    "589c68ae09effd6c4f26505d61636f779c22e99f",
    "081eda94fec4bbf321047c93a9bb40be678b1666",
    "4283ac6d7af638ef6662810c5765bafe92704624",
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
    "55d3dc50d16cd5b94f542f74e5329de4c30a8655"
  ],
  "changeHistoryShort": {
    "d1714c20e9309754397588c9b29818b9a74a80d8": "Ybodychange",
    "1d523279da94e199edafc8d4df23107e9c43da3e": "Ybodychange",
    "c634589ab2d602bf80ba513f88d44544e9bedcb5": "Ybodychange",
    "ecdeaa7e6ad43555031aed032e6ba7a14a17d7bc": "Ybodychange",
    "e880660a204b6fd0e5a0799393a4d36359765a54": "Ybodychange",
    "2d105a206884b62ccdba61f2de3e2fe65fc43074": "Ybodychange",
    "8bef4eca28a3466707cc4ea0de0330449319a5eb": "Ybodychange",
    "ea0c2b8b051a2d14927e8f314245442f30748dc8": "Ybodychange",
    "d355573f5681f43e760a1bc23ebed553bd35fca5": "Ybodychange",
    "62a9667136ebd8a048f556b534fcff4fdaf8e2ec": "Ybodychange",
    "23abb09c1f979d8c18ece81e32630a35ed569399": "Ymultichange(Yreturntypechange,Ybodychange)",
    "35f255b03b1bb5c94063ec1818af1d253ceee991": "Ybodychange",
    "574dcd34c0da1903d25e37dc5757642a584dc3d0": "Ybodychange",
    "eded3d109e4c5225d8c5cd3c2d82e7ac93841263": "Ymultichange(Ybodychange,Yparametermetachange)",
    "106234d873c60fa52cd0d812fb1cdc0c6b998a6d": "Ymultichange(Ybodychange,Yparametermetachange)",
    "e4450d47f19131818e1c040b6bd8d85ae8250475": "Ybodychange",
    "5360da8bd9f720384860f411bee081aef13b4bd4": "Ybodychange",
    "83f2f78c118a7e52aba5104bd97b0acedc96be7b": "Ybodychange",
    "93d8a7f2a2d72a1719d02b1ed90678397900b6ed": "Ybodychange",
    "a6c79f92d503c664f2d109355b719124f29a30e5": "Ybodychange",
    "42c22f7e3d6e88bf1115f617f6e803288886d1ac": "Ybodychange",
    "fc94810d3f537e51e826fc21ade7867892b9d8dc": "Ymultichange(Ybodychange,Yparametermetachange)",
    "892ade689f9bcce76daae8f66fc00a49bee8548e": "Ybodychange",
    "a9431425d1aff657fc1ea501c706235f2ebc518f": "Ybodychange",
    "5b56ac4c72d69d1b3d6feec9d96c9d62eb02d28c": "Ybodychange",
    "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5": "Ybodychange",
    "6962510f729717f776929708813f99a28e582f34": "Ybodychange",
    "3eb61be352589491117ac2781bb18f55988a8084": "Ybodychange",
    "357472001725e786f28b27560bac8aca54c3c983": "Ybodychange",
    "ead90cc1a8cd7a0f3ae28d9860ff2e3c108f1172": "Ybodychange",
    "461e614a3aa11372d18537028aa217a9d79527af": "Ybodychange",
    "aa4fe26a01d2ca881cb458d49032ce419351bed1": "Ybodychange",
    "2f478ac89cb592165ab462cd52235814507df9fe": "Ybodychange",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": "Ybodychange",
    "589c68ae09effd6c4f26505d61636f779c22e99f": "Ybodychange",
    "081eda94fec4bbf321047c93a9bb40be678b1666": "Ybodychange",
    "4283ac6d7af638ef6662810c5765bafe92704624": "Ybodychange",
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9": "Ybodychange",
    "55d3dc50d16cd5b94f542f74e5329de4c30a8655": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d1714c20e9309754397588c9b29818b9a74a80d8": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-14084. Need for more stats in DFSClient. Contributed by Pranay Singh.\"\n\nThis reverts commit 1d523279da94e199edafc8d4df23107e9c43da3e.\n",
      "commitDate": "29/01/19 3:43 PM",
      "commitName": "d1714c20e9309754397588c9b29818b9a74a80d8",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "25/01/19 9:02 AM",
      "commitNameOld": "1d523279da94e199edafc8d4df23107e9c43da3e",
      "commitAuthorOld": "Pranay Singh",
      "daysBetweenCommits": 4.28,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,84 @@\n     public Message invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n-        startTime \u003d System.currentTimeMillis();\n+        startTime \u003d Time.now();\n       }\n-\n+      \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\n             \"Too many or few parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       final Message theRequest \u003d (Message) args[1];\n       final RpcWritable.Buffer val;\n       try {\n         val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth, alignmentContext);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n-        long callTime \u003d System.currentTimeMillis() - startTime;\n-        if (callTime \u003e 0) {\n-          MetricStringBuilder rb \u003d\n-              new MetricStringBuilder(null, \"\", \" \u003d \", \"\\n\");\n-          client.updateMetrics(method.getName(), callTime);\n-          MutableRatesWithAggregation rates \u003d\n-              client.getRpcDetailedMetrics().getMutableRates();\n-          rates.snapshot(rb, true);\n-          LOG.debug(\"RPC Client stats: {}\", rb);\n-        }\n+        long callTime \u003d Time.now() - startTime;\n+        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n-\n+      \n       if (Client.isAsynchronousMode()) {\n         final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n             \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             return getReturnMessage(method, arr.get(timeout, unit));\n           }\n \n           @Override\n           public boolean isDone() {\n             return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Message invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\n            \"Too many or few parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      final Message theRequest \u003d (Message) args[1];\n      final RpcWritable.Buffer val;\n      try {\n        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth, alignmentContext);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "1d523279da94e199edafc8d4df23107e9c43da3e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14084. Need for more stats in DFSClient. Contributed by Pranay Singh.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "25/01/19 9:02 AM",
      "commitName": "1d523279da94e199edafc8d4df23107e9c43da3e",
      "commitAuthor": "Pranay Singh",
      "commitDateOld": "09/01/19 3:24 PM",
      "commitNameOld": "c634589ab2d602bf80ba513f88d44544e9bedcb5",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 15.73,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,92 @@\n     public Message invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n-        startTime \u003d Time.now();\n+        startTime \u003d System.currentTimeMillis();\n       }\n-      \n+\n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\n             \"Too many or few parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       final Message theRequest \u003d (Message) args[1];\n       final RpcWritable.Buffer val;\n       try {\n         val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth, alignmentContext);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n-        long callTime \u003d Time.now() - startTime;\n-        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n+        long callTime \u003d System.currentTimeMillis() - startTime;\n+        if (callTime \u003e 0) {\n+          MetricStringBuilder rb \u003d\n+              new MetricStringBuilder(null, \"\", \" \u003d \", \"\\n\");\n+          client.updateMetrics(method.getName(), callTime);\n+          MutableRatesWithAggregation rates \u003d\n+              client.getRpcDetailedMetrics().getMutableRates();\n+          rates.snapshot(rb, true);\n+          LOG.debug(\"RPC Client stats: {}\", rb);\n+        }\n       }\n-      \n+\n       if (Client.isAsynchronousMode()) {\n         final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n             \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             return getReturnMessage(method, arr.get(timeout, unit));\n           }\n \n           @Override\n           public boolean isDone() {\n             return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Message invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d System.currentTimeMillis();\n      }\n\n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\n            \"Too many or few parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      final Message theRequest \u003d (Message) args[1];\n      final RpcWritable.Buffer val;\n      try {\n        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth, alignmentContext);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d System.currentTimeMillis() - startTime;\n        if (callTime \u003e 0) {\n          MetricStringBuilder rb \u003d\n              new MetricStringBuilder(null, \"\", \" \u003d \", \"\\n\");\n          client.updateMetrics(method.getName(), callTime);\n          MutableRatesWithAggregation rates \u003d\n              client.getRpcDetailedMetrics().getMutableRates();\n          rates.snapshot(rb, true);\n          LOG.debug(\"RPC Client stats: {}\", rb);\n        }\n      }\n\n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "c634589ab2d602bf80ba513f88d44544e9bedcb5": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-14084. Need for more stats in DFSClient. Contributed by Pranay Singh.\"\n\nThis reverts commit ecdeaa7e6ad43555031aed032e6ba7a14a17d7bc.\n",
      "commitDate": "09/01/19 3:24 PM",
      "commitName": "c634589ab2d602bf80ba513f88d44544e9bedcb5",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "03/01/19 9:56 AM",
      "commitNameOld": "ecdeaa7e6ad43555031aed032e6ba7a14a17d7bc",
      "commitAuthorOld": "Pranay Singh",
      "daysBetweenCommits": 6.23,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,84 @@\n     public Message invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n-        startTime \u003d System.currentTimeMillis();\n+        startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\n             \"Too many or few parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       final Message theRequest \u003d (Message) args[1];\n       final RpcWritable.Buffer val;\n       try {\n         val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth, alignmentContext);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n-        long callTime \u003d System.currentTimeMillis() - startTime;\n-        if (callTime \u003e 0) {\n-          MetricStringBuilder rb \u003d\n-              new MetricStringBuilder(null, \"\", \" \u003d \", \"\\n\");\n-          client.updateMetrics(method.getName(), callTime);\n-          MutableRatesWithAggregation rates \u003d\n-              client.getRpcDetailedMetrics().getMutableRates();\n-          rates.snapshot(rb, true);\n-          LOG.debug(\"RPC Client stats: {}\", rb);\n-        }\n+        long callTime \u003d Time.now() - startTime;\n+        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n         final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n             \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             return getReturnMessage(method, arr.get(timeout, unit));\n           }\n \n           @Override\n           public boolean isDone() {\n             return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Message invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\n            \"Too many or few parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      final Message theRequest \u003d (Message) args[1];\n      final RpcWritable.Buffer val;\n      try {\n        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth, alignmentContext);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "ecdeaa7e6ad43555031aed032e6ba7a14a17d7bc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14084. Need for more stats in DFSClient. Contributed by Pranay Singh.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "03/01/19 9:56 AM",
      "commitName": "ecdeaa7e6ad43555031aed032e6ba7a14a17d7bc",
      "commitAuthor": "Pranay Singh",
      "commitDateOld": "24/12/18 9:33 AM",
      "commitNameOld": "e880660a204b6fd0e5a0799393a4d36359765a54",
      "commitAuthorOld": "Plamen Jeliazkov",
      "daysBetweenCommits": 10.02,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,92 @@\n     public Message invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n-        startTime \u003d Time.now();\n+        startTime \u003d System.currentTimeMillis();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\n             \"Too many or few parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       final Message theRequest \u003d (Message) args[1];\n       final RpcWritable.Buffer val;\n       try {\n         val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth, alignmentContext);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n-        long callTime \u003d Time.now() - startTime;\n-        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n+        long callTime \u003d System.currentTimeMillis() - startTime;\n+        if (callTime \u003e 0) {\n+          MetricStringBuilder rb \u003d\n+              new MetricStringBuilder(null, \"\", \" \u003d \", \"\\n\");\n+          client.updateMetrics(method.getName(), callTime);\n+          MutableRatesWithAggregation rates \u003d\n+              client.getRpcDetailedMetrics().getMutableRates();\n+          rates.snapshot(rb, true);\n+          LOG.debug(\"RPC Client stats: {}\", rb);\n+        }\n       }\n       \n       if (Client.isAsynchronousMode()) {\n         final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n             \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             return getReturnMessage(method, arr.get(timeout, unit));\n           }\n \n           @Override\n           public boolean isDone() {\n             return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Message invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d System.currentTimeMillis();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\n            \"Too many or few parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      final Message theRequest \u003d (Message) args[1];\n      final RpcWritable.Buffer val;\n      try {\n        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth, alignmentContext);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d System.currentTimeMillis() - startTime;\n        if (callTime \u003e 0) {\n          MetricStringBuilder rb \u003d\n              new MetricStringBuilder(null, \"\", \" \u003d \", \"\\n\");\n          client.updateMetrics(method.getName(), callTime);\n          MutableRatesWithAggregation rates \u003d\n              client.getRpcDetailedMetrics().getMutableRates();\n          rates.snapshot(rb, true);\n          LOG.debug(\"RPC Client stats: {}\", rb);\n        }\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "e880660a204b6fd0e5a0799393a4d36359765a54": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13399. [SBN read] Make Client field AlignmentContext non-static. Contributed by Plamen Jeliazkov.",
      "commitDate": "24/12/18 9:33 AM",
      "commitName": "e880660a204b6fd0e5a0799393a4d36359765a54",
      "commitAuthor": "Plamen Jeliazkov",
      "commitDateOld": "24/12/18 9:33 AM",
      "commitNameOld": "c9d73437e881296282abe46a6b3196befc8cef72",
      "commitAuthorOld": "Plamen Jeliazkov",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n     public Message invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\n             \"Too many or few parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       final Message theRequest \u003d (Message) args[1];\n       final RpcWritable.Buffer val;\n       try {\n         val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n-            fallbackToSimpleAuth);\n+            fallbackToSimpleAuth, alignmentContext);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n         final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n             \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             return getReturnMessage(method, arr.get(timeout, unit));\n           }\n \n           @Override\n           public boolean isDone() {\n             return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Message invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\n            \"Too many or few parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      final Message theRequest \u003d (Message) args[1];\n      final RpcWritable.Buffer val;\n      try {\n        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth, alignmentContext);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "2d105a206884b62ccdba61f2de3e2fe65fc43074": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-14732. ProtobufRpcEngine should use Time.monotonicNow to measure durations. Contributed by Hanisha Koneru.\"\n\nThis reverts commit 8bef4eca28a3466707cc4ea0de0330449319a5eb.\n",
      "commitDate": "18/08/17 10:15 AM",
      "commitName": "2d105a206884b62ccdba61f2de3e2fe65fc43074",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "14/08/17 3:53 PM",
      "commitNameOld": "8bef4eca28a3466707cc4ea0de0330449319a5eb",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n     public Message invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n-        startTime \u003d Time.monotonicNow();\n+        startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\n             \"Too many or few parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       final Message theRequest \u003d (Message) args[1];\n       final RpcWritable.Buffer val;\n       try {\n         val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n-        long callTime \u003d Time.monotonicNow() - startTime;\n+        long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n         final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n             \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             return getReturnMessage(method, arr.get(timeout, unit));\n           }\n \n           @Override\n           public boolean isDone() {\n             return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Message invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\n            \"Too many or few parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      final Message theRequest \u003d (Message) args[1];\n      final RpcWritable.Buffer val;\n      try {\n        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "8bef4eca28a3466707cc4ea0de0330449319a5eb": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14732. ProtobufRpcEngine should use Time.monotonicNow to measure durations. Contributed by Hanisha Koneru.\n",
      "commitDate": "14/08/17 3:53 PM",
      "commitName": "8bef4eca28a3466707cc4ea0de0330449319a5eb",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "17/07/17 9:32 PM",
      "commitNameOld": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 27.76,
      "commitsBetweenForRepo": 222,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n     public Message invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n-        startTime \u003d Time.now();\n+        startTime \u003d Time.monotonicNow();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\n             \"Too many or few parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       final Message theRequest \u003d (Message) args[1];\n       final RpcWritable.Buffer val;\n       try {\n         val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n-        long callTime \u003d Time.now() - startTime;\n+        long callTime \u003d Time.monotonicNow() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n         final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n             \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             return getReturnMessage(method, arr.get(timeout, unit));\n           }\n \n           @Override\n           public boolean isDone() {\n             return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Message invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.monotonicNow();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\n            \"Too many or few parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      final Message theRequest \u003d (Message) args[1];\n      final RpcWritable.Buffer val;\n      try {\n        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.monotonicNow() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "ea0c2b8b051a2d14927e8f314245442f30748dc8": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13218. Migrate other Hadoop side tests to prepare for removing WritableRPCEngine. Contributed by Wei Zhou and Kai Zheng\n",
      "commitDate": "14/09/16 7:46 PM",
      "commitName": "ea0c2b8b051a2d14927e8f314245442f30748dc8",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "07/09/16 2:50 PM",
      "commitNameOld": "d355573f5681f43e760a1bc23ebed553bd35fca5",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 7.21,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,84 @@\n     public Message invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n-        throw new ServiceException(\"Too many parameters for request. Method: [\"\n+        throw new ServiceException(\n+            \"Too many or few parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       final Message theRequest \u003d (Message) args[1];\n       final RpcWritable.Buffer val;\n       try {\n         val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n         final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n             \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             return getReturnMessage(method, arr.get(timeout, unit));\n           }\n \n           @Override\n           public boolean isDone() {\n             return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Message invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\n            \"Too many or few parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      final Message theRequest \u003d (Message) args[1];\n      final RpcWritable.Buffer val;\n      try {\n        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "d355573f5681f43e760a1bc23ebed553bd35fca5": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13218. Migrate other Hadoop side tests to prepare for removing WritableRPCEngine. Contributed by Wei Zhou and Kai Zheng\"\n\nThis reverts commit 62a9667136ebd8a048f556b534fcff4fdaf8e2ec\n",
      "commitDate": "07/09/16 2:50 PM",
      "commitName": "d355573f5681f43e760a1bc23ebed553bd35fca5",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "07/09/16 2:05 AM",
      "commitNameOld": "62a9667136ebd8a048f556b534fcff4fdaf8e2ec",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 0.53,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,83 @@\n     public Message invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n-        throw new ServiceException(\n-            \"Too many or few parameters for request. Method: [\"\n+        throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       final Message theRequest \u003d (Message) args[1];\n       final RpcWritable.Buffer val;\n       try {\n         val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n         final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n             \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             return getReturnMessage(method, arr.get(timeout, unit));\n           }\n \n           @Override\n           public boolean isDone() {\n             return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Message invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      final Message theRequest \u003d (Message) args[1];\n      final RpcWritable.Buffer val;\n      try {\n        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "62a9667136ebd8a048f556b534fcff4fdaf8e2ec": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13218. Migrate other Hadoop side tests to prepare for removing WritableRPCEngine. Contributed by Wei Zhou and Kai Zheng\n",
      "commitDate": "07/09/16 2:05 AM",
      "commitName": "62a9667136ebd8a048f556b534fcff4fdaf8e2ec",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "02/09/16 9:03 AM",
      "commitNameOld": "23abb09c1f979d8c18ece81e32630a35ed569399",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 4.71,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,84 @@\n     public Message invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n-        throw new ServiceException(\"Too many parameters for request. Method: [\"\n+        throw new ServiceException(\n+            \"Too many or few parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       final Message theRequest \u003d (Message) args[1];\n       final RpcWritable.Buffer val;\n       try {\n         val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n         final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n             \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             return getReturnMessage(method, arr.get(timeout, unit));\n           }\n \n           @Override\n           public boolean isDone() {\n             return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Message invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\n            \"Too many or few parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      final Message theRequest \u003d (Message) args[1];\n      final RpcWritable.Buffer val;\n      try {\n        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "23abb09c1f979d8c18ece81e32630a35ed569399": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HADOOP-13547. Optimize IPC client protobuf decoding. Contributed by Daryn Sharp.\n",
      "commitDate": "02/09/16 9:03 AM",
      "commitName": "23abb09c1f979d8c18ece81e32630a35ed569399",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-13547. Optimize IPC client protobuf decoding. Contributed by Daryn Sharp.\n",
          "commitDate": "02/09/16 9:03 AM",
          "commitName": "23abb09c1f979d8c18ece81e32630a35ed569399",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "09/08/16 12:33 PM",
          "commitNameOld": "caf800d5290d8618003b764afb0b3ef8d9a5a0a8",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 23.85,
          "commitsBetweenForRepo": 162,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,83 +1,83 @@\n-    public Object invoke(Object proxy, final Method method, Object[] args)\n+    public Message invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n-      Message theRequest \u003d (Message) args[1];\n-      final RpcResponseWrapper val;\n+      final Message theRequest \u003d (Message) args[1];\n+      final RpcWritable.Buffer val;\n       try {\n-        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n-            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n+        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n+            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n-        final AsyncGet\u003cRpcResponseWrapper, IOException\u003e arr\n+        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n             \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             return getReturnMessage(method, arr.get(timeout, unit));\n           }\n \n           @Override\n           public boolean isDone() {\n             return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Message invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      final Message theRequest \u003d (Message) args[1];\n      final RpcWritable.Buffer val;\n      try {\n        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {
            "oldValue": "Object",
            "newValue": "Message"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13547. Optimize IPC client protobuf decoding. Contributed by Daryn Sharp.\n",
          "commitDate": "02/09/16 9:03 AM",
          "commitName": "23abb09c1f979d8c18ece81e32630a35ed569399",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "09/08/16 12:33 PM",
          "commitNameOld": "caf800d5290d8618003b764afb0b3ef8d9a5a0a8",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 23.85,
          "commitsBetweenForRepo": 162,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,83 +1,83 @@\n-    public Object invoke(Object proxy, final Method method, Object[] args)\n+    public Message invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n-      Message theRequest \u003d (Message) args[1];\n-      final RpcResponseWrapper val;\n+      final Message theRequest \u003d (Message) args[1];\n+      final RpcWritable.Buffer val;\n       try {\n-        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n-            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n+        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n+            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n-        final AsyncGet\u003cRpcResponseWrapper, IOException\u003e arr\n+        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n             \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             return getReturnMessage(method, arr.get(timeout, unit));\n           }\n \n           @Override\n           public boolean isDone() {\n             return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Message invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      final Message theRequest \u003d (Message) args[1];\n      final RpcWritable.Buffer val;\n      try {\n        val \u003d (RpcWritable.Buffer) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcProtobufRequest(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcWritable.Buffer, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {}
        }
      ]
    },
    "35f255b03b1bb5c94063ec1818af1d253ceee991": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Revert \"HADOOP-13226 Support async call retry and failover.\"\"\n\nThis reverts commit 5360da8bd9f720384860f411bee081aef13b4bd4.\n",
      "commitDate": "06/06/16 1:31 AM",
      "commitName": "35f255b03b1bb5c94063ec1818af1d253ceee991",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "06/06/16 1:31 AM",
      "commitNameOld": "574dcd34c0da1903d25e37dc5757642a584dc3d0",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,83 @@\n     public Object invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n-        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n+        final AsyncGet\u003cRpcResponseWrapper, IOException\u003e arr\n+            \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n-            final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n-                frrw.get(): frrw.get(timeout, unit);\n-            return getReturnMessage(method, rrw);\n+            return getReturnMessage(method, arr.get(timeout, unit));\n+          }\n+\n+          @Override\n+          public boolean isDone() {\n+            return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcResponseWrapper, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "574dcd34c0da1903d25e37dc5757642a584dc3d0": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Revert \"HADOOP-13168. Support Future.get with timeout in ipc async calls.\"\"\n\nThis reverts commit e4450d47f19131818e1c040b6bd8d85ae8250475.\n",
      "commitDate": "06/06/16 1:31 AM",
      "commitName": "574dcd34c0da1903d25e37dc5757642a584dc3d0",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "06/06/16 1:28 AM",
      "commitNameOld": "eded3d109e4c5225d8c5cd3c2d82e7ac93841263",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,79 @@\n     public Object invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n-        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n-        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n+        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n+        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n+            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n-          public Message call() throws Exception {\n-            return getReturnMessage(method, frrw.get());\n+          public Message get(long timeout, TimeUnit unit) throws Exception {\n+            final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n+                frrw.get(): frrw.get(timeout, unit);\n+            return getReturnMessage(method, rrw);\n           }\n         };\n-        RETURN_MESSAGE_CALLBACK.set(callback);\n+        ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n                frrw.get(): frrw.get(timeout, unit);\n            return getReturnMessage(method, rrw);\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "eded3d109e4c5225d8c5cd3c2d82e7ac93841263": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "Revert \"Revert \"HDFS-10224. Implement asynchronous rename for DistributedFileSystem.  Contributed by Xiaobing Zhou\"\"\n\nThis reverts commit 106234d873c60fa52cd0d812fb1cdc0c6b998a6d.\n",
      "commitDate": "06/06/16 1:28 AM",
      "commitName": "eded3d109e4c5225d8c5cd3c2d82e7ac93841263",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Revert \"Revert \"HDFS-10224. Implement asynchronous rename for DistributedFileSystem.  Contributed by Xiaobing Zhou\"\"\n\nThis reverts commit 106234d873c60fa52cd0d812fb1cdc0c6b998a6d.\n",
          "commitDate": "06/06/16 1:28 AM",
          "commitName": "eded3d109e4c5225d8c5cd3c2d82e7ac93841263",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "03/06/16 6:09 PM",
          "commitNameOld": "106234d873c60fa52cd0d812fb1cdc0c6b998a6d",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.3,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,76 @@\n-    public Object invoke(Object proxy, Method method, Object[] args)\n+    public Object invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n-      Message prototype \u003d null;\n-      try {\n-        prototype \u003d getReturnProtoType(method);\n-      } catch (Exception e) {\n-        throw new ServiceException(e);\n+      if (Client.isAsynchronousMode()) {\n+        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n+        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n+          @Override\n+          public Message call() throws Exception {\n+            return getReturnMessage(method, frrw.get());\n+          }\n+        };\n+        RETURN_MESSAGE_CALLBACK.set(callback);\n+        return null;\n+      } else {\n+        return getReturnMessage(method, val);\n       }\n-      Message returnMessage;\n-      try {\n-        returnMessage \u003d prototype.newBuilderForType()\n-            .mergeFrom(val.theResponseRead).build();\n-\n-        if (LOG.isTraceEnabled()) {\n-          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n-              remoteId + \": \" + method.getName() +\n-                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n-        }\n-\n-      } catch (Throwable e) {\n-        throw new ServiceException(e);\n-      }\n-      return returnMessage;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Object invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n          @Override\n          public Message call() throws Exception {\n            return getReturnMessage(method, frrw.get());\n          }\n        };\n        RETURN_MESSAGE_CALLBACK.set(callback);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "Revert \"Revert \"HDFS-10224. Implement asynchronous rename for DistributedFileSystem.  Contributed by Xiaobing Zhou\"\"\n\nThis reverts commit 106234d873c60fa52cd0d812fb1cdc0c6b998a6d.\n",
          "commitDate": "06/06/16 1:28 AM",
          "commitName": "eded3d109e4c5225d8c5cd3c2d82e7ac93841263",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "03/06/16 6:09 PM",
          "commitNameOld": "106234d873c60fa52cd0d812fb1cdc0c6b998a6d",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.3,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,76 @@\n-    public Object invoke(Object proxy, Method method, Object[] args)\n+    public Object invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n-      Message prototype \u003d null;\n-      try {\n-        prototype \u003d getReturnProtoType(method);\n-      } catch (Exception e) {\n-        throw new ServiceException(e);\n+      if (Client.isAsynchronousMode()) {\n+        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n+        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n+          @Override\n+          public Message call() throws Exception {\n+            return getReturnMessage(method, frrw.get());\n+          }\n+        };\n+        RETURN_MESSAGE_CALLBACK.set(callback);\n+        return null;\n+      } else {\n+        return getReturnMessage(method, val);\n       }\n-      Message returnMessage;\n-      try {\n-        returnMessage \u003d prototype.newBuilderForType()\n-            .mergeFrom(val.theResponseRead).build();\n-\n-        if (LOG.isTraceEnabled()) {\n-          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n-              remoteId + \": \" + method.getName() +\n-                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n-        }\n-\n-      } catch (Throwable e) {\n-        throw new ServiceException(e);\n-      }\n-      return returnMessage;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Object invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n          @Override\n          public Message call() throws Exception {\n            return getReturnMessage(method, frrw.get());\n          }\n        };\n        RETURN_MESSAGE_CALLBACK.set(callback);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {
            "oldValue": "[proxy-Object, method-Method, args-Object[]]",
            "newValue": "[proxy-Object, method-Method(modifiers-final), args-Object[]]"
          }
        }
      ]
    },
    "106234d873c60fa52cd0d812fb1cdc0c6b998a6d": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "Revert \"HDFS-10224. Implement asynchronous rename for DistributedFileSystem.  Contributed by Xiaobing Zhou\"\n\nThis reverts commit fc94810d3f537e51e826fc21ade7867892b9d8dc.\n",
      "commitDate": "03/06/16 6:09 PM",
      "commitName": "106234d873c60fa52cd0d812fb1cdc0c6b998a6d",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "Revert \"HDFS-10224. Implement asynchronous rename for DistributedFileSystem.  Contributed by Xiaobing Zhou\"\n\nThis reverts commit fc94810d3f537e51e826fc21ade7867892b9d8dc.\n",
          "commitDate": "03/06/16 6:09 PM",
          "commitName": "106234d873c60fa52cd0d812fb1cdc0c6b998a6d",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "03/06/16 6:09 PM",
          "commitNameOld": "e4450d47f19131818e1c040b6bd8d85ae8250475",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,76 +1,84 @@\n-    public Object invoke(Object proxy, final Method method, Object[] args)\n+    public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n-      if (Client.isAsynchronousMode()) {\n-        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n-        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n-          @Override\n-          public Message call() throws Exception {\n-            return getReturnMessage(method, frrw.get());\n-          }\n-        };\n-        RETURN_MESSAGE_CALLBACK.set(callback);\n-        return null;\n-      } else {\n-        return getReturnMessage(method, val);\n+      Message prototype \u003d null;\n+      try {\n+        prototype \u003d getReturnProtoType(method);\n+      } catch (Exception e) {\n+        throw new ServiceException(e);\n       }\n+      Message returnMessage;\n+      try {\n+        returnMessage \u003d prototype.newBuilderForType()\n+            .mergeFrom(val.theResponseRead).build();\n+\n+        if (LOG.isTraceEnabled()) {\n+          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n+              remoteId + \": \" + method.getName() +\n+                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n+        }\n+\n+      } catch (Throwable e) {\n+        throw new ServiceException(e);\n+      }\n+      return returnMessage;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.theResponseRead).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "Revert \"HDFS-10224. Implement asynchronous rename for DistributedFileSystem.  Contributed by Xiaobing Zhou\"\n\nThis reverts commit fc94810d3f537e51e826fc21ade7867892b9d8dc.\n",
          "commitDate": "03/06/16 6:09 PM",
          "commitName": "106234d873c60fa52cd0d812fb1cdc0c6b998a6d",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "03/06/16 6:09 PM",
          "commitNameOld": "e4450d47f19131818e1c040b6bd8d85ae8250475",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,76 +1,84 @@\n-    public Object invoke(Object proxy, final Method method, Object[] args)\n+    public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n-      if (Client.isAsynchronousMode()) {\n-        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n-        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n-          @Override\n-          public Message call() throws Exception {\n-            return getReturnMessage(method, frrw.get());\n-          }\n-        };\n-        RETURN_MESSAGE_CALLBACK.set(callback);\n-        return null;\n-      } else {\n-        return getReturnMessage(method, val);\n+      Message prototype \u003d null;\n+      try {\n+        prototype \u003d getReturnProtoType(method);\n+      } catch (Exception e) {\n+        throw new ServiceException(e);\n       }\n+      Message returnMessage;\n+      try {\n+        returnMessage \u003d prototype.newBuilderForType()\n+            .mergeFrom(val.theResponseRead).build();\n+\n+        if (LOG.isTraceEnabled()) {\n+          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n+              remoteId + \": \" + method.getName() +\n+                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n+        }\n+\n+      } catch (Throwable e) {\n+        throw new ServiceException(e);\n+      }\n+      return returnMessage;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.theResponseRead).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {
            "oldValue": "[proxy-Object, method-Method(modifiers-final), args-Object[]]",
            "newValue": "[proxy-Object, method-Method, args-Object[]]"
          }
        }
      ]
    },
    "e4450d47f19131818e1c040b6bd8d85ae8250475": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13168. Support Future.get with timeout in ipc async calls.\"\n\nThis reverts commit 42c22f7e3d6e88bf1115f617f6e803288886d1ac.\n",
      "commitDate": "03/06/16 6:09 PM",
      "commitName": "e4450d47f19131818e1c040b6bd8d85ae8250475",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "03/06/16 6:09 PM",
      "commitNameOld": "5360da8bd9f720384860f411bee081aef13b4bd4",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,76 @@\n     public Object invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n-        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n-        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n-            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n+        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n+        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n           @Override\n-          public Message get(long timeout, TimeUnit unit) throws Exception {\n-            final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n-                frrw.get(): frrw.get(timeout, unit);\n-            return getReturnMessage(method, rrw);\n+          public Message call() throws Exception {\n+            return getReturnMessage(method, frrw.get());\n           }\n         };\n-        ASYNC_RETURN_MESSAGE.set(asyncGet);\n+        RETURN_MESSAGE_CALLBACK.set(callback);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n          @Override\n          public Message call() throws Exception {\n            return getReturnMessage(method, frrw.get());\n          }\n        };\n        RETURN_MESSAGE_CALLBACK.set(callback);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "5360da8bd9f720384860f411bee081aef13b4bd4": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13226 Support async call retry and failover.\"\n\nThis reverts commit 83f2f78c118a7e52aba5104bd97b0acedc96be7b.\n",
      "commitDate": "03/06/16 6:09 PM",
      "commitName": "5360da8bd9f720384860f411bee081aef13b4bd4",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "31/05/16 4:30 PM",
      "commitNameOld": "83f2f78c118a7e52aba5104bd97b0acedc96be7b",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 3.07,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,79 @@\n     public Object invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n-        final AsyncGet\u003cRpcResponseWrapper, IOException\u003e arr\n-            \u003d Client.getAsyncRpcResponse();\n+        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n-            return getReturnMessage(method, arr.get(timeout, unit));\n-          }\n-\n-          @Override\n-          public boolean isDone() {\n-            return arr.isDone();\n+            final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n+                frrw.get(): frrw.get(timeout, unit);\n+            return getReturnMessage(method, rrw);\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n                frrw.get(): frrw.get(timeout, unit);\n            return getReturnMessage(method, rrw);\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "83f2f78c118a7e52aba5104bd97b0acedc96be7b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13226 Support async call retry and failover.\n",
      "commitDate": "31/05/16 4:30 PM",
      "commitName": "83f2f78c118a7e52aba5104bd97b0acedc96be7b",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "31/05/16 5:41 PM",
      "commitNameOld": "93d8a7f2a2d72a1719d02b1ed90678397900b6ed",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": -0.05,
      "commitsBetweenForRepo": 0,
      "commitsBetweenForFile": 0,
      "diff": "@@ -1,79 +1,83 @@\n     public Object invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n-        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n+        final AsyncGet\u003cRpcResponseWrapper, IOException\u003e arr\n+            \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n-            final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n-                frrw.get(): frrw.get(timeout, unit);\n-            return getReturnMessage(method, rrw);\n+            return getReturnMessage(method, arr.get(timeout, unit));\n+          }\n+\n+          @Override\n+          public boolean isDone() {\n+            return arr.isDone();\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final AsyncGet\u003cRpcResponseWrapper, IOException\u003e arr\n            \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            return getReturnMessage(method, arr.get(timeout, unit));\n          }\n\n          @Override\n          public boolean isDone() {\n            return arr.isDone();\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "93d8a7f2a2d72a1719d02b1ed90678397900b6ed": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-12579. Deprecate and remove WriteableRPCEngine. Contributed by Kai Zheng\"\n\nThis reverts commit a6c79f92d503c664f2d109355b719124f29a30e5.\n",
      "commitDate": "31/05/16 5:41 PM",
      "commitName": "93d8a7f2a2d72a1719d02b1ed90678397900b6ed",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "26/05/16 1:29 PM",
      "commitNameOld": "a6c79f92d503c664f2d109355b719124f29a30e5",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 5.17,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,79 @@\n     public Object invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n-        throw new ServiceException(\n-            \"Too many or few parameters for request. Method: [\"\n+        throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n         final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n                 frrw.get(): frrw.get(timeout, unit);\n             return getReturnMessage(method, rrw);\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n                frrw.get(): frrw.get(timeout, unit);\n            return getReturnMessage(method, rrw);\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "a6c79f92d503c664f2d109355b719124f29a30e5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12579. Deprecate and remove WriteableRPCEngine. Contributed by Kai Zheng\n",
      "commitDate": "26/05/16 1:29 PM",
      "commitName": "a6c79f92d503c664f2d109355b719124f29a30e5",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "19/05/16 3:34 PM",
      "commitNameOld": "42c22f7e3d6e88bf1115f617f6e803288886d1ac",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 6.91,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,80 @@\n     public Object invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n-        throw new ServiceException(\"Too many parameters for request. Method: [\"\n+        throw new ServiceException(\n+            \"Too many or few parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n         final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n         final AsyncGet\u003cMessage, Exception\u003e asyncGet\n             \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n           public Message get(long timeout, TimeUnit unit) throws Exception {\n             final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n                 frrw.get(): frrw.get(timeout, unit);\n             return getReturnMessage(method, rrw);\n           }\n         };\n         ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\n            \"Too many or few parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n                frrw.get(): frrw.get(timeout, unit);\n            return getReturnMessage(method, rrw);\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "42c22f7e3d6e88bf1115f617f6e803288886d1ac": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13168. Support Future.get with timeout in ipc async calls.\n",
      "commitDate": "19/05/16 3:34 PM",
      "commitName": "42c22f7e3d6e88bf1115f617f6e803288886d1ac",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "26/04/16 5:10 PM",
      "commitNameOld": "fc94810d3f537e51e826fc21ade7867892b9d8dc",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 22.93,
      "commitsBetweenForRepo": 163,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,79 @@\n     public Object invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       if (Client.isAsynchronousMode()) {\n-        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n-        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n+        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n+        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n+            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n           @Override\n-          public Message call() throws Exception {\n-            return getReturnMessage(method, frrw.get());\n+          public Message get(long timeout, TimeUnit unit) throws Exception {\n+            final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n+                frrw.get(): frrw.get(timeout, unit);\n+            return getReturnMessage(method, rrw);\n           }\n         };\n-        RETURN_MESSAGE_CALLBACK.set(callback);\n+        ASYNC_RETURN_MESSAGE.set(asyncGet);\n         return null;\n       } else {\n         return getReturnMessage(method, val);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getAsyncRpcResponse();\n        final AsyncGet\u003cMessage, Exception\u003e asyncGet\n            \u003d new AsyncGet\u003cMessage, Exception\u003e() {\n          @Override\n          public Message get(long timeout, TimeUnit unit) throws Exception {\n            final RpcResponseWrapper rrw \u003d timeout \u003c 0?\n                frrw.get(): frrw.get(timeout, unit);\n            return getReturnMessage(method, rrw);\n          }\n        };\n        ASYNC_RETURN_MESSAGE.set(asyncGet);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "fc94810d3f537e51e826fc21ade7867892b9d8dc": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "HDFS-10224. Implement asynchronous rename for DistributedFileSystem.  Contributed by Xiaobing Zhou\n",
      "commitDate": "26/04/16 5:10 PM",
      "commitName": "fc94810d3f537e51e826fc21ade7867892b9d8dc",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10224. Implement asynchronous rename for DistributedFileSystem.  Contributed by Xiaobing Zhou\n",
          "commitDate": "26/04/16 5:10 PM",
          "commitName": "fc94810d3f537e51e826fc21ade7867892b9d8dc",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "31/03/16 8:42 AM",
          "commitNameOld": "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc",
          "commitAuthorOld": "Xiaoyu Yao",
          "daysBetweenCommits": 26.35,
          "commitsBetweenForRepo": 164,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,76 @@\n-    public Object invoke(Object proxy, Method method, Object[] args)\n+    public Object invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n-      Message prototype \u003d null;\n-      try {\n-        prototype \u003d getReturnProtoType(method);\n-      } catch (Exception e) {\n-        throw new ServiceException(e);\n+      if (Client.isAsynchronousMode()) {\n+        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n+        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n+          @Override\n+          public Message call() throws Exception {\n+            return getReturnMessage(method, frrw.get());\n+          }\n+        };\n+        RETURN_MESSAGE_CALLBACK.set(callback);\n+        return null;\n+      } else {\n+        return getReturnMessage(method, val);\n       }\n-      Message returnMessage;\n-      try {\n-        returnMessage \u003d prototype.newBuilderForType()\n-            .mergeFrom(val.theResponseRead).build();\n-\n-        if (LOG.isTraceEnabled()) {\n-          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n-              remoteId + \": \" + method.getName() +\n-                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n-        }\n-\n-      } catch (Throwable e) {\n-        throw new ServiceException(e);\n-      }\n-      return returnMessage;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Object invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n          @Override\n          public Message call() throws Exception {\n            return getReturnMessage(method, frrw.get());\n          }\n        };\n        RETURN_MESSAGE_CALLBACK.set(callback);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HDFS-10224. Implement asynchronous rename for DistributedFileSystem.  Contributed by Xiaobing Zhou\n",
          "commitDate": "26/04/16 5:10 PM",
          "commitName": "fc94810d3f537e51e826fc21ade7867892b9d8dc",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "31/03/16 8:42 AM",
          "commitNameOld": "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc",
          "commitAuthorOld": "Xiaoyu Yao",
          "daysBetweenCommits": 26.35,
          "commitsBetweenForRepo": 164,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,76 @@\n-    public Object invoke(Object proxy, Method method, Object[] args)\n+    public Object invoke(Object proxy, final Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       Tracer tracer \u003d Tracer.curThreadTracer();\n       TraceScope traceScope \u003d null;\n       if (tracer !\u003d null) {\n         traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (traceScope !\u003d null) {\n           traceScope.addTimelineAnnotation(\"Call got exception: \" +\n               e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n-      Message prototype \u003d null;\n-      try {\n-        prototype \u003d getReturnProtoType(method);\n-      } catch (Exception e) {\n-        throw new ServiceException(e);\n+      if (Client.isAsynchronousMode()) {\n+        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n+        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n+          @Override\n+          public Message call() throws Exception {\n+            return getReturnMessage(method, frrw.get());\n+          }\n+        };\n+        RETURN_MESSAGE_CALLBACK.set(callback);\n+        return null;\n+      } else {\n+        return getReturnMessage(method, val);\n       }\n-      Message returnMessage;\n-      try {\n-        returnMessage \u003d prototype.newBuilderForType()\n-            .mergeFrom(val.theResponseRead).build();\n-\n-        if (LOG.isTraceEnabled()) {\n-          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n-              remoteId + \": \" + method.getName() +\n-                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n-        }\n-\n-      } catch (Throwable e) {\n-        throw new ServiceException(e);\n-      }\n-      return returnMessage;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public Object invoke(Object proxy, final Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      if (Client.isAsynchronousMode()) {\n        final Future\u003cRpcResponseWrapper\u003e frrw \u003d Client.getReturnRpcResponse();\n        Callable\u003cMessage\u003e callback \u003d new Callable\u003cMessage\u003e() {\n          @Override\n          public Message call() throws Exception {\n            return getReturnMessage(method, frrw.get());\n          }\n        };\n        RETURN_MESSAGE_CALLBACK.set(callback);\n        return null;\n      } else {\n        return getReturnMessage(method, val);\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
          "extendedDetails": {
            "oldValue": "[proxy-Object, method-Method, args-Object[]]",
            "newValue": "[proxy-Object, method-Method(modifiers-final), args-Object[]]"
          }
        }
      ]
    },
    "892ade689f9bcce76daae8f66fc00a49bee8548e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9080. Update htrace version to 4.0.1 (cmccabe)\n",
      "commitDate": "28/09/15 7:42 AM",
      "commitName": "892ade689f9bcce76daae8f66fc00a49bee8548e",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "24/08/15 2:31 PM",
      "commitNameOld": "48774d0a45d95557affbd6bbaf8035cc9575ef36",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 34.72,
      "commitsBetweenForRepo": 222,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,84 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n-      TraceScope traceScope \u003d null;\n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n-      if (Trace.isTracing()) {\n-        traceScope \u003d Trace.startSpan(RpcClientUtil.methodToTraceString(method));\n+      Tracer tracer \u003d Tracer.curThreadTracer();\n+      TraceScope traceScope \u003d null;\n+      if (tracer !\u003d null) {\n+        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n-        if (Trace.isTracing()) {\n-          traceScope.getSpan().addTimelineAnnotation(\n-              \"Call got exception: \" + e.toString());\n+        if (traceScope !\u003d null) {\n+          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n+              e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(val.theResponseRead).build();\n \n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n         }\n \n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      Tracer tracer \u003d Tracer.curThreadTracer();\n      TraceScope traceScope \u003d null;\n      if (tracer !\u003d null) {\n        traceScope \u003d tracer.newScope(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (traceScope !\u003d null) {\n          traceScope.addTimelineAnnotation(\"Call got exception: \" +\n              e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.theResponseRead).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "a9431425d1aff657fc1ea501c706235f2ebc518f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12051. ProtobufRpcEngine.invoke() should use Exception.toString()  over getMessage() in logging/span events. (Varun Saxena via stevel)\n",
      "commitDate": "20/07/15 5:13 AM",
      "commitName": "a9431425d1aff657fc1ea501c706235f2ebc518f",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "30/01/15 4:01 PM",
      "commitNameOld": "09ad9a868a89922e9b55b3e7c5b9f41fa54d3770",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 170.51,
      "commitsBetweenForRepo": 1473,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,83 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       TraceScope traceScope \u003d null;\n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       if (Trace.isTracing()) {\n         traceScope \u003d Trace.startSpan(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (Trace.isTracing()) {\n           traceScope.getSpan().addTimelineAnnotation(\n-              \"Call got exception: \" + e.getMessage());\n+              \"Call got exception: \" + e.toString());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(val.theResponseRead).build();\n \n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n         }\n \n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      TraceScope traceScope \u003d null;\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      if (Trace.isTracing()) {\n        traceScope \u003d Trace.startSpan(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (Trace.isTracing()) {\n          traceScope.getSpan().addTimelineAnnotation(\n              \"Call got exception: \" + e.toString());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.theResponseRead).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "5b56ac4c72d69d1b3d6feec9d96c9d62eb02d28c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7223. Tracing span description of IPC client is too long (iwasakims via cmccabe)\n",
      "commitDate": "23/10/14 7:14 PM",
      "commitName": "5b56ac4c72d69d1b3d6feec9d96c9d62eb02d28c",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "19/09/14 9:23 PM",
      "commitNameOld": "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 33.91,
      "commitsBetweenForRepo": 313,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,83 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       TraceScope traceScope \u003d null;\n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       if (Trace.isTracing()) {\n-        traceScope \u003d Trace.startSpan(\n-            method.getDeclaringClass().getCanonicalName() +\n-            \".\" + method.getName());\n+        traceScope \u003d Trace.startSpan(RpcClientUtil.methodToTraceString(method));\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n             fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (Trace.isTracing()) {\n           traceScope.getSpan().addTimelineAnnotation(\n               \"Call got exception: \" + e.getMessage());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(val.theResponseRead).build();\n \n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n         }\n \n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      TraceScope traceScope \u003d null;\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      if (Trace.isTracing()) {\n        traceScope \u003d Trace.startSpan(RpcClientUtil.methodToTraceString(method));\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (Trace.isTracing()) {\n          traceScope.getSpan().addTimelineAnnotation(\n              \"Call got exception: \" + e.getMessage());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.theResponseRead).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7073. Allow falling back to a non-SASL connection on DataTransferProtocol in several edge cases. Contributed by Chris Nauroth.\n",
      "commitDate": "19/09/14 9:23 PM",
      "commitName": "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5",
      "commitAuthor": "cnauroth",
      "commitDateOld": "27/08/14 2:12 PM",
      "commitNameOld": "6962510f729717f776929708813f99a28e582f34",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 23.3,
      "commitsBetweenForRepo": 247,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,85 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       TraceScope traceScope \u003d null;\n       // if Tracing is on then start a new span for this rpc.\n       // guard it in the if statement to make sure there isn\u0027t\n       // any extra string manipulation.\n       if (Trace.isTracing()) {\n         traceScope \u003d Trace.startSpan(\n             method.getDeclaringClass().getCanonicalName() +\n             \".\" + method.getName());\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n-            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId);\n+            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n+            fallbackToSimpleAuth);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n         if (Trace.isTracing()) {\n           traceScope.getSpan().addTimelineAnnotation(\n               \"Call got exception: \" + e.getMessage());\n         }\n         throw new ServiceException(e);\n       } finally {\n         if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(val.theResponseRead).build();\n \n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n         }\n \n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      TraceScope traceScope \u003d null;\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      if (Trace.isTracing()) {\n        traceScope \u003d Trace.startSpan(\n            method.getDeclaringClass().getCanonicalName() +\n            \".\" + method.getName());\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (Trace.isTracing()) {\n          traceScope.getSpan().addTimelineAnnotation(\n              \"Call got exception: \" + e.getMessage());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.theResponseRead).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "6962510f729717f776929708813f99a28e582f34": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6879. Adding tracing to Hadoop RPC.  Contributed by Masatake Iwasaki.\n",
      "commitDate": "27/08/14 2:12 PM",
      "commitName": "6962510f729717f776929708813f99a28e582f34",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "15/07/14 4:05 PM",
      "commitNameOld": "790ee456439729073d75ccf91e1f63b3d360b1c7",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 42.92,
      "commitsBetweenForRepo": 361,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,84 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n+      TraceScope traceScope \u003d null;\n+      // if Tracing is on then start a new span for this rpc.\n+      // guard it in the if statement to make sure there isn\u0027t\n+      // any extra string manipulation.\n+      if (Trace.isTracing()) {\n+        traceScope \u003d Trace.startSpan(\n+            method.getDeclaringClass().getCanonicalName() +\n+            \".\" + method.getName());\n+      }\n+\n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n-\n+        if (Trace.isTracing()) {\n+          traceScope.getSpan().addTimelineAnnotation(\n+              \"Call got exception: \" + e.getMessage());\n+        }\n         throw new ServiceException(e);\n+      } finally {\n+        if (traceScope !\u003d null) traceScope.close();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(val.theResponseRead).build();\n \n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n         }\n \n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      TraceScope traceScope \u003d null;\n      // if Tracing is on then start a new span for this rpc.\n      // guard it in the if statement to make sure there isn\u0027t\n      // any extra string manipulation.\n      if (Trace.isTracing()) {\n        traceScope \u003d Trace.startSpan(\n            method.getDeclaringClass().getCanonicalName() +\n            \".\" + method.getName());\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        if (Trace.isTracing()) {\n          traceScope.getSpan().addTimelineAnnotation(\n              \"Call got exception: \" + e.getMessage());\n        }\n        throw new ServiceException(e);\n      } finally {\n        if (traceScope !\u003d null) traceScope.close();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.theResponseRead).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "3eb61be352589491117ac2781bb18f55988a8084": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9754. Remove unnecessary \"throws IOException/InterruptedException\", and fix generic and other javac warnings.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505610 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/13 12:22 AM",
      "commitName": "3eb61be352589491117ac2781bb18f55988a8084",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "17/07/13 9:42 PM",
      "commitNameOld": "7ec67c5118e8d13e2cb0ab09d04f0609b645a676",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 4.11,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,69 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n-      RpcResponseWrapper val \u003d null;\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n+      final RpcResponseWrapper val;\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n \n         throw new ServiceException(e);\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(val.theResponseRead).build();\n \n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n         }\n \n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n\n        throw new ServiceException(e);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.theResponseRead).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "357472001725e786f28b27560bac8aca54c3c983": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9380 Add totalLength to rpc response  (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459392 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/13 9:41 AM",
      "commitName": "357472001725e786f28b27560bac8aca54c3c983",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "04/03/13 2:55 PM",
      "commitNameOld": "ead90cc1a8cd7a0f3ae28d9860ff2e3c108f1172",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 16.74,
      "commitsBetweenForRepo": 93,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,69 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n       \n       if (args.length !\u003d 2) { // RpcController + Message\n         throw new ServiceException(\"Too many parameters for request. Method: [\"\n             + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n             + args.length);\n       }\n       if (args[1] \u003d\u003d null) {\n         throw new ServiceException(\"null param while calling Method: [\"\n             + method.getName() + \"]\");\n       }\n \n       RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       RpcResponseWrapper val \u003d null;\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n \n \n       Message theRequest \u003d (Message) args[1];\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n \n         throw new ServiceException(e);\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n-            .mergeFrom(val.responseMessage).build();\n+            .mergeFrom(val.theResponseRead).build();\n \n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n         }\n \n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      RpcResponseWrapper val \u003d null;\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n\n        throw new ServiceException(e);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.theResponseRead).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "ead90cc1a8cd7a0f3ae28d9860ff2e3c108f1172": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9163 The rpc msg in ProtobufRpcEngine.proto should be moved out to avoid an extra copy (Sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1452581 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/03/13 2:55 PM",
      "commitName": "ead90cc1a8cd7a0f3ae28d9860ff2e3c108f1172",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "14/02/13 6:26 PM",
      "commitNameOld": "461e614a3aa11372d18537028aa217a9d79527af",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 17.85,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,69 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n+      \n+      if (args.length !\u003d 2) { // RpcController + Message\n+        throw new ServiceException(\"Too many parameters for request. Method: [\"\n+            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n+            + args.length);\n+      }\n+      if (args[1] \u003d\u003d null) {\n+        throw new ServiceException(\"null param while calling Method: [\"\n+            + method.getName() + \"]\");\n+      }\n \n-      RequestProto rpcRequest \u003d constructRpcRequest(method, args);\n+      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n       RpcResponseWrapper val \u003d null;\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n+\n+\n+      Message theRequest \u003d (Message) args[1];\n       try {\n         val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n-            new RpcRequestWrapper(rpcRequest), remoteId);\n+            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n \n         throw new ServiceException(e);\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(val.responseMessage).build();\n \n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n         }\n \n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n      \n      if (args.length !\u003d 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] \u003d\u003d null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n\n      RequestHeaderProto rpcRequestHeader \u003d constructRpcRequestHeader(method);\n      RpcResponseWrapper val \u003d null;\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n\n\n      Message theRequest \u003d (Message) args[1];\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n\n        throw new ServiceException(e);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.responseMessage).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "461e614a3aa11372d18537028aa217a9d79527af": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9218 Document the Rpc-wrappers used internally (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1446428 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/02/13 6:26 PM",
      "commitName": "461e614a3aa11372d18537028aa217a9d79527af",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "17/12/12 2:16 PM",
      "commitNameOld": "aa4fe26a01d2ca881cb458d49032ce419351bed1",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 59.17,
      "commitsBetweenForRepo": 271,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n \n       RequestProto rpcRequest \u003d constructRpcRequest(method, args);\n-      RpcResponseWritable val \u003d null;\n+      RpcResponseWrapper val \u003d null;\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n       try {\n-        val \u003d (RpcResponseWritable) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n-            new RpcRequestWritable(rpcRequest), remoteId);\n+        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n+            new RpcRequestWrapper(rpcRequest), remoteId);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n \n         throw new ServiceException(e);\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(val.responseMessage).build();\n \n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n         }\n \n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n\n      RequestProto rpcRequest \u003d constructRpcRequest(method, args);\n      RpcResponseWrapper val \u003d null;\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n      try {\n        val \u003d (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequest), remoteId);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n\n        throw new ServiceException(e);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.responseMessage).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "aa4fe26a01d2ca881cb458d49032ce419351bed1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9140 Cleanup rpc PB protos (sanjay Radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1423189 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/12/12 2:16 PM",
      "commitName": "aa4fe26a01d2ca881cb458d49032ce419351bed1",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "24/08/12 6:03 PM",
      "commitNameOld": "deead78e35b0cb81af875b5a8032cbd06c9a2dae",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 114.88,
      "commitsBetweenForRepo": 607,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n \n-      HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n+      RequestProto rpcRequest \u003d constructRpcRequest(method, args);\n       RpcResponseWritable val \u003d null;\n       \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n             remoteId + \": \" + method.getName() +\n             \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n       }\n       try {\n         val \u003d (RpcResponseWritable) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWritable(rpcRequest), remoteId);\n \n       } catch (Throwable e) {\n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + e + \"}\");\n         }\n \n         throw new ServiceException(e);\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(val.responseMessage).build();\n \n         if (LOG.isTraceEnabled()) {\n           LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n               remoteId + \": \" + method.getName() +\n                 \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n         }\n \n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n\n      RequestProto rpcRequest \u003d constructRpcRequest(method, args);\n      RpcResponseWritable val \u003d null;\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n      try {\n        val \u003d (RpcResponseWritable) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWritable(rpcRequest), remoteId);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n\n        throw new ServiceException(e);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.responseMessage).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "2f478ac89cb592165ab462cd52235814507df9fe": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8642. ProtobufRpcEngine should log all RPCs if TRACE logging is enabled. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1366127 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/07/12 11:22 AM",
      "commitName": "2f478ac89cb592165ab462cd52235814507df9fe",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "12/07/12 12:01 PM",
      "commitNameOld": "4a5ba3b7bd2360fd9605863630b477d362874e1e",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 13.97,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,56 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d Time.now();\n       }\n \n       HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n       RpcResponseWritable val \u003d null;\n+      \n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n+            remoteId + \": \" + method.getName() +\n+            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n+      }\n       try {\n         val \u003d (RpcResponseWritable) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWritable(rpcRequest), remoteId);\n+\n       } catch (Throwable e) {\n+        if (LOG.isTraceEnabled()) {\n+          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n+              remoteId + \": \" + method.getName() +\n+                \" {\" + e + \"}\");\n+        }\n+\n         throw new ServiceException(e);\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d Time.now() - startTime;\n-        LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n+        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(val.responseMessage).build();\n+\n+        if (LOG.isTraceEnabled()) {\n+          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n+              remoteId + \": \" + method.getName() +\n+                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n+        }\n+\n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n\n      HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n      RpcResponseWritable val \u003d null;\n      \n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -\u003e \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n      try {\n        val \u003d (RpcResponseWritable) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWritable(rpcRequest), remoteId);\n\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n\n        throw new ServiceException(e);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.responseMessage).build();\n\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response \u003c- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3641. Move server Util time methods to common and use now instead of System#currentTimeMillis. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1360858 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 12:01 PM",
      "commitName": "4a5ba3b7bd2360fd9605863630b477d362874e1e",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "02/07/12 3:15 PM",
      "commitNameOld": "22822df7c3d08f157cf268b907083d0782d3fa67",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 9.87,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n-        startTime \u003d System.currentTimeMillis();\n+        startTime \u003d Time.now();\n       }\n \n       HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n       RpcResponseWritable val \u003d null;\n       try {\n         val \u003d (RpcResponseWritable) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWritable(rpcRequest), remoteId);\n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n \n       if (LOG.isDebugEnabled()) {\n-        long callTime \u003d System.currentTimeMillis() - startTime;\n+        long callTime \u003d Time.now() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(val.responseMessage).build();\n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d Time.now();\n      }\n\n      HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n      RpcResponseWritable val \u003d null;\n      try {\n        val \u003d (RpcResponseWritable) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWritable(rpcRequest), remoteId);\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.responseMessage).build();\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "589c68ae09effd6c4f26505d61636f779c22e99f": {
      "type": "Ybodychange",
      "commitMessage": "    HADOOP-8285 Use ProtoBuf for RpcPayLoadHeader (sanjay radia)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1329319 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/12 9:34 AM",
      "commitName": "589c68ae09effd6c4f26505d61636f779c22e99f",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "17/04/12 8:04 AM",
      "commitNameOld": "e8eed2f62d30e0bf2f915ee3ad6b9c9f6d2d97cb",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 6.06,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d System.currentTimeMillis();\n       }\n \n       HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n       RpcResponseWritable val \u003d null;\n       try {\n-        val \u003d (RpcResponseWritable) client.call(RpcKind.RPC_PROTOCOL_BUFFER,\n+        val \u003d (RpcResponseWritable) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWritable(rpcRequest), remoteId);\n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n \n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d System.currentTimeMillis() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n       }\n       \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(val.responseMessage).build();\n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d System.currentTimeMillis();\n      }\n\n      HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n      RpcResponseWritable val \u003d null;\n      try {\n        val \u003d (RpcResponseWritable) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWritable(rpcRequest), remoteId);\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d System.currentTimeMillis() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.responseMessage).build();\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "081eda94fec4bbf321047c93a9bb40be678b1666": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8184.  ProtoBuf RPC engine uses the IPC layer reply packet.  Contributed by Sanjay Radia\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1304542 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/03/12 11:21 AM",
      "commitName": "081eda94fec4bbf321047c93a9bb40be678b1666",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "23/02/12 8:05 PM",
      "commitNameOld": "22d5944c42b4bef5144a9f6426751b15717c5a3e",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 28.59,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,36 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d System.currentTimeMillis();\n       }\n \n       HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n       RpcResponseWritable val \u003d null;\n       try {\n         val \u003d (RpcResponseWritable) client.call(RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWritable(rpcRequest), remoteId);\n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n \n-      HadoopRpcResponseProto response \u003d val.message;\n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d System.currentTimeMillis() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n       }\n-\n-      // Wrap the received message\n-      ResponseStatus status \u003d response.getStatus();\n-      if (status !\u003d ResponseStatus.SUCCESS) {\n-        RemoteException re \u003d  new RemoteException(response.getException()\n-            .getExceptionName(), response.getException().getStackTrace());\n-        re.fillInStackTrace();\n-        throw new ServiceException(re);\n-      }\n-\n+      \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n-            .mergeFrom(response.getResponse()).build();\n+            .mergeFrom(val.responseMessage).build();\n       } catch (Throwable e) {\n         throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d System.currentTimeMillis();\n      }\n\n      HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n      RpcResponseWritable val \u003d null;\n      try {\n        val \u003d (RpcResponseWritable) client.call(RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWritable(rpcRequest), remoteId);\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d System.currentTimeMillis() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n      }\n      \n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(val.responseMessage).build();\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "4283ac6d7af638ef6662810c5765bafe92704624": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7897. ProtobufRpcEngine client side exception mechanism is not consistent with WritableRpcEngine. Contributed by Suresh Srinivas.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1212004 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/12/11 9:47 AM",
      "commitName": "4283ac6d7af638ef6662810c5765bafe92704624",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "04/12/11 12:44 PM",
      "commitNameOld": "65200998c01b17e017d1814e8b1f4d82ac334a23",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 3.88,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,46 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d System.currentTimeMillis();\n       }\n \n       HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n       RpcResponseWritable val \u003d null;\n       try {\n         val \u003d (RpcResponseWritable) client.call(RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWritable(rpcRequest), remoteId);\n-      } catch (Exception e) {\n-        RpcClientException ce \u003d new RpcClientException(\"Client exception\", e);\n-        throw new ServiceException(getRemoteException(ce));\n+      } catch (Throwable e) {\n+        throw new ServiceException(e);\n       }\n \n       HadoopRpcResponseProto response \u003d val.message;\n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d System.currentTimeMillis() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n       }\n \n       // Wrap the received message\n       ResponseStatus status \u003d response.getStatus();\n       if (status !\u003d ResponseStatus.SUCCESS) {\n         RemoteException re \u003d  new RemoteException(response.getException()\n             .getExceptionName(), response.getException().getStackTrace());\n         re.fillInStackTrace();\n         throw new ServiceException(re);\n       }\n \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(response.getResponse()).build();\n-      } catch (InvalidProtocolBufferException e) {\n-        RpcClientException ce \u003d new RpcClientException(\"Client exception\", e);\n-        throw new ServiceException(getRemoteException(ce));\n+      } catch (Throwable e) {\n+        throw new ServiceException(e);\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d System.currentTimeMillis();\n      }\n\n      HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n      RpcResponseWritable val \u003d null;\n      try {\n        val \u003d (RpcResponseWritable) client.call(RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWritable(rpcRequest), remoteId);\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n\n      HadoopRpcResponseProto response \u003d val.message;\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d System.currentTimeMillis() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n      }\n\n      // Wrap the received message\n      ResponseStatus status \u003d response.getStatus();\n      if (status !\u003d ResponseStatus.SUCCESS) {\n        RemoteException re \u003d  new RemoteException(response.getException()\n            .getExceptionName(), response.getException().getStackTrace());\n        re.fillInStackTrace();\n        throw new ServiceException(re);\n      }\n\n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(response.getResponse()).build();\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "072bdd85d16509d2c0cc32b5cfae3739521a29e9": {
      "type": "Ybodychange",
      "commitMessage": "\t\tHADOOP-7776 Make the Ipc-Header in a RPC-Payload an explicit header (sanjay)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1197885 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/11/11 10:06 PM",
      "commitName": "072bdd85d16509d2c0cc32b5cfae3739521a29e9",
      "commitAuthor": "Sanjay Radia",
      "commitDateOld": "28/10/11 2:55 PM",
      "commitNameOld": "55d3dc50d16cd5b94f542f74e5329de4c30a8655",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 7.3,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws ServiceException {\n       long startTime \u003d 0;\n       if (LOG.isDebugEnabled()) {\n         startTime \u003d System.currentTimeMillis();\n       }\n \n       HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n       RpcResponseWritable val \u003d null;\n       try {\n-        val \u003d (RpcResponseWritable) client.call(\n+        val \u003d (RpcResponseWritable) client.call(RpcKind.RPC_PROTOCOL_BUFFER,\n             new RpcRequestWritable(rpcRequest), remoteId);\n       } catch (Exception e) {\n         RpcClientException ce \u003d new RpcClientException(\"Client exception\", e);\n         throw new ServiceException(getRemoteException(ce));\n       }\n \n       HadoopRpcResponseProto response \u003d val.message;\n       if (LOG.isDebugEnabled()) {\n         long callTime \u003d System.currentTimeMillis() - startTime;\n         LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n       }\n \n       // Wrap the received message\n       ResponseStatus status \u003d response.getStatus();\n       if (status !\u003d ResponseStatus.SUCCESS) {\n         RemoteException re \u003d  new RemoteException(response.getException()\n             .getExceptionName(), response.getException().getStackTrace());\n         re.fillInStackTrace();\n         throw new ServiceException(re);\n       }\n \n       Message prototype \u003d null;\n       try {\n         prototype \u003d getReturnProtoType(method);\n       } catch (Exception e) {\n         throw new ServiceException(e);\n       }\n       Message returnMessage;\n       try {\n         returnMessage \u003d prototype.newBuilderForType()\n             .mergeFrom(response.getResponse()).build();\n       } catch (InvalidProtocolBufferException e) {\n         RpcClientException ce \u003d new RpcClientException(\"Client exception\", e);\n         throw new ServiceException(getRemoteException(ce));\n       }\n       return returnMessage;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d System.currentTimeMillis();\n      }\n\n      HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n      RpcResponseWritable val \u003d null;\n      try {\n        val \u003d (RpcResponseWritable) client.call(RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWritable(rpcRequest), remoteId);\n      } catch (Exception e) {\n        RpcClientException ce \u003d new RpcClientException(\"Client exception\", e);\n        throw new ServiceException(getRemoteException(ce));\n      }\n\n      HadoopRpcResponseProto response \u003d val.message;\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d System.currentTimeMillis() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n      }\n\n      // Wrap the received message\n      ResponseStatus status \u003d response.getStatus();\n      if (status !\u003d ResponseStatus.SUCCESS) {\n        RemoteException re \u003d  new RemoteException(response.getException()\n            .getExceptionName(), response.getException().getStackTrace());\n        re.fillInStackTrace();\n        throw new ServiceException(re);\n      }\n\n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(response.getResponse()).build();\n      } catch (InvalidProtocolBufferException e) {\n        RpcClientException ce \u003d new RpcClientException(\"Client exception\", e);\n        throw new ServiceException(getRemoteException(ce));\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java",
      "extendedDetails": {}
    },
    "55d3dc50d16cd5b94f542f74e5329de4c30a8655": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7773. Add support for protocol buffer based RPC engine. Contributed by Suresh Srinivas.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190611 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/11 2:55 PM",
      "commitName": "55d3dc50d16cd5b94f542f74e5329de4c30a8655",
      "commitAuthor": "Suresh Srinivas",
      "diff": "@@ -0,0 +1,48 @@\n+    public Object invoke(Object proxy, Method method, Object[] args)\n+        throws ServiceException {\n+      long startTime \u003d 0;\n+      if (LOG.isDebugEnabled()) {\n+        startTime \u003d System.currentTimeMillis();\n+      }\n+\n+      HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n+      RpcResponseWritable val \u003d null;\n+      try {\n+        val \u003d (RpcResponseWritable) client.call(\n+            new RpcRequestWritable(rpcRequest), remoteId);\n+      } catch (Exception e) {\n+        RpcClientException ce \u003d new RpcClientException(\"Client exception\", e);\n+        throw new ServiceException(getRemoteException(ce));\n+      }\n+\n+      HadoopRpcResponseProto response \u003d val.message;\n+      if (LOG.isDebugEnabled()) {\n+        long callTime \u003d System.currentTimeMillis() - startTime;\n+        LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n+      }\n+\n+      // Wrap the received message\n+      ResponseStatus status \u003d response.getStatus();\n+      if (status !\u003d ResponseStatus.SUCCESS) {\n+        RemoteException re \u003d  new RemoteException(response.getException()\n+            .getExceptionName(), response.getException().getStackTrace());\n+        re.fillInStackTrace();\n+        throw new ServiceException(re);\n+      }\n+\n+      Message prototype \u003d null;\n+      try {\n+        prototype \u003d getReturnProtoType(method);\n+      } catch (Exception e) {\n+        throw new ServiceException(e);\n+      }\n+      Message returnMessage;\n+      try {\n+        returnMessage \u003d prototype.newBuilderForType()\n+            .mergeFrom(response.getResponse()).build();\n+      } catch (InvalidProtocolBufferException e) {\n+        RpcClientException ce \u003d new RpcClientException(\"Client exception\", e);\n+        throw new ServiceException(getRemoteException(ce));\n+      }\n+      return returnMessage;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime \u003d 0;\n      if (LOG.isDebugEnabled()) {\n        startTime \u003d System.currentTimeMillis();\n      }\n\n      HadoopRpcRequestProto rpcRequest \u003d constructRpcRequest(method, args);\n      RpcResponseWritable val \u003d null;\n      try {\n        val \u003d (RpcResponseWritable) client.call(\n            new RpcRequestWritable(rpcRequest), remoteId);\n      } catch (Exception e) {\n        RpcClientException ce \u003d new RpcClientException(\"Client exception\", e);\n        throw new ServiceException(getRemoteException(ce));\n      }\n\n      HadoopRpcResponseProto response \u003d val.message;\n      if (LOG.isDebugEnabled()) {\n        long callTime \u003d System.currentTimeMillis() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" \" + callTime);\n      }\n\n      // Wrap the received message\n      ResponseStatus status \u003d response.getStatus();\n      if (status !\u003d ResponseStatus.SUCCESS) {\n        RemoteException re \u003d  new RemoteException(response.getException()\n            .getExceptionName(), response.getException().getStackTrace());\n        re.fillInStackTrace();\n        throw new ServiceException(re);\n      }\n\n      Message prototype \u003d null;\n      try {\n        prototype \u003d getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage \u003d prototype.newBuilderForType()\n            .mergeFrom(response.getResponse()).build();\n      } catch (InvalidProtocolBufferException e) {\n        RpcClientException ce \u003d new RpcClientException(\"Client exception\", e);\n        throw new ServiceException(getRemoteException(ce));\n      }\n      return returnMessage;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufRpcEngine.java"
    }
  }
}