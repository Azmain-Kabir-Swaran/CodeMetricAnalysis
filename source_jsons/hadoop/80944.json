{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Configuration.java",
  "functionName": "substituteVars",
  "functionId": "substituteVars___expr-String",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
  "functionStartLine": 1127,
  "functionEndLine": 1194,
  "numCommitsSeen": 166,
  "timeTaken": 5781,
  "changeHistory": [
    "5eb7dbe9b31a45f57f2e1623aa1c9ce84a56c4d1",
    "03060075c53a2cecfbf5f60b6fc77afecf64ace5",
    "50fa38370468bf44031607dfed49b052cfc6d1e3",
    "61bf9cae6f3882c6e9a9222f59457b9be91e3018",
    "d4e8c09593b8edc4d0494d64ce19ac78c6f31277",
    "644548f201743408904dfe24b9f5b515b2c96713",
    "73db6bdb9b1b9ccc85dbc5de9e7c4eeb5ac169b3",
    "4709160d75a762ff1e189f49e28e84d59c3e8fd6",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "5eb7dbe9b31a45f57f2e1623aa1c9ce84a56c4d1": "Ybodychange",
    "03060075c53a2cecfbf5f60b6fc77afecf64ace5": "Ybodychange",
    "50fa38370468bf44031607dfed49b052cfc6d1e3": "Ybodychange",
    "61bf9cae6f3882c6e9a9222f59457b9be91e3018": "Ybodychange",
    "d4e8c09593b8edc4d0494d64ce19ac78c6f31277": "Ybodychange",
    "644548f201743408904dfe24b9f5b515b2c96713": "Ybodychange",
    "73db6bdb9b1b9ccc85dbc5de9e7c4eeb5ac169b3": "Ybodychange",
    "4709160d75a762ff1e189f49e28e84d59c3e8fd6": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5eb7dbe9b31a45f57f2e1623aa1c9ce84a56c4d1": {
      "type": "Ybodychange",
      "commitMessage": "Fixing Job History Server Configuration parsing. (Jason Lowe via asuresh)\n",
      "commitDate": "09/11/17 3:15 PM",
      "commitName": "5eb7dbe9b31a45f57f2e1623aa1c9ce84a56c4d1",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "13/10/17 1:52 PM",
      "commitNameOld": "e163f41850bd09a17d3102a3af0af2e3cd831ab0",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 27.1,
      "commitsBetweenForRepo": 273,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,68 @@\n   private String substituteVars(String expr) {\n     if (expr \u003d\u003d null) {\n       return null;\n     }\n     String eval \u003d expr;\n     for(int s \u003d 0; s \u003c MAX_SUBST; s++) {\n       final int[] varBounds \u003d findSubVariable(eval);\n       if (varBounds[SUB_START_IDX] \u003d\u003d -1) {\n         return eval;\n       }\n       final String var \u003d eval.substring(varBounds[SUB_START_IDX],\n           varBounds[SUB_END_IDX]);\n       String val \u003d null;\n-      try {\n-        if (var.startsWith(\"env.\") \u0026\u0026 4 \u003c var.length()) {\n-          String v \u003d var.substring(4);\n-          int i \u003d 0;\n-          for (; i \u003c v.length(); i++) {\n-            char c \u003d v.charAt(i);\n-            if (c \u003d\u003d \u0027:\u0027 \u0026\u0026 i \u003c v.length() - 1 \u0026\u0026 v.charAt(i + 1) \u003d\u003d \u0027-\u0027) {\n-              val \u003d getenv(v.substring(0, i));\n-              if (val \u003d\u003d null || val.length() \u003d\u003d 0) {\n-                val \u003d v.substring(i + 2);\n+      if (!restrictSystemProps) {\n+        try {\n+          if (var.startsWith(\"env.\") \u0026\u0026 4 \u003c var.length()) {\n+            String v \u003d var.substring(4);\n+            int i \u003d 0;\n+            for (; i \u003c v.length(); i++) {\n+              char c \u003d v.charAt(i);\n+              if (c \u003d\u003d \u0027:\u0027 \u0026\u0026 i \u003c v.length() - 1 \u0026\u0026 v.charAt(i + 1) \u003d\u003d \u0027-\u0027) {\n+                val \u003d getenv(v.substring(0, i));\n+                if (val \u003d\u003d null || val.length() \u003d\u003d 0) {\n+                  val \u003d v.substring(i + 2);\n+                }\n+                break;\n+              } else if (c \u003d\u003d \u0027-\u0027) {\n+                val \u003d getenv(v.substring(0, i));\n+                if (val \u003d\u003d null) {\n+                  val \u003d v.substring(i + 1);\n+                }\n+                break;\n               }\n-              break;\n-            } else if (c \u003d\u003d \u0027-\u0027) {\n-              val \u003d getenv(v.substring(0, i));\n-              if (val \u003d\u003d null) {\n-                val \u003d v.substring(i + 1);\n-              }\n-              break;\n             }\n+            if (i \u003d\u003d v.length()) {\n+              val \u003d getenv(v);\n+            }\n+          } else {\n+            val \u003d getProperty(var);\n           }\n-          if (i \u003d\u003d v.length()) {\n-            val \u003d getenv(v);\n-          }\n-        } else {\n-          val \u003d getProperty(var);\n+        } catch (SecurityException se) {\n+          LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n         }\n-      } catch(SecurityException se) {\n-        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n       }\n       if (val \u003d\u003d null) {\n         val \u003d getRaw(var);\n       }\n       if (val \u003d\u003d null) {\n         return eval; // return literal ${var}: var is unbound\n       }\n \n       final int dollar \u003d varBounds[SUB_START_IDX] - \"${\".length();\n       final int afterRightBrace \u003d varBounds[SUB_END_IDX] + \"}\".length();\n       final String refVar \u003d eval.substring(dollar, afterRightBrace);\n \n       // detect self-referential values\n       if (val.contains(refVar)) {\n         return expr; // return original expression if there is a loop\n       }\n \n       // substitute\n       eval \u003d eval.substring(0, dollar)\n              + val\n              + eval.substring(afterRightBrace);\n     }\n     throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                     + MAX_SUBST + \" \" + expr);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private String substituteVars(String expr) {\n    if (expr \u003d\u003d null) {\n      return null;\n    }\n    String eval \u003d expr;\n    for(int s \u003d 0; s \u003c MAX_SUBST; s++) {\n      final int[] varBounds \u003d findSubVariable(eval);\n      if (varBounds[SUB_START_IDX] \u003d\u003d -1) {\n        return eval;\n      }\n      final String var \u003d eval.substring(varBounds[SUB_START_IDX],\n          varBounds[SUB_END_IDX]);\n      String val \u003d null;\n      if (!restrictSystemProps) {\n        try {\n          if (var.startsWith(\"env.\") \u0026\u0026 4 \u003c var.length()) {\n            String v \u003d var.substring(4);\n            int i \u003d 0;\n            for (; i \u003c v.length(); i++) {\n              char c \u003d v.charAt(i);\n              if (c \u003d\u003d \u0027:\u0027 \u0026\u0026 i \u003c v.length() - 1 \u0026\u0026 v.charAt(i + 1) \u003d\u003d \u0027-\u0027) {\n                val \u003d getenv(v.substring(0, i));\n                if (val \u003d\u003d null || val.length() \u003d\u003d 0) {\n                  val \u003d v.substring(i + 2);\n                }\n                break;\n              } else if (c \u003d\u003d \u0027-\u0027) {\n                val \u003d getenv(v.substring(0, i));\n                if (val \u003d\u003d null) {\n                  val \u003d v.substring(i + 1);\n                }\n                break;\n              }\n            }\n            if (i \u003d\u003d v.length()) {\n              val \u003d getenv(v);\n            }\n          } else {\n            val \u003d getProperty(var);\n          }\n        } catch (SecurityException se) {\n          LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n        }\n      }\n      if (val \u003d\u003d null) {\n        val \u003d getRaw(var);\n      }\n      if (val \u003d\u003d null) {\n        return eval; // return literal ${var}: var is unbound\n      }\n\n      final int dollar \u003d varBounds[SUB_START_IDX] - \"${\".length();\n      final int afterRightBrace \u003d varBounds[SUB_END_IDX] + \"}\".length();\n      final String refVar \u003d eval.substring(dollar, afterRightBrace);\n\n      // detect self-referential values\n      if (val.contains(refVar)) {\n        return expr; // return original expression if there is a loop\n      }\n\n      // substitute\n      eval \u003d eval.substring(0, dollar)\n             + val\n             + eval.substring(afterRightBrace);\n    }\n    throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                    + MAX_SUBST + \" \" + expr);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "03060075c53a2cecfbf5f60b6fc77afecf64ace5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13699. Configuration does not substitute multiple references to the same var.\n",
      "commitDate": "10/10/16 12:19 PM",
      "commitName": "03060075c53a2cecfbf5f60b6fc77afecf64ace5",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "05/10/16 1:50 PM",
      "commitNameOld": "00160f71b6d98244fcb1cb58b2db9fc24f1cd672",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 4.94,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,66 @@\n   private String substituteVars(String expr) {\n     if (expr \u003d\u003d null) {\n       return null;\n     }\n     String eval \u003d expr;\n-    Set\u003cString\u003e evalSet \u003d null;\n     for(int s \u003d 0; s \u003c MAX_SUBST; s++) {\n       final int[] varBounds \u003d findSubVariable(eval);\n       if (varBounds[SUB_START_IDX] \u003d\u003d -1) {\n         return eval;\n       }\n       final String var \u003d eval.substring(varBounds[SUB_START_IDX],\n           varBounds[SUB_END_IDX]);\n       String val \u003d null;\n       try {\n         if (var.startsWith(\"env.\") \u0026\u0026 4 \u003c var.length()) {\n           String v \u003d var.substring(4);\n           int i \u003d 0;\n           for (; i \u003c v.length(); i++) {\n             char c \u003d v.charAt(i);\n             if (c \u003d\u003d \u0027:\u0027 \u0026\u0026 i \u003c v.length() - 1 \u0026\u0026 v.charAt(i + 1) \u003d\u003d \u0027-\u0027) {\n               val \u003d getenv(v.substring(0, i));\n               if (val \u003d\u003d null || val.length() \u003d\u003d 0) {\n                 val \u003d v.substring(i + 2);\n               }\n               break;\n             } else if (c \u003d\u003d \u0027-\u0027) {\n               val \u003d getenv(v.substring(0, i));\n               if (val \u003d\u003d null) {\n                 val \u003d v.substring(i + 1);\n               }\n               break;\n             }\n           }\n           if (i \u003d\u003d v.length()) {\n             val \u003d getenv(v);\n           }\n         } else {\n           val \u003d getProperty(var);\n         }\n       } catch(SecurityException se) {\n         LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n       }\n       if (val \u003d\u003d null) {\n         val \u003d getRaw(var);\n       }\n       if (val \u003d\u003d null) {\n         return eval; // return literal ${var}: var is unbound\n       }\n \n-      // prevent recursive resolution\n-      //\n       final int dollar \u003d varBounds[SUB_START_IDX] - \"${\".length();\n       final int afterRightBrace \u003d varBounds[SUB_END_IDX] + \"}\".length();\n       final String refVar \u003d eval.substring(dollar, afterRightBrace);\n-      if (evalSet \u003d\u003d null) {\n-        evalSet \u003d new HashSet\u003cString\u003e();\n-      }\n-      if (!evalSet.add(refVar)) {\n+\n+      // detect self-referential values\n+      if (val.contains(refVar)) {\n         return expr; // return original expression if there is a loop\n       }\n \n       // substitute\n       eval \u003d eval.substring(0, dollar)\n              + val\n              + eval.substring(afterRightBrace);\n     }\n     throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                     + MAX_SUBST + \" \" + expr);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private String substituteVars(String expr) {\n    if (expr \u003d\u003d null) {\n      return null;\n    }\n    String eval \u003d expr;\n    for(int s \u003d 0; s \u003c MAX_SUBST; s++) {\n      final int[] varBounds \u003d findSubVariable(eval);\n      if (varBounds[SUB_START_IDX] \u003d\u003d -1) {\n        return eval;\n      }\n      final String var \u003d eval.substring(varBounds[SUB_START_IDX],\n          varBounds[SUB_END_IDX]);\n      String val \u003d null;\n      try {\n        if (var.startsWith(\"env.\") \u0026\u0026 4 \u003c var.length()) {\n          String v \u003d var.substring(4);\n          int i \u003d 0;\n          for (; i \u003c v.length(); i++) {\n            char c \u003d v.charAt(i);\n            if (c \u003d\u003d \u0027:\u0027 \u0026\u0026 i \u003c v.length() - 1 \u0026\u0026 v.charAt(i + 1) \u003d\u003d \u0027-\u0027) {\n              val \u003d getenv(v.substring(0, i));\n              if (val \u003d\u003d null || val.length() \u003d\u003d 0) {\n                val \u003d v.substring(i + 2);\n              }\n              break;\n            } else if (c \u003d\u003d \u0027-\u0027) {\n              val \u003d getenv(v.substring(0, i));\n              if (val \u003d\u003d null) {\n                val \u003d v.substring(i + 1);\n              }\n              break;\n            }\n          }\n          if (i \u003d\u003d v.length()) {\n            val \u003d getenv(v);\n          }\n        } else {\n          val \u003d getProperty(var);\n        }\n      } catch(SecurityException se) {\n        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n      }\n      if (val \u003d\u003d null) {\n        val \u003d getRaw(var);\n      }\n      if (val \u003d\u003d null) {\n        return eval; // return literal ${var}: var is unbound\n      }\n\n      final int dollar \u003d varBounds[SUB_START_IDX] - \"${\".length();\n      final int afterRightBrace \u003d varBounds[SUB_END_IDX] + \"}\".length();\n      final String refVar \u003d eval.substring(dollar, afterRightBrace);\n\n      // detect self-referential values\n      if (val.contains(refVar)) {\n        return expr; // return original expression if there is a loop\n      }\n\n      // substitute\n      eval \u003d eval.substring(0, dollar)\n             + val\n             + eval.substring(afterRightBrace);\n    }\n    throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                    + MAX_SUBST + \" \" + expr);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "50fa38370468bf44031607dfed49b052cfc6d1e3": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"MAPREDUCE-6455. Unable to use surefire \u003e 2.18. (Charlie Helin via kasha)\"\n\nThis reverts commit 61bf9cae6f3882c6e9a9222f59457b9be91e3018.\n",
      "commitDate": "27/08/15 10:15 AM",
      "commitName": "50fa38370468bf44031607dfed49b052cfc6d1e3",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "22/08/15 12:39 AM",
      "commitNameOld": "61bf9cae6f3882c6e9a9222f59457b9be91e3018",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 5.4,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,70 @@\n   private String substituteVars(String expr) {\n     if (expr \u003d\u003d null) {\n       return null;\n     }\n     String eval \u003d expr;\n     Set\u003cString\u003e evalSet \u003d null;\n     for(int s \u003d 0; s \u003c MAX_SUBST; s++) {\n       final int[] varBounds \u003d findSubVariable(eval);\n       if (varBounds[SUB_START_IDX] \u003d\u003d -1) {\n         return eval;\n       }\n       final String var \u003d eval.substring(varBounds[SUB_START_IDX],\n           varBounds[SUB_END_IDX]);\n       String val \u003d null;\n       try {\n         if (var.startsWith(\"env.\") \u0026\u0026 4 \u003c var.length()) {\n           String v \u003d var.substring(4);\n           int i \u003d 0;\n           for (; i \u003c v.length(); i++) {\n             char c \u003d v.charAt(i);\n             if (c \u003d\u003d \u0027:\u0027 \u0026\u0026 i \u003c v.length() - 1 \u0026\u0026 v.charAt(i + 1) \u003d\u003d \u0027-\u0027) {\n               val \u003d getenv(v.substring(0, i));\n               if (val \u003d\u003d null || val.length() \u003d\u003d 0) {\n                 val \u003d v.substring(i + 2);\n               }\n               break;\n             } else if (c \u003d\u003d \u0027-\u0027) {\n               val \u003d getenv(v.substring(0, i));\n               if (val \u003d\u003d null) {\n                 val \u003d v.substring(i + 1);\n               }\n               break;\n             }\n           }\n           if (i \u003d\u003d v.length()) {\n             val \u003d getenv(v);\n           }\n         } else {\n           val \u003d getProperty(var);\n         }\n       } catch(SecurityException se) {\n         LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n       }\n-      if (val \u003d\u003d null || val.isEmpty()) {\n-        String raw \u003d getRaw(var);\n-        if (raw !\u003d null) {\n-          // if System.getProperty(var) returns an empty string, retain this\n-          // value instead of return null\n-          val \u003d raw;\n-        }\n+      if (val \u003d\u003d null) {\n+        val \u003d getRaw(var);\n       }\n       if (val \u003d\u003d null) {\n         return eval; // return literal ${var}: var is unbound\n       }\n \n       // prevent recursive resolution\n       //\n       final int dollar \u003d varBounds[SUB_START_IDX] - \"${\".length();\n       final int afterRightBrace \u003d varBounds[SUB_END_IDX] + \"}\".length();\n       final String refVar \u003d eval.substring(dollar, afterRightBrace);\n       if (evalSet \u003d\u003d null) {\n         evalSet \u003d new HashSet\u003cString\u003e();\n       }\n       if (!evalSet.add(refVar)) {\n         return expr; // return original expression if there is a loop\n       }\n \n       // substitute\n       eval \u003d eval.substring(0, dollar)\n              + val\n              + eval.substring(afterRightBrace);\n     }\n     throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                     + MAX_SUBST + \" \" + expr);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private String substituteVars(String expr) {\n    if (expr \u003d\u003d null) {\n      return null;\n    }\n    String eval \u003d expr;\n    Set\u003cString\u003e evalSet \u003d null;\n    for(int s \u003d 0; s \u003c MAX_SUBST; s++) {\n      final int[] varBounds \u003d findSubVariable(eval);\n      if (varBounds[SUB_START_IDX] \u003d\u003d -1) {\n        return eval;\n      }\n      final String var \u003d eval.substring(varBounds[SUB_START_IDX],\n          varBounds[SUB_END_IDX]);\n      String val \u003d null;\n      try {\n        if (var.startsWith(\"env.\") \u0026\u0026 4 \u003c var.length()) {\n          String v \u003d var.substring(4);\n          int i \u003d 0;\n          for (; i \u003c v.length(); i++) {\n            char c \u003d v.charAt(i);\n            if (c \u003d\u003d \u0027:\u0027 \u0026\u0026 i \u003c v.length() - 1 \u0026\u0026 v.charAt(i + 1) \u003d\u003d \u0027-\u0027) {\n              val \u003d getenv(v.substring(0, i));\n              if (val \u003d\u003d null || val.length() \u003d\u003d 0) {\n                val \u003d v.substring(i + 2);\n              }\n              break;\n            } else if (c \u003d\u003d \u0027-\u0027) {\n              val \u003d getenv(v.substring(0, i));\n              if (val \u003d\u003d null) {\n                val \u003d v.substring(i + 1);\n              }\n              break;\n            }\n          }\n          if (i \u003d\u003d v.length()) {\n            val \u003d getenv(v);\n          }\n        } else {\n          val \u003d getProperty(var);\n        }\n      } catch(SecurityException se) {\n        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n      }\n      if (val \u003d\u003d null) {\n        val \u003d getRaw(var);\n      }\n      if (val \u003d\u003d null) {\n        return eval; // return literal ${var}: var is unbound\n      }\n\n      // prevent recursive resolution\n      //\n      final int dollar \u003d varBounds[SUB_START_IDX] - \"${\".length();\n      final int afterRightBrace \u003d varBounds[SUB_END_IDX] + \"}\".length();\n      final String refVar \u003d eval.substring(dollar, afterRightBrace);\n      if (evalSet \u003d\u003d null) {\n        evalSet \u003d new HashSet\u003cString\u003e();\n      }\n      if (!evalSet.add(refVar)) {\n        return expr; // return original expression if there is a loop\n      }\n\n      // substitute\n      eval \u003d eval.substring(0, dollar)\n             + val\n             + eval.substring(afterRightBrace);\n    }\n    throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                    + MAX_SUBST + \" \" + expr);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "61bf9cae6f3882c6e9a9222f59457b9be91e3018": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6455. Unable to use surefire \u003e 2.18. (Charlie Helin via kasha)\n",
      "commitDate": "22/08/15 12:39 AM",
      "commitName": "61bf9cae6f3882c6e9a9222f59457b9be91e3018",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "07/07/15 3:41 AM",
      "commitNameOld": "99c8c5839b65666e6099116e4d7024e0eb4682b9",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 45.87,
      "commitsBetweenForRepo": 265,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,75 @@\n   private String substituteVars(String expr) {\n     if (expr \u003d\u003d null) {\n       return null;\n     }\n     String eval \u003d expr;\n     Set\u003cString\u003e evalSet \u003d null;\n     for(int s \u003d 0; s \u003c MAX_SUBST; s++) {\n       final int[] varBounds \u003d findSubVariable(eval);\n       if (varBounds[SUB_START_IDX] \u003d\u003d -1) {\n         return eval;\n       }\n       final String var \u003d eval.substring(varBounds[SUB_START_IDX],\n           varBounds[SUB_END_IDX]);\n       String val \u003d null;\n       try {\n         if (var.startsWith(\"env.\") \u0026\u0026 4 \u003c var.length()) {\n           String v \u003d var.substring(4);\n           int i \u003d 0;\n           for (; i \u003c v.length(); i++) {\n             char c \u003d v.charAt(i);\n             if (c \u003d\u003d \u0027:\u0027 \u0026\u0026 i \u003c v.length() - 1 \u0026\u0026 v.charAt(i + 1) \u003d\u003d \u0027-\u0027) {\n               val \u003d getenv(v.substring(0, i));\n               if (val \u003d\u003d null || val.length() \u003d\u003d 0) {\n                 val \u003d v.substring(i + 2);\n               }\n               break;\n             } else if (c \u003d\u003d \u0027-\u0027) {\n               val \u003d getenv(v.substring(0, i));\n               if (val \u003d\u003d null) {\n                 val \u003d v.substring(i + 1);\n               }\n               break;\n             }\n           }\n           if (i \u003d\u003d v.length()) {\n             val \u003d getenv(v);\n           }\n         } else {\n           val \u003d getProperty(var);\n         }\n       } catch(SecurityException se) {\n         LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n       }\n-      if (val \u003d\u003d null) {\n-        val \u003d getRaw(var);\n+      if (val \u003d\u003d null || val.isEmpty()) {\n+        String raw \u003d getRaw(var);\n+        if (raw !\u003d null) {\n+          // if System.getProperty(var) returns an empty string, retain this\n+          // value instead of return null\n+          val \u003d raw;\n+        }\n       }\n       if (val \u003d\u003d null) {\n         return eval; // return literal ${var}: var is unbound\n       }\n \n       // prevent recursive resolution\n       //\n       final int dollar \u003d varBounds[SUB_START_IDX] - \"${\".length();\n       final int afterRightBrace \u003d varBounds[SUB_END_IDX] + \"}\".length();\n       final String refVar \u003d eval.substring(dollar, afterRightBrace);\n       if (evalSet \u003d\u003d null) {\n         evalSet \u003d new HashSet\u003cString\u003e();\n       }\n       if (!evalSet.add(refVar)) {\n         return expr; // return original expression if there is a loop\n       }\n \n       // substitute\n       eval \u003d eval.substring(0, dollar)\n              + val\n              + eval.substring(afterRightBrace);\n     }\n     throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                     + MAX_SUBST + \" \" + expr);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private String substituteVars(String expr) {\n    if (expr \u003d\u003d null) {\n      return null;\n    }\n    String eval \u003d expr;\n    Set\u003cString\u003e evalSet \u003d null;\n    for(int s \u003d 0; s \u003c MAX_SUBST; s++) {\n      final int[] varBounds \u003d findSubVariable(eval);\n      if (varBounds[SUB_START_IDX] \u003d\u003d -1) {\n        return eval;\n      }\n      final String var \u003d eval.substring(varBounds[SUB_START_IDX],\n          varBounds[SUB_END_IDX]);\n      String val \u003d null;\n      try {\n        if (var.startsWith(\"env.\") \u0026\u0026 4 \u003c var.length()) {\n          String v \u003d var.substring(4);\n          int i \u003d 0;\n          for (; i \u003c v.length(); i++) {\n            char c \u003d v.charAt(i);\n            if (c \u003d\u003d \u0027:\u0027 \u0026\u0026 i \u003c v.length() - 1 \u0026\u0026 v.charAt(i + 1) \u003d\u003d \u0027-\u0027) {\n              val \u003d getenv(v.substring(0, i));\n              if (val \u003d\u003d null || val.length() \u003d\u003d 0) {\n                val \u003d v.substring(i + 2);\n              }\n              break;\n            } else if (c \u003d\u003d \u0027-\u0027) {\n              val \u003d getenv(v.substring(0, i));\n              if (val \u003d\u003d null) {\n                val \u003d v.substring(i + 1);\n              }\n              break;\n            }\n          }\n          if (i \u003d\u003d v.length()) {\n            val \u003d getenv(v);\n          }\n        } else {\n          val \u003d getProperty(var);\n        }\n      } catch(SecurityException se) {\n        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n      }\n      if (val \u003d\u003d null || val.isEmpty()) {\n        String raw \u003d getRaw(var);\n        if (raw !\u003d null) {\n          // if System.getProperty(var) returns an empty string, retain this\n          // value instead of return null\n          val \u003d raw;\n        }\n      }\n      if (val \u003d\u003d null) {\n        return eval; // return literal ${var}: var is unbound\n      }\n\n      // prevent recursive resolution\n      //\n      final int dollar \u003d varBounds[SUB_START_IDX] - \"${\".length();\n      final int afterRightBrace \u003d varBounds[SUB_END_IDX] + \"}\".length();\n      final String refVar \u003d eval.substring(dollar, afterRightBrace);\n      if (evalSet \u003d\u003d null) {\n        evalSet \u003d new HashSet\u003cString\u003e();\n      }\n      if (!evalSet.add(refVar)) {\n        return expr; // return original expression if there is a loop\n      }\n\n      // substitute\n      eval \u003d eval.substring(0, dollar)\n             + val\n             + eval.substring(afterRightBrace);\n    }\n    throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                    + MAX_SUBST + \" \" + expr);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "d4e8c09593b8edc4d0494d64ce19ac78c6f31277": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9642. Configuration to resolve environment variables via ${env.VARIABLE} references (Kengo Seki via aw)\n",
      "commitDate": "13/04/15 11:20 PM",
      "commitName": "d4e8c09593b8edc4d0494d64ce19ac78c6f31277",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "25/03/15 12:36 AM",
      "commitNameOld": "5582b0f1d469e7c98811a341c4b4c78eaa64ede5",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 19.95,
      "commitsBetweenForRepo": 171,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,70 @@\n   private String substituteVars(String expr) {\n     if (expr \u003d\u003d null) {\n       return null;\n     }\n     String eval \u003d expr;\n     Set\u003cString\u003e evalSet \u003d null;\n     for(int s \u003d 0; s \u003c MAX_SUBST; s++) {\n       final int[] varBounds \u003d findSubVariable(eval);\n       if (varBounds[SUB_START_IDX] \u003d\u003d -1) {\n         return eval;\n       }\n       final String var \u003d eval.substring(varBounds[SUB_START_IDX],\n           varBounds[SUB_END_IDX]);\n       String val \u003d null;\n       try {\n-        val \u003d System.getProperty(var);\n+        if (var.startsWith(\"env.\") \u0026\u0026 4 \u003c var.length()) {\n+          String v \u003d var.substring(4);\n+          int i \u003d 0;\n+          for (; i \u003c v.length(); i++) {\n+            char c \u003d v.charAt(i);\n+            if (c \u003d\u003d \u0027:\u0027 \u0026\u0026 i \u003c v.length() - 1 \u0026\u0026 v.charAt(i + 1) \u003d\u003d \u0027-\u0027) {\n+              val \u003d getenv(v.substring(0, i));\n+              if (val \u003d\u003d null || val.length() \u003d\u003d 0) {\n+                val \u003d v.substring(i + 2);\n+              }\n+              break;\n+            } else if (c \u003d\u003d \u0027-\u0027) {\n+              val \u003d getenv(v.substring(0, i));\n+              if (val \u003d\u003d null) {\n+                val \u003d v.substring(i + 1);\n+              }\n+              break;\n+            }\n+          }\n+          if (i \u003d\u003d v.length()) {\n+            val \u003d getenv(v);\n+          }\n+        } else {\n+          val \u003d getProperty(var);\n+        }\n       } catch(SecurityException se) {\n         LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n       }\n       if (val \u003d\u003d null) {\n         val \u003d getRaw(var);\n       }\n       if (val \u003d\u003d null) {\n         return eval; // return literal ${var}: var is unbound\n       }\n \n       // prevent recursive resolution\n       //\n       final int dollar \u003d varBounds[SUB_START_IDX] - \"${\".length();\n       final int afterRightBrace \u003d varBounds[SUB_END_IDX] + \"}\".length();\n       final String refVar \u003d eval.substring(dollar, afterRightBrace);\n       if (evalSet \u003d\u003d null) {\n         evalSet \u003d new HashSet\u003cString\u003e();\n       }\n       if (!evalSet.add(refVar)) {\n         return expr; // return original expression if there is a loop\n       }\n \n       // substitute\n       eval \u003d eval.substring(0, dollar)\n              + val\n              + eval.substring(afterRightBrace);\n     }\n     throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                     + MAX_SUBST + \" \" + expr);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private String substituteVars(String expr) {\n    if (expr \u003d\u003d null) {\n      return null;\n    }\n    String eval \u003d expr;\n    Set\u003cString\u003e evalSet \u003d null;\n    for(int s \u003d 0; s \u003c MAX_SUBST; s++) {\n      final int[] varBounds \u003d findSubVariable(eval);\n      if (varBounds[SUB_START_IDX] \u003d\u003d -1) {\n        return eval;\n      }\n      final String var \u003d eval.substring(varBounds[SUB_START_IDX],\n          varBounds[SUB_END_IDX]);\n      String val \u003d null;\n      try {\n        if (var.startsWith(\"env.\") \u0026\u0026 4 \u003c var.length()) {\n          String v \u003d var.substring(4);\n          int i \u003d 0;\n          for (; i \u003c v.length(); i++) {\n            char c \u003d v.charAt(i);\n            if (c \u003d\u003d \u0027:\u0027 \u0026\u0026 i \u003c v.length() - 1 \u0026\u0026 v.charAt(i + 1) \u003d\u003d \u0027-\u0027) {\n              val \u003d getenv(v.substring(0, i));\n              if (val \u003d\u003d null || val.length() \u003d\u003d 0) {\n                val \u003d v.substring(i + 2);\n              }\n              break;\n            } else if (c \u003d\u003d \u0027-\u0027) {\n              val \u003d getenv(v.substring(0, i));\n              if (val \u003d\u003d null) {\n                val \u003d v.substring(i + 1);\n              }\n              break;\n            }\n          }\n          if (i \u003d\u003d v.length()) {\n            val \u003d getenv(v);\n          }\n        } else {\n          val \u003d getProperty(var);\n        }\n      } catch(SecurityException se) {\n        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n      }\n      if (val \u003d\u003d null) {\n        val \u003d getRaw(var);\n      }\n      if (val \u003d\u003d null) {\n        return eval; // return literal ${var}: var is unbound\n      }\n\n      // prevent recursive resolution\n      //\n      final int dollar \u003d varBounds[SUB_START_IDX] - \"${\".length();\n      final int afterRightBrace \u003d varBounds[SUB_END_IDX] + \"}\".length();\n      final String refVar \u003d eval.substring(dollar, afterRightBrace);\n      if (evalSet \u003d\u003d null) {\n        evalSet \u003d new HashSet\u003cString\u003e();\n      }\n      if (!evalSet.add(refVar)) {\n        return expr; // return original expression if there is a loop\n      }\n\n      // substitute\n      eval \u003d eval.substring(0, dollar)\n             + val\n             + eval.substring(afterRightBrace);\n    }\n    throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                    + MAX_SUBST + \" \" + expr);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "644548f201743408904dfe24b9f5b515b2c96713": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11506. Configuration variable expansion regex expensive for long values. (Gera Shegalov via gera)\n",
      "commitDate": "06/02/15 12:27 AM",
      "commitName": "644548f201743408904dfe24b9f5b515b2c96713",
      "commitAuthor": "Gera Shegalov",
      "commitDateOld": "05/02/15 7:09 PM",
      "commitNameOld": "af3aadf04f0d6aff19fff99fe18c9b3feae2c529",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 0.22,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,46 @@\n   private String substituteVars(String expr) {\n     if (expr \u003d\u003d null) {\n       return null;\n     }\n-    Matcher match \u003d VAR_PATTERN.matcher(\"\");\n     String eval \u003d expr;\n-    Set\u003cString\u003e evalSet \u003d new HashSet\u003cString\u003e();\n-    for(int s\u003d0; s\u003cMAX_SUBST; s++) {\n-      if (evalSet.contains(eval)) {\n-        // Cyclic resolution pattern detected. Return current expression.\n+    Set\u003cString\u003e evalSet \u003d null;\n+    for(int s \u003d 0; s \u003c MAX_SUBST; s++) {\n+      final int[] varBounds \u003d findSubVariable(eval);\n+      if (varBounds[SUB_START_IDX] \u003d\u003d -1) {\n         return eval;\n       }\n-      evalSet.add(eval);\n-      match.reset(eval);\n-      if (!match.find()) {\n-        return eval;\n-      }\n-      String var \u003d match.group();\n-      var \u003d var.substring(2, var.length()-1); // remove ${ .. }\n+      final String var \u003d eval.substring(varBounds[SUB_START_IDX],\n+          varBounds[SUB_END_IDX]);\n       String val \u003d null;\n       try {\n         val \u003d System.getProperty(var);\n       } catch(SecurityException se) {\n         LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n       }\n       if (val \u003d\u003d null) {\n         val \u003d getRaw(var);\n       }\n       if (val \u003d\u003d null) {\n         return eval; // return literal ${var}: var is unbound\n       }\n+\n+      // prevent recursive resolution\n+      //\n+      final int dollar \u003d varBounds[SUB_START_IDX] - \"${\".length();\n+      final int afterRightBrace \u003d varBounds[SUB_END_IDX] + \"}\".length();\n+      final String refVar \u003d eval.substring(dollar, afterRightBrace);\n+      if (evalSet \u003d\u003d null) {\n+        evalSet \u003d new HashSet\u003cString\u003e();\n+      }\n+      if (!evalSet.add(refVar)) {\n+        return expr; // return original expression if there is a loop\n+      }\n+\n       // substitute\n-      eval \u003d eval.substring(0, match.start())+val+eval.substring(match.end());\n+      eval \u003d eval.substring(0, dollar)\n+             + val\n+             + eval.substring(afterRightBrace);\n     }\n     throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                     + MAX_SUBST + \" \" + expr);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private String substituteVars(String expr) {\n    if (expr \u003d\u003d null) {\n      return null;\n    }\n    String eval \u003d expr;\n    Set\u003cString\u003e evalSet \u003d null;\n    for(int s \u003d 0; s \u003c MAX_SUBST; s++) {\n      final int[] varBounds \u003d findSubVariable(eval);\n      if (varBounds[SUB_START_IDX] \u003d\u003d -1) {\n        return eval;\n      }\n      final String var \u003d eval.substring(varBounds[SUB_START_IDX],\n          varBounds[SUB_END_IDX]);\n      String val \u003d null;\n      try {\n        val \u003d System.getProperty(var);\n      } catch(SecurityException se) {\n        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n      }\n      if (val \u003d\u003d null) {\n        val \u003d getRaw(var);\n      }\n      if (val \u003d\u003d null) {\n        return eval; // return literal ${var}: var is unbound\n      }\n\n      // prevent recursive resolution\n      //\n      final int dollar \u003d varBounds[SUB_START_IDX] - \"${\".length();\n      final int afterRightBrace \u003d varBounds[SUB_END_IDX] + \"}\".length();\n      final String refVar \u003d eval.substring(dollar, afterRightBrace);\n      if (evalSet \u003d\u003d null) {\n        evalSet \u003d new HashSet\u003cString\u003e();\n      }\n      if (!evalSet.add(refVar)) {\n        return expr; // return original expression if there is a loop\n      }\n\n      // substitute\n      eval \u003d eval.substring(0, dollar)\n             + val\n             + eval.substring(afterRightBrace);\n    }\n    throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                    + MAX_SUBST + \" \" + expr);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "73db6bdb9b1b9ccc85dbc5de9e7c4eeb5ac169b3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10549. MAX_SUBST and varPat should be final in Configuration.java. Contributed by Gera Shegalov.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1592011 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/05/14 12:08 PM",
      "commitName": "73db6bdb9b1b9ccc85dbc5de9e7c4eeb5ac169b3",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "04/04/14 2:22 AM",
      "commitNameOld": "0941b99c86e21e7ad7b53f536788bb266c8468a7",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 28.41,
      "commitsBetweenForRepo": 170,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n   private String substituteVars(String expr) {\n     if (expr \u003d\u003d null) {\n       return null;\n     }\n-    Matcher match \u003d varPat.matcher(\"\");\n+    Matcher match \u003d VAR_PATTERN.matcher(\"\");\n     String eval \u003d expr;\n     Set\u003cString\u003e evalSet \u003d new HashSet\u003cString\u003e();\n     for(int s\u003d0; s\u003cMAX_SUBST; s++) {\n       if (evalSet.contains(eval)) {\n         // Cyclic resolution pattern detected. Return current expression.\n         return eval;\n       }\n       evalSet.add(eval);\n       match.reset(eval);\n       if (!match.find()) {\n         return eval;\n       }\n       String var \u003d match.group();\n       var \u003d var.substring(2, var.length()-1); // remove ${ .. }\n       String val \u003d null;\n       try {\n         val \u003d System.getProperty(var);\n       } catch(SecurityException se) {\n         LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n       }\n       if (val \u003d\u003d null) {\n         val \u003d getRaw(var);\n       }\n       if (val \u003d\u003d null) {\n         return eval; // return literal ${var}: var is unbound\n       }\n       // substitute\n       eval \u003d eval.substring(0, match.start())+val+eval.substring(match.end());\n     }\n     throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                     + MAX_SUBST + \" \" + expr);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private String substituteVars(String expr) {\n    if (expr \u003d\u003d null) {\n      return null;\n    }\n    Matcher match \u003d VAR_PATTERN.matcher(\"\");\n    String eval \u003d expr;\n    Set\u003cString\u003e evalSet \u003d new HashSet\u003cString\u003e();\n    for(int s\u003d0; s\u003cMAX_SUBST; s++) {\n      if (evalSet.contains(eval)) {\n        // Cyclic resolution pattern detected. Return current expression.\n        return eval;\n      }\n      evalSet.add(eval);\n      match.reset(eval);\n      if (!match.find()) {\n        return eval;\n      }\n      String var \u003d match.group();\n      var \u003d var.substring(2, var.length()-1); // remove ${ .. }\n      String val \u003d null;\n      try {\n        val \u003d System.getProperty(var);\n      } catch(SecurityException se) {\n        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n      }\n      if (val \u003d\u003d null) {\n        val \u003d getRaw(var);\n      }\n      if (val \u003d\u003d null) {\n        return eval; // return literal ${var}: var is unbound\n      }\n      // substitute\n      eval \u003d eval.substring(0, match.start())+val+eval.substring(match.end());\n    }\n    throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                    + MAX_SUBST + \" \" + expr);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "4709160d75a762ff1e189f49e28e84d59c3e8fd6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6871. When the value of a configuration key is set to its unresolved form, it causes an IllegalStateException in Configuration.get() stating that substitution depth is too large. Contributed by Arvind Prabhakar (harsh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1342626 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/05/12 7:02 AM",
      "commitName": "4709160d75a762ff1e189f49e28e84d59c3e8fd6",
      "commitAuthor": "Harsh J",
      "commitDateOld": "24/05/12 11:06 PM",
      "commitNameOld": "458be39423913aafa49302bd8f18c40bc3313823",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 0.33,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,37 @@\n   private String substituteVars(String expr) {\n     if (expr \u003d\u003d null) {\n       return null;\n     }\n     Matcher match \u003d varPat.matcher(\"\");\n     String eval \u003d expr;\n+    Set\u003cString\u003e evalSet \u003d new HashSet\u003cString\u003e();\n     for(int s\u003d0; s\u003cMAX_SUBST; s++) {\n+      if (evalSet.contains(eval)) {\n+        // Cyclic resolution pattern detected. Return current expression.\n+        return eval;\n+      }\n+      evalSet.add(eval);\n       match.reset(eval);\n       if (!match.find()) {\n         return eval;\n       }\n       String var \u003d match.group();\n       var \u003d var.substring(2, var.length()-1); // remove ${ .. }\n       String val \u003d null;\n       try {\n         val \u003d System.getProperty(var);\n       } catch(SecurityException se) {\n         LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n       }\n       if (val \u003d\u003d null) {\n         val \u003d getRaw(var);\n       }\n       if (val \u003d\u003d null) {\n         return eval; // return literal ${var}: var is unbound\n       }\n       // substitute\n       eval \u003d eval.substring(0, match.start())+val+eval.substring(match.end());\n     }\n     throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                     + MAX_SUBST + \" \" + expr);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private String substituteVars(String expr) {\n    if (expr \u003d\u003d null) {\n      return null;\n    }\n    Matcher match \u003d varPat.matcher(\"\");\n    String eval \u003d expr;\n    Set\u003cString\u003e evalSet \u003d new HashSet\u003cString\u003e();\n    for(int s\u003d0; s\u003cMAX_SUBST; s++) {\n      if (evalSet.contains(eval)) {\n        // Cyclic resolution pattern detected. Return current expression.\n        return eval;\n      }\n      evalSet.add(eval);\n      match.reset(eval);\n      if (!match.find()) {\n        return eval;\n      }\n      String var \u003d match.group();\n      var \u003d var.substring(2, var.length()-1); // remove ${ .. }\n      String val \u003d null;\n      try {\n        val \u003d System.getProperty(var);\n      } catch(SecurityException se) {\n        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n      }\n      if (val \u003d\u003d null) {\n        val \u003d getRaw(var);\n      }\n      if (val \u003d\u003d null) {\n        return eval; // return literal ${var}: var is unbound\n      }\n      // substitute\n      eval \u003d eval.substring(0, match.start())+val+eval.substring(match.end());\n    }\n    throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                    + MAX_SUBST + \" \" + expr);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private String substituteVars(String expr) {\n    if (expr \u003d\u003d null) {\n      return null;\n    }\n    Matcher match \u003d varPat.matcher(\"\");\n    String eval \u003d expr;\n    for(int s\u003d0; s\u003cMAX_SUBST; s++) {\n      match.reset(eval);\n      if (!match.find()) {\n        return eval;\n      }\n      String var \u003d match.group();\n      var \u003d var.substring(2, var.length()-1); // remove ${ .. }\n      String val \u003d null;\n      try {\n        val \u003d System.getProperty(var);\n      } catch(SecurityException se) {\n        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n      }\n      if (val \u003d\u003d null) {\n        val \u003d getRaw(var);\n      }\n      if (val \u003d\u003d null) {\n        return eval; // return literal ${var}: var is unbound\n      }\n      // substitute\n      eval \u003d eval.substring(0, match.start())+val+eval.substring(match.end());\n    }\n    throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                    + MAX_SUBST + \" \" + expr);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private String substituteVars(String expr) {\n    if (expr \u003d\u003d null) {\n      return null;\n    }\n    Matcher match \u003d varPat.matcher(\"\");\n    String eval \u003d expr;\n    for(int s\u003d0; s\u003cMAX_SUBST; s++) {\n      match.reset(eval);\n      if (!match.find()) {\n        return eval;\n      }\n      String var \u003d match.group();\n      var \u003d var.substring(2, var.length()-1); // remove ${ .. }\n      String val \u003d null;\n      try {\n        val \u003d System.getProperty(var);\n      } catch(SecurityException se) {\n        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n      }\n      if (val \u003d\u003d null) {\n        val \u003d getRaw(var);\n      }\n      if (val \u003d\u003d null) {\n        return eval; // return literal ${var}: var is unbound\n      }\n      // substitute\n      eval \u003d eval.substring(0, match.start())+val+eval.substring(match.end());\n    }\n    throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                    + MAX_SUBST + \" \" + expr);\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/conf/Configuration.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private String substituteVars(String expr) {\n    if (expr \u003d\u003d null) {\n      return null;\n    }\n    Matcher match \u003d varPat.matcher(\"\");\n    String eval \u003d expr;\n    for(int s\u003d0; s\u003cMAX_SUBST; s++) {\n      match.reset(eval);\n      if (!match.find()) {\n        return eval;\n      }\n      String var \u003d match.group();\n      var \u003d var.substring(2, var.length()-1); // remove ${ .. }\n      String val \u003d null;\n      try {\n        val \u003d System.getProperty(var);\n      } catch(SecurityException se) {\n        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n      }\n      if (val \u003d\u003d null) {\n        val \u003d getRaw(var);\n      }\n      if (val \u003d\u003d null) {\n        return eval; // return literal ${var}: var is unbound\n      }\n      // substitute\n      eval \u003d eval.substring(0, match.start())+val+eval.substring(match.end());\n    }\n    throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                    + MAX_SUBST + \" \" + expr);\n  }",
      "path": "common/src/java/org/apache/hadoop/conf/Configuration.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/conf/Configuration.java",
        "newPath": "common/src/java/org/apache/hadoop/conf/Configuration.java"
      }
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,31 @@\n+  private String substituteVars(String expr) {\n+    if (expr \u003d\u003d null) {\n+      return null;\n+    }\n+    Matcher match \u003d varPat.matcher(\"\");\n+    String eval \u003d expr;\n+    for(int s\u003d0; s\u003cMAX_SUBST; s++) {\n+      match.reset(eval);\n+      if (!match.find()) {\n+        return eval;\n+      }\n+      String var \u003d match.group();\n+      var \u003d var.substring(2, var.length()-1); // remove ${ .. }\n+      String val \u003d null;\n+      try {\n+        val \u003d System.getProperty(var);\n+      } catch(SecurityException se) {\n+        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n+      }\n+      if (val \u003d\u003d null) {\n+        val \u003d getRaw(var);\n+      }\n+      if (val \u003d\u003d null) {\n+        return eval; // return literal ${var}: var is unbound\n+      }\n+      // substitute\n+      eval \u003d eval.substring(0, match.start())+val+eval.substring(match.end());\n+    }\n+    throw new IllegalStateException(\"Variable substitution depth too large: \" \n+                                    + MAX_SUBST + \" \" + expr);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private String substituteVars(String expr) {\n    if (expr \u003d\u003d null) {\n      return null;\n    }\n    Matcher match \u003d varPat.matcher(\"\");\n    String eval \u003d expr;\n    for(int s\u003d0; s\u003cMAX_SUBST; s++) {\n      match.reset(eval);\n      if (!match.find()) {\n        return eval;\n      }\n      String var \u003d match.group();\n      var \u003d var.substring(2, var.length()-1); // remove ${ .. }\n      String val \u003d null;\n      try {\n        val \u003d System.getProperty(var);\n      } catch(SecurityException se) {\n        LOG.warn(\"Unexpected SecurityException in Configuration\", se);\n      }\n      if (val \u003d\u003d null) {\n        val \u003d getRaw(var);\n      }\n      if (val \u003d\u003d null) {\n        return eval; // return literal ${var}: var is unbound\n      }\n      // substitute\n      eval \u003d eval.substring(0, match.start())+val+eval.substring(match.end());\n    }\n    throw new IllegalStateException(\"Variable substitution depth too large: \" \n                                    + MAX_SUBST + \" \" + expr);\n  }",
      "path": "src/java/org/apache/hadoop/conf/Configuration.java"
    }
  }
}