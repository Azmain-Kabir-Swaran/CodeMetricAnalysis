{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FileSystemTimelineReaderImpl.java",
  "functionName": "getEntities",
  "functionId": "getEntities___dir-Path__entityType-String__filters-TimelineEntityFilters__dataToRetrieve-TimelineDataToRetrieve",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java",
  "functionStartLine": 276,
  "functionEndLine": 375,
  "numCommitsSeen": 54,
  "timeTaken": 5770,
  "changeHistory": [
    "bca928d3c7b88f39e9bc1784889596f0b00964d4",
    "0f1af3178eb2a38aaaa1e1a27edd409cda19a198",
    "c2efdc415a13496da43a9a8d13c73d88ca8565a1",
    "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3",
    "6934b05c7117a12286fb2ba7a47f75e227cacb22",
    "1f710484e5b8ab4d5c67379c012004e8a4242d15",
    "b51d0fef56a59b15489f5b932025718b4e9613d2",
    "9e5155be363c6610ccf41fe08b7f1394f353ea65",
    "2d59bc4458eaeba6e5b98709340db6f0f1204b59"
  ],
  "changeHistoryShort": {
    "bca928d3c7b88f39e9bc1784889596f0b00964d4": "Ymultichange(Yparameterchange,Ybodychange)",
    "0f1af3178eb2a38aaaa1e1a27edd409cda19a198": "Ybodychange",
    "c2efdc415a13496da43a9a8d13c73d88ca8565a1": "Ybodychange",
    "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3": "Ymultichange(Yparameterchange,Ybodychange)",
    "6934b05c7117a12286fb2ba7a47f75e227cacb22": "Ymultichange(Yparameterchange,Ybodychange)",
    "1f710484e5b8ab4d5c67379c012004e8a4242d15": "Yparameterchange",
    "b51d0fef56a59b15489f5b932025718b4e9613d2": "Ybodychange",
    "9e5155be363c6610ccf41fe08b7f1394f353ea65": "Ybodychange",
    "2d59bc4458eaeba6e5b98709340db6f0f1204b59": "Yintroduced"
  },
  "changeHistoryDetails": {
    "bca928d3c7b88f39e9bc1784889596f0b00964d4": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3879 [Storage implementation] Create HDFS backing storage implementation for ATS reads. Contributed by Abhishek Modi.\n",
      "commitDate": "11/10/18 9:14 PM",
      "commitName": "bca928d3c7b88f39e9bc1784889596f0b00964d4",
      "commitAuthor": "Vrushali C",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3879 [Storage implementation] Create HDFS backing storage implementation for ATS reads. Contributed by Abhishek Modi.\n",
          "commitDate": "11/10/18 9:14 PM",
          "commitName": "bca928d3c7b88f39e9bc1784889596f0b00964d4",
          "commitAuthor": "Vrushali C",
          "commitDateOld": "29/08/17 10:59 PM",
          "commitNameOld": "4481561e4a3433197dd8e73f38856eef84f0fd03",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 407.93,
          "commitsBetweenForRepo": 3724,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,97 +1,100 @@\n-  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n+  private Set\u003cTimelineEntity\u003e getEntities(Path dir, String entityType,\n       TimelineEntityFilters filters, TimelineDataToRetrieve dataToRetrieve)\n       throws IOException {\n     // First sort the selected entities based on created/start time.\n     Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n         new TreeMap\u003c\u003e(\n             new Comparator\u003cLong\u003e() {\n             @Override\n             public int compare(Long l1, Long l2) {\n               return l2.compareTo(l1);\n             }\n           }\n         );\n     if (dir !\u003d null) {\n-      File[] files \u003d dir.listFiles();\n-      if (files !\u003d null) {\n-        for (File entityFile : files) {\n+      RemoteIterator\u003cLocatedFileStatus\u003e fileStatuses \u003d fs.listFiles(dir,\n+              false);\n+      if (fileStatuses !\u003d null) {\n+        while (fileStatuses.hasNext()) {\n+          LocatedFileStatus locatedFileStatus \u003d fileStatuses.next();\n+          Path entityFile \u003d locatedFileStatus.getPath();\n           if (!entityFile.getName()\n               .contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n             continue;\n           }\n           try (BufferedReader reader \u003d new BufferedReader(\n-              new InputStreamReader(new FileInputStream(entityFile),\n+              new InputStreamReader(fs.open(entityFile),\n                   Charset.forName(\"UTF-8\")))) {\n             TimelineEntity entity \u003d readEntityFromFile(reader);\n             if (!entity.getType().equals(entityType)) {\n               continue;\n             }\n             if (!isTimeInRange(entity.getCreatedTime(),\n                 filters.getCreatedTimeBegin(),\n                 filters.getCreatedTimeEnd())) {\n               continue;\n             }\n             if (filters.getRelatesTo() !\u003d null \u0026\u0026\n                 !filters.getRelatesTo().getFilterList().isEmpty() \u0026\u0026\n                 !TimelineStorageUtils.matchRelatesTo(entity,\n                     filters.getRelatesTo())) {\n               continue;\n             }\n             if (filters.getIsRelatedTo() !\u003d null \u0026\u0026\n                 !filters.getIsRelatedTo().getFilterList().isEmpty() \u0026\u0026\n                 !TimelineStorageUtils.matchIsRelatedTo(entity,\n                     filters.getIsRelatedTo())) {\n               continue;\n             }\n             if (filters.getInfoFilters() !\u003d null \u0026\u0026\n                 !filters.getInfoFilters().getFilterList().isEmpty() \u0026\u0026\n                 !TimelineStorageUtils.matchInfoFilters(entity,\n                     filters.getInfoFilters())) {\n               continue;\n             }\n             if (filters.getConfigFilters() !\u003d null \u0026\u0026\n                 !filters.getConfigFilters().getFilterList().isEmpty() \u0026\u0026\n                 !TimelineStorageUtils.matchConfigFilters(entity,\n                     filters.getConfigFilters())) {\n               continue;\n             }\n             if (filters.getMetricFilters() !\u003d null \u0026\u0026\n                 !filters.getMetricFilters().getFilterList().isEmpty() \u0026\u0026\n                 !TimelineStorageUtils.matchMetricFilters(entity,\n                     filters.getMetricFilters())) {\n               continue;\n             }\n             if (filters.getEventFilters() !\u003d null \u0026\u0026\n                 !filters.getEventFilters().getFilterList().isEmpty() \u0026\u0026\n                 !TimelineStorageUtils.matchEventFilters(entity,\n                     filters.getEventFilters())) {\n               continue;\n             }\n             TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n                 entity, dataToRetrieve.getFieldsToRetrieve());\n             Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n                 sortedEntities.get(entityToBeReturned.getCreatedTime());\n             if (entitiesCreatedAtSameTime \u003d\u003d null) {\n               entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n             }\n             entitiesCreatedAtSameTime.add(entityToBeReturned);\n             sortedEntities.put(entityToBeReturned.getCreatedTime(),\n                 entitiesCreatedAtSameTime);\n           }\n         }\n       }\n     }\n \n     Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n     long entitiesAdded \u003d 0;\n     for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n       for (TimelineEntity entity : entitySet) {\n         entities.add(entity);\n         ++entitiesAdded;\n         if (entitiesAdded \u003e\u003d filters.getLimit()) {\n           return entities;\n         }\n       }\n     }\n     return entities;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Set\u003cTimelineEntity\u003e getEntities(Path dir, String entityType,\n      TimelineEntityFilters filters, TimelineDataToRetrieve dataToRetrieve)\n      throws IOException {\n    // First sort the selected entities based on created/start time.\n    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n        new TreeMap\u003c\u003e(\n            new Comparator\u003cLong\u003e() {\n            @Override\n            public int compare(Long l1, Long l2) {\n              return l2.compareTo(l1);\n            }\n          }\n        );\n    if (dir !\u003d null) {\n      RemoteIterator\u003cLocatedFileStatus\u003e fileStatuses \u003d fs.listFiles(dir,\n              false);\n      if (fileStatuses !\u003d null) {\n        while (fileStatuses.hasNext()) {\n          LocatedFileStatus locatedFileStatus \u003d fileStatuses.next();\n          Path entityFile \u003d locatedFileStatus.getPath();\n          if (!entityFile.getName()\n              .contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n            continue;\n          }\n          try (BufferedReader reader \u003d new BufferedReader(\n              new InputStreamReader(fs.open(entityFile),\n                  Charset.forName(\"UTF-8\")))) {\n            TimelineEntity entity \u003d readEntityFromFile(reader);\n            if (!entity.getType().equals(entityType)) {\n              continue;\n            }\n            if (!isTimeInRange(entity.getCreatedTime(),\n                filters.getCreatedTimeBegin(),\n                filters.getCreatedTimeEnd())) {\n              continue;\n            }\n            if (filters.getRelatesTo() !\u003d null \u0026\u0026\n                !filters.getRelatesTo().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchRelatesTo(entity,\n                    filters.getRelatesTo())) {\n              continue;\n            }\n            if (filters.getIsRelatedTo() !\u003d null \u0026\u0026\n                !filters.getIsRelatedTo().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchIsRelatedTo(entity,\n                    filters.getIsRelatedTo())) {\n              continue;\n            }\n            if (filters.getInfoFilters() !\u003d null \u0026\u0026\n                !filters.getInfoFilters().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchInfoFilters(entity,\n                    filters.getInfoFilters())) {\n              continue;\n            }\n            if (filters.getConfigFilters() !\u003d null \u0026\u0026\n                !filters.getConfigFilters().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchConfigFilters(entity,\n                    filters.getConfigFilters())) {\n              continue;\n            }\n            if (filters.getMetricFilters() !\u003d null \u0026\u0026\n                !filters.getMetricFilters().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchMetricFilters(entity,\n                    filters.getMetricFilters())) {\n              continue;\n            }\n            if (filters.getEventFilters() !\u003d null \u0026\u0026\n                !filters.getEventFilters().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchEventFilters(entity,\n                    filters.getEventFilters())) {\n              continue;\n            }\n            TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n                entity, dataToRetrieve.getFieldsToRetrieve());\n            Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n                sortedEntities.get(entityToBeReturned.getCreatedTime());\n            if (entitiesCreatedAtSameTime \u003d\u003d null) {\n              entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n            }\n            entitiesCreatedAtSameTime.add(entityToBeReturned);\n            sortedEntities.put(entityToBeReturned.getCreatedTime(),\n                entitiesCreatedAtSameTime);\n          }\n        }\n      }\n    }\n\n    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n    long entitiesAdded \u003d 0;\n    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n      for (TimelineEntity entity : entitySet) {\n        entities.add(entity);\n        ++entitiesAdded;\n        if (entitiesAdded \u003e\u003d filters.getLimit()) {\n          return entities;\n        }\n      }\n    }\n    return entities;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java",
          "extendedDetails": {
            "oldValue": "[dir-File, entityType-String, filters-TimelineEntityFilters, dataToRetrieve-TimelineDataToRetrieve]",
            "newValue": "[dir-Path, entityType-String, filters-TimelineEntityFilters, dataToRetrieve-TimelineDataToRetrieve]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3879 [Storage implementation] Create HDFS backing storage implementation for ATS reads. Contributed by Abhishek Modi.\n",
          "commitDate": "11/10/18 9:14 PM",
          "commitName": "bca928d3c7b88f39e9bc1784889596f0b00964d4",
          "commitAuthor": "Vrushali C",
          "commitDateOld": "29/08/17 10:59 PM",
          "commitNameOld": "4481561e4a3433197dd8e73f38856eef84f0fd03",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 407.93,
          "commitsBetweenForRepo": 3724,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,97 +1,100 @@\n-  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n+  private Set\u003cTimelineEntity\u003e getEntities(Path dir, String entityType,\n       TimelineEntityFilters filters, TimelineDataToRetrieve dataToRetrieve)\n       throws IOException {\n     // First sort the selected entities based on created/start time.\n     Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n         new TreeMap\u003c\u003e(\n             new Comparator\u003cLong\u003e() {\n             @Override\n             public int compare(Long l1, Long l2) {\n               return l2.compareTo(l1);\n             }\n           }\n         );\n     if (dir !\u003d null) {\n-      File[] files \u003d dir.listFiles();\n-      if (files !\u003d null) {\n-        for (File entityFile : files) {\n+      RemoteIterator\u003cLocatedFileStatus\u003e fileStatuses \u003d fs.listFiles(dir,\n+              false);\n+      if (fileStatuses !\u003d null) {\n+        while (fileStatuses.hasNext()) {\n+          LocatedFileStatus locatedFileStatus \u003d fileStatuses.next();\n+          Path entityFile \u003d locatedFileStatus.getPath();\n           if (!entityFile.getName()\n               .contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n             continue;\n           }\n           try (BufferedReader reader \u003d new BufferedReader(\n-              new InputStreamReader(new FileInputStream(entityFile),\n+              new InputStreamReader(fs.open(entityFile),\n                   Charset.forName(\"UTF-8\")))) {\n             TimelineEntity entity \u003d readEntityFromFile(reader);\n             if (!entity.getType().equals(entityType)) {\n               continue;\n             }\n             if (!isTimeInRange(entity.getCreatedTime(),\n                 filters.getCreatedTimeBegin(),\n                 filters.getCreatedTimeEnd())) {\n               continue;\n             }\n             if (filters.getRelatesTo() !\u003d null \u0026\u0026\n                 !filters.getRelatesTo().getFilterList().isEmpty() \u0026\u0026\n                 !TimelineStorageUtils.matchRelatesTo(entity,\n                     filters.getRelatesTo())) {\n               continue;\n             }\n             if (filters.getIsRelatedTo() !\u003d null \u0026\u0026\n                 !filters.getIsRelatedTo().getFilterList().isEmpty() \u0026\u0026\n                 !TimelineStorageUtils.matchIsRelatedTo(entity,\n                     filters.getIsRelatedTo())) {\n               continue;\n             }\n             if (filters.getInfoFilters() !\u003d null \u0026\u0026\n                 !filters.getInfoFilters().getFilterList().isEmpty() \u0026\u0026\n                 !TimelineStorageUtils.matchInfoFilters(entity,\n                     filters.getInfoFilters())) {\n               continue;\n             }\n             if (filters.getConfigFilters() !\u003d null \u0026\u0026\n                 !filters.getConfigFilters().getFilterList().isEmpty() \u0026\u0026\n                 !TimelineStorageUtils.matchConfigFilters(entity,\n                     filters.getConfigFilters())) {\n               continue;\n             }\n             if (filters.getMetricFilters() !\u003d null \u0026\u0026\n                 !filters.getMetricFilters().getFilterList().isEmpty() \u0026\u0026\n                 !TimelineStorageUtils.matchMetricFilters(entity,\n                     filters.getMetricFilters())) {\n               continue;\n             }\n             if (filters.getEventFilters() !\u003d null \u0026\u0026\n                 !filters.getEventFilters().getFilterList().isEmpty() \u0026\u0026\n                 !TimelineStorageUtils.matchEventFilters(entity,\n                     filters.getEventFilters())) {\n               continue;\n             }\n             TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n                 entity, dataToRetrieve.getFieldsToRetrieve());\n             Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n                 sortedEntities.get(entityToBeReturned.getCreatedTime());\n             if (entitiesCreatedAtSameTime \u003d\u003d null) {\n               entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n             }\n             entitiesCreatedAtSameTime.add(entityToBeReturned);\n             sortedEntities.put(entityToBeReturned.getCreatedTime(),\n                 entitiesCreatedAtSameTime);\n           }\n         }\n       }\n     }\n \n     Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n     long entitiesAdded \u003d 0;\n     for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n       for (TimelineEntity entity : entitySet) {\n         entities.add(entity);\n         ++entitiesAdded;\n         if (entitiesAdded \u003e\u003d filters.getLimit()) {\n           return entities;\n         }\n       }\n     }\n     return entities;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Set\u003cTimelineEntity\u003e getEntities(Path dir, String entityType,\n      TimelineEntityFilters filters, TimelineDataToRetrieve dataToRetrieve)\n      throws IOException {\n    // First sort the selected entities based on created/start time.\n    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n        new TreeMap\u003c\u003e(\n            new Comparator\u003cLong\u003e() {\n            @Override\n            public int compare(Long l1, Long l2) {\n              return l2.compareTo(l1);\n            }\n          }\n        );\n    if (dir !\u003d null) {\n      RemoteIterator\u003cLocatedFileStatus\u003e fileStatuses \u003d fs.listFiles(dir,\n              false);\n      if (fileStatuses !\u003d null) {\n        while (fileStatuses.hasNext()) {\n          LocatedFileStatus locatedFileStatus \u003d fileStatuses.next();\n          Path entityFile \u003d locatedFileStatus.getPath();\n          if (!entityFile.getName()\n              .contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n            continue;\n          }\n          try (BufferedReader reader \u003d new BufferedReader(\n              new InputStreamReader(fs.open(entityFile),\n                  Charset.forName(\"UTF-8\")))) {\n            TimelineEntity entity \u003d readEntityFromFile(reader);\n            if (!entity.getType().equals(entityType)) {\n              continue;\n            }\n            if (!isTimeInRange(entity.getCreatedTime(),\n                filters.getCreatedTimeBegin(),\n                filters.getCreatedTimeEnd())) {\n              continue;\n            }\n            if (filters.getRelatesTo() !\u003d null \u0026\u0026\n                !filters.getRelatesTo().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchRelatesTo(entity,\n                    filters.getRelatesTo())) {\n              continue;\n            }\n            if (filters.getIsRelatedTo() !\u003d null \u0026\u0026\n                !filters.getIsRelatedTo().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchIsRelatedTo(entity,\n                    filters.getIsRelatedTo())) {\n              continue;\n            }\n            if (filters.getInfoFilters() !\u003d null \u0026\u0026\n                !filters.getInfoFilters().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchInfoFilters(entity,\n                    filters.getInfoFilters())) {\n              continue;\n            }\n            if (filters.getConfigFilters() !\u003d null \u0026\u0026\n                !filters.getConfigFilters().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchConfigFilters(entity,\n                    filters.getConfigFilters())) {\n              continue;\n            }\n            if (filters.getMetricFilters() !\u003d null \u0026\u0026\n                !filters.getMetricFilters().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchMetricFilters(entity,\n                    filters.getMetricFilters())) {\n              continue;\n            }\n            if (filters.getEventFilters() !\u003d null \u0026\u0026\n                !filters.getEventFilters().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchEventFilters(entity,\n                    filters.getEventFilters())) {\n              continue;\n            }\n            TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n                entity, dataToRetrieve.getFieldsToRetrieve());\n            Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n                sortedEntities.get(entityToBeReturned.getCreatedTime());\n            if (entitiesCreatedAtSameTime \u003d\u003d null) {\n              entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n            }\n            entitiesCreatedAtSameTime.add(entityToBeReturned);\n            sortedEntities.put(entityToBeReturned.getCreatedTime(),\n                entitiesCreatedAtSameTime);\n          }\n        }\n      }\n    }\n\n    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n    long entitiesAdded \u003d 0;\n    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n      for (TimelineEntity entity : entitySet) {\n        entities.add(entity);\n        ++entitiesAdded;\n        if (entitiesAdded \u003e\u003d filters.getLimit()) {\n          return entities;\n        }\n      }\n    }\n    return entities;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "0f1af3178eb2a38aaaa1e1a27edd409cda19a198": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6518. Fix warnings from Spotbugs in hadoop-yarn-server-timelineservice. Contributed by Weiwei Yang.\n",
      "commitDate": "01/05/17 4:19 AM",
      "commitName": "0f1af3178eb2a38aaaa1e1a27edd409cda19a198",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "21/11/16 5:20 PM",
      "commitNameOld": "6f8074298d8f33effe08f6be49ecfc89f69feda7",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 160.42,
      "commitsBetweenForRepo": 863,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,97 @@\n   private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n       TimelineEntityFilters filters, TimelineDataToRetrieve dataToRetrieve)\n       throws IOException {\n     // First sort the selected entities based on created/start time.\n     Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n         new TreeMap\u003c\u003e(\n             new Comparator\u003cLong\u003e() {\n             @Override\n             public int compare(Long l1, Long l2) {\n               return l2.compareTo(l1);\n             }\n           }\n         );\n-    for (File entityFile : dir.listFiles()) {\n-      if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n-        continue;\n-      }\n-      try (BufferedReader reader \u003d\n-               new BufferedReader(\n-                   new InputStreamReader(\n-                       new FileInputStream(\n-                           entityFile), Charset.forName(\"UTF-8\")))) {\n-        TimelineEntity entity \u003d readEntityFromFile(reader);\n-        if (!entity.getType().equals(entityType)) {\n-          continue;\n+    if (dir !\u003d null) {\n+      File[] files \u003d dir.listFiles();\n+      if (files !\u003d null) {\n+        for (File entityFile : files) {\n+          if (!entityFile.getName()\n+              .contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n+            continue;\n+          }\n+          try (BufferedReader reader \u003d new BufferedReader(\n+              new InputStreamReader(new FileInputStream(entityFile),\n+                  Charset.forName(\"UTF-8\")))) {\n+            TimelineEntity entity \u003d readEntityFromFile(reader);\n+            if (!entity.getType().equals(entityType)) {\n+              continue;\n+            }\n+            if (!isTimeInRange(entity.getCreatedTime(),\n+                filters.getCreatedTimeBegin(),\n+                filters.getCreatedTimeEnd())) {\n+              continue;\n+            }\n+            if (filters.getRelatesTo() !\u003d null \u0026\u0026\n+                !filters.getRelatesTo().getFilterList().isEmpty() \u0026\u0026\n+                !TimelineStorageUtils.matchRelatesTo(entity,\n+                    filters.getRelatesTo())) {\n+              continue;\n+            }\n+            if (filters.getIsRelatedTo() !\u003d null \u0026\u0026\n+                !filters.getIsRelatedTo().getFilterList().isEmpty() \u0026\u0026\n+                !TimelineStorageUtils.matchIsRelatedTo(entity,\n+                    filters.getIsRelatedTo())) {\n+              continue;\n+            }\n+            if (filters.getInfoFilters() !\u003d null \u0026\u0026\n+                !filters.getInfoFilters().getFilterList().isEmpty() \u0026\u0026\n+                !TimelineStorageUtils.matchInfoFilters(entity,\n+                    filters.getInfoFilters())) {\n+              continue;\n+            }\n+            if (filters.getConfigFilters() !\u003d null \u0026\u0026\n+                !filters.getConfigFilters().getFilterList().isEmpty() \u0026\u0026\n+                !TimelineStorageUtils.matchConfigFilters(entity,\n+                    filters.getConfigFilters())) {\n+              continue;\n+            }\n+            if (filters.getMetricFilters() !\u003d null \u0026\u0026\n+                !filters.getMetricFilters().getFilterList().isEmpty() \u0026\u0026\n+                !TimelineStorageUtils.matchMetricFilters(entity,\n+                    filters.getMetricFilters())) {\n+              continue;\n+            }\n+            if (filters.getEventFilters() !\u003d null \u0026\u0026\n+                !filters.getEventFilters().getFilterList().isEmpty() \u0026\u0026\n+                !TimelineStorageUtils.matchEventFilters(entity,\n+                    filters.getEventFilters())) {\n+              continue;\n+            }\n+            TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n+                entity, dataToRetrieve.getFieldsToRetrieve());\n+            Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n+                sortedEntities.get(entityToBeReturned.getCreatedTime());\n+            if (entitiesCreatedAtSameTime \u003d\u003d null) {\n+              entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n+            }\n+            entitiesCreatedAtSameTime.add(entityToBeReturned);\n+            sortedEntities.put(entityToBeReturned.getCreatedTime(),\n+                entitiesCreatedAtSameTime);\n+          }\n         }\n-        if (!isTimeInRange(entity.getCreatedTime(),\n-            filters.getCreatedTimeBegin(), filters.getCreatedTimeEnd())) {\n-          continue;\n-        }\n-        if (filters.getRelatesTo() !\u003d null \u0026\u0026\n-            !filters.getRelatesTo().getFilterList().isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchRelatesTo(entity,\n-            filters.getRelatesTo())) {\n-          continue;\n-        }\n-        if (filters.getIsRelatedTo()  !\u003d null \u0026\u0026\n-            !filters.getIsRelatedTo().getFilterList().isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchIsRelatedTo(entity,\n-            filters.getIsRelatedTo())) {\n-          continue;\n-        }\n-        if (filters.getInfoFilters() !\u003d null \u0026\u0026\n-            !filters.getInfoFilters().getFilterList().isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchInfoFilters(entity,\n-            filters.getInfoFilters())) {\n-          continue;\n-        }\n-        if (filters.getConfigFilters() !\u003d null \u0026\u0026\n-            !filters.getConfigFilters().getFilterList().isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchConfigFilters(entity,\n-            filters.getConfigFilters())) {\n-          continue;\n-        }\n-        if (filters.getMetricFilters() !\u003d null \u0026\u0026\n-            !filters.getMetricFilters().getFilterList().isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchMetricFilters(entity,\n-            filters.getMetricFilters())) {\n-          continue;\n-        }\n-        if (filters.getEventFilters() !\u003d null \u0026\u0026\n-            !filters.getEventFilters().getFilterList().isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchEventFilters(entity,\n-            filters.getEventFilters())) {\n-          continue;\n-        }\n-        TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n-            entity, dataToRetrieve.getFieldsToRetrieve());\n-        Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n-            sortedEntities.get(entityToBeReturned.getCreatedTime());\n-        if (entitiesCreatedAtSameTime \u003d\u003d null) {\n-          entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n-        }\n-        entitiesCreatedAtSameTime.add(entityToBeReturned);\n-        sortedEntities.put(\n-            entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n       }\n     }\n \n     Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n     long entitiesAdded \u003d 0;\n     for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n       for (TimelineEntity entity : entitySet) {\n         entities.add(entity);\n         ++entitiesAdded;\n         if (entitiesAdded \u003e\u003d filters.getLimit()) {\n           return entities;\n         }\n       }\n     }\n     return entities;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n      TimelineEntityFilters filters, TimelineDataToRetrieve dataToRetrieve)\n      throws IOException {\n    // First sort the selected entities based on created/start time.\n    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n        new TreeMap\u003c\u003e(\n            new Comparator\u003cLong\u003e() {\n            @Override\n            public int compare(Long l1, Long l2) {\n              return l2.compareTo(l1);\n            }\n          }\n        );\n    if (dir !\u003d null) {\n      File[] files \u003d dir.listFiles();\n      if (files !\u003d null) {\n        for (File entityFile : files) {\n          if (!entityFile.getName()\n              .contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n            continue;\n          }\n          try (BufferedReader reader \u003d new BufferedReader(\n              new InputStreamReader(new FileInputStream(entityFile),\n                  Charset.forName(\"UTF-8\")))) {\n            TimelineEntity entity \u003d readEntityFromFile(reader);\n            if (!entity.getType().equals(entityType)) {\n              continue;\n            }\n            if (!isTimeInRange(entity.getCreatedTime(),\n                filters.getCreatedTimeBegin(),\n                filters.getCreatedTimeEnd())) {\n              continue;\n            }\n            if (filters.getRelatesTo() !\u003d null \u0026\u0026\n                !filters.getRelatesTo().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchRelatesTo(entity,\n                    filters.getRelatesTo())) {\n              continue;\n            }\n            if (filters.getIsRelatedTo() !\u003d null \u0026\u0026\n                !filters.getIsRelatedTo().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchIsRelatedTo(entity,\n                    filters.getIsRelatedTo())) {\n              continue;\n            }\n            if (filters.getInfoFilters() !\u003d null \u0026\u0026\n                !filters.getInfoFilters().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchInfoFilters(entity,\n                    filters.getInfoFilters())) {\n              continue;\n            }\n            if (filters.getConfigFilters() !\u003d null \u0026\u0026\n                !filters.getConfigFilters().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchConfigFilters(entity,\n                    filters.getConfigFilters())) {\n              continue;\n            }\n            if (filters.getMetricFilters() !\u003d null \u0026\u0026\n                !filters.getMetricFilters().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchMetricFilters(entity,\n                    filters.getMetricFilters())) {\n              continue;\n            }\n            if (filters.getEventFilters() !\u003d null \u0026\u0026\n                !filters.getEventFilters().getFilterList().isEmpty() \u0026\u0026\n                !TimelineStorageUtils.matchEventFilters(entity,\n                    filters.getEventFilters())) {\n              continue;\n            }\n            TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n                entity, dataToRetrieve.getFieldsToRetrieve());\n            Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n                sortedEntities.get(entityToBeReturned.getCreatedTime());\n            if (entitiesCreatedAtSameTime \u003d\u003d null) {\n              entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n            }\n            entitiesCreatedAtSameTime.add(entityToBeReturned);\n            sortedEntities.put(entityToBeReturned.getCreatedTime(),\n                entitiesCreatedAtSameTime);\n          }\n        }\n      }\n    }\n\n    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n    long entitiesAdded \u003d 0;\n    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n      for (TimelineEntity entity : entitySet) {\n        entities.add(entity);\n        ++entitiesAdded;\n        if (entitiesAdded \u003e\u003d filters.getLimit()) {\n          return entities;\n        }\n      }\n    }\n    return entities;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java",
      "extendedDetails": {}
    },
    "c2efdc415a13496da43a9a8d13c73d88ca8565a1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3863. Support complex filters in TimelineReader (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "c2efdc415a13496da43a9a8d13c73d88ca8565a1",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "960af7d4717b8a8949d0b2e43949e7daab45aa88",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n   private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n       TimelineEntityFilters filters, TimelineDataToRetrieve dataToRetrieve)\n       throws IOException {\n     // First sort the selected entities based on created/start time.\n     Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n         new TreeMap\u003c\u003e(\n             new Comparator\u003cLong\u003e() {\n             @Override\n             public int compare(Long l1, Long l2) {\n               return l2.compareTo(l1);\n             }\n           }\n         );\n     for (File entityFile : dir.listFiles()) {\n       if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n         continue;\n       }\n       try (BufferedReader reader \u003d\n                new BufferedReader(\n                    new InputStreamReader(\n                        new FileInputStream(\n                            entityFile), Charset.forName(\"UTF-8\")))) {\n         TimelineEntity entity \u003d readEntityFromFile(reader);\n         if (!entity.getType().equals(entityType)) {\n           continue;\n         }\n         if (!isTimeInRange(entity.getCreatedTime(),\n             filters.getCreatedTimeBegin(), filters.getCreatedTimeEnd())) {\n           continue;\n         }\n         if (filters.getRelatesTo() !\u003d null \u0026\u0026\n-            !filters.getRelatesTo().isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchRelations(\n-            entity.getRelatesToEntities(), filters.getRelatesTo())) {\n+            !filters.getRelatesTo().getFilterList().isEmpty() \u0026\u0026\n+            !TimelineStorageUtils.matchRelatesTo(entity,\n+            filters.getRelatesTo())) {\n           continue;\n         }\n         if (filters.getIsRelatedTo()  !\u003d null \u0026\u0026\n-            !filters.getIsRelatedTo().isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchRelations(\n-            entity.getIsRelatedToEntities(), filters.getIsRelatedTo())) {\n+            !filters.getIsRelatedTo().getFilterList().isEmpty() \u0026\u0026\n+            !TimelineStorageUtils.matchIsRelatedTo(entity,\n+            filters.getIsRelatedTo())) {\n           continue;\n         }\n         if (filters.getInfoFilters() !\u003d null \u0026\u0026\n-            !filters.getInfoFilters().isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchFilters(\n-            entity.getInfo(), filters.getInfoFilters())) {\n+            !filters.getInfoFilters().getFilterList().isEmpty() \u0026\u0026\n+            !TimelineStorageUtils.matchInfoFilters(entity,\n+            filters.getInfoFilters())) {\n           continue;\n         }\n         if (filters.getConfigFilters() !\u003d null \u0026\u0026\n-            !filters.getConfigFilters().isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchFilters(\n-            entity.getConfigs(), filters.getConfigFilters())) {\n+            !filters.getConfigFilters().getFilterList().isEmpty() \u0026\u0026\n+            !TimelineStorageUtils.matchConfigFilters(entity,\n+            filters.getConfigFilters())) {\n           continue;\n         }\n         if (filters.getMetricFilters() !\u003d null \u0026\u0026\n-            !filters.getMetricFilters().isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchMetricFilters(\n-            entity.getMetrics(), filters.getMetricFilters())) {\n+            !filters.getMetricFilters().getFilterList().isEmpty() \u0026\u0026\n+            !TimelineStorageUtils.matchMetricFilters(entity,\n+            filters.getMetricFilters())) {\n           continue;\n         }\n         if (filters.getEventFilters() !\u003d null \u0026\u0026\n-            !filters.getEventFilters().isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchEventFilters(\n-            entity.getEvents(), filters.getEventFilters())) {\n+            !filters.getEventFilters().getFilterList().isEmpty() \u0026\u0026\n+            !TimelineStorageUtils.matchEventFilters(entity,\n+            filters.getEventFilters())) {\n           continue;\n         }\n         TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n             entity, dataToRetrieve.getFieldsToRetrieve());\n         Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n             sortedEntities.get(entityToBeReturned.getCreatedTime());\n         if (entitiesCreatedAtSameTime \u003d\u003d null) {\n           entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n         }\n         entitiesCreatedAtSameTime.add(entityToBeReturned);\n         sortedEntities.put(\n             entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n       }\n     }\n \n     Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n     long entitiesAdded \u003d 0;\n     for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n       for (TimelineEntity entity : entitySet) {\n         entities.add(entity);\n         ++entitiesAdded;\n         if (entitiesAdded \u003e\u003d filters.getLimit()) {\n           return entities;\n         }\n       }\n     }\n     return entities;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n      TimelineEntityFilters filters, TimelineDataToRetrieve dataToRetrieve)\n      throws IOException {\n    // First sort the selected entities based on created/start time.\n    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n        new TreeMap\u003c\u003e(\n            new Comparator\u003cLong\u003e() {\n            @Override\n            public int compare(Long l1, Long l2) {\n              return l2.compareTo(l1);\n            }\n          }\n        );\n    for (File entityFile : dir.listFiles()) {\n      if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n        continue;\n      }\n      try (BufferedReader reader \u003d\n               new BufferedReader(\n                   new InputStreamReader(\n                       new FileInputStream(\n                           entityFile), Charset.forName(\"UTF-8\")))) {\n        TimelineEntity entity \u003d readEntityFromFile(reader);\n        if (!entity.getType().equals(entityType)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getCreatedTime(),\n            filters.getCreatedTimeBegin(), filters.getCreatedTimeEnd())) {\n          continue;\n        }\n        if (filters.getRelatesTo() !\u003d null \u0026\u0026\n            !filters.getRelatesTo().getFilterList().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchRelatesTo(entity,\n            filters.getRelatesTo())) {\n          continue;\n        }\n        if (filters.getIsRelatedTo()  !\u003d null \u0026\u0026\n            !filters.getIsRelatedTo().getFilterList().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchIsRelatedTo(entity,\n            filters.getIsRelatedTo())) {\n          continue;\n        }\n        if (filters.getInfoFilters() !\u003d null \u0026\u0026\n            !filters.getInfoFilters().getFilterList().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchInfoFilters(entity,\n            filters.getInfoFilters())) {\n          continue;\n        }\n        if (filters.getConfigFilters() !\u003d null \u0026\u0026\n            !filters.getConfigFilters().getFilterList().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchConfigFilters(entity,\n            filters.getConfigFilters())) {\n          continue;\n        }\n        if (filters.getMetricFilters() !\u003d null \u0026\u0026\n            !filters.getMetricFilters().getFilterList().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchMetricFilters(entity,\n            filters.getMetricFilters())) {\n          continue;\n        }\n        if (filters.getEventFilters() !\u003d null \u0026\u0026\n            !filters.getEventFilters().getFilterList().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchEventFilters(entity,\n            filters.getEventFilters())) {\n          continue;\n        }\n        TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n            entity, dataToRetrieve.getFieldsToRetrieve());\n        Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n            sortedEntities.get(entityToBeReturned.getCreatedTime());\n        if (entitiesCreatedAtSameTime \u003d\u003d null) {\n          entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n        }\n        entitiesCreatedAtSameTime.add(entityToBeReturned);\n        sortedEntities.put(\n            entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n      }\n    }\n\n    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n    long entitiesAdded \u003d 0;\n    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n      for (TimelineEntity entity : entitySet) {\n        entities.add(entity);\n        ++entitiesAdded;\n        if (entitiesAdded \u003e\u003d filters.getLimit()) {\n          return entities;\n        }\n      }\n    }\n    return entities;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java",
      "extendedDetails": {}
    },
    "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4446. Refactor reader API for better extensibility (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3",
      "commitAuthor": "Sangjin Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4446. Refactor reader API for better extensibility (Varun Saxena via sjlee)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3",
          "commitAuthor": "Sangjin Lee",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "6934b05c7117a12286fb2ba7a47f75e227cacb22",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,92 @@\n   private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n-      Long limit, Long createdTimeBegin, Long createdTimeEnd,\n-      Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n-      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n-      Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n-      TimelineFilterList confsToRetrieve, TimelineFilterList metricsToRetrieve,\n-      EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n-    if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n-      limit \u003d DEFAULT_LIMIT;\n-    }\n-    if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n-      createdTimeBegin \u003d 0L;\n-    }\n-    if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n-      createdTimeEnd \u003d Long.MAX_VALUE;\n-    }\n-\n+      TimelineEntityFilters filters, TimelineDataToRetrieve dataToRetrieve)\n+      throws IOException {\n     // First sort the selected entities based on created/start time.\n     Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n         new TreeMap\u003c\u003e(\n             new Comparator\u003cLong\u003e() {\n               @Override\n               public int compare(Long l1, Long l2) {\n                 return l2.compareTo(l1);\n               }\n             }\n         );\n     for (File entityFile : dir.listFiles()) {\n       if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n         continue;\n       }\n       try (BufferedReader reader \u003d\n                new BufferedReader(\n                    new InputStreamReader(\n                        new FileInputStream(\n                            entityFile), Charset.forName(\"UTF-8\")))) {\n         TimelineEntity entity \u003d readEntityFromFile(reader);\n         if (!entity.getType().equals(entityType)) {\n           continue;\n         }\n-        if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n-            createdTimeEnd)) {\n+        if (!isTimeInRange(entity.getCreatedTime(),\n+            filters.getCreatedTimeBegin(), filters.getCreatedTimeEnd())) {\n           continue;\n         }\n-        if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n-            !TimelineStorageUtils\n-                .matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n+        if (filters.getRelatesTo() !\u003d null \u0026\u0026\n+            !filters.getRelatesTo().isEmpty() \u0026\u0026\n+            !TimelineStorageUtils.matchRelations(\n+            entity.getRelatesToEntities(), filters.getRelatesTo())) {\n           continue;\n         }\n-        if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n-            !TimelineStorageUtils\n-                .matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n+        if (filters.getIsRelatedTo()  !\u003d null \u0026\u0026\n+            !filters.getIsRelatedTo().isEmpty() \u0026\u0026\n+            !TimelineStorageUtils.matchRelations(\n+            entity.getIsRelatedToEntities(), filters.getIsRelatedTo())) {\n           continue;\n         }\n-        if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n-          continue;\n-        }\n-        if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n+        if (filters.getInfoFilters() !\u003d null \u0026\u0026\n+            !filters.getInfoFilters().isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchFilters(\n-                entity.getConfigs(), configFilters)) {\n+            entity.getInfo(), filters.getInfoFilters())) {\n           continue;\n         }\n-        if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n+        if (filters.getConfigFilters() !\u003d null \u0026\u0026\n+            !filters.getConfigFilters().isEmpty() \u0026\u0026\n+            !TimelineStorageUtils.matchFilters(\n+            entity.getConfigs(), filters.getConfigFilters())) {\n+          continue;\n+        }\n+        if (filters.getMetricFilters() !\u003d null \u0026\u0026\n+            !filters.getMetricFilters().isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchMetricFilters(\n-                entity.getMetrics(), metricFilters)) {\n+            entity.getMetrics(), filters.getMetricFilters())) {\n           continue;\n         }\n-        if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n+        if (filters.getEventFilters() !\u003d null \u0026\u0026\n+            !filters.getEventFilters().isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchEventFilters(\n-                entity.getEvents(), eventFilters)) {\n+            entity.getEvents(), filters.getEventFilters())) {\n           continue;\n         }\n-        TimelineEntity entityToBeReturned \u003d\n-            createEntityToBeReturned(entity, fieldsToRetrieve);\n+        TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n+            entity, dataToRetrieve.getFieldsToRetrieve());\n         Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n             sortedEntities.get(entityToBeReturned.getCreatedTime());\n         if (entitiesCreatedAtSameTime \u003d\u003d null) {\n           entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n         }\n         entitiesCreatedAtSameTime.add(entityToBeReturned);\n         sortedEntities.put(\n             entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n       }\n     }\n \n     Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n     long entitiesAdded \u003d 0;\n     for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n       for (TimelineEntity entity : entitySet) {\n         entities.add(entity);\n         ++entitiesAdded;\n-        if (entitiesAdded \u003e\u003d limit) {\n+        if (entitiesAdded \u003e\u003d filters.getLimit()) {\n           return entities;\n         }\n       }\n     }\n     return entities;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n      TimelineEntityFilters filters, TimelineDataToRetrieve dataToRetrieve)\n      throws IOException {\n    // First sort the selected entities based on created/start time.\n    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n        new TreeMap\u003c\u003e(\n            new Comparator\u003cLong\u003e() {\n              @Override\n              public int compare(Long l1, Long l2) {\n                return l2.compareTo(l1);\n              }\n            }\n        );\n    for (File entityFile : dir.listFiles()) {\n      if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n        continue;\n      }\n      try (BufferedReader reader \u003d\n               new BufferedReader(\n                   new InputStreamReader(\n                       new FileInputStream(\n                           entityFile), Charset.forName(\"UTF-8\")))) {\n        TimelineEntity entity \u003d readEntityFromFile(reader);\n        if (!entity.getType().equals(entityType)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getCreatedTime(),\n            filters.getCreatedTimeBegin(), filters.getCreatedTimeEnd())) {\n          continue;\n        }\n        if (filters.getRelatesTo() !\u003d null \u0026\u0026\n            !filters.getRelatesTo().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchRelations(\n            entity.getRelatesToEntities(), filters.getRelatesTo())) {\n          continue;\n        }\n        if (filters.getIsRelatedTo()  !\u003d null \u0026\u0026\n            !filters.getIsRelatedTo().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchRelations(\n            entity.getIsRelatedToEntities(), filters.getIsRelatedTo())) {\n          continue;\n        }\n        if (filters.getInfoFilters() !\u003d null \u0026\u0026\n            !filters.getInfoFilters().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchFilters(\n            entity.getInfo(), filters.getInfoFilters())) {\n          continue;\n        }\n        if (filters.getConfigFilters() !\u003d null \u0026\u0026\n            !filters.getConfigFilters().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchFilters(\n            entity.getConfigs(), filters.getConfigFilters())) {\n          continue;\n        }\n        if (filters.getMetricFilters() !\u003d null \u0026\u0026\n            !filters.getMetricFilters().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchMetricFilters(\n            entity.getMetrics(), filters.getMetricFilters())) {\n          continue;\n        }\n        if (filters.getEventFilters() !\u003d null \u0026\u0026\n            !filters.getEventFilters().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchEventFilters(\n            entity.getEvents(), filters.getEventFilters())) {\n          continue;\n        }\n        TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n            entity, dataToRetrieve.getFieldsToRetrieve());\n        Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n            sortedEntities.get(entityToBeReturned.getCreatedTime());\n        if (entitiesCreatedAtSameTime \u003d\u003d null) {\n          entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n        }\n        entitiesCreatedAtSameTime.add(entityToBeReturned);\n        sortedEntities.put(\n            entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n      }\n    }\n\n    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n    long entitiesAdded \u003d 0;\n    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n      for (TimelineEntity entity : entitySet) {\n        entities.add(entity);\n        ++entitiesAdded;\n        if (entitiesAdded \u003e\u003d filters.getLimit()) {\n          return entities;\n        }\n      }\n    }\n    return entities;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java",
          "extendedDetails": {
            "oldValue": "[dir-File, entityType-String, limit-Long, createdTimeBegin-Long, createdTimeEnd-Long, relatesTo-Map\u003cString,Set\u003cString\u003e\u003e, isRelatedTo-Map\u003cString,Set\u003cString\u003e\u003e, infoFilters-Map\u003cString,Object\u003e, configFilters-Map\u003cString,String\u003e, metricFilters-Set\u003cString\u003e, eventFilters-Set\u003cString\u003e, confsToRetrieve-TimelineFilterList, metricsToRetrieve-TimelineFilterList, fieldsToRetrieve-EnumSet\u003cField\u003e]",
            "newValue": "[dir-File, entityType-String, filters-TimelineEntityFilters, dataToRetrieve-TimelineDataToRetrieve]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4446. Refactor reader API for better extensibility (Varun Saxena via sjlee)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3",
          "commitAuthor": "Sangjin Lee",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "6934b05c7117a12286fb2ba7a47f75e227cacb22",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,92 @@\n   private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n-      Long limit, Long createdTimeBegin, Long createdTimeEnd,\n-      Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n-      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n-      Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n-      TimelineFilterList confsToRetrieve, TimelineFilterList metricsToRetrieve,\n-      EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n-    if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n-      limit \u003d DEFAULT_LIMIT;\n-    }\n-    if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n-      createdTimeBegin \u003d 0L;\n-    }\n-    if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n-      createdTimeEnd \u003d Long.MAX_VALUE;\n-    }\n-\n+      TimelineEntityFilters filters, TimelineDataToRetrieve dataToRetrieve)\n+      throws IOException {\n     // First sort the selected entities based on created/start time.\n     Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n         new TreeMap\u003c\u003e(\n             new Comparator\u003cLong\u003e() {\n               @Override\n               public int compare(Long l1, Long l2) {\n                 return l2.compareTo(l1);\n               }\n             }\n         );\n     for (File entityFile : dir.listFiles()) {\n       if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n         continue;\n       }\n       try (BufferedReader reader \u003d\n                new BufferedReader(\n                    new InputStreamReader(\n                        new FileInputStream(\n                            entityFile), Charset.forName(\"UTF-8\")))) {\n         TimelineEntity entity \u003d readEntityFromFile(reader);\n         if (!entity.getType().equals(entityType)) {\n           continue;\n         }\n-        if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n-            createdTimeEnd)) {\n+        if (!isTimeInRange(entity.getCreatedTime(),\n+            filters.getCreatedTimeBegin(), filters.getCreatedTimeEnd())) {\n           continue;\n         }\n-        if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n-            !TimelineStorageUtils\n-                .matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n+        if (filters.getRelatesTo() !\u003d null \u0026\u0026\n+            !filters.getRelatesTo().isEmpty() \u0026\u0026\n+            !TimelineStorageUtils.matchRelations(\n+            entity.getRelatesToEntities(), filters.getRelatesTo())) {\n           continue;\n         }\n-        if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n-            !TimelineStorageUtils\n-                .matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n+        if (filters.getIsRelatedTo()  !\u003d null \u0026\u0026\n+            !filters.getIsRelatedTo().isEmpty() \u0026\u0026\n+            !TimelineStorageUtils.matchRelations(\n+            entity.getIsRelatedToEntities(), filters.getIsRelatedTo())) {\n           continue;\n         }\n-        if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n-            !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n-          continue;\n-        }\n-        if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n+        if (filters.getInfoFilters() !\u003d null \u0026\u0026\n+            !filters.getInfoFilters().isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchFilters(\n-                entity.getConfigs(), configFilters)) {\n+            entity.getInfo(), filters.getInfoFilters())) {\n           continue;\n         }\n-        if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n+        if (filters.getConfigFilters() !\u003d null \u0026\u0026\n+            !filters.getConfigFilters().isEmpty() \u0026\u0026\n+            !TimelineStorageUtils.matchFilters(\n+            entity.getConfigs(), filters.getConfigFilters())) {\n+          continue;\n+        }\n+        if (filters.getMetricFilters() !\u003d null \u0026\u0026\n+            !filters.getMetricFilters().isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchMetricFilters(\n-                entity.getMetrics(), metricFilters)) {\n+            entity.getMetrics(), filters.getMetricFilters())) {\n           continue;\n         }\n-        if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n+        if (filters.getEventFilters() !\u003d null \u0026\u0026\n+            !filters.getEventFilters().isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchEventFilters(\n-                entity.getEvents(), eventFilters)) {\n+            entity.getEvents(), filters.getEventFilters())) {\n           continue;\n         }\n-        TimelineEntity entityToBeReturned \u003d\n-            createEntityToBeReturned(entity, fieldsToRetrieve);\n+        TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n+            entity, dataToRetrieve.getFieldsToRetrieve());\n         Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n             sortedEntities.get(entityToBeReturned.getCreatedTime());\n         if (entitiesCreatedAtSameTime \u003d\u003d null) {\n           entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n         }\n         entitiesCreatedAtSameTime.add(entityToBeReturned);\n         sortedEntities.put(\n             entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n       }\n     }\n \n     Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n     long entitiesAdded \u003d 0;\n     for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n       for (TimelineEntity entity : entitySet) {\n         entities.add(entity);\n         ++entitiesAdded;\n-        if (entitiesAdded \u003e\u003d limit) {\n+        if (entitiesAdded \u003e\u003d filters.getLimit()) {\n           return entities;\n         }\n       }\n     }\n     return entities;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n      TimelineEntityFilters filters, TimelineDataToRetrieve dataToRetrieve)\n      throws IOException {\n    // First sort the selected entities based on created/start time.\n    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n        new TreeMap\u003c\u003e(\n            new Comparator\u003cLong\u003e() {\n              @Override\n              public int compare(Long l1, Long l2) {\n                return l2.compareTo(l1);\n              }\n            }\n        );\n    for (File entityFile : dir.listFiles()) {\n      if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n        continue;\n      }\n      try (BufferedReader reader \u003d\n               new BufferedReader(\n                   new InputStreamReader(\n                       new FileInputStream(\n                           entityFile), Charset.forName(\"UTF-8\")))) {\n        TimelineEntity entity \u003d readEntityFromFile(reader);\n        if (!entity.getType().equals(entityType)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getCreatedTime(),\n            filters.getCreatedTimeBegin(), filters.getCreatedTimeEnd())) {\n          continue;\n        }\n        if (filters.getRelatesTo() !\u003d null \u0026\u0026\n            !filters.getRelatesTo().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchRelations(\n            entity.getRelatesToEntities(), filters.getRelatesTo())) {\n          continue;\n        }\n        if (filters.getIsRelatedTo()  !\u003d null \u0026\u0026\n            !filters.getIsRelatedTo().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchRelations(\n            entity.getIsRelatedToEntities(), filters.getIsRelatedTo())) {\n          continue;\n        }\n        if (filters.getInfoFilters() !\u003d null \u0026\u0026\n            !filters.getInfoFilters().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchFilters(\n            entity.getInfo(), filters.getInfoFilters())) {\n          continue;\n        }\n        if (filters.getConfigFilters() !\u003d null \u0026\u0026\n            !filters.getConfigFilters().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchFilters(\n            entity.getConfigs(), filters.getConfigFilters())) {\n          continue;\n        }\n        if (filters.getMetricFilters() !\u003d null \u0026\u0026\n            !filters.getMetricFilters().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchMetricFilters(\n            entity.getMetrics(), filters.getMetricFilters())) {\n          continue;\n        }\n        if (filters.getEventFilters() !\u003d null \u0026\u0026\n            !filters.getEventFilters().isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchEventFilters(\n            entity.getEvents(), filters.getEventFilters())) {\n          continue;\n        }\n        TimelineEntity entityToBeReturned \u003d createEntityToBeReturned(\n            entity, dataToRetrieve.getFieldsToRetrieve());\n        Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n            sortedEntities.get(entityToBeReturned.getCreatedTime());\n        if (entitiesCreatedAtSameTime \u003d\u003d null) {\n          entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n        }\n        entitiesCreatedAtSameTime.add(entityToBeReturned);\n        sortedEntities.put(\n            entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n      }\n    }\n\n    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n    long entitiesAdded \u003d 0;\n    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n      for (TimelineEntity entity : entitySet) {\n        entities.add(entity);\n        ++entitiesAdded;\n        if (entitiesAdded \u003e\u003d filters.getLimit()) {\n          return entities;\n        }\n      }\n    }\n    return entities;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "6934b05c7117a12286fb2ba7a47f75e227cacb22": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4238. createdTime and modifiedTime is not reported while publishing entities to ATSv2. (Varun Saxena via Naganarasimha G R)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "6934b05c7117a12286fb2ba7a47f75e227cacb22",
      "commitAuthor": "Naganarasimha",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4238. createdTime and modifiedTime is not reported while publishing entities to ATSv2. (Varun Saxena via Naganarasimha G R)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "6934b05c7117a12286fb2ba7a47f75e227cacb22",
          "commitAuthor": "Naganarasimha",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "8ef546c1ee9fce0b171813547253374d268566ba",
          "commitAuthorOld": "Li Lu",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,99 @@\n   private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n-      Long limit, Long createdTimeBegin,\n-      Long createdTimeEnd, Long modifiedTimeBegin, Long modifiedTimeEnd,\n+      Long limit, Long createdTimeBegin, Long createdTimeEnd,\n       Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n       Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n       Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n       TimelineFilterList confsToRetrieve, TimelineFilterList metricsToRetrieve,\n       EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n     if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n       limit \u003d DEFAULT_LIMIT;\n     }\n     if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n       createdTimeBegin \u003d 0L;\n     }\n     if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n       createdTimeEnd \u003d Long.MAX_VALUE;\n     }\n-    if (modifiedTimeBegin \u003d\u003d null || modifiedTimeBegin \u003c\u003d 0) {\n-      modifiedTimeBegin \u003d 0L;\n-    }\n-    if (modifiedTimeEnd \u003d\u003d null || modifiedTimeEnd \u003c\u003d 0) {\n-      modifiedTimeEnd \u003d Long.MAX_VALUE;\n-    }\n \n     // First sort the selected entities based on created/start time.\n     Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n         new TreeMap\u003c\u003e(\n             new Comparator\u003cLong\u003e() {\n               @Override\n               public int compare(Long l1, Long l2) {\n                 return l2.compareTo(l1);\n               }\n             }\n         );\n     for (File entityFile : dir.listFiles()) {\n       if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n         continue;\n       }\n       try (BufferedReader reader \u003d\n                new BufferedReader(\n                    new InputStreamReader(\n                        new FileInputStream(\n                            entityFile), Charset.forName(\"UTF-8\")))) {\n         TimelineEntity entity \u003d readEntityFromFile(reader);\n         if (!entity.getType().equals(entityType)) {\n           continue;\n         }\n         if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n             createdTimeEnd)) {\n           continue;\n         }\n-        if (!isTimeInRange(entity.getModifiedTime(), modifiedTimeBegin,\n-            modifiedTimeEnd)) {\n-          continue;\n-        }\n         if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n             !TimelineStorageUtils\n                 .matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n           continue;\n         }\n         if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n             !TimelineStorageUtils\n                 .matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n           continue;\n         }\n         if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n           continue;\n         }\n         if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchFilters(\n                 entity.getConfigs(), configFilters)) {\n           continue;\n         }\n         if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchMetricFilters(\n                 entity.getMetrics(), metricFilters)) {\n           continue;\n         }\n         if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchEventFilters(\n                 entity.getEvents(), eventFilters)) {\n           continue;\n         }\n         TimelineEntity entityToBeReturned \u003d\n             createEntityToBeReturned(entity, fieldsToRetrieve);\n         Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n             sortedEntities.get(entityToBeReturned.getCreatedTime());\n         if (entitiesCreatedAtSameTime \u003d\u003d null) {\n           entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n         }\n         entitiesCreatedAtSameTime.add(entityToBeReturned);\n         sortedEntities.put(\n             entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n       }\n     }\n \n     Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n     long entitiesAdded \u003d 0;\n     for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n       for (TimelineEntity entity : entitySet) {\n         entities.add(entity);\n         ++entitiesAdded;\n         if (entitiesAdded \u003e\u003d limit) {\n           return entities;\n         }\n       }\n     }\n     return entities;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n      Long limit, Long createdTimeBegin, Long createdTimeEnd,\n      Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n      Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n      TimelineFilterList confsToRetrieve, TimelineFilterList metricsToRetrieve,\n      EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n    if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n      limit \u003d DEFAULT_LIMIT;\n    }\n    if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n      createdTimeBegin \u003d 0L;\n    }\n    if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n      createdTimeEnd \u003d Long.MAX_VALUE;\n    }\n\n    // First sort the selected entities based on created/start time.\n    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n        new TreeMap\u003c\u003e(\n            new Comparator\u003cLong\u003e() {\n              @Override\n              public int compare(Long l1, Long l2) {\n                return l2.compareTo(l1);\n              }\n            }\n        );\n    for (File entityFile : dir.listFiles()) {\n      if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n        continue;\n      }\n      try (BufferedReader reader \u003d\n               new BufferedReader(\n                   new InputStreamReader(\n                       new FileInputStream(\n                           entityFile), Charset.forName(\"UTF-8\")))) {\n        TimelineEntity entity \u003d readEntityFromFile(reader);\n        if (!entity.getType().equals(entityType)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n            createdTimeEnd)) {\n          continue;\n        }\n        if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n            !TimelineStorageUtils\n                .matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n          continue;\n        }\n        if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n            !TimelineStorageUtils\n                .matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n          continue;\n        }\n        if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n          continue;\n        }\n        if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchFilters(\n                entity.getConfigs(), configFilters)) {\n          continue;\n        }\n        if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchMetricFilters(\n                entity.getMetrics(), metricFilters)) {\n          continue;\n        }\n        if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchEventFilters(\n                entity.getEvents(), eventFilters)) {\n          continue;\n        }\n        TimelineEntity entityToBeReturned \u003d\n            createEntityToBeReturned(entity, fieldsToRetrieve);\n        Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n            sortedEntities.get(entityToBeReturned.getCreatedTime());\n        if (entitiesCreatedAtSameTime \u003d\u003d null) {\n          entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n        }\n        entitiesCreatedAtSameTime.add(entityToBeReturned);\n        sortedEntities.put(\n            entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n      }\n    }\n\n    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n    long entitiesAdded \u003d 0;\n    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n      for (TimelineEntity entity : entitySet) {\n        entities.add(entity);\n        ++entitiesAdded;\n        if (entitiesAdded \u003e\u003d limit) {\n          return entities;\n        }\n      }\n    }\n    return entities;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java",
          "extendedDetails": {
            "oldValue": "[dir-File, entityType-String, limit-Long, createdTimeBegin-Long, createdTimeEnd-Long, modifiedTimeBegin-Long, modifiedTimeEnd-Long, relatesTo-Map\u003cString,Set\u003cString\u003e\u003e, isRelatedTo-Map\u003cString,Set\u003cString\u003e\u003e, infoFilters-Map\u003cString,Object\u003e, configFilters-Map\u003cString,String\u003e, metricFilters-Set\u003cString\u003e, eventFilters-Set\u003cString\u003e, confsToRetrieve-TimelineFilterList, metricsToRetrieve-TimelineFilterList, fieldsToRetrieve-EnumSet\u003cField\u003e]",
            "newValue": "[dir-File, entityType-String, limit-Long, createdTimeBegin-Long, createdTimeEnd-Long, relatesTo-Map\u003cString,Set\u003cString\u003e\u003e, isRelatedTo-Map\u003cString,Set\u003cString\u003e\u003e, infoFilters-Map\u003cString,Object\u003e, configFilters-Map\u003cString,String\u003e, metricFilters-Set\u003cString\u003e, eventFilters-Set\u003cString\u003e, confsToRetrieve-TimelineFilterList, metricsToRetrieve-TimelineFilterList, fieldsToRetrieve-EnumSet\u003cField\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4238. createdTime and modifiedTime is not reported while publishing entities to ATSv2. (Varun Saxena via Naganarasimha G R)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "6934b05c7117a12286fb2ba7a47f75e227cacb22",
          "commitAuthor": "Naganarasimha",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "8ef546c1ee9fce0b171813547253374d268566ba",
          "commitAuthorOld": "Li Lu",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,99 @@\n   private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n-      Long limit, Long createdTimeBegin,\n-      Long createdTimeEnd, Long modifiedTimeBegin, Long modifiedTimeEnd,\n+      Long limit, Long createdTimeBegin, Long createdTimeEnd,\n       Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n       Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n       Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n       TimelineFilterList confsToRetrieve, TimelineFilterList metricsToRetrieve,\n       EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n     if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n       limit \u003d DEFAULT_LIMIT;\n     }\n     if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n       createdTimeBegin \u003d 0L;\n     }\n     if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n       createdTimeEnd \u003d Long.MAX_VALUE;\n     }\n-    if (modifiedTimeBegin \u003d\u003d null || modifiedTimeBegin \u003c\u003d 0) {\n-      modifiedTimeBegin \u003d 0L;\n-    }\n-    if (modifiedTimeEnd \u003d\u003d null || modifiedTimeEnd \u003c\u003d 0) {\n-      modifiedTimeEnd \u003d Long.MAX_VALUE;\n-    }\n \n     // First sort the selected entities based on created/start time.\n     Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n         new TreeMap\u003c\u003e(\n             new Comparator\u003cLong\u003e() {\n               @Override\n               public int compare(Long l1, Long l2) {\n                 return l2.compareTo(l1);\n               }\n             }\n         );\n     for (File entityFile : dir.listFiles()) {\n       if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n         continue;\n       }\n       try (BufferedReader reader \u003d\n                new BufferedReader(\n                    new InputStreamReader(\n                        new FileInputStream(\n                            entityFile), Charset.forName(\"UTF-8\")))) {\n         TimelineEntity entity \u003d readEntityFromFile(reader);\n         if (!entity.getType().equals(entityType)) {\n           continue;\n         }\n         if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n             createdTimeEnd)) {\n           continue;\n         }\n-        if (!isTimeInRange(entity.getModifiedTime(), modifiedTimeBegin,\n-            modifiedTimeEnd)) {\n-          continue;\n-        }\n         if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n             !TimelineStorageUtils\n                 .matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n           continue;\n         }\n         if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n             !TimelineStorageUtils\n                 .matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n           continue;\n         }\n         if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n           continue;\n         }\n         if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchFilters(\n                 entity.getConfigs(), configFilters)) {\n           continue;\n         }\n         if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchMetricFilters(\n                 entity.getMetrics(), metricFilters)) {\n           continue;\n         }\n         if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchEventFilters(\n                 entity.getEvents(), eventFilters)) {\n           continue;\n         }\n         TimelineEntity entityToBeReturned \u003d\n             createEntityToBeReturned(entity, fieldsToRetrieve);\n         Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n             sortedEntities.get(entityToBeReturned.getCreatedTime());\n         if (entitiesCreatedAtSameTime \u003d\u003d null) {\n           entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n         }\n         entitiesCreatedAtSameTime.add(entityToBeReturned);\n         sortedEntities.put(\n             entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n       }\n     }\n \n     Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n     long entitiesAdded \u003d 0;\n     for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n       for (TimelineEntity entity : entitySet) {\n         entities.add(entity);\n         ++entitiesAdded;\n         if (entitiesAdded \u003e\u003d limit) {\n           return entities;\n         }\n       }\n     }\n     return entities;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n      Long limit, Long createdTimeBegin, Long createdTimeEnd,\n      Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n      Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n      TimelineFilterList confsToRetrieve, TimelineFilterList metricsToRetrieve,\n      EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n    if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n      limit \u003d DEFAULT_LIMIT;\n    }\n    if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n      createdTimeBegin \u003d 0L;\n    }\n    if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n      createdTimeEnd \u003d Long.MAX_VALUE;\n    }\n\n    // First sort the selected entities based on created/start time.\n    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n        new TreeMap\u003c\u003e(\n            new Comparator\u003cLong\u003e() {\n              @Override\n              public int compare(Long l1, Long l2) {\n                return l2.compareTo(l1);\n              }\n            }\n        );\n    for (File entityFile : dir.listFiles()) {\n      if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n        continue;\n      }\n      try (BufferedReader reader \u003d\n               new BufferedReader(\n                   new InputStreamReader(\n                       new FileInputStream(\n                           entityFile), Charset.forName(\"UTF-8\")))) {\n        TimelineEntity entity \u003d readEntityFromFile(reader);\n        if (!entity.getType().equals(entityType)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n            createdTimeEnd)) {\n          continue;\n        }\n        if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n            !TimelineStorageUtils\n                .matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n          continue;\n        }\n        if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n            !TimelineStorageUtils\n                .matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n          continue;\n        }\n        if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n          continue;\n        }\n        if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchFilters(\n                entity.getConfigs(), configFilters)) {\n          continue;\n        }\n        if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchMetricFilters(\n                entity.getMetrics(), metricFilters)) {\n          continue;\n        }\n        if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchEventFilters(\n                entity.getEvents(), eventFilters)) {\n          continue;\n        }\n        TimelineEntity entityToBeReturned \u003d\n            createEntityToBeReturned(entity, fieldsToRetrieve);\n        Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n            sortedEntities.get(entityToBeReturned.getCreatedTime());\n        if (entitiesCreatedAtSameTime \u003d\u003d null) {\n          entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n        }\n        entitiesCreatedAtSameTime.add(entityToBeReturned);\n        sortedEntities.put(\n            entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n      }\n    }\n\n    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n    long entitiesAdded \u003d 0;\n    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n      for (TimelineEntity entity : entitySet) {\n        entities.add(entity);\n        ++entitiesAdded;\n        if (entitiesAdded \u003e\u003d limit) {\n          return entities;\n        }\n      }\n    }\n    return entities;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "1f710484e5b8ab4d5c67379c012004e8a4242d15": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-3862. Support for fetching specific configs and metrics based on prefixes (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "1f710484e5b8ab4d5c67379c012004e8a4242d15",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "b51d0fef56a59b15489f5b932025718b4e9613d2",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,110 @@\n   private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n       Long limit, Long createdTimeBegin,\n       Long createdTimeEnd, Long modifiedTimeBegin, Long modifiedTimeEnd,\n       Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n       Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n       Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n+      TimelineFilterList confsToRetrieve, TimelineFilterList metricsToRetrieve,\n       EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n     if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n       limit \u003d DEFAULT_LIMIT;\n     }\n     if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n       createdTimeBegin \u003d 0L;\n     }\n     if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n       createdTimeEnd \u003d Long.MAX_VALUE;\n     }\n     if (modifiedTimeBegin \u003d\u003d null || modifiedTimeBegin \u003c\u003d 0) {\n       modifiedTimeBegin \u003d 0L;\n     }\n     if (modifiedTimeEnd \u003d\u003d null || modifiedTimeEnd \u003c\u003d 0) {\n       modifiedTimeEnd \u003d Long.MAX_VALUE;\n     }\n \n     // First sort the selected entities based on created/start time.\n     Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n         new TreeMap\u003c\u003e(\n             new Comparator\u003cLong\u003e() {\n               @Override\n               public int compare(Long l1, Long l2) {\n                 return l2.compareTo(l1);\n               }\n             }\n         );\n     for (File entityFile : dir.listFiles()) {\n       if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n         continue;\n       }\n       try (BufferedReader reader \u003d\n                new BufferedReader(\n                    new InputStreamReader(\n                        new FileInputStream(\n                            entityFile), Charset.forName(\"UTF-8\")))) {\n         TimelineEntity entity \u003d readEntityFromFile(reader);\n         if (!entity.getType().equals(entityType)) {\n           continue;\n         }\n         if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n             createdTimeEnd)) {\n           continue;\n         }\n         if (!isTimeInRange(entity.getModifiedTime(), modifiedTimeBegin,\n             modifiedTimeEnd)) {\n           continue;\n         }\n         if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n             !TimelineStorageUtils\n                 .matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n           continue;\n         }\n         if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n             !TimelineStorageUtils\n                 .matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n           continue;\n         }\n         if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n           continue;\n         }\n         if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchFilters(\n                 entity.getConfigs(), configFilters)) {\n           continue;\n         }\n         if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchMetricFilters(\n                 entity.getMetrics(), metricFilters)) {\n           continue;\n         }\n         if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n             !TimelineStorageUtils.matchEventFilters(\n                 entity.getEvents(), eventFilters)) {\n           continue;\n         }\n         TimelineEntity entityToBeReturned \u003d\n             createEntityToBeReturned(entity, fieldsToRetrieve);\n         Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n             sortedEntities.get(entityToBeReturned.getCreatedTime());\n         if (entitiesCreatedAtSameTime \u003d\u003d null) {\n           entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n         }\n         entitiesCreatedAtSameTime.add(entityToBeReturned);\n         sortedEntities.put(\n             entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n       }\n     }\n \n     Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n     long entitiesAdded \u003d 0;\n     for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n       for (TimelineEntity entity : entitySet) {\n         entities.add(entity);\n         ++entitiesAdded;\n         if (entitiesAdded \u003e\u003d limit) {\n           return entities;\n         }\n       }\n     }\n     return entities;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n      Long limit, Long createdTimeBegin,\n      Long createdTimeEnd, Long modifiedTimeBegin, Long modifiedTimeEnd,\n      Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n      Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n      TimelineFilterList confsToRetrieve, TimelineFilterList metricsToRetrieve,\n      EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n    if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n      limit \u003d DEFAULT_LIMIT;\n    }\n    if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n      createdTimeBegin \u003d 0L;\n    }\n    if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n      createdTimeEnd \u003d Long.MAX_VALUE;\n    }\n    if (modifiedTimeBegin \u003d\u003d null || modifiedTimeBegin \u003c\u003d 0) {\n      modifiedTimeBegin \u003d 0L;\n    }\n    if (modifiedTimeEnd \u003d\u003d null || modifiedTimeEnd \u003c\u003d 0) {\n      modifiedTimeEnd \u003d Long.MAX_VALUE;\n    }\n\n    // First sort the selected entities based on created/start time.\n    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n        new TreeMap\u003c\u003e(\n            new Comparator\u003cLong\u003e() {\n              @Override\n              public int compare(Long l1, Long l2) {\n                return l2.compareTo(l1);\n              }\n            }\n        );\n    for (File entityFile : dir.listFiles()) {\n      if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n        continue;\n      }\n      try (BufferedReader reader \u003d\n               new BufferedReader(\n                   new InputStreamReader(\n                       new FileInputStream(\n                           entityFile), Charset.forName(\"UTF-8\")))) {\n        TimelineEntity entity \u003d readEntityFromFile(reader);\n        if (!entity.getType().equals(entityType)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n            createdTimeEnd)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getModifiedTime(), modifiedTimeBegin,\n            modifiedTimeEnd)) {\n          continue;\n        }\n        if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n            !TimelineStorageUtils\n                .matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n          continue;\n        }\n        if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n            !TimelineStorageUtils\n                .matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n          continue;\n        }\n        if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n          continue;\n        }\n        if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchFilters(\n                entity.getConfigs(), configFilters)) {\n          continue;\n        }\n        if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchMetricFilters(\n                entity.getMetrics(), metricFilters)) {\n          continue;\n        }\n        if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchEventFilters(\n                entity.getEvents(), eventFilters)) {\n          continue;\n        }\n        TimelineEntity entityToBeReturned \u003d\n            createEntityToBeReturned(entity, fieldsToRetrieve);\n        Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n            sortedEntities.get(entityToBeReturned.getCreatedTime());\n        if (entitiesCreatedAtSameTime \u003d\u003d null) {\n          entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n        }\n        entitiesCreatedAtSameTime.add(entityToBeReturned);\n        sortedEntities.put(\n            entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n      }\n    }\n\n    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n    long entitiesAdded \u003d 0;\n    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n      for (TimelineEntity entity : entitySet) {\n        entities.add(entity);\n        ++entitiesAdded;\n        if (entitiesAdded \u003e\u003d limit) {\n          return entities;\n        }\n      }\n    }\n    return entities;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java",
      "extendedDetails": {
        "oldValue": "[dir-File, entityType-String, limit-Long, createdTimeBegin-Long, createdTimeEnd-Long, modifiedTimeBegin-Long, modifiedTimeEnd-Long, relatesTo-Map\u003cString,Set\u003cString\u003e\u003e, isRelatedTo-Map\u003cString,Set\u003cString\u003e\u003e, infoFilters-Map\u003cString,Object\u003e, configFilters-Map\u003cString,String\u003e, metricFilters-Set\u003cString\u003e, eventFilters-Set\u003cString\u003e, fieldsToRetrieve-EnumSet\u003cField\u003e]",
        "newValue": "[dir-File, entityType-String, limit-Long, createdTimeBegin-Long, createdTimeEnd-Long, modifiedTimeBegin-Long, modifiedTimeEnd-Long, relatesTo-Map\u003cString,Set\u003cString\u003e\u003e, isRelatedTo-Map\u003cString,Set\u003cString\u003e\u003e, infoFilters-Map\u003cString,Object\u003e, configFilters-Map\u003cString,String\u003e, metricFilters-Set\u003cString\u003e, eventFilters-Set\u003cString\u003e, confsToRetrieve-TimelineFilterList, metricsToRetrieve-TimelineFilterList, fieldsToRetrieve-EnumSet\u003cField\u003e]"
      }
    },
    "b51d0fef56a59b15489f5b932025718b4e9613d2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4178. [storage implementation] app id as string in row keys can cause incorrect ordering (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "b51d0fef56a59b15489f5b932025718b4e9613d2",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "451c13b1de1e42394a4c92888192da9a9519d9ac",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,109 @@\n   private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n       Long limit, Long createdTimeBegin,\n       Long createdTimeEnd, Long modifiedTimeBegin, Long modifiedTimeEnd,\n       Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n       Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n       Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n       EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n     if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n       limit \u003d DEFAULT_LIMIT;\n     }\n     if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n       createdTimeBegin \u003d 0L;\n     }\n     if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n       createdTimeEnd \u003d Long.MAX_VALUE;\n     }\n     if (modifiedTimeBegin \u003d\u003d null || modifiedTimeBegin \u003c\u003d 0) {\n       modifiedTimeBegin \u003d 0L;\n     }\n     if (modifiedTimeEnd \u003d\u003d null || modifiedTimeEnd \u003c\u003d 0) {\n       modifiedTimeEnd \u003d Long.MAX_VALUE;\n     }\n \n     // First sort the selected entities based on created/start time.\n     Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n         new TreeMap\u003c\u003e(\n             new Comparator\u003cLong\u003e() {\n               @Override\n               public int compare(Long l1, Long l2) {\n                 return l2.compareTo(l1);\n               }\n             }\n         );\n     for (File entityFile : dir.listFiles()) {\n       if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n         continue;\n       }\n       try (BufferedReader reader \u003d\n                new BufferedReader(\n                    new InputStreamReader(\n                        new FileInputStream(\n                            entityFile), Charset.forName(\"UTF-8\")))) {\n         TimelineEntity entity \u003d readEntityFromFile(reader);\n         if (!entity.getType().equals(entityType)) {\n           continue;\n         }\n         if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n             createdTimeEnd)) {\n           continue;\n         }\n         if (!isTimeInRange(entity.getModifiedTime(), modifiedTimeBegin,\n             modifiedTimeEnd)) {\n           continue;\n         }\n         if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n-            !TimelineReaderUtils\n+            !TimelineStorageUtils\n                 .matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n           continue;\n         }\n         if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n-            !TimelineReaderUtils\n+            !TimelineStorageUtils\n                 .matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n           continue;\n         }\n         if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n-            !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n+            !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n           continue;\n         }\n         if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n-            !TimelineReaderUtils.matchFilters(\n+            !TimelineStorageUtils.matchFilters(\n                 entity.getConfigs(), configFilters)) {\n           continue;\n         }\n         if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n-            !TimelineReaderUtils.matchMetricFilters(\n+            !TimelineStorageUtils.matchMetricFilters(\n                 entity.getMetrics(), metricFilters)) {\n           continue;\n         }\n         if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n-            !TimelineReaderUtils.matchEventFilters(\n+            !TimelineStorageUtils.matchEventFilters(\n                 entity.getEvents(), eventFilters)) {\n           continue;\n         }\n         TimelineEntity entityToBeReturned \u003d\n             createEntityToBeReturned(entity, fieldsToRetrieve);\n         Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n             sortedEntities.get(entityToBeReturned.getCreatedTime());\n         if (entitiesCreatedAtSameTime \u003d\u003d null) {\n           entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n         }\n         entitiesCreatedAtSameTime.add(entityToBeReturned);\n         sortedEntities.put(\n             entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n       }\n     }\n \n     Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n     long entitiesAdded \u003d 0;\n     for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n       for (TimelineEntity entity : entitySet) {\n         entities.add(entity);\n         ++entitiesAdded;\n         if (entitiesAdded \u003e\u003d limit) {\n           return entities;\n         }\n       }\n     }\n     return entities;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n      Long limit, Long createdTimeBegin,\n      Long createdTimeEnd, Long modifiedTimeBegin, Long modifiedTimeEnd,\n      Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n      Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n      EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n    if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n      limit \u003d DEFAULT_LIMIT;\n    }\n    if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n      createdTimeBegin \u003d 0L;\n    }\n    if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n      createdTimeEnd \u003d Long.MAX_VALUE;\n    }\n    if (modifiedTimeBegin \u003d\u003d null || modifiedTimeBegin \u003c\u003d 0) {\n      modifiedTimeBegin \u003d 0L;\n    }\n    if (modifiedTimeEnd \u003d\u003d null || modifiedTimeEnd \u003c\u003d 0) {\n      modifiedTimeEnd \u003d Long.MAX_VALUE;\n    }\n\n    // First sort the selected entities based on created/start time.\n    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n        new TreeMap\u003c\u003e(\n            new Comparator\u003cLong\u003e() {\n              @Override\n              public int compare(Long l1, Long l2) {\n                return l2.compareTo(l1);\n              }\n            }\n        );\n    for (File entityFile : dir.listFiles()) {\n      if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n        continue;\n      }\n      try (BufferedReader reader \u003d\n               new BufferedReader(\n                   new InputStreamReader(\n                       new FileInputStream(\n                           entityFile), Charset.forName(\"UTF-8\")))) {\n        TimelineEntity entity \u003d readEntityFromFile(reader);\n        if (!entity.getType().equals(entityType)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n            createdTimeEnd)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getModifiedTime(), modifiedTimeBegin,\n            modifiedTimeEnd)) {\n          continue;\n        }\n        if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n            !TimelineStorageUtils\n                .matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n          continue;\n        }\n        if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n            !TimelineStorageUtils\n                .matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n          continue;\n        }\n        if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n          continue;\n        }\n        if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchFilters(\n                entity.getConfigs(), configFilters)) {\n          continue;\n        }\n        if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchMetricFilters(\n                entity.getMetrics(), metricFilters)) {\n          continue;\n        }\n        if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n            !TimelineStorageUtils.matchEventFilters(\n                entity.getEvents(), eventFilters)) {\n          continue;\n        }\n        TimelineEntity entityToBeReturned \u003d\n            createEntityToBeReturned(entity, fieldsToRetrieve);\n        Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n            sortedEntities.get(entityToBeReturned.getCreatedTime());\n        if (entitiesCreatedAtSameTime \u003d\u003d null) {\n          entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n        }\n        entitiesCreatedAtSameTime.add(entityToBeReturned);\n        sortedEntities.put(\n            entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n      }\n    }\n\n    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n    long entitiesAdded \u003d 0;\n    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n      for (TimelineEntity entity : entitySet) {\n        entities.add(entity);\n        ++entitiesAdded;\n        if (entitiesAdded \u003e\u003d limit) {\n          return entities;\n        }\n      }\n    }\n    return entities;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java",
      "extendedDetails": {}
    },
    "9e5155be363c6610ccf41fe08b7f1394f353ea65": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3049. [Storage Implementation] Implement storage reader interface to fetch raw data from HBase backend (Zhijie Shen via sjlee)\n\n(cherry picked from commit 07433c2ad52df9e844dbd90020c277d3df844dcd)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "9e5155be363c6610ccf41fe08b7f1394f353ea65",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "2d59bc4458eaeba6e5b98709340db6f0f1204b59",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,109 @@\n   private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n       Long limit, Long createdTimeBegin,\n       Long createdTimeEnd, Long modifiedTimeBegin, Long modifiedTimeEnd,\n       Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n       Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n       Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n       EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n     if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n       limit \u003d DEFAULT_LIMIT;\n     }\n     if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n       createdTimeBegin \u003d 0L;\n     }\n     if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n       createdTimeEnd \u003d Long.MAX_VALUE;\n     }\n     if (modifiedTimeBegin \u003d\u003d null || modifiedTimeBegin \u003c\u003d 0) {\n       modifiedTimeBegin \u003d 0L;\n     }\n     if (modifiedTimeEnd \u003d\u003d null || modifiedTimeEnd \u003c\u003d 0) {\n       modifiedTimeEnd \u003d Long.MAX_VALUE;\n     }\n \n     // First sort the selected entities based on created/start time.\n     Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n         new TreeMap\u003c\u003e(\n-          new Comparator\u003cLong\u003e() {\n-            @Override\n-            public int compare(Long l1, Long l2) {\n-              return l2.compareTo(l1);\n+            new Comparator\u003cLong\u003e() {\n+              @Override\n+              public int compare(Long l1, Long l2) {\n+                return l2.compareTo(l1);\n+              }\n             }\n-          }\n         );\n     for (File entityFile : dir.listFiles()) {\n       if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n         continue;\n       }\n       try (BufferedReader reader \u003d\n-          new BufferedReader(\n-              new InputStreamReader(\n-                  new FileInputStream(\n-                      entityFile), Charset.forName(\"UTF-8\")))) {\n+               new BufferedReader(\n+                   new InputStreamReader(\n+                       new FileInputStream(\n+                           entityFile), Charset.forName(\"UTF-8\")))) {\n         TimelineEntity entity \u003d readEntityFromFile(reader);\n         if (!entity.getType().equals(entityType)) {\n           continue;\n         }\n         if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n             createdTimeEnd)) {\n           continue;\n         }\n         if (!isTimeInRange(entity.getModifiedTime(), modifiedTimeBegin,\n             modifiedTimeEnd)) {\n           continue;\n         }\n         if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n-            !matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n+            !TimelineReaderUtils\n+                .matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n           continue;\n         }\n         if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n-            !matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n+            !TimelineReaderUtils\n+                .matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n           continue;\n         }\n         if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n-            !matchFilters(entity.getInfo(), infoFilters)) {\n+            !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n           continue;\n         }\n         if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n-            !matchFilters(entity.getConfigs(), configFilters)) {\n+            !TimelineReaderUtils.matchFilters(\n+                entity.getConfigs(), configFilters)) {\n           continue;\n         }\n         if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n-            !matchMetricFilters(entity.getMetrics(), metricFilters)) {\n+            !TimelineReaderUtils.matchMetricFilters(\n+                entity.getMetrics(), metricFilters)) {\n           continue;\n         }\n         if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n-            !matchEventFilters(entity.getEvents(), eventFilters)) {\n+            !TimelineReaderUtils.matchEventFilters(\n+                entity.getEvents(), eventFilters)) {\n           continue;\n         }\n         TimelineEntity entityToBeReturned \u003d\n             createEntityToBeReturned(entity, fieldsToRetrieve);\n         Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n             sortedEntities.get(entityToBeReturned.getCreatedTime());\n         if (entitiesCreatedAtSameTime \u003d\u003d null) {\n           entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n         }\n         entitiesCreatedAtSameTime.add(entityToBeReturned);\n         sortedEntities.put(\n             entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n       }\n     }\n \n     Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n     long entitiesAdded \u003d 0;\n     for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n       for (TimelineEntity entity : entitySet) {\n         entities.add(entity);\n         ++entitiesAdded;\n         if (entitiesAdded \u003e\u003d limit) {\n           return entities;\n         }\n       }\n     }\n     return entities;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n      Long limit, Long createdTimeBegin,\n      Long createdTimeEnd, Long modifiedTimeBegin, Long modifiedTimeEnd,\n      Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n      Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n      EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n    if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n      limit \u003d DEFAULT_LIMIT;\n    }\n    if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n      createdTimeBegin \u003d 0L;\n    }\n    if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n      createdTimeEnd \u003d Long.MAX_VALUE;\n    }\n    if (modifiedTimeBegin \u003d\u003d null || modifiedTimeBegin \u003c\u003d 0) {\n      modifiedTimeBegin \u003d 0L;\n    }\n    if (modifiedTimeEnd \u003d\u003d null || modifiedTimeEnd \u003c\u003d 0) {\n      modifiedTimeEnd \u003d Long.MAX_VALUE;\n    }\n\n    // First sort the selected entities based on created/start time.\n    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n        new TreeMap\u003c\u003e(\n            new Comparator\u003cLong\u003e() {\n              @Override\n              public int compare(Long l1, Long l2) {\n                return l2.compareTo(l1);\n              }\n            }\n        );\n    for (File entityFile : dir.listFiles()) {\n      if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n        continue;\n      }\n      try (BufferedReader reader \u003d\n               new BufferedReader(\n                   new InputStreamReader(\n                       new FileInputStream(\n                           entityFile), Charset.forName(\"UTF-8\")))) {\n        TimelineEntity entity \u003d readEntityFromFile(reader);\n        if (!entity.getType().equals(entityType)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n            createdTimeEnd)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getModifiedTime(), modifiedTimeBegin,\n            modifiedTimeEnd)) {\n          continue;\n        }\n        if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n            !TimelineReaderUtils\n                .matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n          continue;\n        }\n        if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n            !TimelineReaderUtils\n                .matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n          continue;\n        }\n        if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n            !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n          continue;\n        }\n        if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n            !TimelineReaderUtils.matchFilters(\n                entity.getConfigs(), configFilters)) {\n          continue;\n        }\n        if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n            !TimelineReaderUtils.matchMetricFilters(\n                entity.getMetrics(), metricFilters)) {\n          continue;\n        }\n        if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n            !TimelineReaderUtils.matchEventFilters(\n                entity.getEvents(), eventFilters)) {\n          continue;\n        }\n        TimelineEntity entityToBeReturned \u003d\n            createEntityToBeReturned(entity, fieldsToRetrieve);\n        Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n            sortedEntities.get(entityToBeReturned.getCreatedTime());\n        if (entitiesCreatedAtSameTime \u003d\u003d null) {\n          entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n        }\n        entitiesCreatedAtSameTime.add(entityToBeReturned);\n        sortedEntities.put(\n            entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n      }\n    }\n\n    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n    long entitiesAdded \u003d 0;\n    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n      for (TimelineEntity entity : entitySet) {\n        entities.add(entity);\n        ++entitiesAdded;\n        if (entitiesAdded \u003e\u003d limit) {\n          return entities;\n        }\n      }\n    }\n    return entities;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java",
      "extendedDetails": {}
    },
    "2d59bc4458eaeba6e5b98709340db6f0f1204b59": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3051. Created storage oriented reader interface for fetching raw entity data and made the filesystem based implementation. Contributed by Varun Saxena.\n\n(cherry picked from commit 499ce52c7b645ec0b1cc8ac62dc9a3127b987a20)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "2d59bc4458eaeba6e5b98709340db6f0f1204b59",
      "commitAuthor": "Zhijie Shen",
      "diff": "@@ -0,0 +1,104 @@\n+  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n+      Long limit, Long createdTimeBegin,\n+      Long createdTimeEnd, Long modifiedTimeBegin, Long modifiedTimeEnd,\n+      Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n+      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n+      Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n+      EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n+    if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n+      limit \u003d DEFAULT_LIMIT;\n+    }\n+    if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n+      createdTimeBegin \u003d 0L;\n+    }\n+    if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n+      createdTimeEnd \u003d Long.MAX_VALUE;\n+    }\n+    if (modifiedTimeBegin \u003d\u003d null || modifiedTimeBegin \u003c\u003d 0) {\n+      modifiedTimeBegin \u003d 0L;\n+    }\n+    if (modifiedTimeEnd \u003d\u003d null || modifiedTimeEnd \u003c\u003d 0) {\n+      modifiedTimeEnd \u003d Long.MAX_VALUE;\n+    }\n+\n+    // First sort the selected entities based on created/start time.\n+    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n+        new TreeMap\u003c\u003e(\n+          new Comparator\u003cLong\u003e() {\n+            @Override\n+            public int compare(Long l1, Long l2) {\n+              return l2.compareTo(l1);\n+            }\n+          }\n+        );\n+    for (File entityFile : dir.listFiles()) {\n+      if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n+        continue;\n+      }\n+      try (BufferedReader reader \u003d\n+          new BufferedReader(\n+              new InputStreamReader(\n+                  new FileInputStream(\n+                      entityFile), Charset.forName(\"UTF-8\")))) {\n+        TimelineEntity entity \u003d readEntityFromFile(reader);\n+        if (!entity.getType().equals(entityType)) {\n+          continue;\n+        }\n+        if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n+            createdTimeEnd)) {\n+          continue;\n+        }\n+        if (!isTimeInRange(entity.getModifiedTime(), modifiedTimeBegin,\n+            modifiedTimeEnd)) {\n+          continue;\n+        }\n+        if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n+            !matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n+          continue;\n+        }\n+        if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n+            !matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n+          continue;\n+        }\n+        if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n+            !matchFilters(entity.getInfo(), infoFilters)) {\n+          continue;\n+        }\n+        if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n+            !matchFilters(entity.getConfigs(), configFilters)) {\n+          continue;\n+        }\n+        if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n+            !matchMetricFilters(entity.getMetrics(), metricFilters)) {\n+          continue;\n+        }\n+        if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n+            !matchEventFilters(entity.getEvents(), eventFilters)) {\n+          continue;\n+        }\n+        TimelineEntity entityToBeReturned \u003d\n+            createEntityToBeReturned(entity, fieldsToRetrieve);\n+        Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n+            sortedEntities.get(entityToBeReturned.getCreatedTime());\n+        if (entitiesCreatedAtSameTime \u003d\u003d null) {\n+          entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n+        }\n+        entitiesCreatedAtSameTime.add(entityToBeReturned);\n+        sortedEntities.put(\n+            entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n+      }\n+    }\n+\n+    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n+    long entitiesAdded \u003d 0;\n+    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n+      for (TimelineEntity entity : entitySet) {\n+        entities.add(entity);\n+        ++entitiesAdded;\n+        if (entitiesAdded \u003e\u003d limit) {\n+          return entities;\n+        }\n+      }\n+    }\n+    return entities;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Set\u003cTimelineEntity\u003e getEntities(File dir, String entityType,\n      Long limit, Long createdTimeBegin,\n      Long createdTimeEnd, Long modifiedTimeBegin, Long modifiedTimeEnd,\n      Map\u003cString, Set\u003cString\u003e\u003e relatesTo, Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo,\n      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n      Set\u003cString\u003e metricFilters, Set\u003cString\u003e eventFilters,\n      EnumSet\u003cField\u003e fieldsToRetrieve) throws IOException {\n    if (limit \u003d\u003d null || limit \u003c\u003d 0) {\n      limit \u003d DEFAULT_LIMIT;\n    }\n    if (createdTimeBegin \u003d\u003d null || createdTimeBegin \u003c\u003d 0) {\n      createdTimeBegin \u003d 0L;\n    }\n    if (createdTimeEnd \u003d\u003d null || createdTimeEnd \u003c\u003d 0) {\n      createdTimeEnd \u003d Long.MAX_VALUE;\n    }\n    if (modifiedTimeBegin \u003d\u003d null || modifiedTimeBegin \u003c\u003d 0) {\n      modifiedTimeBegin \u003d 0L;\n    }\n    if (modifiedTimeEnd \u003d\u003d null || modifiedTimeEnd \u003c\u003d 0) {\n      modifiedTimeEnd \u003d Long.MAX_VALUE;\n    }\n\n    // First sort the selected entities based on created/start time.\n    Map\u003cLong, Set\u003cTimelineEntity\u003e\u003e sortedEntities \u003d\n        new TreeMap\u003c\u003e(\n          new Comparator\u003cLong\u003e() {\n            @Override\n            public int compare(Long l1, Long l2) {\n              return l2.compareTo(l1);\n            }\n          }\n        );\n    for (File entityFile : dir.listFiles()) {\n      if (!entityFile.getName().contains(TIMELINE_SERVICE_STORAGE_EXTENSION)) {\n        continue;\n      }\n      try (BufferedReader reader \u003d\n          new BufferedReader(\n              new InputStreamReader(\n                  new FileInputStream(\n                      entityFile), Charset.forName(\"UTF-8\")))) {\n        TimelineEntity entity \u003d readEntityFromFile(reader);\n        if (!entity.getType().equals(entityType)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getCreatedTime(), createdTimeBegin,\n            createdTimeEnd)) {\n          continue;\n        }\n        if (!isTimeInRange(entity.getModifiedTime(), modifiedTimeBegin,\n            modifiedTimeEnd)) {\n          continue;\n        }\n        if (relatesTo !\u003d null \u0026\u0026 !relatesTo.isEmpty() \u0026\u0026\n            !matchRelations(entity.getRelatesToEntities(), relatesTo)) {\n          continue;\n        }\n        if (isRelatedTo !\u003d null \u0026\u0026 !isRelatedTo.isEmpty() \u0026\u0026\n            !matchRelations(entity.getIsRelatedToEntities(), isRelatedTo)) {\n          continue;\n        }\n        if (infoFilters !\u003d null \u0026\u0026 !infoFilters.isEmpty() \u0026\u0026\n            !matchFilters(entity.getInfo(), infoFilters)) {\n          continue;\n        }\n        if (configFilters !\u003d null \u0026\u0026 !configFilters.isEmpty() \u0026\u0026\n            !matchFilters(entity.getConfigs(), configFilters)) {\n          continue;\n        }\n        if (metricFilters !\u003d null \u0026\u0026 !metricFilters.isEmpty() \u0026\u0026\n            !matchMetricFilters(entity.getMetrics(), metricFilters)) {\n          continue;\n        }\n        if (eventFilters !\u003d null \u0026\u0026 !eventFilters.isEmpty() \u0026\u0026\n            !matchEventFilters(entity.getEvents(), eventFilters)) {\n          continue;\n        }\n        TimelineEntity entityToBeReturned \u003d\n            createEntityToBeReturned(entity, fieldsToRetrieve);\n        Set\u003cTimelineEntity\u003e entitiesCreatedAtSameTime \u003d\n            sortedEntities.get(entityToBeReturned.getCreatedTime());\n        if (entitiesCreatedAtSameTime \u003d\u003d null) {\n          entitiesCreatedAtSameTime \u003d new HashSet\u003cTimelineEntity\u003e();\n        }\n        entitiesCreatedAtSameTime.add(entityToBeReturned);\n        sortedEntities.put(\n            entityToBeReturned.getCreatedTime(), entitiesCreatedAtSameTime);\n      }\n    }\n\n    Set\u003cTimelineEntity\u003e entities \u003d new HashSet\u003cTimelineEntity\u003e();\n    long entitiesAdded \u003d 0;\n    for (Set\u003cTimelineEntity\u003e entitySet : sortedEntities.values()) {\n      for (TimelineEntity entity : entitySet) {\n        entities.add(entity);\n        ++entitiesAdded;\n        if (entitiesAdded \u003e\u003d limit) {\n          return entities;\n        }\n      }\n    }\n    return entities;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/FileSystemTimelineReaderImpl.java"
    }
  }
}