{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockPlacementPolicyDefault.java",
  "functionName": "getMaxNodesPerRack",
  "functionId": "getMaxNodesPerRack___numOfChosen-int__numOfReplicas-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
  "functionStartLine": 362,
  "functionEndLine": 392,
  "numCommitsSeen": 99,
  "timeTaken": 2943,
  "changeHistory": [
    "944adc61b1830388d520d4052fc7eb6c7ba2790d",
    "9595cc003ca5ed3d59b6942056a4fcb9080f79c9",
    "3ae84e1ba8928879b3eda90e79667ba5a45d60f8"
  ],
  "changeHistoryShort": {
    "944adc61b1830388d520d4052fc7eb6c7ba2790d": "Ybodychange",
    "9595cc003ca5ed3d59b6942056a4fcb9080f79c9": "Ymodifierchange",
    "3ae84e1ba8928879b3eda90e79667ba5a45d60f8": "Ybodychange"
  },
  "changeHistoryDetails": {
    "944adc61b1830388d520d4052fc7eb6c7ba2790d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14527. Stop all DataNodes may result in NN terminate. Contributed by He Xiaoqiao.\n",
      "commitDate": "06/06/19 10:20 AM",
      "commitName": "944adc61b1830388d520d4052fc7eb6c7ba2790d",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "29/05/19 8:56 PM",
      "commitNameOld": "c1caab40f27e3e4f58ff1b5ef3e93efc56bbecbe",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 7.56,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,31 @@\n   protected int[] getMaxNodesPerRack(int numOfChosen, int numOfReplicas) {\n     int clusterSize \u003d clusterMap.getNumOfLeaves();\n     int totalNumOfReplicas \u003d numOfChosen + numOfReplicas;\n     if (totalNumOfReplicas \u003e clusterSize) {\n       numOfReplicas -\u003d (totalNumOfReplicas-clusterSize);\n       totalNumOfReplicas \u003d clusterSize;\n     }\n     // No calculation needed when there is only one rack or picking one node.\n     int numOfRacks \u003d clusterMap.getNumOfRacks();\n-    if (numOfRacks \u003d\u003d 1 || totalNumOfReplicas \u003c\u003d 1) {\n+    // HDFS-14527 return default when numOfRacks \u003d 0 to avoid\n+    // ArithmeticException when calc maxNodesPerRack at following logic.\n+    if (numOfRacks \u003c\u003d 1 || totalNumOfReplicas \u003c\u003d 1) {\n       return new int[] {numOfReplicas, totalNumOfReplicas};\n     }\n \n     int maxNodesPerRack \u003d (totalNumOfReplicas-1)/numOfRacks + 2;\n     // At this point, there are more than one racks and more than one replicas\n     // to store. Avoid all replicas being in the same rack.\n     //\n     // maxNodesPerRack has the following properties at this stage.\n     //   1) maxNodesPerRack \u003e\u003d 2\n     //   2) (maxNodesPerRack-1) * numOfRacks \u003e totalNumOfReplicas\n     //          when numOfRacks \u003e 1\n     //\n     // Thus, the following adjustment will still result in a value that forces\n     // multi-rack allocation and gives enough number of total nodes.\n     if (maxNodesPerRack \u003d\u003d totalNumOfReplicas) {\n       maxNodesPerRack--;\n     }\n     return new int[] {numOfReplicas, maxNodesPerRack};\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected int[] getMaxNodesPerRack(int numOfChosen, int numOfReplicas) {\n    int clusterSize \u003d clusterMap.getNumOfLeaves();\n    int totalNumOfReplicas \u003d numOfChosen + numOfReplicas;\n    if (totalNumOfReplicas \u003e clusterSize) {\n      numOfReplicas -\u003d (totalNumOfReplicas-clusterSize);\n      totalNumOfReplicas \u003d clusterSize;\n    }\n    // No calculation needed when there is only one rack or picking one node.\n    int numOfRacks \u003d clusterMap.getNumOfRacks();\n    // HDFS-14527 return default when numOfRacks \u003d 0 to avoid\n    // ArithmeticException when calc maxNodesPerRack at following logic.\n    if (numOfRacks \u003c\u003d 1 || totalNumOfReplicas \u003c\u003d 1) {\n      return new int[] {numOfReplicas, totalNumOfReplicas};\n    }\n\n    int maxNodesPerRack \u003d (totalNumOfReplicas-1)/numOfRacks + 2;\n    // At this point, there are more than one racks and more than one replicas\n    // to store. Avoid all replicas being in the same rack.\n    //\n    // maxNodesPerRack has the following properties at this stage.\n    //   1) maxNodesPerRack \u003e\u003d 2\n    //   2) (maxNodesPerRack-1) * numOfRacks \u003e totalNumOfReplicas\n    //          when numOfRacks \u003e 1\n    //\n    // Thus, the following adjustment will still result in a value that forces\n    // multi-rack allocation and gives enough number of total nodes.\n    if (maxNodesPerRack \u003d\u003d totalNumOfReplicas) {\n      maxNodesPerRack--;\n    }\n    return new int[] {numOfReplicas, maxNodesPerRack};\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "9595cc003ca5ed3d59b6942056a4fcb9080f79c9": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-7891. A block placement policy with best rack failure tolerance.  Contributed by Walter Su\n",
      "commitDate": "16/04/15 6:25 PM",
      "commitName": "9595cc003ca5ed3d59b6942056a4fcb9080f79c9",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "07/04/15 9:26 PM",
      "commitNameOld": "d505c8acd30d6f40d0632fe9c93c886a4499a9fc",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 8.87,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n-  private int[] getMaxNodesPerRack(int numOfChosen, int numOfReplicas) {\n+  protected int[] getMaxNodesPerRack(int numOfChosen, int numOfReplicas) {\n     int clusterSize \u003d clusterMap.getNumOfLeaves();\n     int totalNumOfReplicas \u003d numOfChosen + numOfReplicas;\n     if (totalNumOfReplicas \u003e clusterSize) {\n       numOfReplicas -\u003d (totalNumOfReplicas-clusterSize);\n       totalNumOfReplicas \u003d clusterSize;\n     }\n     // No calculation needed when there is only one rack or picking one node.\n     int numOfRacks \u003d clusterMap.getNumOfRacks();\n     if (numOfRacks \u003d\u003d 1 || totalNumOfReplicas \u003c\u003d 1) {\n       return new int[] {numOfReplicas, totalNumOfReplicas};\n     }\n \n     int maxNodesPerRack \u003d (totalNumOfReplicas-1)/numOfRacks + 2;\n     // At this point, there are more than one racks and more than one replicas\n     // to store. Avoid all replicas being in the same rack.\n     //\n     // maxNodesPerRack has the following properties at this stage.\n     //   1) maxNodesPerRack \u003e\u003d 2\n     //   2) (maxNodesPerRack-1) * numOfRacks \u003e totalNumOfReplicas\n     //          when numOfRacks \u003e 1\n     //\n     // Thus, the following adjustment will still result in a value that forces\n     // multi-rack allocation and gives enough number of total nodes.\n     if (maxNodesPerRack \u003d\u003d totalNumOfReplicas) {\n       maxNodesPerRack--;\n     }\n     return new int[] {numOfReplicas, maxNodesPerRack};\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected int[] getMaxNodesPerRack(int numOfChosen, int numOfReplicas) {\n    int clusterSize \u003d clusterMap.getNumOfLeaves();\n    int totalNumOfReplicas \u003d numOfChosen + numOfReplicas;\n    if (totalNumOfReplicas \u003e clusterSize) {\n      numOfReplicas -\u003d (totalNumOfReplicas-clusterSize);\n      totalNumOfReplicas \u003d clusterSize;\n    }\n    // No calculation needed when there is only one rack or picking one node.\n    int numOfRacks \u003d clusterMap.getNumOfRacks();\n    if (numOfRacks \u003d\u003d 1 || totalNumOfReplicas \u003c\u003d 1) {\n      return new int[] {numOfReplicas, totalNumOfReplicas};\n    }\n\n    int maxNodesPerRack \u003d (totalNumOfReplicas-1)/numOfRacks + 2;\n    // At this point, there are more than one racks and more than one replicas\n    // to store. Avoid all replicas being in the same rack.\n    //\n    // maxNodesPerRack has the following properties at this stage.\n    //   1) maxNodesPerRack \u003e\u003d 2\n    //   2) (maxNodesPerRack-1) * numOfRacks \u003e totalNumOfReplicas\n    //          when numOfRacks \u003e 1\n    //\n    // Thus, the following adjustment will still result in a value that forces\n    // multi-rack allocation and gives enough number of total nodes.\n    if (maxNodesPerRack \u003d\u003d totalNumOfReplicas) {\n      maxNodesPerRack--;\n    }\n    return new int[] {numOfReplicas, maxNodesPerRack};\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[protected]"
      }
    },
    "3ae84e1ba8928879b3eda90e79667ba5a45d60f8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7300.     HDFS-7300. The getMaxNodesPerRack() method in\nBlockPlacementPolicyDefault is flawed. contributed by Kihwal Lee\n",
      "commitDate": "29/10/14 3:23 PM",
      "commitName": "3ae84e1ba8928879b3eda90e79667ba5a45d60f8",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "15/10/14 8:44 PM",
      "commitNameOld": "41980c56d3c01d7a0ddc7deea2d89b7f28026722",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 13.78,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,10 +1,29 @@\n   private int[] getMaxNodesPerRack(int numOfChosen, int numOfReplicas) {\n     int clusterSize \u003d clusterMap.getNumOfLeaves();\n     int totalNumOfReplicas \u003d numOfChosen + numOfReplicas;\n     if (totalNumOfReplicas \u003e clusterSize) {\n       numOfReplicas -\u003d (totalNumOfReplicas-clusterSize);\n       totalNumOfReplicas \u003d clusterSize;\n     }\n-    int maxNodesPerRack \u003d (totalNumOfReplicas-1)/clusterMap.getNumOfRacks()+2;\n+    // No calculation needed when there is only one rack or picking one node.\n+    int numOfRacks \u003d clusterMap.getNumOfRacks();\n+    if (numOfRacks \u003d\u003d 1 || totalNumOfReplicas \u003c\u003d 1) {\n+      return new int[] {numOfReplicas, totalNumOfReplicas};\n+    }\n+\n+    int maxNodesPerRack \u003d (totalNumOfReplicas-1)/numOfRacks + 2;\n+    // At this point, there are more than one racks and more than one replicas\n+    // to store. Avoid all replicas being in the same rack.\n+    //\n+    // maxNodesPerRack has the following properties at this stage.\n+    //   1) maxNodesPerRack \u003e\u003d 2\n+    //   2) (maxNodesPerRack-1) * numOfRacks \u003e totalNumOfReplicas\n+    //          when numOfRacks \u003e 1\n+    //\n+    // Thus, the following adjustment will still result in a value that forces\n+    // multi-rack allocation and gives enough number of total nodes.\n+    if (maxNodesPerRack \u003d\u003d totalNumOfReplicas) {\n+      maxNodesPerRack--;\n+    }\n     return new int[] {numOfReplicas, maxNodesPerRack};\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int[] getMaxNodesPerRack(int numOfChosen, int numOfReplicas) {\n    int clusterSize \u003d clusterMap.getNumOfLeaves();\n    int totalNumOfReplicas \u003d numOfChosen + numOfReplicas;\n    if (totalNumOfReplicas \u003e clusterSize) {\n      numOfReplicas -\u003d (totalNumOfReplicas-clusterSize);\n      totalNumOfReplicas \u003d clusterSize;\n    }\n    // No calculation needed when there is only one rack or picking one node.\n    int numOfRacks \u003d clusterMap.getNumOfRacks();\n    if (numOfRacks \u003d\u003d 1 || totalNumOfReplicas \u003c\u003d 1) {\n      return new int[] {numOfReplicas, totalNumOfReplicas};\n    }\n\n    int maxNodesPerRack \u003d (totalNumOfReplicas-1)/numOfRacks + 2;\n    // At this point, there are more than one racks and more than one replicas\n    // to store. Avoid all replicas being in the same rack.\n    //\n    // maxNodesPerRack has the following properties at this stage.\n    //   1) maxNodesPerRack \u003e\u003d 2\n    //   2) (maxNodesPerRack-1) * numOfRacks \u003e totalNumOfReplicas\n    //          when numOfRacks \u003e 1\n    //\n    // Thus, the following adjustment will still result in a value that forces\n    // multi-rack allocation and gives enough number of total nodes.\n    if (maxNodesPerRack \u003d\u003d totalNumOfReplicas) {\n      maxNodesPerRack--;\n    }\n    return new int[] {numOfReplicas, maxNodesPerRack};\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    }
  }
}