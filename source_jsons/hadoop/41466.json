{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FairScheduler.java",
  "functionName": "removeNode",
  "functionId": "removeNode___rmNode-RMNode",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
  "functionStartLine": 781,
  "functionEndLine": 821,
  "numCommitsSeen": 228,
  "timeTaken": 9561,
  "changeHistory": [
    "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911",
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
    "e1ccc9622b2f1fbefea1862fa74d1fb56d8eb264",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff",
    "adf260a728df427eb729abe8fb9ad7248991ea54",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
    "7e2837f830382835838c82398db6fc9823d612a7",
    "75885852cc19dd6de12e62498b112d5d70ce87f4",
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
    "0097b15e2150f95745f64179a0ef4644e96128f5",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
    "f218527fff9faa45e9399f716cc41dcad19b9029",
    "51ccb87031eda6a2b75be098a88f1d89ea82c610",
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c"
  ],
  "changeHistoryShort": {
    "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911": "Ybodychange",
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030": "Ybodychange",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ymultichange(Ymodifierchange,Ybodychange)",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": "Ybodychange",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": "Ybodychange",
    "e1ccc9622b2f1fbefea1862fa74d1fb56d8eb264": "Ybodychange",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": "Ybodychange",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": "Ybodychange",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": "Ybodychange",
    "adf260a728df427eb729abe8fb9ad7248991ea54": "Ybodychange",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": "Ybodychange",
    "7e2837f830382835838c82398db6fc9823d612a7": "Ybodychange",
    "75885852cc19dd6de12e62498b112d5d70ce87f4": "Ybodychange",
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": "Ybodychange",
    "0097b15e2150f95745f64179a0ef4644e96128f5": "Ybodychange",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": "Ybodychange",
    "f218527fff9faa45e9399f716cc41dcad19b9029": "Ybodychange",
    "51ccb87031eda6a2b75be098a88f1d89ea82c610": "Ybodychange",
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Ybodychange",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10034. Remove Allocation Tags from released container from Decommission node\n\nContributed by Kyungwan Nam. Reviewed by Adam Antal.\n",
      "commitDate": "19/03/20 12:25 AM",
      "commitName": "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911",
      "commitAuthor": "Prabhu Joseph",
      "commitDateOld": "20/01/20 4:10 AM",
      "commitNameOld": "581072a8f04f7568d3560f105fd1988d3acc9e54",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 58.8,
      "commitsBetweenForRepo": 195,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,41 @@\n   private void removeNode(RMNode rmNode) {\n     writeLock.lock();\n     try {\n       NodeId nodeId \u003d rmNode.getNodeID();\n       FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n       if (node \u003d\u003d null) {\n         LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n         return;\n       }\n \n       // Remove running containers\n       List\u003cRMContainer\u003e runningContainers \u003d\n           node.getCopiedListOfRunningContainers();\n       for (RMContainer container : runningContainers) {\n         super.completedContainer(container, SchedulerUtils\n             .createAbnormalContainerStatus(container.getContainerId(),\n                 SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n+        node.releaseContainer(container.getContainerId(), true);\n       }\n \n       // Remove reservations, if any\n       RMContainer reservedContainer \u003d node.getReservedContainer();\n       if (reservedContainer !\u003d null) {\n         super.completedContainer(reservedContainer, SchedulerUtils\n             .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                 SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n       }\n \n       nodeTracker.removeNode(nodeId);\n       Resource clusterResource \u003d getClusterResource();\n       queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n       queueMgr.getRootQueue().recomputeSteadyShares();\n       updateRootQueueMetrics();\n       triggerUpdate();\n \n       LOG.info(\"Removed node \" + rmNode.getNodeAddress() + \" cluster capacity: \"\n           + clusterResource);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void removeNode(RMNode rmNode) {\n    writeLock.lock();\n    try {\n      NodeId nodeId \u003d rmNode.getNodeID();\n      FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n      if (node \u003d\u003d null) {\n        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n        return;\n      }\n\n      // Remove running containers\n      List\u003cRMContainer\u003e runningContainers \u003d\n          node.getCopiedListOfRunningContainers();\n      for (RMContainer container : runningContainers) {\n        super.completedContainer(container, SchedulerUtils\n            .createAbnormalContainerStatus(container.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n        node.releaseContainer(container.getContainerId(), true);\n      }\n\n      // Remove reservations, if any\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (reservedContainer !\u003d null) {\n        super.completedContainer(reservedContainer, SchedulerUtils\n            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      nodeTracker.removeNode(nodeId);\n      Resource clusterResource \u003d getClusterResource();\n      queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n      queueMgr.getRootQueue().recomputeSteadyShares();\n      updateRootQueueMetrics();\n      triggerUpdate();\n\n      LOG.info(\"Removed node \" + rmNode.getNodeAddress() + \" cluster capacity: \"\n          + clusterResource);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7133. Clean up lock-try order in fair scheduler. (Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "24/07/18 12:46 PM",
      "commitName": "ea2c6c8c9a55813a19b3dbd0d29747d6a7739030",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "11/06/18 11:12 AM",
      "commitNameOld": "c190ac2be88e574b3322cdc73a7c0af0cef708b2",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 43.07,
      "commitsBetweenForRepo": 266,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   private void removeNode(RMNode rmNode) {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       NodeId nodeId \u003d rmNode.getNodeID();\n       FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n       if (node \u003d\u003d null) {\n         LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n         return;\n       }\n \n       // Remove running containers\n       List\u003cRMContainer\u003e runningContainers \u003d\n           node.getCopiedListOfRunningContainers();\n       for (RMContainer container : runningContainers) {\n         super.completedContainer(container, SchedulerUtils\n             .createAbnormalContainerStatus(container.getContainerId(),\n                 SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n       }\n \n       // Remove reservations, if any\n       RMContainer reservedContainer \u003d node.getReservedContainer();\n       if (reservedContainer !\u003d null) {\n         super.completedContainer(reservedContainer, SchedulerUtils\n             .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                 SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n       }\n \n       nodeTracker.removeNode(nodeId);\n       Resource clusterResource \u003d getClusterResource();\n       queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n       queueMgr.getRootQueue().recomputeSteadyShares();\n       updateRootQueueMetrics();\n       triggerUpdate();\n \n       LOG.info(\"Removed node \" + rmNode.getNodeAddress() + \" cluster capacity: \"\n           + clusterResource);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void removeNode(RMNode rmNode) {\n    writeLock.lock();\n    try {\n      NodeId nodeId \u003d rmNode.getNodeID();\n      FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n      if (node \u003d\u003d null) {\n        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n        return;\n      }\n\n      // Remove running containers\n      List\u003cRMContainer\u003e runningContainers \u003d\n          node.getCopiedListOfRunningContainers();\n      for (RMContainer container : runningContainers) {\n        super.completedContainer(container, SchedulerUtils\n            .createAbnormalContainerStatus(container.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      // Remove reservations, if any\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (reservedContainer !\u003d null) {\n        super.completedContainer(reservedContainer, SchedulerUtils\n            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      nodeTracker.removeNode(nodeId);\n      Resource clusterResource \u003d getClusterResource();\n      queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n      queueMgr.getRootQueue().recomputeSteadyShares();\n      updateRootQueueMetrics();\n      triggerUpdate();\n\n      LOG.info(\"Removed node \" + rmNode.getNodeAddress() + \" cluster capacity: \"\n          + clusterResource);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "03/10/16 6:03 AM",
          "commitNameOld": "0da54e8848764c71a31473516d23ada582013f8c",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,40 @@\n-  private synchronized void removeNode(RMNode rmNode) {\n-    NodeId nodeId \u003d rmNode.getNodeID();\n-    FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n-    if (node \u003d\u003d null) {\n-      LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n-      return;\n+  private void removeNode(RMNode rmNode) {\n+    try {\n+      writeLock.lock();\n+      NodeId nodeId \u003d rmNode.getNodeID();\n+      FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n+      if (node \u003d\u003d null) {\n+        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n+        return;\n+      }\n+\n+      // Remove running containers\n+      List\u003cRMContainer\u003e runningContainers \u003d\n+          node.getCopiedListOfRunningContainers();\n+      for (RMContainer container : runningContainers) {\n+        super.completedContainer(container, SchedulerUtils\n+            .createAbnormalContainerStatus(container.getContainerId(),\n+                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n+      }\n+\n+      // Remove reservations, if any\n+      RMContainer reservedContainer \u003d node.getReservedContainer();\n+      if (reservedContainer !\u003d null) {\n+        super.completedContainer(reservedContainer, SchedulerUtils\n+            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n+                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n+      }\n+\n+      nodeTracker.removeNode(nodeId);\n+      Resource clusterResource \u003d getClusterResource();\n+      queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n+      queueMgr.getRootQueue().recomputeSteadyShares();\n+      updateRootQueueMetrics();\n+      triggerUpdate();\n+\n+      LOG.info(\"Removed node \" + rmNode.getNodeAddress() + \" cluster capacity: \"\n+          + clusterResource);\n+    } finally {\n+      writeLock.unlock();\n     }\n-\n-    // Remove running containers\n-    List\u003cRMContainer\u003e runningContainers \u003d\n-        node.getCopiedListOfRunningContainers();\n-    for (RMContainer container : runningContainers) {\n-      super.completedContainer(container,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              container.getContainerId(),\n-              SchedulerUtils.LOST_CONTAINER),\n-          RMContainerEventType.KILL);\n-    }\n-\n-    // Remove reservations, if any\n-    RMContainer reservedContainer \u003d node.getReservedContainer();\n-    if (reservedContainer !\u003d null) {\n-      super.completedContainer(reservedContainer,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              reservedContainer.getContainerId(),\n-              SchedulerUtils.LOST_CONTAINER),\n-          RMContainerEventType.KILL);\n-    }\n-\n-    nodeTracker.removeNode(nodeId);\n-    Resource clusterResource \u003d getClusterResource();\n-    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n-    queueMgr.getRootQueue().recomputeSteadyShares();\n-    updateRootQueueMetrics();\n-    triggerUpdate();\n-\n-    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n-        \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void removeNode(RMNode rmNode) {\n    try {\n      writeLock.lock();\n      NodeId nodeId \u003d rmNode.getNodeID();\n      FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n      if (node \u003d\u003d null) {\n        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n        return;\n      }\n\n      // Remove running containers\n      List\u003cRMContainer\u003e runningContainers \u003d\n          node.getCopiedListOfRunningContainers();\n      for (RMContainer container : runningContainers) {\n        super.completedContainer(container, SchedulerUtils\n            .createAbnormalContainerStatus(container.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      // Remove reservations, if any\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (reservedContainer !\u003d null) {\n        super.completedContainer(reservedContainer, SchedulerUtils\n            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      nodeTracker.removeNode(nodeId);\n      Resource clusterResource \u003d getClusterResource();\n      queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n      queueMgr.getRootQueue().recomputeSteadyShares();\n      updateRootQueueMetrics();\n      triggerUpdate();\n\n      LOG.info(\"Removed node \" + rmNode.getNodeAddress() + \" cluster capacity: \"\n          + clusterResource);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[private, synchronized]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "03/10/16 6:03 AM",
          "commitNameOld": "0da54e8848764c71a31473516d23ada582013f8c",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,40 @@\n-  private synchronized void removeNode(RMNode rmNode) {\n-    NodeId nodeId \u003d rmNode.getNodeID();\n-    FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n-    if (node \u003d\u003d null) {\n-      LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n-      return;\n+  private void removeNode(RMNode rmNode) {\n+    try {\n+      writeLock.lock();\n+      NodeId nodeId \u003d rmNode.getNodeID();\n+      FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n+      if (node \u003d\u003d null) {\n+        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n+        return;\n+      }\n+\n+      // Remove running containers\n+      List\u003cRMContainer\u003e runningContainers \u003d\n+          node.getCopiedListOfRunningContainers();\n+      for (RMContainer container : runningContainers) {\n+        super.completedContainer(container, SchedulerUtils\n+            .createAbnormalContainerStatus(container.getContainerId(),\n+                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n+      }\n+\n+      // Remove reservations, if any\n+      RMContainer reservedContainer \u003d node.getReservedContainer();\n+      if (reservedContainer !\u003d null) {\n+        super.completedContainer(reservedContainer, SchedulerUtils\n+            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n+                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n+      }\n+\n+      nodeTracker.removeNode(nodeId);\n+      Resource clusterResource \u003d getClusterResource();\n+      queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n+      queueMgr.getRootQueue().recomputeSteadyShares();\n+      updateRootQueueMetrics();\n+      triggerUpdate();\n+\n+      LOG.info(\"Removed node \" + rmNode.getNodeAddress() + \" cluster capacity: \"\n+          + clusterResource);\n+    } finally {\n+      writeLock.unlock();\n     }\n-\n-    // Remove running containers\n-    List\u003cRMContainer\u003e runningContainers \u003d\n-        node.getCopiedListOfRunningContainers();\n-    for (RMContainer container : runningContainers) {\n-      super.completedContainer(container,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              container.getContainerId(),\n-              SchedulerUtils.LOST_CONTAINER),\n-          RMContainerEventType.KILL);\n-    }\n-\n-    // Remove reservations, if any\n-    RMContainer reservedContainer \u003d node.getReservedContainer();\n-    if (reservedContainer !\u003d null) {\n-      super.completedContainer(reservedContainer,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              reservedContainer.getContainerId(),\n-              SchedulerUtils.LOST_CONTAINER),\n-          RMContainerEventType.KILL);\n-    }\n-\n-    nodeTracker.removeNode(nodeId);\n-    Resource clusterResource \u003d getClusterResource();\n-    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n-    queueMgr.getRootQueue().recomputeSteadyShares();\n-    updateRootQueueMetrics();\n-    triggerUpdate();\n-\n-    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n-        \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void removeNode(RMNode rmNode) {\n    try {\n      writeLock.lock();\n      NodeId nodeId \u003d rmNode.getNodeID();\n      FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n      if (node \u003d\u003d null) {\n        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n        return;\n      }\n\n      // Remove running containers\n      List\u003cRMContainer\u003e runningContainers \u003d\n          node.getCopiedListOfRunningContainers();\n      for (RMContainer container : runningContainers) {\n        super.completedContainer(container, SchedulerUtils\n            .createAbnormalContainerStatus(container.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      // Remove reservations, if any\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (reservedContainer !\u003d null) {\n        super.completedContainer(reservedContainer, SchedulerUtils\n            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      nodeTracker.removeNode(nodeId);\n      Resource clusterResource \u003d getClusterResource();\n      queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n      queueMgr.getRootQueue().recomputeSteadyShares();\n      updateRootQueueMetrics();\n      triggerUpdate();\n\n      LOG.info(\"Removed node \" + rmNode.getNodeAddress() + \" cluster capacity: \"\n          + clusterResource);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
      "commitDate": "05/05/16 12:56 PM",
      "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthor": "Jian He",
      "commitDateOld": "26/04/16 5:10 AM",
      "commitNameOld": "4b1dcbbe0c1d0036f65283be4b25d9b2211abed3",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 9.32,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,39 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     NodeId nodeId \u003d rmNode.getNodeID();\n     FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n     if (node \u003d\u003d null) {\n       LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n       return;\n     }\n \n     // Remove running containers\n-    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n+    List\u003cRMContainer\u003e runningContainers \u003d\n+        node.getCopiedListOfRunningContainers();\n     for (RMContainer container : runningContainers) {\n       super.completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       super.completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodeTracker.removeNode(nodeId);\n     Resource clusterResource \u003d getClusterResource();\n     queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n     queueMgr.getRootQueue().recomputeSteadyShares();\n     updateRootQueueMetrics();\n     triggerUpdate();\n \n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    NodeId nodeId \u003d rmNode.getNodeID();\n    FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n    if (node \u003d\u003d null) {\n      LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n      return;\n    }\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d\n        node.getCopiedListOfRunningContainers();\n    for (RMContainer container : runningContainers) {\n      super.completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      super.completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodeTracker.removeNode(nodeId);\n    Resource clusterResource \u003d getClusterResource();\n    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n    queueMgr.getRootQueue().recomputeSteadyShares();\n    updateRootQueueMetrics();\n    triggerUpdate();\n\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4719. Add a helper library to maintain node state and allows common queries. (kasha)\n",
      "commitDate": "14/03/16 2:19 PM",
      "commitName": "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "06/03/16 7:46 PM",
      "commitNameOld": "e1ccc9622b2f1fbefea1862fa74d1fb56d8eb264",
      "commitAuthorOld": "Zhihai Xu",
      "daysBetweenCommits": 7.73,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,38 @@\n   private synchronized void removeNode(RMNode rmNode) {\n-    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n-    // This can occur when an UNHEALTHY node reconnects\n+    NodeId nodeId \u003d rmNode.getNodeID();\n+    FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n     if (node \u003d\u003d null) {\n+      LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n       return;\n     }\n-    Resources.subtractFrom(clusterResource, node.getTotalResource());\n-    updateRootQueueMetrics();\n-\n-    triggerUpdate();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       super.completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       super.completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n-    nodes.remove(rmNode.getNodeID());\n-    String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n-    if (nodesPerRack.containsKey(rackName)\n-            \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n-      nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n-    } else {\n-      LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n-              \" unknown rack [\" + rackName + \"] !!\");\n-    }\n+    nodeTracker.removeNode(nodeId);\n+    Resource clusterResource \u003d getClusterResource();\n     queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n     queueMgr.getRootQueue().recomputeSteadyShares();\n-    updateMaximumAllocation(node, false);\n+    updateRootQueueMetrics();\n+    triggerUpdate();\n+\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    NodeId nodeId \u003d rmNode.getNodeID();\n    FSSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n    if (node \u003d\u003d null) {\n      LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n      return;\n    }\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      super.completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      super.completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodeTracker.removeNode(nodeId);\n    Resource clusterResource \u003d getClusterResource();\n    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n    queueMgr.getRootQueue().recomputeSteadyShares();\n    updateRootQueueMetrics();\n    triggerUpdate();\n\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "e1ccc9622b2f1fbefea1862fa74d1fb56d8eb264": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4761. NMs reconnecting with changed capabilities can lead to wrong cluster resource calculations on fair scheduler. Contributed by Sangjin Lee\n",
      "commitDate": "06/03/16 7:46 PM",
      "commitName": "e1ccc9622b2f1fbefea1862fa74d1fb56d8eb264",
      "commitAuthor": "Zhihai Xu",
      "commitDateOld": "28/02/16 9:35 AM",
      "commitNameOld": "f9692770a58af0ab082eb7f15da9cbdcd177605b",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 7.42,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n     // This can occur when an UNHEALTHY node reconnects\n     if (node \u003d\u003d null) {\n       return;\n     }\n-    Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n+    Resources.subtractFrom(clusterResource, node.getTotalResource());\n     updateRootQueueMetrics();\n \n     triggerUpdate();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       super.completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       super.completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n     String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n     if (nodesPerRack.containsKey(rackName)\n             \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n       nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n     } else {\n       LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n               \" unknown rack [\" + rackName + \"] !!\");\n     }\n     queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n     queueMgr.getRootQueue().recomputeSteadyShares();\n     updateMaximumAllocation(node, false);\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n    // This can occur when an UNHEALTHY node reconnects\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getTotalResource());\n    updateRootQueueMetrics();\n\n    triggerUpdate();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      super.completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      super.completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n    if (nodesPerRack.containsKey(rackName)\n            \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n      nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n    } else {\n      LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n              \" unknown rack [\" + rackName + \"] !!\");\n    }\n    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n    queueMgr.getRootQueue().recomputeSteadyShares();\n    updateMaximumAllocation(node, false);\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "18/01/16 5:30 PM",
      "commitName": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 5:27 PM",
      "commitNameOld": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n     // This can occur when an UNHEALTHY node reconnects\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n     updateRootQueueMetrics();\n \n     triggerUpdate();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n-      completedContainer(container,\n+      super.completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      completedContainer(reservedContainer,\n+      super.completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n     String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n     if (nodesPerRack.containsKey(rackName)\n             \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n       nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n     } else {\n       LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n               \" unknown rack [\" + rackName + \"] !!\");\n     }\n     queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n     queueMgr.getRootQueue().recomputeSteadyShares();\n     updateMaximumAllocation(node, false);\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n    // This can occur when an UNHEALTHY node reconnects\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n    updateRootQueueMetrics();\n\n    triggerUpdate();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      super.completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      super.completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n    if (nodesPerRack.containsKey(rackName)\n            \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n      nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n    } else {\n      LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n              \" unknown rack [\" + rackName + \"] !!\");\n    }\n    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n    queueMgr.getRootQueue().recomputeSteadyShares();\n    updateMaximumAllocation(node, false);\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 3fe57285635e8058c34aa40a103845b49ca7d6ff.\n\nConflicts:\n\thadoop-yarn-project/CHANGES.txt\n",
      "commitDate": "18/01/16 5:27 PM",
      "commitName": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 1:58 AM",
      "commitNameOld": "d40859fab1ad977636457a6cc96b6a4f9b903afc",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 0.65,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n     // This can occur when an UNHEALTHY node reconnects\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n     updateRootQueueMetrics();\n \n     triggerUpdate();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n-      super.completedContainer(container,\n+      completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      super.completedContainer(reservedContainer,\n+      completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n     String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n     if (nodesPerRack.containsKey(rackName)\n             \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n       nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n     } else {\n       LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n               \" unknown rack [\" + rackName + \"] !!\");\n     }\n     queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n     queueMgr.getRootQueue().recomputeSteadyShares();\n     updateMaximumAllocation(node, false);\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n    // This can occur when an UNHEALTHY node reconnects\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n    updateRootQueueMetrics();\n\n    triggerUpdate();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n    if (nodesPerRack.containsKey(rackName)\n            \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n      nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n    } else {\n      LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n              \" unknown rack [\" + rackName + \"] !!\");\n    }\n    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n    queueMgr.getRootQueue().recomputeSteadyShares();\n    updateMaximumAllocation(node, false);\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n\n(cherry picked from commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579)\n",
      "commitDate": "18/01/16 1:06 AM",
      "commitName": "3fe57285635e8058c34aa40a103845b49ca7d6ff",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 12:50 AM",
      "commitNameOld": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n     // This can occur when an UNHEALTHY node reconnects\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n     updateRootQueueMetrics();\n \n     triggerUpdate();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n-      completedContainer(container,\n+      super.completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      completedContainer(reservedContainer,\n+      super.completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n     String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n     if (nodesPerRack.containsKey(rackName)\n             \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n       nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n     } else {\n       LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n               \" unknown rack [\" + rackName + \"] !!\");\n     }\n     queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n     queueMgr.getRootQueue().recomputeSteadyShares();\n     updateMaximumAllocation(node, false);\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n    // This can occur when an UNHEALTHY node reconnects\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n    updateRootQueueMetrics();\n\n    triggerUpdate();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      super.completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      super.completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n    if (nodesPerRack.containsKey(rackName)\n            \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n      nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n    } else {\n      LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n              \" unknown rack [\" + rackName + \"] !!\");\n    }\n    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n    queueMgr.getRootQueue().recomputeSteadyShares();\n    updateMaximumAllocation(node, false);\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "adf260a728df427eb729abe8fb9ad7248991ea54": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579.\n",
      "commitDate": "18/01/16 12:50 AM",
      "commitName": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/01/16 7:04 PM",
      "commitNameOld": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n     // This can occur when an UNHEALTHY node reconnects\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n     updateRootQueueMetrics();\n \n     triggerUpdate();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n-      super.completedContainer(container,\n+      completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      super.completedContainer(reservedContainer,\n+      completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n     String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n     if (nodesPerRack.containsKey(rackName)\n             \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n       nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n     } else {\n       LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n               \" unknown rack [\" + rackName + \"] !!\");\n     }\n     queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n     queueMgr.getRootQueue().recomputeSteadyShares();\n     updateMaximumAllocation(node, false);\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n    // This can occur when an UNHEALTHY node reconnects\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n    updateRootQueueMetrics();\n\n    triggerUpdate();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n    if (nodesPerRack.containsKey(rackName)\n            \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n      nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n    } else {\n      LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n              \" unknown rack [\" + rackName + \"] !!\");\n    }\n    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n    queueMgr.getRootQueue().recomputeSteadyShares();\n    updateMaximumAllocation(node, false);\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "17/01/16 7:04 PM",
      "commitName": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/12/15 10:52 AM",
      "commitNameOld": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 34.34,
      "commitsBetweenForRepo": 200,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n     // This can occur when an UNHEALTHY node reconnects\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n     updateRootQueueMetrics();\n \n     triggerUpdate();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n-      completedContainer(container,\n+      super.completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      completedContainer(reservedContainer,\n+      super.completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n     String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n     if (nodesPerRack.containsKey(rackName)\n             \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n       nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n     } else {\n       LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n               \" unknown rack [\" + rackName + \"] !!\");\n     }\n     queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n     queueMgr.getRootQueue().recomputeSteadyShares();\n     updateMaximumAllocation(node, false);\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n    // This can occur when an UNHEALTHY node reconnects\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n    updateRootQueueMetrics();\n\n    triggerUpdate();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      super.completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      super.completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n    if (nodesPerRack.containsKey(rackName)\n            \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n      nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n    } else {\n      LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n              \" unknown rack [\" + rackName + \"] !!\");\n    }\n    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n    queueMgr.getRootQueue().recomputeSteadyShares();\n    updateMaximumAllocation(node, false);\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "7e2837f830382835838c82398db6fc9823d612a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4270. Limit application resource reservation on nodes for non-node/rack specific requests (asuresh)\n",
      "commitDate": "19/10/15 8:00 PM",
      "commitName": "7e2837f830382835838c82398db6fc9823d612a7",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "15/10/15 5:12 PM",
      "commitNameOld": "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 4.12,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,46 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n     // This can occur when an UNHEALTHY node reconnects\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n     updateRootQueueMetrics();\n \n     triggerUpdate();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n+    String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n+    if (nodesPerRack.containsKey(rackName)\n+            \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n+      nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n+    } else {\n+      LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n+              \" unknown rack [\" + rackName + \"] !!\");\n+    }\n     queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n     queueMgr.getRootQueue().recomputeSteadyShares();\n     updateMaximumAllocation(node, false);\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n    // This can occur when an UNHEALTHY node reconnects\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n    updateRootQueueMetrics();\n\n    triggerUpdate();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    String rackName \u003d node.getRackName() \u003d\u003d null ? \"NULL\" : node.getRackName();\n    if (nodesPerRack.containsKey(rackName)\n            \u0026\u0026 (nodesPerRack.get(rackName) \u003e 0)) {\n      nodesPerRack.put(rackName, nodesPerRack.get(rackName) - 1);\n    } else {\n      LOG.error(\"Node [\" + rmNode.getNodeAddress() + \"] being removed from\" +\n              \" unknown rack [\" + rackName + \"] !!\");\n    }\n    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n    queueMgr.getRootQueue().recomputeSteadyShares();\n    updateMaximumAllocation(node, false);\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "75885852cc19dd6de12e62498b112d5d70ce87f4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3259. FairScheduler: Trigger fairShare updates on node events. (Anubhav Dhoot via kasha)\n",
      "commitDate": "05/06/15 9:39 AM",
      "commitName": "75885852cc19dd6de12e62498b112d5d70ce87f4",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "21/05/15 1:44 PM",
      "commitNameOld": "4513761869c732cf2f462763043067ebf8749df7",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 14.83,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,38 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n     // This can occur when an UNHEALTHY node reconnects\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n     updateRootQueueMetrics();\n \n+    triggerUpdate();\n+\n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n     queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n     queueMgr.getRootQueue().recomputeSteadyShares();\n     updateMaximumAllocation(node, false);\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n    // This can occur when an UNHEALTHY node reconnects\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n    updateRootQueueMetrics();\n\n    triggerUpdate();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n    queueMgr.getRootQueue().recomputeSteadyShares();\n    updateMaximumAllocation(node, false);\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2604. Scheduler should consider max-allocation-* in conjunction with the largest node. (Robert Kanter via kasha)\n",
      "commitDate": "21/11/14 10:32 AM",
      "commitName": "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "14/11/14 3:18 PM",
      "commitNameOld": "1a47f890ba3cb22b6262f47c1f1af2990559bb89",
      "commitAuthorOld": "Sandy Ryza",
      "daysBetweenCommits": 6.8,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,36 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n     // This can occur when an UNHEALTHY node reconnects\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n     updateRootQueueMetrics();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n     queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n     queueMgr.getRootQueue().recomputeSteadyShares();\n+    updateMaximumAllocation(node, false);\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n    // This can occur when an UNHEALTHY node reconnects\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n    updateRootQueueMetrics();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n    queueMgr.getRootQueue().recomputeSteadyShares();\n    updateMaximumAllocation(node, false);\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "0097b15e2150f95745f64179a0ef4644e96128f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2393. FairScheduler: Add the notion of steady fair share. (Wei Yan via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1619845 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/08/14 8:44 AM",
      "commitName": "0097b15e2150f95745f64179a0ef4644e96128f5",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "19/08/14 1:33 PM",
      "commitNameOld": "f6a778c3725bcdaba1e1de43786af17dd44deb78",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 2.8,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,35 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n     // This can occur when an UNHEALTHY node reconnects\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n     updateRootQueueMetrics();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n+    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n+    queueMgr.getRootQueue().recomputeSteadyShares();\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n    // This can occur when an UNHEALTHY node reconnects\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n    updateRootQueueMetrics();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    queueMgr.getRootQueue().setSteadyFairShare(clusterResource);\n    queueMgr.getRootQueue().recomputeSteadyShares();\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2017. Merged some of the common scheduler code. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 10:32 PM",
      "commitName": "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/03/14 4:40 PM",
      "commitNameOld": "7bd62b8da03642612fae8349e967b9c0aa290843",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 51.24,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   private synchronized void removeNode(RMNode rmNode) {\n-    FSSchedulerNode node \u003d nodes.get(rmNode.getNodeID());\n+    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n     // This can occur when an UNHEALTHY node reconnects\n     if (node \u003d\u003d null) {\n       return;\n     }\n-    Resources.subtractFrom(clusterCapacity, rmNode.getTotalCapability());\n+    Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n     updateRootQueueMetrics();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n-        \" cluster capacity: \" + clusterCapacity);\n+        \" cluster capacity: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d getFSSchedulerNode(rmNode.getNodeID());\n    // This can occur when an UNHEALTHY node reconnects\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, rmNode.getTotalCapability());\n    updateRootQueueMetrics();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "f218527fff9faa45e9399f716cc41dcad19b9029": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1265. Fair Scheduler chokes on unhealthy node reconnect (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1531146 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/10/13 3:49 PM",
      "commitName": "f218527fff9faa45e9399f716cc41dcad19b9029",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "03/10/13 4:29 PM",
      "commitNameOld": "ac2cdb5f6586cc3358ea4fc818f477959d2daa38",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 6.97,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,33 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     FSSchedulerNode node \u003d nodes.get(rmNode.getNodeID());\n+    // This can occur when an UNHEALTHY node reconnects\n+    if (node \u003d\u003d null) {\n+      return;\n+    }\n     Resources.subtractFrom(clusterCapacity, rmNode.getTotalCapability());\n     updateRootQueueMetrics();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterCapacity);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d nodes.get(rmNode.getNodeID());\n    // This can occur when an UNHEALTHY node reconnects\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterCapacity, rmNode.getTotalCapability());\n    updateRootQueueMetrics();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterCapacity);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "51ccb87031eda6a2b75be098a88f1d89ea82c610": {
      "type": "Ybodychange",
      "commitMessage": "YARN-655. Fair scheduler metrics should subtract allocated memory from available memory. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480809 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/05/13 3:15 PM",
      "commitName": "51ccb87031eda6a2b75be098a88f1d89ea82c610",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "09/05/13 2:52 PM",
      "commitNameOld": "e0562e3d07f29afbf283857293db0699dcb232c9",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,29 @@\n   private synchronized void removeNode(RMNode rmNode) {\n     FSSchedulerNode node \u003d nodes.get(rmNode.getNodeID());\n     Resources.subtractFrom(clusterCapacity, rmNode.getTotalCapability());\n+    updateRootQueueMetrics();\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     nodes.remove(rmNode.getNodeID());\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterCapacity);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d nodes.get(rmNode.getNodeID());\n    Resources.subtractFrom(clusterCapacity, rmNode.getTotalCapability());\n    updateRootQueueMetrics();\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterCapacity);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-183. Clean up fair scheduler code. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1407433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/11/12 4:38 AM",
      "commitName": "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
      "commitAuthor": "Thomas White",
      "commitDateOld": "26/10/12 1:55 PM",
      "commitNameOld": "b54e794fb059fa68b115c2ca5e58f11a0d7f3985",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 13.65,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n   private synchronized void removeNode(RMNode rmNode) {\n-    FSSchedulerNode node \u003d this.nodes.get(rmNode.getNodeID());\n+    FSSchedulerNode node \u003d nodes.get(rmNode.getNodeID());\n     Resources.subtractFrom(clusterCapacity, rmNode.getTotalCapability());\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n-    this.nodes.remove(rmNode.getNodeID());\n+    nodes.remove(rmNode.getNodeID());\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterCapacity);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d nodes.get(rmNode.getNodeID());\n    Resources.subtractFrom(clusterCapacity, rmNode.getTotalCapability());\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    nodes.remove(rmNode.getNodeID());\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterCapacity);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d this.nodes.get(rmNode.getNodeID());\n    Resources.subtractFrom(clusterCapacity, rmNode.getTotalCapability());\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(rmNode.getNodeID());\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterCapacity);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "12/07/12 5:43 PM",
      "commitNameOld": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 4.04,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n   private synchronized void removeNode(RMNode rmNode) {\n-    SchedulerNode node \u003d this.nodes.get(rmNode.getNodeID());\n+    FSSchedulerNode node \u003d this.nodes.get(rmNode.getNodeID());\n     Resources.subtractFrom(clusterCapacity, rmNode.getTotalCapability());\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(),\n               SchedulerUtils.LOST_CONTAINER),\n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(rmNode.getNodeID());\n     LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n         \" cluster capacity: \" + clusterCapacity);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    FSSchedulerNode node \u003d this.nodes.get(rmNode.getNodeID());\n    Resources.subtractFrom(clusterCapacity, rmNode.getTotalCapability());\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(rmNode.getNodeID());\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterCapacity);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3451. Port Fair Scheduler to MR2 (pwendell via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361020 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 5:43 PM",
      "commitName": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,28 @@\n+  private synchronized void removeNode(RMNode rmNode) {\n+    SchedulerNode node \u003d this.nodes.get(rmNode.getNodeID());\n+    Resources.subtractFrom(clusterCapacity, rmNode.getTotalCapability());\n+\n+    // Remove running containers\n+    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n+    for (RMContainer container : runningContainers) {\n+      completedContainer(container,\n+          SchedulerUtils.createAbnormalContainerStatus(\n+              container.getContainerId(),\n+              SchedulerUtils.LOST_CONTAINER),\n+          RMContainerEventType.KILL);\n+    }\n+\n+    // Remove reservations, if any\n+    RMContainer reservedContainer \u003d node.getReservedContainer();\n+    if (reservedContainer !\u003d null) {\n+      completedContainer(reservedContainer,\n+          SchedulerUtils.createAbnormalContainerStatus(\n+              reservedContainer.getContainerId(),\n+              SchedulerUtils.LOST_CONTAINER),\n+          RMContainerEventType.KILL);\n+    }\n+\n+    this.nodes.remove(rmNode.getNodeID());\n+    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n+        \" cluster capacity: \" + clusterCapacity);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode rmNode) {\n    SchedulerNode node \u003d this.nodes.get(rmNode.getNodeID());\n    Resources.subtractFrom(clusterCapacity, rmNode.getTotalCapability());\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(),\n              SchedulerUtils.LOST_CONTAINER),\n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(rmNode.getNodeID());\n    LOG.info(\"Removed node \" + rmNode.getNodeAddress() +\n        \" cluster capacity: \" + clusterCapacity);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
    }
  }
}