{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PacketReceiver.java",
  "functionName": "doRead",
  "functionId": "doRead___ch-ReadableByteChannel__in-InputStream",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/PacketReceiver.java",
  "functionStartLine": 112,
  "functionEndLine": 190,
  "numCommitsSeen": 11,
  "timeTaken": 2271,
  "changeHistory": [
    "39285e6a1978ea5e53bdc1b0aef62421382124a8",
    "6ee0539ede78b640f01c5eac18ded161182a7835",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
    "826ae1c26d31f87d88efc920b271bec7eec2e17a",
    "f761bd8fe472c311bdff7c9d469f2805b867855a",
    "ded304e6a6e74742f6f4a35989f762dcefa234cb",
    "9ea7c06468d236452f03c38a31d1a45f7f09dc50"
  ],
  "changeHistoryShort": {
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": "Ybodychange",
    "6ee0539ede78b640f01c5eac18ded161182a7835": "Ybodychange",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": "Ybodychange",
    "826ae1c26d31f87d88efc920b271bec7eec2e17a": "Yfilerename",
    "f761bd8fe472c311bdff7c9d469f2805b867855a": "Ybodychange",
    "ded304e6a6e74742f6f4a35989f762dcefa234cb": "Ybodychange",
    "9ea7c06468d236452f03c38a31d1a45f7f09dc50": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8971. Remove guards when calling LOG.debug() and LOG.trace() in client package. Contributed by Mingliang Liu.\n",
      "commitDate": "29/09/15 5:52 PM",
      "commitName": "39285e6a1978ea5e53bdc1b0aef62421382124a8",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:51 PM",
      "commitNameOld": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,79 @@\n   private void doRead(ReadableByteChannel ch, InputStream in)\n       throws IOException {\n     // Each packet looks like:\n     //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n     //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n     //\n     // PLEN:      Payload length\n     //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n     //            This length includes its own encoded length in\n     //            the sum for historical reasons.\n     //\n     // HLEN:      Header length\n     //            \u003d length(HEADER)\n     //\n     // HEADER:    the actual packet header fields, encoded in protobuf\n     // CHECKSUMS: the crcs for the data chunk. May be missing if\n     //            checksums were not requested\n     // DATA       the actual block data\n     Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n \n     curPacketBuf.clear();\n     curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN);\n     doReadFully(ch, in, curPacketBuf);\n     curPacketBuf.flip();\n     int payloadLen \u003d curPacketBuf.getInt();\n     \n     if (payloadLen \u003c Ints.BYTES) {\n       // The \"payload length\" includes its own length. Therefore it\n       // should never be less than 4 bytes\n       throw new IOException(\"Invalid payload length \" +\n           payloadLen);\n     }\n     int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n     int headerLen \u003d curPacketBuf.getShort();\n     if (headerLen \u003c 0) {\n       throw new IOException(\"Invalid header length \" + headerLen);\n     }\n     \n-    if (LOG.isTraceEnabled()) {\n-      LOG.trace(\"readNextPacket: dataPlusChecksumLen \u003d \" + dataPlusChecksumLen +\n-          \" headerLen \u003d \" + headerLen);\n-    }\n-    \n+    LOG.trace(\"readNextPacket: dataPlusChecksumLen\u003d{}, headerLen\u003d{}\",\n+        dataPlusChecksumLen, headerLen);\n+\n     // Sanity check the buffer size so we don\u0027t allocate too much memory\n     // and OOME.\n     int totalLen \u003d payloadLen + headerLen;\n     if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n       throw new IOException(\"Incorrect value for packet payload size: \" +\n                             payloadLen);\n     }\n \n     // Make sure we have space for the whole packet, and\n     // read it.\n     reallocPacketBuf(PacketHeader.PKT_LENGTHS_LEN +\n         dataPlusChecksumLen + headerLen);\n     curPacketBuf.clear();\n     curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n     curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN +\n         dataPlusChecksumLen + headerLen);\n     doReadFully(ch, in, curPacketBuf);\n     curPacketBuf.flip();\n     curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n \n     // Extract the header from the front of the buffer (after the length prefixes)\n     byte[] headerBuf \u003d new byte[headerLen];\n     curPacketBuf.get(headerBuf);\n     if (curHeader \u003d\u003d null) {\n       curHeader \u003d new PacketHeader();\n     }\n     curHeader.setFieldsFromData(payloadLen, headerBuf);\n     \n     // Compute the sub-slices of the packet\n     int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n     if (checksumLen \u003c 0) {\n       throw new IOException(\"Invalid packet: data length in packet header \" + \n           \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n           dataPlusChecksumLen + \" header: \" + curHeader); \n     }\n     \n     reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRead(ReadableByteChannel ch, InputStream in)\n      throws IOException {\n    // Each packet looks like:\n    //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n    //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n    //\n    // PLEN:      Payload length\n    //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n    //            This length includes its own encoded length in\n    //            the sum for historical reasons.\n    //\n    // HLEN:      Header length\n    //            \u003d length(HEADER)\n    //\n    // HEADER:    the actual packet header fields, encoded in protobuf\n    // CHECKSUMS: the crcs for the data chunk. May be missing if\n    //            checksums were not requested\n    // DATA       the actual block data\n    Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n\n    curPacketBuf.clear();\n    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n    int payloadLen \u003d curPacketBuf.getInt();\n    \n    if (payloadLen \u003c Ints.BYTES) {\n      // The \"payload length\" includes its own length. Therefore it\n      // should never be less than 4 bytes\n      throw new IOException(\"Invalid payload length \" +\n          payloadLen);\n    }\n    int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n    int headerLen \u003d curPacketBuf.getShort();\n    if (headerLen \u003c 0) {\n      throw new IOException(\"Invalid header length \" + headerLen);\n    }\n    \n    LOG.trace(\"readNextPacket: dataPlusChecksumLen\u003d{}, headerLen\u003d{}\",\n        dataPlusChecksumLen, headerLen);\n\n    // Sanity check the buffer size so we don\u0027t allocate too much memory\n    // and OOME.\n    int totalLen \u003d payloadLen + headerLen;\n    if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n      throw new IOException(\"Incorrect value for packet payload size: \" +\n                            payloadLen);\n    }\n\n    // Make sure we have space for the whole packet, and\n    // read it.\n    reallocPacketBuf(PacketHeader.PKT_LENGTHS_LEN +\n        dataPlusChecksumLen + headerLen);\n    curPacketBuf.clear();\n    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN +\n        dataPlusChecksumLen + headerLen);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n\n    // Extract the header from the front of the buffer (after the length prefixes)\n    byte[] headerBuf \u003d new byte[headerLen];\n    curPacketBuf.get(headerBuf);\n    if (curHeader \u003d\u003d null) {\n      curHeader \u003d new PacketHeader();\n    }\n    curHeader.setFieldsFromData(payloadLen, headerBuf);\n    \n    // Compute the sub-slices of the packet\n    int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n    if (checksumLen \u003c 0) {\n      throw new IOException(\"Invalid packet: data length in packet header \" + \n          \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n          dataPlusChecksumLen + \" header: \" + curHeader); \n    }\n    \n    reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/PacketReceiver.java",
      "extendedDetails": {}
    },
    "6ee0539ede78b640f01c5eac18ded161182a7835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\"\n\nThis reverts commit d5a9a3daa0224249221ffa7b8bd5751ab2feca56.\n",
      "commitDate": "29/09/15 5:51 PM",
      "commitName": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:48 PM",
      "commitNameOld": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,81 @@\n   private void doRead(ReadableByteChannel ch, InputStream in)\n       throws IOException {\n     // Each packet looks like:\n     //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n     //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n     //\n     // PLEN:      Payload length\n     //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n     //            This length includes its own encoded length in\n     //            the sum for historical reasons.\n     //\n     // HLEN:      Header length\n     //            \u003d length(HEADER)\n     //\n     // HEADER:    the actual packet header fields, encoded in protobuf\n     // CHECKSUMS: the crcs for the data chunk. May be missing if\n     //            checksums were not requested\n     // DATA       the actual block data\n     Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n \n     curPacketBuf.clear();\n     curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN);\n     doReadFully(ch, in, curPacketBuf);\n     curPacketBuf.flip();\n     int payloadLen \u003d curPacketBuf.getInt();\n     \n     if (payloadLen \u003c Ints.BYTES) {\n       // The \"payload length\" includes its own length. Therefore it\n       // should never be less than 4 bytes\n       throw new IOException(\"Invalid payload length \" +\n           payloadLen);\n     }\n     int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n     int headerLen \u003d curPacketBuf.getShort();\n     if (headerLen \u003c 0) {\n       throw new IOException(\"Invalid header length \" + headerLen);\n     }\n     \n-    LOG.trace(\"readNextPacket: dataPlusChecksumLen\u003d{}, headerLen\u003d{}\",\n-        dataPlusChecksumLen, headerLen);\n-\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(\"readNextPacket: dataPlusChecksumLen \u003d \" + dataPlusChecksumLen +\n+          \" headerLen \u003d \" + headerLen);\n+    }\n+    \n     // Sanity check the buffer size so we don\u0027t allocate too much memory\n     // and OOME.\n     int totalLen \u003d payloadLen + headerLen;\n     if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n       throw new IOException(\"Incorrect value for packet payload size: \" +\n                             payloadLen);\n     }\n \n     // Make sure we have space for the whole packet, and\n     // read it.\n     reallocPacketBuf(PacketHeader.PKT_LENGTHS_LEN +\n         dataPlusChecksumLen + headerLen);\n     curPacketBuf.clear();\n     curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n     curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN +\n         dataPlusChecksumLen + headerLen);\n     doReadFully(ch, in, curPacketBuf);\n     curPacketBuf.flip();\n     curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n \n     // Extract the header from the front of the buffer (after the length prefixes)\n     byte[] headerBuf \u003d new byte[headerLen];\n     curPacketBuf.get(headerBuf);\n     if (curHeader \u003d\u003d null) {\n       curHeader \u003d new PacketHeader();\n     }\n     curHeader.setFieldsFromData(payloadLen, headerBuf);\n     \n     // Compute the sub-slices of the packet\n     int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n     if (checksumLen \u003c 0) {\n       throw new IOException(\"Invalid packet: data length in packet header \" + \n           \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n           dataPlusChecksumLen + \" header: \" + curHeader); \n     }\n     \n     reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRead(ReadableByteChannel ch, InputStream in)\n      throws IOException {\n    // Each packet looks like:\n    //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n    //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n    //\n    // PLEN:      Payload length\n    //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n    //            This length includes its own encoded length in\n    //            the sum for historical reasons.\n    //\n    // HLEN:      Header length\n    //            \u003d length(HEADER)\n    //\n    // HEADER:    the actual packet header fields, encoded in protobuf\n    // CHECKSUMS: the crcs for the data chunk. May be missing if\n    //            checksums were not requested\n    // DATA       the actual block data\n    Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n\n    curPacketBuf.clear();\n    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n    int payloadLen \u003d curPacketBuf.getInt();\n    \n    if (payloadLen \u003c Ints.BYTES) {\n      // The \"payload length\" includes its own length. Therefore it\n      // should never be less than 4 bytes\n      throw new IOException(\"Invalid payload length \" +\n          payloadLen);\n    }\n    int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n    int headerLen \u003d curPacketBuf.getShort();\n    if (headerLen \u003c 0) {\n      throw new IOException(\"Invalid header length \" + headerLen);\n    }\n    \n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"readNextPacket: dataPlusChecksumLen \u003d \" + dataPlusChecksumLen +\n          \" headerLen \u003d \" + headerLen);\n    }\n    \n    // Sanity check the buffer size so we don\u0027t allocate too much memory\n    // and OOME.\n    int totalLen \u003d payloadLen + headerLen;\n    if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n      throw new IOException(\"Incorrect value for packet payload size: \" +\n                            payloadLen);\n    }\n\n    // Make sure we have space for the whole packet, and\n    // read it.\n    reallocPacketBuf(PacketHeader.PKT_LENGTHS_LEN +\n        dataPlusChecksumLen + headerLen);\n    curPacketBuf.clear();\n    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN +\n        dataPlusChecksumLen + headerLen);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n\n    // Extract the header from the front of the buffer (after the length prefixes)\n    byte[] headerBuf \u003d new byte[headerLen];\n    curPacketBuf.get(headerBuf);\n    if (curHeader \u003d\u003d null) {\n      curHeader \u003d new PacketHeader();\n    }\n    curHeader.setFieldsFromData(payloadLen, headerBuf);\n    \n    // Compute the sub-slices of the packet\n    int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n    if (checksumLen \u003c 0) {\n      throw new IOException(\"Invalid packet: data length in packet header \" + \n          \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n          dataPlusChecksumLen + \" header: \" + curHeader); \n    }\n    \n    reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/PacketReceiver.java",
      "extendedDetails": {}
    },
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\n",
      "commitDate": "29/09/15 5:48 PM",
      "commitName": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "31/08/15 1:54 PM",
      "commitNameOld": "826ae1c26d31f87d88efc920b271bec7eec2e17a",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 29.16,
      "commitsBetweenForRepo": 208,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,79 @@\n   private void doRead(ReadableByteChannel ch, InputStream in)\n       throws IOException {\n     // Each packet looks like:\n     //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n     //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n     //\n     // PLEN:      Payload length\n     //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n     //            This length includes its own encoded length in\n     //            the sum for historical reasons.\n     //\n     // HLEN:      Header length\n     //            \u003d length(HEADER)\n     //\n     // HEADER:    the actual packet header fields, encoded in protobuf\n     // CHECKSUMS: the crcs for the data chunk. May be missing if\n     //            checksums were not requested\n     // DATA       the actual block data\n     Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n \n     curPacketBuf.clear();\n     curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN);\n     doReadFully(ch, in, curPacketBuf);\n     curPacketBuf.flip();\n     int payloadLen \u003d curPacketBuf.getInt();\n     \n     if (payloadLen \u003c Ints.BYTES) {\n       // The \"payload length\" includes its own length. Therefore it\n       // should never be less than 4 bytes\n       throw new IOException(\"Invalid payload length \" +\n           payloadLen);\n     }\n     int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n     int headerLen \u003d curPacketBuf.getShort();\n     if (headerLen \u003c 0) {\n       throw new IOException(\"Invalid header length \" + headerLen);\n     }\n     \n-    if (LOG.isTraceEnabled()) {\n-      LOG.trace(\"readNextPacket: dataPlusChecksumLen \u003d \" + dataPlusChecksumLen +\n-          \" headerLen \u003d \" + headerLen);\n-    }\n-    \n+    LOG.trace(\"readNextPacket: dataPlusChecksumLen\u003d{}, headerLen\u003d{}\",\n+        dataPlusChecksumLen, headerLen);\n+\n     // Sanity check the buffer size so we don\u0027t allocate too much memory\n     // and OOME.\n     int totalLen \u003d payloadLen + headerLen;\n     if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n       throw new IOException(\"Incorrect value for packet payload size: \" +\n                             payloadLen);\n     }\n \n     // Make sure we have space for the whole packet, and\n     // read it.\n     reallocPacketBuf(PacketHeader.PKT_LENGTHS_LEN +\n         dataPlusChecksumLen + headerLen);\n     curPacketBuf.clear();\n     curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n     curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN +\n         dataPlusChecksumLen + headerLen);\n     doReadFully(ch, in, curPacketBuf);\n     curPacketBuf.flip();\n     curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n \n     // Extract the header from the front of the buffer (after the length prefixes)\n     byte[] headerBuf \u003d new byte[headerLen];\n     curPacketBuf.get(headerBuf);\n     if (curHeader \u003d\u003d null) {\n       curHeader \u003d new PacketHeader();\n     }\n     curHeader.setFieldsFromData(payloadLen, headerBuf);\n     \n     // Compute the sub-slices of the packet\n     int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n     if (checksumLen \u003c 0) {\n       throw new IOException(\"Invalid packet: data length in packet header \" + \n           \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n           dataPlusChecksumLen + \" header: \" + curHeader); \n     }\n     \n     reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRead(ReadableByteChannel ch, InputStream in)\n      throws IOException {\n    // Each packet looks like:\n    //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n    //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n    //\n    // PLEN:      Payload length\n    //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n    //            This length includes its own encoded length in\n    //            the sum for historical reasons.\n    //\n    // HLEN:      Header length\n    //            \u003d length(HEADER)\n    //\n    // HEADER:    the actual packet header fields, encoded in protobuf\n    // CHECKSUMS: the crcs for the data chunk. May be missing if\n    //            checksums were not requested\n    // DATA       the actual block data\n    Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n\n    curPacketBuf.clear();\n    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n    int payloadLen \u003d curPacketBuf.getInt();\n    \n    if (payloadLen \u003c Ints.BYTES) {\n      // The \"payload length\" includes its own length. Therefore it\n      // should never be less than 4 bytes\n      throw new IOException(\"Invalid payload length \" +\n          payloadLen);\n    }\n    int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n    int headerLen \u003d curPacketBuf.getShort();\n    if (headerLen \u003c 0) {\n      throw new IOException(\"Invalid header length \" + headerLen);\n    }\n    \n    LOG.trace(\"readNextPacket: dataPlusChecksumLen\u003d{}, headerLen\u003d{}\",\n        dataPlusChecksumLen, headerLen);\n\n    // Sanity check the buffer size so we don\u0027t allocate too much memory\n    // and OOME.\n    int totalLen \u003d payloadLen + headerLen;\n    if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n      throw new IOException(\"Incorrect value for packet payload size: \" +\n                            payloadLen);\n    }\n\n    // Make sure we have space for the whole packet, and\n    // read it.\n    reallocPacketBuf(PacketHeader.PKT_LENGTHS_LEN +\n        dataPlusChecksumLen + headerLen);\n    curPacketBuf.clear();\n    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN +\n        dataPlusChecksumLen + headerLen);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n\n    // Extract the header from the front of the buffer (after the length prefixes)\n    byte[] headerBuf \u003d new byte[headerLen];\n    curPacketBuf.get(headerBuf);\n    if (curHeader \u003d\u003d null) {\n      curHeader \u003d new PacketHeader();\n    }\n    curHeader.setFieldsFromData(payloadLen, headerBuf);\n    \n    // Compute the sub-slices of the packet\n    int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n    if (checksumLen \u003c 0) {\n      throw new IOException(\"Invalid packet: data length in packet header \" + \n          \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n          dataPlusChecksumLen + \" header: \" + curHeader); \n    }\n    \n    reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/PacketReceiver.java",
      "extendedDetails": {}
    },
    "826ae1c26d31f87d88efc920b271bec7eec2e17a": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8990. Move RemoteBlockReader to hdfs-client module. Contributed by Mingliang Liu.\n",
      "commitDate": "31/08/15 1:54 PM",
      "commitName": "826ae1c26d31f87d88efc920b271bec7eec2e17a",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "31/08/15 11:48 AM",
      "commitNameOld": "caa04de149030691b7bc952b534c6128db217ed2",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void doRead(ReadableByteChannel ch, InputStream in)\n      throws IOException {\n    // Each packet looks like:\n    //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n    //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n    //\n    // PLEN:      Payload length\n    //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n    //            This length includes its own encoded length in\n    //            the sum for historical reasons.\n    //\n    // HLEN:      Header length\n    //            \u003d length(HEADER)\n    //\n    // HEADER:    the actual packet header fields, encoded in protobuf\n    // CHECKSUMS: the crcs for the data chunk. May be missing if\n    //            checksums were not requested\n    // DATA       the actual block data\n    Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n\n    curPacketBuf.clear();\n    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n    int payloadLen \u003d curPacketBuf.getInt();\n    \n    if (payloadLen \u003c Ints.BYTES) {\n      // The \"payload length\" includes its own length. Therefore it\n      // should never be less than 4 bytes\n      throw new IOException(\"Invalid payload length \" +\n          payloadLen);\n    }\n    int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n    int headerLen \u003d curPacketBuf.getShort();\n    if (headerLen \u003c 0) {\n      throw new IOException(\"Invalid header length \" + headerLen);\n    }\n    \n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"readNextPacket: dataPlusChecksumLen \u003d \" + dataPlusChecksumLen +\n          \" headerLen \u003d \" + headerLen);\n    }\n    \n    // Sanity check the buffer size so we don\u0027t allocate too much memory\n    // and OOME.\n    int totalLen \u003d payloadLen + headerLen;\n    if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n      throw new IOException(\"Incorrect value for packet payload size: \" +\n                            payloadLen);\n    }\n\n    // Make sure we have space for the whole packet, and\n    // read it.\n    reallocPacketBuf(PacketHeader.PKT_LENGTHS_LEN +\n        dataPlusChecksumLen + headerLen);\n    curPacketBuf.clear();\n    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN +\n        dataPlusChecksumLen + headerLen);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n\n    // Extract the header from the front of the buffer (after the length prefixes)\n    byte[] headerBuf \u003d new byte[headerLen];\n    curPacketBuf.get(headerBuf);\n    if (curHeader \u003d\u003d null) {\n      curHeader \u003d new PacketHeader();\n    }\n    curHeader.setFieldsFromData(payloadLen, headerBuf);\n    \n    // Compute the sub-slices of the packet\n    int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n    if (checksumLen \u003c 0) {\n      throw new IOException(\"Invalid packet: data length in packet header \" + \n          \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n          dataPlusChecksumLen + \" header: \" + curHeader); \n    }\n    \n    reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/PacketReceiver.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/PacketReceiver.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/PacketReceiver.java"
      }
    },
    "f761bd8fe472c311bdff7c9d469f2805b867855a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5445. PacketReceiver populates the packetLen field in PacketHeader incorrectly (Jonathan Mace via Colin P. McCabe)\n",
      "commitDate": "12/01/15 5:11 PM",
      "commitName": "f761bd8fe472c311bdff7c9d469f2805b867855a",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "23/07/14 11:22 PM",
      "commitNameOld": "2054453a39efeca86361e26033a65f2715f4785c",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 172.78,
      "commitsBetweenForRepo": 1449,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,81 @@\n   private void doRead(ReadableByteChannel ch, InputStream in)\n       throws IOException {\n     // Each packet looks like:\n     //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n     //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n     //\n     // PLEN:      Payload length\n     //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n     //            This length includes its own encoded length in\n     //            the sum for historical reasons.\n     //\n     // HLEN:      Header length\n     //            \u003d length(HEADER)\n     //\n     // HEADER:    the actual packet header fields, encoded in protobuf\n     // CHECKSUMS: the crcs for the data chunk. May be missing if\n     //            checksums were not requested\n     // DATA       the actual block data\n     Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n \n     curPacketBuf.clear();\n     curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN);\n     doReadFully(ch, in, curPacketBuf);\n     curPacketBuf.flip();\n     int payloadLen \u003d curPacketBuf.getInt();\n     \n     if (payloadLen \u003c Ints.BYTES) {\n       // The \"payload length\" includes its own length. Therefore it\n       // should never be less than 4 bytes\n       throw new IOException(\"Invalid payload length \" +\n           payloadLen);\n     }\n     int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n     int headerLen \u003d curPacketBuf.getShort();\n     if (headerLen \u003c 0) {\n       throw new IOException(\"Invalid header length \" + headerLen);\n     }\n     \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"readNextPacket: dataPlusChecksumLen \u003d \" + dataPlusChecksumLen +\n           \" headerLen \u003d \" + headerLen);\n     }\n     \n     // Sanity check the buffer size so we don\u0027t allocate too much memory\n     // and OOME.\n     int totalLen \u003d payloadLen + headerLen;\n     if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n       throw new IOException(\"Incorrect value for packet payload size: \" +\n                             payloadLen);\n     }\n \n     // Make sure we have space for the whole packet, and\n     // read it.\n     reallocPacketBuf(PacketHeader.PKT_LENGTHS_LEN +\n         dataPlusChecksumLen + headerLen);\n     curPacketBuf.clear();\n     curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n     curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN +\n         dataPlusChecksumLen + headerLen);\n     doReadFully(ch, in, curPacketBuf);\n     curPacketBuf.flip();\n     curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n \n     // Extract the header from the front of the buffer (after the length prefixes)\n     byte[] headerBuf \u003d new byte[headerLen];\n     curPacketBuf.get(headerBuf);\n     if (curHeader \u003d\u003d null) {\n       curHeader \u003d new PacketHeader();\n     }\n-    curHeader.setFieldsFromData(dataPlusChecksumLen, headerBuf);\n+    curHeader.setFieldsFromData(payloadLen, headerBuf);\n     \n     // Compute the sub-slices of the packet\n     int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n     if (checksumLen \u003c 0) {\n       throw new IOException(\"Invalid packet: data length in packet header \" + \n           \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n           dataPlusChecksumLen + \" header: \" + curHeader); \n     }\n     \n     reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRead(ReadableByteChannel ch, InputStream in)\n      throws IOException {\n    // Each packet looks like:\n    //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n    //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n    //\n    // PLEN:      Payload length\n    //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n    //            This length includes its own encoded length in\n    //            the sum for historical reasons.\n    //\n    // HLEN:      Header length\n    //            \u003d length(HEADER)\n    //\n    // HEADER:    the actual packet header fields, encoded in protobuf\n    // CHECKSUMS: the crcs for the data chunk. May be missing if\n    //            checksums were not requested\n    // DATA       the actual block data\n    Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n\n    curPacketBuf.clear();\n    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n    int payloadLen \u003d curPacketBuf.getInt();\n    \n    if (payloadLen \u003c Ints.BYTES) {\n      // The \"payload length\" includes its own length. Therefore it\n      // should never be less than 4 bytes\n      throw new IOException(\"Invalid payload length \" +\n          payloadLen);\n    }\n    int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n    int headerLen \u003d curPacketBuf.getShort();\n    if (headerLen \u003c 0) {\n      throw new IOException(\"Invalid header length \" + headerLen);\n    }\n    \n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"readNextPacket: dataPlusChecksumLen \u003d \" + dataPlusChecksumLen +\n          \" headerLen \u003d \" + headerLen);\n    }\n    \n    // Sanity check the buffer size so we don\u0027t allocate too much memory\n    // and OOME.\n    int totalLen \u003d payloadLen + headerLen;\n    if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n      throw new IOException(\"Incorrect value for packet payload size: \" +\n                            payloadLen);\n    }\n\n    // Make sure we have space for the whole packet, and\n    // read it.\n    reallocPacketBuf(PacketHeader.PKT_LENGTHS_LEN +\n        dataPlusChecksumLen + headerLen);\n    curPacketBuf.clear();\n    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN +\n        dataPlusChecksumLen + headerLen);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n\n    // Extract the header from the front of the buffer (after the length prefixes)\n    byte[] headerBuf \u003d new byte[headerLen];\n    curPacketBuf.get(headerBuf);\n    if (curHeader \u003d\u003d null) {\n      curHeader \u003d new PacketHeader();\n    }\n    curHeader.setFieldsFromData(payloadLen, headerBuf);\n    \n    // Compute the sub-slices of the packet\n    int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n    if (checksumLen \u003c 0) {\n      throw new IOException(\"Invalid packet: data length in packet header \" + \n          \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n          dataPlusChecksumLen + \" header: \" + curHeader); \n    }\n    \n    reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/PacketReceiver.java",
      "extendedDetails": {}
    },
    "ded304e6a6e74742f6f4a35989f762dcefa234cb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4049. Fix hflush performance regression due to nagling delays. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1398591 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/10/12 5:55 PM",
      "commitName": "ded304e6a6e74742f6f4a35989f762dcefa234cb",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "09/08/12 2:31 PM",
      "commitNameOld": "9ea7c06468d236452f03c38a31d1a45f7f09dc50",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 67.14,
      "commitsBetweenForRepo": 411,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,81 @@\n   private void doRead(ReadableByteChannel ch, InputStream in)\n       throws IOException {\n     // Each packet looks like:\n     //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n     //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n     //\n     // PLEN:      Payload length\n     //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n     //            This length includes its own encoded length in\n     //            the sum for historical reasons.\n     //\n     // HLEN:      Header length\n     //            \u003d length(HEADER)\n     //\n     // HEADER:    the actual packet header fields, encoded in protobuf\n     // CHECKSUMS: the crcs for the data chunk. May be missing if\n     //            checksums were not requested\n     // DATA       the actual block data\n     Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n-    \n-    lengthPrefixBuf.clear();\n-    doReadFully(ch, in, lengthPrefixBuf);\n-    lengthPrefixBuf.flip();\n-    int payloadLen \u003d lengthPrefixBuf.getInt();\n+\n+    curPacketBuf.clear();\n+    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN);\n+    doReadFully(ch, in, curPacketBuf);\n+    curPacketBuf.flip();\n+    int payloadLen \u003d curPacketBuf.getInt();\n     \n     if (payloadLen \u003c Ints.BYTES) {\n       // The \"payload length\" includes its own length. Therefore it\n       // should never be less than 4 bytes\n       throw new IOException(\"Invalid payload length \" +\n           payloadLen);\n     }\n     int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n-    int headerLen \u003d lengthPrefixBuf.getShort();\n+    int headerLen \u003d curPacketBuf.getShort();\n     if (headerLen \u003c 0) {\n       throw new IOException(\"Invalid header length \" + headerLen);\n     }\n     \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"readNextPacket: dataPlusChecksumLen \u003d \" + dataPlusChecksumLen +\n           \" headerLen \u003d \" + headerLen);\n     }\n     \n     // Sanity check the buffer size so we don\u0027t allocate too much memory\n     // and OOME.\n     int totalLen \u003d payloadLen + headerLen;\n     if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n       throw new IOException(\"Incorrect value for packet payload size: \" +\n                             payloadLen);\n     }\n \n     // Make sure we have space for the whole packet, and\n     // read it.\n-    reallocPacketBuf(dataPlusChecksumLen + headerLen);\n+    reallocPacketBuf(PacketHeader.PKT_LENGTHS_LEN +\n+        dataPlusChecksumLen + headerLen);\n     curPacketBuf.clear();\n-    curPacketBuf.limit(dataPlusChecksumLen + headerLen);\n+    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n+    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN +\n+        dataPlusChecksumLen + headerLen);\n     doReadFully(ch, in, curPacketBuf);\n     curPacketBuf.flip();\n+    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n \n-    // Extract the header from the front of the buffer.\n+    // Extract the header from the front of the buffer (after the length prefixes)\n     byte[] headerBuf \u003d new byte[headerLen];\n     curPacketBuf.get(headerBuf);\n     if (curHeader \u003d\u003d null) {\n       curHeader \u003d new PacketHeader();\n     }\n     curHeader.setFieldsFromData(dataPlusChecksumLen, headerBuf);\n     \n     // Compute the sub-slices of the packet\n     int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n     if (checksumLen \u003c 0) {\n       throw new IOException(\"Invalid packet: data length in packet header \" + \n           \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n           dataPlusChecksumLen + \" header: \" + curHeader); \n     }\n     \n     reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRead(ReadableByteChannel ch, InputStream in)\n      throws IOException {\n    // Each packet looks like:\n    //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n    //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n    //\n    // PLEN:      Payload length\n    //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n    //            This length includes its own encoded length in\n    //            the sum for historical reasons.\n    //\n    // HLEN:      Header length\n    //            \u003d length(HEADER)\n    //\n    // HEADER:    the actual packet header fields, encoded in protobuf\n    // CHECKSUMS: the crcs for the data chunk. May be missing if\n    //            checksums were not requested\n    // DATA       the actual block data\n    Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n\n    curPacketBuf.clear();\n    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n    int payloadLen \u003d curPacketBuf.getInt();\n    \n    if (payloadLen \u003c Ints.BYTES) {\n      // The \"payload length\" includes its own length. Therefore it\n      // should never be less than 4 bytes\n      throw new IOException(\"Invalid payload length \" +\n          payloadLen);\n    }\n    int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n    int headerLen \u003d curPacketBuf.getShort();\n    if (headerLen \u003c 0) {\n      throw new IOException(\"Invalid header length \" + headerLen);\n    }\n    \n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"readNextPacket: dataPlusChecksumLen \u003d \" + dataPlusChecksumLen +\n          \" headerLen \u003d \" + headerLen);\n    }\n    \n    // Sanity check the buffer size so we don\u0027t allocate too much memory\n    // and OOME.\n    int totalLen \u003d payloadLen + headerLen;\n    if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n      throw new IOException(\"Incorrect value for packet payload size: \" +\n                            payloadLen);\n    }\n\n    // Make sure we have space for the whole packet, and\n    // read it.\n    reallocPacketBuf(PacketHeader.PKT_LENGTHS_LEN +\n        dataPlusChecksumLen + headerLen);\n    curPacketBuf.clear();\n    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n    curPacketBuf.limit(PacketHeader.PKT_LENGTHS_LEN +\n        dataPlusChecksumLen + headerLen);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n    curPacketBuf.position(PacketHeader.PKT_LENGTHS_LEN);\n\n    // Extract the header from the front of the buffer (after the length prefixes)\n    byte[] headerBuf \u003d new byte[headerLen];\n    curPacketBuf.get(headerBuf);\n    if (curHeader \u003d\u003d null) {\n      curHeader \u003d new PacketHeader();\n    }\n    curHeader.setFieldsFromData(dataPlusChecksumLen, headerBuf);\n    \n    // Compute the sub-slices of the packet\n    int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n    if (checksumLen \u003c 0) {\n      throw new IOException(\"Invalid packet: data length in packet header \" + \n          \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n          dataPlusChecksumLen + \" header: \" + curHeader); \n    }\n    \n    reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/PacketReceiver.java",
      "extendedDetails": {}
    },
    "9ea7c06468d236452f03c38a31d1a45f7f09dc50": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3721. hsync support broke wire compatibility. Contributed by Todd Lipcon and Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1371495 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/08/12 2:31 PM",
      "commitName": "9ea7c06468d236452f03c38a31d1a45f7f09dc50",
      "commitAuthor": "Aaron Myers",
      "diff": "@@ -0,0 +1,76 @@\n+  private void doRead(ReadableByteChannel ch, InputStream in)\n+      throws IOException {\n+    // Each packet looks like:\n+    //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n+    //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n+    //\n+    // PLEN:      Payload length\n+    //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n+    //            This length includes its own encoded length in\n+    //            the sum for historical reasons.\n+    //\n+    // HLEN:      Header length\n+    //            \u003d length(HEADER)\n+    //\n+    // HEADER:    the actual packet header fields, encoded in protobuf\n+    // CHECKSUMS: the crcs for the data chunk. May be missing if\n+    //            checksums were not requested\n+    // DATA       the actual block data\n+    Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n+    \n+    lengthPrefixBuf.clear();\n+    doReadFully(ch, in, lengthPrefixBuf);\n+    lengthPrefixBuf.flip();\n+    int payloadLen \u003d lengthPrefixBuf.getInt();\n+    \n+    if (payloadLen \u003c Ints.BYTES) {\n+      // The \"payload length\" includes its own length. Therefore it\n+      // should never be less than 4 bytes\n+      throw new IOException(\"Invalid payload length \" +\n+          payloadLen);\n+    }\n+    int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n+    int headerLen \u003d lengthPrefixBuf.getShort();\n+    if (headerLen \u003c 0) {\n+      throw new IOException(\"Invalid header length \" + headerLen);\n+    }\n+    \n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(\"readNextPacket: dataPlusChecksumLen \u003d \" + dataPlusChecksumLen +\n+          \" headerLen \u003d \" + headerLen);\n+    }\n+    \n+    // Sanity check the buffer size so we don\u0027t allocate too much memory\n+    // and OOME.\n+    int totalLen \u003d payloadLen + headerLen;\n+    if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n+      throw new IOException(\"Incorrect value for packet payload size: \" +\n+                            payloadLen);\n+    }\n+\n+    // Make sure we have space for the whole packet, and\n+    // read it.\n+    reallocPacketBuf(dataPlusChecksumLen + headerLen);\n+    curPacketBuf.clear();\n+    curPacketBuf.limit(dataPlusChecksumLen + headerLen);\n+    doReadFully(ch, in, curPacketBuf);\n+    curPacketBuf.flip();\n+\n+    // Extract the header from the front of the buffer.\n+    byte[] headerBuf \u003d new byte[headerLen];\n+    curPacketBuf.get(headerBuf);\n+    if (curHeader \u003d\u003d null) {\n+      curHeader \u003d new PacketHeader();\n+    }\n+    curHeader.setFieldsFromData(dataPlusChecksumLen, headerBuf);\n+    \n+    // Compute the sub-slices of the packet\n+    int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n+    if (checksumLen \u003c 0) {\n+      throw new IOException(\"Invalid packet: data length in packet header \" + \n+          \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n+          dataPlusChecksumLen + \" header: \" + curHeader); \n+    }\n+    \n+    reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRead(ReadableByteChannel ch, InputStream in)\n      throws IOException {\n    // Each packet looks like:\n    //   PLEN    HLEN      HEADER     CHECKSUMS  DATA\n    //   32-bit  16-bit   \u003cprotobuf\u003e  \u003cvariable length\u003e\n    //\n    // PLEN:      Payload length\n    //            \u003d length(PLEN) + length(CHECKSUMS) + length(DATA)\n    //            This length includes its own encoded length in\n    //            the sum for historical reasons.\n    //\n    // HLEN:      Header length\n    //            \u003d length(HEADER)\n    //\n    // HEADER:    the actual packet header fields, encoded in protobuf\n    // CHECKSUMS: the crcs for the data chunk. May be missing if\n    //            checksums were not requested\n    // DATA       the actual block data\n    Preconditions.checkState(curHeader \u003d\u003d null || !curHeader.isLastPacketInBlock());\n    \n    lengthPrefixBuf.clear();\n    doReadFully(ch, in, lengthPrefixBuf);\n    lengthPrefixBuf.flip();\n    int payloadLen \u003d lengthPrefixBuf.getInt();\n    \n    if (payloadLen \u003c Ints.BYTES) {\n      // The \"payload length\" includes its own length. Therefore it\n      // should never be less than 4 bytes\n      throw new IOException(\"Invalid payload length \" +\n          payloadLen);\n    }\n    int dataPlusChecksumLen \u003d payloadLen - Ints.BYTES;\n    int headerLen \u003d lengthPrefixBuf.getShort();\n    if (headerLen \u003c 0) {\n      throw new IOException(\"Invalid header length \" + headerLen);\n    }\n    \n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"readNextPacket: dataPlusChecksumLen \u003d \" + dataPlusChecksumLen +\n          \" headerLen \u003d \" + headerLen);\n    }\n    \n    // Sanity check the buffer size so we don\u0027t allocate too much memory\n    // and OOME.\n    int totalLen \u003d payloadLen + headerLen;\n    if (totalLen \u003c 0 || totalLen \u003e MAX_PACKET_SIZE) {\n      throw new IOException(\"Incorrect value for packet payload size: \" +\n                            payloadLen);\n    }\n\n    // Make sure we have space for the whole packet, and\n    // read it.\n    reallocPacketBuf(dataPlusChecksumLen + headerLen);\n    curPacketBuf.clear();\n    curPacketBuf.limit(dataPlusChecksumLen + headerLen);\n    doReadFully(ch, in, curPacketBuf);\n    curPacketBuf.flip();\n\n    // Extract the header from the front of the buffer.\n    byte[] headerBuf \u003d new byte[headerLen];\n    curPacketBuf.get(headerBuf);\n    if (curHeader \u003d\u003d null) {\n      curHeader \u003d new PacketHeader();\n    }\n    curHeader.setFieldsFromData(dataPlusChecksumLen, headerBuf);\n    \n    // Compute the sub-slices of the packet\n    int checksumLen \u003d dataPlusChecksumLen - curHeader.getDataLen();\n    if (checksumLen \u003c 0) {\n      throw new IOException(\"Invalid packet: data length in packet header \" + \n          \"exceeds data length received. dataPlusChecksumLen\u003d\" +\n          dataPlusChecksumLen + \" header: \" + curHeader); \n    }\n    \n    reslicePacket(headerLen, checksumLen, curHeader.getDataLen());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/PacketReceiver.java"
    }
  }
}