{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CleanerTask.java",
  "functionName": "processSingleResource",
  "functionId": "processSingleResource___resource-FileStatus",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-sharedcachemanager/src/main/java/org/apache/hadoop/yarn/server/sharedcachemanager/CleanerTask.java",
  "functionStartLine": 196,
  "functionEndLine": 276,
  "numCommitsSeen": 2,
  "timeTaken": 652,
  "changeHistory": [
    "c51e53d7aad46059f52d4046a5fedfdfd3c37955"
  ],
  "changeHistoryShort": {
    "c51e53d7aad46059f52d4046a5fedfdfd3c37955": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c51e53d7aad46059f52d4046a5fedfdfd3c37955": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2183. [YARN-1492] Cleaner service for cache manager. (Chris Trezzo and Sangjin Lee via kasha)\n",
      "commitDate": "25/10/14 10:31 AM",
      "commitName": "c51e53d7aad46059f52d4046a5fedfdfd3c37955",
      "commitAuthor": "Karthik Kambatla",
      "diff": "@@ -0,0 +1,81 @@\n+  void processSingleResource(FileStatus resource) {\n+    Path path \u003d resource.getPath();\n+    // indicates the processing status of the resource\n+    ResourceStatus resourceStatus \u003d ResourceStatus.INIT;\n+\n+    // first, if the path ends with the renamed suffix, it indicates the\n+    // directory was moved (as stale) but somehow not deleted (probably due to\n+    // SCM failure); delete the directory\n+    if (path.toString().endsWith(RENAMED_SUFFIX)) {\n+      LOG.info(\"Found a renamed directory that was left undeleted at \" +\n+          path.toString() + \". Deleting.\");\n+      try {\n+        if (fs.delete(path, true)) {\n+          resourceStatus \u003d ResourceStatus.DELETED;\n+        }\n+      } catch (IOException e) {\n+        LOG.error(\"Error while processing a shared cache resource: \" + path, e);\n+      }\n+    } else {\n+      // this is the path to the cache resource directory\n+      // the directory name is the resource key (i.e. a unique identifier)\n+      String key \u003d path.getName();\n+\n+      try {\n+        store.cleanResourceReferences(key);\n+      } catch (YarnException e) {\n+        LOG.error(\"Exception thrown while removing dead appIds.\", e);\n+      }\n+\n+      if (store.isResourceEvictable(key, resource)) {\n+        try {\n+          /*\n+           * TODO See YARN-2663: There is a race condition between\n+           * store.removeResource(key) and\n+           * removeResourceFromCacheFileSystem(path) operations because they do\n+           * not happen atomically and resources can be uploaded with different\n+           * file names by the node managers.\n+           */\n+          // remove the resource from scm (checks for appIds as well)\n+          if (store.removeResource(key)) {\n+            // remove the resource from the file system\n+            boolean deleted \u003d removeResourceFromCacheFileSystem(path);\n+            if (deleted) {\n+              resourceStatus \u003d ResourceStatus.DELETED;\n+            } else {\n+              LOG.error(\"Failed to remove path from the file system.\"\n+                  + \" Skipping this resource: \" + path);\n+              resourceStatus \u003d ResourceStatus.ERROR;\n+            }\n+          } else {\n+            // we did not delete the resource because it contained application\n+            // ids\n+            resourceStatus \u003d ResourceStatus.PROCESSED;\n+          }\n+        } catch (IOException e) {\n+          LOG.error(\n+              \"Failed to remove path from the file system. Skipping this resource: \"\n+                  + path, e);\n+          resourceStatus \u003d ResourceStatus.ERROR;\n+        }\n+      } else {\n+        resourceStatus \u003d ResourceStatus.PROCESSED;\n+      }\n+    }\n+\n+    // record the processing\n+    switch (resourceStatus) {\n+    case DELETED:\n+      metrics.reportAFileDelete();\n+      break;\n+    case PROCESSED:\n+      metrics.reportAFileProcess();\n+      break;\n+    case ERROR:\n+      metrics.reportAFileError();\n+      break;\n+    default:\n+      LOG.error(\"Cleaner encountered an invalid status (\" + resourceStatus\n+          + \") while processing resource: \" + path.getName());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void processSingleResource(FileStatus resource) {\n    Path path \u003d resource.getPath();\n    // indicates the processing status of the resource\n    ResourceStatus resourceStatus \u003d ResourceStatus.INIT;\n\n    // first, if the path ends with the renamed suffix, it indicates the\n    // directory was moved (as stale) but somehow not deleted (probably due to\n    // SCM failure); delete the directory\n    if (path.toString().endsWith(RENAMED_SUFFIX)) {\n      LOG.info(\"Found a renamed directory that was left undeleted at \" +\n          path.toString() + \". Deleting.\");\n      try {\n        if (fs.delete(path, true)) {\n          resourceStatus \u003d ResourceStatus.DELETED;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error while processing a shared cache resource: \" + path, e);\n      }\n    } else {\n      // this is the path to the cache resource directory\n      // the directory name is the resource key (i.e. a unique identifier)\n      String key \u003d path.getName();\n\n      try {\n        store.cleanResourceReferences(key);\n      } catch (YarnException e) {\n        LOG.error(\"Exception thrown while removing dead appIds.\", e);\n      }\n\n      if (store.isResourceEvictable(key, resource)) {\n        try {\n          /*\n           * TODO See YARN-2663: There is a race condition between\n           * store.removeResource(key) and\n           * removeResourceFromCacheFileSystem(path) operations because they do\n           * not happen atomically and resources can be uploaded with different\n           * file names by the node managers.\n           */\n          // remove the resource from scm (checks for appIds as well)\n          if (store.removeResource(key)) {\n            // remove the resource from the file system\n            boolean deleted \u003d removeResourceFromCacheFileSystem(path);\n            if (deleted) {\n              resourceStatus \u003d ResourceStatus.DELETED;\n            } else {\n              LOG.error(\"Failed to remove path from the file system.\"\n                  + \" Skipping this resource: \" + path);\n              resourceStatus \u003d ResourceStatus.ERROR;\n            }\n          } else {\n            // we did not delete the resource because it contained application\n            // ids\n            resourceStatus \u003d ResourceStatus.PROCESSED;\n          }\n        } catch (IOException e) {\n          LOG.error(\n              \"Failed to remove path from the file system. Skipping this resource: \"\n                  + path, e);\n          resourceStatus \u003d ResourceStatus.ERROR;\n        }\n      } else {\n        resourceStatus \u003d ResourceStatus.PROCESSED;\n      }\n    }\n\n    // record the processing\n    switch (resourceStatus) {\n    case DELETED:\n      metrics.reportAFileDelete();\n      break;\n    case PROCESSED:\n      metrics.reportAFileProcess();\n      break;\n    case ERROR:\n      metrics.reportAFileError();\n      break;\n    default:\n      LOG.error(\"Cleaner encountered an invalid status (\" + resourceStatus\n          + \") while processing resource: \" + path.getName());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-sharedcachemanager/src/main/java/org/apache/hadoop/yarn/server/sharedcachemanager/CleanerTask.java"
    }
  }
}