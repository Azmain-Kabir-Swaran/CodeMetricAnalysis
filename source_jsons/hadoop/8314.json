{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NamenodeWebHdfsMethods.java",
  "functionName": "get",
  "functionId": "get___ugi-UserGroupInformation(modifiers-final)__delegation-DelegationParam(modifiers-final)__username-UserParam(modifiers-final)__doAsUser-DoAsParam(modifiers-final)__fullpath-String(modifiers-final)__op-GetOpParam(modifiers-final)__offset-OffsetParam(modifiers-final)__length-LengthParam(modifiers-final)__renewer-RenewerParam(modifiers-final)__bufferSize-BufferSizeParam(modifiers-final)__xattrNames-List__XAttrNameParam__(modifiers-final)__xattrEncoding-XAttrEncodingParam(modifiers-final)__excludeDatanodes-ExcludeDatanodesParam(modifiers-final)__fsAction-FsActionParam(modifiers-final)__snapshotName-SnapshotNameParam(modifiers-final)__oldSnapshotName-OldSnapshotNameParam(modifiers-final)__tokenKind-TokenKindParam(modifiers-final)__tokenService-TokenServiceParam(modifiers-final)__noredirectParam-NoRedirectParam(modifiers-final)__startAfter-StartAfterParam(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
  "functionStartLine": 1122,
  "functionEndLine": 1346,
  "numCommitsSeen": 583,
  "timeTaken": 20198,
  "changeHistory": [
    "2338d25dc7150d75fbda84cc95422380b5622224",
    "3ae775d74029b6ae82263739f598ceb25c597dcd",
    "729cb3aefe71d7f728c7edea78ce7f268a1fdecb",
    "39dc7345b80e27ba8bd1ff4c19ca241aef5ac0fc",
    "e7b63baca1e10b28d8b4462fd80537b871951aa3",
    "3ead525c71cba068e7abf1c76ad629bfeec10852",
    "6e31a090842f8aeedb331b653b075499f8df6c60",
    "0355ec20ebeb988679c7192c7024bef7a2a3bced",
    "1e84e46f1621fe694f806bfc41d3b2a06c9500b6",
    "fde95d463c3123b315b3d07cb5b7b7dc19f7cb73",
    "2ee0d64aceed876f57f09eb9efe1872b6de98d2e",
    "0da29cbeea40cb7839abcd72566b997962829329",
    "390c2b5df0c4e25a2156d8daefd4670efe82b191",
    "7fcc73fc0d248aae1edbd4e1514c5818f6198928",
    "ea2895f4ed5031809d856faa52e9de5b9501bdea",
    "08a7253bc0eb6c9155457feecb9c5cdc17c3a814",
    "c7ff34f8dcca3a2024230c5383abd9299daa1b20",
    "ca68f9cb5bc78e996c0daf8024cf0e7a4faef12a",
    "d8bab3dcb693b2773ede9a6e4f71ae85ee056f79",
    "85bab5fb572194fda38854f1f21c670925058009",
    "4b0f55b6ea1665e2118fd573f72a6fcd1fce20d6",
    "576b569b6c97bd5f57e52efdabdf8c2fa996a524",
    "832b3cbde1c2f77b04c93188e3a94420974090cf",
    "fac4e04dd359a7ff31f286d664fb06f019ec0b58",
    "e2be3337448ec0f6772a2ba463da376e7089b1fa",
    "535fe14dedbf919442ec03ac573315c7a16a6dbe",
    "7c18f8d55b899dc4a6e118d3b54447a9b36b960a",
    "6a4f6d6b3e41e660c214b77c9ed43d4c65200b6a",
    "880a0c673c74a128a01c72b60695f05327f5e961",
    "ac23a55547716df29b3e25c98a113399e184d9d1",
    "b46fbd0275bfc7ec16a219c72cff555d912170d7",
    "7a03dc0482d28b8d5741f633f305bd3afb7a572b",
    "8fa10b184e607a33f59e67bd4b1fbe5a2e683941",
    "bf1649d5fd095ce027f013be57d216212fa14198",
    "eeec4dc72abf4c540146a81c5419828520b80fa4"
  ],
  "changeHistoryShort": {
    "2338d25dc7150d75fbda84cc95422380b5622224": "Ybodychange",
    "3ae775d74029b6ae82263739f598ceb25c597dcd": "Ybodychange",
    "729cb3aefe71d7f728c7edea78ce7f268a1fdecb": "Ybodychange",
    "39dc7345b80e27ba8bd1ff4c19ca241aef5ac0fc": "Ybodychange",
    "e7b63baca1e10b28d8b4462fd80537b871951aa3": "Ybodychange",
    "3ead525c71cba068e7abf1c76ad629bfeec10852": "Ybodychange",
    "6e31a090842f8aeedb331b653b075499f8df6c60": "Ymodifierchange",
    "0355ec20ebeb988679c7192c7024bef7a2a3bced": "Ybodychange",
    "1e84e46f1621fe694f806bfc41d3b2a06c9500b6": "Ymultichange(Yparameterchange,Ybodychange)",
    "fde95d463c3123b315b3d07cb5b7b7dc19f7cb73": "Ybodychange",
    "2ee0d64aceed876f57f09eb9efe1872b6de98d2e": "Ybodychange",
    "0da29cbeea40cb7839abcd72566b997962829329": "Ybodychange",
    "390c2b5df0c4e25a2156d8daefd4670efe82b191": "Ybodychange",
    "7fcc73fc0d248aae1edbd4e1514c5818f6198928": "Ybodychange",
    "ea2895f4ed5031809d856faa52e9de5b9501bdea": "Ybodychange",
    "08a7253bc0eb6c9155457feecb9c5cdc17c3a814": "Ybodychange",
    "c7ff34f8dcca3a2024230c5383abd9299daa1b20": "Ybodychange",
    "ca68f9cb5bc78e996c0daf8024cf0e7a4faef12a": "Ybodychange",
    "d8bab3dcb693b2773ede9a6e4f71ae85ee056f79": "Ybodychange",
    "85bab5fb572194fda38854f1f21c670925058009": "Ymultichange(Yparameterchange,Ybodychange)",
    "4b0f55b6ea1665e2118fd573f72a6fcd1fce20d6": "Ymultichange(Yparameterchange,Ybodychange)",
    "576b569b6c97bd5f57e52efdabdf8c2fa996a524": "Ybodychange",
    "832b3cbde1c2f77b04c93188e3a94420974090cf": "Ybodychange",
    "fac4e04dd359a7ff31f286d664fb06f019ec0b58": "Ybodychange",
    "e2be3337448ec0f6772a2ba463da376e7089b1fa": "Ymultichange(Yparameterchange,Ybodychange)",
    "535fe14dedbf919442ec03ac573315c7a16a6dbe": "Ymultichange(Yparameterchange,Ybodychange)",
    "7c18f8d55b899dc4a6e118d3b54447a9b36b960a": "Ymultichange(Yparameterchange,Ybodychange)",
    "6a4f6d6b3e41e660c214b77c9ed43d4c65200b6a": "Ymultichange(Yparameterchange,Ybodychange)",
    "880a0c673c74a128a01c72b60695f05327f5e961": "Ybodychange",
    "ac23a55547716df29b3e25c98a113399e184d9d1": "Ymultichange(Yparameterchange,Ybodychange)",
    "b46fbd0275bfc7ec16a219c72cff555d912170d7": "Ybodychange",
    "7a03dc0482d28b8d5741f633f305bd3afb7a572b": "Ybodychange",
    "8fa10b184e607a33f59e67bd4b1fbe5a2e683941": "Ybodychange",
    "bf1649d5fd095ce027f013be57d216212fa14198": "Ybodychange",
    "eeec4dc72abf4c540146a81c5419828520b80fa4": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2338d25dc7150d75fbda84cc95422380b5622224": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15052. WebHDFS getTrashRoot leads to OOM due to FileSystem object creation. (#1758)\n\n\r\n",
      "commitDate": "20/02/20 6:56 PM",
      "commitName": "2338d25dc7150d75fbda84cc95422380b5622224",
      "commitAuthor": "Masatake Iwasaki",
      "commitDateOld": "28/08/19 11:28 AM",
      "commitNameOld": "29bd6f3fc3bd78b439d61768885c9f3e7f31a540",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 176.35,
      "commitsBetweenForRepo": 827,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,225 +1,225 @@\n   protected Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final SnapshotNameParam snapshotName,\n       final OldSnapshotNameParam oldSnapshotName,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final ClientProtocol cp \u003d getRpcClientProtocol();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       ResponseBuilder rb \u003d Response.noContent();\n       final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n             .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n             .build();\n       }\n     }\n     case GETFILEBLOCKLOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       LocatedBlocks locatedBlocks \u003d getRpcClientProtocol()\n           .getBlockLocations(fullpath, offsetValue, lengthValue !\u003d null ?\n               lengthValue : Long.MAX_VALUE);\n       BlockLocation[] locations \u003d\n           DFSUtilClient.locatedBlocks2Locations(locatedBlocks);\n       final String js \u003d JsonUtil.toJsonString(locations);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETQUOTAUSAGE:\n     {\n       final QuotaUsage quotaUsage \u003d cp.getQuotaUsage(fullpath);\n       final String js \u003d JsonUtil.toJsonString(quotaUsage);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n-      String userHome \u003d DFSUtilClient.getHomeDirectory(conf, ugi).toString();\n+      String userHome \u003d DFSUtilClient.getHomeDirectory(conf, ugi);\n       final String js \u003d JsonUtil.toJsonString(\"Path\", userHome);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d cp.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n-      final String trashPath \u003d getTrashRoot(fullpath, conf);\n+      final String trashPath \u003d getTrashRoot(conf, fullpath);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETECPOLICY: {\n       ErasureCodingPolicy ecpolicy \u003d cp.getErasureCodingPolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(ecpolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSERVERDEFAULTS: {\n       // Since none of the server defaults values are hot reloaded, we can\n       // cache the output of serverDefaults.\n       String serverDefaultsResponse \u003d\n           (String) context.getAttribute(\"serverDefaults\");\n       if (serverDefaultsResponse \u003d\u003d null) {\n         FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n         serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n         context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n       }\n       return Response.ok(serverDefaultsResponse)\n           .type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTDIFF: {\n       SnapshotDiffReport diffReport \u003d\n           cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n               snapshotName.getValue());\n       final String js \u003d JsonUtil.toJsonString(diffReport);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n           cp.getSnapshottableDirListing();\n       final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final SnapshotNameParam snapshotName,\n      final OldSnapshotNameParam oldSnapshotName,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final ClientProtocol cp \u003d getRpcClientProtocol();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      ResponseBuilder rb \u003d Response.noContent();\n      final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n            .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n            .build();\n      }\n    }\n    case GETFILEBLOCKLOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      LocatedBlocks locatedBlocks \u003d getRpcClientProtocol()\n          .getBlockLocations(fullpath, offsetValue, lengthValue !\u003d null ?\n              lengthValue : Long.MAX_VALUE);\n      BlockLocation[] locations \u003d\n          DFSUtilClient.locatedBlocks2Locations(locatedBlocks);\n      final String js \u003d JsonUtil.toJsonString(locations);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETQUOTAUSAGE:\n    {\n      final QuotaUsage quotaUsage \u003d cp.getQuotaUsage(fullpath);\n      final String js \u003d JsonUtil.toJsonString(quotaUsage);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      String userHome \u003d DFSUtilClient.getHomeDirectory(conf, ugi);\n      final String js \u003d JsonUtil.toJsonString(\"Path\", userHome);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d cp.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(conf, fullpath);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETECPOLICY: {\n      ErasureCodingPolicy ecpolicy \u003d cp.getErasureCodingPolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(ecpolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      String serverDefaultsResponse \u003d\n          (String) context.getAttribute(\"serverDefaults\");\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n        context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTDIFF: {\n      SnapshotDiffReport diffReport \u003d\n          cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n              snapshotName.getValue());\n      final String js \u003d JsonUtil.toJsonString(diffReport);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n          cp.getSnapshottableDirListing();\n      final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "3ae775d74029b6ae82263739f598ceb25c597dcd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14034. Support getQuotaUsage API in WebHDFS. Contributed by Chao Sun.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "30/07/19 4:01 PM",
      "commitName": "3ae775d74029b6ae82263739f598ceb25c597dcd",
      "commitAuthor": "Chao Sun",
      "commitDateOld": "03/07/19 6:37 PM",
      "commitNameOld": "729cb3aefe71d7f728c7edea78ce7f268a1fdecb",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 26.89,
      "commitsBetweenForRepo": 183,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,219 +1,225 @@\n   protected Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final SnapshotNameParam snapshotName,\n       final OldSnapshotNameParam oldSnapshotName,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final ClientProtocol cp \u003d getRpcClientProtocol();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       ResponseBuilder rb \u003d Response.noContent();\n       final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n             .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n             .build();\n       }\n     }\n     case GETFILEBLOCKLOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       LocatedBlocks locatedBlocks \u003d getRpcClientProtocol()\n           .getBlockLocations(fullpath, offsetValue, lengthValue !\u003d null ?\n               lengthValue : Long.MAX_VALUE);\n       BlockLocation[] locations \u003d\n           DFSUtilClient.locatedBlocks2Locations(locatedBlocks);\n       final String js \u003d JsonUtil.toJsonString(locations);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n+    case GETQUOTAUSAGE:\n+    {\n+      final QuotaUsage quotaUsage \u003d cp.getQuotaUsage(fullpath);\n+      final String js \u003d JsonUtil.toJsonString(quotaUsage);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     case GETFILECHECKSUM:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       String userHome \u003d DFSUtilClient.getHomeDirectory(conf, ugi).toString();\n       final String js \u003d JsonUtil.toJsonString(\"Path\", userHome);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d cp.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETECPOLICY: {\n       ErasureCodingPolicy ecpolicy \u003d cp.getErasureCodingPolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(ecpolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSERVERDEFAULTS: {\n       // Since none of the server defaults values are hot reloaded, we can\n       // cache the output of serverDefaults.\n       String serverDefaultsResponse \u003d\n           (String) context.getAttribute(\"serverDefaults\");\n       if (serverDefaultsResponse \u003d\u003d null) {\n         FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n         serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n         context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n       }\n       return Response.ok(serverDefaultsResponse)\n           .type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTDIFF: {\n       SnapshotDiffReport diffReport \u003d\n           cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n               snapshotName.getValue());\n       final String js \u003d JsonUtil.toJsonString(diffReport);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n           cp.getSnapshottableDirListing();\n       final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final SnapshotNameParam snapshotName,\n      final OldSnapshotNameParam oldSnapshotName,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final ClientProtocol cp \u003d getRpcClientProtocol();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      ResponseBuilder rb \u003d Response.noContent();\n      final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n            .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n            .build();\n      }\n    }\n    case GETFILEBLOCKLOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      LocatedBlocks locatedBlocks \u003d getRpcClientProtocol()\n          .getBlockLocations(fullpath, offsetValue, lengthValue !\u003d null ?\n              lengthValue : Long.MAX_VALUE);\n      BlockLocation[] locations \u003d\n          DFSUtilClient.locatedBlocks2Locations(locatedBlocks);\n      final String js \u003d JsonUtil.toJsonString(locations);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETQUOTAUSAGE:\n    {\n      final QuotaUsage quotaUsage \u003d cp.getQuotaUsage(fullpath);\n      final String js \u003d JsonUtil.toJsonString(quotaUsage);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      String userHome \u003d DFSUtilClient.getHomeDirectory(conf, ugi).toString();\n      final String js \u003d JsonUtil.toJsonString(\"Path\", userHome);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d cp.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETECPOLICY: {\n      ErasureCodingPolicy ecpolicy \u003d cp.getErasureCodingPolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(ecpolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      String serverDefaultsResponse \u003d\n          (String) context.getAttribute(\"serverDefaults\");\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n        context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTDIFF: {\n      SnapshotDiffReport diffReport \u003d\n          cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n              snapshotName.getValue());\n      final String js \u003d JsonUtil.toJsonString(diffReport);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n          cp.getSnapshottableDirListing();\n      final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "729cb3aefe71d7f728c7edea78ce7f268a1fdecb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12748. NameNode memory leak when accessing webhdfs GETHOMEDIRECTORY. Contributed by Weiwei Yang.\n",
      "commitDate": "03/07/19 6:37 PM",
      "commitName": "729cb3aefe71d7f728c7edea78ce7f268a1fdecb",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "21/02/19 7:06 AM",
      "commitNameOld": "92b53c40f070bbfe65c736f6f3eca721b9d227f5",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 132.44,
      "commitsBetweenForRepo": 985,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,220 +1,219 @@\n   protected Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final SnapshotNameParam snapshotName,\n       final OldSnapshotNameParam oldSnapshotName,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final ClientProtocol cp \u003d getRpcClientProtocol();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       ResponseBuilder rb \u003d Response.noContent();\n       final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n             .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n             .build();\n       }\n     }\n     case GETFILEBLOCKLOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       LocatedBlocks locatedBlocks \u003d getRpcClientProtocol()\n           .getBlockLocations(fullpath, offsetValue, lengthValue !\u003d null ?\n               lengthValue : Long.MAX_VALUE);\n       BlockLocation[] locations \u003d\n           DFSUtilClient.locatedBlocks2Locations(locatedBlocks);\n       final String js \u003d JsonUtil.toJsonString(locations);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n-      final String js \u003d JsonUtil.toJsonString(\"Path\",\n-          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n-              .getHomeDirectory().toUri().getPath());\n+      String userHome \u003d DFSUtilClient.getHomeDirectory(conf, ugi).toString();\n+      final String js \u003d JsonUtil.toJsonString(\"Path\", userHome);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d cp.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETECPOLICY: {\n       ErasureCodingPolicy ecpolicy \u003d cp.getErasureCodingPolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(ecpolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSERVERDEFAULTS: {\n       // Since none of the server defaults values are hot reloaded, we can\n       // cache the output of serverDefaults.\n       String serverDefaultsResponse \u003d\n           (String) context.getAttribute(\"serverDefaults\");\n       if (serverDefaultsResponse \u003d\u003d null) {\n         FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n         serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n         context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n       }\n       return Response.ok(serverDefaultsResponse)\n           .type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTDIFF: {\n       SnapshotDiffReport diffReport \u003d\n           cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n               snapshotName.getValue());\n       final String js \u003d JsonUtil.toJsonString(diffReport);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n           cp.getSnapshottableDirListing();\n       final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final SnapshotNameParam snapshotName,\n      final OldSnapshotNameParam oldSnapshotName,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final ClientProtocol cp \u003d getRpcClientProtocol();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      ResponseBuilder rb \u003d Response.noContent();\n      final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n            .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n            .build();\n      }\n    }\n    case GETFILEBLOCKLOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      LocatedBlocks locatedBlocks \u003d getRpcClientProtocol()\n          .getBlockLocations(fullpath, offsetValue, lengthValue !\u003d null ?\n              lengthValue : Long.MAX_VALUE);\n      BlockLocation[] locations \u003d\n          DFSUtilClient.locatedBlocks2Locations(locatedBlocks);\n      final String js \u003d JsonUtil.toJsonString(locations);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      String userHome \u003d DFSUtilClient.getHomeDirectory(conf, ugi).toString();\n      final String js \u003d JsonUtil.toJsonString(\"Path\", userHome);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d cp.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETECPOLICY: {\n      ErasureCodingPolicy ecpolicy \u003d cp.getErasureCodingPolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(ecpolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      String serverDefaultsResponse \u003d\n          (String) context.getAttribute(\"serverDefaults\");\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n        context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTDIFF: {\n      SnapshotDiffReport diffReport \u003d\n          cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n              snapshotName.getValue());\n      final String js \u003d JsonUtil.toJsonString(diffReport);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n          cp.getSnapshottableDirListing();\n      final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "39dc7345b80e27ba8bd1ff4c19ca241aef5ac0fc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14124. EC : Support EC Commands (set/get/unset EcPolicy) via WebHdfs. Contributed by Ayush Saxena.\n",
      "commitDate": "11/12/18 4:29 AM",
      "commitName": "39dc7345b80e27ba8bd1ff4c19ca241aef5ac0fc",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "21/11/18 10:43 AM",
      "commitNameOld": "892b33e054efdcfb6127f20b7468fb08b0e2b8aa",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 19.74,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,215 +1,220 @@\n   protected Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final SnapshotNameParam snapshotName,\n       final OldSnapshotNameParam oldSnapshotName,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final ClientProtocol cp \u003d getRpcClientProtocol();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       ResponseBuilder rb \u003d Response.noContent();\n       final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n             .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n             .build();\n       }\n     }\n     case GETFILEBLOCKLOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       LocatedBlocks locatedBlocks \u003d getRpcClientProtocol()\n           .getBlockLocations(fullpath, offsetValue, lengthValue !\u003d null ?\n               lengthValue : Long.MAX_VALUE);\n       BlockLocation[] locations \u003d\n           DFSUtilClient.locatedBlocks2Locations(locatedBlocks);\n       final String js \u003d JsonUtil.toJsonString(locations);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d cp.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n+    case GETECPOLICY: {\n+      ErasureCodingPolicy ecpolicy \u003d cp.getErasureCodingPolicy(fullpath);\n+      final String js \u003d JsonUtil.toJsonString(ecpolicy);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     case GETSERVERDEFAULTS: {\n       // Since none of the server defaults values are hot reloaded, we can\n       // cache the output of serverDefaults.\n       String serverDefaultsResponse \u003d\n           (String) context.getAttribute(\"serverDefaults\");\n       if (serverDefaultsResponse \u003d\u003d null) {\n         FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n         serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n         context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n       }\n       return Response.ok(serverDefaultsResponse)\n           .type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTDIFF: {\n       SnapshotDiffReport diffReport \u003d\n           cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n               snapshotName.getValue());\n       final String js \u003d JsonUtil.toJsonString(diffReport);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n           cp.getSnapshottableDirListing();\n       final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final SnapshotNameParam snapshotName,\n      final OldSnapshotNameParam oldSnapshotName,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final ClientProtocol cp \u003d getRpcClientProtocol();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      ResponseBuilder rb \u003d Response.noContent();\n      final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n            .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n            .build();\n      }\n    }\n    case GETFILEBLOCKLOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      LocatedBlocks locatedBlocks \u003d getRpcClientProtocol()\n          .getBlockLocations(fullpath, offsetValue, lengthValue !\u003d null ?\n              lengthValue : Long.MAX_VALUE);\n      BlockLocation[] locations \u003d\n          DFSUtilClient.locatedBlocks2Locations(locatedBlocks);\n      final String js \u003d JsonUtil.toJsonString(locations);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d cp.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETECPOLICY: {\n      ErasureCodingPolicy ecpolicy \u003d cp.getErasureCodingPolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(ecpolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      String serverDefaultsResponse \u003d\n          (String) context.getAttribute(\"serverDefaults\");\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n        context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTDIFF: {\n      SnapshotDiffReport diffReport \u003d\n          cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n              snapshotName.getValue());\n      final String js \u003d JsonUtil.toJsonString(diffReport);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n          cp.getSnapshottableDirListing();\n      final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "e7b63baca1e10b28d8b4462fd80537b871951aa3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14070. Refactor NameNodeWebHdfsMethods to allow better extensibility. Contributed by CR Hota\n",
      "commitDate": "12/11/18 11:15 PM",
      "commitName": "e7b63baca1e10b28d8b4462fd80537b871951aa3",
      "commitAuthor": "Brahma Reddy Battula",
      "commitDateOld": "10/10/18 10:11 AM",
      "commitNameOld": "3ead525c71cba068e7abf1c76ad629bfeec10852",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 33.59,
      "commitsBetweenForRepo": 307,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,216 +1,215 @@\n   protected Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final SnapshotNameParam snapshotName,\n       final OldSnapshotNameParam oldSnapshotName,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final ClientProtocol cp \u003d getRpcClientProtocol();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       ResponseBuilder rb \u003d Response.noContent();\n       final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n             .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n             .build();\n       }\n     }\n     case GETFILEBLOCKLOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       LocatedBlocks locatedBlocks \u003d getRpcClientProtocol()\n           .getBlockLocations(fullpath, offsetValue, lengthValue !\u003d null ?\n               lengthValue : Long.MAX_VALUE);\n       BlockLocation[] locations \u003d\n           DFSUtilClient.locatedBlocks2Locations(locatedBlocks);\n       final String js \u003d JsonUtil.toJsonString(locations);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n-      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n-          namenode, ugi, renewer.getValue());\n+          ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d cp.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSERVERDEFAULTS: {\n       // Since none of the server defaults values are hot reloaded, we can\n       // cache the output of serverDefaults.\n       String serverDefaultsResponse \u003d\n           (String) context.getAttribute(\"serverDefaults\");\n       if (serverDefaultsResponse \u003d\u003d null) {\n         FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n         serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n         context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n       }\n       return Response.ok(serverDefaultsResponse)\n           .type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTDIFF: {\n       SnapshotDiffReport diffReport \u003d\n           cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n               snapshotName.getValue());\n       final String js \u003d JsonUtil.toJsonString(diffReport);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n           cp.getSnapshottableDirListing();\n       final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final SnapshotNameParam snapshotName,\n      final OldSnapshotNameParam oldSnapshotName,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final ClientProtocol cp \u003d getRpcClientProtocol();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      ResponseBuilder rb \u003d Response.noContent();\n      final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n            .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n            .build();\n      }\n    }\n    case GETFILEBLOCKLOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      LocatedBlocks locatedBlocks \u003d getRpcClientProtocol()\n          .getBlockLocations(fullpath, offsetValue, lengthValue !\u003d null ?\n              lengthValue : Long.MAX_VALUE);\n      BlockLocation[] locations \u003d\n          DFSUtilClient.locatedBlocks2Locations(locatedBlocks);\n      final String js \u003d JsonUtil.toJsonString(locations);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d cp.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      String serverDefaultsResponse \u003d\n          (String) context.getAttribute(\"serverDefaults\");\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n        context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTDIFF: {\n      SnapshotDiffReport diffReport \u003d\n          cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n              snapshotName.getValue());\n      final String js \u003d JsonUtil.toJsonString(diffReport);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n          cp.getSnapshottableDirListing();\n      final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "3ead525c71cba068e7abf1c76ad629bfeec10852": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12459. Fix revert: Add new op GETFILEBLOCKLOCATIONS to WebHDFS REST API. Contributed by Weiwei Yang.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "10/10/18 10:11 AM",
      "commitName": "3ead525c71cba068e7abf1c76ad629bfeec10852",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "06/09/18 2:48 PM",
      "commitNameOld": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 33.81,
      "commitsBetweenForRepo": 353,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,204 +1,216 @@\n   protected Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final SnapshotNameParam snapshotName,\n       final OldSnapshotNameParam oldSnapshotName,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final ClientProtocol cp \u003d getRpcClientProtocol();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       ResponseBuilder rb \u003d Response.noContent();\n       final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n             .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n             .build();\n       }\n     }\n+    case GETFILEBLOCKLOCATIONS:\n+    {\n+      final long offsetValue \u003d offset.getValue();\n+      final Long lengthValue \u003d length.getValue();\n+      LocatedBlocks locatedBlocks \u003d getRpcClientProtocol()\n+          .getBlockLocations(fullpath, offsetValue, lengthValue !\u003d null ?\n+              lengthValue : Long.MAX_VALUE);\n+      BlockLocation[] locations \u003d\n+          DFSUtilClient.locatedBlocks2Locations(locatedBlocks);\n+      final String js \u003d JsonUtil.toJsonString(locations);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d cp.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSERVERDEFAULTS: {\n       // Since none of the server defaults values are hot reloaded, we can\n       // cache the output of serverDefaults.\n       String serverDefaultsResponse \u003d\n           (String) context.getAttribute(\"serverDefaults\");\n       if (serverDefaultsResponse \u003d\u003d null) {\n         FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n         serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n         context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n       }\n       return Response.ok(serverDefaultsResponse)\n           .type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTDIFF: {\n       SnapshotDiffReport diffReport \u003d\n           cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n               snapshotName.getValue());\n       final String js \u003d JsonUtil.toJsonString(diffReport);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n           cp.getSnapshottableDirListing();\n       final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final SnapshotNameParam snapshotName,\n      final OldSnapshotNameParam oldSnapshotName,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final ClientProtocol cp \u003d getRpcClientProtocol();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      ResponseBuilder rb \u003d Response.noContent();\n      final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n            .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n            .build();\n      }\n    }\n    case GETFILEBLOCKLOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      LocatedBlocks locatedBlocks \u003d getRpcClientProtocol()\n          .getBlockLocations(fullpath, offsetValue, lengthValue !\u003d null ?\n              lengthValue : Long.MAX_VALUE);\n      BlockLocation[] locations \u003d\n          DFSUtilClient.locatedBlocks2Locations(locatedBlocks);\n      final String js \u003d JsonUtil.toJsonString(locations);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d cp.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      String serverDefaultsResponse \u003d\n          (String) context.getAttribute(\"serverDefaults\");\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n        context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTDIFF: {\n      SnapshotDiffReport diffReport \u003d\n          cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n              snapshotName.getValue());\n      final String js \u003d JsonUtil.toJsonString(diffReport);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n          cp.getSnapshottableDirListing();\n      final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "6e31a090842f8aeedb331b653b075499f8df6c60": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-12512. RBF: Add WebHDFS.\n",
      "commitDate": "23/03/18 8:32 AM",
      "commitName": "6e31a090842f8aeedb331b653b075499f8df6c60",
      "commitAuthor": "weiy",
      "commitDateOld": "12/03/18 8:41 PM",
      "commitNameOld": "0355ec20ebeb988679c7192c7024bef7a2a3bced",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 10.49,
      "commitsBetweenForRepo": 212,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,204 +1,204 @@\n-  private Response get(\n+  protected Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final SnapshotNameParam snapshotName,\n       final OldSnapshotNameParam oldSnapshotName,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final ClientProtocol cp \u003d getRpcClientProtocol();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       ResponseBuilder rb \u003d Response.noContent();\n       final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n             .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n             .build();\n       }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d cp.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSERVERDEFAULTS: {\n       // Since none of the server defaults values are hot reloaded, we can\n       // cache the output of serverDefaults.\n       String serverDefaultsResponse \u003d\n           (String) context.getAttribute(\"serverDefaults\");\n       if (serverDefaultsResponse \u003d\u003d null) {\n         FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n         serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n         context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n       }\n       return Response.ok(serverDefaultsResponse)\n           .type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTDIFF: {\n       SnapshotDiffReport diffReport \u003d\n           cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n               snapshotName.getValue());\n       final String js \u003d JsonUtil.toJsonString(diffReport);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n           cp.getSnapshottableDirListing();\n       final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final SnapshotNameParam snapshotName,\n      final OldSnapshotNameParam oldSnapshotName,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final ClientProtocol cp \u003d getRpcClientProtocol();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      ResponseBuilder rb \u003d Response.noContent();\n      final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n            .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n            .build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d cp.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      String serverDefaultsResponse \u003d\n          (String) context.getAttribute(\"serverDefaults\");\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n        context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTDIFF: {\n      SnapshotDiffReport diffReport \u003d\n          cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n              snapshotName.getValue());\n      final String js \u003d JsonUtil.toJsonString(diffReport);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n          cp.getSnapshottableDirListing();\n      final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[protected]"
      }
    },
    "0355ec20ebeb988679c7192c7024bef7a2a3bced": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13141. WebHDFS: Add support for getting snasphottable directory list. Contributed by Lokesh Jain.\n",
      "commitDate": "12/03/18 8:41 PM",
      "commitName": "0355ec20ebeb988679c7192c7024bef7a2a3bced",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "07/03/18 12:33 PM",
      "commitNameOld": "46d29e3d7ee8dc9bb1818b886d9cc5336b1d67a4",
      "commitAuthorOld": "Sean Mackrory",
      "daysBetweenCommits": 5.3,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,198 +1,204 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final SnapshotNameParam snapshotName,\n       final OldSnapshotNameParam oldSnapshotName,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final ClientProtocol cp \u003d getRpcClientProtocol();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       ResponseBuilder rb \u003d Response.noContent();\n       final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n             .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n             .build();\n       }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d cp.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSERVERDEFAULTS: {\n       // Since none of the server defaults values are hot reloaded, we can\n       // cache the output of serverDefaults.\n       String serverDefaultsResponse \u003d\n           (String) context.getAttribute(\"serverDefaults\");\n       if (serverDefaultsResponse \u003d\u003d null) {\n         FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n         serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n         context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n       }\n       return Response.ok(serverDefaultsResponse)\n           .type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSNAPSHOTDIFF: {\n       SnapshotDiffReport diffReport \u003d\n           cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n               snapshotName.getValue());\n       final String js \u003d JsonUtil.toJsonString(diffReport);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n+    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n+      SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n+          cp.getSnapshottableDirListing();\n+      final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final SnapshotNameParam snapshotName,\n      final OldSnapshotNameParam oldSnapshotName,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final ClientProtocol cp \u003d getRpcClientProtocol();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      ResponseBuilder rb \u003d Response.noContent();\n      final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n            .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n            .build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d cp.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      String serverDefaultsResponse \u003d\n          (String) context.getAttribute(\"serverDefaults\");\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n        context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTDIFF: {\n      SnapshotDiffReport diffReport \u003d\n          cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n              snapshotName.getValue());\n      final String js \u003d JsonUtil.toJsonString(diffReport);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      SnapshottableDirectoryStatus[] snapshottableDirectoryList \u003d\n          cp.getSnapshottableDirListing();\n      final String js \u003d JsonUtil.toJsonString(snapshottableDirectoryList);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "1e84e46f1621fe694f806bfc41d3b2a06c9500b6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-13052. WebHDFS: Add support for snasphot diff. Contributed by Lokesh Jain.\n",
      "commitDate": "23/02/18 7:35 PM",
      "commitName": "1e84e46f1621fe694f806bfc41d3b2a06c9500b6",
      "commitAuthor": "Xiaoyu Yao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-13052. WebHDFS: Add support for snasphot diff. Contributed by Lokesh Jain.\n",
          "commitDate": "23/02/18 7:35 PM",
          "commitName": "1e84e46f1621fe694f806bfc41d3b2a06c9500b6",
          "commitAuthor": "Xiaoyu Yao",
          "commitDateOld": "29/01/18 3:23 PM",
          "commitNameOld": "fde95d463c3123b315b3d07cb5b7b7dc19f7cb73",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 25.17,
          "commitsBetweenForRepo": 175,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,189 +1,198 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n+      final SnapshotNameParam snapshotName,\n+      final OldSnapshotNameParam oldSnapshotName,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final ClientProtocol cp \u003d getRpcClientProtocol();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       ResponseBuilder rb \u003d Response.noContent();\n       final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n             .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n             .build();\n       }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d cp.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSERVERDEFAULTS: {\n       // Since none of the server defaults values are hot reloaded, we can\n       // cache the output of serverDefaults.\n       String serverDefaultsResponse \u003d\n           (String) context.getAttribute(\"serverDefaults\");\n       if (serverDefaultsResponse \u003d\u003d null) {\n         FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n         serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n         context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n       }\n       return Response.ok(serverDefaultsResponse)\n           .type(MediaType.APPLICATION_JSON).build();\n     }\n+    case GETSNAPSHOTDIFF: {\n+      SnapshotDiffReport diffReport \u003d\n+          cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n+              snapshotName.getValue());\n+      final String js \u003d JsonUtil.toJsonString(diffReport);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final SnapshotNameParam snapshotName,\n      final OldSnapshotNameParam oldSnapshotName,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final ClientProtocol cp \u003d getRpcClientProtocol();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      ResponseBuilder rb \u003d Response.noContent();\n      final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n            .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n            .build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d cp.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      String serverDefaultsResponse \u003d\n          (String) context.getAttribute(\"serverDefaults\");\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n        context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTDIFF: {\n      SnapshotDiffReport diffReport \u003d\n          cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n              snapshotName.getValue());\n      final String js \u003d JsonUtil.toJsonString(diffReport);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {
            "oldValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final), excludeDatanodes-ExcludeDatanodesParam(modifiers-final), fsAction-FsActionParam(modifiers-final), tokenKind-TokenKindParam(modifiers-final), tokenService-TokenServiceParam(modifiers-final), noredirectParam-NoRedirectParam(modifiers-final), startAfter-StartAfterParam(modifiers-final)]",
            "newValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final), excludeDatanodes-ExcludeDatanodesParam(modifiers-final), fsAction-FsActionParam(modifiers-final), snapshotName-SnapshotNameParam(modifiers-final), oldSnapshotName-OldSnapshotNameParam(modifiers-final), tokenKind-TokenKindParam(modifiers-final), tokenService-TokenServiceParam(modifiers-final), noredirectParam-NoRedirectParam(modifiers-final), startAfter-StartAfterParam(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13052. WebHDFS: Add support for snasphot diff. Contributed by Lokesh Jain.\n",
          "commitDate": "23/02/18 7:35 PM",
          "commitName": "1e84e46f1621fe694f806bfc41d3b2a06c9500b6",
          "commitAuthor": "Xiaoyu Yao",
          "commitDateOld": "29/01/18 3:23 PM",
          "commitNameOld": "fde95d463c3123b315b3d07cb5b7b7dc19f7cb73",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 25.17,
          "commitsBetweenForRepo": 175,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,189 +1,198 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n+      final SnapshotNameParam snapshotName,\n+      final OldSnapshotNameParam oldSnapshotName,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final ClientProtocol cp \u003d getRpcClientProtocol();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       ResponseBuilder rb \u003d Response.noContent();\n       final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n             .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n             .build();\n       }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d cp.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSERVERDEFAULTS: {\n       // Since none of the server defaults values are hot reloaded, we can\n       // cache the output of serverDefaults.\n       String serverDefaultsResponse \u003d\n           (String) context.getAttribute(\"serverDefaults\");\n       if (serverDefaultsResponse \u003d\u003d null) {\n         FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n         serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n         context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n       }\n       return Response.ok(serverDefaultsResponse)\n           .type(MediaType.APPLICATION_JSON).build();\n     }\n+    case GETSNAPSHOTDIFF: {\n+      SnapshotDiffReport diffReport \u003d\n+          cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n+              snapshotName.getValue());\n+      final String js \u003d JsonUtil.toJsonString(diffReport);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final SnapshotNameParam snapshotName,\n      final OldSnapshotNameParam oldSnapshotName,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final ClientProtocol cp \u003d getRpcClientProtocol();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      ResponseBuilder rb \u003d Response.noContent();\n      final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n            .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n            .build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d cp.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      String serverDefaultsResponse \u003d\n          (String) context.getAttribute(\"serverDefaults\");\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n        context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSNAPSHOTDIFF: {\n      SnapshotDiffReport diffReport \u003d\n          cp.getSnapshotDiffReport(fullpath, oldSnapshotName.getValue(),\n              snapshotName.getValue());\n      final String js \u003d JsonUtil.toJsonString(diffReport);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {}
        }
      ]
    },
    "fde95d463c3123b315b3d07cb5b7b7dc19f7cb73": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12574. Add CryptoInputStream to WebHdfsFileSystem read call. Contributed by Rushabh S Shah\n",
      "commitDate": "29/01/18 3:23 PM",
      "commitName": "fde95d463c3123b315b3d07cb5b7b7dc19f7cb73",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "08/01/18 2:25 PM",
      "commitNameOld": "2ee0d64aceed876f57f09eb9efe1872b6de98d2e",
      "commitAuthorOld": "Wei Yan",
      "daysBetweenCommits": 21.04,
      "commitsBetweenForRepo": 117,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,184 +1,189 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final ClientProtocol cp \u003d getRpcClientProtocol();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n-      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n+      ResponseBuilder rb \u003d Response.noContent();\n+      final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n-        return Response.temporaryRedirect(uri)\n-          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n+        return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n+            .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n-        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+        return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n+            .build();\n       }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n-      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n-          fullpath, op.getValue(), -1L, -1L, null);\n+      final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n+          doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d cp.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSERVERDEFAULTS: {\n       // Since none of the server defaults values are hot reloaded, we can\n       // cache the output of serverDefaults.\n+      String serverDefaultsResponse \u003d\n+          (String) context.getAttribute(\"serverDefaults\");\n       if (serverDefaultsResponse \u003d\u003d null) {\n         FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n         serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n+        context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n       }\n       return Response.ok(serverDefaultsResponse)\n           .type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final ClientProtocol cp \u003d getRpcClientProtocol();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      ResponseBuilder rb \u003d Response.noContent();\n      final URI uri \u003d redirectURI(rb, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return rb.status(Status.TEMPORARY_REDIRECT).location(uri)\n            .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return rb.status(Status.OK).entity(js).type(MediaType.APPLICATION_JSON)\n            .build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(null, namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d cp.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      String serverDefaultsResponse \u003d\n          (String) context.getAttribute(\"serverDefaults\");\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n        context.setAttribute(\"serverDefaults\", serverDefaultsResponse);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "2ee0d64aceed876f57f09eb9efe1872b6de98d2e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12945. Switch to ClientProtocol instead of NamenodeProtocols in NamenodeWebHdfsMethods. Contributed by Wei Yan.\n",
      "commitDate": "08/01/18 2:25 PM",
      "commitName": "2ee0d64aceed876f57f09eb9efe1872b6de98d2e",
      "commitAuthor": "Wei Yan",
      "commitDateOld": "26/09/17 1:15 PM",
      "commitNameOld": "0da29cbeea40cb7839abcd72566b997962829329",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 104.09,
      "commitsBetweenForRepo": 716,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,182 +1,184 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n-    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n-    final NamenodeProtocols np \u003d getRPCServer(namenode);\n+    final ClientProtocol cp \u003d getRpcClientProtocol();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n+      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n-      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n+      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n-      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n+      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n-      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n+      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n-      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n+      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n+      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n+      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n-      AclStatus status \u003d np.getAclStatus(fullpath);\n+      AclStatus status \u003d cp.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n-      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n+      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n-      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n+      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n-      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n+      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n-      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n+      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n-      BlockStoragePolicy[] storagePolicies \u003d np.getStoragePolicies();\n+      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n-      BlockStoragePolicy storagePolicy \u003d np.getStoragePolicy(fullpath);\n+      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSERVERDEFAULTS: {\n       // Since none of the server defaults values are hot reloaded, we can\n       // cache the output of serverDefaults.\n       if (serverDefaultsResponse \u003d\u003d null) {\n-        FsServerDefaults serverDefaults \u003d np.getServerDefaults();\n+        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n         serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n       }\n       return Response.ok(serverDefaultsResponse)\n           .type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final ClientProtocol cp \u003d getRpcClientProtocol();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d cp.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d cp.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(cp, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d cp.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d cp.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d cp.getXAttrs(fullpath, (names !\u003d null \u0026\u0026\n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d cp.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      cp.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(cp, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d cp.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d cp.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d cp.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "0da29cbeea40cb7839abcd72566b997962829329": {
      "type": "Ybodychange",
      "commitMessage": "[HDFS-12386] Add fsserver defaults call to WebhdfsFileSystem. (Rushabh Shah via daryn)\n",
      "commitDate": "26/09/17 1:15 PM",
      "commitName": "0da29cbeea40cb7839abcd72566b997962829329",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "14/09/17 3:12 PM",
      "commitNameOld": "390c2b5df0c4e25a2156d8daefd4670efe82b191",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 11.92,
      "commitsBetweenForRepo": 99,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,172 +1,182 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d np.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d np.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n+    case GETSERVERDEFAULTS: {\n+      // Since none of the server defaults values are hot reloaded, we can\n+      // cache the output of serverDefaults.\n+      if (serverDefaultsResponse \u003d\u003d null) {\n+        FsServerDefaults serverDefaults \u003d np.getServerDefaults();\n+        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n+      }\n+      return Response.ok(serverDefaultsResponse)\n+          .type(MediaType.APPLICATION_JSON).build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d np.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d np.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSERVERDEFAULTS: {\n      // Since none of the server defaults values are hot reloaded, we can\n      // cache the output of serverDefaults.\n      if (serverDefaultsResponse \u003d\u003d null) {\n        FsServerDefaults serverDefaults \u003d np.getServerDefaults();\n        serverDefaultsResponse \u003d JsonUtil.toJsonString(serverDefaults);\n      }\n      return Response.ok(serverDefaultsResponse)\n          .type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "390c2b5df0c4e25a2156d8daefd4670efe82b191": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-11156. Add new op GETFILEBLOCKLOCATIONS to WebHDFS REST API. Contributed by Weiwei Yang.\"\n\nThis reverts commit 7fcc73fc0d248aae1edbd4e1514c5818f6198928.\n\n Conflicts:\n\thadoop-hdfs-project/hadoop-hdfs/src/site/markdown/WebHDFS.md\n\thadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/web/TestWebHDFS.java\n",
      "commitDate": "14/09/17 3:12 PM",
      "commitName": "390c2b5df0c4e25a2156d8daefd4670efe82b191",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "03/01/17 9:58 AM",
      "commitNameOld": "7fcc73fc0d248aae1edbd4e1514c5818f6198928",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 254.18,
      "commitsBetweenForRepo": 1568,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,187 +1,172 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n-    case GETFILEBLOCKLOCATIONS:\n-    {\n-      final long offsetValue \u003d offset.getValue();\n-      final Long lengthValue \u003d length.getValue();\n-\n-      FileSystem fs \u003d FileSystem.get(conf !\u003d null ?\n-          conf : new Configuration());\n-      BlockLocation[] locations \u003d fs.getFileBlockLocations(\n-          new org.apache.hadoop.fs.Path(fullpath),\n-          offsetValue,\n-          lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n-      final String js \u003d JsonUtil.toJsonString(\"BlockLocations\",\n-          JsonUtil.toJsonMap(locations));\n-      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n-    }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d np.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d np.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d np.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d np.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "7fcc73fc0d248aae1edbd4e1514c5818f6198928": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11156. Add new op GETFILEBLOCKLOCATIONS to WebHDFS REST API. Contributed by Weiwei Yang.\n",
      "commitDate": "03/01/17 9:58 AM",
      "commitName": "7fcc73fc0d248aae1edbd4e1514c5818f6198928",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "07/12/16 3:52 PM",
      "commitNameOld": "ea2895f4ed5031809d856faa52e9de5b9501bdea",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 26.75,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,172 +1,187 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n+    case GETFILEBLOCKLOCATIONS:\n+    {\n+      final long offsetValue \u003d offset.getValue();\n+      final Long lengthValue \u003d length.getValue();\n+\n+      FileSystem fs \u003d FileSystem.get(conf !\u003d null ?\n+          conf : new Configuration());\n+      BlockLocation[] locations \u003d fs.getFileBlockLocations(\n+          new org.apache.hadoop.fs.Path(fullpath),\n+          offsetValue,\n+          lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n+      final String js \u003d JsonUtil.toJsonString(\"BlockLocations\",\n+          JsonUtil.toJsonMap(locations));\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETALLSTORAGEPOLICY: {\n       BlockStoragePolicy[] storagePolicies \u003d np.getStoragePolicies();\n       final String js \u003d JsonUtil.toJsonString(storagePolicies);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETSTORAGEPOLICY: {\n       BlockStoragePolicy storagePolicy \u003d np.getStoragePolicy(fullpath);\n       final String js \u003d JsonUtil.toJsonString(storagePolicy);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETFILEBLOCKLOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n\n      FileSystem fs \u003d FileSystem.get(conf !\u003d null ?\n          conf : new Configuration());\n      BlockLocation[] locations \u003d fs.getFileBlockLocations(\n          new org.apache.hadoop.fs.Path(fullpath),\n          offsetValue,\n          lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(\"BlockLocations\",\n          JsonUtil.toJsonMap(locations));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d np.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d np.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "ea2895f4ed5031809d856faa52e9de5b9501bdea": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8630. WebHDFS : Support get/set/unset StoragePolicy. Contributed by Surendra Singh Lilhore.\n",
      "commitDate": "07/12/16 3:52 PM",
      "commitName": "ea2895f4ed5031809d856faa52e9de5b9501bdea",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "05/12/16 11:09 PM",
      "commitNameOld": "08a7253bc0eb6c9155457feecb9c5cdc17c3a814",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 1.7,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,162 +1,172 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n+    case GETALLSTORAGEPOLICY: {\n+      BlockStoragePolicy[] storagePolicies \u003d np.getStoragePolicies();\n+      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n+    case GETSTORAGEPOLICY: {\n+      BlockStoragePolicy storagePolicy \u003d np.getStoragePolicy(fullpath);\n+      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETALLSTORAGEPOLICY: {\n      BlockStoragePolicy[] storagePolicies \u003d np.getStoragePolicies();\n      final String js \u003d JsonUtil.toJsonString(storagePolicies);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETSTORAGEPOLICY: {\n      BlockStoragePolicy storagePolicy \u003d np.getStoragePolicy(fullpath);\n      final String js \u003d JsonUtil.toJsonString(storagePolicy);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "08a7253bc0eb6c9155457feecb9c5cdc17c3a814": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-11156. Add new op GETFILEBLOCKLOCATIONS to WebHDFS REST API. Contributed by Weiwei Yang\"\n\nThis reverts commit c7ff34f8dcca3a2024230c5383abd9299daa1b20.\n",
      "commitDate": "05/12/16 11:09 PM",
      "commitName": "08a7253bc0eb6c9155457feecb9c5cdc17c3a814",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "05/12/16 10:54 AM",
      "commitNameOld": "1b5cceaffbdde50a87ede81552dc380832db8e79",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 0.51,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,178 +1,162 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n-    case GETFILEBLOCKLOCATIONS:\n-    {\n-      final long offsetValue \u003d offset.getValue();\n-      final Long lengthValue \u003d length.getValue();\n-\n-      try (final FileSystem fs \u003d FileSystem.get(conf !\u003d null ?\n-          conf : new Configuration())) {\n-        BlockLocation[] locations \u003d fs.getFileBlockLocations(\n-            new org.apache.hadoop.fs.Path(fullpath),\n-            offsetValue,\n-            lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n-        final String js \u003d JsonUtil.toJsonString(\"BlockLocations\",\n-            JsonUtil.toJsonArray(locations));\n-        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n-      }\n-    }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "c7ff34f8dcca3a2024230c5383abd9299daa1b20": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11156. Add new op GETFILEBLOCKLOCATIONS to WebHDFS REST API. Contributed by Weiwei Yang\n",
      "commitDate": "02/12/16 11:10 AM",
      "commitName": "c7ff34f8dcca3a2024230c5383abd9299daa1b20",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "10/11/16 3:21 AM",
      "commitNameOld": "ca68f9cb5bc78e996c0daf8024cf0e7a4faef12a",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 22.33,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,162 +1,178 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n+    case GETFILEBLOCKLOCATIONS:\n+    {\n+      final long offsetValue \u003d offset.getValue();\n+      final Long lengthValue \u003d length.getValue();\n+\n+      try (final FileSystem fs \u003d FileSystem.get(conf !\u003d null ?\n+          conf : new Configuration())) {\n+        BlockLocation[] locations \u003d fs.getFileBlockLocations(\n+            new org.apache.hadoop.fs.Path(fullpath),\n+            offsetValue,\n+            lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n+        final String js \u003d JsonUtil.toJsonString(\"BlockLocations\",\n+            JsonUtil.toJsonArray(locations));\n+        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      }\n+    }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       validateOpParams(op, fsAction);\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETFILEBLOCKLOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n\n      try (final FileSystem fs \u003d FileSystem.get(conf !\u003d null ?\n          conf : new Configuration())) {\n        BlockLocation[] locations \u003d fs.getFileBlockLocations(\n            new org.apache.hadoop.fs.Path(fullpath),\n            offsetValue,\n            lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n        final String js \u003d JsonUtil.toJsonString(\"BlockLocations\",\n            JsonUtil.toJsonArray(locations));\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "ca68f9cb5bc78e996c0daf8024cf0e7a4faef12a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9337. Validate required params for WebHDFS requests (Contributed by Jagadesh Kiran N)\n",
      "commitDate": "10/11/16 3:21 AM",
      "commitName": "ca68f9cb5bc78e996c0daf8024cf0e7a4faef12a",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "04/11/16 6:06 PM",
      "commitNameOld": "d8bab3dcb693b2773ede9a6e4f71ae85ee056f79",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 5.43,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,160 +1,162 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n+      validateOpParams(op, xattrEncoding);\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n+      validateOpParams(op, fsAction);\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     case GETTRASHROOT: {\n       final String trashPath \u003d getTrashRoot(fullpath, conf);\n       final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n       return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      validateOpParams(op, xattrEncoding);\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      validateOpParams(op, fsAction);\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "d8bab3dcb693b2773ede9a6e4f71ae85ee056f79": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10756. Expose getTrashRoot to HTTPFS and WebHDFS. Contributed by Yuanbo Liu.\n",
      "commitDate": "04/11/16 6:06 PM",
      "commitName": "d8bab3dcb693b2773ede9a6e4f71ae85ee056f79",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "27/10/16 4:09 PM",
      "commitNameOld": "5877f20f9c3f6f0afa505715e9a2ee312475af17",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 8.08,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,155 +1,160 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n       final NoRedirectParam noredirectParam,\n       final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n+    case GETTRASHROOT: {\n+      final String trashPath \u003d getTrashRoot(fullpath, conf);\n+      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n+      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n+    }\n     case LISTSTATUS_BATCH:\n     {\n       byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n       if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n         start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n       }\n       final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n       final String js \u003d JsonUtil.toJsonString(listing);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case GETTRASHROOT: {\n      final String trashPath \u003d getTrashRoot(fullpath, conf);\n      final String jsonStr \u003d JsonUtil.toJsonString(\"Path\", trashPath);\n      return Response.ok(jsonStr).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "85bab5fb572194fda38854f1f21c670925058009": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10784. Implement WebHdfsFileSystem#listStatusIterator.\n",
      "commitDate": "31/08/16 2:29 PM",
      "commitName": "85bab5fb572194fda38854f1f21c670925058009",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10784. Implement WebHdfsFileSystem#listStatusIterator.\n",
          "commitDate": "31/08/16 2:29 PM",
          "commitName": "85bab5fb572194fda38854f1f21c670925058009",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "28/06/16 1:55 PM",
          "commitNameOld": "c0829f449337b78ac0b995e216f7324843e74dd2",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 64.02,
          "commitsBetweenForRepo": 534,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,144 +1,155 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n-      final NoRedirectParam noredirectParam\n+      final NoRedirectParam noredirectParam,\n+      final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n+    case LISTSTATUS_BATCH:\n+    {\n+      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n+      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n+        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n+      }\n+      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n+      final String js \u003d JsonUtil.toJsonString(listing);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {
            "oldValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final), excludeDatanodes-ExcludeDatanodesParam(modifiers-final), fsAction-FsActionParam(modifiers-final), tokenKind-TokenKindParam(modifiers-final), tokenService-TokenServiceParam(modifiers-final), noredirectParam-NoRedirectParam(modifiers-final)]",
            "newValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final), excludeDatanodes-ExcludeDatanodesParam(modifiers-final), fsAction-FsActionParam(modifiers-final), tokenKind-TokenKindParam(modifiers-final), tokenService-TokenServiceParam(modifiers-final), noredirectParam-NoRedirectParam(modifiers-final), startAfter-StartAfterParam(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10784. Implement WebHdfsFileSystem#listStatusIterator.\n",
          "commitDate": "31/08/16 2:29 PM",
          "commitName": "85bab5fb572194fda38854f1f21c670925058009",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "28/06/16 1:55 PM",
          "commitNameOld": "c0829f449337b78ac0b995e216f7324843e74dd2",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 64.02,
          "commitsBetweenForRepo": 534,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,144 +1,155 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService,\n-      final NoRedirectParam noredirectParam\n+      final NoRedirectParam noredirectParam,\n+      final StartAfterParam startAfter\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       if(!noredirectParam.getValue()) {\n         return Response.temporaryRedirect(uri)\n           .type(MediaType.APPLICATION_OCTET_STREAM).build();\n       } else {\n         final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n         return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n+    case LISTSTATUS_BATCH:\n+    {\n+      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n+      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n+        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n+      }\n+      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n+      final String js \u003d JsonUtil.toJsonString(listing);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam,\n      final StartAfterParam startAfter\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    case LISTSTATUS_BATCH:\n    {\n      byte[] start \u003d HdfsFileStatus.EMPTY_NAME;\n      if (startAfter !\u003d null \u0026\u0026 startAfter.getValue() !\u003d null) {\n        start \u003d startAfter.getValue().getBytes(Charsets.UTF_8);\n      }\n      final DirectoryListing listing \u003d getDirectoryListing(np, fullpath, start);\n      final String js \u003d JsonUtil.toJsonString(listing);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {}
        }
      ]
    },
    "4b0f55b6ea1665e2118fd573f72a6fcd1fce20d6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7766. Add a flag to WebHDFS op\u003dCREATE to not respond with a 307 redirect (Ravi Prakash via aw)\n",
      "commitDate": "23/05/16 3:52 PM",
      "commitName": "4b0f55b6ea1665e2118fd573f72a6fcd1fce20d6",
      "commitAuthor": "Allen Wittenauer",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7766. Add a flag to WebHDFS op\u003dCREATE to not respond with a 307 redirect (Ravi Prakash via aw)\n",
          "commitDate": "23/05/16 3:52 PM",
          "commitName": "4b0f55b6ea1665e2118fd573f72a6fcd1fce20d6",
          "commitAuthor": "Allen Wittenauer",
          "commitDateOld": "04/05/16 5:02 PM",
          "commitNameOld": "1268cf5fbe4458fa75ad0662512d352f9e8d3470",
          "commitAuthorOld": "Ming Ma",
          "daysBetweenCommits": 18.95,
          "commitsBetweenForRepo": 134,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,131 +1,144 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n-      final TokenServiceParam tokenService\n+      final TokenServiceParam tokenService,\n+      final NoRedirectParam noredirectParam\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n-      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n+      if(!noredirectParam.getValue()) {\n+        return Response.temporaryRedirect(uri)\n+          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n+      } else {\n+        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n+        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n-      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n+      if(!noredirectParam.getValue()) {\n+        return Response.temporaryRedirect(uri)\n+          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n+      } else {\n+        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n+        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {
            "oldValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final), excludeDatanodes-ExcludeDatanodesParam(modifiers-final), fsAction-FsActionParam(modifiers-final), tokenKind-TokenKindParam(modifiers-final), tokenService-TokenServiceParam(modifiers-final)]",
            "newValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final), excludeDatanodes-ExcludeDatanodesParam(modifiers-final), fsAction-FsActionParam(modifiers-final), tokenKind-TokenKindParam(modifiers-final), tokenService-TokenServiceParam(modifiers-final), noredirectParam-NoRedirectParam(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7766. Add a flag to WebHDFS op\u003dCREATE to not respond with a 307 redirect (Ravi Prakash via aw)\n",
          "commitDate": "23/05/16 3:52 PM",
          "commitName": "4b0f55b6ea1665e2118fd573f72a6fcd1fce20d6",
          "commitAuthor": "Allen Wittenauer",
          "commitDateOld": "04/05/16 5:02 PM",
          "commitNameOld": "1268cf5fbe4458fa75ad0662512d352f9e8d3470",
          "commitAuthorOld": "Ming Ma",
          "daysBetweenCommits": 18.95,
          "commitsBetweenForRepo": 134,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,131 +1,144 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n-      final TokenServiceParam tokenService\n+      final TokenServiceParam tokenService,\n+      final NoRedirectParam noredirectParam\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n-      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n+      if(!noredirectParam.getValue()) {\n+        return Response.temporaryRedirect(uri)\n+          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n+      } else {\n+        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n+        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      }\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n-      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n+      if(!noredirectParam.getValue()) {\n+        return Response.temporaryRedirect(uri)\n+          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n+      } else {\n+        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n+        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      }\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService,\n      final NoRedirectParam noredirectParam\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      if(!noredirectParam.getValue()) {\n        return Response.temporaryRedirect(uri)\n          .type(MediaType.APPLICATION_OCTET_STREAM).build();\n      } else {\n        final String js \u003d JsonUtil.toJsonString(\"Location\", uri);\n        return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      }\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {}
        }
      ]
    },
    "576b569b6c97bd5f57e52efdabdf8c2fa996a524": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9525. hadoop utilities need to support provided delegation tokens (HeeSoo Kim via aw)\"\n\nThis reverts commit 832b3cbde1c2f77b04c93188e3a94420974090cf.\n",
      "commitDate": "11/12/15 10:59 AM",
      "commitName": "576b569b6c97bd5f57e52efdabdf8c2fa996a524",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "08/12/15 12:56 PM",
      "commitNameOld": "832b3cbde1c2f77b04c93188e3a94420974090cf",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 2.92,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,131 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n+      if (delegation.getValue() !\u003d null) {\n+        throw new IllegalArgumentException(delegation.getName()\n+            + \" parameter is not null.\");\n+      }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "832b3cbde1c2f77b04c93188e3a94420974090cf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9525. hadoop utilities need to support provided delegation tokens (HeeSoo Kim via aw)\n",
      "commitDate": "08/12/15 12:56 PM",
      "commitName": "832b3cbde1c2f77b04c93188e3a94420974090cf",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "08/11/15 2:54 AM",
      "commitNameOld": "6d2332ae375e26d024358c6e75fdb3c68a781a66",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 30.42,
      "commitsBetweenForRepo": 188,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,127 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final Configuration conf \u003d (Configuration) context\n         .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n-      if (delegation.getValue() !\u003d null) {\n-        throw new IllegalArgumentException(delegation.getName()\n-            + \" parameter is not null.\");\n-      }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY: {\n       final String js \u003d JsonUtil.toJsonString(\"Path\",\n           FileSystem.get(conf !\u003d null ? conf : new Configuration())\n               .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "fac4e04dd359a7ff31f286d664fb06f019ec0b58": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8542. WebHDFS getHomeDirectory behavior does not match specification. Contributed by  Kanaka Kumar Avvaru.\n",
      "commitDate": "22/06/15 4:30 PM",
      "commitName": "fac4e04dd359a7ff31f286d664fb06f019ec0b58",
      "commitAuthor": "Jakob Homan",
      "commitDateOld": "04/05/15 11:35 AM",
      "commitNameOld": "c4578760b67d5b5169949a1b059f4472a268ff1b",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 49.21,
      "commitsBetweenForRepo": 452,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,131 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n       final FsActionParam fsAction,\n       final TokenKindParam tokenKind,\n       final TokenServiceParam tokenService\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n+    final Configuration conf \u003d (Configuration) context\n+        .getAttribute(JspHelper.CURRENT_CONF);\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n \n       final String setServiceName \u003d tokenService.getValue();\n       final String setKind \u003d tokenKind.getValue();\n       if (setServiceName !\u003d null) {\n         token.setService(new Text(setServiceName));\n       }\n       if (setKind !\u003d null) {\n         token.setKind(new Text(setKind));\n       }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n-    case GETHOMEDIRECTORY:\n-    {\n-      final String js \u003d JsonUtil.toJsonString(\n-          org.apache.hadoop.fs.Path.class.getSimpleName(),\n-          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n+    case GETHOMEDIRECTORY: {\n+      final String js \u003d JsonUtil.toJsonString(\"Path\",\n+          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n+              .getHomeDirectory().toUri().getPath());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final Configuration conf \u003d (Configuration) context\n        .getAttribute(JspHelper.CURRENT_CONF);\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY: {\n      final String js \u003d JsonUtil.toJsonString(\"Path\",\n          FileSystem.get(conf !\u003d null ? conf : new Configuration())\n              .getHomeDirectory().toUri().getPath());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "e2be3337448ec0f6772a2ba463da376e7089b1fa": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6904. YARN unable to renew delegation token fetched via webhdfs due to incorrect service port.\n",
      "commitDate": "24/10/14 11:35 AM",
      "commitName": "e2be3337448ec0f6772a2ba463da376e7089b1fa",
      "commitAuthor": "Jitendra Pandey",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6904. YARN unable to renew delegation token fetched via webhdfs due to incorrect service port.\n",
          "commitDate": "24/10/14 11:35 AM",
          "commitName": "e2be3337448ec0f6772a2ba463da376e7089b1fa",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "11/09/14 12:23 AM",
          "commitNameOld": "70dfe9cfab73fc1ff0ed4dd37027a77b19ac3104",
          "commitAuthorOld": "",
          "daysBetweenCommits": 43.47,
          "commitsBetweenForRepo": 438,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,119 +1,130 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n-      final FsActionParam fsAction\n+      final FsActionParam fsAction,\n+      final TokenKindParam tokenKind,\n+      final TokenServiceParam tokenService\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n+\n+      final String setServiceName \u003d tokenService.getValue();\n+      final String setKind \u003d tokenKind.getValue();\n+      if (setServiceName !\u003d null) {\n+        token.setService(new Text(setServiceName));\n+      }\n+      if (setKind !\u003d null) {\n+        token.setKind(new Text(setKind));\n+      }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {
            "oldValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final), excludeDatanodes-ExcludeDatanodesParam(modifiers-final), fsAction-FsActionParam(modifiers-final)]",
            "newValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final), excludeDatanodes-ExcludeDatanodesParam(modifiers-final), fsAction-FsActionParam(modifiers-final), tokenKind-TokenKindParam(modifiers-final), tokenService-TokenServiceParam(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6904. YARN unable to renew delegation token fetched via webhdfs due to incorrect service port.\n",
          "commitDate": "24/10/14 11:35 AM",
          "commitName": "e2be3337448ec0f6772a2ba463da376e7089b1fa",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "11/09/14 12:23 AM",
          "commitNameOld": "70dfe9cfab73fc1ff0ed4dd37027a77b19ac3104",
          "commitAuthorOld": "",
          "daysBetweenCommits": 43.47,
          "commitsBetweenForRepo": 438,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,119 +1,130 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n       final ExcludeDatanodesParam excludeDatanodes,\n-      final FsActionParam fsAction\n+      final FsActionParam fsAction,\n+      final TokenKindParam tokenKind,\n+      final TokenServiceParam tokenService\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n+\n+      final String setServiceName \u003d tokenService.getValue();\n+      final String setKind \u003d tokenKind.getValue();\n+      if (setServiceName !\u003d null) {\n+        token.setService(new Text(setServiceName));\n+      }\n+      if (setKind !\u003d null) {\n+        token.setKind(new Text(setKind));\n+      }\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case CHECKACCESS: {\n       np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n       return Response.ok().build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction,\n      final TokenKindParam tokenKind,\n      final TokenServiceParam tokenService\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n\n      final String setServiceName \u003d tokenService.getValue();\n      final String setKind \u003d tokenKind.getValue();\n      if (setServiceName !\u003d null) {\n        token.setService(new Text(setServiceName));\n      }\n      if (setKind !\u003d null) {\n        token.setKind(new Text(setKind));\n      }\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {}
        }
      ]
    },
    "535fe14dedbf919442ec03ac573315c7a16a6dbe": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6570. add api that enables checking if a user has certain permissions on a file. Contributed by Jitendra Pandey.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1614723 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/07/14 10:49 AM",
      "commitName": "535fe14dedbf919442ec03ac573315c7a16a6dbe",
      "commitAuthor": "Chris Nauroth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6570. add api that enables checking if a user has certain permissions on a file. Contributed by Jitendra Pandey.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1614723 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/07/14 10:49 AM",
          "commitName": "535fe14dedbf919442ec03ac573315c7a16a6dbe",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "24/07/14 11:28 AM",
          "commitNameOld": "8c6e172a0ad8f06a4f9b70d61d9f3f7789405815",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 5.97,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,114 +1,119 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n-      final ExcludeDatanodesParam excludeDatanodes\n+      final ExcludeDatanodesParam excludeDatanodes,\n+      final FsActionParam fsAction\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n+    case CHECKACCESS: {\n+      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n+      return Response.ok().build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {
            "oldValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final), excludeDatanodes-ExcludeDatanodesParam(modifiers-final)]",
            "newValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final), excludeDatanodes-ExcludeDatanodesParam(modifiers-final), fsAction-FsActionParam(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6570. add api that enables checking if a user has certain permissions on a file. Contributed by Jitendra Pandey.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1614723 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/07/14 10:49 AM",
          "commitName": "535fe14dedbf919442ec03ac573315c7a16a6dbe",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "24/07/14 11:28 AM",
          "commitNameOld": "8c6e172a0ad8f06a4f9b70d61d9f3f7789405815",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 5.97,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,114 +1,119 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding,\n-      final ExcludeDatanodesParam excludeDatanodes\n+      final ExcludeDatanodesParam excludeDatanodes,\n+      final FsActionParam fsAction\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n           doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n           excludeDatanodes.getValue(), offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L, null);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n+    case CHECKACCESS: {\n+      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n+      return Response.ok().build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes,\n      final FsActionParam fsAction\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case CHECKACCESS: {\n      np.checkAccess(fullpath, FsAction.getFsAction(fsAction.getValue()));\n      return Response.ok().build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {}
        }
      ]
    },
    "7c18f8d55b899dc4a6e118d3b54447a9b36b960a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6616. Add exclude-datanodes feature to WebHDFS redirection so that it will not redirect retries to the same datanode. Contributed by zhaoyunjiong\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611750 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/14 11:20 AM",
      "commitName": "7c18f8d55b899dc4a6e118d3b54447a9b36b960a",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6616. Add exclude-datanodes feature to WebHDFS redirection so that it will not redirect retries to the same datanode. Contributed by zhaoyunjiong\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611750 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/07/14 11:20 AM",
          "commitName": "7c18f8d55b899dc4a6e118d3b54447a9b36b960a",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "05/06/14 8:48 PM",
          "commitNameOld": "6a4f6d6b3e41e660c214b77c9ed43d4c65200b6a",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 42.61,
          "commitsBetweenForRepo": 298,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,112 +1,114 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n-      final XAttrEncodingParam xattrEncoding\n+      final XAttrEncodingParam xattrEncoding,\n+      final ExcludeDatanodesParam excludeDatanodes\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n-      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n-          fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n+      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n+          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n+          excludeDatanodes.getValue(), offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n-          fullpath, op.getValue(), -1L, -1L);\n+          fullpath, op.getValue(), -1L, -1L, null);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {
            "oldValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final)]",
            "newValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final), excludeDatanodes-ExcludeDatanodesParam(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6616. Add exclude-datanodes feature to WebHDFS redirection so that it will not redirect retries to the same datanode. Contributed by zhaoyunjiong\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611750 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/07/14 11:20 AM",
          "commitName": "7c18f8d55b899dc4a6e118d3b54447a9b36b960a",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "05/06/14 8:48 PM",
          "commitNameOld": "6a4f6d6b3e41e660c214b77c9ed43d4c65200b6a",
          "commitAuthorOld": "Uma Maheswara Rao G",
          "daysBetweenCommits": 42.61,
          "commitsBetweenForRepo": 298,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,112 +1,114 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final List\u003cXAttrNameParam\u003e xattrNames,\n-      final XAttrEncodingParam xattrEncoding\n+      final XAttrEncodingParam xattrEncoding,\n+      final ExcludeDatanodesParam excludeDatanodes\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n-      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n-          fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n+      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n+          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n+          excludeDatanodes.getValue(), offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n-          fullpath, op.getValue(), -1L, -1L);\n+          fullpath, op.getValue(), -1L, -1L, null);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e names \u003d null;\n       if (xattrNames !\u003d null) {\n         names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n         for (XAttrNameParam xattrName : xattrNames) {\n           if (xattrName.getXAttrName() !\u003d null) {\n             names.add(xattrName.getXAttrName());\n           }\n         }\n       }\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n           !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding,\n      final ExcludeDatanodesParam excludeDatanodes\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username,\n          doAsUser, fullpath, op.getValue(), offset.getValue(), -1L,\n          excludeDatanodes.getValue(), offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L, null);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {}
        }
      ]
    },
    "6a4f6d6b3e41e660c214b77c9ed43d4c65200b6a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6464. Support multiple xattr.name parameters for WebHDFS getXAttrs. Contributed by Yi Liu.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1600810 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/06/14 8:48 PM",
      "commitName": "6a4f6d6b3e41e660c214b77c9ed43d4c65200b6a",
      "commitAuthor": "Uma Maheswara Rao G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6464. Support multiple xattr.name parameters for WebHDFS getXAttrs. Contributed by Yi Liu.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1600810 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/06/14 8:48 PM",
          "commitName": "6a4f6d6b3e41e660c214b77c9ed43d4c65200b6a",
          "commitAuthor": "Uma Maheswara Rao G",
          "commitDateOld": "30/05/14 5:12 PM",
          "commitNameOld": "880a0c673c74a128a01c72b60695f05327f5e961",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 6.15,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,109 +1,112 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n-      final XAttrNameParam xattrName,\n+      final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n-    case GETXATTR: {\n-      XAttr xAttr \u003d XAttrHelper.getFirstXAttr(np.getXAttrs(fullpath,\n-          XAttrHelper.buildXAttrAsList(xattrName.getXAttrName())));\n-      final String js \u003d JsonUtil.toJsonString(xAttr,\n-          xattrEncoding.getEncoding());\n-      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n-    }\n     case GETXATTRS: {\n-      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, null);\n+      List\u003cString\u003e names \u003d null;\n+      if (xattrNames !\u003d null) {\n+        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n+        for (XAttrNameParam xattrName : xattrNames) {\n+          if (xattrName.getXAttrName() !\u003d null) {\n+            names.add(xattrName.getXAttrName());\n+          }\n+        }\n+      }\n+      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n+          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {
            "oldValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrName-XAttrNameParam(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final)]",
            "newValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrNames-List\u003cXAttrNameParam\u003e(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6464. Support multiple xattr.name parameters for WebHDFS getXAttrs. Contributed by Yi Liu.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1600810 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/06/14 8:48 PM",
          "commitName": "6a4f6d6b3e41e660c214b77c9ed43d4c65200b6a",
          "commitAuthor": "Uma Maheswara Rao G",
          "commitDateOld": "30/05/14 5:12 PM",
          "commitNameOld": "880a0c673c74a128a01c72b60695f05327f5e961",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 6.15,
          "commitsBetweenForRepo": 18,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,109 +1,112 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n-      final XAttrNameParam xattrName,\n+      final List\u003cXAttrNameParam\u003e xattrNames,\n       final XAttrEncodingParam xattrEncoding\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n-    case GETXATTR: {\n-      XAttr xAttr \u003d XAttrHelper.getFirstXAttr(np.getXAttrs(fullpath,\n-          XAttrHelper.buildXAttrAsList(xattrName.getXAttrName())));\n-      final String js \u003d JsonUtil.toJsonString(xAttr,\n-          xattrEncoding.getEncoding());\n-      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n-    }\n     case GETXATTRS: {\n-      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, null);\n+      List\u003cString\u003e names \u003d null;\n+      if (xattrNames !\u003d null) {\n+        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n+        for (XAttrNameParam xattrName : xattrNames) {\n+          if (xattrName.getXAttrName() !\u003d null) {\n+            names.add(xattrName.getXAttrName());\n+          }\n+        }\n+      }\n+      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n+          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTXATTRS: {\n       final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n       final String js \u003d JsonUtil.toJsonString(xAttrs);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final List\u003cXAttrNameParam\u003e xattrNames,\n      final XAttrEncodingParam xattrEncoding\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e names \u003d null;\n      if (xattrNames !\u003d null) {\n        names \u003d Lists.newArrayListWithCapacity(xattrNames.size());\n        for (XAttrNameParam xattrName : xattrNames) {\n          if (xattrName.getXAttrName() !\u003d null) {\n            names.add(xattrName.getXAttrName());\n          }\n        }\n      }\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, (names !\u003d null \u0026\u0026 \n          !names.isEmpty()) ? XAttrHelper.buildXAttrs(names) : null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {}
        }
      ]
    },
    "880a0c673c74a128a01c72b60695f05327f5e961": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6375. Listing extended attributes with the search permission. Contributed by Charles Lamb.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1598788 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/14 5:12 PM",
      "commitName": "880a0c673c74a128a01c72b60695f05327f5e961",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "22/05/14 12:30 AM",
      "commitNameOld": "752a9d84bb3ff7451667de3cfaa74fe7feeecb83",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 8.7,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,109 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize,\n       final XAttrNameParam xattrName,\n       final XAttrEncodingParam xattrEncoding\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTR: {\n       XAttr xAttr \u003d XAttrHelper.getFirstXAttr(np.getXAttrs(fullpath,\n           XAttrHelper.buildXAttrAsList(xattrName.getXAttrName())));\n       final String js \u003d JsonUtil.toJsonString(xAttr,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETXATTRS: {\n       List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, null);\n       final String js \u003d JsonUtil.toJsonString(xAttrs,\n           xattrEncoding.getEncoding());\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n+    case LISTXATTRS: {\n+      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n+      final String js \u003d JsonUtil.toJsonString(xAttrs);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final XAttrNameParam xattrName,\n      final XAttrEncodingParam xattrEncoding\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTR: {\n      XAttr xAttr \u003d XAttrHelper.getFirstXAttr(np.getXAttrs(fullpath,\n          XAttrHelper.buildXAttrAsList(xattrName.getXAttrName())));\n      final String js \u003d JsonUtil.toJsonString(xAttr,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTXATTRS: {\n      final List\u003cXAttr\u003e xAttrs \u003d np.listXAttrs(fullpath);\n      final String js \u003d JsonUtil.toJsonString(xAttrs);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "ac23a55547716df29b3e25c98a113399e184d9d1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "Merge HDFS-2006 HDFS XAttrs branch to Trunk\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596575 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 6:57 AM",
      "commitName": "ac23a55547716df29b3e25c98a113399e184d9d1",
      "commitAuthor": "Uma Maheswara Rao G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "Merge HDFS-2006 HDFS XAttrs branch to Trunk\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596575 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/05/14 6:57 AM",
          "commitName": "ac23a55547716df29b3e25c98a113399e184d9d1",
          "commitAuthor": "Uma Maheswara Rao G",
          "commitDateOld": "20/05/14 10:33 AM",
          "commitNameOld": "44e9d346e974d0d862b2cc7ef406ac9e5a321c17",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 0.85,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,89 +1,104 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n-      final BufferSizeParam bufferSize\n+      final BufferSizeParam bufferSize,\n+      final XAttrNameParam xattrName,\n+      final XAttrEncodingParam xattrEncoding\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n+    case GETXATTR: {\n+      XAttr xAttr \u003d XAttrHelper.getFirstXAttr(np.getXAttrs(fullpath,\n+          XAttrHelper.buildXAttrAsList(xattrName.getXAttrName())));\n+      final String js \u003d JsonUtil.toJsonString(xAttr,\n+          xattrEncoding.getEncoding());\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n+    case GETXATTRS: {\n+      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, null);\n+      final String js \u003d JsonUtil.toJsonString(xAttrs,\n+          xattrEncoding.getEncoding());\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final XAttrNameParam xattrName,\n      final XAttrEncodingParam xattrEncoding\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTR: {\n      XAttr xAttr \u003d XAttrHelper.getFirstXAttr(np.getXAttrs(fullpath,\n          XAttrHelper.buildXAttrAsList(xattrName.getXAttrName())));\n      final String js \u003d JsonUtil.toJsonString(xAttr,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {
            "oldValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final)]",
            "newValue": "[ugi-UserGroupInformation(modifiers-final), delegation-DelegationParam(modifiers-final), username-UserParam(modifiers-final), doAsUser-DoAsParam(modifiers-final), fullpath-String(modifiers-final), op-GetOpParam(modifiers-final), offset-OffsetParam(modifiers-final), length-LengthParam(modifiers-final), renewer-RenewerParam(modifiers-final), bufferSize-BufferSizeParam(modifiers-final), xattrName-XAttrNameParam(modifiers-final), xattrEncoding-XAttrEncodingParam(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Merge HDFS-2006 HDFS XAttrs branch to Trunk\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596575 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "21/05/14 6:57 AM",
          "commitName": "ac23a55547716df29b3e25c98a113399e184d9d1",
          "commitAuthor": "Uma Maheswara Rao G",
          "commitDateOld": "20/05/14 10:33 AM",
          "commitNameOld": "44e9d346e974d0d862b2cc7ef406ac9e5a321c17",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 0.85,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,89 +1,104 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n-      final BufferSizeParam bufferSize\n+      final BufferSizeParam bufferSize,\n+      final XAttrNameParam xattrName,\n+      final XAttrEncodingParam xattrEncoding\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n+    case GETXATTR: {\n+      XAttr xAttr \u003d XAttrHelper.getFirstXAttr(np.getXAttrs(fullpath,\n+          XAttrHelper.buildXAttrAsList(xattrName.getXAttrName())));\n+      final String js \u003d JsonUtil.toJsonString(xAttr,\n+          xattrEncoding.getEncoding());\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n+    case GETXATTRS: {\n+      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, null);\n+      final String js \u003d JsonUtil.toJsonString(xAttrs,\n+          xattrEncoding.getEncoding());\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize,\n      final XAttrNameParam xattrName,\n      final XAttrEncodingParam xattrEncoding\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTR: {\n      XAttr xAttr \u003d XAttrHelper.getFirstXAttr(np.getXAttrs(fullpath,\n          XAttrHelper.buildXAttrAsList(xattrName.getXAttrName())));\n      final String js \u003d JsonUtil.toJsonString(xAttr,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETXATTRS: {\n      List\u003cXAttr\u003e xAttrs \u003d np.getXAttrs(fullpath, null);\n      final String js \u003d JsonUtil.toJsonString(xAttrs,\n          xattrEncoding.getEncoding());\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
          "extendedDetails": {}
        }
      ]
    },
    "b46fbd0275bfc7ec16a219c72cff555d912170d7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5857. TestWebHDFS#testNamenodeRestart fails intermittently with NPE. Contributed By Mit Desai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1574683 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/03/14 1:51 PM",
      "commitName": "b46fbd0275bfc7ec16a219c72cff555d912170d7",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "25/02/14 10:36 AM",
      "commitNameOld": "df6e1ab4916e41810f092474a1f3abd9845d9956",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 8.14,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,89 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n-    final NamenodeProtocols np \u003d namenode.getRpcServer();\n+    final NamenodeProtocols np \u003d getRPCServer(namenode);\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETACLSTATUS: {\n       AclStatus status \u003d np.getAclStatus(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d getRPCServer(namenode);\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "7a03dc0482d28b8d5741f633f305bd3afb7a572b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5608. WebHDFS: implement ACL APIs. Contributed by Sachin Jose and Renil Joseph.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1563013 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/01/14 3:13 PM",
      "commitName": "7a03dc0482d28b8d5741f633f305bd3afb7a572b",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "05/12/13 3:41 PM",
      "commitNameOld": "00718c2ffaa11cbdabac6f5ef4b2de5dcf9d6859",
      "commitAuthorOld": "",
      "daysBetweenCommits": 55.98,
      "commitsBetweenForRepo": 295,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,89 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d namenode.getRpcServer();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n+    case GETACLSTATUS: {\n+      AclStatus status \u003d np.getAclStatus(fullpath);\n+      if (status \u003d\u003d null) {\n+        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n+      }\n+\n+      final String js \u003d JsonUtil.toJsonString(status);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d namenode.getRpcServer();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETACLSTATUS: {\n      AclStatus status \u003d np.getAclStatus(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "8fa10b184e607a33f59e67bd4b1fbe5a2e683941": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7967. Need generalized multi-token filesystem support (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1374271 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/08/12 7:05 AM",
      "commitName": "8fa10b184e607a33f59e67bd4b1fbe5a2e683941",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "26/06/12 7:51 PM",
      "commitNameOld": "bf1649d5fd095ce027f013be57d216212fa14198",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 51.47,
      "commitsBetweenForRepo": 292,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,80 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d namenode.getRpcServer();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n           fullpath, op.getValue(), -1L, -1L);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n-    case GETDELEGATIONTOKENS:\n-    {\n-      if (delegation.getValue() !\u003d null) {\n-        throw new IllegalArgumentException(delegation.getName()\n-            + \" parameter is not null.\");\n-      }\n-      final Token\u003c? extends TokenIdentifier\u003e[] tokens \u003d new Token\u003c?\u003e[1];\n-      tokens[0] \u003d generateDelegationToken(namenode, ugi, renewer.getValue());\n-      final String js \u003d JsonUtil.toJsonString(tokens);\n-      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n-    }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d namenode.getRpcServer();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "bf1649d5fd095ce027f013be57d216212fa14198": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3551. WebHDFS CREATE should use client location for HTTP redirection.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1354316 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/06/12 7:51 PM",
      "commitName": "bf1649d5fd095ce027f013be57d216212fa14198",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "08/06/12 5:54 PM",
      "commitNameOld": "5991ed9cbd18520040159508ef8bd02b7b3bf5e5",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 18.08,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,91 @@\n   private Response get(\n       final UserGroupInformation ugi,\n       final DelegationParam delegation,\n       final UserParam username,\n       final DoAsParam doAsUser,\n       final String fullpath,\n       final GetOpParam op,\n       final OffsetParam offset,\n       final LengthParam length,\n       final RenewerParam renewer,\n       final BufferSizeParam bufferSize\n       ) throws IOException, URISyntaxException {\n     final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n     final NamenodeProtocols np \u003d namenode.getRpcServer();\n \n     switch(op.getValue()) {\n     case OPEN:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n-          fullpath, op.getValue(), offset.getValue(), offset, length, bufferSize);\n+          fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GET_BLOCK_LOCATIONS:\n     {\n       final long offsetValue \u003d offset.getValue();\n       final Long lengthValue \u003d length.getValue();\n       final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n           offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n       final String js \u003d JsonUtil.toJsonString(locatedblocks);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILESTATUS:\n     {\n       final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n       if (status \u003d\u003d null) {\n         throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n       }\n \n       final String js \u003d JsonUtil.toJsonString(status, true);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case LISTSTATUS:\n     {\n       final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n       return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETCONTENTSUMMARY:\n     {\n       final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n       final String js \u003d JsonUtil.toJsonString(contentsummary);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETFILECHECKSUM:\n     {\n       final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n-          fullpath, op.getValue(), -1L);\n+          fullpath, op.getValue(), -1L, -1L);\n       return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n     }\n     case GETDELEGATIONTOKEN:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n           namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(token);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETDELEGATIONTOKENS:\n     {\n       if (delegation.getValue() !\u003d null) {\n         throw new IllegalArgumentException(delegation.getName()\n             + \" parameter is not null.\");\n       }\n       final Token\u003c? extends TokenIdentifier\u003e[] tokens \u003d new Token\u003c?\u003e[1];\n       tokens[0] \u003d generateDelegationToken(namenode, ugi, renewer.getValue());\n       final String js \u003d JsonUtil.toJsonString(tokens);\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     case GETHOMEDIRECTORY:\n     {\n       final String js \u003d JsonUtil.toJsonString(\n           org.apache.hadoop.fs.Path.class.getSimpleName(),\n           WebHdfsFileSystem.getHomeDirectoryString(ugi));\n       return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n     }\n     default:\n       throw new UnsupportedOperationException(op + \" is not supported\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d namenode.getRpcServer();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), offset.getValue(), -1L, offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L, -1L);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETDELEGATIONTOKENS:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e[] tokens \u003d new Token\u003c?\u003e[1];\n      tokens[0] \u003d generateDelegationToken(namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(tokens);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java",
      "extendedDetails": {}
    },
    "eeec4dc72abf4c540146a81c5419828520b80fa4": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3294. Fix code indentation in NamenodeWebHdfsMethods and DatanodeWebHdfsMethods.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1327365 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/04/12 8:25 PM",
      "commitName": "eeec4dc72abf4c540146a81c5419828520b80fa4",
      "commitAuthor": "Tsz-wo Sze",
      "diff": "@@ -0,0 +1,91 @@\n+  private Response get(\n+      final UserGroupInformation ugi,\n+      final DelegationParam delegation,\n+      final UserParam username,\n+      final DoAsParam doAsUser,\n+      final String fullpath,\n+      final GetOpParam op,\n+      final OffsetParam offset,\n+      final LengthParam length,\n+      final RenewerParam renewer,\n+      final BufferSizeParam bufferSize\n+      ) throws IOException, URISyntaxException {\n+    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n+    final NamenodeProtocols np \u003d namenode.getRpcServer();\n+\n+    switch(op.getValue()) {\n+    case OPEN:\n+    {\n+      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n+          fullpath, op.getValue(), offset.getValue(), offset, length, bufferSize);\n+      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n+    }\n+    case GET_BLOCK_LOCATIONS:\n+    {\n+      final long offsetValue \u003d offset.getValue();\n+      final Long lengthValue \u003d length.getValue();\n+      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n+          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n+      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n+    case GETFILESTATUS:\n+    {\n+      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n+      if (status \u003d\u003d null) {\n+        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n+      }\n+\n+      final String js \u003d JsonUtil.toJsonString(status, true);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n+    case LISTSTATUS:\n+    {\n+      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n+      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n+    }\n+    case GETCONTENTSUMMARY:\n+    {\n+      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n+      final String js \u003d JsonUtil.toJsonString(contentsummary);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n+    case GETFILECHECKSUM:\n+    {\n+      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n+          fullpath, op.getValue(), -1L);\n+      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n+    }\n+    case GETDELEGATIONTOKEN:\n+    {\n+      if (delegation.getValue() !\u003d null) {\n+        throw new IllegalArgumentException(delegation.getName()\n+            + \" parameter is not null.\");\n+      }\n+      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n+          namenode, ugi, renewer.getValue());\n+      final String js \u003d JsonUtil.toJsonString(token);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n+    case GETDELEGATIONTOKENS:\n+    {\n+      if (delegation.getValue() !\u003d null) {\n+        throw new IllegalArgumentException(delegation.getName()\n+            + \" parameter is not null.\");\n+      }\n+      final Token\u003c? extends TokenIdentifier\u003e[] tokens \u003d new Token\u003c?\u003e[1];\n+      tokens[0] \u003d generateDelegationToken(namenode, ugi, renewer.getValue());\n+      final String js \u003d JsonUtil.toJsonString(tokens);\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n+    case GETHOMEDIRECTORY:\n+    {\n+      final String js \u003d JsonUtil.toJsonString(\n+          org.apache.hadoop.fs.Path.class.getSimpleName(),\n+          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n+      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+    }\n+    default:\n+      throw new UnsupportedOperationException(op + \" is not supported\");\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Response get(\n      final UserGroupInformation ugi,\n      final DelegationParam delegation,\n      final UserParam username,\n      final DoAsParam doAsUser,\n      final String fullpath,\n      final GetOpParam op,\n      final OffsetParam offset,\n      final LengthParam length,\n      final RenewerParam renewer,\n      final BufferSizeParam bufferSize\n      ) throws IOException, URISyntaxException {\n    final NameNode namenode \u003d (NameNode)context.getAttribute(\"name.node\");\n    final NamenodeProtocols np \u003d namenode.getRpcServer();\n\n    switch(op.getValue()) {\n    case OPEN:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), offset.getValue(), offset, length, bufferSize);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GET_BLOCK_LOCATIONS:\n    {\n      final long offsetValue \u003d offset.getValue();\n      final Long lengthValue \u003d length.getValue();\n      final LocatedBlocks locatedblocks \u003d np.getBlockLocations(fullpath,\n          offsetValue, lengthValue !\u003d null? lengthValue: Long.MAX_VALUE);\n      final String js \u003d JsonUtil.toJsonString(locatedblocks);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILESTATUS:\n    {\n      final HdfsFileStatus status \u003d np.getFileInfo(fullpath);\n      if (status \u003d\u003d null) {\n        throw new FileNotFoundException(\"File does not exist: \" + fullpath);\n      }\n\n      final String js \u003d JsonUtil.toJsonString(status, true);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case LISTSTATUS:\n    {\n      final StreamingOutput streaming \u003d getListingStream(np, fullpath);\n      return Response.ok(streaming).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETCONTENTSUMMARY:\n    {\n      final ContentSummary contentsummary \u003d np.getContentSummary(fullpath);\n      final String js \u003d JsonUtil.toJsonString(contentsummary);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETFILECHECKSUM:\n    {\n      final URI uri \u003d redirectURI(namenode, ugi, delegation, username, doAsUser,\n          fullpath, op.getValue(), -1L);\n      return Response.temporaryRedirect(uri).type(MediaType.APPLICATION_OCTET_STREAM).build();\n    }\n    case GETDELEGATIONTOKEN:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e token \u003d generateDelegationToken(\n          namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(token);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETDELEGATIONTOKENS:\n    {\n      if (delegation.getValue() !\u003d null) {\n        throw new IllegalArgumentException(delegation.getName()\n            + \" parameter is not null.\");\n      }\n      final Token\u003c? extends TokenIdentifier\u003e[] tokens \u003d new Token\u003c?\u003e[1];\n      tokens[0] \u003d generateDelegationToken(namenode, ugi, renewer.getValue());\n      final String js \u003d JsonUtil.toJsonString(tokens);\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    case GETHOMEDIRECTORY:\n    {\n      final String js \u003d JsonUtil.toJsonString(\n          org.apache.hadoop.fs.Path.class.getSimpleName(),\n          WebHdfsFileSystem.getHomeDirectoryString(ugi));\n      return Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n    }\n    default:\n      throw new UnsupportedOperationException(op + \" is not supported\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/web/resources/NamenodeWebHdfsMethods.java"
    }
  }
}