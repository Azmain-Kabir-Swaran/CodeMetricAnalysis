{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ZKFailoverController.java",
  "functionName": "waitForActiveAttempt",
  "functionId": "waitForActiveAttempt___timeoutMillis-int__onlyAfterNanoTime-long",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java",
  "functionStartLine": 456,
  "functionEndLine": 488,
  "numCommitsSeen": 67,
  "timeTaken": 2541,
  "changeHistory": [
    "6d92aa7c30439d78deb68cc3186a67557544681f",
    "9d5799553fea81920edfab611e5d485a97841848"
  ],
  "changeHistoryShort": {
    "6d92aa7c30439d78deb68cc3186a67557544681f": "Ymultichange(Yparameterchange,Ybodychange)",
    "9d5799553fea81920edfab611e5d485a97841848": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6d92aa7c30439d78deb68cc3186a67557544681f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16579. Upgrade to Curator 4.2.0 and ZooKeeper 3.5.5 (#1656). Contributed by Norbert Kalmár, Mate Szalay-Beko\n\n* HADOOP-16579 - Upgrade to Apache Curator 4.2.0 and ZooKeeper 3.5.5\r\n\r\n- Add a static initializer for the unit tests using ZooKeeper to enable\r\nthe four-letter-words diagnostic telnet commands. (this is an interface\r\nthat become disabled by default, so to keep the ZooKeeper 3.4.x behavior\r\nwe enabled it for the tests)\r\n- Also fix ZKFailoverController to look for relevant fail-over ActiveAttempt\r\nrecords. The new ZooKeeper seems to respond quicker during the fail-over\r\ntests than the ZooKeeper, so we made sure to catch all the relevant records\r\nby adding a new parameter to ZKFailoverontroller.waitForActiveAttempt().\r\n\r\nCo-authored-by: Norbert Kalmár \u003cnkalmar@cloudera.com\u003e",
      "commitDate": "18/10/19 1:26 PM",
      "commitName": "6d92aa7c30439d78deb68cc3186a67557544681f",
      "commitAuthor": "Mate Szalay-Beko",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16579. Upgrade to Curator 4.2.0 and ZooKeeper 3.5.5 (#1656). Contributed by Norbert Kalmár, Mate Szalay-Beko\n\n* HADOOP-16579 - Upgrade to Apache Curator 4.2.0 and ZooKeeper 3.5.5\r\n\r\n- Add a static initializer for the unit tests using ZooKeeper to enable\r\nthe four-letter-words diagnostic telnet commands. (this is an interface\r\nthat become disabled by default, so to keep the ZooKeeper 3.4.x behavior\r\nwe enabled it for the tests)\r\n- Also fix ZKFailoverController to look for relevant fail-over ActiveAttempt\r\nrecords. The new ZooKeeper seems to respond quicker during the fail-over\r\ntests than the ZooKeeper, so we made sure to catch all the relevant records\r\nby adding a new parameter to ZKFailoverontroller.waitForActiveAttempt().\r\n\r\nCo-authored-by: Norbert Kalmár \u003cnkalmar@cloudera.com\u003e",
          "commitDate": "18/10/19 1:26 PM",
          "commitName": "6d92aa7c30439d78deb68cc3186a67557544681f",
          "commitAuthor": "Mate Szalay-Beko",
          "commitDateOld": "25/02/19 2:35 PM",
          "commitNameOld": "a6ab37192a90e5ee868376b42be226e00cce31d8",
          "commitAuthorOld": "Konstantin V Shvachko",
          "daysBetweenCommits": 234.91,
          "commitsBetweenForRepo": 1816,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,33 @@\n-  private ActiveAttemptRecord waitForActiveAttempt(int timeoutMillis)\n-      throws InterruptedException {\n-    long st \u003d System.nanoTime();\n-    long waitUntil \u003d st + TimeUnit.NANOSECONDS.convert(\n+  private ActiveAttemptRecord waitForActiveAttempt(int timeoutMillis,\n+      long onlyAfterNanoTime) throws InterruptedException {\n+    long waitUntil \u003d onlyAfterNanoTime + TimeUnit.NANOSECONDS.convert(\n         timeoutMillis, TimeUnit.MILLISECONDS);\n     \n     do {\n       // periodically check health state, because entering an\n       // unhealthy state could prevent us from ever attempting to\n       // become active. We can detect this and respond to the user\n       // immediately.\n       synchronized (this) {\n         if (lastHealthState !\u003d State.SERVICE_HEALTHY) {\n           // early out if service became unhealthy\n           return null;\n         }\n       }\n \n       synchronized (activeAttemptRecordLock) {\n         if ((lastActiveAttemptRecord !\u003d null \u0026\u0026\n-            lastActiveAttemptRecord.nanoTime \u003e\u003d st)) {\n+            lastActiveAttemptRecord.nanoTime \u003e\u003d onlyAfterNanoTime)) {\n           return lastActiveAttemptRecord;\n         }\n         // Only wait 1sec so that we periodically recheck the health state\n         // above.\n         activeAttemptRecordLock.wait(1000);\n       }\n     } while (System.nanoTime() \u003c waitUntil);\n     \n     // Timeout elapsed.\n     LOG.warn(timeoutMillis + \"ms timeout elapsed waiting for an attempt \" +\n         \"to become active\");\n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ActiveAttemptRecord waitForActiveAttempt(int timeoutMillis,\n      long onlyAfterNanoTime) throws InterruptedException {\n    long waitUntil \u003d onlyAfterNanoTime + TimeUnit.NANOSECONDS.convert(\n        timeoutMillis, TimeUnit.MILLISECONDS);\n    \n    do {\n      // periodically check health state, because entering an\n      // unhealthy state could prevent us from ever attempting to\n      // become active. We can detect this and respond to the user\n      // immediately.\n      synchronized (this) {\n        if (lastHealthState !\u003d State.SERVICE_HEALTHY) {\n          // early out if service became unhealthy\n          return null;\n        }\n      }\n\n      synchronized (activeAttemptRecordLock) {\n        if ((lastActiveAttemptRecord !\u003d null \u0026\u0026\n            lastActiveAttemptRecord.nanoTime \u003e\u003d onlyAfterNanoTime)) {\n          return lastActiveAttemptRecord;\n        }\n        // Only wait 1sec so that we periodically recheck the health state\n        // above.\n        activeAttemptRecordLock.wait(1000);\n      }\n    } while (System.nanoTime() \u003c waitUntil);\n    \n    // Timeout elapsed.\n    LOG.warn(timeoutMillis + \"ms timeout elapsed waiting for an attempt \" +\n        \"to become active\");\n    return null;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java",
          "extendedDetails": {
            "oldValue": "[timeoutMillis-int]",
            "newValue": "[timeoutMillis-int, onlyAfterNanoTime-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16579. Upgrade to Curator 4.2.0 and ZooKeeper 3.5.5 (#1656). Contributed by Norbert Kalmár, Mate Szalay-Beko\n\n* HADOOP-16579 - Upgrade to Apache Curator 4.2.0 and ZooKeeper 3.5.5\r\n\r\n- Add a static initializer for the unit tests using ZooKeeper to enable\r\nthe four-letter-words diagnostic telnet commands. (this is an interface\r\nthat become disabled by default, so to keep the ZooKeeper 3.4.x behavior\r\nwe enabled it for the tests)\r\n- Also fix ZKFailoverController to look for relevant fail-over ActiveAttempt\r\nrecords. The new ZooKeeper seems to respond quicker during the fail-over\r\ntests than the ZooKeeper, so we made sure to catch all the relevant records\r\nby adding a new parameter to ZKFailoverontroller.waitForActiveAttempt().\r\n\r\nCo-authored-by: Norbert Kalmár \u003cnkalmar@cloudera.com\u003e",
          "commitDate": "18/10/19 1:26 PM",
          "commitName": "6d92aa7c30439d78deb68cc3186a67557544681f",
          "commitAuthor": "Mate Szalay-Beko",
          "commitDateOld": "25/02/19 2:35 PM",
          "commitNameOld": "a6ab37192a90e5ee868376b42be226e00cce31d8",
          "commitAuthorOld": "Konstantin V Shvachko",
          "daysBetweenCommits": 234.91,
          "commitsBetweenForRepo": 1816,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,34 +1,33 @@\n-  private ActiveAttemptRecord waitForActiveAttempt(int timeoutMillis)\n-      throws InterruptedException {\n-    long st \u003d System.nanoTime();\n-    long waitUntil \u003d st + TimeUnit.NANOSECONDS.convert(\n+  private ActiveAttemptRecord waitForActiveAttempt(int timeoutMillis,\n+      long onlyAfterNanoTime) throws InterruptedException {\n+    long waitUntil \u003d onlyAfterNanoTime + TimeUnit.NANOSECONDS.convert(\n         timeoutMillis, TimeUnit.MILLISECONDS);\n     \n     do {\n       // periodically check health state, because entering an\n       // unhealthy state could prevent us from ever attempting to\n       // become active. We can detect this and respond to the user\n       // immediately.\n       synchronized (this) {\n         if (lastHealthState !\u003d State.SERVICE_HEALTHY) {\n           // early out if service became unhealthy\n           return null;\n         }\n       }\n \n       synchronized (activeAttemptRecordLock) {\n         if ((lastActiveAttemptRecord !\u003d null \u0026\u0026\n-            lastActiveAttemptRecord.nanoTime \u003e\u003d st)) {\n+            lastActiveAttemptRecord.nanoTime \u003e\u003d onlyAfterNanoTime)) {\n           return lastActiveAttemptRecord;\n         }\n         // Only wait 1sec so that we periodically recheck the health state\n         // above.\n         activeAttemptRecordLock.wait(1000);\n       }\n     } while (System.nanoTime() \u003c waitUntil);\n     \n     // Timeout elapsed.\n     LOG.warn(timeoutMillis + \"ms timeout elapsed waiting for an attempt \" +\n         \"to become active\");\n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ActiveAttemptRecord waitForActiveAttempt(int timeoutMillis,\n      long onlyAfterNanoTime) throws InterruptedException {\n    long waitUntil \u003d onlyAfterNanoTime + TimeUnit.NANOSECONDS.convert(\n        timeoutMillis, TimeUnit.MILLISECONDS);\n    \n    do {\n      // periodically check health state, because entering an\n      // unhealthy state could prevent us from ever attempting to\n      // become active. We can detect this and respond to the user\n      // immediately.\n      synchronized (this) {\n        if (lastHealthState !\u003d State.SERVICE_HEALTHY) {\n          // early out if service became unhealthy\n          return null;\n        }\n      }\n\n      synchronized (activeAttemptRecordLock) {\n        if ((lastActiveAttemptRecord !\u003d null \u0026\u0026\n            lastActiveAttemptRecord.nanoTime \u003e\u003d onlyAfterNanoTime)) {\n          return lastActiveAttemptRecord;\n        }\n        // Only wait 1sec so that we periodically recheck the health state\n        // above.\n        activeAttemptRecordLock.wait(1000);\n      }\n    } while (System.nanoTime() \u003c waitUntil);\n    \n    // Timeout elapsed.\n    LOG.warn(timeoutMillis + \"ms timeout elapsed waiting for an attempt \" +\n        \"to become active\");\n    return null;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java",
          "extendedDetails": {}
        }
      ]
    },
    "9d5799553fea81920edfab611e5d485a97841848": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8279. Allow manual failover to be invoked when auto-failover is enabled. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3042@1333288 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/05/12 6:56 PM",
      "commitName": "9d5799553fea81920edfab611e5d485a97841848",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,34 @@\n+  private ActiveAttemptRecord waitForActiveAttempt(int timeoutMillis)\n+      throws InterruptedException {\n+    long st \u003d System.nanoTime();\n+    long waitUntil \u003d st + TimeUnit.NANOSECONDS.convert(\n+        timeoutMillis, TimeUnit.MILLISECONDS);\n+    \n+    do {\n+      // periodically check health state, because entering an\n+      // unhealthy state could prevent us from ever attempting to\n+      // become active. We can detect this and respond to the user\n+      // immediately.\n+      synchronized (this) {\n+        if (lastHealthState !\u003d State.SERVICE_HEALTHY) {\n+          // early out if service became unhealthy\n+          return null;\n+        }\n+      }\n+\n+      synchronized (activeAttemptRecordLock) {\n+        if ((lastActiveAttemptRecord !\u003d null \u0026\u0026\n+            lastActiveAttemptRecord.nanoTime \u003e\u003d st)) {\n+          return lastActiveAttemptRecord;\n+        }\n+        // Only wait 1sec so that we periodically recheck the health state\n+        // above.\n+        activeAttemptRecordLock.wait(1000);\n+      }\n+    } while (System.nanoTime() \u003c waitUntil);\n+    \n+    // Timeout elapsed.\n+    LOG.warn(timeoutMillis + \"ms timeout elapsed waiting for an attempt \" +\n+        \"to become active\");\n+    return null;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private ActiveAttemptRecord waitForActiveAttempt(int timeoutMillis)\n      throws InterruptedException {\n    long st \u003d System.nanoTime();\n    long waitUntil \u003d st + TimeUnit.NANOSECONDS.convert(\n        timeoutMillis, TimeUnit.MILLISECONDS);\n    \n    do {\n      // periodically check health state, because entering an\n      // unhealthy state could prevent us from ever attempting to\n      // become active. We can detect this and respond to the user\n      // immediately.\n      synchronized (this) {\n        if (lastHealthState !\u003d State.SERVICE_HEALTHY) {\n          // early out if service became unhealthy\n          return null;\n        }\n      }\n\n      synchronized (activeAttemptRecordLock) {\n        if ((lastActiveAttemptRecord !\u003d null \u0026\u0026\n            lastActiveAttemptRecord.nanoTime \u003e\u003d st)) {\n          return lastActiveAttemptRecord;\n        }\n        // Only wait 1sec so that we periodically recheck the health state\n        // above.\n        activeAttemptRecordLock.wait(1000);\n      }\n    } while (System.nanoTime() \u003c waitUntil);\n    \n    // Timeout elapsed.\n    LOG.warn(timeoutMillis + \"ms timeout elapsed waiting for an attempt \" +\n        \"to become active\");\n    return null;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java"
    }
  }
}