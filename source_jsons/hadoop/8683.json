{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSEditLogLoader.java",
  "functionName": "loadEditRecords",
  "functionId": "loadEditRecords___in-EditLogInputStream__closeOnExit-boolean__expectedStartingTxId-long__maxTxnsToRead-long__startOpt-StartupOption__recovery-MetaRecoveryContext",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogLoader.java",
  "functionStartLine": 210,
  "functionEndLine": 359,
  "numCommitsSeen": 198,
  "timeTaken": 2009,
  "changeHistory": [
    "a65bb97f5d8bf2eb817923a69bbb966359f736d7",
    "ebe5853a458150b7e42fe7434851bfcbe25e354d"
  ],
  "changeHistoryShort": {
    "a65bb97f5d8bf2eb817923a69bbb966359f736d7": "Ybodychange",
    "ebe5853a458150b7e42fe7434851bfcbe25e354d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a65bb97f5d8bf2eb817923a69bbb966359f736d7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13791. Limit logging frequency of edit tail related statements. Contributed by Erik Krogen.\n",
      "commitDate": "24/12/18 9:34 AM",
      "commitName": "a65bb97f5d8bf2eb817923a69bbb966359f736d7",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "06/09/18 2:48 PM",
      "commitNameOld": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 108.82,
      "commitsBetweenForRepo": 942,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,150 @@\n   long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n       long expectedStartingTxId, long maxTxnsToRead, StartupOption startOpt,\n       MetaRecoveryContext recovery) throws IOException {\n     EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n       new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Acquiring write lock to replay edit log\");\n     }\n \n     fsNamesys.writeLock();\n     FSDirectory fsDir \u003d fsNamesys.dir;\n     fsDir.writeLock();\n \n     long recentOpcodeOffsets[] \u003d new long[4];\n     Arrays.fill(recentOpcodeOffsets, -1);\n     \n     long expectedTxId \u003d expectedStartingTxId;\n     long numEdits \u003d 0;\n     long lastTxId \u003d in.getLastTxId();\n     long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     Step step \u003d createStartupProgressStep(in);\n     prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n     Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n-    long lastLogTime \u003d monotonicNow();\n+    long lastLogTime \u003d timer.monotonicNow();\n     long lastInodeId \u003d fsNamesys.dir.getLastInodeId();\n     \n     try {\n       while (true) {\n         try {\n           FSEditLogOp op;\n           try {\n             op \u003d in.readOp();\n             if (op \u003d\u003d null) {\n               break;\n             }\n           } catch (Throwable e) {\n             // Handle a problem with our input\n             check203UpgradeFailure(in.getVersion(true), e);\n             String errorMessage \u003d\n               formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n             FSImage.LOG.error(errorMessage, e);\n             if (recovery \u003d\u003d null) {\n                // We will only try to skip over problematic opcodes when in\n                // recovery mode.\n               throw new EditLogInputException(errorMessage, e, numEdits);\n             }\n             MetaRecoveryContext.editLogLoaderPrompt(\n                 \"We failed to read txId \" + expectedTxId,\n                 recovery, \"skipping the bad section in the log\");\n             in.resync();\n             continue;\n           }\n           recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n             in.getPosition();\n           if (op.hasTransactionId()) {\n             if (op.getTransactionId() \u003e expectedTxId) { \n               MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                   \"to be a gap in the edit log.  We expected txid \" +\n                   expectedTxId + \", but got txid \" +\n                   op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                   \" transaction IDs\");\n             } else if (op.getTransactionId() \u003c expectedTxId) { \n               MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                   \"to be an out-of-order edit in the edit log.  We \" +\n                   \"expected txid \" + expectedTxId + \", but got txid \" +\n                   op.getTransactionId() + \".\", recovery,\n                   \"skipping the out-of-order edit\");\n               continue;\n             }\n           }\n           try {\n             if (LOG.isTraceEnabled()) {\n               LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                   + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n             }\n             long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n                 in.getVersion(true), lastInodeId);\n             if (lastInodeId \u003c inodeId) {\n               lastInodeId \u003d inodeId;\n             }\n           } catch (RollingUpgradeOp.RollbackException e) {\n             throw e;\n           } catch (Throwable e) {\n             LOG.error(\"Encountered exception on operation \" + op, e);\n             if (recovery \u003d\u003d null) {\n               throw e instanceof IOException? (IOException)e: new IOException(e);\n             }\n \n             MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n              \"apply edit log operation \" + op + \": error \" +\n              e.getMessage(), recovery, \"applying edits\");\n           }\n           // Now that the operation has been successfully decoded and\n           // applied, update our bookkeeping.\n           incrOpCount(op.opCode, opCounts, step, counter);\n           if (op.hasTransactionId()) {\n             lastAppliedTxId \u003d op.getTransactionId();\n             expectedTxId \u003d lastAppliedTxId + 1;\n           } else {\n             expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n           }\n           // log progress\n           if (op.hasTransactionId()) {\n-            long now \u003d monotonicNow();\n+            long now \u003d timer.monotonicNow();\n             if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n               long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n               int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n               LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                   + \" transactions completed. (\" + percent + \"%)\");\n               lastLogTime \u003d now;\n             }\n           }\n           numEdits++;\n           totalEdits++;\n           if(numEdits \u003e\u003d maxTxnsToRead) {\n             break;\n           }\n         } catch (RollingUpgradeOp.RollbackException e) {\n           LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n           break;\n         } catch (MetaRecoveryContext.RequestStopException e) {\n           MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n               in.getPosition() + \"/\"  + in.length());\n           break;\n         }\n       }\n     } finally {\n       fsNamesys.dir.resetLastInodeId(lastInodeId);\n       if(closeOnExit) {\n         in.close();\n       }\n       fsDir.writeUnlock();\n       fsNamesys.writeUnlock(\"loadEditRecords\");\n \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(\"replaying edit log finished\");\n       }\n \n       if (FSImage.LOG.isDebugEnabled()) {\n         dumpOpCounts(opCounts);\n         FSImage.LOG.debug(\"maxTxnsToRead \u003d \" + maxTxnsToRead\n             + \" actual edits read \u003d \" + numEdits);\n       }\n       assert numEdits \u003c\u003d maxTxnsToRead || numEdits \u003d\u003d 1 :\n         \"should read at least one txn, but not more than the configured max\";\n     }\n     return numEdits;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n      long expectedStartingTxId, long maxTxnsToRead, StartupOption startOpt,\n      MetaRecoveryContext recovery) throws IOException {\n    EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n      new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Acquiring write lock to replay edit log\");\n    }\n\n    fsNamesys.writeLock();\n    FSDirectory fsDir \u003d fsNamesys.dir;\n    fsDir.writeLock();\n\n    long recentOpcodeOffsets[] \u003d new long[4];\n    Arrays.fill(recentOpcodeOffsets, -1);\n    \n    long expectedTxId \u003d expectedStartingTxId;\n    long numEdits \u003d 0;\n    long lastTxId \u003d in.getLastTxId();\n    long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    Step step \u003d createStartupProgressStep(in);\n    prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n    Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n    long lastLogTime \u003d timer.monotonicNow();\n    long lastInodeId \u003d fsNamesys.dir.getLastInodeId();\n    \n    try {\n      while (true) {\n        try {\n          FSEditLogOp op;\n          try {\n            op \u003d in.readOp();\n            if (op \u003d\u003d null) {\n              break;\n            }\n          } catch (Throwable e) {\n            // Handle a problem with our input\n            check203UpgradeFailure(in.getVersion(true), e);\n            String errorMessage \u003d\n              formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n            FSImage.LOG.error(errorMessage, e);\n            if (recovery \u003d\u003d null) {\n               // We will only try to skip over problematic opcodes when in\n               // recovery mode.\n              throw new EditLogInputException(errorMessage, e, numEdits);\n            }\n            MetaRecoveryContext.editLogLoaderPrompt(\n                \"We failed to read txId \" + expectedTxId,\n                recovery, \"skipping the bad section in the log\");\n            in.resync();\n            continue;\n          }\n          recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n            in.getPosition();\n          if (op.hasTransactionId()) {\n            if (op.getTransactionId() \u003e expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be a gap in the edit log.  We expected txid \" +\n                  expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                  \" transaction IDs\");\n            } else if (op.getTransactionId() \u003c expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be an out-of-order edit in the edit log.  We \" +\n                  \"expected txid \" + expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery,\n                  \"skipping the out-of-order edit\");\n              continue;\n            }\n          }\n          try {\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                  + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n            }\n            long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n                in.getVersion(true), lastInodeId);\n            if (lastInodeId \u003c inodeId) {\n              lastInodeId \u003d inodeId;\n            }\n          } catch (RollingUpgradeOp.RollbackException e) {\n            throw e;\n          } catch (Throwable e) {\n            LOG.error(\"Encountered exception on operation \" + op, e);\n            if (recovery \u003d\u003d null) {\n              throw e instanceof IOException? (IOException)e: new IOException(e);\n            }\n\n            MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n             \"apply edit log operation \" + op + \": error \" +\n             e.getMessage(), recovery, \"applying edits\");\n          }\n          // Now that the operation has been successfully decoded and\n          // applied, update our bookkeeping.\n          incrOpCount(op.opCode, opCounts, step, counter);\n          if (op.hasTransactionId()) {\n            lastAppliedTxId \u003d op.getTransactionId();\n            expectedTxId \u003d lastAppliedTxId + 1;\n          } else {\n            expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n          }\n          // log progress\n          if (op.hasTransactionId()) {\n            long now \u003d timer.monotonicNow();\n            if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n              long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n              int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n              LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                  + \" transactions completed. (\" + percent + \"%)\");\n              lastLogTime \u003d now;\n            }\n          }\n          numEdits++;\n          totalEdits++;\n          if(numEdits \u003e\u003d maxTxnsToRead) {\n            break;\n          }\n        } catch (RollingUpgradeOp.RollbackException e) {\n          LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n          break;\n        } catch (MetaRecoveryContext.RequestStopException e) {\n          MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n              in.getPosition() + \"/\"  + in.length());\n          break;\n        }\n      }\n    } finally {\n      fsNamesys.dir.resetLastInodeId(lastInodeId);\n      if(closeOnExit) {\n        in.close();\n      }\n      fsDir.writeUnlock();\n      fsNamesys.writeUnlock(\"loadEditRecords\");\n\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"replaying edit log finished\");\n      }\n\n      if (FSImage.LOG.isDebugEnabled()) {\n        dumpOpCounts(opCounts);\n        FSImage.LOG.debug(\"maxTxnsToRead \u003d \" + maxTxnsToRead\n            + \" actual edits read \u003d \" + numEdits);\n      }\n      assert numEdits \u003c\u003d maxTxnsToRead || numEdits \u003d\u003d 1 :\n        \"should read at least one txn, but not more than the configured max\";\n    }\n    return numEdits;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogLoader.java",
      "extendedDetails": {}
    },
    "ebe5853a458150b7e42fe7434851bfcbe25e354d": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-12978. Fine-grained locking while consuming journal stream. Contributed by Konstantin Shvachko.",
      "commitDate": "31/05/18 2:56 PM",
      "commitName": "ebe5853a458150b7e42fe7434851bfcbe25e354d",
      "commitAuthor": "Konstantin V Shvachko",
      "diff": "@@ -0,0 +1,150 @@\n+  long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n+      long expectedStartingTxId, long maxTxnsToRead, StartupOption startOpt,\n+      MetaRecoveryContext recovery) throws IOException {\n+    EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n+      new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n+\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(\"Acquiring write lock to replay edit log\");\n+    }\n+\n+    fsNamesys.writeLock();\n+    FSDirectory fsDir \u003d fsNamesys.dir;\n+    fsDir.writeLock();\n+\n+    long recentOpcodeOffsets[] \u003d new long[4];\n+    Arrays.fill(recentOpcodeOffsets, -1);\n+    \n+    long expectedTxId \u003d expectedStartingTxId;\n+    long numEdits \u003d 0;\n+    long lastTxId \u003d in.getLastTxId();\n+    long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n+    StartupProgress prog \u003d NameNode.getStartupProgress();\n+    Step step \u003d createStartupProgressStep(in);\n+    prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n+    Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n+    long lastLogTime \u003d monotonicNow();\n+    long lastInodeId \u003d fsNamesys.dir.getLastInodeId();\n+    \n+    try {\n+      while (true) {\n+        try {\n+          FSEditLogOp op;\n+          try {\n+            op \u003d in.readOp();\n+            if (op \u003d\u003d null) {\n+              break;\n+            }\n+          } catch (Throwable e) {\n+            // Handle a problem with our input\n+            check203UpgradeFailure(in.getVersion(true), e);\n+            String errorMessage \u003d\n+              formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n+            FSImage.LOG.error(errorMessage, e);\n+            if (recovery \u003d\u003d null) {\n+               // We will only try to skip over problematic opcodes when in\n+               // recovery mode.\n+              throw new EditLogInputException(errorMessage, e, numEdits);\n+            }\n+            MetaRecoveryContext.editLogLoaderPrompt(\n+                \"We failed to read txId \" + expectedTxId,\n+                recovery, \"skipping the bad section in the log\");\n+            in.resync();\n+            continue;\n+          }\n+          recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n+            in.getPosition();\n+          if (op.hasTransactionId()) {\n+            if (op.getTransactionId() \u003e expectedTxId) { \n+              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n+                  \"to be a gap in the edit log.  We expected txid \" +\n+                  expectedTxId + \", but got txid \" +\n+                  op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n+                  \" transaction IDs\");\n+            } else if (op.getTransactionId() \u003c expectedTxId) { \n+              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n+                  \"to be an out-of-order edit in the edit log.  We \" +\n+                  \"expected txid \" + expectedTxId + \", but got txid \" +\n+                  op.getTransactionId() + \".\", recovery,\n+                  \"skipping the out-of-order edit\");\n+              continue;\n+            }\n+          }\n+          try {\n+            if (LOG.isTraceEnabled()) {\n+              LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n+                  + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n+            }\n+            long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n+                in.getVersion(true), lastInodeId);\n+            if (lastInodeId \u003c inodeId) {\n+              lastInodeId \u003d inodeId;\n+            }\n+          } catch (RollingUpgradeOp.RollbackException e) {\n+            throw e;\n+          } catch (Throwable e) {\n+            LOG.error(\"Encountered exception on operation \" + op, e);\n+            if (recovery \u003d\u003d null) {\n+              throw e instanceof IOException? (IOException)e: new IOException(e);\n+            }\n+\n+            MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n+             \"apply edit log operation \" + op + \": error \" +\n+             e.getMessage(), recovery, \"applying edits\");\n+          }\n+          // Now that the operation has been successfully decoded and\n+          // applied, update our bookkeeping.\n+          incrOpCount(op.opCode, opCounts, step, counter);\n+          if (op.hasTransactionId()) {\n+            lastAppliedTxId \u003d op.getTransactionId();\n+            expectedTxId \u003d lastAppliedTxId + 1;\n+          } else {\n+            expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n+          }\n+          // log progress\n+          if (op.hasTransactionId()) {\n+            long now \u003d monotonicNow();\n+            if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n+              long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n+              int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n+              LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n+                  + \" transactions completed. (\" + percent + \"%)\");\n+              lastLogTime \u003d now;\n+            }\n+          }\n+          numEdits++;\n+          totalEdits++;\n+          if(numEdits \u003e\u003d maxTxnsToRead) {\n+            break;\n+          }\n+        } catch (RollingUpgradeOp.RollbackException e) {\n+          LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n+          break;\n+        } catch (MetaRecoveryContext.RequestStopException e) {\n+          MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n+              in.getPosition() + \"/\"  + in.length());\n+          break;\n+        }\n+      }\n+    } finally {\n+      fsNamesys.dir.resetLastInodeId(lastInodeId);\n+      if(closeOnExit) {\n+        in.close();\n+      }\n+      fsDir.writeUnlock();\n+      fsNamesys.writeUnlock(\"loadEditRecords\");\n+\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"replaying edit log finished\");\n+      }\n+\n+      if (FSImage.LOG.isDebugEnabled()) {\n+        dumpOpCounts(opCounts);\n+        FSImage.LOG.debug(\"maxTxnsToRead \u003d \" + maxTxnsToRead\n+            + \" actual edits read \u003d \" + numEdits);\n+      }\n+      assert numEdits \u003c\u003d maxTxnsToRead || numEdits \u003d\u003d 1 :\n+        \"should read at least one txn, but not more than the configured max\";\n+    }\n+    return numEdits;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n      long expectedStartingTxId, long maxTxnsToRead, StartupOption startOpt,\n      MetaRecoveryContext recovery) throws IOException {\n    EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n      new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Acquiring write lock to replay edit log\");\n    }\n\n    fsNamesys.writeLock();\n    FSDirectory fsDir \u003d fsNamesys.dir;\n    fsDir.writeLock();\n\n    long recentOpcodeOffsets[] \u003d new long[4];\n    Arrays.fill(recentOpcodeOffsets, -1);\n    \n    long expectedTxId \u003d expectedStartingTxId;\n    long numEdits \u003d 0;\n    long lastTxId \u003d in.getLastTxId();\n    long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    Step step \u003d createStartupProgressStep(in);\n    prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n    Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n    long lastLogTime \u003d monotonicNow();\n    long lastInodeId \u003d fsNamesys.dir.getLastInodeId();\n    \n    try {\n      while (true) {\n        try {\n          FSEditLogOp op;\n          try {\n            op \u003d in.readOp();\n            if (op \u003d\u003d null) {\n              break;\n            }\n          } catch (Throwable e) {\n            // Handle a problem with our input\n            check203UpgradeFailure(in.getVersion(true), e);\n            String errorMessage \u003d\n              formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n            FSImage.LOG.error(errorMessage, e);\n            if (recovery \u003d\u003d null) {\n               // We will only try to skip over problematic opcodes when in\n               // recovery mode.\n              throw new EditLogInputException(errorMessage, e, numEdits);\n            }\n            MetaRecoveryContext.editLogLoaderPrompt(\n                \"We failed to read txId \" + expectedTxId,\n                recovery, \"skipping the bad section in the log\");\n            in.resync();\n            continue;\n          }\n          recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n            in.getPosition();\n          if (op.hasTransactionId()) {\n            if (op.getTransactionId() \u003e expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be a gap in the edit log.  We expected txid \" +\n                  expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                  \" transaction IDs\");\n            } else if (op.getTransactionId() \u003c expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be an out-of-order edit in the edit log.  We \" +\n                  \"expected txid \" + expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery,\n                  \"skipping the out-of-order edit\");\n              continue;\n            }\n          }\n          try {\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                  + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n            }\n            long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n                in.getVersion(true), lastInodeId);\n            if (lastInodeId \u003c inodeId) {\n              lastInodeId \u003d inodeId;\n            }\n          } catch (RollingUpgradeOp.RollbackException e) {\n            throw e;\n          } catch (Throwable e) {\n            LOG.error(\"Encountered exception on operation \" + op, e);\n            if (recovery \u003d\u003d null) {\n              throw e instanceof IOException? (IOException)e: new IOException(e);\n            }\n\n            MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n             \"apply edit log operation \" + op + \": error \" +\n             e.getMessage(), recovery, \"applying edits\");\n          }\n          // Now that the operation has been successfully decoded and\n          // applied, update our bookkeeping.\n          incrOpCount(op.opCode, opCounts, step, counter);\n          if (op.hasTransactionId()) {\n            lastAppliedTxId \u003d op.getTransactionId();\n            expectedTxId \u003d lastAppliedTxId + 1;\n          } else {\n            expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n          }\n          // log progress\n          if (op.hasTransactionId()) {\n            long now \u003d monotonicNow();\n            if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n              long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n              int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n              LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                  + \" transactions completed. (\" + percent + \"%)\");\n              lastLogTime \u003d now;\n            }\n          }\n          numEdits++;\n          totalEdits++;\n          if(numEdits \u003e\u003d maxTxnsToRead) {\n            break;\n          }\n        } catch (RollingUpgradeOp.RollbackException e) {\n          LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n          break;\n        } catch (MetaRecoveryContext.RequestStopException e) {\n          MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n              in.getPosition() + \"/\"  + in.length());\n          break;\n        }\n      }\n    } finally {\n      fsNamesys.dir.resetLastInodeId(lastInodeId);\n      if(closeOnExit) {\n        in.close();\n      }\n      fsDir.writeUnlock();\n      fsNamesys.writeUnlock(\"loadEditRecords\");\n\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"replaying edit log finished\");\n      }\n\n      if (FSImage.LOG.isDebugEnabled()) {\n        dumpOpCounts(opCounts);\n        FSImage.LOG.debug(\"maxTxnsToRead \u003d \" + maxTxnsToRead\n            + \" actual edits read \u003d \" + numEdits);\n      }\n      assert numEdits \u003c\u003d maxTxnsToRead || numEdits \u003d\u003d 1 :\n        \"should read at least one txn, but not more than the configured max\";\n    }\n    return numEdits;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogLoader.java"
    }
  }
}