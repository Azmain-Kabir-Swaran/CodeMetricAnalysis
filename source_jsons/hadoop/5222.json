{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirWriteFileOp.java",
  "functionName": "storeAllocatedBlock",
  "functionId": "storeAllocatedBlock___fsn-FSNamesystem__src-String__fileId-long__clientName-String__previous-ExtendedBlock__targets-DatanodeStorageInfo[]",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
  "functionStartLine": 223,
  "functionEndLine": 266,
  "numCommitsSeen": 614,
  "timeTaken": 8320,
  "changeHistory": [
    "a2a5d7b5bca715835d92816e7b267b59f7270708",
    "869393643de23dcb010cc33091c8eb398de0fd6c",
    "164cbe643988f878f0f4100a4de51783e5b6738e",
    "bdd79388f39f4f35af7decd5703eff587b0ddfb7",
    "e535e0f05b5fbd087c93238deb888cc985254b4c",
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
    "c17439c2ddd921b63b1635e6f1cba634b8da8557",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "d8ea443af0b1c8289a1dd738945831ff8be0e9c1",
    "e5afac5896a1a88e152746598527d91f73cbb724",
    "0959b67f1a189b4a99752904115efbd471f1d6d7"
  ],
  "changeHistoryShort": {
    "a2a5d7b5bca715835d92816e7b267b59f7270708": "Ybodychange",
    "869393643de23dcb010cc33091c8eb398de0fd6c": "Ybodychange",
    "164cbe643988f878f0f4100a4de51783e5b6738e": "Ybodychange",
    "bdd79388f39f4f35af7decd5703eff587b0ddfb7": "Ybodychange",
    "e535e0f05b5fbd087c93238deb888cc985254b4c": "Ybodychange",
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835": "Ybodychange",
    "c17439c2ddd921b63b1635e6f1cba634b8da8557": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Ybodychange",
    "d8ea443af0b1c8289a1dd738945831ff8be0e9c1": "Ybodychange",
    "e5afac5896a1a88e152746598527d91f73cbb724": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
    "0959b67f1a189b4a99752904115efbd471f1d6d7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a2a5d7b5bca715835d92816e7b267b59f7270708": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10759. Change fsimage bool isStriped from boolean to an enum. Contributed by Ewan Higgs.\n",
      "commitDate": "18/01/17 1:31 PM",
      "commitName": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "24/10/16 3:14 PM",
      "commitNameOld": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 85.97,
      "commitsBetweenForRepo": 568,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,44 @@\n   static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n       long fileId, String clientName, ExtendedBlock previous,\n       DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n     // Run the full analysis again, since things could have changed\n     // while chooseTarget() was executing.\n     LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n     INodesInPath iip \u003d fsn.dir.resolvePath(null, src, fileId);\n     FileState fileState \u003d analyzeFileState(fsn, iip, fileId, clientName,\n                                            previous, onRetryBlock);\n     final INodeFile pendingFile \u003d fileState.inode;\n     src \u003d fileState.path;\n \n     if (onRetryBlock[0] !\u003d null) {\n       if (onRetryBlock[0].getLocations().length \u003e 0) {\n         // This is a retry. Just return the last block if having locations.\n         return onRetryBlock[0];\n       } else {\n         // add new chosen targets to already allocated block and return\n         BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n         lastBlockInFile.getUnderConstructionFeature().setExpectedLocations(\n-            lastBlockInFile, targets, pendingFile.isStriped());\n+            lastBlockInFile, targets, pendingFile.getBlockType());\n         offset \u003d pendingFile.computeFileSize();\n         return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n     }\n \n     // commit the last block and complete it if it has minimum replicas\n     fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                   ExtendedBlock.getLocalBlock(previous));\n \n     // allocate new block, record block locations in INode.\n-    final boolean isStriped \u003d pendingFile.isStriped();\n+    final BlockType blockType \u003d pendingFile.getBlockType();\n     // allocate new block, record block locations in INode.\n-    Block newBlock \u003d fsn.createNewBlock(isStriped);\n+    Block newBlock \u003d fsn.createNewBlock(blockType);\n     INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n-    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets, isStriped);\n+    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets, blockType);\n \n     persistNewBlock(fsn, src, pendingFile);\n     offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n     return makeLocatedBlock(fsn, fsn.getStoredBlock(newBlock), targets, offset);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    INodesInPath iip \u003d fsn.dir.resolvePath(null, src, fileId);\n    FileState fileState \u003d analyzeFileState(fsn, iip, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n        lastBlockInFile.getUnderConstructionFeature().setExpectedLocations(\n            lastBlockInFile, targets, pendingFile.getBlockType());\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    final BlockType blockType \u003d pendingFile.getBlockType();\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock(blockType);\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets, blockType);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, fsn.getStoredBlock(newBlock), targets, offset);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "869393643de23dcb010cc33091c8eb398de0fd6c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10745. Directly resolve paths into INodesInPath. Contributed by Daryn Sharp.\n",
      "commitDate": "17/08/16 1:53 PM",
      "commitName": "869393643de23dcb010cc33091c8eb398de0fd6c",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "15/08/16 2:45 PM",
      "commitNameOld": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,44 @@\n   static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n       long fileId, String clientName, ExtendedBlock previous,\n       DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n     // Run the full analysis again, since things could have changed\n     // while chooseTarget() was executing.\n     LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n-    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n+    INodesInPath iip \u003d fsn.dir.resolvePath(null, src, fileId);\n+    FileState fileState \u003d analyzeFileState(fsn, iip, fileId, clientName,\n                                            previous, onRetryBlock);\n     final INodeFile pendingFile \u003d fileState.inode;\n     src \u003d fileState.path;\n \n     if (onRetryBlock[0] !\u003d null) {\n       if (onRetryBlock[0].getLocations().length \u003e 0) {\n         // This is a retry. Just return the last block if having locations.\n         return onRetryBlock[0];\n       } else {\n         // add new chosen targets to already allocated block and return\n         BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n         lastBlockInFile.getUnderConstructionFeature().setExpectedLocations(\n             lastBlockInFile, targets, pendingFile.isStriped());\n         offset \u003d pendingFile.computeFileSize();\n         return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n     }\n \n     // commit the last block and complete it if it has minimum replicas\n     fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                   ExtendedBlock.getLocalBlock(previous));\n \n     // allocate new block, record block locations in INode.\n     final boolean isStriped \u003d pendingFile.isStriped();\n     // allocate new block, record block locations in INode.\n     Block newBlock \u003d fsn.createNewBlock(isStriped);\n     INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n     saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets, isStriped);\n \n     persistNewBlock(fsn, src, pendingFile);\n     offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n     return makeLocatedBlock(fsn, fsn.getStoredBlock(newBlock), targets, offset);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    INodesInPath iip \u003d fsn.dir.resolvePath(null, src, fileId);\n    FileState fileState \u003d analyzeFileState(fsn, iip, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n        lastBlockInFile.getUnderConstructionFeature().setExpectedLocations(\n            lastBlockInFile, targets, pendingFile.isStriped());\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    final boolean isStriped \u003d pendingFile.isStriped();\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock(isStriped);\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets, isStriped);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, fsn.getStoredBlock(newBlock), targets, offset);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "164cbe643988f878f0f4100a4de51783e5b6738e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8909. Erasure coding: update BlockInfoContiguousUC and BlockInfoStripedUC to use BlockUnderConstructionFeature. Contributed by Jing Zhao.\n",
      "commitDate": "27/08/15 1:02 AM",
      "commitName": "164cbe643988f878f0f4100a4de51783e5b6738e",
      "commitAuthor": "Walter Su",
      "commitDateOld": "26/08/15 6:11 PM",
      "commitNameOld": "067ec8c2b14fb0929dc348b763383838e06ff8a5",
      "commitAuthorOld": "Walter Su",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n       long fileId, String clientName, ExtendedBlock previous,\n       DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n     // Run the full analysis again, since things could have changed\n     // while chooseTarget() was executing.\n     LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n     FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                            previous, onRetryBlock);\n     final INodeFile pendingFile \u003d fileState.inode;\n     src \u003d fileState.path;\n \n     if (onRetryBlock[0] !\u003d null) {\n       if (onRetryBlock[0].getLocations().length \u003e 0) {\n         // This is a retry. Just return the last block if having locations.\n         return onRetryBlock[0];\n       } else {\n         // add new chosen targets to already allocated block and return\n         BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n-        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n-            .setExpectedLocations(targets);\n+        lastBlockInFile.getUnderConstructionFeature().setExpectedLocations(\n+            lastBlockInFile, targets, pendingFile.isStriped());\n         offset \u003d pendingFile.computeFileSize();\n         return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n     }\n \n     // commit the last block and complete it if it has minimum replicas\n     fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                   ExtendedBlock.getLocalBlock(previous));\n \n     // allocate new block, record block locations in INode.\n     final boolean isStriped \u003d pendingFile.isStriped();\n     // allocate new block, record block locations in INode.\n     Block newBlock \u003d fsn.createNewBlock(isStriped);\n     INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n     saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets, isStriped);\n \n     persistNewBlock(fsn, src, pendingFile);\n     offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n     return makeLocatedBlock(fsn, fsn.getStoredBlock(newBlock), targets, offset);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n        lastBlockInFile.getUnderConstructionFeature().setExpectedLocations(\n            lastBlockInFile, targets, pendingFile.isStriped());\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    final boolean isStriped \u003d pendingFile.isStriped();\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock(isStriped);\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets, isStriped);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, fsn.getStoredBlock(newBlock), targets, offset);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "bdd79388f39f4f35af7decd5703eff587b0ddfb7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8928. Improvements for BlockUnderConstructionFeature: ReplicaUnderConstruction as a separate class and replicas as an array. Contributed by Jing Zhao.\n",
      "commitDate": "24/08/15 3:53 PM",
      "commitName": "bdd79388f39f4f35af7decd5703eff587b0ddfb7",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "22/08/15 12:09 AM",
      "commitNameOld": "745d04be59accf80feda0ad38efcc74ba362f2ca",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 2.66,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,41 @@\n   static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n       long fileId, String clientName, ExtendedBlock previous,\n       DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n     // Run the full analysis again, since things could have changed\n     // while chooseTarget() was executing.\n     LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n     FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                            previous, onRetryBlock);\n     final INodeFile pendingFile \u003d fileState.inode;\n     src \u003d fileState.path;\n \n     if (onRetryBlock[0] !\u003d null) {\n       if (onRetryBlock[0].getLocations().length \u003e 0) {\n         // This is a retry. Just return the last block if having locations.\n         return onRetryBlock[0];\n       } else {\n         // add new chosen targets to already allocated block and return\n         BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n-        lastBlockInFile.getUnderConstructionFeature().setExpectedLocations(lastBlockInFile.getGenerationStamp(), targets);\n+        lastBlockInFile.getUnderConstructionFeature().\n+            setExpectedLocations(lastBlockInFile, targets);\n         offset \u003d pendingFile.computeFileSize();\n         return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n     }\n \n     // commit the last block and complete it if it has minimum replicas\n     fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                   ExtendedBlock.getLocalBlock(previous));\n \n     // allocate new block, record block locations in INode.\n     Block newBlock \u003d fsn.createNewBlock();\n     INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n     saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n \n     persistNewBlock(fsn, src, pendingFile);\n     offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n     return makeLocatedBlock(fsn, newBlock, targets, offset);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n        lastBlockInFile.getUnderConstructionFeature().\n            setExpectedLocations(lastBlockInFile, targets);\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock();\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, newBlock, targets, offset);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "e535e0f05b5fbd087c93238deb888cc985254b4c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8801. Convert BlockInfoUnderConstruction as a feature. Contributed by Jing Zhao.\n",
      "commitDate": "17/08/15 11:28 AM",
      "commitName": "e535e0f05b5fbd087c93238deb888cc985254b4c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "11/08/15 10:28 AM",
      "commitNameOld": "1fc3c779a422bafdb86ad1a5b2349802dda1cb62",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 6.04,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,40 @@\n   static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n       long fileId, String clientName, ExtendedBlock previous,\n       DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n     // Run the full analysis again, since things could have changed\n     // while chooseTarget() was executing.\n     LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n     FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                            previous, onRetryBlock);\n     final INodeFile pendingFile \u003d fileState.inode;\n     src \u003d fileState.path;\n \n     if (onRetryBlock[0] !\u003d null) {\n       if (onRetryBlock[0].getLocations().length \u003e 0) {\n         // This is a retry. Just return the last block if having locations.\n         return onRetryBlock[0];\n       } else {\n         // add new chosen targets to already allocated block and return\n         BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n-        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n-            .setExpectedLocations(targets);\n+        lastBlockInFile.getUnderConstructionFeature().setExpectedLocations(lastBlockInFile.getGenerationStamp(), targets);\n         offset \u003d pendingFile.computeFileSize();\n         return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n     }\n \n     // commit the last block and complete it if it has minimum replicas\n     fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                   ExtendedBlock.getLocalBlock(previous));\n \n     // allocate new block, record block locations in INode.\n     Block newBlock \u003d fsn.createNewBlock();\n     INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n     saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n \n     persistNewBlock(fsn, src, pendingFile);\n     offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n     return makeLocatedBlock(fsn, newBlock, targets, offset);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n        lastBlockInFile.getUnderConstructionFeature().setExpectedLocations(lastBlockInFile.getGenerationStamp(), targets);\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock();\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, newBlock, targets, offset);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang.\"\n\nThis reverts commit c17439c2ddd921b63b1635e6f1cba634b8da8557.\n",
      "commitDate": "06/08/15 10:21 AM",
      "commitName": "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "21/07/15 5:25 PM",
      "commitNameOld": "31f117138a00794de4951ee8433e304d72b04094",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 15.71,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n       long fileId, String clientName, ExtendedBlock previous,\n       DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n     // Run the full analysis again, since things could have changed\n     // while chooseTarget() was executing.\n     LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n     FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                            previous, onRetryBlock);\n     final INodeFile pendingFile \u003d fileState.inode;\n     src \u003d fileState.path;\n \n     if (onRetryBlock[0] !\u003d null) {\n       if (onRetryBlock[0].getLocations().length \u003e 0) {\n         // This is a retry. Just return the last block if having locations.\n         return onRetryBlock[0];\n       } else {\n         // add new chosen targets to already allocated block and return\n         BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n-        ((BlockInfoUnderConstruction) lastBlockInFile)\n+        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n             .setExpectedLocations(targets);\n         offset \u003d pendingFile.computeFileSize();\n         return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n     }\n \n     // commit the last block and complete it if it has minimum replicas\n     fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                   ExtendedBlock.getLocalBlock(previous));\n \n     // allocate new block, record block locations in INode.\n     Block newBlock \u003d fsn.createNewBlock();\n     INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n     saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n \n     persistNewBlock(fsn, src, pendingFile);\n     offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n     return makeLocatedBlock(fsn, newBlock, targets, offset);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n            .setExpectedLocations(targets);\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock();\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, newBlock, targets, offset);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "c17439c2ddd921b63b1635e6f1cba634b8da8557": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang.\n",
      "commitDate": "12/06/15 11:38 AM",
      "commitName": "c17439c2ddd921b63b1635e6f1cba634b8da8557",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "27/05/15 3:42 PM",
      "commitNameOld": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 15.83,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n       long fileId, String clientName, ExtendedBlock previous,\n       DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n     // Run the full analysis again, since things could have changed\n     // while chooseTarget() was executing.\n     LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n     FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                            previous, onRetryBlock);\n     final INodeFile pendingFile \u003d fileState.inode;\n     src \u003d fileState.path;\n \n     if (onRetryBlock[0] !\u003d null) {\n       if (onRetryBlock[0].getLocations().length \u003e 0) {\n         // This is a retry. Just return the last block if having locations.\n         return onRetryBlock[0];\n       } else {\n         // add new chosen targets to already allocated block and return\n         BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n-        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n+        ((BlockInfoUnderConstruction) lastBlockInFile)\n             .setExpectedLocations(targets);\n         offset \u003d pendingFile.computeFileSize();\n         return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n     }\n \n     // commit the last block and complete it if it has minimum replicas\n     fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                   ExtendedBlock.getLocalBlock(previous));\n \n     // allocate new block, record block locations in INode.\n     Block newBlock \u003d fsn.createNewBlock();\n     INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n     saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n \n     persistNewBlock(fsn, src, pendingFile);\n     offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n     return makeLocatedBlock(fsn, newBlock, targets, offset);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n        ((BlockInfoUnderConstruction) lastBlockInFile)\n            .setExpectedLocations(targets);\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock();\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, newBlock, targets, offset);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/05/15 8:08 AM",
      "commitNameOld": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 6.32,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n       long fileId, String clientName, ExtendedBlock previous,\n       DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n     // Run the full analysis again, since things could have changed\n     // while chooseTarget() was executing.\n     LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n     FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                            previous, onRetryBlock);\n     final INodeFile pendingFile \u003d fileState.inode;\n     src \u003d fileState.path;\n \n     if (onRetryBlock[0] !\u003d null) {\n       if (onRetryBlock[0].getLocations().length \u003e 0) {\n         // This is a retry. Just return the last block if having locations.\n         return onRetryBlock[0];\n       } else {\n         // add new chosen targets to already allocated block and return\n-        BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n+        BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n         ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n             .setExpectedLocations(targets);\n         offset \u003d pendingFile.computeFileSize();\n         return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n     }\n \n     // commit the last block and complete it if it has minimum replicas\n     fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                   ExtendedBlock.getLocalBlock(previous));\n \n     // allocate new block, record block locations in INode.\n     Block newBlock \u003d fsn.createNewBlock();\n     INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n     saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n \n     persistNewBlock(fsn, src, pendingFile);\n     offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n     return makeLocatedBlock(fsn, newBlock, targets, offset);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n            .setExpectedLocations(targets);\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock();\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, newBlock, targets, offset);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "d8ea443af0b1c8289a1dd738945831ff8be0e9c1": {
      "type": "Ybodychange",
      "commitMessage": "Merge HDFS-8394 from trunk: Move getAdditionalBlock() and related functionalities into a separate class.\n",
      "commitDate": "26/05/15 12:02 PM",
      "commitName": "d8ea443af0b1c8289a1dd738945831ff8be0e9c1",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:55 AM",
      "commitNameOld": "1af8c148626effe1b41fc536019fd3349f485d59",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,44 @@\n   static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n       long fileId, String clientName, ExtendedBlock previous,\n       DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n     // Run the full analysis again, since things could have changed\n     // while chooseTarget() was executing.\n     LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n     FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                            previous, onRetryBlock);\n     final INodeFile pendingFile \u003d fileState.inode;\n     src \u003d fileState.path;\n \n     if (onRetryBlock[0] !\u003d null) {\n       if (onRetryBlock[0].getLocations().length \u003e 0) {\n         // This is a retry. Just return the last block if having locations.\n         return onRetryBlock[0];\n       } else {\n         // add new chosen targets to already allocated block and return\n-        BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n-        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n-            .setExpectedLocations(targets);\n+        BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n+        final BlockInfoUnderConstruction uc\n+            \u003d (BlockInfoUnderConstruction)lastBlockInFile;\n+        uc.setExpectedLocations(targets);\n         offset \u003d pendingFile.computeFileSize();\n         return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n     }\n \n     // commit the last block and complete it if it has minimum replicas\n     fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                   ExtendedBlock.getLocalBlock(previous));\n \n     // allocate new block, record block locations in INode.\n-    Block newBlock \u003d fsn.createNewBlock();\n+    final boolean isStriped \u003d pendingFile.isStriped();\n+    // allocate new block, record block locations in INode.\n+    Block newBlock \u003d fsn.createNewBlock(isStriped);\n     INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n-    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n+    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets, isStriped);\n \n     persistNewBlock(fsn, src, pendingFile);\n     offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n-    return makeLocatedBlock(fsn, newBlock, targets, offset);\n+    return makeLocatedBlock(fsn, fsn.getStoredBlock(newBlock), targets, offset);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfo lastBlockInFile \u003d pendingFile.getLastBlock();\n        final BlockInfoUnderConstruction uc\n            \u003d (BlockInfoUnderConstruction)lastBlockInFile;\n        uc.setExpectedLocations(targets);\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    final boolean isStriped \u003d pendingFile.isStriped();\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock(isStriped);\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets, isStriped);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, fsn.getStoredBlock(newBlock), targets, offset);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "e5afac5896a1a88e152746598527d91f73cbb724": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-8394. Move getAdditionalBlock() and related functionalities into a separate class. Contributed by Haohui Mai.\n",
      "commitDate": "15/05/15 7:09 PM",
      "commitName": "e5afac5896a1a88e152746598527d91f73cbb724",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-8394. Move getAdditionalBlock() and related functionalities into a separate class. Contributed by Haohui Mai.\n",
          "commitDate": "15/05/15 7:09 PM",
          "commitName": "e5afac5896a1a88e152746598527d91f73cbb724",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "15/05/15 4:14 PM",
          "commitNameOld": "8f378733423a5244461df79a92c00239514b8b93",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 0.12,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,41 @@\n-  LocatedBlock storeAllocatedBlock(String src, long fileId, String clientName,\n-      ExtendedBlock previous, DatanodeStorageInfo[] targets) throws IOException {\n-    Block newBlock \u003d null;\n+  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n+      long fileId, String clientName, ExtendedBlock previous,\n+      DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n-    checkOperation(OperationCategory.WRITE);\n-    waitForLoadingFSImage();\n-    writeLock();\n-    try {\n-      checkOperation(OperationCategory.WRITE);\n-      // Run the full analysis again, since things could have changed\n-      // while chooseTarget() was executing.\n-      LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n-      FileState fileState \u003d \n-          analyzeFileState(src, fileId, clientName, previous, onRetryBlock);\n-      final INodeFile pendingFile \u003d fileState.inode;\n-      src \u003d fileState.path;\n+    // Run the full analysis again, since things could have changed\n+    // while chooseTarget() was executing.\n+    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n+    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n+                                           previous, onRetryBlock);\n+    final INodeFile pendingFile \u003d fileState.inode;\n+    src \u003d fileState.path;\n \n-      if (onRetryBlock[0] !\u003d null) {\n-        if (onRetryBlock[0].getLocations().length \u003e 0) {\n-          // This is a retry. Just return the last block if having locations.\n-          return onRetryBlock[0];\n-        } else {\n-          // add new chosen targets to already allocated block and return\n-          BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n-          ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n-              .setExpectedLocations(targets);\n-          offset \u003d pendingFile.computeFileSize();\n-          return makeLocatedBlock(lastBlockInFile, targets, offset);\n-        }\n+    if (onRetryBlock[0] !\u003d null) {\n+      if (onRetryBlock[0].getLocations().length \u003e 0) {\n+        // This is a retry. Just return the last block if having locations.\n+        return onRetryBlock[0];\n+      } else {\n+        // add new chosen targets to already allocated block and return\n+        BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n+        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n+            .setExpectedLocations(targets);\n+        offset \u003d pendingFile.computeFileSize();\n+        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n-\n-      // commit the last block and complete it if it has minimum replicas\n-      commitOrCompleteLastBlock(pendingFile, fileState.iip,\n-                                ExtendedBlock.getLocalBlock(previous));\n-\n-      // allocate new block, record block locations in INode.\n-      newBlock \u003d createNewBlock();\n-      INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n-      saveAllocatedBlock(src, inodesInPath, newBlock, targets);\n-\n-      persistNewBlock(src, pendingFile);\n-      offset \u003d pendingFile.computeFileSize();\n-    } finally {\n-      writeUnlock();\n     }\n-    getEditLog().logSync();\n+\n+    // commit the last block and complete it if it has minimum replicas\n+    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n+                                  ExtendedBlock.getLocalBlock(previous));\n+\n+    // allocate new block, record block locations in INode.\n+    Block newBlock \u003d fsn.createNewBlock();\n+    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n+    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n+\n+    persistNewBlock(fsn, src, pendingFile);\n+    offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n-    return makeLocatedBlock(newBlock, targets, offset);\n+    return makeLocatedBlock(fsn, newBlock, targets, offset);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n            .setExpectedLocations(targets);\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock();\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, newBlock, targets, offset);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
            "oldMethodName": "storeAllocatedBlock",
            "newMethodName": "storeAllocatedBlock"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-8394. Move getAdditionalBlock() and related functionalities into a separate class. Contributed by Haohui Mai.\n",
          "commitDate": "15/05/15 7:09 PM",
          "commitName": "e5afac5896a1a88e152746598527d91f73cbb724",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "15/05/15 4:14 PM",
          "commitNameOld": "8f378733423a5244461df79a92c00239514b8b93",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 0.12,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,41 @@\n-  LocatedBlock storeAllocatedBlock(String src, long fileId, String clientName,\n-      ExtendedBlock previous, DatanodeStorageInfo[] targets) throws IOException {\n-    Block newBlock \u003d null;\n+  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n+      long fileId, String clientName, ExtendedBlock previous,\n+      DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n-    checkOperation(OperationCategory.WRITE);\n-    waitForLoadingFSImage();\n-    writeLock();\n-    try {\n-      checkOperation(OperationCategory.WRITE);\n-      // Run the full analysis again, since things could have changed\n-      // while chooseTarget() was executing.\n-      LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n-      FileState fileState \u003d \n-          analyzeFileState(src, fileId, clientName, previous, onRetryBlock);\n-      final INodeFile pendingFile \u003d fileState.inode;\n-      src \u003d fileState.path;\n+    // Run the full analysis again, since things could have changed\n+    // while chooseTarget() was executing.\n+    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n+    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n+                                           previous, onRetryBlock);\n+    final INodeFile pendingFile \u003d fileState.inode;\n+    src \u003d fileState.path;\n \n-      if (onRetryBlock[0] !\u003d null) {\n-        if (onRetryBlock[0].getLocations().length \u003e 0) {\n-          // This is a retry. Just return the last block if having locations.\n-          return onRetryBlock[0];\n-        } else {\n-          // add new chosen targets to already allocated block and return\n-          BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n-          ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n-              .setExpectedLocations(targets);\n-          offset \u003d pendingFile.computeFileSize();\n-          return makeLocatedBlock(lastBlockInFile, targets, offset);\n-        }\n+    if (onRetryBlock[0] !\u003d null) {\n+      if (onRetryBlock[0].getLocations().length \u003e 0) {\n+        // This is a retry. Just return the last block if having locations.\n+        return onRetryBlock[0];\n+      } else {\n+        // add new chosen targets to already allocated block and return\n+        BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n+        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n+            .setExpectedLocations(targets);\n+        offset \u003d pendingFile.computeFileSize();\n+        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n-\n-      // commit the last block and complete it if it has minimum replicas\n-      commitOrCompleteLastBlock(pendingFile, fileState.iip,\n-                                ExtendedBlock.getLocalBlock(previous));\n-\n-      // allocate new block, record block locations in INode.\n-      newBlock \u003d createNewBlock();\n-      INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n-      saveAllocatedBlock(src, inodesInPath, newBlock, targets);\n-\n-      persistNewBlock(src, pendingFile);\n-      offset \u003d pendingFile.computeFileSize();\n-    } finally {\n-      writeUnlock();\n     }\n-    getEditLog().logSync();\n+\n+    // commit the last block and complete it if it has minimum replicas\n+    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n+                                  ExtendedBlock.getLocalBlock(previous));\n+\n+    // allocate new block, record block locations in INode.\n+    Block newBlock \u003d fsn.createNewBlock();\n+    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n+    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n+\n+    persistNewBlock(fsn, src, pendingFile);\n+    offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n-    return makeLocatedBlock(newBlock, targets, offset);\n+    return makeLocatedBlock(fsn, newBlock, targets, offset);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n            .setExpectedLocations(targets);\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock();\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, newBlock, targets, offset);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8394. Move getAdditionalBlock() and related functionalities into a separate class. Contributed by Haohui Mai.\n",
          "commitDate": "15/05/15 7:09 PM",
          "commitName": "e5afac5896a1a88e152746598527d91f73cbb724",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "15/05/15 4:14 PM",
          "commitNameOld": "8f378733423a5244461df79a92c00239514b8b93",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 0.12,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,41 @@\n-  LocatedBlock storeAllocatedBlock(String src, long fileId, String clientName,\n-      ExtendedBlock previous, DatanodeStorageInfo[] targets) throws IOException {\n-    Block newBlock \u003d null;\n+  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n+      long fileId, String clientName, ExtendedBlock previous,\n+      DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n-    checkOperation(OperationCategory.WRITE);\n-    waitForLoadingFSImage();\n-    writeLock();\n-    try {\n-      checkOperation(OperationCategory.WRITE);\n-      // Run the full analysis again, since things could have changed\n-      // while chooseTarget() was executing.\n-      LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n-      FileState fileState \u003d \n-          analyzeFileState(src, fileId, clientName, previous, onRetryBlock);\n-      final INodeFile pendingFile \u003d fileState.inode;\n-      src \u003d fileState.path;\n+    // Run the full analysis again, since things could have changed\n+    // while chooseTarget() was executing.\n+    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n+    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n+                                           previous, onRetryBlock);\n+    final INodeFile pendingFile \u003d fileState.inode;\n+    src \u003d fileState.path;\n \n-      if (onRetryBlock[0] !\u003d null) {\n-        if (onRetryBlock[0].getLocations().length \u003e 0) {\n-          // This is a retry. Just return the last block if having locations.\n-          return onRetryBlock[0];\n-        } else {\n-          // add new chosen targets to already allocated block and return\n-          BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n-          ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n-              .setExpectedLocations(targets);\n-          offset \u003d pendingFile.computeFileSize();\n-          return makeLocatedBlock(lastBlockInFile, targets, offset);\n-        }\n+    if (onRetryBlock[0] !\u003d null) {\n+      if (onRetryBlock[0].getLocations().length \u003e 0) {\n+        // This is a retry. Just return the last block if having locations.\n+        return onRetryBlock[0];\n+      } else {\n+        // add new chosen targets to already allocated block and return\n+        BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n+        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n+            .setExpectedLocations(targets);\n+        offset \u003d pendingFile.computeFileSize();\n+        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n-\n-      // commit the last block and complete it if it has minimum replicas\n-      commitOrCompleteLastBlock(pendingFile, fileState.iip,\n-                                ExtendedBlock.getLocalBlock(previous));\n-\n-      // allocate new block, record block locations in INode.\n-      newBlock \u003d createNewBlock();\n-      INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n-      saveAllocatedBlock(src, inodesInPath, newBlock, targets);\n-\n-      persistNewBlock(src, pendingFile);\n-      offset \u003d pendingFile.computeFileSize();\n-    } finally {\n-      writeUnlock();\n     }\n-    getEditLog().logSync();\n+\n+    // commit the last block and complete it if it has minimum replicas\n+    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n+                                  ExtendedBlock.getLocalBlock(previous));\n+\n+    // allocate new block, record block locations in INode.\n+    Block newBlock \u003d fsn.createNewBlock();\n+    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n+    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n+\n+    persistNewBlock(fsn, src, pendingFile);\n+    offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n-    return makeLocatedBlock(newBlock, targets, offset);\n+    return makeLocatedBlock(fsn, newBlock, targets, offset);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n            .setExpectedLocations(targets);\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock();\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, newBlock, targets, offset);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8394. Move getAdditionalBlock() and related functionalities into a separate class. Contributed by Haohui Mai.\n",
          "commitDate": "15/05/15 7:09 PM",
          "commitName": "e5afac5896a1a88e152746598527d91f73cbb724",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "15/05/15 4:14 PM",
          "commitNameOld": "8f378733423a5244461df79a92c00239514b8b93",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 0.12,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,41 @@\n-  LocatedBlock storeAllocatedBlock(String src, long fileId, String clientName,\n-      ExtendedBlock previous, DatanodeStorageInfo[] targets) throws IOException {\n-    Block newBlock \u003d null;\n+  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n+      long fileId, String clientName, ExtendedBlock previous,\n+      DatanodeStorageInfo[] targets) throws IOException {\n     long offset;\n-    checkOperation(OperationCategory.WRITE);\n-    waitForLoadingFSImage();\n-    writeLock();\n-    try {\n-      checkOperation(OperationCategory.WRITE);\n-      // Run the full analysis again, since things could have changed\n-      // while chooseTarget() was executing.\n-      LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n-      FileState fileState \u003d \n-          analyzeFileState(src, fileId, clientName, previous, onRetryBlock);\n-      final INodeFile pendingFile \u003d fileState.inode;\n-      src \u003d fileState.path;\n+    // Run the full analysis again, since things could have changed\n+    // while chooseTarget() was executing.\n+    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n+    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n+                                           previous, onRetryBlock);\n+    final INodeFile pendingFile \u003d fileState.inode;\n+    src \u003d fileState.path;\n \n-      if (onRetryBlock[0] !\u003d null) {\n-        if (onRetryBlock[0].getLocations().length \u003e 0) {\n-          // This is a retry. Just return the last block if having locations.\n-          return onRetryBlock[0];\n-        } else {\n-          // add new chosen targets to already allocated block and return\n-          BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n-          ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n-              .setExpectedLocations(targets);\n-          offset \u003d pendingFile.computeFileSize();\n-          return makeLocatedBlock(lastBlockInFile, targets, offset);\n-        }\n+    if (onRetryBlock[0] !\u003d null) {\n+      if (onRetryBlock[0].getLocations().length \u003e 0) {\n+        // This is a retry. Just return the last block if having locations.\n+        return onRetryBlock[0];\n+      } else {\n+        // add new chosen targets to already allocated block and return\n+        BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n+        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n+            .setExpectedLocations(targets);\n+        offset \u003d pendingFile.computeFileSize();\n+        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n       }\n-\n-      // commit the last block and complete it if it has minimum replicas\n-      commitOrCompleteLastBlock(pendingFile, fileState.iip,\n-                                ExtendedBlock.getLocalBlock(previous));\n-\n-      // allocate new block, record block locations in INode.\n-      newBlock \u003d createNewBlock();\n-      INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n-      saveAllocatedBlock(src, inodesInPath, newBlock, targets);\n-\n-      persistNewBlock(src, pendingFile);\n-      offset \u003d pendingFile.computeFileSize();\n-    } finally {\n-      writeUnlock();\n     }\n-    getEditLog().logSync();\n+\n+    // commit the last block and complete it if it has minimum replicas\n+    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n+                                  ExtendedBlock.getLocalBlock(previous));\n+\n+    // allocate new block, record block locations in INode.\n+    Block newBlock \u003d fsn.createNewBlock();\n+    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n+    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n+\n+    persistNewBlock(fsn, src, pendingFile);\n+    offset \u003d pendingFile.computeFileSize();\n \n     // Return located block\n-    return makeLocatedBlock(newBlock, targets, offset);\n+    return makeLocatedBlock(fsn, newBlock, targets, offset);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static LocatedBlock storeAllocatedBlock(FSNamesystem fsn, String src,\n      long fileId, String clientName, ExtendedBlock previous,\n      DatanodeStorageInfo[] targets) throws IOException {\n    long offset;\n    // Run the full analysis again, since things could have changed\n    // while chooseTarget() was executing.\n    LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n    FileState fileState \u003d analyzeFileState(fsn, src, fileId, clientName,\n                                           previous, onRetryBlock);\n    final INodeFile pendingFile \u003d fileState.inode;\n    src \u003d fileState.path;\n\n    if (onRetryBlock[0] !\u003d null) {\n      if (onRetryBlock[0].getLocations().length \u003e 0) {\n        // This is a retry. Just return the last block if having locations.\n        return onRetryBlock[0];\n      } else {\n        // add new chosen targets to already allocated block and return\n        BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n        ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n            .setExpectedLocations(targets);\n        offset \u003d pendingFile.computeFileSize();\n        return makeLocatedBlock(fsn, lastBlockInFile, targets, offset);\n      }\n    }\n\n    // commit the last block and complete it if it has minimum replicas\n    fsn.commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                  ExtendedBlock.getLocalBlock(previous));\n\n    // allocate new block, record block locations in INode.\n    Block newBlock \u003d fsn.createNewBlock();\n    INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n    saveAllocatedBlock(fsn, src, inodesInPath, newBlock, targets);\n\n    persistNewBlock(fsn, src, pendingFile);\n    offset \u003d pendingFile.computeFileSize();\n\n    // Return located block\n    return makeLocatedBlock(fsn, newBlock, targets, offset);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[src-String, fileId-long, clientName-String, previous-ExtendedBlock, targets-DatanodeStorageInfo[]]",
            "newValue": "[fsn-FSNamesystem, src-String, fileId-long, clientName-String, previous-ExtendedBlock, targets-DatanodeStorageInfo[]]"
          }
        }
      ]
    },
    "0959b67f1a189b4a99752904115efbd471f1d6d7": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-8081. Split getAdditionalBlock() into two methods. Contributed by Konstantin Shvachko",
      "commitDate": "09/04/15 10:00 PM",
      "commitName": "0959b67f1a189b4a99752904115efbd471f1d6d7",
      "commitAuthor": "Konstantin V Shvachko",
      "diff": "@@ -0,0 +1,50 @@\n+  LocatedBlock storeAllocatedBlock(String src, long fileId, String clientName,\n+      ExtendedBlock previous, DatanodeStorageInfo[] targets) throws IOException {\n+    Block newBlock \u003d null;\n+    long offset;\n+    checkOperation(OperationCategory.WRITE);\n+    waitForLoadingFSImage();\n+    writeLock();\n+    try {\n+      checkOperation(OperationCategory.WRITE);\n+      // Run the full analysis again, since things could have changed\n+      // while chooseTarget() was executing.\n+      LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n+      FileState fileState \u003d \n+          analyzeFileState(src, fileId, clientName, previous, onRetryBlock);\n+      final INodeFile pendingFile \u003d fileState.inode;\n+      src \u003d fileState.path;\n+\n+      if (onRetryBlock[0] !\u003d null) {\n+        if (onRetryBlock[0].getLocations().length \u003e 0) {\n+          // This is a retry. Just return the last block if having locations.\n+          return onRetryBlock[0];\n+        } else {\n+          // add new chosen targets to already allocated block and return\n+          BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n+          ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n+              .setExpectedLocations(targets);\n+          offset \u003d pendingFile.computeFileSize();\n+          return makeLocatedBlock(lastBlockInFile, targets, offset);\n+        }\n+      }\n+\n+      // commit the last block and complete it if it has minimum replicas\n+      commitOrCompleteLastBlock(pendingFile, fileState.iip,\n+                                ExtendedBlock.getLocalBlock(previous));\n+\n+      // allocate new block, record block locations in INode.\n+      newBlock \u003d createNewBlock();\n+      INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n+      saveAllocatedBlock(src, inodesInPath, newBlock, targets);\n+\n+      persistNewBlock(src, pendingFile);\n+      offset \u003d pendingFile.computeFileSize();\n+    } finally {\n+      writeUnlock();\n+    }\n+    getEditLog().logSync();\n+\n+    // Return located block\n+    return makeLocatedBlock(newBlock, targets, offset);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  LocatedBlock storeAllocatedBlock(String src, long fileId, String clientName,\n      ExtendedBlock previous, DatanodeStorageInfo[] targets) throws IOException {\n    Block newBlock \u003d null;\n    long offset;\n    checkOperation(OperationCategory.WRITE);\n    waitForLoadingFSImage();\n    writeLock();\n    try {\n      checkOperation(OperationCategory.WRITE);\n      // Run the full analysis again, since things could have changed\n      // while chooseTarget() was executing.\n      LocatedBlock[] onRetryBlock \u003d new LocatedBlock[1];\n      FileState fileState \u003d \n          analyzeFileState(src, fileId, clientName, previous, onRetryBlock);\n      final INodeFile pendingFile \u003d fileState.inode;\n      src \u003d fileState.path;\n\n      if (onRetryBlock[0] !\u003d null) {\n        if (onRetryBlock[0].getLocations().length \u003e 0) {\n          // This is a retry. Just return the last block if having locations.\n          return onRetryBlock[0];\n        } else {\n          // add new chosen targets to already allocated block and return\n          BlockInfoContiguous lastBlockInFile \u003d pendingFile.getLastBlock();\n          ((BlockInfoContiguousUnderConstruction) lastBlockInFile)\n              .setExpectedLocations(targets);\n          offset \u003d pendingFile.computeFileSize();\n          return makeLocatedBlock(lastBlockInFile, targets, offset);\n        }\n      }\n\n      // commit the last block and complete it if it has minimum replicas\n      commitOrCompleteLastBlock(pendingFile, fileState.iip,\n                                ExtendedBlock.getLocalBlock(previous));\n\n      // allocate new block, record block locations in INode.\n      newBlock \u003d createNewBlock();\n      INodesInPath inodesInPath \u003d INodesInPath.fromINode(pendingFile);\n      saveAllocatedBlock(src, inodesInPath, newBlock, targets);\n\n      persistNewBlock(src, pendingFile);\n      offset \u003d pendingFile.computeFileSize();\n    } finally {\n      writeUnlock();\n    }\n    getEditLog().logSync();\n\n    // Return located block\n    return makeLocatedBlock(newBlock, targets, offset);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
    }
  }
}