{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LeveldbTimelineStore.java",
  "functionName": "put",
  "functionId": "put___entity-TimelineEntity__response-TimelinePutResponse__allowEmptyDomainId-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
  "functionStartLine": 774,
  "functionEndLine": 968,
  "numCommitsSeen": 28,
  "timeTaken": 4420,
  "changeHistory": [
    "839e077faf4019d6efdcd89d95930023cd0b0a08",
    "a4aa1cb40504299d3401008fdabc795eafb28713",
    "1a78c0ff016097930edf68e8278f826b637e918c",
    "241d3b3a50c6af92f023d8b2c24598f4813f4674",
    "1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1",
    "4a114dd67aae83e5bb2d65470166de954acf36a2",
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
    "0f1eda6bbf895a1239b25cdf8b17fabd3759e806",
    "b3ea4aebff42131642af0393748dc751cb3fc31e",
    "40464fba22bac99d0e5b79674152aa5dfba99483",
    "84425fb435cb603fd8adcc2f76631c0244175310"
  ],
  "changeHistoryShort": {
    "839e077faf4019d6efdcd89d95930023cd0b0a08": "Ybodychange",
    "a4aa1cb40504299d3401008fdabc795eafb28713": "Ybodychange",
    "1a78c0ff016097930edf68e8278f826b637e918c": "Ybodychange",
    "241d3b3a50c6af92f023d8b2c24598f4813f4674": "Ybodychange",
    "1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1": "Ybodychange",
    "4a114dd67aae83e5bb2d65470166de954acf36a2": "Ymultichange(Yparameterchange,Ybodychange)",
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614": "Ybodychange",
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c": "Yfilerename",
    "0f1eda6bbf895a1239b25cdf8b17fabd3759e806": "Ybodychange",
    "b3ea4aebff42131642af0393748dc751cb3fc31e": "Ybodychange",
    "40464fba22bac99d0e5b79674152aa5dfba99483": "Ybodychange",
    "84425fb435cb603fd8adcc2f76631c0244175310": "Yintroduced"
  },
  "changeHistoryDetails": {
    "839e077faf4019d6efdcd89d95930023cd0b0a08": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6873. Moving logging APIs over to slf4j in hadoop-yarn-server-applicationhistoryservice. Contributed by Yeliang Cang.\n",
      "commitDate": "07/08/17 2:56 AM",
      "commitName": "839e077faf4019d6efdcd89d95930023cd0b0a08",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "31/07/17 8:15 PM",
      "commitNameOld": "a4aa1cb40504299d3401008fdabc795eafb28713",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 6.28,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private void put(TimelineEntity entity, TimelinePutResponse response,\n       boolean allowEmptyDomainId) {\n     LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n         writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n             entity.getEntityType()));\n     lock.lock();\n     WriteBatch writeBatch \u003d null;\n     List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n         new ArrayList\u003cEntityIdentifier\u003e();\n     byte[] revStartTime \u003d null;\n     Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n     try {\n       writeBatch \u003d db.createWriteBatch();\n       List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n       // look up the start time for the entity\n       StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n           entity.getEntityId(), entity.getEntityType(),\n           entity.getStartTime(), events);\n       if (startAndInsertTime \u003d\u003d null) {\n         // if no start time is found, add an error and return\n         handleError(entity, response, TimelinePutError.NO_START_TIME);   \n         return;\n       }\n       revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n           .startTime);\n \n       primaryFilters \u003d entity.getPrimaryFilters();\n \n       // write entity marker\n       byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n           .insertTime);\n       writeBatch.put(markerKey, markerValue);\n       writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n           markerValue);\n \n       // write event entries\n       if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n         for (TimelineEvent event : events) {\n           byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n           byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, revts,\n               event.getEventType());\n           byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write related entity entries\n       Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n           entity.getRelatedEntities();\n       if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n         for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n             relatedEntities.entrySet()) {\n           String relatedEntityType \u003d relatedEntityList.getKey();\n           for (String relatedEntityId : relatedEntityList.getValue()) {\n             // invisible \"reverse\" entries (entity -\u003e related entity)\n             byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime, relatedEntityId,\n                 relatedEntityType);\n             writeBatch.put(key, EMPTY_BYTES);\n             // look up start time of related entity\n             byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                 relatedEntityType);\n             // delay writing the related entity if no start time is found\n             if (relatedEntityStartTime \u003d\u003d null) {\n               relatedEntitiesWithoutStartTimes.add(\n                   new EntityIdentifier(relatedEntityId, relatedEntityType));\n               continue;\n             } else {\n               // This is the existing entity\n               byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                   relatedEntityId, relatedEntityType, relatedEntityStartTime));\n               // The timeline data created by the server before 2.6 won\u0027t have\n               // the domain field. We assume this timeline data is in the\n               // default timeline domain.\n               String domainId \u003d null;\n               if (domainIdBytes \u003d\u003d null) {\n                 domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n               } else {\n                 domainId \u003d new String(domainIdBytes, Charset.forName(\"UTF-8\"));\n               }\n               if (!domainId.equals(entity.getDomainId())) {\n                 // in this case the entity will be put, but the relation will be\n                 // ignored\n                 handleError(entity, response, TimelinePutError.FORBIDDEN_RELATION);\n                 continue;\n               }\n             }\n             // write \"forward\" entry (related entity -\u003e entity)\n             key \u003d createRelatedEntityKey(relatedEntityId,\n                 relatedEntityType, relatedEntityStartTime,\n                 entity.getEntityId(), entity.getEntityType());\n             writeBatch.put(key, EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write primary filter entries\n       if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n             primaryFilters.entrySet()) {\n           for (Object primaryFilterValue : primaryFilter.getValue()) {\n             byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime,\n                 primaryFilter.getKey(), primaryFilterValue);\n             writeBatch.put(key, EMPTY_BYTES);\n             writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                 EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write other info entries\n       Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n       if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n         for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n           byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, i.getKey());\n           byte[] value \u003d GenericObjectMapper.write(i.getValue());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write domain id entry\n       byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       if (entity.getDomainId() \u003d\u003d null ||\n           entity.getDomainId().length() \u003d\u003d 0) {\n         if (!allowEmptyDomainId) {\n           handleError(entity, response, TimelinePutError.NO_DOMAIN);\n           return;\n         }\n       } else {\n         writeBatch.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n         writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n             entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n       }\n       db.write(writeBatch);\n     } catch (DBException de) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n                 \" of type \" + entity.getEntityType(), de);\n       handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n     } catch (IOException e) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n           \" of type \" + entity.getEntityType(), e);\n       handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n     } finally {\n       lock.unlock();\n       writeLocks.returnLock(lock);\n-      IOUtils.cleanup(LOG, writeBatch);\n+      IOUtils.cleanupWithLogger(LOG, writeBatch);\n     }\n \n     for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n       lock \u003d writeLocks.getLock(relatedEntity);\n       lock.lock();\n       try {\n         StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n             getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n             readReverseOrderedLong(revStartTime, 0), null);\n         if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n           throw new IOException(\"Error setting start time for related entity\");\n         }\n         byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n             relatedEntityStartAndInsertTime.startTime);\n           // This is the new entity, the domain should be the same\n         byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime);\n         db.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n         db.put(createRelatedEntityKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime,\n             entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n         db.put(createEntityMarkerKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime),\n             writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                 .insertTime));\n       } catch (DBException de) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), de);\n         handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n       } catch (IOException e) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n         handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n       } finally {\n         lock.unlock();\n         writeLocks.returnLock(lock);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response,\n      boolean allowEmptyDomainId) {\n    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch \u003d null;\n    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n        new ArrayList\u003cEntityIdentifier\u003e();\n    byte[] revStartTime \u003d null;\n    Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n          entity.getEntityId(), entity.getEntityType(),\n          entity.getStartTime(), events);\n      if (startAndInsertTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        handleError(entity, response, TimelinePutError.NO_START_TIME);   \n        return;\n      }\n      revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n          .startTime);\n\n      primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write entity marker\n      byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n          .insertTime);\n      writeBatch.put(markerKey, markerValue);\n      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n          markerValue);\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -\u003e related entity)\n            byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime \u003d\u003d null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            } else {\n              // This is the existing entity\n              byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                  relatedEntityId, relatedEntityType, relatedEntityStartTime));\n              // The timeline data created by the server before 2.6 won\u0027t have\n              // the domain field. We assume this timeline data is in the\n              // default timeline domain.\n              String domainId \u003d null;\n              if (domainIdBytes \u003d\u003d null) {\n                domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n              } else {\n                domainId \u003d new String(domainIdBytes, Charset.forName(\"UTF-8\"));\n              }\n              if (!domainId.equals(entity.getDomainId())) {\n                // in this case the entity will be put, but the relation will be\n                // ignored\n                handleError(entity, response, TimelinePutError.FORBIDDEN_RELATION);\n                continue;\n              }\n            }\n            // write \"forward\" entry (related entity -\u003e entity)\n            key \u003d createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write domain id entry\n      byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      if (entity.getDomainId() \u003d\u003d null ||\n          entity.getDomainId().length() \u003d\u003d 0) {\n        if (!allowEmptyDomainId) {\n          handleError(entity, response, TimelinePutError.NO_DOMAIN);\n          return;\n        }\n      } else {\n        writeBatch.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n        writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n            entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n      }\n      db.write(writeBatch);\n    } catch (DBException de) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n                \" of type \" + entity.getEntityType(), de);\n      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanupWithLogger(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock \u003d writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n            relatedEntityStartAndInsertTime.startTime);\n          // This is the new entity, the domain should be the same\n        byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime);\n        db.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime),\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                .insertTime));\n      } catch (DBException de) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), de);\n        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "a4aa1cb40504299d3401008fdabc795eafb28713": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-6873. Moving logging APIs over to slf4j in hadoop-yarn-server-applicationhistoryservice. Contributed by Yeliang Cang.\"\n\nThis reverts commit 1a78c0ff016097930edf68e8278f826b637e918c.\n",
      "commitDate": "31/07/17 8:15 PM",
      "commitName": "a4aa1cb40504299d3401008fdabc795eafb28713",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "31/07/17 6:53 PM",
      "commitNameOld": "1a78c0ff016097930edf68e8278f826b637e918c",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private void put(TimelineEntity entity, TimelinePutResponse response,\n       boolean allowEmptyDomainId) {\n     LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n         writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n             entity.getEntityType()));\n     lock.lock();\n     WriteBatch writeBatch \u003d null;\n     List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n         new ArrayList\u003cEntityIdentifier\u003e();\n     byte[] revStartTime \u003d null;\n     Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n     try {\n       writeBatch \u003d db.createWriteBatch();\n       List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n       // look up the start time for the entity\n       StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n           entity.getEntityId(), entity.getEntityType(),\n           entity.getStartTime(), events);\n       if (startAndInsertTime \u003d\u003d null) {\n         // if no start time is found, add an error and return\n         handleError(entity, response, TimelinePutError.NO_START_TIME);   \n         return;\n       }\n       revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n           .startTime);\n \n       primaryFilters \u003d entity.getPrimaryFilters();\n \n       // write entity marker\n       byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n           .insertTime);\n       writeBatch.put(markerKey, markerValue);\n       writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n           markerValue);\n \n       // write event entries\n       if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n         for (TimelineEvent event : events) {\n           byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n           byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, revts,\n               event.getEventType());\n           byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write related entity entries\n       Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n           entity.getRelatedEntities();\n       if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n         for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n             relatedEntities.entrySet()) {\n           String relatedEntityType \u003d relatedEntityList.getKey();\n           for (String relatedEntityId : relatedEntityList.getValue()) {\n             // invisible \"reverse\" entries (entity -\u003e related entity)\n             byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime, relatedEntityId,\n                 relatedEntityType);\n             writeBatch.put(key, EMPTY_BYTES);\n             // look up start time of related entity\n             byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                 relatedEntityType);\n             // delay writing the related entity if no start time is found\n             if (relatedEntityStartTime \u003d\u003d null) {\n               relatedEntitiesWithoutStartTimes.add(\n                   new EntityIdentifier(relatedEntityId, relatedEntityType));\n               continue;\n             } else {\n               // This is the existing entity\n               byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                   relatedEntityId, relatedEntityType, relatedEntityStartTime));\n               // The timeline data created by the server before 2.6 won\u0027t have\n               // the domain field. We assume this timeline data is in the\n               // default timeline domain.\n               String domainId \u003d null;\n               if (domainIdBytes \u003d\u003d null) {\n                 domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n               } else {\n                 domainId \u003d new String(domainIdBytes, Charset.forName(\"UTF-8\"));\n               }\n               if (!domainId.equals(entity.getDomainId())) {\n                 // in this case the entity will be put, but the relation will be\n                 // ignored\n                 handleError(entity, response, TimelinePutError.FORBIDDEN_RELATION);\n                 continue;\n               }\n             }\n             // write \"forward\" entry (related entity -\u003e entity)\n             key \u003d createRelatedEntityKey(relatedEntityId,\n                 relatedEntityType, relatedEntityStartTime,\n                 entity.getEntityId(), entity.getEntityType());\n             writeBatch.put(key, EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write primary filter entries\n       if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n             primaryFilters.entrySet()) {\n           for (Object primaryFilterValue : primaryFilter.getValue()) {\n             byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime,\n                 primaryFilter.getKey(), primaryFilterValue);\n             writeBatch.put(key, EMPTY_BYTES);\n             writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                 EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write other info entries\n       Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n       if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n         for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n           byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, i.getKey());\n           byte[] value \u003d GenericObjectMapper.write(i.getValue());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write domain id entry\n       byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       if (entity.getDomainId() \u003d\u003d null ||\n           entity.getDomainId().length() \u003d\u003d 0) {\n         if (!allowEmptyDomainId) {\n           handleError(entity, response, TimelinePutError.NO_DOMAIN);\n           return;\n         }\n       } else {\n         writeBatch.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n         writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n             entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n       }\n       db.write(writeBatch);\n     } catch (DBException de) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n                 \" of type \" + entity.getEntityType(), de);\n       handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n     } catch (IOException e) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n           \" of type \" + entity.getEntityType(), e);\n       handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n     } finally {\n       lock.unlock();\n       writeLocks.returnLock(lock);\n-      IOUtils.cleanupWithLogger(LOG, writeBatch);\n+      IOUtils.cleanup(LOG, writeBatch);\n     }\n \n     for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n       lock \u003d writeLocks.getLock(relatedEntity);\n       lock.lock();\n       try {\n         StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n             getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n             readReverseOrderedLong(revStartTime, 0), null);\n         if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n           throw new IOException(\"Error setting start time for related entity\");\n         }\n         byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n             relatedEntityStartAndInsertTime.startTime);\n           // This is the new entity, the domain should be the same\n         byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime);\n         db.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n         db.put(createRelatedEntityKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime,\n             entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n         db.put(createEntityMarkerKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime),\n             writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                 .insertTime));\n       } catch (DBException de) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), de);\n         handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n       } catch (IOException e) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n         handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n       } finally {\n         lock.unlock();\n         writeLocks.returnLock(lock);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response,\n      boolean allowEmptyDomainId) {\n    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch \u003d null;\n    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n        new ArrayList\u003cEntityIdentifier\u003e();\n    byte[] revStartTime \u003d null;\n    Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n          entity.getEntityId(), entity.getEntityType(),\n          entity.getStartTime(), events);\n      if (startAndInsertTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        handleError(entity, response, TimelinePutError.NO_START_TIME);   \n        return;\n      }\n      revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n          .startTime);\n\n      primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write entity marker\n      byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n          .insertTime);\n      writeBatch.put(markerKey, markerValue);\n      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n          markerValue);\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -\u003e related entity)\n            byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime \u003d\u003d null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            } else {\n              // This is the existing entity\n              byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                  relatedEntityId, relatedEntityType, relatedEntityStartTime));\n              // The timeline data created by the server before 2.6 won\u0027t have\n              // the domain field. We assume this timeline data is in the\n              // default timeline domain.\n              String domainId \u003d null;\n              if (domainIdBytes \u003d\u003d null) {\n                domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n              } else {\n                domainId \u003d new String(domainIdBytes, Charset.forName(\"UTF-8\"));\n              }\n              if (!domainId.equals(entity.getDomainId())) {\n                // in this case the entity will be put, but the relation will be\n                // ignored\n                handleError(entity, response, TimelinePutError.FORBIDDEN_RELATION);\n                continue;\n              }\n            }\n            // write \"forward\" entry (related entity -\u003e entity)\n            key \u003d createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write domain id entry\n      byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      if (entity.getDomainId() \u003d\u003d null ||\n          entity.getDomainId().length() \u003d\u003d 0) {\n        if (!allowEmptyDomainId) {\n          handleError(entity, response, TimelinePutError.NO_DOMAIN);\n          return;\n        }\n      } else {\n        writeBatch.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n        writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n            entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n      }\n      db.write(writeBatch);\n    } catch (DBException de) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n                \" of type \" + entity.getEntityType(), de);\n      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock \u003d writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n            relatedEntityStartAndInsertTime.startTime);\n          // This is the new entity, the domain should be the same\n        byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime);\n        db.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime),\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                .insertTime));\n      } catch (DBException de) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), de);\n        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "1a78c0ff016097930edf68e8278f826b637e918c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6873. Moving logging APIs over to slf4j in hadoop-yarn-server-applicationhistoryservice. Contributed by Yeliang Cang.\n",
      "commitDate": "31/07/17 6:53 PM",
      "commitName": "1a78c0ff016097930edf68e8278f826b637e918c",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "10/01/17 2:24 AM",
      "commitNameOld": "4c431a694059e40e78365b02a1497a6c7e479a70",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 202.65,
      "commitsBetweenForRepo": 1063,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private void put(TimelineEntity entity, TimelinePutResponse response,\n       boolean allowEmptyDomainId) {\n     LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n         writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n             entity.getEntityType()));\n     lock.lock();\n     WriteBatch writeBatch \u003d null;\n     List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n         new ArrayList\u003cEntityIdentifier\u003e();\n     byte[] revStartTime \u003d null;\n     Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n     try {\n       writeBatch \u003d db.createWriteBatch();\n       List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n       // look up the start time for the entity\n       StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n           entity.getEntityId(), entity.getEntityType(),\n           entity.getStartTime(), events);\n       if (startAndInsertTime \u003d\u003d null) {\n         // if no start time is found, add an error and return\n         handleError(entity, response, TimelinePutError.NO_START_TIME);   \n         return;\n       }\n       revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n           .startTime);\n \n       primaryFilters \u003d entity.getPrimaryFilters();\n \n       // write entity marker\n       byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n           .insertTime);\n       writeBatch.put(markerKey, markerValue);\n       writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n           markerValue);\n \n       // write event entries\n       if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n         for (TimelineEvent event : events) {\n           byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n           byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, revts,\n               event.getEventType());\n           byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write related entity entries\n       Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n           entity.getRelatedEntities();\n       if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n         for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n             relatedEntities.entrySet()) {\n           String relatedEntityType \u003d relatedEntityList.getKey();\n           for (String relatedEntityId : relatedEntityList.getValue()) {\n             // invisible \"reverse\" entries (entity -\u003e related entity)\n             byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime, relatedEntityId,\n                 relatedEntityType);\n             writeBatch.put(key, EMPTY_BYTES);\n             // look up start time of related entity\n             byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                 relatedEntityType);\n             // delay writing the related entity if no start time is found\n             if (relatedEntityStartTime \u003d\u003d null) {\n               relatedEntitiesWithoutStartTimes.add(\n                   new EntityIdentifier(relatedEntityId, relatedEntityType));\n               continue;\n             } else {\n               // This is the existing entity\n               byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                   relatedEntityId, relatedEntityType, relatedEntityStartTime));\n               // The timeline data created by the server before 2.6 won\u0027t have\n               // the domain field. We assume this timeline data is in the\n               // default timeline domain.\n               String domainId \u003d null;\n               if (domainIdBytes \u003d\u003d null) {\n                 domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n               } else {\n                 domainId \u003d new String(domainIdBytes, Charset.forName(\"UTF-8\"));\n               }\n               if (!domainId.equals(entity.getDomainId())) {\n                 // in this case the entity will be put, but the relation will be\n                 // ignored\n                 handleError(entity, response, TimelinePutError.FORBIDDEN_RELATION);\n                 continue;\n               }\n             }\n             // write \"forward\" entry (related entity -\u003e entity)\n             key \u003d createRelatedEntityKey(relatedEntityId,\n                 relatedEntityType, relatedEntityStartTime,\n                 entity.getEntityId(), entity.getEntityType());\n             writeBatch.put(key, EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write primary filter entries\n       if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n             primaryFilters.entrySet()) {\n           for (Object primaryFilterValue : primaryFilter.getValue()) {\n             byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime,\n                 primaryFilter.getKey(), primaryFilterValue);\n             writeBatch.put(key, EMPTY_BYTES);\n             writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                 EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write other info entries\n       Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n       if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n         for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n           byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, i.getKey());\n           byte[] value \u003d GenericObjectMapper.write(i.getValue());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write domain id entry\n       byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       if (entity.getDomainId() \u003d\u003d null ||\n           entity.getDomainId().length() \u003d\u003d 0) {\n         if (!allowEmptyDomainId) {\n           handleError(entity, response, TimelinePutError.NO_DOMAIN);\n           return;\n         }\n       } else {\n         writeBatch.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n         writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n             entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n       }\n       db.write(writeBatch);\n     } catch (DBException de) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n                 \" of type \" + entity.getEntityType(), de);\n       handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n     } catch (IOException e) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n           \" of type \" + entity.getEntityType(), e);\n       handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n     } finally {\n       lock.unlock();\n       writeLocks.returnLock(lock);\n-      IOUtils.cleanup(LOG, writeBatch);\n+      IOUtils.cleanupWithLogger(LOG, writeBatch);\n     }\n \n     for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n       lock \u003d writeLocks.getLock(relatedEntity);\n       lock.lock();\n       try {\n         StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n             getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n             readReverseOrderedLong(revStartTime, 0), null);\n         if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n           throw new IOException(\"Error setting start time for related entity\");\n         }\n         byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n             relatedEntityStartAndInsertTime.startTime);\n           // This is the new entity, the domain should be the same\n         byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime);\n         db.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n         db.put(createRelatedEntityKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime,\n             entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n         db.put(createEntityMarkerKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime),\n             writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                 .insertTime));\n       } catch (DBException de) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), de);\n         handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n       } catch (IOException e) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n         handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n       } finally {\n         lock.unlock();\n         writeLocks.returnLock(lock);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response,\n      boolean allowEmptyDomainId) {\n    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch \u003d null;\n    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n        new ArrayList\u003cEntityIdentifier\u003e();\n    byte[] revStartTime \u003d null;\n    Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n          entity.getEntityId(), entity.getEntityType(),\n          entity.getStartTime(), events);\n      if (startAndInsertTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        handleError(entity, response, TimelinePutError.NO_START_TIME);   \n        return;\n      }\n      revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n          .startTime);\n\n      primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write entity marker\n      byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n          .insertTime);\n      writeBatch.put(markerKey, markerValue);\n      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n          markerValue);\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -\u003e related entity)\n            byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime \u003d\u003d null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            } else {\n              // This is the existing entity\n              byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                  relatedEntityId, relatedEntityType, relatedEntityStartTime));\n              // The timeline data created by the server before 2.6 won\u0027t have\n              // the domain field. We assume this timeline data is in the\n              // default timeline domain.\n              String domainId \u003d null;\n              if (domainIdBytes \u003d\u003d null) {\n                domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n              } else {\n                domainId \u003d new String(domainIdBytes, Charset.forName(\"UTF-8\"));\n              }\n              if (!domainId.equals(entity.getDomainId())) {\n                // in this case the entity will be put, but the relation will be\n                // ignored\n                handleError(entity, response, TimelinePutError.FORBIDDEN_RELATION);\n                continue;\n              }\n            }\n            // write \"forward\" entry (related entity -\u003e entity)\n            key \u003d createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write domain id entry\n      byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      if (entity.getDomainId() \u003d\u003d null ||\n          entity.getDomainId().length() \u003d\u003d 0) {\n        if (!allowEmptyDomainId) {\n          handleError(entity, response, TimelinePutError.NO_DOMAIN);\n          return;\n        }\n      } else {\n        writeBatch.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n        writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n            entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n      }\n      db.write(writeBatch);\n    } catch (DBException de) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n                \" of type \" + entity.getEntityType(), de);\n      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanupWithLogger(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock \u003d writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n            relatedEntityStartAndInsertTime.startTime);\n          // This is the new entity, the domain should be the same\n        byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime);\n        db.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime),\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                .insertTime));\n      } catch (DBException de) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), de);\n        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "241d3b3a50c6af92f023d8b2c24598f4813f4674": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2938. Fixed new findbugs warnings in hadoop-yarn-resourcemanager and hadoop-yarn-applicationhistoryservice. Contributed by Varun Saxena.\n",
      "commitDate": "29/12/14 9:59 AM",
      "commitName": "241d3b3a50c6af92f023d8b2c24598f4813f4674",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "23/12/14 6:25 PM",
      "commitNameOld": "149512a83743715bb100feb6747b7e88301018ab",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 5.65,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private void put(TimelineEntity entity, TimelinePutResponse response,\n       boolean allowEmptyDomainId) {\n     LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n         writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n             entity.getEntityType()));\n     lock.lock();\n     WriteBatch writeBatch \u003d null;\n     List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n         new ArrayList\u003cEntityIdentifier\u003e();\n     byte[] revStartTime \u003d null;\n     Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n     try {\n       writeBatch \u003d db.createWriteBatch();\n       List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n       // look up the start time for the entity\n       StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n           entity.getEntityId(), entity.getEntityType(),\n           entity.getStartTime(), events);\n       if (startAndInsertTime \u003d\u003d null) {\n         // if no start time is found, add an error and return\n         handleError(entity, response, TimelinePutError.NO_START_TIME);   \n         return;\n       }\n       revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n           .startTime);\n \n       primaryFilters \u003d entity.getPrimaryFilters();\n \n       // write entity marker\n       byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n           .insertTime);\n       writeBatch.put(markerKey, markerValue);\n       writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n           markerValue);\n \n       // write event entries\n       if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n         for (TimelineEvent event : events) {\n           byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n           byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, revts,\n               event.getEventType());\n           byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write related entity entries\n       Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n           entity.getRelatedEntities();\n       if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n         for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n             relatedEntities.entrySet()) {\n           String relatedEntityType \u003d relatedEntityList.getKey();\n           for (String relatedEntityId : relatedEntityList.getValue()) {\n             // invisible \"reverse\" entries (entity -\u003e related entity)\n             byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime, relatedEntityId,\n                 relatedEntityType);\n             writeBatch.put(key, EMPTY_BYTES);\n             // look up start time of related entity\n             byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                 relatedEntityType);\n             // delay writing the related entity if no start time is found\n             if (relatedEntityStartTime \u003d\u003d null) {\n               relatedEntitiesWithoutStartTimes.add(\n                   new EntityIdentifier(relatedEntityId, relatedEntityType));\n               continue;\n             } else {\n               // This is the existing entity\n               byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                   relatedEntityId, relatedEntityType, relatedEntityStartTime));\n               // The timeline data created by the server before 2.6 won\u0027t have\n               // the domain field. We assume this timeline data is in the\n               // default timeline domain.\n               String domainId \u003d null;\n               if (domainIdBytes \u003d\u003d null) {\n                 domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n               } else {\n-                domainId \u003d new String(domainIdBytes);\n+                domainId \u003d new String(domainIdBytes, Charset.forName(\"UTF-8\"));\n               }\n               if (!domainId.equals(entity.getDomainId())) {\n                 // in this case the entity will be put, but the relation will be\n                 // ignored\n                 handleError(entity, response, TimelinePutError.FORBIDDEN_RELATION);\n                 continue;\n               }\n             }\n             // write \"forward\" entry (related entity -\u003e entity)\n             key \u003d createRelatedEntityKey(relatedEntityId,\n                 relatedEntityType, relatedEntityStartTime,\n                 entity.getEntityId(), entity.getEntityType());\n             writeBatch.put(key, EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write primary filter entries\n       if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n             primaryFilters.entrySet()) {\n           for (Object primaryFilterValue : primaryFilter.getValue()) {\n             byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime,\n                 primaryFilter.getKey(), primaryFilterValue);\n             writeBatch.put(key, EMPTY_BYTES);\n             writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                 EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write other info entries\n       Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n       if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n         for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n           byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, i.getKey());\n           byte[] value \u003d GenericObjectMapper.write(i.getValue());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write domain id entry\n       byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       if (entity.getDomainId() \u003d\u003d null ||\n           entity.getDomainId().length() \u003d\u003d 0) {\n         if (!allowEmptyDomainId) {\n           handleError(entity, response, TimelinePutError.NO_DOMAIN);\n           return;\n         }\n       } else {\n-        writeBatch.put(key, entity.getDomainId().getBytes());\n+        writeBatch.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n         writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n-            entity.getDomainId().getBytes());\n+            entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n       }\n       db.write(writeBatch);\n     } catch (DBException de) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n                 \" of type \" + entity.getEntityType(), de);\n       handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n     } catch (IOException e) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n           \" of type \" + entity.getEntityType(), e);\n       handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n     } finally {\n       lock.unlock();\n       writeLocks.returnLock(lock);\n       IOUtils.cleanup(LOG, writeBatch);\n     }\n \n     for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n       lock \u003d writeLocks.getLock(relatedEntity);\n       lock.lock();\n       try {\n         StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n             getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n             readReverseOrderedLong(revStartTime, 0), null);\n         if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n           throw new IOException(\"Error setting start time for related entity\");\n         }\n         byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n             relatedEntityStartAndInsertTime.startTime);\n           // This is the new entity, the domain should be the same\n         byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime);\n-        db.put(key, entity.getDomainId().getBytes());\n+        db.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n         db.put(createRelatedEntityKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime,\n             entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n         db.put(createEntityMarkerKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime),\n             writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                 .insertTime));\n       } catch (DBException de) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), de);\n         handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n       } catch (IOException e) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n         handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n       } finally {\n         lock.unlock();\n         writeLocks.returnLock(lock);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response,\n      boolean allowEmptyDomainId) {\n    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch \u003d null;\n    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n        new ArrayList\u003cEntityIdentifier\u003e();\n    byte[] revStartTime \u003d null;\n    Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n          entity.getEntityId(), entity.getEntityType(),\n          entity.getStartTime(), events);\n      if (startAndInsertTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        handleError(entity, response, TimelinePutError.NO_START_TIME);   \n        return;\n      }\n      revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n          .startTime);\n\n      primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write entity marker\n      byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n          .insertTime);\n      writeBatch.put(markerKey, markerValue);\n      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n          markerValue);\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -\u003e related entity)\n            byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime \u003d\u003d null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            } else {\n              // This is the existing entity\n              byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                  relatedEntityId, relatedEntityType, relatedEntityStartTime));\n              // The timeline data created by the server before 2.6 won\u0027t have\n              // the domain field. We assume this timeline data is in the\n              // default timeline domain.\n              String domainId \u003d null;\n              if (domainIdBytes \u003d\u003d null) {\n                domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n              } else {\n                domainId \u003d new String(domainIdBytes, Charset.forName(\"UTF-8\"));\n              }\n              if (!domainId.equals(entity.getDomainId())) {\n                // in this case the entity will be put, but the relation will be\n                // ignored\n                handleError(entity, response, TimelinePutError.FORBIDDEN_RELATION);\n                continue;\n              }\n            }\n            // write \"forward\" entry (related entity -\u003e entity)\n            key \u003d createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write domain id entry\n      byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      if (entity.getDomainId() \u003d\u003d null ||\n          entity.getDomainId().length() \u003d\u003d 0) {\n        if (!allowEmptyDomainId) {\n          handleError(entity, response, TimelinePutError.NO_DOMAIN);\n          return;\n        }\n      } else {\n        writeBatch.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n        writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n            entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n      }\n      db.write(writeBatch);\n    } catch (DBException de) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n                \" of type \" + entity.getEntityType(), de);\n      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock \u003d writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n            relatedEntityStartAndInsertTime.startTime);\n          // This is the new entity, the domain should be the same\n        byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime);\n        db.put(key, entity.getDomainId().getBytes(Charset.forName(\"UTF-8\")));\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime),\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                .insertTime));\n      } catch (DBException de) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), de);\n        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1984. LeveldbTimelineStore does not handle db exceptions properly. Contributed by Varun Saxena\n",
      "commitDate": "24/11/14 2:36 PM",
      "commitName": "1ce4d33c2dc86d711b227a04d2f9a2ab696a24a1",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "07/11/14 4:11 PM",
      "commitNameOld": "4a114dd67aae83e5bb2d65470166de954acf36a2",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 16.93,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,206 +1,195 @@\n   private void put(TimelineEntity entity, TimelinePutResponse response,\n       boolean allowEmptyDomainId) {\n     LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n         writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n             entity.getEntityType()));\n     lock.lock();\n     WriteBatch writeBatch \u003d null;\n     List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n         new ArrayList\u003cEntityIdentifier\u003e();\n     byte[] revStartTime \u003d null;\n     Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n     try {\n       writeBatch \u003d db.createWriteBatch();\n       List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n       // look up the start time for the entity\n       StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n           entity.getEntityId(), entity.getEntityType(),\n           entity.getStartTime(), events);\n       if (startAndInsertTime \u003d\u003d null) {\n         // if no start time is found, add an error and return\n-        TimelinePutError error \u003d new TimelinePutError();\n-        error.setEntityId(entity.getEntityId());\n-        error.setEntityType(entity.getEntityType());\n-        error.setErrorCode(TimelinePutError.NO_START_TIME);\n-        response.addError(error);\n+        handleError(entity, response, TimelinePutError.NO_START_TIME);   \n         return;\n       }\n       revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n           .startTime);\n \n       primaryFilters \u003d entity.getPrimaryFilters();\n \n       // write entity marker\n       byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n           .insertTime);\n       writeBatch.put(markerKey, markerValue);\n       writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n           markerValue);\n \n       // write event entries\n       if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n         for (TimelineEvent event : events) {\n           byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n           byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, revts,\n               event.getEventType());\n           byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write related entity entries\n       Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n           entity.getRelatedEntities();\n       if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n         for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n             relatedEntities.entrySet()) {\n           String relatedEntityType \u003d relatedEntityList.getKey();\n           for (String relatedEntityId : relatedEntityList.getValue()) {\n             // invisible \"reverse\" entries (entity -\u003e related entity)\n             byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime, relatedEntityId,\n                 relatedEntityType);\n             writeBatch.put(key, EMPTY_BYTES);\n             // look up start time of related entity\n             byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                 relatedEntityType);\n             // delay writing the related entity if no start time is found\n             if (relatedEntityStartTime \u003d\u003d null) {\n               relatedEntitiesWithoutStartTimes.add(\n                   new EntityIdentifier(relatedEntityId, relatedEntityType));\n               continue;\n             } else {\n               // This is the existing entity\n               byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                   relatedEntityId, relatedEntityType, relatedEntityStartTime));\n               // The timeline data created by the server before 2.6 won\u0027t have\n               // the domain field. We assume this timeline data is in the\n               // default timeline domain.\n               String domainId \u003d null;\n               if (domainIdBytes \u003d\u003d null) {\n                 domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n               } else {\n                 domainId \u003d new String(domainIdBytes);\n               }\n               if (!domainId.equals(entity.getDomainId())) {\n                 // in this case the entity will be put, but the relation will be\n                 // ignored\n-                TimelinePutError error \u003d new TimelinePutError();\n-                error.setEntityId(entity.getEntityId());\n-                error.setEntityType(entity.getEntityType());\n-                error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n-                response.addError(error);\n+                handleError(entity, response, TimelinePutError.FORBIDDEN_RELATION);\n                 continue;\n               }\n             }\n             // write \"forward\" entry (related entity -\u003e entity)\n             key \u003d createRelatedEntityKey(relatedEntityId,\n                 relatedEntityType, relatedEntityStartTime,\n                 entity.getEntityId(), entity.getEntityType());\n             writeBatch.put(key, EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write primary filter entries\n       if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n             primaryFilters.entrySet()) {\n           for (Object primaryFilterValue : primaryFilter.getValue()) {\n             byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime,\n                 primaryFilter.getKey(), primaryFilterValue);\n             writeBatch.put(key, EMPTY_BYTES);\n             writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                 EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write other info entries\n       Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n       if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n         for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n           byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, i.getKey());\n           byte[] value \u003d GenericObjectMapper.write(i.getValue());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write domain id entry\n       byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       if (entity.getDomainId() \u003d\u003d null ||\n           entity.getDomainId().length() \u003d\u003d 0) {\n         if (!allowEmptyDomainId) {\n-          TimelinePutError error \u003d new TimelinePutError();\n-          error.setEntityId(entity.getEntityId());\n-          error.setEntityType(entity.getEntityType());\n-          error.setErrorCode(TimelinePutError.NO_DOMAIN);\n-          response.addError(error);\n+          handleError(entity, response, TimelinePutError.NO_DOMAIN);\n           return;\n         }\n       } else {\n         writeBatch.put(key, entity.getDomainId().getBytes());\n         writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n             entity.getDomainId().getBytes());\n       }\n       db.write(writeBatch);\n+    } catch (DBException de) {\n+      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n+                \" of type \" + entity.getEntityType(), de);\n+      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n     } catch (IOException e) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n           \" of type \" + entity.getEntityType(), e);\n-      TimelinePutError error \u003d new TimelinePutError();\n-      error.setEntityId(entity.getEntityId());\n-      error.setEntityType(entity.getEntityType());\n-      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n-      response.addError(error);\n+      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n     } finally {\n       lock.unlock();\n       writeLocks.returnLock(lock);\n       IOUtils.cleanup(LOG, writeBatch);\n     }\n \n     for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n       lock \u003d writeLocks.getLock(relatedEntity);\n       lock.lock();\n       try {\n         StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n             getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n             readReverseOrderedLong(revStartTime, 0), null);\n         if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n           throw new IOException(\"Error setting start time for related entity\");\n         }\n         byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n             relatedEntityStartAndInsertTime.startTime);\n           // This is the new entity, the domain should be the same\n         byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime);\n         db.put(key, entity.getDomainId().getBytes());\n         db.put(createRelatedEntityKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime,\n             entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n         db.put(createEntityMarkerKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime),\n             writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                 .insertTime));\n+      } catch (DBException de) {\n+        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n+            \" of type \" + relatedEntity.getType() + \" for entity \" +\n+            entity.getEntityId() + \" of type \" + entity.getEntityType(), de);\n+        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n       } catch (IOException e) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n-        TimelinePutError error \u003d new TimelinePutError();\n-        error.setEntityId(entity.getEntityId());\n-        error.setEntityType(entity.getEntityType());\n-        error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n-        response.addError(error);\n+        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n       } finally {\n         lock.unlock();\n         writeLocks.returnLock(lock);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response,\n      boolean allowEmptyDomainId) {\n    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch \u003d null;\n    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n        new ArrayList\u003cEntityIdentifier\u003e();\n    byte[] revStartTime \u003d null;\n    Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n          entity.getEntityId(), entity.getEntityType(),\n          entity.getStartTime(), events);\n      if (startAndInsertTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        handleError(entity, response, TimelinePutError.NO_START_TIME);   \n        return;\n      }\n      revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n          .startTime);\n\n      primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write entity marker\n      byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n          .insertTime);\n      writeBatch.put(markerKey, markerValue);\n      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n          markerValue);\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -\u003e related entity)\n            byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime \u003d\u003d null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            } else {\n              // This is the existing entity\n              byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                  relatedEntityId, relatedEntityType, relatedEntityStartTime));\n              // The timeline data created by the server before 2.6 won\u0027t have\n              // the domain field. We assume this timeline data is in the\n              // default timeline domain.\n              String domainId \u003d null;\n              if (domainIdBytes \u003d\u003d null) {\n                domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n              } else {\n                domainId \u003d new String(domainIdBytes);\n              }\n              if (!domainId.equals(entity.getDomainId())) {\n                // in this case the entity will be put, but the relation will be\n                // ignored\n                handleError(entity, response, TimelinePutError.FORBIDDEN_RELATION);\n                continue;\n              }\n            }\n            // write \"forward\" entry (related entity -\u003e entity)\n            key \u003d createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write domain id entry\n      byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      if (entity.getDomainId() \u003d\u003d null ||\n          entity.getDomainId().length() \u003d\u003d 0) {\n        if (!allowEmptyDomainId) {\n          handleError(entity, response, TimelinePutError.NO_DOMAIN);\n          return;\n        }\n      } else {\n        writeBatch.put(key, entity.getDomainId().getBytes());\n        writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n            entity.getDomainId().getBytes());\n      }\n      db.write(writeBatch);\n    } catch (DBException de) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n                \" of type \" + entity.getEntityType(), de);\n      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock \u003d writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n            relatedEntityStartAndInsertTime.startTime);\n          // This is the new entity, the domain should be the same\n        byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime);\n        db.put(key, entity.getDomainId().getBytes());\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime),\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                .insertTime));\n      } catch (DBException de) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), de);\n        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        handleError(entity, response, TimelinePutError.IO_EXCEPTION);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "4a114dd67aae83e5bb2d65470166de954acf36a2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2819. NPE in ATS Timeline Domains when upgrading from 2.4 to 2.6. Contributed by Zhijie Shen\n",
      "commitDate": "07/11/14 4:11 PM",
      "commitName": "4a114dd67aae83e5bb2d65470166de954acf36a2",
      "commitAuthor": "Xuan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2819. NPE in ATS Timeline Domains when upgrading from 2.4 to 2.6. Contributed by Zhijie Shen\n",
          "commitDate": "07/11/14 4:11 PM",
          "commitName": "4a114dd67aae83e5bb2d65470166de954acf36a2",
          "commitAuthor": "Xuan",
          "commitDateOld": "01/10/14 5:52 PM",
          "commitNameOld": "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 36.97,
          "commitsBetweenForRepo": 357,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,195 +1,206 @@\n-  private void put(TimelineEntity entity, TimelinePutResponse response) {\n+  private void put(TimelineEntity entity, TimelinePutResponse response,\n+      boolean allowEmptyDomainId) {\n     LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n         writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n             entity.getEntityType()));\n     lock.lock();\n     WriteBatch writeBatch \u003d null;\n     List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n         new ArrayList\u003cEntityIdentifier\u003e();\n     byte[] revStartTime \u003d null;\n     Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n     try {\n       writeBatch \u003d db.createWriteBatch();\n       List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n       // look up the start time for the entity\n       StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n           entity.getEntityId(), entity.getEntityType(),\n           entity.getStartTime(), events);\n       if (startAndInsertTime \u003d\u003d null) {\n         // if no start time is found, add an error and return\n         TimelinePutError error \u003d new TimelinePutError();\n         error.setEntityId(entity.getEntityId());\n         error.setEntityType(entity.getEntityType());\n         error.setErrorCode(TimelinePutError.NO_START_TIME);\n         response.addError(error);\n         return;\n       }\n       revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n           .startTime);\n \n       primaryFilters \u003d entity.getPrimaryFilters();\n \n       // write entity marker\n       byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n           .insertTime);\n       writeBatch.put(markerKey, markerValue);\n       writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n           markerValue);\n \n       // write event entries\n       if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n         for (TimelineEvent event : events) {\n           byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n           byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, revts,\n               event.getEventType());\n           byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write related entity entries\n       Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n           entity.getRelatedEntities();\n       if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n         for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n             relatedEntities.entrySet()) {\n           String relatedEntityType \u003d relatedEntityList.getKey();\n           for (String relatedEntityId : relatedEntityList.getValue()) {\n             // invisible \"reverse\" entries (entity -\u003e related entity)\n             byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime, relatedEntityId,\n                 relatedEntityType);\n             writeBatch.put(key, EMPTY_BYTES);\n             // look up start time of related entity\n             byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                 relatedEntityType);\n             // delay writing the related entity if no start time is found\n             if (relatedEntityStartTime \u003d\u003d null) {\n               relatedEntitiesWithoutStartTimes.add(\n                   new EntityIdentifier(relatedEntityId, relatedEntityType));\n               continue;\n             } else {\n+              // This is the existing entity\n               byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                   relatedEntityId, relatedEntityType, relatedEntityStartTime));\n-              // This is the existing entity\n-              String domainId \u003d new String(domainIdBytes);\n+              // The timeline data created by the server before 2.6 won\u0027t have\n+              // the domain field. We assume this timeline data is in the\n+              // default timeline domain.\n+              String domainId \u003d null;\n+              if (domainIdBytes \u003d\u003d null) {\n+                domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n+              } else {\n+                domainId \u003d new String(domainIdBytes);\n+              }\n               if (!domainId.equals(entity.getDomainId())) {\n                 // in this case the entity will be put, but the relation will be\n                 // ignored\n                 TimelinePutError error \u003d new TimelinePutError();\n                 error.setEntityId(entity.getEntityId());\n                 error.setEntityType(entity.getEntityType());\n                 error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n                 response.addError(error);\n                 continue;\n               }\n             }\n             // write \"forward\" entry (related entity -\u003e entity)\n             key \u003d createRelatedEntityKey(relatedEntityId,\n                 relatedEntityType, relatedEntityStartTime,\n                 entity.getEntityId(), entity.getEntityType());\n             writeBatch.put(key, EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write primary filter entries\n       if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n             primaryFilters.entrySet()) {\n           for (Object primaryFilterValue : primaryFilter.getValue()) {\n             byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime,\n                 primaryFilter.getKey(), primaryFilterValue);\n             writeBatch.put(key, EMPTY_BYTES);\n             writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                 EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write other info entries\n       Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n       if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n         for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n           byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, i.getKey());\n           byte[] value \u003d GenericObjectMapper.write(i.getValue());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write domain id entry\n       byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       if (entity.getDomainId() \u003d\u003d null ||\n           entity.getDomainId().length() \u003d\u003d 0) {\n-        TimelinePutError error \u003d new TimelinePutError();\n-        error.setEntityId(entity.getEntityId());\n-        error.setEntityType(entity.getEntityType());\n-        error.setErrorCode(TimelinePutError.NO_DOMAIN);\n-        response.addError(error);\n-        return;\n+        if (!allowEmptyDomainId) {\n+          TimelinePutError error \u003d new TimelinePutError();\n+          error.setEntityId(entity.getEntityId());\n+          error.setEntityType(entity.getEntityType());\n+          error.setErrorCode(TimelinePutError.NO_DOMAIN);\n+          response.addError(error);\n+          return;\n+        }\n       } else {\n         writeBatch.put(key, entity.getDomainId().getBytes());\n         writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n             entity.getDomainId().getBytes());\n       }\n       db.write(writeBatch);\n     } catch (IOException e) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n           \" of type \" + entity.getEntityType(), e);\n       TimelinePutError error \u003d new TimelinePutError();\n       error.setEntityId(entity.getEntityId());\n       error.setEntityType(entity.getEntityType());\n       error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n       response.addError(error);\n     } finally {\n       lock.unlock();\n       writeLocks.returnLock(lock);\n       IOUtils.cleanup(LOG, writeBatch);\n     }\n \n     for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n       lock \u003d writeLocks.getLock(relatedEntity);\n       lock.lock();\n       try {\n         StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n             getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n             readReverseOrderedLong(revStartTime, 0), null);\n         if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n           throw new IOException(\"Error setting start time for related entity\");\n         }\n         byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n             relatedEntityStartAndInsertTime.startTime);\n           // This is the new entity, the domain should be the same\n         byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime);\n         db.put(key, entity.getDomainId().getBytes());\n         db.put(createRelatedEntityKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime,\n             entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n         db.put(createEntityMarkerKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime),\n             writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                 .insertTime));\n       } catch (IOException e) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n         TimelinePutError error \u003d new TimelinePutError();\n         error.setEntityId(entity.getEntityId());\n         error.setEntityType(entity.getEntityType());\n         error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n         response.addError(error);\n       } finally {\n         lock.unlock();\n         writeLocks.returnLock(lock);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response,\n      boolean allowEmptyDomainId) {\n    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch \u003d null;\n    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n        new ArrayList\u003cEntityIdentifier\u003e();\n    byte[] revStartTime \u003d null;\n    Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n          entity.getEntityId(), entity.getEntityType(),\n          entity.getStartTime(), events);\n      if (startAndInsertTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_START_TIME);\n        response.addError(error);\n        return;\n      }\n      revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n          .startTime);\n\n      primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write entity marker\n      byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n          .insertTime);\n      writeBatch.put(markerKey, markerValue);\n      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n          markerValue);\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -\u003e related entity)\n            byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime \u003d\u003d null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            } else {\n              // This is the existing entity\n              byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                  relatedEntityId, relatedEntityType, relatedEntityStartTime));\n              // The timeline data created by the server before 2.6 won\u0027t have\n              // the domain field. We assume this timeline data is in the\n              // default timeline domain.\n              String domainId \u003d null;\n              if (domainIdBytes \u003d\u003d null) {\n                domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n              } else {\n                domainId \u003d new String(domainIdBytes);\n              }\n              if (!domainId.equals(entity.getDomainId())) {\n                // in this case the entity will be put, but the relation will be\n                // ignored\n                TimelinePutError error \u003d new TimelinePutError();\n                error.setEntityId(entity.getEntityId());\n                error.setEntityType(entity.getEntityType());\n                error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n                response.addError(error);\n                continue;\n              }\n            }\n            // write \"forward\" entry (related entity -\u003e entity)\n            key \u003d createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write domain id entry\n      byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      if (entity.getDomainId() \u003d\u003d null ||\n          entity.getDomainId().length() \u003d\u003d 0) {\n        if (!allowEmptyDomainId) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entity.getEntityId());\n          error.setEntityType(entity.getEntityType());\n          error.setErrorCode(TimelinePutError.NO_DOMAIN);\n          response.addError(error);\n          return;\n        }\n      } else {\n        writeBatch.put(key, entity.getDomainId().getBytes());\n        writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n            entity.getDomainId().getBytes());\n      }\n      db.write(writeBatch);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      TimelinePutError error \u003d new TimelinePutError();\n      error.setEntityId(entity.getEntityId());\n      error.setEntityType(entity.getEntityType());\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock \u003d writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n            relatedEntityStartAndInsertTime.startTime);\n          // This is the new entity, the domain should be the same\n        byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime);\n        db.put(key, entity.getDomainId().getBytes());\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime),\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                .insertTime));\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n        response.addError(error);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
          "extendedDetails": {
            "oldValue": "[entity-TimelineEntity, response-TimelinePutResponse]",
            "newValue": "[entity-TimelineEntity, response-TimelinePutResponse, allowEmptyDomainId-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2819. NPE in ATS Timeline Domains when upgrading from 2.4 to 2.6. Contributed by Zhijie Shen\n",
          "commitDate": "07/11/14 4:11 PM",
          "commitName": "4a114dd67aae83e5bb2d65470166de954acf36a2",
          "commitAuthor": "Xuan",
          "commitDateOld": "01/10/14 5:52 PM",
          "commitNameOld": "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 36.97,
          "commitsBetweenForRepo": 357,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,195 +1,206 @@\n-  private void put(TimelineEntity entity, TimelinePutResponse response) {\n+  private void put(TimelineEntity entity, TimelinePutResponse response,\n+      boolean allowEmptyDomainId) {\n     LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n         writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n             entity.getEntityType()));\n     lock.lock();\n     WriteBatch writeBatch \u003d null;\n     List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n         new ArrayList\u003cEntityIdentifier\u003e();\n     byte[] revStartTime \u003d null;\n     Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n     try {\n       writeBatch \u003d db.createWriteBatch();\n       List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n       // look up the start time for the entity\n       StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n           entity.getEntityId(), entity.getEntityType(),\n           entity.getStartTime(), events);\n       if (startAndInsertTime \u003d\u003d null) {\n         // if no start time is found, add an error and return\n         TimelinePutError error \u003d new TimelinePutError();\n         error.setEntityId(entity.getEntityId());\n         error.setEntityType(entity.getEntityType());\n         error.setErrorCode(TimelinePutError.NO_START_TIME);\n         response.addError(error);\n         return;\n       }\n       revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n           .startTime);\n \n       primaryFilters \u003d entity.getPrimaryFilters();\n \n       // write entity marker\n       byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n           .insertTime);\n       writeBatch.put(markerKey, markerValue);\n       writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n           markerValue);\n \n       // write event entries\n       if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n         for (TimelineEvent event : events) {\n           byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n           byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, revts,\n               event.getEventType());\n           byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write related entity entries\n       Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n           entity.getRelatedEntities();\n       if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n         for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n             relatedEntities.entrySet()) {\n           String relatedEntityType \u003d relatedEntityList.getKey();\n           for (String relatedEntityId : relatedEntityList.getValue()) {\n             // invisible \"reverse\" entries (entity -\u003e related entity)\n             byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime, relatedEntityId,\n                 relatedEntityType);\n             writeBatch.put(key, EMPTY_BYTES);\n             // look up start time of related entity\n             byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                 relatedEntityType);\n             // delay writing the related entity if no start time is found\n             if (relatedEntityStartTime \u003d\u003d null) {\n               relatedEntitiesWithoutStartTimes.add(\n                   new EntityIdentifier(relatedEntityId, relatedEntityType));\n               continue;\n             } else {\n+              // This is the existing entity\n               byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                   relatedEntityId, relatedEntityType, relatedEntityStartTime));\n-              // This is the existing entity\n-              String domainId \u003d new String(domainIdBytes);\n+              // The timeline data created by the server before 2.6 won\u0027t have\n+              // the domain field. We assume this timeline data is in the\n+              // default timeline domain.\n+              String domainId \u003d null;\n+              if (domainIdBytes \u003d\u003d null) {\n+                domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n+              } else {\n+                domainId \u003d new String(domainIdBytes);\n+              }\n               if (!domainId.equals(entity.getDomainId())) {\n                 // in this case the entity will be put, but the relation will be\n                 // ignored\n                 TimelinePutError error \u003d new TimelinePutError();\n                 error.setEntityId(entity.getEntityId());\n                 error.setEntityType(entity.getEntityType());\n                 error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n                 response.addError(error);\n                 continue;\n               }\n             }\n             // write \"forward\" entry (related entity -\u003e entity)\n             key \u003d createRelatedEntityKey(relatedEntityId,\n                 relatedEntityType, relatedEntityStartTime,\n                 entity.getEntityId(), entity.getEntityType());\n             writeBatch.put(key, EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write primary filter entries\n       if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n             primaryFilters.entrySet()) {\n           for (Object primaryFilterValue : primaryFilter.getValue()) {\n             byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime,\n                 primaryFilter.getKey(), primaryFilterValue);\n             writeBatch.put(key, EMPTY_BYTES);\n             writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                 EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write other info entries\n       Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n       if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n         for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n           byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, i.getKey());\n           byte[] value \u003d GenericObjectMapper.write(i.getValue());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write domain id entry\n       byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       if (entity.getDomainId() \u003d\u003d null ||\n           entity.getDomainId().length() \u003d\u003d 0) {\n-        TimelinePutError error \u003d new TimelinePutError();\n-        error.setEntityId(entity.getEntityId());\n-        error.setEntityType(entity.getEntityType());\n-        error.setErrorCode(TimelinePutError.NO_DOMAIN);\n-        response.addError(error);\n-        return;\n+        if (!allowEmptyDomainId) {\n+          TimelinePutError error \u003d new TimelinePutError();\n+          error.setEntityId(entity.getEntityId());\n+          error.setEntityType(entity.getEntityType());\n+          error.setErrorCode(TimelinePutError.NO_DOMAIN);\n+          response.addError(error);\n+          return;\n+        }\n       } else {\n         writeBatch.put(key, entity.getDomainId().getBytes());\n         writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n             entity.getDomainId().getBytes());\n       }\n       db.write(writeBatch);\n     } catch (IOException e) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n           \" of type \" + entity.getEntityType(), e);\n       TimelinePutError error \u003d new TimelinePutError();\n       error.setEntityId(entity.getEntityId());\n       error.setEntityType(entity.getEntityType());\n       error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n       response.addError(error);\n     } finally {\n       lock.unlock();\n       writeLocks.returnLock(lock);\n       IOUtils.cleanup(LOG, writeBatch);\n     }\n \n     for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n       lock \u003d writeLocks.getLock(relatedEntity);\n       lock.lock();\n       try {\n         StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n             getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n             readReverseOrderedLong(revStartTime, 0), null);\n         if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n           throw new IOException(\"Error setting start time for related entity\");\n         }\n         byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n             relatedEntityStartAndInsertTime.startTime);\n           // This is the new entity, the domain should be the same\n         byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime);\n         db.put(key, entity.getDomainId().getBytes());\n         db.put(createRelatedEntityKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime,\n             entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n         db.put(createEntityMarkerKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime),\n             writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                 .insertTime));\n       } catch (IOException e) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n         TimelinePutError error \u003d new TimelinePutError();\n         error.setEntityId(entity.getEntityId());\n         error.setEntityType(entity.getEntityType());\n         error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n         response.addError(error);\n       } finally {\n         lock.unlock();\n         writeLocks.returnLock(lock);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response,\n      boolean allowEmptyDomainId) {\n    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch \u003d null;\n    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n        new ArrayList\u003cEntityIdentifier\u003e();\n    byte[] revStartTime \u003d null;\n    Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n          entity.getEntityId(), entity.getEntityType(),\n          entity.getStartTime(), events);\n      if (startAndInsertTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_START_TIME);\n        response.addError(error);\n        return;\n      }\n      revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n          .startTime);\n\n      primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write entity marker\n      byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n          .insertTime);\n      writeBatch.put(markerKey, markerValue);\n      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n          markerValue);\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -\u003e related entity)\n            byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime \u003d\u003d null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            } else {\n              // This is the existing entity\n              byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                  relatedEntityId, relatedEntityType, relatedEntityStartTime));\n              // The timeline data created by the server before 2.6 won\u0027t have\n              // the domain field. We assume this timeline data is in the\n              // default timeline domain.\n              String domainId \u003d null;\n              if (domainIdBytes \u003d\u003d null) {\n                domainId \u003d TimelineDataManager.DEFAULT_DOMAIN_ID;\n              } else {\n                domainId \u003d new String(domainIdBytes);\n              }\n              if (!domainId.equals(entity.getDomainId())) {\n                // in this case the entity will be put, but the relation will be\n                // ignored\n                TimelinePutError error \u003d new TimelinePutError();\n                error.setEntityId(entity.getEntityId());\n                error.setEntityType(entity.getEntityType());\n                error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n                response.addError(error);\n                continue;\n              }\n            }\n            // write \"forward\" entry (related entity -\u003e entity)\n            key \u003d createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write domain id entry\n      byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      if (entity.getDomainId() \u003d\u003d null ||\n          entity.getDomainId().length() \u003d\u003d 0) {\n        if (!allowEmptyDomainId) {\n          TimelinePutError error \u003d new TimelinePutError();\n          error.setEntityId(entity.getEntityId());\n          error.setEntityType(entity.getEntityType());\n          error.setErrorCode(TimelinePutError.NO_DOMAIN);\n          response.addError(error);\n          return;\n        }\n      } else {\n        writeBatch.put(key, entity.getDomainId().getBytes());\n        writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n            entity.getDomainId().getBytes());\n      }\n      db.write(writeBatch);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      TimelinePutError error \u003d new TimelinePutError();\n      error.setEntityId(entity.getEntityId());\n      error.setEntityType(entity.getEntityType());\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock \u003d writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n            relatedEntityStartAndInsertTime.startTime);\n          // This is the new entity, the domain should be the same\n        byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime);\n        db.put(key, entity.getDomainId().getBytes());\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime),\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                .insertTime));\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n        response.addError(error);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "9e40de6af7959ac7bb5f4e4d2833ca14ea457614": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2446. Augmented Timeline service APIs to start taking in domains as a parameter while posting entities and events. Contributed by Zhijie Shen.\n",
      "commitDate": "01/10/14 5:52 PM",
      "commitName": "9e40de6af7959ac7bb5f4e4d2833ca14ea457614",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/09/14 11:27 AM",
      "commitNameOld": "d78b452a4f413c6931a494c33df0666ce9b44973",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.27,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,158 +1,195 @@\n   private void put(TimelineEntity entity, TimelinePutResponse response) {\n     LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n         writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n             entity.getEntityType()));\n     lock.lock();\n     WriteBatch writeBatch \u003d null;\n     List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n         new ArrayList\u003cEntityIdentifier\u003e();\n     byte[] revStartTime \u003d null;\n+    Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n     try {\n       writeBatch \u003d db.createWriteBatch();\n       List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n       // look up the start time for the entity\n       StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n           entity.getEntityId(), entity.getEntityType(),\n           entity.getStartTime(), events);\n       if (startAndInsertTime \u003d\u003d null) {\n         // if no start time is found, add an error and return\n         TimelinePutError error \u003d new TimelinePutError();\n         error.setEntityId(entity.getEntityId());\n         error.setEntityType(entity.getEntityType());\n         error.setErrorCode(TimelinePutError.NO_START_TIME);\n         response.addError(error);\n         return;\n       }\n       revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n           .startTime);\n \n-      Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d entity.getPrimaryFilters();\n+      primaryFilters \u003d entity.getPrimaryFilters();\n \n       // write entity marker\n       byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n           entity.getEntityType(), revStartTime);\n       byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n           .insertTime);\n       writeBatch.put(markerKey, markerValue);\n       writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n           markerValue);\n \n       // write event entries\n       if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n         for (TimelineEvent event : events) {\n           byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n           byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, revts,\n               event.getEventType());\n           byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write related entity entries\n       Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n           entity.getRelatedEntities();\n       if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n         for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n             relatedEntities.entrySet()) {\n           String relatedEntityType \u003d relatedEntityList.getKey();\n           for (String relatedEntityId : relatedEntityList.getValue()) {\n             // invisible \"reverse\" entries (entity -\u003e related entity)\n             byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime, relatedEntityId,\n                 relatedEntityType);\n             writeBatch.put(key, EMPTY_BYTES);\n             // look up start time of related entity\n             byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                 relatedEntityType);\n             // delay writing the related entity if no start time is found\n             if (relatedEntityStartTime \u003d\u003d null) {\n               relatedEntitiesWithoutStartTimes.add(\n                   new EntityIdentifier(relatedEntityId, relatedEntityType));\n               continue;\n+            } else {\n+              byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n+                  relatedEntityId, relatedEntityType, relatedEntityStartTime));\n+              // This is the existing entity\n+              String domainId \u003d new String(domainIdBytes);\n+              if (!domainId.equals(entity.getDomainId())) {\n+                // in this case the entity will be put, but the relation will be\n+                // ignored\n+                TimelinePutError error \u003d new TimelinePutError();\n+                error.setEntityId(entity.getEntityId());\n+                error.setEntityType(entity.getEntityType());\n+                error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n+                response.addError(error);\n+                continue;\n+              }\n             }\n             // write \"forward\" entry (related entity -\u003e entity)\n             key \u003d createRelatedEntityKey(relatedEntityId,\n                 relatedEntityType, relatedEntityStartTime,\n                 entity.getEntityId(), entity.getEntityType());\n             writeBatch.put(key, EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write primary filter entries\n       if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n             primaryFilters.entrySet()) {\n           for (Object primaryFilterValue : primaryFilter.getValue()) {\n             byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime,\n                 primaryFilter.getKey(), primaryFilterValue);\n             writeBatch.put(key, EMPTY_BYTES);\n             writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                 EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write other info entries\n       Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n       if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n         for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n           byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, i.getKey());\n           byte[] value \u003d GenericObjectMapper.write(i.getValue());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n+\n+      // write domain id entry\n+      byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n+          entity.getEntityType(), revStartTime);\n+      if (entity.getDomainId() \u003d\u003d null ||\n+          entity.getDomainId().length() \u003d\u003d 0) {\n+        TimelinePutError error \u003d new TimelinePutError();\n+        error.setEntityId(entity.getEntityId());\n+        error.setEntityType(entity.getEntityType());\n+        error.setErrorCode(TimelinePutError.NO_DOMAIN);\n+        response.addError(error);\n+        return;\n+      } else {\n+        writeBatch.put(key, entity.getDomainId().getBytes());\n+        writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n+            entity.getDomainId().getBytes());\n+      }\n       db.write(writeBatch);\n     } catch (IOException e) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n           \" of type \" + entity.getEntityType(), e);\n       TimelinePutError error \u003d new TimelinePutError();\n       error.setEntityId(entity.getEntityId());\n       error.setEntityType(entity.getEntityType());\n       error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n       response.addError(error);\n     } finally {\n       lock.unlock();\n       writeLocks.returnLock(lock);\n       IOUtils.cleanup(LOG, writeBatch);\n     }\n \n     for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n       lock \u003d writeLocks.getLock(relatedEntity);\n       lock.lock();\n       try {\n         StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n             getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n             readReverseOrderedLong(revStartTime, 0), null);\n         if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n           throw new IOException(\"Error setting start time for related entity\");\n         }\n         byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n             relatedEntityStartAndInsertTime.startTime);\n+          // This is the new entity, the domain should be the same\n+        byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n+            relatedEntity.getType(), relatedEntityStartTime);\n+        db.put(key, entity.getDomainId().getBytes());\n         db.put(createRelatedEntityKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime,\n             entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n         db.put(createEntityMarkerKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime),\n             writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                 .insertTime));\n       } catch (IOException e) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n         TimelinePutError error \u003d new TimelinePutError();\n         error.setEntityId(entity.getEntityId());\n         error.setEntityType(entity.getEntityType());\n         error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n         response.addError(error);\n       } finally {\n         lock.unlock();\n         writeLocks.returnLock(lock);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response) {\n    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch \u003d null;\n    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n        new ArrayList\u003cEntityIdentifier\u003e();\n    byte[] revStartTime \u003d null;\n    Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n          entity.getEntityId(), entity.getEntityType(),\n          entity.getStartTime(), events);\n      if (startAndInsertTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_START_TIME);\n        response.addError(error);\n        return;\n      }\n      revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n          .startTime);\n\n      primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write entity marker\n      byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n          .insertTime);\n      writeBatch.put(markerKey, markerValue);\n      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n          markerValue);\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -\u003e related entity)\n            byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime \u003d\u003d null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            } else {\n              byte[] domainIdBytes \u003d db.get(createDomainIdKey(\n                  relatedEntityId, relatedEntityType, relatedEntityStartTime));\n              // This is the existing entity\n              String domainId \u003d new String(domainIdBytes);\n              if (!domainId.equals(entity.getDomainId())) {\n                // in this case the entity will be put, but the relation will be\n                // ignored\n                TimelinePutError error \u003d new TimelinePutError();\n                error.setEntityId(entity.getEntityId());\n                error.setEntityType(entity.getEntityType());\n                error.setErrorCode(TimelinePutError.FORBIDDEN_RELATION);\n                response.addError(error);\n                continue;\n              }\n            }\n            // write \"forward\" entry (related entity -\u003e entity)\n            key \u003d createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write domain id entry\n      byte[] key \u003d createDomainIdKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      if (entity.getDomainId() \u003d\u003d null ||\n          entity.getDomainId().length() \u003d\u003d 0) {\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_DOMAIN);\n        response.addError(error);\n        return;\n      } else {\n        writeBatch.put(key, entity.getDomainId().getBytes());\n        writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n            entity.getDomainId().getBytes());\n      }\n      db.write(writeBatch);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      TimelinePutError error \u003d new TimelinePutError();\n      error.setEntityId(entity.getEntityId());\n      error.setEntityType(entity.getEntityType());\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock \u003d writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n            relatedEntityStartAndInsertTime.startTime);\n          // This is the new entity, the domain should be the same\n        byte[] key \u003d createDomainIdKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime);\n        db.put(key, entity.getDomainId().getBytes());\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime),\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                .insertTime));\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n        response.addError(error);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "001078e0677e39b962ca1da81fc34d7ac9a7e65c": {
      "type": "Yfilerename",
      "commitMessage": "YARN-2107. Refactored timeline classes into o.a.h.y.s.timeline package. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1598094 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/05/14 11:09 AM",
      "commitName": "001078e0677e39b962ca1da81fc34d7ac9a7e65c",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "28/05/14 10:44 AM",
      "commitNameOld": "cfd8647d0f20c08761f908be1f5b718c1c372498",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response) {\n    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch \u003d null;\n    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n        new ArrayList\u003cEntityIdentifier\u003e();\n    byte[] revStartTime \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n          entity.getEntityId(), entity.getEntityType(),\n          entity.getStartTime(), events);\n      if (startAndInsertTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_START_TIME);\n        response.addError(error);\n        return;\n      }\n      revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n          .startTime);\n\n      Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write entity marker\n      byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n          .insertTime);\n      writeBatch.put(markerKey, markerValue);\n      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n          markerValue);\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -\u003e related entity)\n            byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime \u003d\u003d null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            }\n            // write \"forward\" entry (related entity -\u003e entity)\n            key \u003d createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n      db.write(writeBatch);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      TimelinePutError error \u003d new TimelinePutError();\n      error.setEntityId(entity.getEntityId());\n      error.setEntityType(entity.getEntityType());\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock \u003d writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n            relatedEntityStartAndInsertTime.startTime);\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime),\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                .insertTime));\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n        response.addError(error);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/LeveldbTimelineStore.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/LeveldbTimelineStore.java"
      }
    },
    "0f1eda6bbf895a1239b25cdf8b17fabd3759e806": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1838. Enhanced timeline service getEntities API to get entities from a given entity ID or insertion timestamp. Contributed by Billie Rinaldi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580960 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/03/14 11:14 AM",
      "commitName": "0f1eda6bbf895a1239b25cdf8b17fabd3759e806",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "14/03/14 1:35 PM",
      "commitNameOld": "b3ea4aebff42131642af0393748dc751cb3fc31e",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 9.9,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,158 @@\n   private void put(TimelineEntity entity, TimelinePutResponse response) {\n     LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n         writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n             entity.getEntityType()));\n     lock.lock();\n     WriteBatch writeBatch \u003d null;\n     List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n         new ArrayList\u003cEntityIdentifier\u003e();\n     byte[] revStartTime \u003d null;\n     try {\n       writeBatch \u003d db.createWriteBatch();\n       List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n       // look up the start time for the entity\n-      revStartTime \u003d getAndSetStartTime(entity.getEntityId(),\n-          entity.getEntityType(), entity.getStartTime(), events);\n-      if (revStartTime \u003d\u003d null) {\n+      StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n+          entity.getEntityId(), entity.getEntityType(),\n+          entity.getStartTime(), events);\n+      if (startAndInsertTime \u003d\u003d null) {\n         // if no start time is found, add an error and return\n         TimelinePutError error \u003d new TimelinePutError();\n         error.setEntityId(entity.getEntityId());\n         error.setEntityType(entity.getEntityType());\n         error.setErrorCode(TimelinePutError.NO_START_TIME);\n         response.addError(error);\n         return;\n       }\n+      revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n+          .startTime);\n+\n       Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d entity.getPrimaryFilters();\n \n       // write entity marker\n-      writeBatch.put(createEntityMarkerKey(entity.getEntityId(),\n-          entity.getEntityType(), revStartTime), EMPTY_BYTES);\n+      byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n+          entity.getEntityType(), revStartTime);\n+      byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n+          .insertTime);\n+      writeBatch.put(markerKey, markerValue);\n+      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n+          markerValue);\n \n       // write event entries\n       if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n         for (TimelineEvent event : events) {\n           byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n           byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, revts,\n               event.getEventType());\n           byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write related entity entries\n       Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n           entity.getRelatedEntities();\n       if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n         for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n             relatedEntities.entrySet()) {\n           String relatedEntityType \u003d relatedEntityList.getKey();\n           for (String relatedEntityId : relatedEntityList.getValue()) {\n             // invisible \"reverse\" entries (entity -\u003e related entity)\n             byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime, relatedEntityId,\n                 relatedEntityType);\n             writeBatch.put(key, EMPTY_BYTES);\n             // look up start time of related entity\n             byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                 relatedEntityType);\n             // delay writing the related entity if no start time is found\n             if (relatedEntityStartTime \u003d\u003d null) {\n               relatedEntitiesWithoutStartTimes.add(\n                   new EntityIdentifier(relatedEntityId, relatedEntityType));\n               continue;\n             }\n             // write \"forward\" entry (related entity -\u003e entity)\n             key \u003d createRelatedEntityKey(relatedEntityId,\n                 relatedEntityType, relatedEntityStartTime,\n                 entity.getEntityId(), entity.getEntityType());\n             writeBatch.put(key, EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write primary filter entries\n       if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n             primaryFilters.entrySet()) {\n           for (Object primaryFilterValue : primaryFilter.getValue()) {\n             byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime,\n                 primaryFilter.getKey(), primaryFilterValue);\n             writeBatch.put(key, EMPTY_BYTES);\n             writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                 EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write other info entries\n       Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n       if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n         for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n           byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, i.getKey());\n           byte[] value \u003d GenericObjectMapper.write(i.getValue());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n       db.write(writeBatch);\n     } catch (IOException e) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n           \" of type \" + entity.getEntityType(), e);\n       TimelinePutError error \u003d new TimelinePutError();\n       error.setEntityId(entity.getEntityId());\n       error.setEntityType(entity.getEntityType());\n       error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n       response.addError(error);\n     } finally {\n       lock.unlock();\n       writeLocks.returnLock(lock);\n       IOUtils.cleanup(LOG, writeBatch);\n     }\n \n     for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n       lock \u003d writeLocks.getLock(relatedEntity);\n       lock.lock();\n       try {\n-        byte[] relatedEntityStartTime \u003d getAndSetStartTime(\n-            relatedEntity.getId(), relatedEntity.getType(),\n+        StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n+            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n             readReverseOrderedLong(revStartTime, 0), null);\n-        if (relatedEntityStartTime \u003d\u003d null) {\n+        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n           throw new IOException(\"Error setting start time for related entity\");\n         }\n+        byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n+            relatedEntityStartAndInsertTime.startTime);\n         db.put(createRelatedEntityKey(relatedEntity.getId(),\n             relatedEntity.getType(), relatedEntityStartTime,\n             entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n         db.put(createEntityMarkerKey(relatedEntity.getId(),\n-            relatedEntity.getType(), relatedEntityStartTime), EMPTY_BYTES);\n+            relatedEntity.getType(), relatedEntityStartTime),\n+            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n+                .insertTime));\n       } catch (IOException e) {\n         LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n             \" of type \" + relatedEntity.getType() + \" for entity \" +\n             entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n         TimelinePutError error \u003d new TimelinePutError();\n         error.setEntityId(entity.getEntityId());\n         error.setEntityType(entity.getEntityType());\n         error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n         response.addError(error);\n       } finally {\n         lock.unlock();\n         writeLocks.returnLock(lock);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response) {\n    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch \u003d null;\n    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n        new ArrayList\u003cEntityIdentifier\u003e();\n    byte[] revStartTime \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      StartAndInsertTime startAndInsertTime \u003d getAndSetStartTime(\n          entity.getEntityId(), entity.getEntityType(),\n          entity.getStartTime(), events);\n      if (startAndInsertTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_START_TIME);\n        response.addError(error);\n        return;\n      }\n      revStartTime \u003d writeReverseOrderedLong(startAndInsertTime\n          .startTime);\n\n      Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write entity marker\n      byte[] markerKey \u003d createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime);\n      byte[] markerValue \u003d writeReverseOrderedLong(startAndInsertTime\n          .insertTime);\n      writeBatch.put(markerKey, markerValue);\n      writePrimaryFilterEntries(writeBatch, primaryFilters, markerKey,\n          markerValue);\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -\u003e related entity)\n            byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime \u003d\u003d null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            }\n            // write \"forward\" entry (related entity -\u003e entity)\n            key \u003d createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n      db.write(writeBatch);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      TimelinePutError error \u003d new TimelinePutError();\n      error.setEntityId(entity.getEntityId());\n      error.setEntityType(entity.getEntityType());\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock \u003d writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        StartAndInsertTime relatedEntityStartAndInsertTime \u003d\n            getAndSetStartTime(relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartAndInsertTime \u003d\u003d null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        byte[] relatedEntityStartTime \u003d writeReverseOrderedLong(\n            relatedEntityStartAndInsertTime.startTime);\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime),\n            writeReverseOrderedLong(relatedEntityStartAndInsertTime\n                .insertTime));\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n        response.addError(error);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "b3ea4aebff42131642af0393748dc751cb3fc31e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1717. Enabled periodically discarding old data in LeveldbTimelineStore. Contributed by Billie Rinaldi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1577693 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/03/14 1:35 PM",
      "commitName": "b3ea4aebff42131642af0393748dc751cb3fc31e",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "04/03/14 9:32 AM",
      "commitNameOld": "40464fba22bac99d0e5b79674152aa5dfba99483",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 10.13,
      "commitsBetweenForRepo": 99,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,145 @@\n   private void put(TimelineEntity entity, TimelinePutResponse response) {\n     LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n         writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n             entity.getEntityType()));\n     lock.lock();\n     WriteBatch writeBatch \u003d null;\n+    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n+        new ArrayList\u003cEntityIdentifier\u003e();\n+    byte[] revStartTime \u003d null;\n     try {\n       writeBatch \u003d db.createWriteBatch();\n       List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n       // look up the start time for the entity\n-      byte[] revStartTime \u003d getAndSetStartTime(entity.getEntityId(),\n-          entity.getEntityType(), entity.getStartTime(), events,\n-          writeBatch);\n+      revStartTime \u003d getAndSetStartTime(entity.getEntityId(),\n+          entity.getEntityType(), entity.getStartTime(), events);\n       if (revStartTime \u003d\u003d null) {\n         // if no start time is found, add an error and return\n         TimelinePutError error \u003d new TimelinePutError();\n         error.setEntityId(entity.getEntityId());\n         error.setEntityType(entity.getEntityType());\n         error.setErrorCode(TimelinePutError.NO_START_TIME);\n         response.addError(error);\n         return;\n       }\n-      Long revStartTimeLong \u003d readReverseOrderedLong(revStartTime, 0);\n       Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d entity.getPrimaryFilters();\n \n+      // write entity marker\n+      writeBatch.put(createEntityMarkerKey(entity.getEntityId(),\n+          entity.getEntityType(), revStartTime), EMPTY_BYTES);\n+\n       // write event entries\n       if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n         for (TimelineEvent event : events) {\n           byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n           byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, revts,\n               event.getEventType());\n           byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write related entity entries\n       Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n           entity.getRelatedEntities();\n       if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n         for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n             relatedEntities.entrySet()) {\n           String relatedEntityType \u003d relatedEntityList.getKey();\n           for (String relatedEntityId : relatedEntityList.getValue()) {\n+            // invisible \"reverse\" entries (entity -\u003e related entity)\n+            byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n+                entity.getEntityType(), revStartTime, relatedEntityId,\n+                relatedEntityType);\n+            writeBatch.put(key, EMPTY_BYTES);\n             // look up start time of related entity\n-            byte[] relatedEntityStartTime \u003d getAndSetStartTime(relatedEntityId,\n-                relatedEntityType, null, null, writeBatch);\n+            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n+                relatedEntityType);\n+            // delay writing the related entity if no start time is found\n             if (relatedEntityStartTime \u003d\u003d null) {\n-              // if start time is not found, set start time of the related\n-              // entity to the start time of this entity, and write it to the\n-              // db and the cache\n-              relatedEntityStartTime \u003d revStartTime;\n-              writeBatch.put(createStartTimeLookupKey(relatedEntityId,\n-                  relatedEntityType), relatedEntityStartTime);\n-              startTimeWriteCache.put(new EntityIdentifier(relatedEntityId,\n-                  relatedEntityType), revStartTimeLong);\n+              relatedEntitiesWithoutStartTimes.add(\n+                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n+              continue;\n             }\n-            // write reverse entry (related entity -\u003e entity)\n-            byte[] key \u003d createReleatedEntityKey(relatedEntityId,\n+            // write \"forward\" entry (related entity -\u003e entity)\n+            key \u003d createRelatedEntityKey(relatedEntityId,\n                 relatedEntityType, relatedEntityStartTime,\n                 entity.getEntityId(), entity.getEntityType());\n             writeBatch.put(key, EMPTY_BYTES);\n-            // TODO: write forward entry (entity -\u003e related entity)?\n           }\n         }\n       }\n \n       // write primary filter entries\n       if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n             primaryFilters.entrySet()) {\n           for (Object primaryFilterValue : primaryFilter.getValue()) {\n             byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime,\n                 primaryFilter.getKey(), primaryFilterValue);\n             writeBatch.put(key, EMPTY_BYTES);\n             writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                 EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write other info entries\n       Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n       if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n         for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n           byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, i.getKey());\n           byte[] value \u003d GenericObjectMapper.write(i.getValue());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n       db.write(writeBatch);\n     } catch (IOException e) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n           \" of type \" + entity.getEntityType(), e);\n       TimelinePutError error \u003d new TimelinePutError();\n       error.setEntityId(entity.getEntityId());\n       error.setEntityType(entity.getEntityType());\n       error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n       response.addError(error);\n     } finally {\n       lock.unlock();\n       writeLocks.returnLock(lock);\n       IOUtils.cleanup(LOG, writeBatch);\n     }\n+\n+    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n+      lock \u003d writeLocks.getLock(relatedEntity);\n+      lock.lock();\n+      try {\n+        byte[] relatedEntityStartTime \u003d getAndSetStartTime(\n+            relatedEntity.getId(), relatedEntity.getType(),\n+            readReverseOrderedLong(revStartTime, 0), null);\n+        if (relatedEntityStartTime \u003d\u003d null) {\n+          throw new IOException(\"Error setting start time for related entity\");\n+        }\n+        db.put(createRelatedEntityKey(relatedEntity.getId(),\n+            relatedEntity.getType(), relatedEntityStartTime,\n+            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n+        db.put(createEntityMarkerKey(relatedEntity.getId(),\n+            relatedEntity.getType(), relatedEntityStartTime), EMPTY_BYTES);\n+      } catch (IOException e) {\n+        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n+            \" of type \" + relatedEntity.getType() + \" for entity \" +\n+            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n+        TimelinePutError error \u003d new TimelinePutError();\n+        error.setEntityId(entity.getEntityId());\n+        error.setEntityType(entity.getEntityType());\n+        error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n+        response.addError(error);\n+      } finally {\n+        lock.unlock();\n+        writeLocks.returnLock(lock);\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response) {\n    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch \u003d null;\n    List\u003cEntityIdentifier\u003e relatedEntitiesWithoutStartTimes \u003d\n        new ArrayList\u003cEntityIdentifier\u003e();\n    byte[] revStartTime \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      revStartTime \u003d getAndSetStartTime(entity.getEntityId(),\n          entity.getEntityType(), entity.getStartTime(), events);\n      if (revStartTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_START_TIME);\n        response.addError(error);\n        return;\n      }\n      Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write entity marker\n      writeBatch.put(createEntityMarkerKey(entity.getEntityId(),\n          entity.getEntityType(), revStartTime), EMPTY_BYTES);\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // invisible \"reverse\" entries (entity -\u003e related entity)\n            byte[] key \u003d createReverseRelatedEntityKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime, relatedEntityId,\n                relatedEntityType);\n            writeBatch.put(key, EMPTY_BYTES);\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                relatedEntityType);\n            // delay writing the related entity if no start time is found\n            if (relatedEntityStartTime \u003d\u003d null) {\n              relatedEntitiesWithoutStartTimes.add(\n                  new EntityIdentifier(relatedEntityId, relatedEntityType));\n              continue;\n            }\n            // write \"forward\" entry (related entity -\u003e entity)\n            key \u003d createRelatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n      db.write(writeBatch);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      TimelinePutError error \u003d new TimelinePutError();\n      error.setEntityId(entity.getEntityId());\n      error.setEntityType(entity.getEntityType());\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n\n    for (EntityIdentifier relatedEntity : relatedEntitiesWithoutStartTimes) {\n      lock \u003d writeLocks.getLock(relatedEntity);\n      lock.lock();\n      try {\n        byte[] relatedEntityStartTime \u003d getAndSetStartTime(\n            relatedEntity.getId(), relatedEntity.getType(),\n            readReverseOrderedLong(revStartTime, 0), null);\n        if (relatedEntityStartTime \u003d\u003d null) {\n          throw new IOException(\"Error setting start time for related entity\");\n        }\n        db.put(createRelatedEntityKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime,\n            entity.getEntityId(), entity.getEntityType()), EMPTY_BYTES);\n        db.put(createEntityMarkerKey(relatedEntity.getId(),\n            relatedEntity.getType(), relatedEntityStartTime), EMPTY_BYTES);\n      } catch (IOException e) {\n        LOG.error(\"Error putting related entity \" + relatedEntity.getId() +\n            \" of type \" + relatedEntity.getType() + \" for entity \" +\n            entity.getEntityId() + \" of type \" + entity.getEntityType(), e);\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n        response.addError(error);\n      } finally {\n        lock.unlock();\n        writeLocks.returnLock(lock);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "40464fba22bac99d0e5b79674152aa5dfba99483": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1730. Implemented simple write-locking in the LevelDB based timeline-store. Contributed by Billie Rinaldi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1574145 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/03/14 9:32 AM",
      "commitName": "40464fba22bac99d0e5b79674152aa5dfba99483",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "22/02/14 12:55 PM",
      "commitNameOld": "84425fb435cb603fd8adcc2f76631c0244175310",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 9.86,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,110 @@\n   private void put(TimelineEntity entity, TimelinePutResponse response) {\n+    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n+        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n+            entity.getEntityType()));\n+    lock.lock();\n     WriteBatch writeBatch \u003d null;\n     try {\n       writeBatch \u003d db.createWriteBatch();\n       List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n       // look up the start time for the entity\n-      byte[] revStartTime \u003d getStartTime(entity.getEntityId(),\n+      byte[] revStartTime \u003d getAndSetStartTime(entity.getEntityId(),\n           entity.getEntityType(), entity.getStartTime(), events,\n           writeBatch);\n       if (revStartTime \u003d\u003d null) {\n         // if no start time is found, add an error and return\n         TimelinePutError error \u003d new TimelinePutError();\n         error.setEntityId(entity.getEntityId());\n         error.setEntityType(entity.getEntityType());\n         error.setErrorCode(TimelinePutError.NO_START_TIME);\n         response.addError(error);\n         return;\n       }\n       Long revStartTimeLong \u003d readReverseOrderedLong(revStartTime, 0);\n       Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d entity.getPrimaryFilters();\n \n       // write event entries\n       if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n         for (TimelineEvent event : events) {\n           byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n           byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, revts,\n               event.getEventType());\n           byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n \n       // write related entity entries\n       Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n           entity.getRelatedEntities();\n       if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n         for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n             relatedEntities.entrySet()) {\n           String relatedEntityType \u003d relatedEntityList.getKey();\n           for (String relatedEntityId : relatedEntityList.getValue()) {\n             // look up start time of related entity\n-            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n+            byte[] relatedEntityStartTime \u003d getAndSetStartTime(relatedEntityId,\n                 relatedEntityType, null, null, writeBatch);\n             if (relatedEntityStartTime \u003d\u003d null) {\n               // if start time is not found, set start time of the related\n               // entity to the start time of this entity, and write it to the\n               // db and the cache\n               relatedEntityStartTime \u003d revStartTime;\n               writeBatch.put(createStartTimeLookupKey(relatedEntityId,\n                   relatedEntityType), relatedEntityStartTime);\n-              startTimeCache.put(new EntityIdentifier(relatedEntityId,\n+              startTimeWriteCache.put(new EntityIdentifier(relatedEntityId,\n                   relatedEntityType), revStartTimeLong);\n             }\n             // write reverse entry (related entity -\u003e entity)\n             byte[] key \u003d createReleatedEntityKey(relatedEntityId,\n                 relatedEntityType, relatedEntityStartTime,\n                 entity.getEntityId(), entity.getEntityType());\n             writeBatch.put(key, EMPTY_BYTES);\n             // TODO: write forward entry (entity -\u003e related entity)?\n           }\n         }\n       }\n \n       // write primary filter entries\n       if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n         for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n             primaryFilters.entrySet()) {\n           for (Object primaryFilterValue : primaryFilter.getValue()) {\n             byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                 entity.getEntityType(), revStartTime,\n                 primaryFilter.getKey(), primaryFilterValue);\n             writeBatch.put(key, EMPTY_BYTES);\n             writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                 EMPTY_BYTES);\n           }\n         }\n       }\n \n       // write other info entries\n       Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n       if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n         for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n           byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n               entity.getEntityType(), revStartTime, i.getKey());\n           byte[] value \u003d GenericObjectMapper.write(i.getValue());\n           writeBatch.put(key, value);\n           writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n         }\n       }\n       db.write(writeBatch);\n     } catch (IOException e) {\n       LOG.error(\"Error putting entity \" + entity.getEntityId() +\n           \" of type \" + entity.getEntityType(), e);\n       TimelinePutError error \u003d new TimelinePutError();\n       error.setEntityId(entity.getEntityId());\n       error.setEntityType(entity.getEntityType());\n       error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n       response.addError(error);\n     } finally {\n+      lock.unlock();\n+      writeLocks.returnLock(lock);\n       IOUtils.cleanup(LOG, writeBatch);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response) {\n    LockMap.CountingReentrantLock\u003cEntityIdentifier\u003e lock \u003d\n        writeLocks.getLock(new EntityIdentifier(entity.getEntityId(),\n            entity.getEntityType()));\n    lock.lock();\n    WriteBatch writeBatch \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      byte[] revStartTime \u003d getAndSetStartTime(entity.getEntityId(),\n          entity.getEntityType(), entity.getStartTime(), events,\n          writeBatch);\n      if (revStartTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_START_TIME);\n        response.addError(error);\n        return;\n      }\n      Long revStartTimeLong \u003d readReverseOrderedLong(revStartTime, 0);\n      Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getAndSetStartTime(relatedEntityId,\n                relatedEntityType, null, null, writeBatch);\n            if (relatedEntityStartTime \u003d\u003d null) {\n              // if start time is not found, set start time of the related\n              // entity to the start time of this entity, and write it to the\n              // db and the cache\n              relatedEntityStartTime \u003d revStartTime;\n              writeBatch.put(createStartTimeLookupKey(relatedEntityId,\n                  relatedEntityType), relatedEntityStartTime);\n              startTimeWriteCache.put(new EntityIdentifier(relatedEntityId,\n                  relatedEntityType), revStartTimeLong);\n            }\n            // write reverse entry (related entity -\u003e entity)\n            byte[] key \u003d createReleatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n            // TODO: write forward entry (entity -\u003e related entity)?\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n      db.write(writeBatch);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      TimelinePutError error \u003d new TimelinePutError();\n      error.setEntityId(entity.getEntityId());\n      error.setEntityType(entity.getEntityType());\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n    } finally {\n      lock.unlock();\n      writeLocks.returnLock(lock);\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/LeveldbTimelineStore.java",
      "extendedDetails": {}
    },
    "84425fb435cb603fd8adcc2f76631c0244175310": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1687. Renamed user-facing records for the timeline-service to be simply named after \u0027timeline\u0027 instead of \u0027apptimeline\u0027. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1570922 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/02/14 12:55 PM",
      "commitName": "84425fb435cb603fd8adcc2f76631c0244175310",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,104 @@\n+  private void put(TimelineEntity entity, TimelinePutResponse response) {\n+    WriteBatch writeBatch \u003d null;\n+    try {\n+      writeBatch \u003d db.createWriteBatch();\n+      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n+      // look up the start time for the entity\n+      byte[] revStartTime \u003d getStartTime(entity.getEntityId(),\n+          entity.getEntityType(), entity.getStartTime(), events,\n+          writeBatch);\n+      if (revStartTime \u003d\u003d null) {\n+        // if no start time is found, add an error and return\n+        TimelinePutError error \u003d new TimelinePutError();\n+        error.setEntityId(entity.getEntityId());\n+        error.setEntityType(entity.getEntityType());\n+        error.setErrorCode(TimelinePutError.NO_START_TIME);\n+        response.addError(error);\n+        return;\n+      }\n+      Long revStartTimeLong \u003d readReverseOrderedLong(revStartTime, 0);\n+      Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d entity.getPrimaryFilters();\n+\n+      // write event entries\n+      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n+        for (TimelineEvent event : events) {\n+          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n+          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n+              entity.getEntityType(), revStartTime, revts,\n+              event.getEventType());\n+          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n+          writeBatch.put(key, value);\n+          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n+        }\n+      }\n+\n+      // write related entity entries\n+      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n+          entity.getRelatedEntities();\n+      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n+        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n+            relatedEntities.entrySet()) {\n+          String relatedEntityType \u003d relatedEntityList.getKey();\n+          for (String relatedEntityId : relatedEntityList.getValue()) {\n+            // look up start time of related entity\n+            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n+                relatedEntityType, null, null, writeBatch);\n+            if (relatedEntityStartTime \u003d\u003d null) {\n+              // if start time is not found, set start time of the related\n+              // entity to the start time of this entity, and write it to the\n+              // db and the cache\n+              relatedEntityStartTime \u003d revStartTime;\n+              writeBatch.put(createStartTimeLookupKey(relatedEntityId,\n+                  relatedEntityType), relatedEntityStartTime);\n+              startTimeCache.put(new EntityIdentifier(relatedEntityId,\n+                  relatedEntityType), revStartTimeLong);\n+            }\n+            // write reverse entry (related entity -\u003e entity)\n+            byte[] key \u003d createReleatedEntityKey(relatedEntityId,\n+                relatedEntityType, relatedEntityStartTime,\n+                entity.getEntityId(), entity.getEntityType());\n+            writeBatch.put(key, EMPTY_BYTES);\n+            // TODO: write forward entry (entity -\u003e related entity)?\n+          }\n+        }\n+      }\n+\n+      // write primary filter entries\n+      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n+        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n+            primaryFilters.entrySet()) {\n+          for (Object primaryFilterValue : primaryFilter.getValue()) {\n+            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n+                entity.getEntityType(), revStartTime,\n+                primaryFilter.getKey(), primaryFilterValue);\n+            writeBatch.put(key, EMPTY_BYTES);\n+            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n+                EMPTY_BYTES);\n+          }\n+        }\n+      }\n+\n+      // write other info entries\n+      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n+      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n+        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n+          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n+              entity.getEntityType(), revStartTime, i.getKey());\n+          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n+          writeBatch.put(key, value);\n+          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n+        }\n+      }\n+      db.write(writeBatch);\n+    } catch (IOException e) {\n+      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n+          \" of type \" + entity.getEntityType(), e);\n+      TimelinePutError error \u003d new TimelinePutError();\n+      error.setEntityId(entity.getEntityId());\n+      error.setEntityType(entity.getEntityType());\n+      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n+      response.addError(error);\n+    } finally {\n+      IOUtils.cleanup(LOG, writeBatch);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void put(TimelineEntity entity, TimelinePutResponse response) {\n    WriteBatch writeBatch \u003d null;\n    try {\n      writeBatch \u003d db.createWriteBatch();\n      List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n      // look up the start time for the entity\n      byte[] revStartTime \u003d getStartTime(entity.getEntityId(),\n          entity.getEntityType(), entity.getStartTime(), events,\n          writeBatch);\n      if (revStartTime \u003d\u003d null) {\n        // if no start time is found, add an error and return\n        TimelinePutError error \u003d new TimelinePutError();\n        error.setEntityId(entity.getEntityId());\n        error.setEntityType(entity.getEntityType());\n        error.setErrorCode(TimelinePutError.NO_START_TIME);\n        response.addError(error);\n        return;\n      }\n      Long revStartTimeLong \u003d readReverseOrderedLong(revStartTime, 0);\n      Map\u003cString, Set\u003cObject\u003e\u003e primaryFilters \u003d entity.getPrimaryFilters();\n\n      // write event entries\n      if (events !\u003d null \u0026\u0026 !events.isEmpty()) {\n        for (TimelineEvent event : events) {\n          byte[] revts \u003d writeReverseOrderedLong(event.getTimestamp());\n          byte[] key \u003d createEntityEventKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, revts,\n              event.getEventType());\n          byte[] value \u003d GenericObjectMapper.write(event.getEventInfo());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n\n      // write related entity entries\n      Map\u003cString, Set\u003cString\u003e\u003e relatedEntities \u003d\n          entity.getRelatedEntities();\n      if (relatedEntities !\u003d null \u0026\u0026 !relatedEntities.isEmpty()) {\n        for (Entry\u003cString, Set\u003cString\u003e\u003e relatedEntityList :\n            relatedEntities.entrySet()) {\n          String relatedEntityType \u003d relatedEntityList.getKey();\n          for (String relatedEntityId : relatedEntityList.getValue()) {\n            // look up start time of related entity\n            byte[] relatedEntityStartTime \u003d getStartTime(relatedEntityId,\n                relatedEntityType, null, null, writeBatch);\n            if (relatedEntityStartTime \u003d\u003d null) {\n              // if start time is not found, set start time of the related\n              // entity to the start time of this entity, and write it to the\n              // db and the cache\n              relatedEntityStartTime \u003d revStartTime;\n              writeBatch.put(createStartTimeLookupKey(relatedEntityId,\n                  relatedEntityType), relatedEntityStartTime);\n              startTimeCache.put(new EntityIdentifier(relatedEntityId,\n                  relatedEntityType), revStartTimeLong);\n            }\n            // write reverse entry (related entity -\u003e entity)\n            byte[] key \u003d createReleatedEntityKey(relatedEntityId,\n                relatedEntityType, relatedEntityStartTime,\n                entity.getEntityId(), entity.getEntityType());\n            writeBatch.put(key, EMPTY_BYTES);\n            // TODO: write forward entry (entity -\u003e related entity)?\n          }\n        }\n      }\n\n      // write primary filter entries\n      if (primaryFilters !\u003d null \u0026\u0026 !primaryFilters.isEmpty()) {\n        for (Entry\u003cString, Set\u003cObject\u003e\u003e primaryFilter :\n            primaryFilters.entrySet()) {\n          for (Object primaryFilterValue : primaryFilter.getValue()) {\n            byte[] key \u003d createPrimaryFilterKey(entity.getEntityId(),\n                entity.getEntityType(), revStartTime,\n                primaryFilter.getKey(), primaryFilterValue);\n            writeBatch.put(key, EMPTY_BYTES);\n            writePrimaryFilterEntries(writeBatch, primaryFilters, key,\n                EMPTY_BYTES);\n          }\n        }\n      }\n\n      // write other info entries\n      Map\u003cString, Object\u003e otherInfo \u003d entity.getOtherInfo();\n      if (otherInfo !\u003d null \u0026\u0026 !otherInfo.isEmpty()) {\n        for (Entry\u003cString, Object\u003e i : otherInfo.entrySet()) {\n          byte[] key \u003d createOtherInfoKey(entity.getEntityId(),\n              entity.getEntityType(), revStartTime, i.getKey());\n          byte[] value \u003d GenericObjectMapper.write(i.getValue());\n          writeBatch.put(key, value);\n          writePrimaryFilterEntries(writeBatch, primaryFilters, key, value);\n        }\n      }\n      db.write(writeBatch);\n    } catch (IOException e) {\n      LOG.error(\"Error putting entity \" + entity.getEntityId() +\n          \" of type \" + entity.getEntityType(), e);\n      TimelinePutError error \u003d new TimelinePutError();\n      error.setEntityId(entity.getEntityId());\n      error.setEntityType(entity.getEntityType());\n      error.setErrorCode(TimelinePutError.IO_EXCEPTION);\n      response.addError(error);\n    } finally {\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/timeline/LeveldbTimelineStore.java"
    }
  }
}