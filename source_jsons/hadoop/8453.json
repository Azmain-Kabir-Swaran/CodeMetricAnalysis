{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SecondaryNameNode.java",
  "functionName": "doWork",
  "functionId": "doWork",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
  "functionStartLine": 333,
  "functionEndLine": 380,
  "numCommitsSeen": 98,
  "timeTaken": 7147,
  "changeHistory": [
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
    "aa22450442ebe39916a6fd460fe97e347945526d",
    "64c50d9dfb2247852b9e03fd3e41ce426f872e94",
    "45b9d19f9d2b14e4d3c386af9de3df817da3c9df",
    "cfa86e611077e19064568a35a191250a57c75db7",
    "527933f4f351a3df5e369c8bb6e2cfc4937e0836",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e",
    "cdae6953e80e81693bb4c9eb38b62eaba3ac8cf9",
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568": "Ybodychange",
    "aa22450442ebe39916a6fd460fe97e347945526d": "Ybodychange",
    "64c50d9dfb2247852b9e03fd3e41ce426f872e94": "Ybodychange",
    "45b9d19f9d2b14e4d3c386af9de3df817da3c9df": "Ybodychange",
    "cfa86e611077e19064568a35a191250a57c75db7": "Ybodychange",
    "527933f4f351a3df5e369c8bb6e2cfc4937e0836": "Ybodychange",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": "Ybodychange",
    "cdae6953e80e81693bb4c9eb38b62eaba3ac8cf9": "Ybodychange",
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": "Ybodychange",
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13695. Move logging to slf4j in HDFS package. Contributed by Ian Pickering.\n",
      "commitDate": "06/09/18 2:48 PM",
      "commitName": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "14/08/18 5:19 PM",
      "commitNameOld": "363bd16e314490e31758cc82de584e75cd8357cc",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 22.9,
      "commitsBetweenForRepo": 138,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   public void doWork() {\n     //\n     // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n     // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n     //\n     long period \u003d checkpointConf.getCheckPeriod();\n     int maxRetries \u003d checkpointConf.getMaxRetriesOnMergeError();\n \n     while (shouldRun) {\n       try {\n         Thread.sleep(1000 * period);\n       } catch (InterruptedException ie) {\n         // do nothing\n       }\n       if (!shouldRun) {\n         break;\n       }\n       try {\n         // We may have lost our ticket since last checkpoint, log in again, just in case\n         if(UserGroupInformation.isSecurityEnabled())\n           UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n         \n         final long monotonicNow \u003d Time.monotonicNow();\n         final long now \u003d Time.now();\n \n         if (shouldCheckpointBasedOnCount() ||\n             monotonicNow \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n           doCheckpoint();\n           lastCheckpointTime \u003d monotonicNow;\n           lastCheckpointWallclockTime \u003d now;\n         }\n       } catch (IOException e) {\n         LOG.error(\"Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         // Prevent a huge number of edits from being created due to\n         // unrecoverable conditions and endless retries.\n         if (checkpointImage.getMergeErrorCount() \u003e maxRetries) {\n-          LOG.fatal(\"Merging failed \" + \n+          LOG.error(\"Merging failed \" +\n               checkpointImage.getMergeErrorCount() + \" times.\");\n           terminate(1);\n         }\n       } catch (Throwable e) {\n-        LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n+        LOG.error(\"Throwable Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         terminate(1, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doWork() {\n    //\n    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n    //\n    long period \u003d checkpointConf.getCheckPeriod();\n    int maxRetries \u003d checkpointConf.getMaxRetriesOnMergeError();\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n        \n        final long monotonicNow \u003d Time.monotonicNow();\n        final long now \u003d Time.now();\n\n        if (shouldCheckpointBasedOnCount() ||\n            monotonicNow \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n          doCheckpoint();\n          lastCheckpointTime \u003d monotonicNow;\n          lastCheckpointWallclockTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        // Prevent a huge number of edits from being created due to\n        // unrecoverable conditions and endless retries.\n        if (checkpointImage.getMergeErrorCount() \u003e maxRetries) {\n          LOG.error(\"Merging failed \" +\n              checkpointImage.getMergeErrorCount() + \" times.\");\n          terminate(1);\n        }\n      } catch (Throwable e) {\n        LOG.error(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        terminate(1, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "aa22450442ebe39916a6fd460fe97e347945526d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8214. Secondary NN Web UI shows wrong date for Last Checkpoint. Contributed by Charles Lamb.\n",
      "commitDate": "29/04/15 5:37 PM",
      "commitName": "aa22450442ebe39916a6fd460fe97e347945526d",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "02/03/15 9:17 PM",
      "commitNameOld": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 57.81,
      "commitsBetweenForRepo": 505,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,48 @@\n   public void doWork() {\n     //\n     // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n     // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n     //\n     long period \u003d checkpointConf.getCheckPeriod();\n     int maxRetries \u003d checkpointConf.getMaxRetriesOnMergeError();\n \n     while (shouldRun) {\n       try {\n         Thread.sleep(1000 * period);\n       } catch (InterruptedException ie) {\n         // do nothing\n       }\n       if (!shouldRun) {\n         break;\n       }\n       try {\n         // We may have lost our ticket since last checkpoint, log in again, just in case\n         if(UserGroupInformation.isSecurityEnabled())\n           UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n         \n-        final long now \u003d Time.monotonicNow();\n+        final long monotonicNow \u003d Time.monotonicNow();\n+        final long now \u003d Time.now();\n \n         if (shouldCheckpointBasedOnCount() ||\n-            now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n+            monotonicNow \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n           doCheckpoint();\n-          lastCheckpointTime \u003d now;\n+          lastCheckpointTime \u003d monotonicNow;\n+          lastCheckpointWallclockTime \u003d now;\n         }\n       } catch (IOException e) {\n         LOG.error(\"Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         // Prevent a huge number of edits from being created due to\n         // unrecoverable conditions and endless retries.\n         if (checkpointImage.getMergeErrorCount() \u003e maxRetries) {\n           LOG.fatal(\"Merging failed \" + \n               checkpointImage.getMergeErrorCount() + \" times.\");\n           terminate(1);\n         }\n       } catch (Throwable e) {\n         LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         terminate(1, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doWork() {\n    //\n    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n    //\n    long period \u003d checkpointConf.getCheckPeriod();\n    int maxRetries \u003d checkpointConf.getMaxRetriesOnMergeError();\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n        \n        final long monotonicNow \u003d Time.monotonicNow();\n        final long now \u003d Time.now();\n\n        if (shouldCheckpointBasedOnCount() ||\n            monotonicNow \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n          doCheckpoint();\n          lastCheckpointTime \u003d monotonicNow;\n          lastCheckpointWallclockTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        // Prevent a huge number of edits from being created due to\n        // unrecoverable conditions and endless retries.\n        if (checkpointImage.getMergeErrorCount() \u003e maxRetries) {\n          LOG.fatal(\"Merging failed \" + \n              checkpointImage.getMergeErrorCount() + \" times.\");\n          terminate(1);\n        }\n      } catch (Throwable e) {\n        LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        terminate(1, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "64c50d9dfb2247852b9e03fd3e41ce426f872e94": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5591. Checkpointing should use monotonic time when calculating period. Contributed by Charles Lamb.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1583926 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/04/14 1:33 AM",
      "commitName": "64c50d9dfb2247852b9e03fd3e41ce426f872e94",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "24/03/14 4:32 PM",
      "commitNameOld": "c2ef7e239eb0e81cf8a3e971378e9e696202de67",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 8.38,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   public void doWork() {\n     //\n     // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n     // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n     //\n     long period \u003d checkpointConf.getCheckPeriod();\n     int maxRetries \u003d checkpointConf.getMaxRetriesOnMergeError();\n \n     while (shouldRun) {\n       try {\n         Thread.sleep(1000 * period);\n       } catch (InterruptedException ie) {\n         // do nothing\n       }\n       if (!shouldRun) {\n         break;\n       }\n       try {\n         // We may have lost our ticket since last checkpoint, log in again, just in case\n         if(UserGroupInformation.isSecurityEnabled())\n           UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n         \n-        long now \u003d Time.now();\n+        final long now \u003d Time.monotonicNow();\n \n         if (shouldCheckpointBasedOnCount() ||\n             now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n           doCheckpoint();\n           lastCheckpointTime \u003d now;\n         }\n       } catch (IOException e) {\n         LOG.error(\"Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         // Prevent a huge number of edits from being created due to\n         // unrecoverable conditions and endless retries.\n         if (checkpointImage.getMergeErrorCount() \u003e maxRetries) {\n           LOG.fatal(\"Merging failed \" + \n               checkpointImage.getMergeErrorCount() + \" times.\");\n           terminate(1);\n         }\n       } catch (Throwable e) {\n         LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         terminate(1, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doWork() {\n    //\n    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n    //\n    long period \u003d checkpointConf.getCheckPeriod();\n    int maxRetries \u003d checkpointConf.getMaxRetriesOnMergeError();\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n        \n        final long now \u003d Time.monotonicNow();\n\n        if (shouldCheckpointBasedOnCount() ||\n            now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n          doCheckpoint();\n          lastCheckpointTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        // Prevent a huge number of edits from being created due to\n        // unrecoverable conditions and endless retries.\n        if (checkpointImage.getMergeErrorCount() \u003e maxRetries) {\n          LOG.fatal(\"Merging failed \" + \n              checkpointImage.getMergeErrorCount() + \" times.\");\n          terminate(1);\n        }\n      } catch (Throwable e) {\n        LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        terminate(1, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "45b9d19f9d2b14e4d3c386af9de3df817da3c9df": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4780. Use the correct relogin method for services. Contributed by Robert Parker.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1486974 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/05/13 8:47 AM",
      "commitName": "45b9d19f9d2b14e4d3c386af9de3df817da3c9df",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "22/05/13 12:37 PM",
      "commitNameOld": "8c62c46046656c01b327c378e89d57b4bf37e16e",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 5.84,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   public void doWork() {\n     //\n     // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n     // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n     //\n     long period \u003d checkpointConf.getCheckPeriod();\n     int maxRetries \u003d checkpointConf.getMaxRetriesOnMergeError();\n \n     while (shouldRun) {\n       try {\n         Thread.sleep(1000 * period);\n       } catch (InterruptedException ie) {\n         // do nothing\n       }\n       if (!shouldRun) {\n         break;\n       }\n       try {\n         // We may have lost our ticket since last checkpoint, log in again, just in case\n         if(UserGroupInformation.isSecurityEnabled())\n-          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n+          UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n         \n         long now \u003d Time.now();\n \n         if (shouldCheckpointBasedOnCount() ||\n             now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n           doCheckpoint();\n           lastCheckpointTime \u003d now;\n         }\n       } catch (IOException e) {\n         LOG.error(\"Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         // Prevent a huge number of edits from being created due to\n         // unrecoverable conditions and endless retries.\n         if (checkpointImage.getMergeErrorCount() \u003e maxRetries) {\n           LOG.fatal(\"Merging failed \" + \n               checkpointImage.getMergeErrorCount() + \" times.\");\n           terminate(1);\n         }\n       } catch (Throwable e) {\n         LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         terminate(1, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doWork() {\n    //\n    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n    //\n    long period \u003d checkpointConf.getCheckPeriod();\n    int maxRetries \u003d checkpointConf.getMaxRetriesOnMergeError();\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().checkTGTAndReloginFromKeytab();\n        \n        long now \u003d Time.now();\n\n        if (shouldCheckpointBasedOnCount() ||\n            now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n          doCheckpoint();\n          lastCheckpointTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        // Prevent a huge number of edits from being created due to\n        // unrecoverable conditions and endless retries.\n        if (checkpointImage.getMergeErrorCount() \u003e maxRetries) {\n          LOG.fatal(\"Merging failed \" + \n              checkpointImage.getMergeErrorCount() + \" times.\");\n          terminate(1);\n        }\n      } catch (Throwable e) {\n        LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        terminate(1, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "cfa86e611077e19064568a35a191250a57c75db7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4128. 2NN gets stuck in inconsistent state if edit log replay fails in the middle (kihwal via daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1452384 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/03/13 8:44 AM",
      "commitName": "cfa86e611077e19064568a35a191250a57c75db7",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "04/02/13 1:29 PM",
      "commitNameOld": "a8e39feed2642dbfedb8fd22648904ad4bb6af97",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 27.8,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,46 @@\n   public void doWork() {\n     //\n     // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n     // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n     //\n     long period \u003d checkpointConf.getCheckPeriod();\n+    int maxRetries \u003d checkpointConf.getMaxRetriesOnMergeError();\n \n     while (shouldRun) {\n       try {\n         Thread.sleep(1000 * period);\n       } catch (InterruptedException ie) {\n         // do nothing\n       }\n       if (!shouldRun) {\n         break;\n       }\n       try {\n         // We may have lost our ticket since last checkpoint, log in again, just in case\n         if(UserGroupInformation.isSecurityEnabled())\n           UserGroupInformation.getCurrentUser().reloginFromKeytab();\n         \n         long now \u003d Time.now();\n \n         if (shouldCheckpointBasedOnCount() ||\n             now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n           doCheckpoint();\n           lastCheckpointTime \u003d now;\n         }\n       } catch (IOException e) {\n         LOG.error(\"Exception in doCheckpoint\", e);\n         e.printStackTrace();\n+        // Prevent a huge number of edits from being created due to\n+        // unrecoverable conditions and endless retries.\n+        if (checkpointImage.getMergeErrorCount() \u003e maxRetries) {\n+          LOG.fatal(\"Merging failed \" + \n+              checkpointImage.getMergeErrorCount() + \" times.\");\n+          terminate(1);\n+        }\n       } catch (Throwable e) {\n         LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         terminate(1, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doWork() {\n    //\n    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n    //\n    long period \u003d checkpointConf.getCheckPeriod();\n    int maxRetries \u003d checkpointConf.getMaxRetriesOnMergeError();\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n        \n        long now \u003d Time.now();\n\n        if (shouldCheckpointBasedOnCount() ||\n            now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n          doCheckpoint();\n          lastCheckpointTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        // Prevent a huge number of edits from being created due to\n        // unrecoverable conditions and endless retries.\n        if (checkpointImage.getMergeErrorCount() \u003e maxRetries) {\n          LOG.fatal(\"Merging failed \" + \n              checkpointImage.getMergeErrorCount() + \" times.\");\n          terminate(1);\n        }\n      } catch (Throwable e) {\n        LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        terminate(1, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "527933f4f351a3df5e369c8bb6e2cfc4937e0836": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3666. Plumb more exception messages to terminate. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362270 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 2:26 PM",
      "commitName": "527933f4f351a3df5e369c8bb6e2cfc4937e0836",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "15/07/12 7:58 PM",
      "commitNameOld": "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 0.77,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   public void doWork() {\n     //\n     // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n     // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n     //\n     long period \u003d checkpointConf.getCheckPeriod();\n \n     while (shouldRun) {\n       try {\n         Thread.sleep(1000 * period);\n       } catch (InterruptedException ie) {\n         // do nothing\n       }\n       if (!shouldRun) {\n         break;\n       }\n       try {\n         // We may have lost our ticket since last checkpoint, log in again, just in case\n         if(UserGroupInformation.isSecurityEnabled())\n           UserGroupInformation.getCurrentUser().reloginFromKeytab();\n         \n         long now \u003d Time.now();\n \n         if (shouldCheckpointBasedOnCount() ||\n             now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n           doCheckpoint();\n           lastCheckpointTime \u003d now;\n         }\n       } catch (IOException e) {\n         LOG.error(\"Exception in doCheckpoint\", e);\n         e.printStackTrace();\n       } catch (Throwable e) {\n         LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n         e.printStackTrace();\n-        terminate(1);\n+        terminate(1, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doWork() {\n    //\n    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n    //\n    long period \u003d checkpointConf.getCheckPeriod();\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n        \n        long now \u003d Time.now();\n\n        if (shouldCheckpointBasedOnCount() ||\n            now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n          doCheckpoint();\n          lastCheckpointTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n      } catch (Throwable e) {\n        LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        terminate(1, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3641. Move server Util time methods to common and use now instead of System#currentTimeMillis. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1360858 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 12:01 PM",
      "commitName": "4a5ba3b7bd2360fd9605863630b477d362874e1e",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "11/07/12 10:58 AM",
      "commitNameOld": "cdae6953e80e81693bb4c9eb38b62eaba3ac8cf9",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 1.04,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   public void doWork() {\n     //\n     // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n     // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n     //\n     long period \u003d checkpointConf.getCheckPeriod();\n \n     while (shouldRun) {\n       try {\n         Thread.sleep(1000 * period);\n       } catch (InterruptedException ie) {\n         // do nothing\n       }\n       if (!shouldRun) {\n         break;\n       }\n       try {\n         // We may have lost our ticket since last checkpoint, log in again, just in case\n         if(UserGroupInformation.isSecurityEnabled())\n           UserGroupInformation.getCurrentUser().reloginFromKeytab();\n         \n-        long now \u003d System.currentTimeMillis();\n+        long now \u003d Time.now();\n \n         if (shouldCheckpointBasedOnCount() ||\n             now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n           doCheckpoint();\n           lastCheckpointTime \u003d now;\n         }\n       } catch (IOException e) {\n         LOG.error(\"Exception in doCheckpoint\", e);\n         e.printStackTrace();\n       } catch (Throwable e) {\n         LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         terminate(1);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doWork() {\n    //\n    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n    //\n    long period \u003d checkpointConf.getCheckPeriod();\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n        \n        long now \u003d Time.now();\n\n        if (shouldCheckpointBasedOnCount() ||\n            now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n          doCheckpoint();\n          lastCheckpointTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n      } catch (Throwable e) {\n        LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        terminate(1);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "cdae6953e80e81693bb4c9eb38b62eaba3ac8cf9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3582. Hook daemon process exit for testing. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1360329 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/07/12 10:58 AM",
      "commitName": "cdae6953e80e81693bb4c9eb38b62eaba3ac8cf9",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "27/06/12 3:41 PM",
      "commitNameOld": "5770a453f304d83463879db6101da1f1e81e5563",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 13.8,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   public void doWork() {\n     //\n     // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n     // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n     //\n     long period \u003d checkpointConf.getCheckPeriod();\n \n     while (shouldRun) {\n       try {\n         Thread.sleep(1000 * period);\n       } catch (InterruptedException ie) {\n         // do nothing\n       }\n       if (!shouldRun) {\n         break;\n       }\n       try {\n         // We may have lost our ticket since last checkpoint, log in again, just in case\n         if(UserGroupInformation.isSecurityEnabled())\n           UserGroupInformation.getCurrentUser().reloginFromKeytab();\n         \n         long now \u003d System.currentTimeMillis();\n \n         if (shouldCheckpointBasedOnCount() ||\n             now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n           doCheckpoint();\n           lastCheckpointTime \u003d now;\n         }\n       } catch (IOException e) {\n         LOG.error(\"Exception in doCheckpoint\", e);\n         e.printStackTrace();\n       } catch (Throwable e) {\n-        LOG.error(\"Throwable Exception in doCheckpoint\", e);\n+        LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n         e.printStackTrace();\n-        Runtime.getRuntime().exit(-1);\n+        terminate(1);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doWork() {\n    //\n    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n    //\n    long period \u003d checkpointConf.getCheckPeriod();\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n        \n        long now \u003d System.currentTimeMillis();\n\n        if (shouldCheckpointBasedOnCount() ||\n            now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n          doCheckpoint();\n          lastCheckpointTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n      } catch (Throwable e) {\n        LOG.fatal(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        terminate(1);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2291. Allow the StandbyNode to make checkpoints in an HA setup. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1227411 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/01/12 4:22 PM",
      "commitName": "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "30/12/11 5:53 PM",
      "commitNameOld": "737df8b67b972155b12ed615e23f3f1e8e4e9ca9",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 4.94,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   public void doWork() {\n \n     //\n     // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n     // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n     //\n-    long period \u003d Math.min(checkpointCheckPeriod, checkpointPeriod);\n+    long period \u003d checkpointConf.getCheckPeriod();\n \n     while (shouldRun) {\n       try {\n         Thread.sleep(1000 * period);\n       } catch (InterruptedException ie) {\n         // do nothing\n       }\n       if (!shouldRun) {\n         break;\n       }\n       try {\n         // We may have lost our ticket since last checkpoint, log in again, just in case\n         if(UserGroupInformation.isSecurityEnabled())\n           UserGroupInformation.getCurrentUser().reloginFromKeytab();\n         \n         long now \u003d System.currentTimeMillis();\n \n         if (shouldCheckpointBasedOnCount() ||\n-            now \u003e\u003d lastCheckpointTime + 1000 * checkpointPeriod) {\n+            now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n           doCheckpoint();\n           lastCheckpointTime \u003d now;\n         }\n       } catch (IOException e) {\n         LOG.error(\"Exception in doCheckpoint\", e);\n         e.printStackTrace();\n       } catch (Throwable e) {\n         LOG.error(\"Throwable Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         Runtime.getRuntime().exit(-1);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doWork() {\n\n    //\n    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n    //\n    long period \u003d checkpointConf.getCheckPeriod();\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n        \n        long now \u003d System.currentTimeMillis();\n\n        if (shouldCheckpointBasedOnCount() ||\n            now \u003e\u003d lastCheckpointTime + 1000 * checkpointConf.getPeriod()) {\n          doCheckpoint();\n          lastCheckpointTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n      } catch (Throwable e) {\n        LOG.error(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        Runtime.getRuntime().exit(-1);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void doWork() {\n\n    //\n    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n    //\n    long period \u003d Math.min(checkpointCheckPeriod, checkpointPeriod);\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n        \n        long now \u003d System.currentTimeMillis();\n\n        if (shouldCheckpointBasedOnCount() ||\n            now \u003e\u003d lastCheckpointTime + 1000 * checkpointPeriod) {\n          doCheckpoint();\n          lastCheckpointTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n      } catch (Throwable e) {\n        LOG.error(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        Runtime.getRuntime().exit(-1);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void doWork() {\n\n    //\n    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n    //\n    long period \u003d Math.min(checkpointCheckPeriod, checkpointPeriod);\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n        \n        long now \u003d System.currentTimeMillis();\n\n        if (shouldCheckpointBasedOnCount() ||\n            now \u003e\u003d lastCheckpointTime + 1000 * checkpointPeriod) {\n          doCheckpoint();\n          lastCheckpointTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n      } catch (Throwable e) {\n        LOG.error(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        Runtime.getRuntime().exit(-1);\n      }\n    }\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java"
      }
    },
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/11 9:28 AM",
      "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "27/07/11 8:19 PM",
      "commitNameOld": "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 1.55,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,39 @@\n   public void doWork() {\n \n     //\n-    // Poll the Namenode (once every 5 minutes) to find the size of the\n-    // pending edit log.\n+    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n+    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n     //\n-    long period \u003d 5 * 60;              // 5 minutes\n-    if (checkpointPeriod \u003c period) {\n-      period \u003d checkpointPeriod;\n-    }\n+    long period \u003d Math.min(checkpointCheckPeriod, checkpointPeriod);\n \n     while (shouldRun) {\n       try {\n         Thread.sleep(1000 * period);\n       } catch (InterruptedException ie) {\n         // do nothing\n       }\n       if (!shouldRun) {\n         break;\n       }\n       try {\n         // We may have lost our ticket since last checkpoint, log in again, just in case\n         if(UserGroupInformation.isSecurityEnabled())\n           UserGroupInformation.getCurrentUser().reloginFromKeytab();\n         \n         long now \u003d System.currentTimeMillis();\n \n-        long size \u003d namenode.getEditLogSize();\n-        if (size \u003e\u003d checkpointSize || \n+        if (shouldCheckpointBasedOnCount() ||\n             now \u003e\u003d lastCheckpointTime + 1000 * checkpointPeriod) {\n           doCheckpoint();\n           lastCheckpointTime \u003d now;\n         }\n       } catch (IOException e) {\n         LOG.error(\"Exception in doCheckpoint\", e);\n         e.printStackTrace();\n-        checkpointImage.getStorage().imageDigest \u003d null;\n       } catch (Throwable e) {\n         LOG.error(\"Throwable Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         Runtime.getRuntime().exit(-1);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doWork() {\n\n    //\n    // Poll the Namenode (once every checkpointCheckPeriod seconds) to find the\n    // number of transactions in the edit log that haven\u0027t yet been checkpointed.\n    //\n    long period \u003d Math.min(checkpointCheckPeriod, checkpointPeriod);\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n        \n        long now \u003d System.currentTimeMillis();\n\n        if (shouldCheckpointBasedOnCount() ||\n            now \u003e\u003d lastCheckpointTime + 1000 * checkpointPeriod) {\n          doCheckpoint();\n          lastCheckpointTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n      } catch (Throwable e) {\n        LOG.error(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        Runtime.getRuntime().exit(-1);\n      }\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1977. Stop using StringUtils.stringifyException(). Contributed by Bharath Mundlapudi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1145834 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/11 6:11 PM",
      "commitName": "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "24/06/11 11:18 AM",
      "commitNameOld": "4c4eed13d5c3155e6a45fb06422e0f9059abfa9c",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 18.29,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,44 @@\n   public void doWork() {\n \n     //\n     // Poll the Namenode (once every 5 minutes) to find the size of the\n     // pending edit log.\n     //\n     long period \u003d 5 * 60;              // 5 minutes\n     if (checkpointPeriod \u003c period) {\n       period \u003d checkpointPeriod;\n     }\n \n     while (shouldRun) {\n       try {\n         Thread.sleep(1000 * period);\n       } catch (InterruptedException ie) {\n         // do nothing\n       }\n       if (!shouldRun) {\n         break;\n       }\n       try {\n         // We may have lost our ticket since last checkpoint, log in again, just in case\n         if(UserGroupInformation.isSecurityEnabled())\n           UserGroupInformation.getCurrentUser().reloginFromKeytab();\n         \n         long now \u003d System.currentTimeMillis();\n \n         long size \u003d namenode.getEditLogSize();\n         if (size \u003e\u003d checkpointSize || \n             now \u003e\u003d lastCheckpointTime + 1000 * checkpointPeriod) {\n           doCheckpoint();\n           lastCheckpointTime \u003d now;\n         }\n       } catch (IOException e) {\n-        LOG.error(\"Exception in doCheckpoint: \");\n-        LOG.error(StringUtils.stringifyException(e));\n+        LOG.error(\"Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         checkpointImage.getStorage().imageDigest \u003d null;\n       } catch (Throwable e) {\n-        LOG.error(\"Throwable Exception in doCheckpoint: \");\n-        LOG.error(StringUtils.stringifyException(e));\n+        LOG.error(\"Throwable Exception in doCheckpoint\", e);\n         e.printStackTrace();\n         Runtime.getRuntime().exit(-1);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doWork() {\n\n    //\n    // Poll the Namenode (once every 5 minutes) to find the size of the\n    // pending edit log.\n    //\n    long period \u003d 5 * 60;              // 5 minutes\n    if (checkpointPeriod \u003c period) {\n      period \u003d checkpointPeriod;\n    }\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n        \n        long now \u003d System.currentTimeMillis();\n\n        long size \u003d namenode.getEditLogSize();\n        if (size \u003e\u003d checkpointSize || \n            now \u003e\u003d lastCheckpointTime + 1000 * checkpointPeriod) {\n          doCheckpoint();\n          lastCheckpointTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        checkpointImage.getStorage().imageDigest \u003d null;\n      } catch (Throwable e) {\n        LOG.error(\"Throwable Exception in doCheckpoint\", e);\n        e.printStackTrace();\n        Runtime.getRuntime().exit(-1);\n      }\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,46 @@\n+  public void doWork() {\n+\n+    //\n+    // Poll the Namenode (once every 5 minutes) to find the size of the\n+    // pending edit log.\n+    //\n+    long period \u003d 5 * 60;              // 5 minutes\n+    if (checkpointPeriod \u003c period) {\n+      period \u003d checkpointPeriod;\n+    }\n+\n+    while (shouldRun) {\n+      try {\n+        Thread.sleep(1000 * period);\n+      } catch (InterruptedException ie) {\n+        // do nothing\n+      }\n+      if (!shouldRun) {\n+        break;\n+      }\n+      try {\n+        // We may have lost our ticket since last checkpoint, log in again, just in case\n+        if(UserGroupInformation.isSecurityEnabled())\n+          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n+        \n+        long now \u003d System.currentTimeMillis();\n+\n+        long size \u003d namenode.getEditLogSize();\n+        if (size \u003e\u003d checkpointSize || \n+            now \u003e\u003d lastCheckpointTime + 1000 * checkpointPeriod) {\n+          doCheckpoint();\n+          lastCheckpointTime \u003d now;\n+        }\n+      } catch (IOException e) {\n+        LOG.error(\"Exception in doCheckpoint: \");\n+        LOG.error(StringUtils.stringifyException(e));\n+        e.printStackTrace();\n+        checkpointImage.getStorage().imageDigest \u003d null;\n+      } catch (Throwable e) {\n+        LOG.error(\"Throwable Exception in doCheckpoint: \");\n+        LOG.error(StringUtils.stringifyException(e));\n+        e.printStackTrace();\n+        Runtime.getRuntime().exit(-1);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void doWork() {\n\n    //\n    // Poll the Namenode (once every 5 minutes) to find the size of the\n    // pending edit log.\n    //\n    long period \u003d 5 * 60;              // 5 minutes\n    if (checkpointPeriod \u003c period) {\n      period \u003d checkpointPeriod;\n    }\n\n    while (shouldRun) {\n      try {\n        Thread.sleep(1000 * period);\n      } catch (InterruptedException ie) {\n        // do nothing\n      }\n      if (!shouldRun) {\n        break;\n      }\n      try {\n        // We may have lost our ticket since last checkpoint, log in again, just in case\n        if(UserGroupInformation.isSecurityEnabled())\n          UserGroupInformation.getCurrentUser().reloginFromKeytab();\n        \n        long now \u003d System.currentTimeMillis();\n\n        long size \u003d namenode.getEditLogSize();\n        if (size \u003e\u003d checkpointSize || \n            now \u003e\u003d lastCheckpointTime + 1000 * checkpointPeriod) {\n          doCheckpoint();\n          lastCheckpointTime \u003d now;\n        }\n      } catch (IOException e) {\n        LOG.error(\"Exception in doCheckpoint: \");\n        LOG.error(StringUtils.stringifyException(e));\n        e.printStackTrace();\n        checkpointImage.getStorage().imageDigest \u003d null;\n      } catch (Throwable e) {\n        LOG.error(\"Throwable Exception in doCheckpoint: \");\n        LOG.error(StringUtils.stringifyException(e));\n        e.printStackTrace();\n        Runtime.getRuntime().exit(-1);\n      }\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/SecondaryNameNode.java"
    }
  }
}