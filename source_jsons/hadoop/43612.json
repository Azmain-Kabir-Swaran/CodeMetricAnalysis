{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ServiceManager.java",
  "functionName": "processUpgradeRequest",
  "functionId": "processUpgradeRequest___upgradeVersion-String__autoFinalize-boolean__expressUpgrade-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/ServiceManager.java",
  "functionStartLine": 404,
  "functionEndLine": 454,
  "numCommitsSeen": 12,
  "timeTaken": 3925,
  "changeHistory": [
    "913f87dada27776c539dfb352400ecf8d40e7943",
    "e557c6bd8de2811a561210f672f47b4d07a9d5c6",
    "7f083ed8699a720d3fb82e4ec310356902a6ac30",
    "4a7369b09547a78f532af66c763c6994a38b5d68"
  ],
  "changeHistoryShort": {
    "913f87dada27776c539dfb352400ecf8d40e7943": "Ybodychange",
    "e557c6bd8de2811a561210f672f47b4d07a9d5c6": "Ymultichange(Yparameterchange,Ybodychange)",
    "7f083ed8699a720d3fb82e4ec310356902a6ac30": "Ybodychange",
    "4a7369b09547a78f532af66c763c6994a38b5d68": "Yintroduced"
  },
  "changeHistoryDetails": {
    "913f87dada27776c539dfb352400ecf8d40e7943": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8665.  Added Yarn service cancel upgrade option.\n            Contributed by Chandni Singh\n",
      "commitDate": "26/09/18 11:51 AM",
      "commitName": "913f87dada27776c539dfb352400ecf8d40e7943",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "21/08/18 4:49 PM",
      "commitNameOld": "e557c6bd8de2811a561210f672f47b4d07a9d5c6",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 35.79,
      "commitsBetweenForRepo": 332,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,51 @@\n   void processUpgradeRequest(String upgradeVersion,\n       boolean autoFinalize, boolean expressUpgrade) throws IOException {\n     Service targetSpec \u003d ServiceApiUtil.loadServiceUpgrade(\n         context.fs, context.service.getName(), upgradeVersion);\n \n     List\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n-        compsNeedUpgradeList \u003d componentsFinder.\n-        findTargetComponentSpecs(context.service, targetSpec);\n-\n-    // remove all components from need upgrade list if there restart policy\n-    // doesn\u0027t all upgrade.\n-    if (compsNeedUpgradeList !\u003d null) {\n-      compsNeedUpgradeList.removeIf(component -\u003e {\n-        org.apache.hadoop.yarn.service.api.records.Component.RestartPolicyEnum\n-            restartPolicy \u003d component.getRestartPolicy();\n-\n-        final ComponentRestartPolicy restartPolicyHandler \u003d\n-            Component.getRestartPolicyHandler(restartPolicy);\n-        // Do not allow upgrades for components which have NEVER/ON_FAILURE\n-        // restart policy\n-        if (!restartPolicyHandler.allowUpgrades()) {\n-          LOG.info(\"The component {} has a restart policy that doesnt \" +\n-                  \"allow upgrades {} \", component.getName(),\n-              component.getRestartPolicy().toString());\n-          return true;\n-        }\n-\n-        return false;\n-      });\n-    }\n+        compsNeedUpgradeList \u003d resolveCompsToUpgrade(context.service,\n+        targetSpec);\n \n     ServiceEvent event \u003d new ServiceEvent(ServiceEventType.UPGRADE)\n         .setVersion(upgradeVersion)\n         .setAutoFinalize(autoFinalize)\n         .setExpressUpgrade(expressUpgrade);\n \n     if (expressUpgrade) {\n       // In case of express upgrade  components need to be upgraded in order.\n       // Once the service manager gets notified that a component finished\n       // upgrading, it then issues event to upgrade the next component.\n       Map\u003cString, org.apache.hadoop.yarn.service.api.records.Component\u003e\n           compsNeedUpgradeByName \u003d new HashMap\u003c\u003e();\n       if (compsNeedUpgradeList !\u003d null) {\n         compsNeedUpgradeList.forEach(component -\u003e\n             compsNeedUpgradeByName.put(component.getName(), component));\n       }\n       List\u003cString\u003e resolvedComps \u003d ServiceApiUtil\n           .resolveCompsDependency(targetSpec);\n \n-      Queue\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n+      List\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n           orderedCompUpgrade \u003d new LinkedList\u003c\u003e();\n       resolvedComps.forEach(compName -\u003e {\n         org.apache.hadoop.yarn.service.api.records.Component component \u003d\n             compsNeedUpgradeByName.get(compName);\n         if (component !\u003d null ) {\n           orderedCompUpgrade.add(component);\n         }\n       });\n-      event.setCompsToUpgradeInOrder(orderedCompUpgrade);\n+      event.setCompsToUpgrade(orderedCompUpgrade);\n+    } else {\n+      event.setCompsToUpgrade(compsNeedUpgradeList);\n     }\n+    context.scheduler.getDispatcher().getEventHandler().handle(\n+        event);\n \n-    context.scheduler.getDispatcher().getEventHandler().handle(event);\n-\n-    if (compsNeedUpgradeList !\u003d null \u0026\u0026 !compsNeedUpgradeList.isEmpty()) {\n-      if (!expressUpgrade) {\n-        compsNeedUpgradeList.forEach(component -\u003e {\n-          ComponentEvent needUpgradeEvent \u003d new ComponentEvent(\n-              component.getName(), ComponentEventType.UPGRADE).setTargetSpec(\n-              component).setUpgradeVersion(event.getVersion());\n-          context.scheduler.getDispatcher().getEventHandler().handle(\n-              needUpgradeEvent);\n-\n-        });\n-      }\n-    }  else if (autoFinalize) {\n-      // nothing to upgrade if upgrade auto finalize is requested, trigger a\n+    if (autoFinalize \u0026\u0026 (compsNeedUpgradeList \u003d\u003d null ||\n+        compsNeedUpgradeList.isEmpty())) {\n+      // nothing to upgrade and auto finalize is requested, trigger a\n       // state check.\n       context.scheduler.getDispatcher().getEventHandler().handle(\n           new ServiceEvent(ServiceEventType.CHECK_STABLE));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void processUpgradeRequest(String upgradeVersion,\n      boolean autoFinalize, boolean expressUpgrade) throws IOException {\n    Service targetSpec \u003d ServiceApiUtil.loadServiceUpgrade(\n        context.fs, context.service.getName(), upgradeVersion);\n\n    List\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n        compsNeedUpgradeList \u003d resolveCompsToUpgrade(context.service,\n        targetSpec);\n\n    ServiceEvent event \u003d new ServiceEvent(ServiceEventType.UPGRADE)\n        .setVersion(upgradeVersion)\n        .setAutoFinalize(autoFinalize)\n        .setExpressUpgrade(expressUpgrade);\n\n    if (expressUpgrade) {\n      // In case of express upgrade  components need to be upgraded in order.\n      // Once the service manager gets notified that a component finished\n      // upgrading, it then issues event to upgrade the next component.\n      Map\u003cString, org.apache.hadoop.yarn.service.api.records.Component\u003e\n          compsNeedUpgradeByName \u003d new HashMap\u003c\u003e();\n      if (compsNeedUpgradeList !\u003d null) {\n        compsNeedUpgradeList.forEach(component -\u003e\n            compsNeedUpgradeByName.put(component.getName(), component));\n      }\n      List\u003cString\u003e resolvedComps \u003d ServiceApiUtil\n          .resolveCompsDependency(targetSpec);\n\n      List\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n          orderedCompUpgrade \u003d new LinkedList\u003c\u003e();\n      resolvedComps.forEach(compName -\u003e {\n        org.apache.hadoop.yarn.service.api.records.Component component \u003d\n            compsNeedUpgradeByName.get(compName);\n        if (component !\u003d null ) {\n          orderedCompUpgrade.add(component);\n        }\n      });\n      event.setCompsToUpgrade(orderedCompUpgrade);\n    } else {\n      event.setCompsToUpgrade(compsNeedUpgradeList);\n    }\n    context.scheduler.getDispatcher().getEventHandler().handle(\n        event);\n\n    if (autoFinalize \u0026\u0026 (compsNeedUpgradeList \u003d\u003d null ||\n        compsNeedUpgradeList.isEmpty())) {\n      // nothing to upgrade and auto finalize is requested, trigger a\n      // state check.\n      context.scheduler.getDispatcher().getEventHandler().handle(\n          new ServiceEvent(ServiceEventType.CHECK_STABLE));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/ServiceManager.java",
      "extendedDetails": {}
    },
    "e557c6bd8de2811a561210f672f47b4d07a9d5c6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-8298.  Added express upgrade for YARN service.\n            Contributed by Chandni Singh\n",
      "commitDate": "21/08/18 4:49 PM",
      "commitName": "e557c6bd8de2811a561210f672f47b4d07a9d5c6",
      "commitAuthor": "Eric Yang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8298.  Added express upgrade for YARN service.\n            Contributed by Chandni Singh\n",
          "commitDate": "21/08/18 4:49 PM",
          "commitName": "e557c6bd8de2811a561210f672f47b4d07a9d5c6",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "17/05/18 2:16 PM",
          "commitNameOld": "7f083ed8699a720d3fb82e4ec310356902a6ac30",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 96.11,
          "commitsBetweenForRepo": 715,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,81 @@\n   void processUpgradeRequest(String upgradeVersion,\n-      boolean autoFinalize) throws IOException {\n+      boolean autoFinalize, boolean expressUpgrade) throws IOException {\n     Service targetSpec \u003d ServiceApiUtil.loadServiceUpgrade(\n         context.fs, context.service.getName(), upgradeVersion);\n \n     List\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n-        compsThatNeedUpgrade \u003d componentsFinder.\n+        compsNeedUpgradeList \u003d componentsFinder.\n         findTargetComponentSpecs(context.service, targetSpec);\n-    ServiceEvent event \u003d new ServiceEvent(ServiceEventType.UPGRADE)\n-        .setVersion(upgradeVersion)\n-        .setAutoFinalize(autoFinalize);\n-    context.scheduler.getDispatcher().getEventHandler().handle(event);\n \n-    if (compsThatNeedUpgrade !\u003d null \u0026\u0026 !compsThatNeedUpgrade.isEmpty()) {\n-      if (autoFinalize) {\n-        event.setAutoFinalize(true);\n-      }\n-      compsThatNeedUpgrade.forEach(component -\u003e {\n+    // remove all components from need upgrade list if there restart policy\n+    // doesn\u0027t all upgrade.\n+    if (compsNeedUpgradeList !\u003d null) {\n+      compsNeedUpgradeList.removeIf(component -\u003e {\n         org.apache.hadoop.yarn.service.api.records.Component.RestartPolicyEnum\n             restartPolicy \u003d component.getRestartPolicy();\n \n         final ComponentRestartPolicy restartPolicyHandler \u003d\n             Component.getRestartPolicyHandler(restartPolicy);\n         // Do not allow upgrades for components which have NEVER/ON_FAILURE\n         // restart policy\n-        if (restartPolicyHandler.allowUpgrades()) {\n+        if (!restartPolicyHandler.allowUpgrades()) {\n+          LOG.info(\"The component {} has a restart policy that doesnt \" +\n+                  \"allow upgrades {} \", component.getName(),\n+              component.getRestartPolicy().toString());\n+          return true;\n+        }\n+\n+        return false;\n+      });\n+    }\n+\n+    ServiceEvent event \u003d new ServiceEvent(ServiceEventType.UPGRADE)\n+        .setVersion(upgradeVersion)\n+        .setAutoFinalize(autoFinalize)\n+        .setExpressUpgrade(expressUpgrade);\n+\n+    if (expressUpgrade) {\n+      // In case of express upgrade  components need to be upgraded in order.\n+      // Once the service manager gets notified that a component finished\n+      // upgrading, it then issues event to upgrade the next component.\n+      Map\u003cString, org.apache.hadoop.yarn.service.api.records.Component\u003e\n+          compsNeedUpgradeByName \u003d new HashMap\u003c\u003e();\n+      if (compsNeedUpgradeList !\u003d null) {\n+        compsNeedUpgradeList.forEach(component -\u003e\n+            compsNeedUpgradeByName.put(component.getName(), component));\n+      }\n+      List\u003cString\u003e resolvedComps \u003d ServiceApiUtil\n+          .resolveCompsDependency(targetSpec);\n+\n+      Queue\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n+          orderedCompUpgrade \u003d new LinkedList\u003c\u003e();\n+      resolvedComps.forEach(compName -\u003e {\n+        org.apache.hadoop.yarn.service.api.records.Component component \u003d\n+            compsNeedUpgradeByName.get(compName);\n+        if (component !\u003d null ) {\n+          orderedCompUpgrade.add(component);\n+        }\n+      });\n+      event.setCompsToUpgradeInOrder(orderedCompUpgrade);\n+    }\n+\n+    context.scheduler.getDispatcher().getEventHandler().handle(event);\n+\n+    if (compsNeedUpgradeList !\u003d null \u0026\u0026 !compsNeedUpgradeList.isEmpty()) {\n+      if (!expressUpgrade) {\n+        compsNeedUpgradeList.forEach(component -\u003e {\n           ComponentEvent needUpgradeEvent \u003d new ComponentEvent(\n               component.getName(), ComponentEventType.UPGRADE).setTargetSpec(\n               component).setUpgradeVersion(event.getVersion());\n           context.scheduler.getDispatcher().getEventHandler().handle(\n               needUpgradeEvent);\n-        } else {\n-          LOG.info(\"The component {} has a restart \"\n-              + \"policy that doesnt allow upgrades {} \", component.getName(),\n-              component.getRestartPolicy().toString());\n-        }\n-      });\n-    } else {\n+\n+        });\n+      }\n+    }  else if (autoFinalize) {\n       // nothing to upgrade if upgrade auto finalize is requested, trigger a\n       // state check.\n-      if (autoFinalize) {\n-        context.scheduler.getDispatcher().getEventHandler().handle(\n-            new ServiceEvent(ServiceEventType.CHECK_STABLE));\n-      }\n+      context.scheduler.getDispatcher().getEventHandler().handle(\n+          new ServiceEvent(ServiceEventType.CHECK_STABLE));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void processUpgradeRequest(String upgradeVersion,\n      boolean autoFinalize, boolean expressUpgrade) throws IOException {\n    Service targetSpec \u003d ServiceApiUtil.loadServiceUpgrade(\n        context.fs, context.service.getName(), upgradeVersion);\n\n    List\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n        compsNeedUpgradeList \u003d componentsFinder.\n        findTargetComponentSpecs(context.service, targetSpec);\n\n    // remove all components from need upgrade list if there restart policy\n    // doesn\u0027t all upgrade.\n    if (compsNeedUpgradeList !\u003d null) {\n      compsNeedUpgradeList.removeIf(component -\u003e {\n        org.apache.hadoop.yarn.service.api.records.Component.RestartPolicyEnum\n            restartPolicy \u003d component.getRestartPolicy();\n\n        final ComponentRestartPolicy restartPolicyHandler \u003d\n            Component.getRestartPolicyHandler(restartPolicy);\n        // Do not allow upgrades for components which have NEVER/ON_FAILURE\n        // restart policy\n        if (!restartPolicyHandler.allowUpgrades()) {\n          LOG.info(\"The component {} has a restart policy that doesnt \" +\n                  \"allow upgrades {} \", component.getName(),\n              component.getRestartPolicy().toString());\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    ServiceEvent event \u003d new ServiceEvent(ServiceEventType.UPGRADE)\n        .setVersion(upgradeVersion)\n        .setAutoFinalize(autoFinalize)\n        .setExpressUpgrade(expressUpgrade);\n\n    if (expressUpgrade) {\n      // In case of express upgrade  components need to be upgraded in order.\n      // Once the service manager gets notified that a component finished\n      // upgrading, it then issues event to upgrade the next component.\n      Map\u003cString, org.apache.hadoop.yarn.service.api.records.Component\u003e\n          compsNeedUpgradeByName \u003d new HashMap\u003c\u003e();\n      if (compsNeedUpgradeList !\u003d null) {\n        compsNeedUpgradeList.forEach(component -\u003e\n            compsNeedUpgradeByName.put(component.getName(), component));\n      }\n      List\u003cString\u003e resolvedComps \u003d ServiceApiUtil\n          .resolveCompsDependency(targetSpec);\n\n      Queue\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n          orderedCompUpgrade \u003d new LinkedList\u003c\u003e();\n      resolvedComps.forEach(compName -\u003e {\n        org.apache.hadoop.yarn.service.api.records.Component component \u003d\n            compsNeedUpgradeByName.get(compName);\n        if (component !\u003d null ) {\n          orderedCompUpgrade.add(component);\n        }\n      });\n      event.setCompsToUpgradeInOrder(orderedCompUpgrade);\n    }\n\n    context.scheduler.getDispatcher().getEventHandler().handle(event);\n\n    if (compsNeedUpgradeList !\u003d null \u0026\u0026 !compsNeedUpgradeList.isEmpty()) {\n      if (!expressUpgrade) {\n        compsNeedUpgradeList.forEach(component -\u003e {\n          ComponentEvent needUpgradeEvent \u003d new ComponentEvent(\n              component.getName(), ComponentEventType.UPGRADE).setTargetSpec(\n              component).setUpgradeVersion(event.getVersion());\n          context.scheduler.getDispatcher().getEventHandler().handle(\n              needUpgradeEvent);\n\n        });\n      }\n    }  else if (autoFinalize) {\n      // nothing to upgrade if upgrade auto finalize is requested, trigger a\n      // state check.\n      context.scheduler.getDispatcher().getEventHandler().handle(\n          new ServiceEvent(ServiceEventType.CHECK_STABLE));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/ServiceManager.java",
          "extendedDetails": {
            "oldValue": "[upgradeVersion-String, autoFinalize-boolean]",
            "newValue": "[upgradeVersion-String, autoFinalize-boolean, expressUpgrade-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8298.  Added express upgrade for YARN service.\n            Contributed by Chandni Singh\n",
          "commitDate": "21/08/18 4:49 PM",
          "commitName": "e557c6bd8de2811a561210f672f47b4d07a9d5c6",
          "commitAuthor": "Eric Yang",
          "commitDateOld": "17/05/18 2:16 PM",
          "commitNameOld": "7f083ed8699a720d3fb82e4ec310356902a6ac30",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 96.11,
          "commitsBetweenForRepo": 715,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,81 @@\n   void processUpgradeRequest(String upgradeVersion,\n-      boolean autoFinalize) throws IOException {\n+      boolean autoFinalize, boolean expressUpgrade) throws IOException {\n     Service targetSpec \u003d ServiceApiUtil.loadServiceUpgrade(\n         context.fs, context.service.getName(), upgradeVersion);\n \n     List\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n-        compsThatNeedUpgrade \u003d componentsFinder.\n+        compsNeedUpgradeList \u003d componentsFinder.\n         findTargetComponentSpecs(context.service, targetSpec);\n-    ServiceEvent event \u003d new ServiceEvent(ServiceEventType.UPGRADE)\n-        .setVersion(upgradeVersion)\n-        .setAutoFinalize(autoFinalize);\n-    context.scheduler.getDispatcher().getEventHandler().handle(event);\n \n-    if (compsThatNeedUpgrade !\u003d null \u0026\u0026 !compsThatNeedUpgrade.isEmpty()) {\n-      if (autoFinalize) {\n-        event.setAutoFinalize(true);\n-      }\n-      compsThatNeedUpgrade.forEach(component -\u003e {\n+    // remove all components from need upgrade list if there restart policy\n+    // doesn\u0027t all upgrade.\n+    if (compsNeedUpgradeList !\u003d null) {\n+      compsNeedUpgradeList.removeIf(component -\u003e {\n         org.apache.hadoop.yarn.service.api.records.Component.RestartPolicyEnum\n             restartPolicy \u003d component.getRestartPolicy();\n \n         final ComponentRestartPolicy restartPolicyHandler \u003d\n             Component.getRestartPolicyHandler(restartPolicy);\n         // Do not allow upgrades for components which have NEVER/ON_FAILURE\n         // restart policy\n-        if (restartPolicyHandler.allowUpgrades()) {\n+        if (!restartPolicyHandler.allowUpgrades()) {\n+          LOG.info(\"The component {} has a restart policy that doesnt \" +\n+                  \"allow upgrades {} \", component.getName(),\n+              component.getRestartPolicy().toString());\n+          return true;\n+        }\n+\n+        return false;\n+      });\n+    }\n+\n+    ServiceEvent event \u003d new ServiceEvent(ServiceEventType.UPGRADE)\n+        .setVersion(upgradeVersion)\n+        .setAutoFinalize(autoFinalize)\n+        .setExpressUpgrade(expressUpgrade);\n+\n+    if (expressUpgrade) {\n+      // In case of express upgrade  components need to be upgraded in order.\n+      // Once the service manager gets notified that a component finished\n+      // upgrading, it then issues event to upgrade the next component.\n+      Map\u003cString, org.apache.hadoop.yarn.service.api.records.Component\u003e\n+          compsNeedUpgradeByName \u003d new HashMap\u003c\u003e();\n+      if (compsNeedUpgradeList !\u003d null) {\n+        compsNeedUpgradeList.forEach(component -\u003e\n+            compsNeedUpgradeByName.put(component.getName(), component));\n+      }\n+      List\u003cString\u003e resolvedComps \u003d ServiceApiUtil\n+          .resolveCompsDependency(targetSpec);\n+\n+      Queue\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n+          orderedCompUpgrade \u003d new LinkedList\u003c\u003e();\n+      resolvedComps.forEach(compName -\u003e {\n+        org.apache.hadoop.yarn.service.api.records.Component component \u003d\n+            compsNeedUpgradeByName.get(compName);\n+        if (component !\u003d null ) {\n+          orderedCompUpgrade.add(component);\n+        }\n+      });\n+      event.setCompsToUpgradeInOrder(orderedCompUpgrade);\n+    }\n+\n+    context.scheduler.getDispatcher().getEventHandler().handle(event);\n+\n+    if (compsNeedUpgradeList !\u003d null \u0026\u0026 !compsNeedUpgradeList.isEmpty()) {\n+      if (!expressUpgrade) {\n+        compsNeedUpgradeList.forEach(component -\u003e {\n           ComponentEvent needUpgradeEvent \u003d new ComponentEvent(\n               component.getName(), ComponentEventType.UPGRADE).setTargetSpec(\n               component).setUpgradeVersion(event.getVersion());\n           context.scheduler.getDispatcher().getEventHandler().handle(\n               needUpgradeEvent);\n-        } else {\n-          LOG.info(\"The component {} has a restart \"\n-              + \"policy that doesnt allow upgrades {} \", component.getName(),\n-              component.getRestartPolicy().toString());\n-        }\n-      });\n-    } else {\n+\n+        });\n+      }\n+    }  else if (autoFinalize) {\n       // nothing to upgrade if upgrade auto finalize is requested, trigger a\n       // state check.\n-      if (autoFinalize) {\n-        context.scheduler.getDispatcher().getEventHandler().handle(\n-            new ServiceEvent(ServiceEventType.CHECK_STABLE));\n-      }\n+      context.scheduler.getDispatcher().getEventHandler().handle(\n+          new ServiceEvent(ServiceEventType.CHECK_STABLE));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void processUpgradeRequest(String upgradeVersion,\n      boolean autoFinalize, boolean expressUpgrade) throws IOException {\n    Service targetSpec \u003d ServiceApiUtil.loadServiceUpgrade(\n        context.fs, context.service.getName(), upgradeVersion);\n\n    List\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n        compsNeedUpgradeList \u003d componentsFinder.\n        findTargetComponentSpecs(context.service, targetSpec);\n\n    // remove all components from need upgrade list if there restart policy\n    // doesn\u0027t all upgrade.\n    if (compsNeedUpgradeList !\u003d null) {\n      compsNeedUpgradeList.removeIf(component -\u003e {\n        org.apache.hadoop.yarn.service.api.records.Component.RestartPolicyEnum\n            restartPolicy \u003d component.getRestartPolicy();\n\n        final ComponentRestartPolicy restartPolicyHandler \u003d\n            Component.getRestartPolicyHandler(restartPolicy);\n        // Do not allow upgrades for components which have NEVER/ON_FAILURE\n        // restart policy\n        if (!restartPolicyHandler.allowUpgrades()) {\n          LOG.info(\"The component {} has a restart policy that doesnt \" +\n                  \"allow upgrades {} \", component.getName(),\n              component.getRestartPolicy().toString());\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    ServiceEvent event \u003d new ServiceEvent(ServiceEventType.UPGRADE)\n        .setVersion(upgradeVersion)\n        .setAutoFinalize(autoFinalize)\n        .setExpressUpgrade(expressUpgrade);\n\n    if (expressUpgrade) {\n      // In case of express upgrade  components need to be upgraded in order.\n      // Once the service manager gets notified that a component finished\n      // upgrading, it then issues event to upgrade the next component.\n      Map\u003cString, org.apache.hadoop.yarn.service.api.records.Component\u003e\n          compsNeedUpgradeByName \u003d new HashMap\u003c\u003e();\n      if (compsNeedUpgradeList !\u003d null) {\n        compsNeedUpgradeList.forEach(component -\u003e\n            compsNeedUpgradeByName.put(component.getName(), component));\n      }\n      List\u003cString\u003e resolvedComps \u003d ServiceApiUtil\n          .resolveCompsDependency(targetSpec);\n\n      Queue\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n          orderedCompUpgrade \u003d new LinkedList\u003c\u003e();\n      resolvedComps.forEach(compName -\u003e {\n        org.apache.hadoop.yarn.service.api.records.Component component \u003d\n            compsNeedUpgradeByName.get(compName);\n        if (component !\u003d null ) {\n          orderedCompUpgrade.add(component);\n        }\n      });\n      event.setCompsToUpgradeInOrder(orderedCompUpgrade);\n    }\n\n    context.scheduler.getDispatcher().getEventHandler().handle(event);\n\n    if (compsNeedUpgradeList !\u003d null \u0026\u0026 !compsNeedUpgradeList.isEmpty()) {\n      if (!expressUpgrade) {\n        compsNeedUpgradeList.forEach(component -\u003e {\n          ComponentEvent needUpgradeEvent \u003d new ComponentEvent(\n              component.getName(), ComponentEventType.UPGRADE).setTargetSpec(\n              component).setUpgradeVersion(event.getVersion());\n          context.scheduler.getDispatcher().getEventHandler().handle(\n              needUpgradeEvent);\n\n        });\n      }\n    }  else if (autoFinalize) {\n      // nothing to upgrade if upgrade auto finalize is requested, trigger a\n      // state check.\n      context.scheduler.getDispatcher().getEventHandler().handle(\n          new ServiceEvent(ServiceEventType.CHECK_STABLE));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/ServiceManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "7f083ed8699a720d3fb82e4ec310356902a6ac30": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8080.  Add restart policy for YARN services.\n            Contributed by Suma Shivaprasad\n",
      "commitDate": "17/05/18 2:16 PM",
      "commitName": "7f083ed8699a720d3fb82e4ec310356902a6ac30",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "11/05/18 12:49 PM",
      "commitNameOld": "ca612e353fc3e3766868ec0816de035e48b1f5b4",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 6.06,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,46 @@\n   void processUpgradeRequest(String upgradeVersion,\n       boolean autoFinalize) throws IOException {\n     Service targetSpec \u003d ServiceApiUtil.loadServiceUpgrade(\n         context.fs, context.service.getName(), upgradeVersion);\n \n     List\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n         compsThatNeedUpgrade \u003d componentsFinder.\n         findTargetComponentSpecs(context.service, targetSpec);\n     ServiceEvent event \u003d new ServiceEvent(ServiceEventType.UPGRADE)\n         .setVersion(upgradeVersion)\n         .setAutoFinalize(autoFinalize);\n     context.scheduler.getDispatcher().getEventHandler().handle(event);\n \n     if (compsThatNeedUpgrade !\u003d null \u0026\u0026 !compsThatNeedUpgrade.isEmpty()) {\n       if (autoFinalize) {\n         event.setAutoFinalize(true);\n       }\n       compsThatNeedUpgrade.forEach(component -\u003e {\n-        ComponentEvent needUpgradeEvent \u003d new ComponentEvent(\n-            component.getName(), ComponentEventType.UPGRADE)\n-            .setTargetSpec(component)\n-            .setUpgradeVersion(event.getVersion());\n-        context.scheduler.getDispatcher().getEventHandler().handle(\n-            needUpgradeEvent);\n+        org.apache.hadoop.yarn.service.api.records.Component.RestartPolicyEnum\n+            restartPolicy \u003d component.getRestartPolicy();\n+\n+        final ComponentRestartPolicy restartPolicyHandler \u003d\n+            Component.getRestartPolicyHandler(restartPolicy);\n+        // Do not allow upgrades for components which have NEVER/ON_FAILURE\n+        // restart policy\n+        if (restartPolicyHandler.allowUpgrades()) {\n+          ComponentEvent needUpgradeEvent \u003d new ComponentEvent(\n+              component.getName(), ComponentEventType.UPGRADE).setTargetSpec(\n+              component).setUpgradeVersion(event.getVersion());\n+          context.scheduler.getDispatcher().getEventHandler().handle(\n+              needUpgradeEvent);\n+        } else {\n+          LOG.info(\"The component {} has a restart \"\n+              + \"policy that doesnt allow upgrades {} \", component.getName(),\n+              component.getRestartPolicy().toString());\n+        }\n       });\n     } else {\n       // nothing to upgrade if upgrade auto finalize is requested, trigger a\n       // state check.\n       if (autoFinalize) {\n         context.scheduler.getDispatcher().getEventHandler().handle(\n             new ServiceEvent(ServiceEventType.CHECK_STABLE));\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void processUpgradeRequest(String upgradeVersion,\n      boolean autoFinalize) throws IOException {\n    Service targetSpec \u003d ServiceApiUtil.loadServiceUpgrade(\n        context.fs, context.service.getName(), upgradeVersion);\n\n    List\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n        compsThatNeedUpgrade \u003d componentsFinder.\n        findTargetComponentSpecs(context.service, targetSpec);\n    ServiceEvent event \u003d new ServiceEvent(ServiceEventType.UPGRADE)\n        .setVersion(upgradeVersion)\n        .setAutoFinalize(autoFinalize);\n    context.scheduler.getDispatcher().getEventHandler().handle(event);\n\n    if (compsThatNeedUpgrade !\u003d null \u0026\u0026 !compsThatNeedUpgrade.isEmpty()) {\n      if (autoFinalize) {\n        event.setAutoFinalize(true);\n      }\n      compsThatNeedUpgrade.forEach(component -\u003e {\n        org.apache.hadoop.yarn.service.api.records.Component.RestartPolicyEnum\n            restartPolicy \u003d component.getRestartPolicy();\n\n        final ComponentRestartPolicy restartPolicyHandler \u003d\n            Component.getRestartPolicyHandler(restartPolicy);\n        // Do not allow upgrades for components which have NEVER/ON_FAILURE\n        // restart policy\n        if (restartPolicyHandler.allowUpgrades()) {\n          ComponentEvent needUpgradeEvent \u003d new ComponentEvent(\n              component.getName(), ComponentEventType.UPGRADE).setTargetSpec(\n              component).setUpgradeVersion(event.getVersion());\n          context.scheduler.getDispatcher().getEventHandler().handle(\n              needUpgradeEvent);\n        } else {\n          LOG.info(\"The component {} has a restart \"\n              + \"policy that doesnt allow upgrades {} \", component.getName(),\n              component.getRestartPolicy().toString());\n        }\n      });\n    } else {\n      // nothing to upgrade if upgrade auto finalize is requested, trigger a\n      // state check.\n      if (autoFinalize) {\n        context.scheduler.getDispatcher().getEventHandler().handle(\n            new ServiceEvent(ServiceEventType.CHECK_STABLE));\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/ServiceManager.java",
      "extendedDetails": {}
    },
    "4a7369b09547a78f532af66c763c6994a38b5d68": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7939.  Added support to upgrade a component instance.\n            Contributed by Chandni Singh\n",
      "commitDate": "26/04/18 1:54 PM",
      "commitName": "4a7369b09547a78f532af66c763c6994a38b5d68",
      "commitAuthor": "Eric Yang",
      "diff": "@@ -0,0 +1,34 @@\n+  void processUpgradeRequest(String upgradeVersion,\n+      boolean autoFinalize) throws IOException {\n+    Service targetSpec \u003d ServiceApiUtil.loadServiceUpgrade(\n+        context.fs, context.service.getName(), upgradeVersion);\n+\n+    List\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n+        compsThatNeedUpgrade \u003d componentsFinder.\n+        findTargetComponentSpecs(context.service, targetSpec);\n+    ServiceEvent event \u003d new ServiceEvent(ServiceEventType.UPGRADE)\n+        .setVersion(upgradeVersion)\n+        .setAutoFinalize(autoFinalize);\n+    context.scheduler.getDispatcher().getEventHandler().handle(event);\n+\n+    if (compsThatNeedUpgrade !\u003d null \u0026\u0026 !compsThatNeedUpgrade.isEmpty()) {\n+      if (autoFinalize) {\n+        event.setAutoFinalize(true);\n+      }\n+      compsThatNeedUpgrade.forEach(component -\u003e {\n+        ComponentEvent needUpgradeEvent \u003d new ComponentEvent(\n+            component.getName(), ComponentEventType.UPGRADE)\n+            .setTargetSpec(component)\n+            .setUpgradeVersion(event.getVersion());\n+        context.scheduler.getDispatcher().getEventHandler().handle(\n+            needUpgradeEvent);\n+      });\n+    } else {\n+      // nothing to upgrade if upgrade auto finalize is requested, trigger a\n+      // state check.\n+      if (autoFinalize) {\n+        context.scheduler.getDispatcher().getEventHandler().handle(\n+            new ServiceEvent(ServiceEventType.CHECK_STABLE));\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void processUpgradeRequest(String upgradeVersion,\n      boolean autoFinalize) throws IOException {\n    Service targetSpec \u003d ServiceApiUtil.loadServiceUpgrade(\n        context.fs, context.service.getName(), upgradeVersion);\n\n    List\u003corg.apache.hadoop.yarn.service.api.records.Component\u003e\n        compsThatNeedUpgrade \u003d componentsFinder.\n        findTargetComponentSpecs(context.service, targetSpec);\n    ServiceEvent event \u003d new ServiceEvent(ServiceEventType.UPGRADE)\n        .setVersion(upgradeVersion)\n        .setAutoFinalize(autoFinalize);\n    context.scheduler.getDispatcher().getEventHandler().handle(event);\n\n    if (compsThatNeedUpgrade !\u003d null \u0026\u0026 !compsThatNeedUpgrade.isEmpty()) {\n      if (autoFinalize) {\n        event.setAutoFinalize(true);\n      }\n      compsThatNeedUpgrade.forEach(component -\u003e {\n        ComponentEvent needUpgradeEvent \u003d new ComponentEvent(\n            component.getName(), ComponentEventType.UPGRADE)\n            .setTargetSpec(component)\n            .setUpgradeVersion(event.getVersion());\n        context.scheduler.getDispatcher().getEventHandler().handle(\n            needUpgradeEvent);\n      });\n    } else {\n      // nothing to upgrade if upgrade auto finalize is requested, trigger a\n      // state check.\n      if (autoFinalize) {\n        context.scheduler.getDispatcher().getEventHandler().handle(\n            new ServiceEvent(ServiceEventType.CHECK_STABLE));\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-core/src/main/java/org/apache/hadoop/yarn/service/ServiceManager.java"
    }
  }
}