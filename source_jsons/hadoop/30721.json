{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RollingLevelDBTimelineStore.java",
  "functionName": "evictOldStartTimes",
  "functionId": "evictOldStartTimes___minStartTime-long",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
  "functionStartLine": 1489,
  "functionEndLine": 1542,
  "numCommitsSeen": 12,
  "timeTaken": 2923,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "839e077faf4019d6efdcd89d95930023cd0b0a08",
    "a4aa1cb40504299d3401008fdabc795eafb28713",
    "1a78c0ff016097930edf68e8278f826b637e918c",
    "01aca54a22c8586d232a8f79fe9977aeb8d09b83",
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "839e077faf4019d6efdcd89d95930023cd0b0a08": "Ybodychange",
    "a4aa1cb40504299d3401008fdabc795eafb28713": "Ybodychange",
    "1a78c0ff016097930edf68e8278f826b637e918c": "Ybodychange",
    "01aca54a22c8586d232a8f79fe9977aeb8d09b83": "Ybodychange",
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "02/07/18 3:34 PM",
      "commitNameOld": "fa9ef15ecd6dc30fb260e1c342a2b51505d39b6b",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 256.03,
      "commitsBetweenForRepo": 2038,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,54 @@\n   long evictOldStartTimes(long minStartTime) throws IOException {\n     LOG.info(\"Searching for start times to evict earlier than \" + minStartTime);\n \n     long batchSize \u003d 0;\n     long totalCount \u003d 0;\n     long startTimesCount \u003d 0;\n \n     WriteBatch writeBatch \u003d null;\n \n     ReadOptions readOptions \u003d new ReadOptions();\n     readOptions.fillCache(false);\n     try (DBIterator iterator \u003d starttimedb.iterator(readOptions)) {\n \n       // seek to the first start time entry\n       iterator.seekToFirst();\n       writeBatch \u003d starttimedb.createWriteBatch();\n \n       // evaluate each start time entry to see if it needs to be evicted or not\n       while (iterator.hasNext()) {\n         Map.Entry\u003cbyte[], byte[]\u003e current \u003d iterator.next();\n         byte[] entityKey \u003d current.getKey();\n         byte[] entityValue \u003d current.getValue();\n         long startTime \u003d readReverseOrderedLong(entityValue, 0);\n         if (startTime \u003c minStartTime) {\n           ++batchSize;\n           ++startTimesCount;\n           writeBatch.delete(entityKey);\n \n           // a large delete will hold the lock for too long\n           if (batchSize \u003e\u003d writeBatchSize) {\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Preparing to delete a batch of \" + batchSize\n-                  + \" old start times\");\n-            }\n+            LOG.debug(\"Preparing to delete a batch of {} old start times\",\n+                batchSize);\n             starttimedb.write(writeBatch);\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Deleted batch of \" + batchSize\n-                  + \". Total start times deleted so far this cycle: \"\n-                  + startTimesCount);\n-            }\n+            LOG.debug(\"Deleted batch of {}. Total start times deleted\"\n+                + \" so far this cycle: {}\", batchSize, startTimesCount);\n             IOUtils.cleanupWithLogger(LOG, writeBatch);\n             writeBatch \u003d starttimedb.createWriteBatch();\n             batchSize \u003d 0;\n           }\n         }\n         ++totalCount;\n       }\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Preparing to delete a batch of \" + batchSize\n-            + \" old start times\");\n-      }\n+      LOG.debug(\"Preparing to delete a batch of {} old start times\",\n+          batchSize);\n       starttimedb.write(writeBatch);\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Deleted batch of \" + batchSize\n-            + \". Total start times deleted so far this cycle: \"\n-            + startTimesCount);\n-      }\n+      LOG.debug(\"Deleted batch of {}. Total start times deleted so far\"\n+          + \" this cycle: {}\", batchSize, startTimesCount);\n       LOG.info(\"Deleted \" + startTimesCount + \"/\" + totalCount\n           + \" start time entities earlier than \" + minStartTime);\n     } finally {\n       IOUtils.cleanupWithLogger(LOG, writeBatch);\n     }\n     return startTimesCount;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long evictOldStartTimes(long minStartTime) throws IOException {\n    LOG.info(\"Searching for start times to evict earlier than \" + minStartTime);\n\n    long batchSize \u003d 0;\n    long totalCount \u003d 0;\n    long startTimesCount \u003d 0;\n\n    WriteBatch writeBatch \u003d null;\n\n    ReadOptions readOptions \u003d new ReadOptions();\n    readOptions.fillCache(false);\n    try (DBIterator iterator \u003d starttimedb.iterator(readOptions)) {\n\n      // seek to the first start time entry\n      iterator.seekToFirst();\n      writeBatch \u003d starttimedb.createWriteBatch();\n\n      // evaluate each start time entry to see if it needs to be evicted or not\n      while (iterator.hasNext()) {\n        Map.Entry\u003cbyte[], byte[]\u003e current \u003d iterator.next();\n        byte[] entityKey \u003d current.getKey();\n        byte[] entityValue \u003d current.getValue();\n        long startTime \u003d readReverseOrderedLong(entityValue, 0);\n        if (startTime \u003c minStartTime) {\n          ++batchSize;\n          ++startTimesCount;\n          writeBatch.delete(entityKey);\n\n          // a large delete will hold the lock for too long\n          if (batchSize \u003e\u003d writeBatchSize) {\n            LOG.debug(\"Preparing to delete a batch of {} old start times\",\n                batchSize);\n            starttimedb.write(writeBatch);\n            LOG.debug(\"Deleted batch of {}. Total start times deleted\"\n                + \" so far this cycle: {}\", batchSize, startTimesCount);\n            IOUtils.cleanupWithLogger(LOG, writeBatch);\n            writeBatch \u003d starttimedb.createWriteBatch();\n            batchSize \u003d 0;\n          }\n        }\n        ++totalCount;\n      }\n      LOG.debug(\"Preparing to delete a batch of {} old start times\",\n          batchSize);\n      starttimedb.write(writeBatch);\n      LOG.debug(\"Deleted batch of {}. Total start times deleted so far\"\n          + \" this cycle: {}\", batchSize, startTimesCount);\n      LOG.info(\"Deleted \" + startTimesCount + \"/\" + totalCount\n          + \" start time entities earlier than \" + minStartTime);\n    } finally {\n      IOUtils.cleanupWithLogger(LOG, writeBatch);\n    }\n    return startTimesCount;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
      "extendedDetails": {}
    },
    "839e077faf4019d6efdcd89d95930023cd0b0a08": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6873. Moving logging APIs over to slf4j in hadoop-yarn-server-applicationhistoryservice. Contributed by Yeliang Cang.\n",
      "commitDate": "07/08/17 2:56 AM",
      "commitName": "839e077faf4019d6efdcd89d95930023cd0b0a08",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "31/07/17 8:15 PM",
      "commitNameOld": "a4aa1cb40504299d3401008fdabc795eafb28713",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 6.28,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   long evictOldStartTimes(long minStartTime) throws IOException {\n     LOG.info(\"Searching for start times to evict earlier than \" + minStartTime);\n \n     long batchSize \u003d 0;\n     long totalCount \u003d 0;\n     long startTimesCount \u003d 0;\n \n     WriteBatch writeBatch \u003d null;\n \n     ReadOptions readOptions \u003d new ReadOptions();\n     readOptions.fillCache(false);\n     try (DBIterator iterator \u003d starttimedb.iterator(readOptions)) {\n \n       // seek to the first start time entry\n       iterator.seekToFirst();\n       writeBatch \u003d starttimedb.createWriteBatch();\n \n       // evaluate each start time entry to see if it needs to be evicted or not\n       while (iterator.hasNext()) {\n         Map.Entry\u003cbyte[], byte[]\u003e current \u003d iterator.next();\n         byte[] entityKey \u003d current.getKey();\n         byte[] entityValue \u003d current.getValue();\n         long startTime \u003d readReverseOrderedLong(entityValue, 0);\n         if (startTime \u003c minStartTime) {\n           ++batchSize;\n           ++startTimesCount;\n           writeBatch.delete(entityKey);\n \n           // a large delete will hold the lock for too long\n           if (batchSize \u003e\u003d writeBatchSize) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Preparing to delete a batch of \" + batchSize\n                   + \" old start times\");\n             }\n             starttimedb.write(writeBatch);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Deleted batch of \" + batchSize\n                   + \". Total start times deleted so far this cycle: \"\n                   + startTimesCount);\n             }\n-            IOUtils.cleanup(LOG, writeBatch);\n+            IOUtils.cleanupWithLogger(LOG, writeBatch);\n             writeBatch \u003d starttimedb.createWriteBatch();\n             batchSize \u003d 0;\n           }\n         }\n         ++totalCount;\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Preparing to delete a batch of \" + batchSize\n             + \" old start times\");\n       }\n       starttimedb.write(writeBatch);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Deleted batch of \" + batchSize\n             + \". Total start times deleted so far this cycle: \"\n             + startTimesCount);\n       }\n       LOG.info(\"Deleted \" + startTimesCount + \"/\" + totalCount\n           + \" start time entities earlier than \" + minStartTime);\n     } finally {\n-      IOUtils.cleanup(LOG, writeBatch);\n+      IOUtils.cleanupWithLogger(LOG, writeBatch);\n     }\n     return startTimesCount;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long evictOldStartTimes(long minStartTime) throws IOException {\n    LOG.info(\"Searching for start times to evict earlier than \" + minStartTime);\n\n    long batchSize \u003d 0;\n    long totalCount \u003d 0;\n    long startTimesCount \u003d 0;\n\n    WriteBatch writeBatch \u003d null;\n\n    ReadOptions readOptions \u003d new ReadOptions();\n    readOptions.fillCache(false);\n    try (DBIterator iterator \u003d starttimedb.iterator(readOptions)) {\n\n      // seek to the first start time entry\n      iterator.seekToFirst();\n      writeBatch \u003d starttimedb.createWriteBatch();\n\n      // evaluate each start time entry to see if it needs to be evicted or not\n      while (iterator.hasNext()) {\n        Map.Entry\u003cbyte[], byte[]\u003e current \u003d iterator.next();\n        byte[] entityKey \u003d current.getKey();\n        byte[] entityValue \u003d current.getValue();\n        long startTime \u003d readReverseOrderedLong(entityValue, 0);\n        if (startTime \u003c minStartTime) {\n          ++batchSize;\n          ++startTimesCount;\n          writeBatch.delete(entityKey);\n\n          // a large delete will hold the lock for too long\n          if (batchSize \u003e\u003d writeBatchSize) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Preparing to delete a batch of \" + batchSize\n                  + \" old start times\");\n            }\n            starttimedb.write(writeBatch);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Deleted batch of \" + batchSize\n                  + \". Total start times deleted so far this cycle: \"\n                  + startTimesCount);\n            }\n            IOUtils.cleanupWithLogger(LOG, writeBatch);\n            writeBatch \u003d starttimedb.createWriteBatch();\n            batchSize \u003d 0;\n          }\n        }\n        ++totalCount;\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Preparing to delete a batch of \" + batchSize\n            + \" old start times\");\n      }\n      starttimedb.write(writeBatch);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Deleted batch of \" + batchSize\n            + \". Total start times deleted so far this cycle: \"\n            + startTimesCount);\n      }\n      LOG.info(\"Deleted \" + startTimesCount + \"/\" + totalCount\n          + \" start time entities earlier than \" + minStartTime);\n    } finally {\n      IOUtils.cleanupWithLogger(LOG, writeBatch);\n    }\n    return startTimesCount;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
      "extendedDetails": {}
    },
    "a4aa1cb40504299d3401008fdabc795eafb28713": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-6873. Moving logging APIs over to slf4j in hadoop-yarn-server-applicationhistoryservice. Contributed by Yeliang Cang.\"\n\nThis reverts commit 1a78c0ff016097930edf68e8278f826b637e918c.\n",
      "commitDate": "31/07/17 8:15 PM",
      "commitName": "a4aa1cb40504299d3401008fdabc795eafb28713",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "31/07/17 6:53 PM",
      "commitNameOld": "1a78c0ff016097930edf68e8278f826b637e918c",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   long evictOldStartTimes(long minStartTime) throws IOException {\n     LOG.info(\"Searching for start times to evict earlier than \" + minStartTime);\n \n     long batchSize \u003d 0;\n     long totalCount \u003d 0;\n     long startTimesCount \u003d 0;\n \n     WriteBatch writeBatch \u003d null;\n \n     ReadOptions readOptions \u003d new ReadOptions();\n     readOptions.fillCache(false);\n     try (DBIterator iterator \u003d starttimedb.iterator(readOptions)) {\n \n       // seek to the first start time entry\n       iterator.seekToFirst();\n       writeBatch \u003d starttimedb.createWriteBatch();\n \n       // evaluate each start time entry to see if it needs to be evicted or not\n       while (iterator.hasNext()) {\n         Map.Entry\u003cbyte[], byte[]\u003e current \u003d iterator.next();\n         byte[] entityKey \u003d current.getKey();\n         byte[] entityValue \u003d current.getValue();\n         long startTime \u003d readReverseOrderedLong(entityValue, 0);\n         if (startTime \u003c minStartTime) {\n           ++batchSize;\n           ++startTimesCount;\n           writeBatch.delete(entityKey);\n \n           // a large delete will hold the lock for too long\n           if (batchSize \u003e\u003d writeBatchSize) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Preparing to delete a batch of \" + batchSize\n                   + \" old start times\");\n             }\n             starttimedb.write(writeBatch);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Deleted batch of \" + batchSize\n                   + \". Total start times deleted so far this cycle: \"\n                   + startTimesCount);\n             }\n-            IOUtils.cleanupWithLogger(LOG, writeBatch);\n+            IOUtils.cleanup(LOG, writeBatch);\n             writeBatch \u003d starttimedb.createWriteBatch();\n             batchSize \u003d 0;\n           }\n         }\n         ++totalCount;\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Preparing to delete a batch of \" + batchSize\n             + \" old start times\");\n       }\n       starttimedb.write(writeBatch);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Deleted batch of \" + batchSize\n             + \". Total start times deleted so far this cycle: \"\n             + startTimesCount);\n       }\n       LOG.info(\"Deleted \" + startTimesCount + \"/\" + totalCount\n           + \" start time entities earlier than \" + minStartTime);\n     } finally {\n-      IOUtils.cleanupWithLogger(LOG, writeBatch);\n+      IOUtils.cleanup(LOG, writeBatch);\n     }\n     return startTimesCount;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long evictOldStartTimes(long minStartTime) throws IOException {\n    LOG.info(\"Searching for start times to evict earlier than \" + minStartTime);\n\n    long batchSize \u003d 0;\n    long totalCount \u003d 0;\n    long startTimesCount \u003d 0;\n\n    WriteBatch writeBatch \u003d null;\n\n    ReadOptions readOptions \u003d new ReadOptions();\n    readOptions.fillCache(false);\n    try (DBIterator iterator \u003d starttimedb.iterator(readOptions)) {\n\n      // seek to the first start time entry\n      iterator.seekToFirst();\n      writeBatch \u003d starttimedb.createWriteBatch();\n\n      // evaluate each start time entry to see if it needs to be evicted or not\n      while (iterator.hasNext()) {\n        Map.Entry\u003cbyte[], byte[]\u003e current \u003d iterator.next();\n        byte[] entityKey \u003d current.getKey();\n        byte[] entityValue \u003d current.getValue();\n        long startTime \u003d readReverseOrderedLong(entityValue, 0);\n        if (startTime \u003c minStartTime) {\n          ++batchSize;\n          ++startTimesCount;\n          writeBatch.delete(entityKey);\n\n          // a large delete will hold the lock for too long\n          if (batchSize \u003e\u003d writeBatchSize) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Preparing to delete a batch of \" + batchSize\n                  + \" old start times\");\n            }\n            starttimedb.write(writeBatch);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Deleted batch of \" + batchSize\n                  + \". Total start times deleted so far this cycle: \"\n                  + startTimesCount);\n            }\n            IOUtils.cleanup(LOG, writeBatch);\n            writeBatch \u003d starttimedb.createWriteBatch();\n            batchSize \u003d 0;\n          }\n        }\n        ++totalCount;\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Preparing to delete a batch of \" + batchSize\n            + \" old start times\");\n      }\n      starttimedb.write(writeBatch);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Deleted batch of \" + batchSize\n            + \". Total start times deleted so far this cycle: \"\n            + startTimesCount);\n      }\n      LOG.info(\"Deleted \" + startTimesCount + \"/\" + totalCount\n          + \" start time entities earlier than \" + minStartTime);\n    } finally {\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n    return startTimesCount;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
      "extendedDetails": {}
    },
    "1a78c0ff016097930edf68e8278f826b637e918c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6873. Moving logging APIs over to slf4j in hadoop-yarn-server-applicationhistoryservice. Contributed by Yeliang Cang.\n",
      "commitDate": "31/07/17 6:53 PM",
      "commitName": "1a78c0ff016097930edf68e8278f826b637e918c",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "13/07/17 3:27 PM",
      "commitNameOld": "5f1ee72b0ebf0330417b7c0115083bc851923be4",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 18.14,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   long evictOldStartTimes(long minStartTime) throws IOException {\n     LOG.info(\"Searching for start times to evict earlier than \" + minStartTime);\n \n     long batchSize \u003d 0;\n     long totalCount \u003d 0;\n     long startTimesCount \u003d 0;\n \n     WriteBatch writeBatch \u003d null;\n \n     ReadOptions readOptions \u003d new ReadOptions();\n     readOptions.fillCache(false);\n     try (DBIterator iterator \u003d starttimedb.iterator(readOptions)) {\n \n       // seek to the first start time entry\n       iterator.seekToFirst();\n       writeBatch \u003d starttimedb.createWriteBatch();\n \n       // evaluate each start time entry to see if it needs to be evicted or not\n       while (iterator.hasNext()) {\n         Map.Entry\u003cbyte[], byte[]\u003e current \u003d iterator.next();\n         byte[] entityKey \u003d current.getKey();\n         byte[] entityValue \u003d current.getValue();\n         long startTime \u003d readReverseOrderedLong(entityValue, 0);\n         if (startTime \u003c minStartTime) {\n           ++batchSize;\n           ++startTimesCount;\n           writeBatch.delete(entityKey);\n \n           // a large delete will hold the lock for too long\n           if (batchSize \u003e\u003d writeBatchSize) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Preparing to delete a batch of \" + batchSize\n                   + \" old start times\");\n             }\n             starttimedb.write(writeBatch);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Deleted batch of \" + batchSize\n                   + \". Total start times deleted so far this cycle: \"\n                   + startTimesCount);\n             }\n-            IOUtils.cleanup(LOG, writeBatch);\n+            IOUtils.cleanupWithLogger(LOG, writeBatch);\n             writeBatch \u003d starttimedb.createWriteBatch();\n             batchSize \u003d 0;\n           }\n         }\n         ++totalCount;\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Preparing to delete a batch of \" + batchSize\n             + \" old start times\");\n       }\n       starttimedb.write(writeBatch);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Deleted batch of \" + batchSize\n             + \". Total start times deleted so far this cycle: \"\n             + startTimesCount);\n       }\n       LOG.info(\"Deleted \" + startTimesCount + \"/\" + totalCount\n           + \" start time entities earlier than \" + minStartTime);\n     } finally {\n-      IOUtils.cleanup(LOG, writeBatch);\n+      IOUtils.cleanupWithLogger(LOG, writeBatch);\n     }\n     return startTimesCount;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long evictOldStartTimes(long minStartTime) throws IOException {\n    LOG.info(\"Searching for start times to evict earlier than \" + minStartTime);\n\n    long batchSize \u003d 0;\n    long totalCount \u003d 0;\n    long startTimesCount \u003d 0;\n\n    WriteBatch writeBatch \u003d null;\n\n    ReadOptions readOptions \u003d new ReadOptions();\n    readOptions.fillCache(false);\n    try (DBIterator iterator \u003d starttimedb.iterator(readOptions)) {\n\n      // seek to the first start time entry\n      iterator.seekToFirst();\n      writeBatch \u003d starttimedb.createWriteBatch();\n\n      // evaluate each start time entry to see if it needs to be evicted or not\n      while (iterator.hasNext()) {\n        Map.Entry\u003cbyte[], byte[]\u003e current \u003d iterator.next();\n        byte[] entityKey \u003d current.getKey();\n        byte[] entityValue \u003d current.getValue();\n        long startTime \u003d readReverseOrderedLong(entityValue, 0);\n        if (startTime \u003c minStartTime) {\n          ++batchSize;\n          ++startTimesCount;\n          writeBatch.delete(entityKey);\n\n          // a large delete will hold the lock for too long\n          if (batchSize \u003e\u003d writeBatchSize) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Preparing to delete a batch of \" + batchSize\n                  + \" old start times\");\n            }\n            starttimedb.write(writeBatch);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Deleted batch of \" + batchSize\n                  + \". Total start times deleted so far this cycle: \"\n                  + startTimesCount);\n            }\n            IOUtils.cleanupWithLogger(LOG, writeBatch);\n            writeBatch \u003d starttimedb.createWriteBatch();\n            batchSize \u003d 0;\n          }\n        }\n        ++totalCount;\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Preparing to delete a batch of \" + batchSize\n            + \" old start times\");\n      }\n      starttimedb.write(writeBatch);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Deleted batch of \" + batchSize\n            + \". Total start times deleted so far this cycle: \"\n            + startTimesCount);\n      }\n      LOG.info(\"Deleted \" + startTimesCount + \"/\" + totalCount\n          + \" start time entities earlier than \" + minStartTime);\n    } finally {\n      IOUtils.cleanupWithLogger(LOG, writeBatch);\n    }\n    return startTimesCount;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
      "extendedDetails": {}
    },
    "01aca54a22c8586d232a8f79fe9977aeb8d09b83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5368. Memory leak in timeline server (Jonathan Eagles via Varun Saxena)\n",
      "commitDate": "28/03/17 1:23 PM",
      "commitName": "01aca54a22c8586d232a8f79fe9977aeb8d09b83",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "20/07/16 8:36 AM",
      "commitNameOld": "1c9d2ab503ea5a3f16757351af9603041059b390",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 251.2,
      "commitsBetweenForRepo": 1583,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,64 @@\n   long evictOldStartTimes(long minStartTime) throws IOException {\n     LOG.info(\"Searching for start times to evict earlier than \" + minStartTime);\n \n     long batchSize \u003d 0;\n     long totalCount \u003d 0;\n     long startTimesCount \u003d 0;\n \n     WriteBatch writeBatch \u003d null;\n-    DBIterator iterator \u003d null;\n \n-    try {\n-      writeBatch \u003d starttimedb.createWriteBatch();\n-      ReadOptions readOptions \u003d new ReadOptions();\n-      readOptions.fillCache(false);\n-      iterator \u003d starttimedb.iterator(readOptions);\n+    ReadOptions readOptions \u003d new ReadOptions();\n+    readOptions.fillCache(false);\n+    try (DBIterator iterator \u003d starttimedb.iterator(readOptions)) {\n+\n       // seek to the first start time entry\n       iterator.seekToFirst();\n+      writeBatch \u003d starttimedb.createWriteBatch();\n \n       // evaluate each start time entry to see if it needs to be evicted or not\n       while (iterator.hasNext()) {\n         Map.Entry\u003cbyte[], byte[]\u003e current \u003d iterator.next();\n         byte[] entityKey \u003d current.getKey();\n         byte[] entityValue \u003d current.getValue();\n         long startTime \u003d readReverseOrderedLong(entityValue, 0);\n         if (startTime \u003c minStartTime) {\n           ++batchSize;\n           ++startTimesCount;\n           writeBatch.delete(entityKey);\n \n           // a large delete will hold the lock for too long\n           if (batchSize \u003e\u003d writeBatchSize) {\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Preparing to delete a batch of \" + batchSize\n                   + \" old start times\");\n             }\n             starttimedb.write(writeBatch);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Deleted batch of \" + batchSize\n                   + \". Total start times deleted so far this cycle: \"\n                   + startTimesCount);\n             }\n             IOUtils.cleanup(LOG, writeBatch);\n             writeBatch \u003d starttimedb.createWriteBatch();\n             batchSize \u003d 0;\n           }\n         }\n         ++totalCount;\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Preparing to delete a batch of \" + batchSize\n             + \" old start times\");\n       }\n       starttimedb.write(writeBatch);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Deleted batch of \" + batchSize\n             + \". Total start times deleted so far this cycle: \"\n             + startTimesCount);\n       }\n       LOG.info(\"Deleted \" + startTimesCount + \"/\" + totalCount\n           + \" start time entities earlier than \" + minStartTime);\n     } finally {\n       IOUtils.cleanup(LOG, writeBatch);\n-      IOUtils.cleanup(LOG, iterator);\n     }\n     return startTimesCount;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long evictOldStartTimes(long minStartTime) throws IOException {\n    LOG.info(\"Searching for start times to evict earlier than \" + minStartTime);\n\n    long batchSize \u003d 0;\n    long totalCount \u003d 0;\n    long startTimesCount \u003d 0;\n\n    WriteBatch writeBatch \u003d null;\n\n    ReadOptions readOptions \u003d new ReadOptions();\n    readOptions.fillCache(false);\n    try (DBIterator iterator \u003d starttimedb.iterator(readOptions)) {\n\n      // seek to the first start time entry\n      iterator.seekToFirst();\n      writeBatch \u003d starttimedb.createWriteBatch();\n\n      // evaluate each start time entry to see if it needs to be evicted or not\n      while (iterator.hasNext()) {\n        Map.Entry\u003cbyte[], byte[]\u003e current \u003d iterator.next();\n        byte[] entityKey \u003d current.getKey();\n        byte[] entityValue \u003d current.getValue();\n        long startTime \u003d readReverseOrderedLong(entityValue, 0);\n        if (startTime \u003c minStartTime) {\n          ++batchSize;\n          ++startTimesCount;\n          writeBatch.delete(entityKey);\n\n          // a large delete will hold the lock for too long\n          if (batchSize \u003e\u003d writeBatchSize) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Preparing to delete a batch of \" + batchSize\n                  + \" old start times\");\n            }\n            starttimedb.write(writeBatch);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Deleted batch of \" + batchSize\n                  + \". Total start times deleted so far this cycle: \"\n                  + startTimesCount);\n            }\n            IOUtils.cleanup(LOG, writeBatch);\n            writeBatch \u003d starttimedb.createWriteBatch();\n            batchSize \u003d 0;\n          }\n        }\n        ++totalCount;\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Preparing to delete a batch of \" + batchSize\n            + \" old start times\");\n      }\n      starttimedb.write(writeBatch);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Deleted batch of \" + batchSize\n            + \". Total start times deleted so far this cycle: \"\n            + startTimesCount);\n      }\n      LOG.info(\"Deleted \" + startTimesCount + \"/\" + totalCount\n          + \" start time entities earlier than \" + minStartTime);\n    } finally {\n      IOUtils.cleanup(LOG, writeBatch);\n    }\n    return startTimesCount;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
      "extendedDetails": {}
    },
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3448. Added a rolling time-to-live LevelDB timeline store implementation. Contributed by Jonathan Eagles.\n",
      "commitDate": "07/05/15 10:01 AM",
      "commitName": "daf3e4ef8bf73cbe4a799d51b4765809cd81089f",
      "commitAuthor": "Zhijie Shen",
      "diff": "@@ -0,0 +1,66 @@\n+  long evictOldStartTimes(long minStartTime) throws IOException {\n+    LOG.info(\"Searching for start times to evict earlier than \" + minStartTime);\n+\n+    long batchSize \u003d 0;\n+    long totalCount \u003d 0;\n+    long startTimesCount \u003d 0;\n+\n+    WriteBatch writeBatch \u003d null;\n+    DBIterator iterator \u003d null;\n+\n+    try {\n+      writeBatch \u003d starttimedb.createWriteBatch();\n+      ReadOptions readOptions \u003d new ReadOptions();\n+      readOptions.fillCache(false);\n+      iterator \u003d starttimedb.iterator(readOptions);\n+      // seek to the first start time entry\n+      iterator.seekToFirst();\n+\n+      // evaluate each start time entry to see if it needs to be evicted or not\n+      while (iterator.hasNext()) {\n+        Map.Entry\u003cbyte[], byte[]\u003e current \u003d iterator.next();\n+        byte[] entityKey \u003d current.getKey();\n+        byte[] entityValue \u003d current.getValue();\n+        long startTime \u003d readReverseOrderedLong(entityValue, 0);\n+        if (startTime \u003c minStartTime) {\n+          ++batchSize;\n+          ++startTimesCount;\n+          writeBatch.delete(entityKey);\n+\n+          // a large delete will hold the lock for too long\n+          if (batchSize \u003e\u003d writeBatchSize) {\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Preparing to delete a batch of \" + batchSize\n+                  + \" old start times\");\n+            }\n+            starttimedb.write(writeBatch);\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Deleted batch of \" + batchSize\n+                  + \". Total start times deleted so far this cycle: \"\n+                  + startTimesCount);\n+            }\n+            IOUtils.cleanup(LOG, writeBatch);\n+            writeBatch \u003d starttimedb.createWriteBatch();\n+            batchSize \u003d 0;\n+          }\n+        }\n+        ++totalCount;\n+      }\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Preparing to delete a batch of \" + batchSize\n+            + \" old start times\");\n+      }\n+      starttimedb.write(writeBatch);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Deleted batch of \" + batchSize\n+            + \". Total start times deleted so far this cycle: \"\n+            + startTimesCount);\n+      }\n+      LOG.info(\"Deleted \" + startTimesCount + \"/\" + totalCount\n+          + \" start time entities earlier than \" + minStartTime);\n+    } finally {\n+      IOUtils.cleanup(LOG, writeBatch);\n+      IOUtils.cleanup(LOG, iterator);\n+    }\n+    return startTimesCount;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  long evictOldStartTimes(long minStartTime) throws IOException {\n    LOG.info(\"Searching for start times to evict earlier than \" + minStartTime);\n\n    long batchSize \u003d 0;\n    long totalCount \u003d 0;\n    long startTimesCount \u003d 0;\n\n    WriteBatch writeBatch \u003d null;\n    DBIterator iterator \u003d null;\n\n    try {\n      writeBatch \u003d starttimedb.createWriteBatch();\n      ReadOptions readOptions \u003d new ReadOptions();\n      readOptions.fillCache(false);\n      iterator \u003d starttimedb.iterator(readOptions);\n      // seek to the first start time entry\n      iterator.seekToFirst();\n\n      // evaluate each start time entry to see if it needs to be evicted or not\n      while (iterator.hasNext()) {\n        Map.Entry\u003cbyte[], byte[]\u003e current \u003d iterator.next();\n        byte[] entityKey \u003d current.getKey();\n        byte[] entityValue \u003d current.getValue();\n        long startTime \u003d readReverseOrderedLong(entityValue, 0);\n        if (startTime \u003c minStartTime) {\n          ++batchSize;\n          ++startTimesCount;\n          writeBatch.delete(entityKey);\n\n          // a large delete will hold the lock for too long\n          if (batchSize \u003e\u003d writeBatchSize) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Preparing to delete a batch of \" + batchSize\n                  + \" old start times\");\n            }\n            starttimedb.write(writeBatch);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Deleted batch of \" + batchSize\n                  + \". Total start times deleted so far this cycle: \"\n                  + startTimesCount);\n            }\n            IOUtils.cleanup(LOG, writeBatch);\n            writeBatch \u003d starttimedb.createWriteBatch();\n            batchSize \u003d 0;\n          }\n        }\n        ++totalCount;\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Preparing to delete a batch of \" + batchSize\n            + \" old start times\");\n      }\n      starttimedb.write(writeBatch);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Deleted batch of \" + batchSize\n            + \". Total start times deleted so far this cycle: \"\n            + startTimesCount);\n      }\n      LOG.info(\"Deleted \" + startTimesCount + \"/\" + totalCount\n          + \" start time entities earlier than \" + minStartTime);\n    } finally {\n      IOUtils.cleanup(LOG, writeBatch);\n      IOUtils.cleanup(LOG, iterator);\n    }\n    return startTimesCount;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java"
    }
  }
}