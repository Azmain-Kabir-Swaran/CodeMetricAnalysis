{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSEditLogLoader.java",
  "functionName": "loadEditRecords",
  "functionId": "loadEditRecords___in-EditLogInputStream__closeOnExit-boolean__expectedStartingTxId-long__startOpt-StartupOption__recovery-MetaRecoveryContext",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogLoader.java",
  "functionStartLine": 203,
  "functionEndLine": 208,
  "numCommitsSeen": 198,
  "timeTaken": 4511,
  "changeHistory": [
    "ebe5853a458150b7e42fe7434851bfcbe25e354d",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498",
    "185e0c7b4c056b88f606362c71e4a22aae7076e0",
    "9dab514b22f49322738935cfd915c2b4eba50b88",
    "4f9bbaa301194e3d20972a10f51638c7f4d121f0"
  ],
  "changeHistoryShort": {
    "ebe5853a458150b7e42fe7434851bfcbe25e354d": "Ybodychange",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": "Ybodychange",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": "Ybodychange",
    "185e0c7b4c056b88f606362c71e4a22aae7076e0": "Ybodychange",
    "9dab514b22f49322738935cfd915c2b4eba50b88": "Ybodychange",
    "4f9bbaa301194e3d20972a10f51638c7f4d121f0": "Ybodychange"
  },
  "changeHistoryDetails": {
    "ebe5853a458150b7e42fe7434851bfcbe25e354d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12978. Fine-grained locking while consuming journal stream. Contributed by Konstantin Shvachko.",
      "commitDate": "31/05/18 2:56 PM",
      "commitName": "ebe5853a458150b7e42fe7434851bfcbe25e354d",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "07/12/17 11:15 AM",
      "commitNameOld": "67662e2ac9e68f32b725c8118cf2be79a662fca5",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 175.11,
      "commitsBetweenForRepo": 1795,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,6 @@\n   long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n       long expectedStartingTxId, StartupOption startOpt,\n       MetaRecoveryContext recovery) throws IOException {\n-    FSDirectory fsDir \u003d fsNamesys.dir;\n-\n-    EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n-      new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n-\n-    if (LOG.isTraceEnabled()) {\n-      LOG.trace(\"Acquiring write lock to replay edit log\");\n-    }\n-\n-    fsNamesys.writeLock();\n-    fsDir.writeLock();\n-\n-    long recentOpcodeOffsets[] \u003d new long[4];\n-    Arrays.fill(recentOpcodeOffsets, -1);\n-    \n-    long expectedTxId \u003d expectedStartingTxId;\n-    long numEdits \u003d 0;\n-    long lastTxId \u003d in.getLastTxId();\n-    long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n-    StartupProgress prog \u003d NameNode.getStartupProgress();\n-    Step step \u003d createStartupProgressStep(in);\n-    prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n-    Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n-    long lastLogTime \u003d monotonicNow();\n-    long lastInodeId \u003d fsNamesys.dir.getLastInodeId();\n-    \n-    try {\n-      while (true) {\n-        try {\n-          FSEditLogOp op;\n-          try {\n-            op \u003d in.readOp();\n-            if (op \u003d\u003d null) {\n-              break;\n-            }\n-          } catch (Throwable e) {\n-            // Handle a problem with our input\n-            check203UpgradeFailure(in.getVersion(true), e);\n-            String errorMessage \u003d\n-              formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n-            FSImage.LOG.error(errorMessage, e);\n-            if (recovery \u003d\u003d null) {\n-               // We will only try to skip over problematic opcodes when in\n-               // recovery mode.\n-              throw new EditLogInputException(errorMessage, e, numEdits);\n-            }\n-            MetaRecoveryContext.editLogLoaderPrompt(\n-                \"We failed to read txId \" + expectedTxId,\n-                recovery, \"skipping the bad section in the log\");\n-            in.resync();\n-            continue;\n-          }\n-          recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n-            in.getPosition();\n-          if (op.hasTransactionId()) {\n-            if (op.getTransactionId() \u003e expectedTxId) { \n-              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n-                  \"to be a gap in the edit log.  We expected txid \" +\n-                  expectedTxId + \", but got txid \" +\n-                  op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n-                  \" transaction IDs\");\n-            } else if (op.getTransactionId() \u003c expectedTxId) { \n-              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n-                  \"to be an out-of-order edit in the edit log.  We \" +\n-                  \"expected txid \" + expectedTxId + \", but got txid \" +\n-                  op.getTransactionId() + \".\", recovery,\n-                  \"skipping the out-of-order edit\");\n-              continue;\n-            }\n-          }\n-          try {\n-            if (LOG.isTraceEnabled()) {\n-              LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n-                  + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n-            }\n-            long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n-                in.getVersion(true), lastInodeId);\n-            if (lastInodeId \u003c inodeId) {\n-              lastInodeId \u003d inodeId;\n-            }\n-          } catch (RollingUpgradeOp.RollbackException e) {\n-            throw e;\n-          } catch (Throwable e) {\n-            LOG.error(\"Encountered exception on operation \" + op, e);\n-            if (recovery \u003d\u003d null) {\n-              throw e instanceof IOException? (IOException)e: new IOException(e);\n-            }\n-\n-            MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n-             \"apply edit log operation \" + op + \": error \" +\n-             e.getMessage(), recovery, \"applying edits\");\n-          }\n-          // Now that the operation has been successfully decoded and\n-          // applied, update our bookkeeping.\n-          incrOpCount(op.opCode, opCounts, step, counter);\n-          if (op.hasTransactionId()) {\n-            lastAppliedTxId \u003d op.getTransactionId();\n-            expectedTxId \u003d lastAppliedTxId + 1;\n-          } else {\n-            expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n-          }\n-          // log progress\n-          if (op.hasTransactionId()) {\n-            long now \u003d monotonicNow();\n-            if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n-              long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n-              int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n-              LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n-                  + \" transactions completed. (\" + percent + \"%)\");\n-              lastLogTime \u003d now;\n-            }\n-          }\n-          numEdits++;\n-          totalEdits++;\n-        } catch (RollingUpgradeOp.RollbackException e) {\n-          LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n-          break;\n-        } catch (MetaRecoveryContext.RequestStopException e) {\n-          MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n-              in.getPosition() + \"/\"  + in.length());\n-          break;\n-        }\n-      }\n-    } finally {\n-      fsNamesys.dir.resetLastInodeId(lastInodeId);\n-      if(closeOnExit) {\n-        in.close();\n-      }\n-      fsDir.writeUnlock();\n-      fsNamesys.writeUnlock(\"loadEditRecords\");\n-\n-      if (LOG.isTraceEnabled()) {\n-        LOG.trace(\"replaying edit log finished\");\n-      }\n-\n-      if (FSImage.LOG.isDebugEnabled()) {\n-        dumpOpCounts(opCounts);\n-      }\n-    }\n-    return numEdits;\n+    return loadEditRecords(in, closeOnExit, expectedStartingTxId,\n+        Long.MAX_VALUE, startOpt, recovery);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n      long expectedStartingTxId, StartupOption startOpt,\n      MetaRecoveryContext recovery) throws IOException {\n    return loadEditRecords(in, closeOnExit, expectedStartingTxId,\n        Long.MAX_VALUE, startOpt, recovery);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogLoader.java",
      "extendedDetails": {}
    },
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10872. Add MutableRate metrics for FSNamesystemLock operations. Contributed by Erik Krogen.\n",
      "commitDate": "14/11/16 11:05 AM",
      "commitName": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "24/10/16 3:14 PM",
      "commitNameOld": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 20.87,
      "commitsBetweenForRepo": 229,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n       long expectedStartingTxId, StartupOption startOpt,\n       MetaRecoveryContext recovery) throws IOException {\n     FSDirectory fsDir \u003d fsNamesys.dir;\n \n     EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n       new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Acquiring write lock to replay edit log\");\n     }\n \n     fsNamesys.writeLock();\n     fsDir.writeLock();\n \n     long recentOpcodeOffsets[] \u003d new long[4];\n     Arrays.fill(recentOpcodeOffsets, -1);\n     \n     long expectedTxId \u003d expectedStartingTxId;\n     long numEdits \u003d 0;\n     long lastTxId \u003d in.getLastTxId();\n     long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     Step step \u003d createStartupProgressStep(in);\n     prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n     Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n     long lastLogTime \u003d monotonicNow();\n     long lastInodeId \u003d fsNamesys.dir.getLastInodeId();\n     \n     try {\n       while (true) {\n         try {\n           FSEditLogOp op;\n           try {\n             op \u003d in.readOp();\n             if (op \u003d\u003d null) {\n               break;\n             }\n           } catch (Throwable e) {\n             // Handle a problem with our input\n             check203UpgradeFailure(in.getVersion(true), e);\n             String errorMessage \u003d\n               formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n             FSImage.LOG.error(errorMessage, e);\n             if (recovery \u003d\u003d null) {\n                // We will only try to skip over problematic opcodes when in\n                // recovery mode.\n               throw new EditLogInputException(errorMessage, e, numEdits);\n             }\n             MetaRecoveryContext.editLogLoaderPrompt(\n                 \"We failed to read txId \" + expectedTxId,\n                 recovery, \"skipping the bad section in the log\");\n             in.resync();\n             continue;\n           }\n           recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n             in.getPosition();\n           if (op.hasTransactionId()) {\n             if (op.getTransactionId() \u003e expectedTxId) { \n               MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                   \"to be a gap in the edit log.  We expected txid \" +\n                   expectedTxId + \", but got txid \" +\n                   op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                   \" transaction IDs\");\n             } else if (op.getTransactionId() \u003c expectedTxId) { \n               MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                   \"to be an out-of-order edit in the edit log.  We \" +\n                   \"expected txid \" + expectedTxId + \", but got txid \" +\n                   op.getTransactionId() + \".\", recovery,\n                   \"skipping the out-of-order edit\");\n               continue;\n             }\n           }\n           try {\n             if (LOG.isTraceEnabled()) {\n               LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                   + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n             }\n             long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n                 in.getVersion(true), lastInodeId);\n             if (lastInodeId \u003c inodeId) {\n               lastInodeId \u003d inodeId;\n             }\n           } catch (RollingUpgradeOp.RollbackException e) {\n             throw e;\n           } catch (Throwable e) {\n             LOG.error(\"Encountered exception on operation \" + op, e);\n             if (recovery \u003d\u003d null) {\n               throw e instanceof IOException? (IOException)e: new IOException(e);\n             }\n \n             MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n              \"apply edit log operation \" + op + \": error \" +\n              e.getMessage(), recovery, \"applying edits\");\n           }\n           // Now that the operation has been successfully decoded and\n           // applied, update our bookkeeping.\n           incrOpCount(op.opCode, opCounts, step, counter);\n           if (op.hasTransactionId()) {\n             lastAppliedTxId \u003d op.getTransactionId();\n             expectedTxId \u003d lastAppliedTxId + 1;\n           } else {\n             expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n           }\n           // log progress\n           if (op.hasTransactionId()) {\n             long now \u003d monotonicNow();\n             if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n               long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n               int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n               LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                   + \" transactions completed. (\" + percent + \"%)\");\n               lastLogTime \u003d now;\n             }\n           }\n           numEdits++;\n           totalEdits++;\n         } catch (RollingUpgradeOp.RollbackException e) {\n           LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n           break;\n         } catch (MetaRecoveryContext.RequestStopException e) {\n           MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n               in.getPosition() + \"/\"  + in.length());\n           break;\n         }\n       }\n     } finally {\n       fsNamesys.dir.resetLastInodeId(lastInodeId);\n       if(closeOnExit) {\n         in.close();\n       }\n       fsDir.writeUnlock();\n-      fsNamesys.writeUnlock();\n+      fsNamesys.writeUnlock(\"loadEditRecords\");\n \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(\"replaying edit log finished\");\n       }\n \n       if (FSImage.LOG.isDebugEnabled()) {\n         dumpOpCounts(opCounts);\n       }\n     }\n     return numEdits;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n      long expectedStartingTxId, StartupOption startOpt,\n      MetaRecoveryContext recovery) throws IOException {\n    FSDirectory fsDir \u003d fsNamesys.dir;\n\n    EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n      new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Acquiring write lock to replay edit log\");\n    }\n\n    fsNamesys.writeLock();\n    fsDir.writeLock();\n\n    long recentOpcodeOffsets[] \u003d new long[4];\n    Arrays.fill(recentOpcodeOffsets, -1);\n    \n    long expectedTxId \u003d expectedStartingTxId;\n    long numEdits \u003d 0;\n    long lastTxId \u003d in.getLastTxId();\n    long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    Step step \u003d createStartupProgressStep(in);\n    prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n    Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n    long lastLogTime \u003d monotonicNow();\n    long lastInodeId \u003d fsNamesys.dir.getLastInodeId();\n    \n    try {\n      while (true) {\n        try {\n          FSEditLogOp op;\n          try {\n            op \u003d in.readOp();\n            if (op \u003d\u003d null) {\n              break;\n            }\n          } catch (Throwable e) {\n            // Handle a problem with our input\n            check203UpgradeFailure(in.getVersion(true), e);\n            String errorMessage \u003d\n              formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n            FSImage.LOG.error(errorMessage, e);\n            if (recovery \u003d\u003d null) {\n               // We will only try to skip over problematic opcodes when in\n               // recovery mode.\n              throw new EditLogInputException(errorMessage, e, numEdits);\n            }\n            MetaRecoveryContext.editLogLoaderPrompt(\n                \"We failed to read txId \" + expectedTxId,\n                recovery, \"skipping the bad section in the log\");\n            in.resync();\n            continue;\n          }\n          recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n            in.getPosition();\n          if (op.hasTransactionId()) {\n            if (op.getTransactionId() \u003e expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be a gap in the edit log.  We expected txid \" +\n                  expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                  \" transaction IDs\");\n            } else if (op.getTransactionId() \u003c expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be an out-of-order edit in the edit log.  We \" +\n                  \"expected txid \" + expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery,\n                  \"skipping the out-of-order edit\");\n              continue;\n            }\n          }\n          try {\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                  + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n            }\n            long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n                in.getVersion(true), lastInodeId);\n            if (lastInodeId \u003c inodeId) {\n              lastInodeId \u003d inodeId;\n            }\n          } catch (RollingUpgradeOp.RollbackException e) {\n            throw e;\n          } catch (Throwable e) {\n            LOG.error(\"Encountered exception on operation \" + op, e);\n            if (recovery \u003d\u003d null) {\n              throw e instanceof IOException? (IOException)e: new IOException(e);\n            }\n\n            MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n             \"apply edit log operation \" + op + \": error \" +\n             e.getMessage(), recovery, \"applying edits\");\n          }\n          // Now that the operation has been successfully decoded and\n          // applied, update our bookkeeping.\n          incrOpCount(op.opCode, opCounts, step, counter);\n          if (op.hasTransactionId()) {\n            lastAppliedTxId \u003d op.getTransactionId();\n            expectedTxId \u003d lastAppliedTxId + 1;\n          } else {\n            expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n          }\n          // log progress\n          if (op.hasTransactionId()) {\n            long now \u003d monotonicNow();\n            if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n              long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n              int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n              LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                  + \" transactions completed. (\" + percent + \"%)\");\n              lastLogTime \u003d now;\n            }\n          }\n          numEdits++;\n          totalEdits++;\n        } catch (RollingUpgradeOp.RollbackException e) {\n          LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n          break;\n        } catch (MetaRecoveryContext.RequestStopException e) {\n          MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n              in.getPosition() + \"/\"  + in.length());\n          break;\n        }\n      }\n    } finally {\n      fsNamesys.dir.resetLastInodeId(lastInodeId);\n      if(closeOnExit) {\n        in.close();\n      }\n      fsDir.writeUnlock();\n      fsNamesys.writeUnlock(\"loadEditRecords\");\n\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"replaying edit log finished\");\n      }\n\n      if (FSImage.LOG.isDebugEnabled()) {\n        dumpOpCounts(opCounts);\n      }\n    }\n    return numEdits;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogLoader.java",
      "extendedDetails": {}
    },
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6841. Use Time.monotonicNow() wherever applicable instead of Time.now(). Contributed by Vinayakumar B\n",
      "commitDate": "20/03/15 12:02 PM",
      "commitName": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "02/03/15 6:04 PM",
      "commitNameOld": "431e7d84c7b68b34ff18de19afe8e46637047fa6",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 17.71,
      "commitsBetweenForRepo": 162,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n       long expectedStartingTxId, StartupOption startOpt,\n       MetaRecoveryContext recovery) throws IOException {\n     FSDirectory fsDir \u003d fsNamesys.dir;\n \n     EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n       new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Acquiring write lock to replay edit log\");\n     }\n \n     fsNamesys.writeLock();\n     fsDir.writeLock();\n \n     long recentOpcodeOffsets[] \u003d new long[4];\n     Arrays.fill(recentOpcodeOffsets, -1);\n     \n     long expectedTxId \u003d expectedStartingTxId;\n     long numEdits \u003d 0;\n     long lastTxId \u003d in.getLastTxId();\n     long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     Step step \u003d createStartupProgressStep(in);\n     prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n     Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n-    long lastLogTime \u003d now();\n+    long lastLogTime \u003d monotonicNow();\n     long lastInodeId \u003d fsNamesys.dir.getLastInodeId();\n     \n     try {\n       while (true) {\n         try {\n           FSEditLogOp op;\n           try {\n             op \u003d in.readOp();\n             if (op \u003d\u003d null) {\n               break;\n             }\n           } catch (Throwable e) {\n             // Handle a problem with our input\n             check203UpgradeFailure(in.getVersion(true), e);\n             String errorMessage \u003d\n               formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n             FSImage.LOG.error(errorMessage, e);\n             if (recovery \u003d\u003d null) {\n                // We will only try to skip over problematic opcodes when in\n                // recovery mode.\n               throw new EditLogInputException(errorMessage, e, numEdits);\n             }\n             MetaRecoveryContext.editLogLoaderPrompt(\n                 \"We failed to read txId \" + expectedTxId,\n                 recovery, \"skipping the bad section in the log\");\n             in.resync();\n             continue;\n           }\n           recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n             in.getPosition();\n           if (op.hasTransactionId()) {\n             if (op.getTransactionId() \u003e expectedTxId) { \n               MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                   \"to be a gap in the edit log.  We expected txid \" +\n                   expectedTxId + \", but got txid \" +\n                   op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                   \" transaction IDs\");\n             } else if (op.getTransactionId() \u003c expectedTxId) { \n               MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                   \"to be an out-of-order edit in the edit log.  We \" +\n                   \"expected txid \" + expectedTxId + \", but got txid \" +\n                   op.getTransactionId() + \".\", recovery,\n                   \"skipping the out-of-order edit\");\n               continue;\n             }\n           }\n           try {\n             if (LOG.isTraceEnabled()) {\n               LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                   + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n             }\n             long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n                 in.getVersion(true), lastInodeId);\n             if (lastInodeId \u003c inodeId) {\n               lastInodeId \u003d inodeId;\n             }\n           } catch (RollingUpgradeOp.RollbackException e) {\n             throw e;\n           } catch (Throwable e) {\n             LOG.error(\"Encountered exception on operation \" + op, e);\n             if (recovery \u003d\u003d null) {\n               throw e instanceof IOException? (IOException)e: new IOException(e);\n             }\n \n             MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n              \"apply edit log operation \" + op + \": error \" +\n              e.getMessage(), recovery, \"applying edits\");\n           }\n           // Now that the operation has been successfully decoded and\n           // applied, update our bookkeeping.\n           incrOpCount(op.opCode, opCounts, step, counter);\n           if (op.hasTransactionId()) {\n             lastAppliedTxId \u003d op.getTransactionId();\n             expectedTxId \u003d lastAppliedTxId + 1;\n           } else {\n             expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n           }\n           // log progress\n           if (op.hasTransactionId()) {\n-            long now \u003d now();\n+            long now \u003d monotonicNow();\n             if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n               long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n               int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n               LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                   + \" transactions completed. (\" + percent + \"%)\");\n               lastLogTime \u003d now;\n             }\n           }\n           numEdits++;\n           totalEdits++;\n         } catch (RollingUpgradeOp.RollbackException e) {\n           LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n           break;\n         } catch (MetaRecoveryContext.RequestStopException e) {\n           MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n               in.getPosition() + \"/\"  + in.length());\n           break;\n         }\n       }\n     } finally {\n       fsNamesys.dir.resetLastInodeId(lastInodeId);\n       if(closeOnExit) {\n         in.close();\n       }\n       fsDir.writeUnlock();\n       fsNamesys.writeUnlock();\n \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(\"replaying edit log finished\");\n       }\n \n       if (FSImage.LOG.isDebugEnabled()) {\n         dumpOpCounts(opCounts);\n       }\n     }\n     return numEdits;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n      long expectedStartingTxId, StartupOption startOpt,\n      MetaRecoveryContext recovery) throws IOException {\n    FSDirectory fsDir \u003d fsNamesys.dir;\n\n    EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n      new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Acquiring write lock to replay edit log\");\n    }\n\n    fsNamesys.writeLock();\n    fsDir.writeLock();\n\n    long recentOpcodeOffsets[] \u003d new long[4];\n    Arrays.fill(recentOpcodeOffsets, -1);\n    \n    long expectedTxId \u003d expectedStartingTxId;\n    long numEdits \u003d 0;\n    long lastTxId \u003d in.getLastTxId();\n    long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    Step step \u003d createStartupProgressStep(in);\n    prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n    Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n    long lastLogTime \u003d monotonicNow();\n    long lastInodeId \u003d fsNamesys.dir.getLastInodeId();\n    \n    try {\n      while (true) {\n        try {\n          FSEditLogOp op;\n          try {\n            op \u003d in.readOp();\n            if (op \u003d\u003d null) {\n              break;\n            }\n          } catch (Throwable e) {\n            // Handle a problem with our input\n            check203UpgradeFailure(in.getVersion(true), e);\n            String errorMessage \u003d\n              formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n            FSImage.LOG.error(errorMessage, e);\n            if (recovery \u003d\u003d null) {\n               // We will only try to skip over problematic opcodes when in\n               // recovery mode.\n              throw new EditLogInputException(errorMessage, e, numEdits);\n            }\n            MetaRecoveryContext.editLogLoaderPrompt(\n                \"We failed to read txId \" + expectedTxId,\n                recovery, \"skipping the bad section in the log\");\n            in.resync();\n            continue;\n          }\n          recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n            in.getPosition();\n          if (op.hasTransactionId()) {\n            if (op.getTransactionId() \u003e expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be a gap in the edit log.  We expected txid \" +\n                  expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                  \" transaction IDs\");\n            } else if (op.getTransactionId() \u003c expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be an out-of-order edit in the edit log.  We \" +\n                  \"expected txid \" + expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery,\n                  \"skipping the out-of-order edit\");\n              continue;\n            }\n          }\n          try {\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                  + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n            }\n            long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n                in.getVersion(true), lastInodeId);\n            if (lastInodeId \u003c inodeId) {\n              lastInodeId \u003d inodeId;\n            }\n          } catch (RollingUpgradeOp.RollbackException e) {\n            throw e;\n          } catch (Throwable e) {\n            LOG.error(\"Encountered exception on operation \" + op, e);\n            if (recovery \u003d\u003d null) {\n              throw e instanceof IOException? (IOException)e: new IOException(e);\n            }\n\n            MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n             \"apply edit log operation \" + op + \": error \" +\n             e.getMessage(), recovery, \"applying edits\");\n          }\n          // Now that the operation has been successfully decoded and\n          // applied, update our bookkeeping.\n          incrOpCount(op.opCode, opCounts, step, counter);\n          if (op.hasTransactionId()) {\n            lastAppliedTxId \u003d op.getTransactionId();\n            expectedTxId \u003d lastAppliedTxId + 1;\n          } else {\n            expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n          }\n          // log progress\n          if (op.hasTransactionId()) {\n            long now \u003d monotonicNow();\n            if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n              long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n              int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n              LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                  + \" transactions completed. (\" + percent + \"%)\");\n              lastLogTime \u003d now;\n            }\n          }\n          numEdits++;\n          totalEdits++;\n        } catch (RollingUpgradeOp.RollbackException e) {\n          LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n          break;\n        } catch (MetaRecoveryContext.RequestStopException e) {\n          MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n              in.getPosition() + \"/\"  + in.length());\n          break;\n        }\n      }\n    } finally {\n      fsNamesys.dir.resetLastInodeId(lastInodeId);\n      if(closeOnExit) {\n        in.close();\n      }\n      fsDir.writeUnlock();\n      fsNamesys.writeUnlock();\n\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"replaying edit log finished\");\n      }\n\n      if (FSImage.LOG.isDebugEnabled()) {\n        dumpOpCounts(opCounts);\n      }\n    }\n    return numEdits;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogLoader.java",
      "extendedDetails": {}
    },
    "185e0c7b4c056b88f606362c71e4a22aae7076e0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7462. Consolidate implementation of mkdirs() into a single class. Contributed by Haohui Mai.\n",
      "commitDate": "02/12/14 2:53 PM",
      "commitName": "185e0c7b4c056b88f606362c71e4a22aae7076e0",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "01/12/14 9:48 PM",
      "commitNameOld": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n       long expectedStartingTxId, StartupOption startOpt,\n       MetaRecoveryContext recovery) throws IOException {\n     FSDirectory fsDir \u003d fsNamesys.dir;\n \n     EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n       new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Acquiring write lock to replay edit log\");\n     }\n \n     fsNamesys.writeLock();\n     fsDir.writeLock();\n \n     long recentOpcodeOffsets[] \u003d new long[4];\n     Arrays.fill(recentOpcodeOffsets, -1);\n     \n     long expectedTxId \u003d expectedStartingTxId;\n     long numEdits \u003d 0;\n     long lastTxId \u003d in.getLastTxId();\n     long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     Step step \u003d createStartupProgressStep(in);\n     prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n     Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n     long lastLogTime \u003d now();\n-    long lastInodeId \u003d fsNamesys.getLastInodeId();\n+    long lastInodeId \u003d fsNamesys.dir.getLastInodeId();\n     \n     try {\n       while (true) {\n         try {\n           FSEditLogOp op;\n           try {\n             op \u003d in.readOp();\n             if (op \u003d\u003d null) {\n               break;\n             }\n           } catch (Throwable e) {\n             // Handle a problem with our input\n             check203UpgradeFailure(in.getVersion(true), e);\n             String errorMessage \u003d\n               formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n             FSImage.LOG.error(errorMessage, e);\n             if (recovery \u003d\u003d null) {\n                // We will only try to skip over problematic opcodes when in\n                // recovery mode.\n               throw new EditLogInputException(errorMessage, e, numEdits);\n             }\n             MetaRecoveryContext.editLogLoaderPrompt(\n                 \"We failed to read txId \" + expectedTxId,\n                 recovery, \"skipping the bad section in the log\");\n             in.resync();\n             continue;\n           }\n           recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n             in.getPosition();\n           if (op.hasTransactionId()) {\n             if (op.getTransactionId() \u003e expectedTxId) { \n               MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                   \"to be a gap in the edit log.  We expected txid \" +\n                   expectedTxId + \", but got txid \" +\n                   op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                   \" transaction IDs\");\n             } else if (op.getTransactionId() \u003c expectedTxId) { \n               MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                   \"to be an out-of-order edit in the edit log.  We \" +\n                   \"expected txid \" + expectedTxId + \", but got txid \" +\n                   op.getTransactionId() + \".\", recovery,\n                   \"skipping the out-of-order edit\");\n               continue;\n             }\n           }\n           try {\n             if (LOG.isTraceEnabled()) {\n               LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                   + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n             }\n             long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n                 in.getVersion(true), lastInodeId);\n             if (lastInodeId \u003c inodeId) {\n               lastInodeId \u003d inodeId;\n             }\n           } catch (RollingUpgradeOp.RollbackException e) {\n             throw e;\n           } catch (Throwable e) {\n             LOG.error(\"Encountered exception on operation \" + op, e);\n             if (recovery \u003d\u003d null) {\n               throw e instanceof IOException? (IOException)e: new IOException(e);\n             }\n \n             MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n              \"apply edit log operation \" + op + \": error \" +\n              e.getMessage(), recovery, \"applying edits\");\n           }\n           // Now that the operation has been successfully decoded and\n           // applied, update our bookkeeping.\n           incrOpCount(op.opCode, opCounts, step, counter);\n           if (op.hasTransactionId()) {\n             lastAppliedTxId \u003d op.getTransactionId();\n             expectedTxId \u003d lastAppliedTxId + 1;\n           } else {\n             expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n           }\n           // log progress\n           if (op.hasTransactionId()) {\n             long now \u003d now();\n             if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n               long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n               int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n               LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                   + \" transactions completed. (\" + percent + \"%)\");\n               lastLogTime \u003d now;\n             }\n           }\n           numEdits++;\n           totalEdits++;\n         } catch (RollingUpgradeOp.RollbackException e) {\n           LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n           break;\n         } catch (MetaRecoveryContext.RequestStopException e) {\n           MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n               in.getPosition() + \"/\"  + in.length());\n           break;\n         }\n       }\n     } finally {\n-      fsNamesys.resetLastInodeId(lastInodeId);\n+      fsNamesys.dir.resetLastInodeId(lastInodeId);\n       if(closeOnExit) {\n         in.close();\n       }\n       fsDir.writeUnlock();\n       fsNamesys.writeUnlock();\n \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(\"replaying edit log finished\");\n       }\n \n       if (FSImage.LOG.isDebugEnabled()) {\n         dumpOpCounts(opCounts);\n       }\n     }\n     return numEdits;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n      long expectedStartingTxId, StartupOption startOpt,\n      MetaRecoveryContext recovery) throws IOException {\n    FSDirectory fsDir \u003d fsNamesys.dir;\n\n    EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n      new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Acquiring write lock to replay edit log\");\n    }\n\n    fsNamesys.writeLock();\n    fsDir.writeLock();\n\n    long recentOpcodeOffsets[] \u003d new long[4];\n    Arrays.fill(recentOpcodeOffsets, -1);\n    \n    long expectedTxId \u003d expectedStartingTxId;\n    long numEdits \u003d 0;\n    long lastTxId \u003d in.getLastTxId();\n    long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    Step step \u003d createStartupProgressStep(in);\n    prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n    Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n    long lastLogTime \u003d now();\n    long lastInodeId \u003d fsNamesys.dir.getLastInodeId();\n    \n    try {\n      while (true) {\n        try {\n          FSEditLogOp op;\n          try {\n            op \u003d in.readOp();\n            if (op \u003d\u003d null) {\n              break;\n            }\n          } catch (Throwable e) {\n            // Handle a problem with our input\n            check203UpgradeFailure(in.getVersion(true), e);\n            String errorMessage \u003d\n              formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n            FSImage.LOG.error(errorMessage, e);\n            if (recovery \u003d\u003d null) {\n               // We will only try to skip over problematic opcodes when in\n               // recovery mode.\n              throw new EditLogInputException(errorMessage, e, numEdits);\n            }\n            MetaRecoveryContext.editLogLoaderPrompt(\n                \"We failed to read txId \" + expectedTxId,\n                recovery, \"skipping the bad section in the log\");\n            in.resync();\n            continue;\n          }\n          recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n            in.getPosition();\n          if (op.hasTransactionId()) {\n            if (op.getTransactionId() \u003e expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be a gap in the edit log.  We expected txid \" +\n                  expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                  \" transaction IDs\");\n            } else if (op.getTransactionId() \u003c expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be an out-of-order edit in the edit log.  We \" +\n                  \"expected txid \" + expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery,\n                  \"skipping the out-of-order edit\");\n              continue;\n            }\n          }\n          try {\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                  + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n            }\n            long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n                in.getVersion(true), lastInodeId);\n            if (lastInodeId \u003c inodeId) {\n              lastInodeId \u003d inodeId;\n            }\n          } catch (RollingUpgradeOp.RollbackException e) {\n            throw e;\n          } catch (Throwable e) {\n            LOG.error(\"Encountered exception on operation \" + op, e);\n            if (recovery \u003d\u003d null) {\n              throw e instanceof IOException? (IOException)e: new IOException(e);\n            }\n\n            MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n             \"apply edit log operation \" + op + \": error \" +\n             e.getMessage(), recovery, \"applying edits\");\n          }\n          // Now that the operation has been successfully decoded and\n          // applied, update our bookkeeping.\n          incrOpCount(op.opCode, opCounts, step, counter);\n          if (op.hasTransactionId()) {\n            lastAppliedTxId \u003d op.getTransactionId();\n            expectedTxId \u003d lastAppliedTxId + 1;\n          } else {\n            expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n          }\n          // log progress\n          if (op.hasTransactionId()) {\n            long now \u003d now();\n            if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n              long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n              int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n              LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                  + \" transactions completed. (\" + percent + \"%)\");\n              lastLogTime \u003d now;\n            }\n          }\n          numEdits++;\n          totalEdits++;\n        } catch (RollingUpgradeOp.RollbackException e) {\n          LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n          break;\n        } catch (MetaRecoveryContext.RequestStopException e) {\n          MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n              in.getPosition() + \"/\"  + in.length());\n          break;\n        }\n      }\n    } finally {\n      fsNamesys.dir.resetLastInodeId(lastInodeId);\n      if(closeOnExit) {\n        in.close();\n      }\n      fsDir.writeUnlock();\n      fsNamesys.writeUnlock();\n\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"replaying edit log finished\");\n      }\n\n      if (FSImage.LOG.isDebugEnabled()) {\n        dumpOpCounts(opCounts);\n      }\n    }\n    return numEdits;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogLoader.java",
      "extendedDetails": {}
    },
    "9dab514b22f49322738935cfd915c2b4eba50b88": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6038. Allow JournalNode to handle editlog produced by new release with future layoutversion. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1579813 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/03/14 4:06 PM",
      "commitName": "9dab514b22f49322738935cfd915c2b4eba50b88",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "03/03/14 8:42 PM",
      "commitNameOld": "5d29338017fb8ebe8626002c1ca670842968ca4a",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 16.77,
      "commitsBetweenForRepo": 144,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n       long expectedStartingTxId, StartupOption startOpt,\n       MetaRecoveryContext recovery) throws IOException {\n     FSDirectory fsDir \u003d fsNamesys.dir;\n \n     EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n       new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Acquiring write lock to replay edit log\");\n     }\n \n     fsNamesys.writeLock();\n     fsDir.writeLock();\n \n     long recentOpcodeOffsets[] \u003d new long[4];\n     Arrays.fill(recentOpcodeOffsets, -1);\n     \n     long expectedTxId \u003d expectedStartingTxId;\n     long numEdits \u003d 0;\n     long lastTxId \u003d in.getLastTxId();\n     long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     Step step \u003d createStartupProgressStep(in);\n     prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n     Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n     long lastLogTime \u003d now();\n     long lastInodeId \u003d fsNamesys.getLastInodeId();\n     \n     try {\n       while (true) {\n         try {\n           FSEditLogOp op;\n           try {\n             op \u003d in.readOp();\n             if (op \u003d\u003d null) {\n               break;\n             }\n           } catch (Throwable e) {\n             // Handle a problem with our input\n-            check203UpgradeFailure(in.getVersion(), e);\n+            check203UpgradeFailure(in.getVersion(true), e);\n             String errorMessage \u003d\n               formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n             FSImage.LOG.error(errorMessage, e);\n             if (recovery \u003d\u003d null) {\n                // We will only try to skip over problematic opcodes when in\n                // recovery mode.\n               throw new EditLogInputException(errorMessage, e, numEdits);\n             }\n             MetaRecoveryContext.editLogLoaderPrompt(\n                 \"We failed to read txId \" + expectedTxId,\n                 recovery, \"skipping the bad section in the log\");\n             in.resync();\n             continue;\n           }\n           recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n             in.getPosition();\n           if (op.hasTransactionId()) {\n             if (op.getTransactionId() \u003e expectedTxId) { \n               MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                   \"to be a gap in the edit log.  We expected txid \" +\n                   expectedTxId + \", but got txid \" +\n                   op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                   \" transaction IDs\");\n             } else if (op.getTransactionId() \u003c expectedTxId) { \n               MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                   \"to be an out-of-order edit in the edit log.  We \" +\n                   \"expected txid \" + expectedTxId + \", but got txid \" +\n                   op.getTransactionId() + \".\", recovery,\n                   \"skipping the out-of-order edit\");\n               continue;\n             }\n           }\n           try {\n             if (LOG.isTraceEnabled()) {\n               LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                   + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n             }\n             long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n-                in.getVersion(), lastInodeId);\n+                in.getVersion(true), lastInodeId);\n             if (lastInodeId \u003c inodeId) {\n               lastInodeId \u003d inodeId;\n             }\n           } catch (RollingUpgradeOp.RollbackException e) {\n             throw e;\n           } catch (Throwable e) {\n             LOG.error(\"Encountered exception on operation \" + op, e);\n             if (recovery \u003d\u003d null) {\n               throw e instanceof IOException? (IOException)e: new IOException(e);\n             }\n \n             MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n              \"apply edit log operation \" + op + \": error \" +\n              e.getMessage(), recovery, \"applying edits\");\n           }\n           // Now that the operation has been successfully decoded and\n           // applied, update our bookkeeping.\n           incrOpCount(op.opCode, opCounts, step, counter);\n           if (op.hasTransactionId()) {\n             lastAppliedTxId \u003d op.getTransactionId();\n             expectedTxId \u003d lastAppliedTxId + 1;\n           } else {\n             expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n           }\n           // log progress\n           if (op.hasTransactionId()) {\n             long now \u003d now();\n             if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n               long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n               int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n               LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                   + \" transactions completed. (\" + percent + \"%)\");\n               lastLogTime \u003d now;\n             }\n           }\n           numEdits++;\n           totalEdits++;\n         } catch (RollingUpgradeOp.RollbackException e) {\n           LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n           break;\n         } catch (MetaRecoveryContext.RequestStopException e) {\n           MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n               in.getPosition() + \"/\"  + in.length());\n           break;\n         }\n       }\n     } finally {\n       fsNamesys.resetLastInodeId(lastInodeId);\n       if(closeOnExit) {\n         in.close();\n       }\n       fsDir.writeUnlock();\n       fsNamesys.writeUnlock();\n \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(\"replaying edit log finished\");\n       }\n \n       if (FSImage.LOG.isDebugEnabled()) {\n         dumpOpCounts(opCounts);\n       }\n     }\n     return numEdits;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n      long expectedStartingTxId, StartupOption startOpt,\n      MetaRecoveryContext recovery) throws IOException {\n    FSDirectory fsDir \u003d fsNamesys.dir;\n\n    EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n      new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Acquiring write lock to replay edit log\");\n    }\n\n    fsNamesys.writeLock();\n    fsDir.writeLock();\n\n    long recentOpcodeOffsets[] \u003d new long[4];\n    Arrays.fill(recentOpcodeOffsets, -1);\n    \n    long expectedTxId \u003d expectedStartingTxId;\n    long numEdits \u003d 0;\n    long lastTxId \u003d in.getLastTxId();\n    long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    Step step \u003d createStartupProgressStep(in);\n    prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n    Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n    long lastLogTime \u003d now();\n    long lastInodeId \u003d fsNamesys.getLastInodeId();\n    \n    try {\n      while (true) {\n        try {\n          FSEditLogOp op;\n          try {\n            op \u003d in.readOp();\n            if (op \u003d\u003d null) {\n              break;\n            }\n          } catch (Throwable e) {\n            // Handle a problem with our input\n            check203UpgradeFailure(in.getVersion(true), e);\n            String errorMessage \u003d\n              formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n            FSImage.LOG.error(errorMessage, e);\n            if (recovery \u003d\u003d null) {\n               // We will only try to skip over problematic opcodes when in\n               // recovery mode.\n              throw new EditLogInputException(errorMessage, e, numEdits);\n            }\n            MetaRecoveryContext.editLogLoaderPrompt(\n                \"We failed to read txId \" + expectedTxId,\n                recovery, \"skipping the bad section in the log\");\n            in.resync();\n            continue;\n          }\n          recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n            in.getPosition();\n          if (op.hasTransactionId()) {\n            if (op.getTransactionId() \u003e expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be a gap in the edit log.  We expected txid \" +\n                  expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                  \" transaction IDs\");\n            } else if (op.getTransactionId() \u003c expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be an out-of-order edit in the edit log.  We \" +\n                  \"expected txid \" + expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery,\n                  \"skipping the out-of-order edit\");\n              continue;\n            }\n          }\n          try {\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                  + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n            }\n            long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n                in.getVersion(true), lastInodeId);\n            if (lastInodeId \u003c inodeId) {\n              lastInodeId \u003d inodeId;\n            }\n          } catch (RollingUpgradeOp.RollbackException e) {\n            throw e;\n          } catch (Throwable e) {\n            LOG.error(\"Encountered exception on operation \" + op, e);\n            if (recovery \u003d\u003d null) {\n              throw e instanceof IOException? (IOException)e: new IOException(e);\n            }\n\n            MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n             \"apply edit log operation \" + op + \": error \" +\n             e.getMessage(), recovery, \"applying edits\");\n          }\n          // Now that the operation has been successfully decoded and\n          // applied, update our bookkeeping.\n          incrOpCount(op.opCode, opCounts, step, counter);\n          if (op.hasTransactionId()) {\n            lastAppliedTxId \u003d op.getTransactionId();\n            expectedTxId \u003d lastAppliedTxId + 1;\n          } else {\n            expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n          }\n          // log progress\n          if (op.hasTransactionId()) {\n            long now \u003d now();\n            if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n              long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n              int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n              LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                  + \" transactions completed. (\" + percent + \"%)\");\n              lastLogTime \u003d now;\n            }\n          }\n          numEdits++;\n          totalEdits++;\n        } catch (RollingUpgradeOp.RollbackException e) {\n          LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n          break;\n        } catch (MetaRecoveryContext.RequestStopException e) {\n          MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n              in.getPosition() + \"/\"  + in.length());\n          break;\n        }\n      }\n    } finally {\n      fsNamesys.resetLastInodeId(lastInodeId);\n      if(closeOnExit) {\n        in.close();\n      }\n      fsDir.writeUnlock();\n      fsNamesys.writeUnlock();\n\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"replaying edit log finished\");\n      }\n\n      if (FSImage.LOG.isDebugEnabled()) {\n        dumpOpCounts(opCounts);\n      }\n    }\n    return numEdits;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogLoader.java",
      "extendedDetails": {}
    },
    "4f9bbaa301194e3d20972a10f51638c7f4d121f0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5889. When starting rolling upgrade, create a fs image for rollback so that the standby namenode can create checkpoints during upgrade.  Contributed by szetszwo \u0026 jing9\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1567861 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/02/14 12:04 AM",
      "commitName": "4f9bbaa301194e3d20972a10f51638c7f4d121f0",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "06/02/14 6:43 PM",
      "commitNameOld": "ccf08d9dc8f88c77d38810cbea4881d94076216c",
      "commitAuthorOld": "",
      "daysBetweenCommits": 6.22,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n       long expectedStartingTxId, StartupOption startOpt,\n       MetaRecoveryContext recovery) throws IOException {\n     FSDirectory fsDir \u003d fsNamesys.dir;\n \n     EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n       new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n \n     if (LOG.isTraceEnabled()) {\n       LOG.trace(\"Acquiring write lock to replay edit log\");\n     }\n \n     fsNamesys.writeLock();\n     fsDir.writeLock();\n \n     long recentOpcodeOffsets[] \u003d new long[4];\n     Arrays.fill(recentOpcodeOffsets, -1);\n     \n     long expectedTxId \u003d expectedStartingTxId;\n     long numEdits \u003d 0;\n     long lastTxId \u003d in.getLastTxId();\n     long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n     StartupProgress prog \u003d NameNode.getStartupProgress();\n     Step step \u003d createStartupProgressStep(in);\n     prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n     Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n     long lastLogTime \u003d now();\n     long lastInodeId \u003d fsNamesys.getLastInodeId();\n     \n     try {\n       while (true) {\n         try {\n           FSEditLogOp op;\n           try {\n             op \u003d in.readOp();\n             if (op \u003d\u003d null) {\n               break;\n             }\n           } catch (Throwable e) {\n             // Handle a problem with our input\n             check203UpgradeFailure(in.getVersion(), e);\n             String errorMessage \u003d\n               formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n             FSImage.LOG.error(errorMessage, e);\n             if (recovery \u003d\u003d null) {\n                // We will only try to skip over problematic opcodes when in\n                // recovery mode.\n               throw new EditLogInputException(errorMessage, e, numEdits);\n             }\n             MetaRecoveryContext.editLogLoaderPrompt(\n                 \"We failed to read txId \" + expectedTxId,\n                 recovery, \"skipping the bad section in the log\");\n             in.resync();\n             continue;\n           }\n           recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n             in.getPosition();\n           if (op.hasTransactionId()) {\n             if (op.getTransactionId() \u003e expectedTxId) { \n               MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                   \"to be a gap in the edit log.  We expected txid \" +\n                   expectedTxId + \", but got txid \" +\n                   op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                   \" transaction IDs\");\n             } else if (op.getTransactionId() \u003c expectedTxId) { \n               MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                   \"to be an out-of-order edit in the edit log.  We \" +\n                   \"expected txid \" + expectedTxId + \", but got txid \" +\n                   op.getTransactionId() + \".\", recovery,\n                   \"skipping the out-of-order edit\");\n               continue;\n             }\n           }\n           try {\n             if (LOG.isTraceEnabled()) {\n               LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                   + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n             }\n             long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n                 in.getVersion(), lastInodeId);\n             if (lastInodeId \u003c inodeId) {\n               lastInodeId \u003d inodeId;\n             }\n-          } catch (UpgradeMarkerException e) {\n+          } catch (RollingUpgradeOp.RollbackException e) {\n             throw e;\n           } catch (Throwable e) {\n             LOG.error(\"Encountered exception on operation \" + op, e);\n             if (recovery \u003d\u003d null) {\n               throw e instanceof IOException? (IOException)e: new IOException(e);\n             }\n \n             MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n              \"apply edit log operation \" + op + \": error \" +\n              e.getMessage(), recovery, \"applying edits\");\n           }\n           // Now that the operation has been successfully decoded and\n           // applied, update our bookkeeping.\n           incrOpCount(op.opCode, opCounts, step, counter);\n           if (op.hasTransactionId()) {\n             lastAppliedTxId \u003d op.getTransactionId();\n             expectedTxId \u003d lastAppliedTxId + 1;\n           } else {\n             expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n           }\n           // log progress\n           if (op.hasTransactionId()) {\n             long now \u003d now();\n             if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n               long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n               int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n               LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                   + \" transactions completed. (\" + percent + \"%)\");\n               lastLogTime \u003d now;\n             }\n           }\n           numEdits++;\n           totalEdits++;\n-        } catch (UpgradeMarkerException e) {\n-          LOG.info(\"Stopped at upgrade marker\");\n+        } catch (RollingUpgradeOp.RollbackException e) {\n+          LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n           break;\n         } catch (MetaRecoveryContext.RequestStopException e) {\n           MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n               in.getPosition() + \"/\"  + in.length());\n           break;\n         }\n       }\n     } finally {\n       fsNamesys.resetLastInodeId(lastInodeId);\n       if(closeOnExit) {\n         in.close();\n       }\n       fsDir.writeUnlock();\n       fsNamesys.writeUnlock();\n \n       if (LOG.isTraceEnabled()) {\n         LOG.trace(\"replaying edit log finished\");\n       }\n \n       if (FSImage.LOG.isDebugEnabled()) {\n         dumpOpCounts(opCounts);\n       }\n     }\n     return numEdits;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  long loadEditRecords(EditLogInputStream in, boolean closeOnExit,\n      long expectedStartingTxId, StartupOption startOpt,\n      MetaRecoveryContext recovery) throws IOException {\n    FSDirectory fsDir \u003d fsNamesys.dir;\n\n    EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e opCounts \u003d\n      new EnumMap\u003cFSEditLogOpCodes, Holder\u003cInteger\u003e\u003e(FSEditLogOpCodes.class);\n\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Acquiring write lock to replay edit log\");\n    }\n\n    fsNamesys.writeLock();\n    fsDir.writeLock();\n\n    long recentOpcodeOffsets[] \u003d new long[4];\n    Arrays.fill(recentOpcodeOffsets, -1);\n    \n    long expectedTxId \u003d expectedStartingTxId;\n    long numEdits \u003d 0;\n    long lastTxId \u003d in.getLastTxId();\n    long numTxns \u003d (lastTxId - expectedStartingTxId) + 1;\n    StartupProgress prog \u003d NameNode.getStartupProgress();\n    Step step \u003d createStartupProgressStep(in);\n    prog.setTotal(Phase.LOADING_EDITS, step, numTxns);\n    Counter counter \u003d prog.getCounter(Phase.LOADING_EDITS, step);\n    long lastLogTime \u003d now();\n    long lastInodeId \u003d fsNamesys.getLastInodeId();\n    \n    try {\n      while (true) {\n        try {\n          FSEditLogOp op;\n          try {\n            op \u003d in.readOp();\n            if (op \u003d\u003d null) {\n              break;\n            }\n          } catch (Throwable e) {\n            // Handle a problem with our input\n            check203UpgradeFailure(in.getVersion(), e);\n            String errorMessage \u003d\n              formatEditLogReplayError(in, recentOpcodeOffsets, expectedTxId);\n            FSImage.LOG.error(errorMessage, e);\n            if (recovery \u003d\u003d null) {\n               // We will only try to skip over problematic opcodes when in\n               // recovery mode.\n              throw new EditLogInputException(errorMessage, e, numEdits);\n            }\n            MetaRecoveryContext.editLogLoaderPrompt(\n                \"We failed to read txId \" + expectedTxId,\n                recovery, \"skipping the bad section in the log\");\n            in.resync();\n            continue;\n          }\n          recentOpcodeOffsets[(int)(numEdits % recentOpcodeOffsets.length)] \u003d\n            in.getPosition();\n          if (op.hasTransactionId()) {\n            if (op.getTransactionId() \u003e expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be a gap in the edit log.  We expected txid \" +\n                  expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery, \"ignoring missing \" +\n                  \" transaction IDs\");\n            } else if (op.getTransactionId() \u003c expectedTxId) { \n              MetaRecoveryContext.editLogLoaderPrompt(\"There appears \" +\n                  \"to be an out-of-order edit in the edit log.  We \" +\n                  \"expected txid \" + expectedTxId + \", but got txid \" +\n                  op.getTransactionId() + \".\", recovery,\n                  \"skipping the out-of-order edit\");\n              continue;\n            }\n          }\n          try {\n            if (LOG.isTraceEnabled()) {\n              LOG.trace(\"op\u003d\" + op + \", startOpt\u003d\" + startOpt\n                  + \", numEdits\u003d\" + numEdits + \", totalEdits\u003d\" + totalEdits);\n            }\n            long inodeId \u003d applyEditLogOp(op, fsDir, startOpt,\n                in.getVersion(), lastInodeId);\n            if (lastInodeId \u003c inodeId) {\n              lastInodeId \u003d inodeId;\n            }\n          } catch (RollingUpgradeOp.RollbackException e) {\n            throw e;\n          } catch (Throwable e) {\n            LOG.error(\"Encountered exception on operation \" + op, e);\n            if (recovery \u003d\u003d null) {\n              throw e instanceof IOException? (IOException)e: new IOException(e);\n            }\n\n            MetaRecoveryContext.editLogLoaderPrompt(\"Failed to \" +\n             \"apply edit log operation \" + op + \": error \" +\n             e.getMessage(), recovery, \"applying edits\");\n          }\n          // Now that the operation has been successfully decoded and\n          // applied, update our bookkeeping.\n          incrOpCount(op.opCode, opCounts, step, counter);\n          if (op.hasTransactionId()) {\n            lastAppliedTxId \u003d op.getTransactionId();\n            expectedTxId \u003d lastAppliedTxId + 1;\n          } else {\n            expectedTxId \u003d lastAppliedTxId \u003d expectedStartingTxId;\n          }\n          // log progress\n          if (op.hasTransactionId()) {\n            long now \u003d now();\n            if (now - lastLogTime \u003e REPLAY_TRANSACTION_LOG_INTERVAL) {\n              long deltaTxId \u003d lastAppliedTxId - expectedStartingTxId + 1;\n              int percent \u003d Math.round((float) deltaTxId / numTxns * 100);\n              LOG.info(\"replaying edit log: \" + deltaTxId + \"/\" + numTxns\n                  + \" transactions completed. (\" + percent + \"%)\");\n              lastLogTime \u003d now;\n            }\n          }\n          numEdits++;\n          totalEdits++;\n        } catch (RollingUpgradeOp.RollbackException e) {\n          LOG.info(\"Stopped at OP_START_ROLLING_UPGRADE for rollback.\");\n          break;\n        } catch (MetaRecoveryContext.RequestStopException e) {\n          MetaRecoveryContext.LOG.warn(\"Stopped reading edit log at \" +\n              in.getPosition() + \"/\"  + in.length());\n          break;\n        }\n      }\n    } finally {\n      fsNamesys.resetLastInodeId(lastInodeId);\n      if(closeOnExit) {\n        in.close();\n      }\n      fsDir.writeUnlock();\n      fsNamesys.writeUnlock();\n\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"replaying edit log finished\");\n      }\n\n      if (FSImage.LOG.isDebugEnabled()) {\n        dumpOpCounts(opCounts);\n      }\n    }\n    return numEdits;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogLoader.java",
      "extendedDetails": {}
    }
  }
}