{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3Guard.java",
  "functionName": "makeDirsOrdered",
  "functionId": "makeDirsOrdered___ms-MetadataStore__dirs-List__Path____owner-String__authoritative-boolean__timeProvider-ITtlTimeProvider",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
  "functionStartLine": 538,
  "functionEndLine": 595,
  "numCommitsSeen": 30,
  "timeTaken": 4197,
  "changeHistory": [
    "7f40e6688a5716fca53e1090d8347a43064d6d43",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
    "a36274d69947648dbe82721220cc5240ec5d396d",
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
    "621b43e254afaff708cd6fc4698b29628f6abc33"
  ],
  "changeHistoryShort": {
    "7f40e6688a5716fca53e1090d8347a43064d6d43": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ybodychange",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": "Ybodychange",
    "a36274d69947648dbe82721220cc5240ec5d396d": "Ybodychange",
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3": "Ymultichange(Yparameterchange,Ybodychange)",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7f40e6688a5716fca53e1090d8347a43064d6d43": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16746. mkdirs and s3guard Authoritative mode.\n\nContributed by Steve Loughran.\n\nThis fixes two problems with S3Guard authoritative mode and\nthe auth directory flags which are stored in DynamoDB.\n\n1. mkdirs was creating dir markers without the auth bit,\n   forcing needless scans on newly created directories and\n   files subsequently added; it was only with the first listStatus call\n   on that directory that the dir would be marked as authoritative -even\n   though it would be complete already.\n\n2. listStatus(path) would reset the authoritative status bit of all\n   child directories even if they were already marked as authoritative.\n\nIssue #2 is possibly the most expensive, as any treewalk using listStatus\n(e.g globfiles) would clear the auth bit for all child directories before\nlisting them. And this would happen every single time...\nessentially you weren\u0027t getting authoritative directory listings.\n\nFor the curious, that the major bug was actually found during testing\n-we\u0027d all missed it during reviews.\n\nA lesson there: the better the tests the fewer the bugs.\n\nMaybe also: something obvious and significant can get by code reviews.\n\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/BulkOperationState.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/NullMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/ITestS3GuardWriteBack.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/auth/ITestRestrictedReadAccess.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/impl/TestPartialDeleteFailures.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreAuthoritativeMode.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreScale.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestS3GuardFsck.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStoreTestBase.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/TestS3Guard.java\n\nChange-Id: Ic3ffda13f2af2430afedd50fd657b595c83e90a7\n",
      "commitDate": "25/01/20 10:35 AM",
      "commitName": "7f40e6688a5716fca53e1090d8347a43064d6d43",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "10/01/20 3:11 AM",
      "commitNameOld": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 15.31,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n       String owner, boolean authoritative, ITtlTimeProvider timeProvider) {\n     if (dirs \u003d\u003d null) {\n       return;\n     }\n \n     /* We discussed atomicity of this implementation.\n      * The concern is that multiple clients could race to write different\n      * cached directories to the MetadataStore.  Two solutions are proposed:\n      * 1. Move mkdirs() into MetadataStore interface and let implementations\n      *    ensure they are atomic.\n      * 2. Specify that the semantics of MetadataStore#putListStatus() is\n      *    always additive,  That is, if MetadataStore has listStatus() state\n      *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n      *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n      *    then we will end up with final state of\n      *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n      *    true\n      */\n     S3AFileStatus prevStatus \u003d null;\n \n     // Use new batched put to reduce round trips.\n     List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n \n     try {\n       // Iterate from leaf to root\n       for (int i \u003d 0; i \u003c dirs.size(); i++) {\n         boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n         Path f \u003d dirs.get(i);\n         assertQualified(f);\n         S3AFileStatus status \u003d\n             createUploadFileStatus(f, true, 0, 0, owner, null, null);\n \n         // We only need to put a DirListingMetadata if we are setting\n         // authoritative bit\n         DirListingMetadata dirMeta \u003d null;\n         if (authoritative) {\n           Collection\u003cPathMetadata\u003e children;\n           if (isLeaf) {\n             children \u003d DirListingMetadata.EMPTY_DIR;\n           } else {\n             children \u003d new ArrayList\u003c\u003e(1);\n             children.add(new PathMetadata(prevStatus));\n           }\n           dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n-          S3Guard.putWithTtl(ms, dirMeta, timeProvider, null);\n+          S3Guard.putWithTtl(ms, dirMeta, Collections.emptyList(), timeProvider, null);\n         }\n \n         pathMetas.add(new PathMetadata(status));\n         prevStatus \u003d status;\n       }\n \n       // Batched put\n       S3Guard.putWithTtl(ms, pathMetas, timeProvider, null);\n     } catch (IOException ioe) {\n       LOG.error(\"MetadataStore#put() failure:\", ioe);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n      String owner, boolean authoritative, ITtlTimeProvider timeProvider) {\n    if (dirs \u003d\u003d null) {\n      return;\n    }\n\n    /* We discussed atomicity of this implementation.\n     * The concern is that multiple clients could race to write different\n     * cached directories to the MetadataStore.  Two solutions are proposed:\n     * 1. Move mkdirs() into MetadataStore interface and let implementations\n     *    ensure they are atomic.\n     * 2. Specify that the semantics of MetadataStore#putListStatus() is\n     *    always additive,  That is, if MetadataStore has listStatus() state\n     *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n     *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n     *    then we will end up with final state of\n     *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n     *    true\n     */\n    S3AFileStatus prevStatus \u003d null;\n\n    // Use new batched put to reduce round trips.\n    List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n\n    try {\n      // Iterate from leaf to root\n      for (int i \u003d 0; i \u003c dirs.size(); i++) {\n        boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n        Path f \u003d dirs.get(i);\n        assertQualified(f);\n        S3AFileStatus status \u003d\n            createUploadFileStatus(f, true, 0, 0, owner, null, null);\n\n        // We only need to put a DirListingMetadata if we are setting\n        // authoritative bit\n        DirListingMetadata dirMeta \u003d null;\n        if (authoritative) {\n          Collection\u003cPathMetadata\u003e children;\n          if (isLeaf) {\n            children \u003d DirListingMetadata.EMPTY_DIR;\n          } else {\n            children \u003d new ArrayList\u003c\u003e(1);\n            children.add(new PathMetadata(prevStatus));\n          }\n          dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n          S3Guard.putWithTtl(ms, dirMeta, Collections.emptyList(), timeProvider, null);\n        }\n\n        pathMetas.add(new PathMetadata(status));\n        prevStatus \u003d status;\n      }\n\n      // Batched put\n      S3Guard.putWithTtl(ms, pathMetas, timeProvider, null);\n    } catch (IOException ioe) {\n      LOG.error(\"MetadataStore#put() failure:\", ioe);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "16/06/19 9:05 AM",
      "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 3.7,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n       String owner, boolean authoritative, ITtlTimeProvider timeProvider) {\n     if (dirs \u003d\u003d null) {\n       return;\n     }\n \n     /* We discussed atomicity of this implementation.\n      * The concern is that multiple clients could race to write different\n      * cached directories to the MetadataStore.  Two solutions are proposed:\n      * 1. Move mkdirs() into MetadataStore interface and let implementations\n      *    ensure they are atomic.\n      * 2. Specify that the semantics of MetadataStore#putListStatus() is\n      *    always additive,  That is, if MetadataStore has listStatus() state\n      *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n      *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n      *    then we will end up with final state of\n      *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n      *    true\n      */\n     S3AFileStatus prevStatus \u003d null;\n \n     // Use new batched put to reduce round trips.\n     List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n \n     try {\n       // Iterate from leaf to root\n       for (int i \u003d 0; i \u003c dirs.size(); i++) {\n         boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n         Path f \u003d dirs.get(i);\n         assertQualified(f);\n         S3AFileStatus status \u003d\n             createUploadFileStatus(f, true, 0, 0, owner, null, null);\n \n         // We only need to put a DirListingMetadata if we are setting\n         // authoritative bit\n         DirListingMetadata dirMeta \u003d null;\n         if (authoritative) {\n           Collection\u003cPathMetadata\u003e children;\n           if (isLeaf) {\n             children \u003d DirListingMetadata.EMPTY_DIR;\n           } else {\n             children \u003d new ArrayList\u003c\u003e(1);\n             children.add(new PathMetadata(prevStatus));\n           }\n           dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n-          S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n+          S3Guard.putWithTtl(ms, dirMeta, timeProvider, null);\n         }\n \n         pathMetas.add(new PathMetadata(status));\n         prevStatus \u003d status;\n       }\n \n       // Batched put\n-      S3Guard.putWithTtl(ms, pathMetas, timeProvider);\n+      S3Guard.putWithTtl(ms, pathMetas, timeProvider, null);\n     } catch (IOException ioe) {\n       LOG.error(\"MetadataStore#put() failure:\", ioe);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n      String owner, boolean authoritative, ITtlTimeProvider timeProvider) {\n    if (dirs \u003d\u003d null) {\n      return;\n    }\n\n    /* We discussed atomicity of this implementation.\n     * The concern is that multiple clients could race to write different\n     * cached directories to the MetadataStore.  Two solutions are proposed:\n     * 1. Move mkdirs() into MetadataStore interface and let implementations\n     *    ensure they are atomic.\n     * 2. Specify that the semantics of MetadataStore#putListStatus() is\n     *    always additive,  That is, if MetadataStore has listStatus() state\n     *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n     *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n     *    then we will end up with final state of\n     *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n     *    true\n     */\n    S3AFileStatus prevStatus \u003d null;\n\n    // Use new batched put to reduce round trips.\n    List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n\n    try {\n      // Iterate from leaf to root\n      for (int i \u003d 0; i \u003c dirs.size(); i++) {\n        boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n        Path f \u003d dirs.get(i);\n        assertQualified(f);\n        S3AFileStatus status \u003d\n            createUploadFileStatus(f, true, 0, 0, owner, null, null);\n\n        // We only need to put a DirListingMetadata if we are setting\n        // authoritative bit\n        DirListingMetadata dirMeta \u003d null;\n        if (authoritative) {\n          Collection\u003cPathMetadata\u003e children;\n          if (isLeaf) {\n            children \u003d DirListingMetadata.EMPTY_DIR;\n          } else {\n            children \u003d new ArrayList\u003c\u003e(1);\n            children.add(new PathMetadata(prevStatus));\n          }\n          dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n          S3Guard.putWithTtl(ms, dirMeta, timeProvider, null);\n        }\n\n        pathMetas.add(new PathMetadata(status));\n        prevStatus \u003d status;\n      }\n\n      // Batched put\n      S3Guard.putWithTtl(ms, pathMetas, timeProvider, null);\n    } catch (IOException ioe) {\n      LOG.error(\"MetadataStore#put() failure:\", ioe);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
      "extendedDetails": {}
    },
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
      "commitDate": "16/06/19 9:05 AM",
      "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "19/05/19 2:29 PM",
      "commitNameOld": "a36274d69947648dbe82721220cc5240ec5d396d",
      "commitAuthorOld": "Ben Roling",
      "daysBetweenCommits": 27.77,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n       String owner, boolean authoritative, ITtlTimeProvider timeProvider) {\n     if (dirs \u003d\u003d null) {\n       return;\n     }\n \n     /* We discussed atomicity of this implementation.\n      * The concern is that multiple clients could race to write different\n      * cached directories to the MetadataStore.  Two solutions are proposed:\n      * 1. Move mkdirs() into MetadataStore interface and let implementations\n      *    ensure they are atomic.\n      * 2. Specify that the semantics of MetadataStore#putListStatus() is\n      *    always additive,  That is, if MetadataStore has listStatus() state\n      *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n      *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n      *    then we will end up with final state of\n      *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n      *    true\n      */\n     S3AFileStatus prevStatus \u003d null;\n \n     // Use new batched put to reduce round trips.\n     List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n \n     try {\n       // Iterate from leaf to root\n       for (int i \u003d 0; i \u003c dirs.size(); i++) {\n         boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n         Path f \u003d dirs.get(i);\n         assertQualified(f);\n         S3AFileStatus status \u003d\n             createUploadFileStatus(f, true, 0, 0, owner, null, null);\n \n         // We only need to put a DirListingMetadata if we are setting\n         // authoritative bit\n         DirListingMetadata dirMeta \u003d null;\n         if (authoritative) {\n           Collection\u003cPathMetadata\u003e children;\n           if (isLeaf) {\n             children \u003d DirListingMetadata.EMPTY_DIR;\n           } else {\n             children \u003d new ArrayList\u003c\u003e(1);\n             children.add(new PathMetadata(prevStatus));\n           }\n           dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n           S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n         }\n \n         pathMetas.add(new PathMetadata(status));\n         prevStatus \u003d status;\n       }\n \n       // Batched put\n-      ms.put(pathMetas);\n+      S3Guard.putWithTtl(ms, pathMetas, timeProvider);\n     } catch (IOException ioe) {\n       LOG.error(\"MetadataStore#put() failure:\", ioe);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n      String owner, boolean authoritative, ITtlTimeProvider timeProvider) {\n    if (dirs \u003d\u003d null) {\n      return;\n    }\n\n    /* We discussed atomicity of this implementation.\n     * The concern is that multiple clients could race to write different\n     * cached directories to the MetadataStore.  Two solutions are proposed:\n     * 1. Move mkdirs() into MetadataStore interface and let implementations\n     *    ensure they are atomic.\n     * 2. Specify that the semantics of MetadataStore#putListStatus() is\n     *    always additive,  That is, if MetadataStore has listStatus() state\n     *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n     *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n     *    then we will end up with final state of\n     *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n     *    true\n     */\n    S3AFileStatus prevStatus \u003d null;\n\n    // Use new batched put to reduce round trips.\n    List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n\n    try {\n      // Iterate from leaf to root\n      for (int i \u003d 0; i \u003c dirs.size(); i++) {\n        boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n        Path f \u003d dirs.get(i);\n        assertQualified(f);\n        S3AFileStatus status \u003d\n            createUploadFileStatus(f, true, 0, 0, owner, null, null);\n\n        // We only need to put a DirListingMetadata if we are setting\n        // authoritative bit\n        DirListingMetadata dirMeta \u003d null;\n        if (authoritative) {\n          Collection\u003cPathMetadata\u003e children;\n          if (isLeaf) {\n            children \u003d DirListingMetadata.EMPTY_DIR;\n          } else {\n            children \u003d new ArrayList\u003c\u003e(1);\n            children.add(new PathMetadata(prevStatus));\n          }\n          dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n          S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n        }\n\n        pathMetas.add(new PathMetadata(status));\n        prevStatus \u003d status;\n      }\n\n      // Batched put\n      S3Guard.putWithTtl(ms, pathMetas, timeProvider);\n    } catch (IOException ioe) {\n      LOG.error(\"MetadataStore#put() failure:\", ioe);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
      "extendedDetails": {}
    },
    "a36274d69947648dbe82721220cc5240ec5d396d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
      "commitDate": "19/05/19 2:29 PM",
      "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
      "commitAuthor": "Ben Roling",
      "commitDateOld": "30/04/19 3:53 AM",
      "commitNameOld": "0af4011580878566213016af0c32633eabd15100",
      "commitAuthorOld": "Ben Roling",
      "daysBetweenCommits": 19.44,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n       String owner, boolean authoritative, ITtlTimeProvider timeProvider) {\n     if (dirs \u003d\u003d null) {\n       return;\n     }\n \n     /* We discussed atomicity of this implementation.\n      * The concern is that multiple clients could race to write different\n      * cached directories to the MetadataStore.  Two solutions are proposed:\n      * 1. Move mkdirs() into MetadataStore interface and let implementations\n      *    ensure they are atomic.\n      * 2. Specify that the semantics of MetadataStore#putListStatus() is\n      *    always additive,  That is, if MetadataStore has listStatus() state\n      *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n      *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n      *    then we will end up with final state of\n      *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n      *    true\n      */\n-    FileStatus prevStatus \u003d null;\n+    S3AFileStatus prevStatus \u003d null;\n \n     // Use new batched put to reduce round trips.\n     List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n \n     try {\n       // Iterate from leaf to root\n       for (int i \u003d 0; i \u003c dirs.size(); i++) {\n         boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n         Path f \u003d dirs.get(i);\n         assertQualified(f);\n-        FileStatus status \u003d\n-            createUploadFileStatus(f, true, 0, 0, owner);\n+        S3AFileStatus status \u003d\n+            createUploadFileStatus(f, true, 0, 0, owner, null, null);\n \n         // We only need to put a DirListingMetadata if we are setting\n         // authoritative bit\n         DirListingMetadata dirMeta \u003d null;\n         if (authoritative) {\n           Collection\u003cPathMetadata\u003e children;\n           if (isLeaf) {\n             children \u003d DirListingMetadata.EMPTY_DIR;\n           } else {\n             children \u003d new ArrayList\u003c\u003e(1);\n             children.add(new PathMetadata(prevStatus));\n           }\n           dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n           S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n         }\n \n         pathMetas.add(new PathMetadata(status));\n         prevStatus \u003d status;\n       }\n \n       // Batched put\n       ms.put(pathMetas);\n     } catch (IOException ioe) {\n       LOG.error(\"MetadataStore#put() failure:\", ioe);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n      String owner, boolean authoritative, ITtlTimeProvider timeProvider) {\n    if (dirs \u003d\u003d null) {\n      return;\n    }\n\n    /* We discussed atomicity of this implementation.\n     * The concern is that multiple clients could race to write different\n     * cached directories to the MetadataStore.  Two solutions are proposed:\n     * 1. Move mkdirs() into MetadataStore interface and let implementations\n     *    ensure they are atomic.\n     * 2. Specify that the semantics of MetadataStore#putListStatus() is\n     *    always additive,  That is, if MetadataStore has listStatus() state\n     *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n     *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n     *    then we will end up with final state of\n     *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n     *    true\n     */\n    S3AFileStatus prevStatus \u003d null;\n\n    // Use new batched put to reduce round trips.\n    List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n\n    try {\n      // Iterate from leaf to root\n      for (int i \u003d 0; i \u003c dirs.size(); i++) {\n        boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n        Path f \u003d dirs.get(i);\n        assertQualified(f);\n        S3AFileStatus status \u003d\n            createUploadFileStatus(f, true, 0, 0, owner, null, null);\n\n        // We only need to put a DirListingMetadata if we are setting\n        // authoritative bit\n        DirListingMetadata dirMeta \u003d null;\n        if (authoritative) {\n          Collection\u003cPathMetadata\u003e children;\n          if (isLeaf) {\n            children \u003d DirListingMetadata.EMPTY_DIR;\n          } else {\n            children \u003d new ArrayList\u003c\u003e(1);\n            children.add(new PathMetadata(prevStatus));\n          }\n          dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n          S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n        }\n\n        pathMetas.add(new PathMetadata(status));\n        prevStatus \u003d status;\n      }\n\n      // Batched put\n      ms.put(pathMetas);\n    } catch (IOException ioe) {\n      LOG.error(\"MetadataStore#put() failure:\", ioe);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
      "extendedDetails": {}
    },
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-15621 S3Guard: Implement time-based (TTL) expiry for Authoritative Directory Listing. Contributed by Gabor Bota\n",
      "commitDate": "02/10/18 9:22 PM",
      "commitName": "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
      "commitAuthor": "Aaron Fabbri",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-15621 S3Guard: Implement time-based (TTL) expiry for Authoritative Directory Listing. Contributed by Gabor Bota\n",
          "commitDate": "02/10/18 9:22 PM",
          "commitName": "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
          "commitAuthor": "Aaron Fabbri",
          "commitDateOld": "17/08/18 10:15 AM",
          "commitNameOld": "d7232857d8d1e10cdac171acdc931187e45fd6be",
          "commitAuthorOld": "Aaron Fabbri",
          "daysBetweenCommits": 46.46,
          "commitsBetweenForRepo": 388,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,58 @@\n   public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n-      String owner, boolean authoritative) {\n+      String owner, boolean authoritative, ITtlTimeProvider timeProvider) {\n     if (dirs \u003d\u003d null) {\n       return;\n     }\n \n     /* We discussed atomicity of this implementation.\n      * The concern is that multiple clients could race to write different\n      * cached directories to the MetadataStore.  Two solutions are proposed:\n      * 1. Move mkdirs() into MetadataStore interface and let implementations\n      *    ensure they are atomic.\n      * 2. Specify that the semantics of MetadataStore#putListStatus() is\n      *    always additive,  That is, if MetadataStore has listStatus() state\n      *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n      *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n      *    then we will end up with final state of\n      *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n      *    true\n      */\n     FileStatus prevStatus \u003d null;\n \n     // Use new batched put to reduce round trips.\n     List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n \n     try {\n       // Iterate from leaf to root\n       for (int i \u003d 0; i \u003c dirs.size(); i++) {\n         boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n         Path f \u003d dirs.get(i);\n         assertQualified(f);\n         FileStatus status \u003d\n             createUploadFileStatus(f, true, 0, 0, owner);\n \n         // We only need to put a DirListingMetadata if we are setting\n         // authoritative bit\n         DirListingMetadata dirMeta \u003d null;\n         if (authoritative) {\n           Collection\u003cPathMetadata\u003e children;\n           if (isLeaf) {\n             children \u003d DirListingMetadata.EMPTY_DIR;\n           } else {\n             children \u003d new ArrayList\u003c\u003e(1);\n             children.add(new PathMetadata(prevStatus));\n           }\n           dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n-          ms.put(dirMeta);\n+          S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n         }\n \n         pathMetas.add(new PathMetadata(status));\n         prevStatus \u003d status;\n       }\n \n       // Batched put\n       ms.put(pathMetas);\n     } catch (IOException ioe) {\n       LOG.error(\"MetadataStore#put() failure:\", ioe);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n      String owner, boolean authoritative, ITtlTimeProvider timeProvider) {\n    if (dirs \u003d\u003d null) {\n      return;\n    }\n\n    /* We discussed atomicity of this implementation.\n     * The concern is that multiple clients could race to write different\n     * cached directories to the MetadataStore.  Two solutions are proposed:\n     * 1. Move mkdirs() into MetadataStore interface and let implementations\n     *    ensure they are atomic.\n     * 2. Specify that the semantics of MetadataStore#putListStatus() is\n     *    always additive,  That is, if MetadataStore has listStatus() state\n     *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n     *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n     *    then we will end up with final state of\n     *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n     *    true\n     */\n    FileStatus prevStatus \u003d null;\n\n    // Use new batched put to reduce round trips.\n    List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n\n    try {\n      // Iterate from leaf to root\n      for (int i \u003d 0; i \u003c dirs.size(); i++) {\n        boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n        Path f \u003d dirs.get(i);\n        assertQualified(f);\n        FileStatus status \u003d\n            createUploadFileStatus(f, true, 0, 0, owner);\n\n        // We only need to put a DirListingMetadata if we are setting\n        // authoritative bit\n        DirListingMetadata dirMeta \u003d null;\n        if (authoritative) {\n          Collection\u003cPathMetadata\u003e children;\n          if (isLeaf) {\n            children \u003d DirListingMetadata.EMPTY_DIR;\n          } else {\n            children \u003d new ArrayList\u003c\u003e(1);\n            children.add(new PathMetadata(prevStatus));\n          }\n          dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n          S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n        }\n\n        pathMetas.add(new PathMetadata(status));\n        prevStatus \u003d status;\n      }\n\n      // Batched put\n      ms.put(pathMetas);\n    } catch (IOException ioe) {\n      LOG.error(\"MetadataStore#put() failure:\", ioe);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
          "extendedDetails": {
            "oldValue": "[ms-MetadataStore, dirs-List\u003cPath\u003e, owner-String, authoritative-boolean]",
            "newValue": "[ms-MetadataStore, dirs-List\u003cPath\u003e, owner-String, authoritative-boolean, timeProvider-ITtlTimeProvider]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15621 S3Guard: Implement time-based (TTL) expiry for Authoritative Directory Listing. Contributed by Gabor Bota\n",
          "commitDate": "02/10/18 9:22 PM",
          "commitName": "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
          "commitAuthor": "Aaron Fabbri",
          "commitDateOld": "17/08/18 10:15 AM",
          "commitNameOld": "d7232857d8d1e10cdac171acdc931187e45fd6be",
          "commitAuthorOld": "Aaron Fabbri",
          "daysBetweenCommits": 46.46,
          "commitsBetweenForRepo": 388,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,58 @@\n   public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n-      String owner, boolean authoritative) {\n+      String owner, boolean authoritative, ITtlTimeProvider timeProvider) {\n     if (dirs \u003d\u003d null) {\n       return;\n     }\n \n     /* We discussed atomicity of this implementation.\n      * The concern is that multiple clients could race to write different\n      * cached directories to the MetadataStore.  Two solutions are proposed:\n      * 1. Move mkdirs() into MetadataStore interface and let implementations\n      *    ensure they are atomic.\n      * 2. Specify that the semantics of MetadataStore#putListStatus() is\n      *    always additive,  That is, if MetadataStore has listStatus() state\n      *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n      *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n      *    then we will end up with final state of\n      *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n      *    true\n      */\n     FileStatus prevStatus \u003d null;\n \n     // Use new batched put to reduce round trips.\n     List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n \n     try {\n       // Iterate from leaf to root\n       for (int i \u003d 0; i \u003c dirs.size(); i++) {\n         boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n         Path f \u003d dirs.get(i);\n         assertQualified(f);\n         FileStatus status \u003d\n             createUploadFileStatus(f, true, 0, 0, owner);\n \n         // We only need to put a DirListingMetadata if we are setting\n         // authoritative bit\n         DirListingMetadata dirMeta \u003d null;\n         if (authoritative) {\n           Collection\u003cPathMetadata\u003e children;\n           if (isLeaf) {\n             children \u003d DirListingMetadata.EMPTY_DIR;\n           } else {\n             children \u003d new ArrayList\u003c\u003e(1);\n             children.add(new PathMetadata(prevStatus));\n           }\n           dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n-          ms.put(dirMeta);\n+          S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n         }\n \n         pathMetas.add(new PathMetadata(status));\n         prevStatus \u003d status;\n       }\n \n       // Batched put\n       ms.put(pathMetas);\n     } catch (IOException ioe) {\n       LOG.error(\"MetadataStore#put() failure:\", ioe);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n      String owner, boolean authoritative, ITtlTimeProvider timeProvider) {\n    if (dirs \u003d\u003d null) {\n      return;\n    }\n\n    /* We discussed atomicity of this implementation.\n     * The concern is that multiple clients could race to write different\n     * cached directories to the MetadataStore.  Two solutions are proposed:\n     * 1. Move mkdirs() into MetadataStore interface and let implementations\n     *    ensure they are atomic.\n     * 2. Specify that the semantics of MetadataStore#putListStatus() is\n     *    always additive,  That is, if MetadataStore has listStatus() state\n     *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n     *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n     *    then we will end up with final state of\n     *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n     *    true\n     */\n    FileStatus prevStatus \u003d null;\n\n    // Use new batched put to reduce round trips.\n    List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n\n    try {\n      // Iterate from leaf to root\n      for (int i \u003d 0; i \u003c dirs.size(); i++) {\n        boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n        Path f \u003d dirs.get(i);\n        assertQualified(f);\n        FileStatus status \u003d\n            createUploadFileStatus(f, true, 0, 0, owner);\n\n        // We only need to put a DirListingMetadata if we are setting\n        // authoritative bit\n        DirListingMetadata dirMeta \u003d null;\n        if (authoritative) {\n          Collection\u003cPathMetadata\u003e children;\n          if (isLeaf) {\n            children \u003d DirListingMetadata.EMPTY_DIR;\n          } else {\n            children \u003d new ArrayList\u003c\u003e(1);\n            children.add(new PathMetadata(prevStatus));\n          }\n          dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n          S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n        }\n\n        pathMetas.add(new PathMetadata(status));\n        prevStatus \u003d status;\n      }\n\n      // Batched put\n      ms.put(pathMetas);\n    } catch (IOException ioe) {\n      LOG.error(\"MetadataStore#put() failure:\", ioe);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
          "extendedDetails": {}
        }
      ]
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,58 @@\n+  public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n+      String owner, boolean authoritative) {\n+    if (dirs \u003d\u003d null) {\n+      return;\n+    }\n+\n+    /* We discussed atomicity of this implementation.\n+     * The concern is that multiple clients could race to write different\n+     * cached directories to the MetadataStore.  Two solutions are proposed:\n+     * 1. Move mkdirs() into MetadataStore interface and let implementations\n+     *    ensure they are atomic.\n+     * 2. Specify that the semantics of MetadataStore#putListStatus() is\n+     *    always additive,  That is, if MetadataStore has listStatus() state\n+     *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n+     *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n+     *    then we will end up with final state of\n+     *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n+     *    true\n+     */\n+    FileStatus prevStatus \u003d null;\n+\n+    // Use new batched put to reduce round trips.\n+    List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n+\n+    try {\n+      // Iterate from leaf to root\n+      for (int i \u003d 0; i \u003c dirs.size(); i++) {\n+        boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n+        Path f \u003d dirs.get(i);\n+        assertQualified(f);\n+        FileStatus status \u003d\n+            createUploadFileStatus(f, true, 0, 0, owner);\n+\n+        // We only need to put a DirListingMetadata if we are setting\n+        // authoritative bit\n+        DirListingMetadata dirMeta \u003d null;\n+        if (authoritative) {\n+          Collection\u003cPathMetadata\u003e children;\n+          if (isLeaf) {\n+            children \u003d DirListingMetadata.EMPTY_DIR;\n+          } else {\n+            children \u003d new ArrayList\u003c\u003e(1);\n+            children.add(new PathMetadata(prevStatus));\n+          }\n+          dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n+          ms.put(dirMeta);\n+        }\n+\n+        pathMetas.add(new PathMetadata(status));\n+        prevStatus \u003d status;\n+      }\n+\n+      // Batched put\n+      ms.put(pathMetas);\n+    } catch (IOException ioe) {\n+      LOG.error(\"MetadataStore#put() failure:\", ioe);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static void makeDirsOrdered(MetadataStore ms, List\u003cPath\u003e dirs,\n      String owner, boolean authoritative) {\n    if (dirs \u003d\u003d null) {\n      return;\n    }\n\n    /* We discussed atomicity of this implementation.\n     * The concern is that multiple clients could race to write different\n     * cached directories to the MetadataStore.  Two solutions are proposed:\n     * 1. Move mkdirs() into MetadataStore interface and let implementations\n     *    ensure they are atomic.\n     * 2. Specify that the semantics of MetadataStore#putListStatus() is\n     *    always additive,  That is, if MetadataStore has listStatus() state\n     *    for /a/b that contains [/a/b/file0, /a/b/file1], and we then call\n     *    putListStatus(/a/b -\u003e [/a/b/file2, /a/b/file3], isAuthoritative\u003dtrue),\n     *    then we will end up with final state of\n     *    [/a/b/file0, /a/b/file1, /a/b/file2, /a/b/file3], isAuthoritative \u003d\n     *    true\n     */\n    FileStatus prevStatus \u003d null;\n\n    // Use new batched put to reduce round trips.\n    List\u003cPathMetadata\u003e pathMetas \u003d new ArrayList\u003c\u003e(dirs.size());\n\n    try {\n      // Iterate from leaf to root\n      for (int i \u003d 0; i \u003c dirs.size(); i++) {\n        boolean isLeaf \u003d (prevStatus \u003d\u003d null);\n        Path f \u003d dirs.get(i);\n        assertQualified(f);\n        FileStatus status \u003d\n            createUploadFileStatus(f, true, 0, 0, owner);\n\n        // We only need to put a DirListingMetadata if we are setting\n        // authoritative bit\n        DirListingMetadata dirMeta \u003d null;\n        if (authoritative) {\n          Collection\u003cPathMetadata\u003e children;\n          if (isLeaf) {\n            children \u003d DirListingMetadata.EMPTY_DIR;\n          } else {\n            children \u003d new ArrayList\u003c\u003e(1);\n            children.add(new PathMetadata(prevStatus));\n          }\n          dirMeta \u003d new DirListingMetadata(f, children, authoritative);\n          ms.put(dirMeta);\n        }\n\n        pathMetas.add(new PathMetadata(status));\n        prevStatus \u003d status;\n      }\n\n      // Batched put\n      ms.put(pathMetas);\n    } catch (IOException ioe) {\n      LOG.error(\"MetadataStore#put() failure:\", ioe);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java"
    }
  }
}