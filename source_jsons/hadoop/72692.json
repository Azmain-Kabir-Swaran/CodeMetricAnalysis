{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "KMSClientProvider.java",
  "functionName": "call",
  "functionId": "call___conn-HttpURLConnection__jsonOutput-Object__expectedResponse-int__klass-Class__T____authRetryCount-int",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
  "functionStartLine": 543,
  "functionEndLine": 605,
  "numCommitsSeen": 145,
  "timeTaken": 5273,
  "changeHistory": [
    "32f867a6a907c05a312657139d295a92756d98ef",
    "4cdbdce752e192b45c2b9756c2d4bd24ceffdabd",
    "c3793102121767c46091805eae65ef3919a5f368",
    "4ec5acc70418a3f2327cf83ecae1789a057fdd99",
    "0202480742b8539aa7aa1e94dc9cab75d863cc4e",
    "28bd138018bea6fc9c3bfb94c7a4143420f02ced",
    "05fa3368f12d189a95a2d6cd8eebc6f7e3a719ee",
    "ef5af4f8de91fbe7891ae3471eb03397e74e1811",
    "0e57aa3bf689374736939300d8f3525ec38bead7",
    "2d8e6e2c4a52a4ba815b23d6d1ac21be4df23d9e",
    "a4c9b80a7c2b30404840f39f2f46646479914345",
    "70b218748badf079c859c3af2b468a0b7b49c333",
    "17d4fbbf0af9b93de9502afb274e91533140d1c6"
  ],
  "changeHistoryShort": {
    "32f867a6a907c05a312657139d295a92756d98ef": "Ybodychange",
    "4cdbdce752e192b45c2b9756c2d4bd24ceffdabd": "Ybodychange",
    "c3793102121767c46091805eae65ef3919a5f368": "Ybodychange",
    "4ec5acc70418a3f2327cf83ecae1789a057fdd99": "Yparameterchange",
    "0202480742b8539aa7aa1e94dc9cab75d863cc4e": "Ybodychange",
    "28bd138018bea6fc9c3bfb94c7a4143420f02ced": "Ybodychange",
    "05fa3368f12d189a95a2d6cd8eebc6f7e3a719ee": "Ybodychange",
    "ef5af4f8de91fbe7891ae3471eb03397e74e1811": "Ybodychange",
    "0e57aa3bf689374736939300d8f3525ec38bead7": "Ybodychange",
    "2d8e6e2c4a52a4ba815b23d6d1ac21be4df23d9e": "Ymultichange(Yparameterchange,Ybodychange)",
    "a4c9b80a7c2b30404840f39f2f46646479914345": "Ymultichange(Ymodifierchange,Ybodychange)",
    "70b218748badf079c859c3af2b468a0b7b49c333": "Ybodychange",
    "17d4fbbf0af9b93de9502afb274e91533140d1c6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "32f867a6a907c05a312657139d295a92756d98ef": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13682. Cannot create encryption zone after KMS auth token expires.\n",
      "commitDate": "20/06/18 3:58 PM",
      "commitName": "32f867a6a907c05a312657139d295a92756d98ef",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "12/05/18 10:19 AM",
      "commitNameOld": "a5449d36312c3de953e05ba8b3b5acf818a0c7e7",
      "commitAuthorOld": "Rushabh Shah",
      "daysBetweenCommits": 39.24,
      "commitsBetweenForRepo": 303,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,63 @@\n   private \u003cT\u003e T call(HttpURLConnection conn, Object jsonOutput,\n       int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n       throws IOException {\n     T ret \u003d null;\n     OutputStream os \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         os \u003d conn.getOutputStream();\n         writeJson(jsonOutput, os);\n       }\n     } catch (IOException ex) {\n       // The payload is not serialized if getOutputStream fails.\n       // Calling getInputStream will issue the put/post request with no payload\n       // which causes HTTP 500 server error.\n       if (os \u003d\u003d null) {\n         conn.disconnect();\n       } else {\n         IOUtils.closeStream(conn.getInputStream());\n       }\n       throw ex;\n     }\n     if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n         \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n             conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n         || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n       // Ideally, this should happen only when there is an Authentication\n       // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n       // cannot authenticate (Since a 401 requires Server to send\n       // WWW-Authenticate header as well)..\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Response\u003d{}({}), resetting authToken\",\n             conn.getResponseCode(), conn.getResponseMessage());\n       }\n       KMSClientProvider.this.authToken \u003d\n           new DelegationTokenAuthenticatedURL.Token();\n       if (authRetryCount \u003e 0) {\n         String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n         String requestMethod \u003d conn.getRequestMethod();\n         URL url \u003d conn.getURL();\n         conn \u003d createConnection(url, requestMethod);\n-        conn.setRequestProperty(CONTENT_TYPE, contentType);\n+        if (contentType !\u003d null \u0026\u0026 !contentType.isEmpty()) {\n+          conn.setRequestProperty(CONTENT_TYPE, contentType);\n+        }\n         return call(conn, jsonOutput, expectedResponse, klass,\n             authRetryCount - 1);\n       }\n     }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (conn.getContentType() !\u003d null\n         \u0026\u0026 conn.getContentType().trim().toLowerCase()\n             .startsWith(APPLICATION_JSON_MIME)\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } finally {\n         IOUtils.closeStream(is);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Object jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n      throws IOException {\n    T ret \u003d null;\n    OutputStream os \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        os \u003d conn.getOutputStream();\n        writeJson(jsonOutput, os);\n      }\n    } catch (IOException ex) {\n      // The payload is not serialized if getOutputStream fails.\n      // Calling getInputStream will issue the put/post request with no payload\n      // which causes HTTP 500 server error.\n      if (os \u003d\u003d null) {\n        conn.disconnect();\n      } else {\n        IOUtils.closeStream(conn.getInputStream());\n      }\n      throw ex;\n    }\n    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n        \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n            conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Response\u003d{}({}), resetting authToken\",\n            conn.getResponseCode(), conn.getResponseMessage());\n      }\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n      if (authRetryCount \u003e 0) {\n        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n        String requestMethod \u003d conn.getRequestMethod();\n        URL url \u003d conn.getURL();\n        conn \u003d createConnection(url, requestMethod);\n        if (contentType !\u003d null \u0026\u0026 !contentType.isEmpty()) {\n          conn.setRequestProperty(CONTENT_TYPE, contentType);\n        }\n        return call(conn, jsonOutput, expectedResponse, klass,\n            authRetryCount - 1);\n      }\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (conn.getContentType() !\u003d null\n        \u0026\u0026 conn.getContentType().trim().toLowerCase()\n            .startsWith(APPLICATION_JSON_MIME)\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } finally {\n        IOUtils.closeStream(is);\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "4cdbdce752e192b45c2b9756c2d4bd24ceffdabd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14841 Kms client should disconnect if unable to get output stream from connection. Contributed by Rushabh S Shah\n",
      "commitDate": "04/05/18 1:36 PM",
      "commitName": "4cdbdce752e192b45c2b9756c2d4bd24ceffdabd",
      "commitAuthor": "Rushabh Shah",
      "commitDateOld": "10/04/18 3:38 PM",
      "commitNameOld": "583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 23.92,
      "commitsBetweenForRepo": 679,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,61 @@\n   private \u003cT\u003e T call(HttpURLConnection conn, Object jsonOutput,\n       int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n       throws IOException {\n     T ret \u003d null;\n+    OutputStream os \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n-        writeJson(jsonOutput, conn.getOutputStream());\n+        os \u003d conn.getOutputStream();\n+        writeJson(jsonOutput, os);\n       }\n     } catch (IOException ex) {\n-      IOUtils.closeStream(conn.getInputStream());\n+      // The payload is not serialized if getOutputStream fails.\n+      // Calling getInputStream will issue the put/post request with no payload\n+      // which causes HTTP 500 server error.\n+      if (os \u003d\u003d null) {\n+        conn.disconnect();\n+      } else {\n+        IOUtils.closeStream(conn.getInputStream());\n+      }\n       throw ex;\n     }\n     if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n         \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n             conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n         || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n       // Ideally, this should happen only when there is an Authentication\n       // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n       // cannot authenticate (Since a 401 requires Server to send\n       // WWW-Authenticate header as well)..\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Response\u003d{}({}), resetting authToken\",\n             conn.getResponseCode(), conn.getResponseMessage());\n       }\n       KMSClientProvider.this.authToken \u003d\n           new DelegationTokenAuthenticatedURL.Token();\n       if (authRetryCount \u003e 0) {\n         String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n         String requestMethod \u003d conn.getRequestMethod();\n         URL url \u003d conn.getURL();\n         conn \u003d createConnection(url, requestMethod);\n         conn.setRequestProperty(CONTENT_TYPE, contentType);\n         return call(conn, jsonOutput, expectedResponse, klass,\n             authRetryCount - 1);\n       }\n     }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (conn.getContentType() !\u003d null\n         \u0026\u0026 conn.getContentType().trim().toLowerCase()\n             .startsWith(APPLICATION_JSON_MIME)\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } finally {\n         IOUtils.closeStream(is);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Object jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n      throws IOException {\n    T ret \u003d null;\n    OutputStream os \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        os \u003d conn.getOutputStream();\n        writeJson(jsonOutput, os);\n      }\n    } catch (IOException ex) {\n      // The payload is not serialized if getOutputStream fails.\n      // Calling getInputStream will issue the put/post request with no payload\n      // which causes HTTP 500 server error.\n      if (os \u003d\u003d null) {\n        conn.disconnect();\n      } else {\n        IOUtils.closeStream(conn.getInputStream());\n      }\n      throw ex;\n    }\n    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n        \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n            conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Response\u003d{}({}), resetting authToken\",\n            conn.getResponseCode(), conn.getResponseMessage());\n      }\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n      if (authRetryCount \u003e 0) {\n        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n        String requestMethod \u003d conn.getRequestMethod();\n        URL url \u003d conn.getURL();\n        conn \u003d createConnection(url, requestMethod);\n        conn.setRequestProperty(CONTENT_TYPE, contentType);\n        return call(conn, jsonOutput, expectedResponse, klass,\n            authRetryCount - 1);\n      }\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (conn.getContentType() !\u003d null\n        \u0026\u0026 conn.getContentType().trim().toLowerCase()\n            .startsWith(APPLICATION_JSON_MIME)\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } finally {\n        IOUtils.closeStream(is);\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "c3793102121767c46091805eae65ef3919a5f368": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14687. AuthenticatedURL will reuse bad/expired session cookies. Contributed by Daryn Sharp\n",
      "commitDate": "22/08/17 2:50 PM",
      "commitName": "c3793102121767c46091805eae65ef3919a5f368",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "22/08/17 7:47 AM",
      "commitNameOld": "4ec5acc70418a3f2327cf83ecae1789a057fdd99",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 0.29,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,52 @@\n   private \u003cT\u003e T call(HttpURLConnection conn, Object jsonOutput,\n       int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n       throws IOException {\n     T ret \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         writeJson(jsonOutput, conn.getOutputStream());\n       }\n     } catch (IOException ex) {\n       IOUtils.closeStream(conn.getInputStream());\n       throw ex;\n     }\n     if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n         \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n             conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n         || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n       // Ideally, this should happen only when there is an Authentication\n       // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n       // cannot authenticate (Since a 401 requires Server to send\n       // WWW-Authenticate header as well)..\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Response\u003d{}({}), resetting authToken\",\n             conn.getResponseCode(), conn.getResponseMessage());\n       }\n       KMSClientProvider.this.authToken \u003d\n           new DelegationTokenAuthenticatedURL.Token();\n       if (authRetryCount \u003e 0) {\n         String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n         String requestMethod \u003d conn.getRequestMethod();\n         URL url \u003d conn.getURL();\n         conn \u003d createConnection(url, requestMethod);\n         conn.setRequestProperty(CONTENT_TYPE, contentType);\n         return call(conn, jsonOutput, expectedResponse, klass,\n             authRetryCount - 1);\n       }\n     }\n-    try {\n-      AuthenticatedURL.extractToken(conn, authToken);\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Extracted token, authToken\u003d{}, its dt\u003d{}\", authToken,\n-            authToken.getDelegationToken());\n-      }\n-    } catch (AuthenticationException e) {\n-      // Ignore the AuthExceptions.. since we are just using the method to\n-      // extract and set the authToken.. (Workaround till we actually fix\n-      // AuthenticatedURL properly to set authToken post initialization)\n-    }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (conn.getContentType() !\u003d null\n         \u0026\u0026 conn.getContentType().trim().toLowerCase()\n             .startsWith(APPLICATION_JSON_MIME)\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } finally {\n         IOUtils.closeStream(is);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Object jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      IOUtils.closeStream(conn.getInputStream());\n      throw ex;\n    }\n    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n        \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n            conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Response\u003d{}({}), resetting authToken\",\n            conn.getResponseCode(), conn.getResponseMessage());\n      }\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n      if (authRetryCount \u003e 0) {\n        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n        String requestMethod \u003d conn.getRequestMethod();\n        URL url \u003d conn.getURL();\n        conn \u003d createConnection(url, requestMethod);\n        conn.setRequestProperty(CONTENT_TYPE, contentType);\n        return call(conn, jsonOutput, expectedResponse, klass,\n            authRetryCount - 1);\n      }\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (conn.getContentType() !\u003d null\n        \u0026\u0026 conn.getContentType().trim().toLowerCase()\n            .startsWith(APPLICATION_JSON_MIME)\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } finally {\n        IOUtils.closeStream(is);\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "4ec5acc70418a3f2327cf83ecae1789a057fdd99": {
      "type": "Yparameterchange",
      "commitMessage": "HADOOP-14705. Add batched interface reencryptEncryptedKeys to KMS.\n",
      "commitDate": "22/08/17 7:47 AM",
      "commitName": "4ec5acc70418a3f2327cf83ecae1789a057fdd99",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "14/07/17 10:22 PM",
      "commitNameOld": "0a6d5c0cf1d963da9131aa12326fc576f0e92d2c",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 38.39,
      "commitsBetweenForRepo": 268,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n-  private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n+  private \u003cT\u003e T call(HttpURLConnection conn, Object jsonOutput,\n       int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n       throws IOException {\n     T ret \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         writeJson(jsonOutput, conn.getOutputStream());\n       }\n     } catch (IOException ex) {\n       IOUtils.closeStream(conn.getInputStream());\n       throw ex;\n     }\n     if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n         \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n             conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n         || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n       // Ideally, this should happen only when there is an Authentication\n       // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n       // cannot authenticate (Since a 401 requires Server to send\n       // WWW-Authenticate header as well)..\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Response\u003d{}({}), resetting authToken\",\n             conn.getResponseCode(), conn.getResponseMessage());\n       }\n       KMSClientProvider.this.authToken \u003d\n           new DelegationTokenAuthenticatedURL.Token();\n       if (authRetryCount \u003e 0) {\n         String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n         String requestMethod \u003d conn.getRequestMethod();\n         URL url \u003d conn.getURL();\n         conn \u003d createConnection(url, requestMethod);\n         conn.setRequestProperty(CONTENT_TYPE, contentType);\n         return call(conn, jsonOutput, expectedResponse, klass,\n             authRetryCount - 1);\n       }\n     }\n     try {\n       AuthenticatedURL.extractToken(conn, authToken);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Extracted token, authToken\u003d{}, its dt\u003d{}\", authToken,\n             authToken.getDelegationToken());\n       }\n     } catch (AuthenticationException e) {\n       // Ignore the AuthExceptions.. since we are just using the method to\n       // extract and set the authToken.. (Workaround till we actually fix\n       // AuthenticatedURL properly to set authToken post initialization)\n     }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (conn.getContentType() !\u003d null\n         \u0026\u0026 conn.getContentType().trim().toLowerCase()\n             .startsWith(APPLICATION_JSON_MIME)\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } finally {\n         IOUtils.closeStream(is);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Object jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      IOUtils.closeStream(conn.getInputStream());\n      throw ex;\n    }\n    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n        \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n            conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Response\u003d{}({}), resetting authToken\",\n            conn.getResponseCode(), conn.getResponseMessage());\n      }\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n      if (authRetryCount \u003e 0) {\n        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n        String requestMethod \u003d conn.getRequestMethod();\n        URL url \u003d conn.getURL();\n        conn \u003d createConnection(url, requestMethod);\n        conn.setRequestProperty(CONTENT_TYPE, contentType);\n        return call(conn, jsonOutput, expectedResponse, klass,\n            authRetryCount - 1);\n      }\n    }\n    try {\n      AuthenticatedURL.extractToken(conn, authToken);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Extracted token, authToken\u003d{}, its dt\u003d{}\", authToken,\n            authToken.getDelegationToken());\n      }\n    } catch (AuthenticationException e) {\n      // Ignore the AuthExceptions.. since we are just using the method to\n      // extract and set the authToken.. (Workaround till we actually fix\n      // AuthenticatedURL properly to set authToken post initialization)\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (conn.getContentType() !\u003d null\n        \u0026\u0026 conn.getContentType().trim().toLowerCase()\n            .startsWith(APPLICATION_JSON_MIME)\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } finally {\n        IOUtils.closeStream(is);\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {
        "oldValue": "[conn-HttpURLConnection, jsonOutput-Map, expectedResponse-int, klass-Class\u003cT\u003e, authRetryCount-int]",
        "newValue": "[conn-HttpURLConnection, jsonOutput-Object, expectedResponse-int, klass-Class\u003cT\u003e, authRetryCount-int]"
      }
    },
    "0202480742b8539aa7aa1e94dc9cab75d863cc4e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13174. Add more debug logs for delegation tokens and authentication.\n",
      "commitDate": "08/06/17 9:34 PM",
      "commitName": "0202480742b8539aa7aa1e94dc9cab75d863cc4e",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "07/02/17 8:36 PM",
      "commitNameOld": "2007e0cf2ad371e2dbf533c367f09c1f5acd1c0b",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 121.0,
      "commitsBetweenForRepo": 685,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,63 @@\n   private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n       int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n       throws IOException {\n     T ret \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         writeJson(jsonOutput, conn.getOutputStream());\n       }\n     } catch (IOException ex) {\n       IOUtils.closeStream(conn.getInputStream());\n       throw ex;\n     }\n     if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n         \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n             conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n         || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n       // Ideally, this should happen only when there is an Authentication\n       // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n       // cannot authenticate (Since a 401 requires Server to send\n       // WWW-Authenticate header as well)..\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Response\u003d{}({}), resetting authToken\",\n+            conn.getResponseCode(), conn.getResponseMessage());\n+      }\n       KMSClientProvider.this.authToken \u003d\n           new DelegationTokenAuthenticatedURL.Token();\n       if (authRetryCount \u003e 0) {\n         String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n         String requestMethod \u003d conn.getRequestMethod();\n         URL url \u003d conn.getURL();\n         conn \u003d createConnection(url, requestMethod);\n         conn.setRequestProperty(CONTENT_TYPE, contentType);\n         return call(conn, jsonOutput, expectedResponse, klass,\n             authRetryCount - 1);\n       }\n     }\n     try {\n       AuthenticatedURL.extractToken(conn, authToken);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Extracted token, authToken\u003d{}, its dt\u003d{}\", authToken,\n+            authToken.getDelegationToken());\n+      }\n     } catch (AuthenticationException e) {\n       // Ignore the AuthExceptions.. since we are just using the method to\n       // extract and set the authToken.. (Workaround till we actually fix\n       // AuthenticatedURL properly to set authToken post initialization)\n     }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (conn.getContentType() !\u003d null\n         \u0026\u0026 conn.getContentType().trim().toLowerCase()\n             .startsWith(APPLICATION_JSON_MIME)\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } finally {\n         IOUtils.closeStream(is);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      IOUtils.closeStream(conn.getInputStream());\n      throw ex;\n    }\n    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n        \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n            conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Response\u003d{}({}), resetting authToken\",\n            conn.getResponseCode(), conn.getResponseMessage());\n      }\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n      if (authRetryCount \u003e 0) {\n        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n        String requestMethod \u003d conn.getRequestMethod();\n        URL url \u003d conn.getURL();\n        conn \u003d createConnection(url, requestMethod);\n        conn.setRequestProperty(CONTENT_TYPE, contentType);\n        return call(conn, jsonOutput, expectedResponse, klass,\n            authRetryCount - 1);\n      }\n    }\n    try {\n      AuthenticatedURL.extractToken(conn, authToken);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Extracted token, authToken\u003d{}, its dt\u003d{}\", authToken,\n            authToken.getDelegationToken());\n      }\n    } catch (AuthenticationException e) {\n      // Ignore the AuthExceptions.. since we are just using the method to\n      // extract and set the authToken.. (Workaround till we actually fix\n      // AuthenticatedURL properly to set authToken post initialization)\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (conn.getContentType() !\u003d null\n        \u0026\u0026 conn.getContentType().trim().toLowerCase()\n            .startsWith(APPLICATION_JSON_MIME)\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } finally {\n        IOUtils.closeStream(is);\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "28bd138018bea6fc9c3bfb94c7a4143420f02ced": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12604. Exception may be swallowed in KMSClientProvider. (Yongjun Zhang)\n",
      "commitDate": "05/01/16 11:09 AM",
      "commitName": "28bd138018bea6fc9c3bfb94c7a4143420f02ced",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "28/12/15 10:41 AM",
      "commitNameOld": "993311e547e6dd7757025d5ffc285019bd4fc1f6",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 8.02,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,55 @@\n   private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n       int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n       throws IOException {\n     T ret \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         writeJson(jsonOutput, conn.getOutputStream());\n       }\n     } catch (IOException ex) {\n-      conn.getInputStream().close();\n+      IOUtils.closeStream(conn.getInputStream());\n       throw ex;\n     }\n     if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n         \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n             conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n         || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n       // Ideally, this should happen only when there is an Authentication\n       // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n       // cannot authenticate (Since a 401 requires Server to send\n       // WWW-Authenticate header as well)..\n       KMSClientProvider.this.authToken \u003d\n           new DelegationTokenAuthenticatedURL.Token();\n       if (authRetryCount \u003e 0) {\n         String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n         String requestMethod \u003d conn.getRequestMethod();\n         URL url \u003d conn.getURL();\n         conn \u003d createConnection(url, requestMethod);\n         conn.setRequestProperty(CONTENT_TYPE, contentType);\n         return call(conn, jsonOutput, expectedResponse, klass,\n             authRetryCount - 1);\n       }\n     }\n     try {\n       AuthenticatedURL.extractToken(conn, authToken);\n     } catch (AuthenticationException e) {\n       // Ignore the AuthExceptions.. since we are just using the method to\n       // extract and set the authToken.. (Workaround till we actually fix\n       // AuthenticatedURL properly to set authToken post initialization)\n     }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (conn.getContentType() !\u003d null\n         \u0026\u0026 conn.getContentType().trim().toLowerCase()\n             .startsWith(APPLICATION_JSON_MIME)\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n-      } catch (IOException ex) {\n-        if (is !\u003d null) {\n-          is.close();\n-        }\n-        throw ex;\n       } finally {\n-        if (is !\u003d null) {\n-          is.close();\n-        }\n+        IOUtils.closeStream(is);\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      IOUtils.closeStream(conn.getInputStream());\n      throw ex;\n    }\n    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n        \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n            conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n      if (authRetryCount \u003e 0) {\n        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n        String requestMethod \u003d conn.getRequestMethod();\n        URL url \u003d conn.getURL();\n        conn \u003d createConnection(url, requestMethod);\n        conn.setRequestProperty(CONTENT_TYPE, contentType);\n        return call(conn, jsonOutput, expectedResponse, klass,\n            authRetryCount - 1);\n      }\n    }\n    try {\n      AuthenticatedURL.extractToken(conn, authToken);\n    } catch (AuthenticationException e) {\n      // Ignore the AuthExceptions.. since we are just using the method to\n      // extract and set the authToken.. (Workaround till we actually fix\n      // AuthenticatedURL properly to set authToken post initialization)\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (conn.getContentType() !\u003d null\n        \u0026\u0026 conn.getContentType().trim().toLowerCase()\n            .startsWith(APPLICATION_JSON_MIME)\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } finally {\n        IOUtils.closeStream(is);\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "05fa3368f12d189a95a2d6cd8eebc6f7e3a719ee": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12088. KMSClientProvider uses equalsIgnoreCase(\"application/json\").   (Brahma Reddy Battula via stevel)\n",
      "commitDate": "20/07/15 5:03 AM",
      "commitName": "05fa3368f12d189a95a2d6cd8eebc6f7e3a719ee",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "25/02/15 9:16 PM",
      "commitNameOld": "71385f9b70e22618db3f3d2b2c6dca3b1e82c317",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 144.28,
      "commitsBetweenForRepo": 1196,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,62 @@\n   private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n       int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n       throws IOException {\n     T ret \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         writeJson(jsonOutput, conn.getOutputStream());\n       }\n     } catch (IOException ex) {\n       conn.getInputStream().close();\n       throw ex;\n     }\n     if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n         \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n             conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n         || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n       // Ideally, this should happen only when there is an Authentication\n       // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n       // cannot authenticate (Since a 401 requires Server to send\n       // WWW-Authenticate header as well)..\n       KMSClientProvider.this.authToken \u003d\n           new DelegationTokenAuthenticatedURL.Token();\n       if (authRetryCount \u003e 0) {\n         String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n         String requestMethod \u003d conn.getRequestMethod();\n         URL url \u003d conn.getURL();\n         conn \u003d createConnection(url, requestMethod);\n         conn.setRequestProperty(CONTENT_TYPE, contentType);\n         return call(conn, jsonOutput, expectedResponse, klass,\n             authRetryCount - 1);\n       }\n     }\n     try {\n       AuthenticatedURL.extractToken(conn, authToken);\n     } catch (AuthenticationException e) {\n       // Ignore the AuthExceptions.. since we are just using the method to\n       // extract and set the authToken.. (Workaround till we actually fix\n       // AuthenticatedURL properly to set authToken post initialization)\n     }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n-    if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n+    if (conn.getContentType() !\u003d null\n+        \u0026\u0026 conn.getContentType().trim().toLowerCase()\n+            .startsWith(APPLICATION_JSON_MIME)\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } catch (IOException ex) {\n         if (is !\u003d null) {\n           is.close();\n         }\n         throw ex;\n       } finally {\n         if (is !\u003d null) {\n           is.close();\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      conn.getInputStream().close();\n      throw ex;\n    }\n    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n        \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n            conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n      if (authRetryCount \u003e 0) {\n        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n        String requestMethod \u003d conn.getRequestMethod();\n        URL url \u003d conn.getURL();\n        conn \u003d createConnection(url, requestMethod);\n        conn.setRequestProperty(CONTENT_TYPE, contentType);\n        return call(conn, jsonOutput, expectedResponse, klass,\n            authRetryCount - 1);\n      }\n    }\n    try {\n      AuthenticatedURL.extractToken(conn, authToken);\n    } catch (AuthenticationException e) {\n      // Ignore the AuthExceptions.. since we are just using the method to\n      // extract and set the authToken.. (Workaround till we actually fix\n      // AuthenticatedURL properly to set authToken post initialization)\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (conn.getContentType() !\u003d null\n        \u0026\u0026 conn.getContentType().trim().toLowerCase()\n            .startsWith(APPLICATION_JSON_MIME)\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } catch (IOException ex) {\n        if (is !\u003d null) {\n          is.close();\n        }\n        throw ex;\n      } finally {\n        if (is !\u003d null) {\n          is.close();\n        }\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "ef5af4f8de91fbe7891ae3471eb03397e74e1811": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11187 NameNode - KMS communication fails after a long period of inactivity. Contributed by Arun Suresh.\n",
      "commitDate": "05/11/14 6:17 PM",
      "commitName": "ef5af4f8de91fbe7891ae3471eb03397e74e1811",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "13/10/14 6:09 PM",
      "commitNameOld": "0e57aa3bf689374736939300d8f3525ec38bead7",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 23.05,
      "commitsBetweenForRepo": 224,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,60 @@\n   private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n       int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n       throws IOException {\n     T ret \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         writeJson(jsonOutput, conn.getOutputStream());\n       }\n     } catch (IOException ex) {\n       conn.getInputStream().close();\n       throw ex;\n     }\n     if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n-        \u0026\u0026 conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED))\n+        \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n+            conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n         || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n       // Ideally, this should happen only when there is an Authentication\n       // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n       // cannot authenticate (Since a 401 requires Server to send\n       // WWW-Authenticate header as well)..\n       KMSClientProvider.this.authToken \u003d\n           new DelegationTokenAuthenticatedURL.Token();\n       if (authRetryCount \u003e 0) {\n         String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n         String requestMethod \u003d conn.getRequestMethod();\n         URL url \u003d conn.getURL();\n         conn \u003d createConnection(url, requestMethod);\n         conn.setRequestProperty(CONTENT_TYPE, contentType);\n         return call(conn, jsonOutput, expectedResponse, klass,\n             authRetryCount - 1);\n       }\n     }\n     try {\n       AuthenticatedURL.extractToken(conn, authToken);\n     } catch (AuthenticationException e) {\n       // Ignore the AuthExceptions.. since we are just using the method to\n       // extract and set the authToken.. (Workaround till we actually fix\n       // AuthenticatedURL properly to set authToken post initialization)\n     }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } catch (IOException ex) {\n         if (is !\u003d null) {\n           is.close();\n         }\n         throw ex;\n       } finally {\n         if (is !\u003d null) {\n           is.close();\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      conn.getInputStream().close();\n      throw ex;\n    }\n    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n        \u0026\u0026 (conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED) ||\n            conn.getResponseMessage().contains(INVALID_SIGNATURE)))\n        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n      if (authRetryCount \u003e 0) {\n        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n        String requestMethod \u003d conn.getRequestMethod();\n        URL url \u003d conn.getURL();\n        conn \u003d createConnection(url, requestMethod);\n        conn.setRequestProperty(CONTENT_TYPE, contentType);\n        return call(conn, jsonOutput, expectedResponse, klass,\n            authRetryCount - 1);\n      }\n    }\n    try {\n      AuthenticatedURL.extractToken(conn, authToken);\n    } catch (AuthenticationException e) {\n      // Ignore the AuthExceptions.. since we are just using the method to\n      // extract and set the authToken.. (Workaround till we actually fix\n      // AuthenticatedURL properly to set authToken post initialization)\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } catch (IOException ex) {\n        if (is !\u003d null) {\n          is.close();\n        }\n        throw ex;\n      } finally {\n        if (is !\u003d null) {\n          is.close();\n        }\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "0e57aa3bf689374736939300d8f3525ec38bead7": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11176. KMSClientProvider authentication fails when both currentUgi and loginUgi are a proxied user. Contributed by Arun Suresh.\n",
      "commitDate": "13/10/14 6:09 PM",
      "commitName": "0e57aa3bf689374736939300d8f3525ec38bead7",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "10/10/14 1:40 PM",
      "commitNameOld": "d3d3d47202a18749eeebec22db759c19dd3e232c",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 3.19,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,59 @@\n   private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n       int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n       throws IOException {\n     T ret \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         writeJson(jsonOutput, conn.getOutputStream());\n       }\n     } catch (IOException ex) {\n       conn.getInputStream().close();\n       throw ex;\n     }\n     if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n         \u0026\u0026 conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED))\n         || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n       // Ideally, this should happen only when there is an Authentication\n       // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n       // cannot authenticate (Since a 401 requires Server to send\n       // WWW-Authenticate header as well)..\n       KMSClientProvider.this.authToken \u003d\n           new DelegationTokenAuthenticatedURL.Token();\n-      KMSClientProvider.this.loginUgi \u003d\n-          UserGroupInformation.getCurrentUser();\n       if (authRetryCount \u003e 0) {\n         String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n         String requestMethod \u003d conn.getRequestMethod();\n         URL url \u003d conn.getURL();\n         conn \u003d createConnection(url, requestMethod);\n         conn.setRequestProperty(CONTENT_TYPE, contentType);\n         return call(conn, jsonOutput, expectedResponse, klass,\n             authRetryCount - 1);\n       }\n     }\n     try {\n       AuthenticatedURL.extractToken(conn, authToken);\n     } catch (AuthenticationException e) {\n       // Ignore the AuthExceptions.. since we are just using the method to\n       // extract and set the authToken.. (Workaround till we actually fix\n       // AuthenticatedURL properly to set authToken post initialization)\n-    } finally {\n-      KMSClientProvider.this.loginUgi \u003d\n-          UserGroupInformation.getCurrentUser();\n     }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } catch (IOException ex) {\n         if (is !\u003d null) {\n           is.close();\n         }\n         throw ex;\n       } finally {\n         if (is !\u003d null) {\n           is.close();\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      conn.getInputStream().close();\n      throw ex;\n    }\n    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n        \u0026\u0026 conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED))\n        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n      if (authRetryCount \u003e 0) {\n        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n        String requestMethod \u003d conn.getRequestMethod();\n        URL url \u003d conn.getURL();\n        conn \u003d createConnection(url, requestMethod);\n        conn.setRequestProperty(CONTENT_TYPE, contentType);\n        return call(conn, jsonOutput, expectedResponse, klass,\n            authRetryCount - 1);\n      }\n    }\n    try {\n      AuthenticatedURL.extractToken(conn, authToken);\n    } catch (AuthenticationException e) {\n      // Ignore the AuthExceptions.. since we are just using the method to\n      // extract and set the authToken.. (Workaround till we actually fix\n      // AuthenticatedURL properly to set authToken post initialization)\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } catch (IOException ex) {\n        if (is !\u003d null) {\n          is.close();\n        }\n        throw ex;\n      } finally {\n        if (is !\u003d null) {\n          is.close();\n        }\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "2d8e6e2c4a52a4ba815b23d6d1ac21be4df23d9e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-11151. Automatically refresh auth token and retry on auth failure. Contributed by Arun Suresh.\n",
      "commitDate": "02/10/14 7:54 PM",
      "commitName": "2d8e6e2c4a52a4ba815b23d6d1ac21be4df23d9e",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-11151. Automatically refresh auth token and retry on auth failure. Contributed by Arun Suresh.\n",
          "commitDate": "02/10/14 7:54 PM",
          "commitName": "2d8e6e2c4a52a4ba815b23d6d1ac21be4df23d9e",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "30/09/14 4:48 PM",
          "commitNameOld": "a4c9b80a7c2b30404840f39f2f46646479914345",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.13,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,64 @@\n   private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n-      int expectedResponse, Class\u003cT\u003e klass)\n+      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n       throws IOException {\n     T ret \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         writeJson(jsonOutput, conn.getOutputStream());\n       }\n     } catch (IOException ex) {\n       conn.getInputStream().close();\n       throw ex;\n     }\n-    if (conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN) {\n+    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n+        \u0026\u0026 conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED))\n+        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n       // Ideally, this should happen only when there is an Authentication\n       // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n       // cannot authenticate (Since a 401 requires Server to send\n       // WWW-Authenticate header as well)..\n       KMSClientProvider.this.authToken \u003d\n           new DelegationTokenAuthenticatedURL.Token();\n+      KMSClientProvider.this.loginUgi \u003d\n+          UserGroupInformation.getCurrentUser();\n+      if (authRetryCount \u003e 0) {\n+        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n+        String requestMethod \u003d conn.getRequestMethod();\n+        URL url \u003d conn.getURL();\n+        conn \u003d createConnection(url, requestMethod);\n+        conn.setRequestProperty(CONTENT_TYPE, contentType);\n+        return call(conn, jsonOutput, expectedResponse, klass,\n+            authRetryCount - 1);\n+      }\n+    }\n+    try {\n+      AuthenticatedURL.extractToken(conn, authToken);\n+    } catch (AuthenticationException e) {\n+      // Ignore the AuthExceptions.. since we are just using the method to\n+      // extract and set the authToken.. (Workaround till we actually fix\n+      // AuthenticatedURL properly to set authToken post initialization)\n+    } finally {\n+      KMSClientProvider.this.loginUgi \u003d\n+          UserGroupInformation.getCurrentUser();\n     }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } catch (IOException ex) {\n         if (is !\u003d null) {\n           is.close();\n         }\n         throw ex;\n       } finally {\n         if (is !\u003d null) {\n           is.close();\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      conn.getInputStream().close();\n      throw ex;\n    }\n    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n        \u0026\u0026 conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED))\n        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n      KMSClientProvider.this.loginUgi \u003d\n          UserGroupInformation.getCurrentUser();\n      if (authRetryCount \u003e 0) {\n        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n        String requestMethod \u003d conn.getRequestMethod();\n        URL url \u003d conn.getURL();\n        conn \u003d createConnection(url, requestMethod);\n        conn.setRequestProperty(CONTENT_TYPE, contentType);\n        return call(conn, jsonOutput, expectedResponse, klass,\n            authRetryCount - 1);\n      }\n    }\n    try {\n      AuthenticatedURL.extractToken(conn, authToken);\n    } catch (AuthenticationException e) {\n      // Ignore the AuthExceptions.. since we are just using the method to\n      // extract and set the authToken.. (Workaround till we actually fix\n      // AuthenticatedURL properly to set authToken post initialization)\n    } finally {\n      KMSClientProvider.this.loginUgi \u003d\n          UserGroupInformation.getCurrentUser();\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } catch (IOException ex) {\n        if (is !\u003d null) {\n          is.close();\n        }\n        throw ex;\n      } finally {\n        if (is !\u003d null) {\n          is.close();\n        }\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
          "extendedDetails": {
            "oldValue": "[conn-HttpURLConnection, jsonOutput-Map, expectedResponse-int, klass-Class\u003cT\u003e]",
            "newValue": "[conn-HttpURLConnection, jsonOutput-Map, expectedResponse-int, klass-Class\u003cT\u003e, authRetryCount-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-11151. Automatically refresh auth token and retry on auth failure. Contributed by Arun Suresh.\n",
          "commitDate": "02/10/14 7:54 PM",
          "commitName": "2d8e6e2c4a52a4ba815b23d6d1ac21be4df23d9e",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "30/09/14 4:48 PM",
          "commitNameOld": "a4c9b80a7c2b30404840f39f2f46646479914345",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 2.13,
          "commitsBetweenForRepo": 29,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,41 +1,64 @@\n   private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n-      int expectedResponse, Class\u003cT\u003e klass)\n+      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n       throws IOException {\n     T ret \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         writeJson(jsonOutput, conn.getOutputStream());\n       }\n     } catch (IOException ex) {\n       conn.getInputStream().close();\n       throw ex;\n     }\n-    if (conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN) {\n+    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n+        \u0026\u0026 conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED))\n+        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n       // Ideally, this should happen only when there is an Authentication\n       // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n       // cannot authenticate (Since a 401 requires Server to send\n       // WWW-Authenticate header as well)..\n       KMSClientProvider.this.authToken \u003d\n           new DelegationTokenAuthenticatedURL.Token();\n+      KMSClientProvider.this.loginUgi \u003d\n+          UserGroupInformation.getCurrentUser();\n+      if (authRetryCount \u003e 0) {\n+        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n+        String requestMethod \u003d conn.getRequestMethod();\n+        URL url \u003d conn.getURL();\n+        conn \u003d createConnection(url, requestMethod);\n+        conn.setRequestProperty(CONTENT_TYPE, contentType);\n+        return call(conn, jsonOutput, expectedResponse, klass,\n+            authRetryCount - 1);\n+      }\n+    }\n+    try {\n+      AuthenticatedURL.extractToken(conn, authToken);\n+    } catch (AuthenticationException e) {\n+      // Ignore the AuthExceptions.. since we are just using the method to\n+      // extract and set the authToken.. (Workaround till we actually fix\n+      // AuthenticatedURL properly to set authToken post initialization)\n+    } finally {\n+      KMSClientProvider.this.loginUgi \u003d\n+          UserGroupInformation.getCurrentUser();\n     }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } catch (IOException ex) {\n         if (is !\u003d null) {\n           is.close();\n         }\n         throw ex;\n       } finally {\n         if (is !\u003d null) {\n           is.close();\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass, int authRetryCount)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      conn.getInputStream().close();\n      throw ex;\n    }\n    if ((conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN\n        \u0026\u0026 conn.getResponseMessage().equals(ANONYMOUS_REQUESTS_DISALLOWED))\n        || conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_UNAUTHORIZED) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n      KMSClientProvider.this.loginUgi \u003d\n          UserGroupInformation.getCurrentUser();\n      if (authRetryCount \u003e 0) {\n        String contentType \u003d conn.getRequestProperty(CONTENT_TYPE);\n        String requestMethod \u003d conn.getRequestMethod();\n        URL url \u003d conn.getURL();\n        conn \u003d createConnection(url, requestMethod);\n        conn.setRequestProperty(CONTENT_TYPE, contentType);\n        return call(conn, jsonOutput, expectedResponse, klass,\n            authRetryCount - 1);\n      }\n    }\n    try {\n      AuthenticatedURL.extractToken(conn, authToken);\n    } catch (AuthenticationException e) {\n      // Ignore the AuthExceptions.. since we are just using the method to\n      // extract and set the authToken.. (Workaround till we actually fix\n      // AuthenticatedURL properly to set authToken post initialization)\n    } finally {\n      KMSClientProvider.this.loginUgi \u003d\n          UserGroupInformation.getCurrentUser();\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } catch (IOException ex) {\n        if (is !\u003d null) {\n          is.close();\n        }\n        throw ex;\n      } finally {\n        if (is !\u003d null) {\n          is.close();\n        }\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
          "extendedDetails": {}
        }
      ]
    },
    "a4c9b80a7c2b30404840f39f2f46646479914345": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HADOOP-11113. Namenode not able to reconnect to KMS after KMS restart. (Arun Suresh via wang)\n",
      "commitDate": "30/09/14 4:48 PM",
      "commitName": "a4c9b80a7c2b30404840f39f2f46646479914345",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HADOOP-11113. Namenode not able to reconnect to KMS after KMS restart. (Arun Suresh via wang)\n",
          "commitDate": "30/09/14 4:48 PM",
          "commitName": "a4c9b80a7c2b30404840f39f2f46646479914345",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "18/09/14 4:03 PM",
          "commitNameOld": "fad4cd85b313a1d2378adcf03cad67e946a12cd5",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 12.03,
          "commitsBetweenForRepo": 124,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,41 @@\n-  private static \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n+  private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n       int expectedResponse, Class\u003cT\u003e klass)\n       throws IOException {\n     T ret \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         writeJson(jsonOutput, conn.getOutputStream());\n       }\n     } catch (IOException ex) {\n       conn.getInputStream().close();\n       throw ex;\n     }\n+    if (conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN) {\n+      // Ideally, this should happen only when there is an Authentication\n+      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n+      // cannot authenticate (Since a 401 requires Server to send\n+      // WWW-Authenticate header as well)..\n+      KMSClientProvider.this.authToken \u003d\n+          new DelegationTokenAuthenticatedURL.Token();\n+    }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } catch (IOException ex) {\n         if (is !\u003d null) {\n           is.close();\n         }\n         throw ex;\n       } finally {\n         if (is !\u003d null) {\n           is.close();\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      conn.getInputStream().close();\n      throw ex;\n    }\n    if (conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } catch (IOException ex) {\n        if (is !\u003d null) {\n          is.close();\n        }\n        throw ex;\n      } finally {\n        if (is !\u003d null) {\n          is.close();\n        }\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
          "extendedDetails": {
            "oldValue": "[private, static]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-11113. Namenode not able to reconnect to KMS after KMS restart. (Arun Suresh via wang)\n",
          "commitDate": "30/09/14 4:48 PM",
          "commitName": "a4c9b80a7c2b30404840f39f2f46646479914345",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "18/09/14 4:03 PM",
          "commitNameOld": "fad4cd85b313a1d2378adcf03cad67e946a12cd5",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 12.03,
          "commitsBetweenForRepo": 124,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,41 @@\n-  private static \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n+  private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n       int expectedResponse, Class\u003cT\u003e klass)\n       throws IOException {\n     T ret \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         writeJson(jsonOutput, conn.getOutputStream());\n       }\n     } catch (IOException ex) {\n       conn.getInputStream().close();\n       throw ex;\n     }\n+    if (conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN) {\n+      // Ideally, this should happen only when there is an Authentication\n+      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n+      // cannot authenticate (Since a 401 requires Server to send\n+      // WWW-Authenticate header as well)..\n+      KMSClientProvider.this.authToken \u003d\n+          new DelegationTokenAuthenticatedURL.Token();\n+    }\n     HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } catch (IOException ex) {\n         if (is !\u003d null) {\n           is.close();\n         }\n         throw ex;\n       } finally {\n         if (is !\u003d null) {\n           is.close();\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      conn.getInputStream().close();\n      throw ex;\n    }\n    if (conn.getResponseCode() \u003d\u003d HttpURLConnection.HTTP_FORBIDDEN) {\n      // Ideally, this should happen only when there is an Authentication\n      // failure. Unfortunately, the AuthenticationFilter returns 403 when it\n      // cannot authenticate (Since a 401 requires Server to send\n      // WWW-Authenticate header as well)..\n      KMSClientProvider.this.authToken \u003d\n          new DelegationTokenAuthenticatedURL.Token();\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } catch (IOException ex) {\n        if (is !\u003d null) {\n          is.close();\n        }\n        throw ex;\n      } finally {\n        if (is !\u003d null) {\n          is.close();\n        }\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
          "extendedDetails": {}
        }
      ]
    },
    "70b218748badf079c859c3af2b468a0b7b49c333": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11015. Http server/client utils to propagate and recreate Exceptions from server to client. (tucu)\n",
      "commitDate": "04/09/14 9:11 AM",
      "commitName": "70b218748badf079c859c3af2b468a0b7b49c333",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "29/08/14 2:21 PM",
      "commitNameOld": "c60da4d3b31e5fa0c4b27cf75ab7ed4add56396a",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 5.78,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   private static \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n       int expectedResponse, Class\u003cT\u003e klass)\n       throws IOException {\n     T ret \u003d null;\n     try {\n       if (jsonOutput !\u003d null) {\n         writeJson(jsonOutput, conn.getOutputStream());\n       }\n     } catch (IOException ex) {\n       conn.getInputStream().close();\n       throw ex;\n     }\n-    validateResponse(conn, expectedResponse);\n+    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n     if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n         \u0026\u0026 klass !\u003d null) {\n       ObjectMapper mapper \u003d new ObjectMapper();\n       InputStream is \u003d null;\n       try {\n         is \u003d conn.getInputStream();\n         ret \u003d mapper.readValue(is, klass);\n       } catch (IOException ex) {\n         if (is !\u003d null) {\n           is.close();\n         }\n         throw ex;\n       } finally {\n         if (is !\u003d null) {\n           is.close();\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      conn.getInputStream().close();\n      throw ex;\n    }\n    HttpExceptionUtils.validateResponse(conn, expectedResponse);\n    if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } catch (IOException ex) {\n        if (is !\u003d null) {\n          is.close();\n        }\n        throw ex;\n      } finally {\n        if (is !\u003d null) {\n          is.close();\n        }\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "17d4fbbf0af9b93de9502afb274e91533140d1c6": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10433. Key Management Server based on KeyProvider API. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1592637 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/05/14 2:43 PM",
      "commitName": "17d4fbbf0af9b93de9502afb274e91533140d1c6",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,33 @@\n+  private static \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n+      int expectedResponse, Class\u003cT\u003e klass)\n+      throws IOException {\n+    T ret \u003d null;\n+    try {\n+      if (jsonOutput !\u003d null) {\n+        writeJson(jsonOutput, conn.getOutputStream());\n+      }\n+    } catch (IOException ex) {\n+      conn.getInputStream().close();\n+      throw ex;\n+    }\n+    validateResponse(conn, expectedResponse);\n+    if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n+        \u0026\u0026 klass !\u003d null) {\n+      ObjectMapper mapper \u003d new ObjectMapper();\n+      InputStream is \u003d null;\n+      try {\n+        is \u003d conn.getInputStream();\n+        ret \u003d mapper.readValue(is, klass);\n+      } catch (IOException ex) {\n+        if (is !\u003d null) {\n+          is.close();\n+        }\n+        throw ex;\n+      } finally {\n+        if (is !\u003d null) {\n+          is.close();\n+        }\n+      }\n+    }\n+    return ret;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static \u003cT\u003e T call(HttpURLConnection conn, Map jsonOutput,\n      int expectedResponse, Class\u003cT\u003e klass)\n      throws IOException {\n    T ret \u003d null;\n    try {\n      if (jsonOutput !\u003d null) {\n        writeJson(jsonOutput, conn.getOutputStream());\n      }\n    } catch (IOException ex) {\n      conn.getInputStream().close();\n      throw ex;\n    }\n    validateResponse(conn, expectedResponse);\n    if (APPLICATION_JSON_MIME.equalsIgnoreCase(conn.getContentType())\n        \u0026\u0026 klass !\u003d null) {\n      ObjectMapper mapper \u003d new ObjectMapper();\n      InputStream is \u003d null;\n      try {\n        is \u003d conn.getInputStream();\n        ret \u003d mapper.readValue(is, klass);\n      } catch (IOException ex) {\n        if (is !\u003d null) {\n          is.close();\n        }\n        throw ex;\n      } finally {\n        if (is !\u003d null) {\n          is.close();\n        }\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java"
    }
  }
}