{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Shell.java",
  "functionName": "runCommand",
  "functionId": "runCommand",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
  "functionStartLine": 905,
  "functionEndLine": 1038,
  "numCommitsSeen": 65,
  "timeTaken": 6001,
  "changeHistory": [
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
    "f494f0b8968a61bf3aa32b7ca0851b8c744aa70f",
    "e8694deb6ad180449f8ce6c1c8b4f84873c0587a",
    "9e19f758c1950cbcfcd1969461a8a910efca0767",
    "631f1daee3507a1adbc68b937cca31c27dbe8d3d",
    "169bfc09037595610eb000fd3a0cb63cc9deca06",
    "9947aeb60c3dd075544866fd6e4dab0ad8b4afa2",
    "9d4d30243b0fc9630da51a2c17b543ef671d035c",
    "c59af2fdf8f7f53117c626a895dab7fd78cf08ec",
    "95c73d49b1bb459b626a9ac52acadb8f5fa724de",
    "5b9fcedb4d116d91d70aaad6cbf59093eeee36df",
    "8e9502e05d09e31b76fda7cc6691e78a39db8de6",
    "4b2834898cbcc66ffbf01b2fb10375e79a50d538",
    "1758f3146ae582493ca02be9babfaf24fb612613",
    "5421725907267d88609442c220aed3f32ccf6ad1",
    "4ba7a5e5642af2db82d8ab0af8ae65758297c1ad",
    "fdba5fac263f9bf79fccf566c36bbc42ef67e875",
    "638801cce16fc1dc3259c541dc30a599faaddda1",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "c60feead5eb3d2de111ac97bdc9f1a95cfbc5263",
    "b089f4448db4196d32ccf8561ed682d42c6b45ba",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd": "Ybodychange",
    "f494f0b8968a61bf3aa32b7ca0851b8c744aa70f": "Ybodychange",
    "e8694deb6ad180449f8ce6c1c8b4f84873c0587a": "Ybodychange",
    "9e19f758c1950cbcfcd1969461a8a910efca0767": "Ybodychange",
    "631f1daee3507a1adbc68b937cca31c27dbe8d3d": "Ybodychange",
    "169bfc09037595610eb000fd3a0cb63cc9deca06": "Ybodychange",
    "9947aeb60c3dd075544866fd6e4dab0ad8b4afa2": "Ybodychange",
    "9d4d30243b0fc9630da51a2c17b543ef671d035c": "Ybodychange",
    "c59af2fdf8f7f53117c626a895dab7fd78cf08ec": "Ybodychange",
    "95c73d49b1bb459b626a9ac52acadb8f5fa724de": "Ybodychange",
    "5b9fcedb4d116d91d70aaad6cbf59093eeee36df": "Ybodychange",
    "8e9502e05d09e31b76fda7cc6691e78a39db8de6": "Ybodychange",
    "4b2834898cbcc66ffbf01b2fb10375e79a50d538": "Ybodychange",
    "1758f3146ae582493ca02be9babfaf24fb612613": "Ybodychange",
    "5421725907267d88609442c220aed3f32ccf6ad1": "Ybodychange",
    "4ba7a5e5642af2db82d8ab0af8ae65758297c1ad": "Ybodychange",
    "fdba5fac263f9bf79fccf566c36bbc42ef67e875": "Ybodychange",
    "638801cce16fc1dc3259c541dc30a599faaddda1": "Ybodychange",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "c60feead5eb3d2de111ac97bdc9f1a95cfbc5263": "Ybodychange",
    "b089f4448db4196d32ccf8561ed682d42c6b45ba": "Ybodychange",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16029. Consecutive StringBuilder.append can be reused. Contributed by Ayush Saxena.\n",
      "commitDate": "11/01/19 10:54 AM",
      "commitName": "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "16/06/18 11:42 PM",
      "commitNameOld": "3905fdb793e6370243d05d0c3036ca69898fe3fb",
      "commitAuthorOld": "Surendra Singh Lilhore",
      "daysBetweenCommits": 208.51,
      "commitsBetweenForRepo": 1594,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,134 @@\n   private void runCommand() throws IOException {\n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut.set(false);\n     completed.set(false);\n \n     // Remove all env vars from the Builder to prevent leaking of env vars from\n     // the parent process.\n     if (!inheritParentEnv) {\n       builder.environment().clear();\n     }\n \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n \n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     waitingThread \u003d Thread.currentThread();\n     CHILD_SHELLS.put(this, null);\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getErrorStream(), Charset.defaultCharset()));\n     BufferedReader inReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getInputStream(), Charset.defaultCharset()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n-            errMsg.append(line);\n-            errMsg.append(System.getProperty(\"line.separator\"));\n+            errMsg.append(line)\n+                .append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           // Its normal to observe a \"Stream closed\" I/O error on\n           // command timeouts destroying the underlying process\n           // so only log a WARN if the command didn\u0027t time out\n           if (!isTimedOut()) {\n             LOG.warn(\"Error reading the error stream\", ioe);\n           } else {\n             LOG.debug(\"Error reading the error stream due to shell \"\n                 + \"command timeout\", ioe);\n           }\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) {\n     } catch (OutOfMemoryError oe) {\n       LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n           + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n           + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n       throw oe;\n     }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) {\n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n       iie.initCause(ie);\n       throw iie;\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         inReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n         errReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       waitingThread \u003d null;\n       CHILD_SHELLS.remove(this);\n       lastTime \u003d Time.monotonicNow();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException {\n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut.set(false);\n    completed.set(false);\n\n    // Remove all env vars from the Builder to prevent leaking of env vars from\n    // the parent process.\n    if (!inheritParentEnv) {\n      builder.environment().clear();\n    }\n\n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n\n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    waitingThread \u003d Thread.currentThread();\n    CHILD_SHELLS.put(this, null);\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getErrorStream(), Charset.defaultCharset()));\n    BufferedReader inReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getInputStream(), Charset.defaultCharset()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n\n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line)\n                .append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          // Its normal to observe a \"Stream closed\" I/O error on\n          // command timeouts destroying the underlying process\n          // so only log a WARN if the command didn\u0027t time out\n          if (!isTimedOut()) {\n            LOG.warn(\"Error reading the error stream\", ioe);\n          } else {\n            LOG.debug(\"Error reading the error stream due to shell \"\n                + \"command timeout\", ioe);\n          }\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) {\n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n      iie.initCause(ie);\n      throw iie;\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        inReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        errReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      waitingThread \u003d null;\n      CHILD_SHELLS.remove(this);\n      lastTime \u003d Time.monotonicNow();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "f494f0b8968a61bf3aa32b7ca0851b8c744aa70f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15512. Clean up Shell from JDK7 workarounds.\nContributed by Zsolt Venczel.\n",
      "commitDate": "07/06/18 7:55 AM",
      "commitName": "f494f0b8968a61bf3aa32b7ca0851b8c744aa70f",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/05/18 5:03 PM",
      "commitNameOld": "53b807a6a8486cefe0b036f7893de9f619bd44a1",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 20.62,
      "commitsBetweenForRepo": 166,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,134 @@\n   private void runCommand() throws IOException {\n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut.set(false);\n     completed.set(false);\n \n     // Remove all env vars from the Builder to prevent leaking of env vars from\n     // the parent process.\n     if (!inheritParentEnv) {\n       builder.environment().clear();\n     }\n \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n \n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     waitingThread \u003d Thread.currentThread();\n     CHILD_SHELLS.put(this, null);\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getErrorStream(), Charset.defaultCharset()));\n     BufferedReader inReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getInputStream(), Charset.defaultCharset()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           // Its normal to observe a \"Stream closed\" I/O error on\n           // command timeouts destroying the underlying process\n           // so only log a WARN if the command didn\u0027t time out\n           if (!isTimedOut()) {\n             LOG.warn(\"Error reading the error stream\", ioe);\n           } else {\n             LOG.debug(\"Error reading the error stream due to shell \"\n                 + \"command timeout\", ioe);\n           }\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) {\n     } catch (OutOfMemoryError oe) {\n       LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n           + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n           + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n       throw oe;\n     }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) {\n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n       iie.initCause(ie);\n       throw iie;\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n-        // JDK 7 tries to automatically drain the input streams for us\n-        // when the process exits, but since close is not synchronized,\n-        // it creates a race if we close the stream first and the same\n-        // fd is recycled.  the stream draining thread will attempt to\n-        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n-        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n-        //      issue is fixed in build 7u60\n-        InputStream stdout \u003d process.getInputStream();\n-        synchronized (stdout) {\n-          inReader.close();\n-        }\n+        inReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n-        InputStream stderr \u003d process.getErrorStream();\n-        synchronized (stderr) {\n-          errReader.close();\n-        }\n+        errReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       waitingThread \u003d null;\n       CHILD_SHELLS.remove(this);\n       lastTime \u003d Time.monotonicNow();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException {\n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut.set(false);\n    completed.set(false);\n\n    // Remove all env vars from the Builder to prevent leaking of env vars from\n    // the parent process.\n    if (!inheritParentEnv) {\n      builder.environment().clear();\n    }\n\n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n\n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    waitingThread \u003d Thread.currentThread();\n    CHILD_SHELLS.put(this, null);\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getErrorStream(), Charset.defaultCharset()));\n    BufferedReader inReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getInputStream(), Charset.defaultCharset()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n\n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          // Its normal to observe a \"Stream closed\" I/O error on\n          // command timeouts destroying the underlying process\n          // so only log a WARN if the command didn\u0027t time out\n          if (!isTimedOut()) {\n            LOG.warn(\"Error reading the error stream\", ioe);\n          } else {\n            LOG.debug(\"Error reading the error stream due to shell \"\n                + \"command timeout\", ioe);\n          }\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) {\n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n      iie.initCause(ie);\n      throw iie;\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        inReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        errReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      waitingThread \u003d null;\n      CHILD_SHELLS.remove(this);\n      lastTime \u003d Time.monotonicNow();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "e8694deb6ad180449f8ce6c1c8b4f84873c0587a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13817. Add a finite shell command timeout to ShellBasedUnixGroupsMapping. (harsh)\n",
      "commitDate": "24/02/17 8:04 AM",
      "commitName": "e8694deb6ad180449f8ce6c1c8b4f84873c0587a",
      "commitAuthor": "Harsh J",
      "commitDateOld": "25/01/17 1:41 PM",
      "commitNameOld": "9e19f758c1950cbcfcd1969461a8a910efca0767",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 29.77,
      "commitsBetweenForRepo": 141,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,139 +1,147 @@\n   private void runCommand() throws IOException {\n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut.set(false);\n     completed.set(false);\n \n     // Remove all env vars from the Builder to prevent leaking of env vars from\n     // the parent process.\n     if (!inheritParentEnv) {\n       builder.environment().clear();\n     }\n \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n \n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     waitingThread \u003d Thread.currentThread();\n     CHILD_SHELLS.put(this, null);\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getErrorStream(), Charset.defaultCharset()));\n     BufferedReader inReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getInputStream(), Charset.defaultCharset()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n-          LOG.warn(\"Error reading the error stream\", ioe);\n+          // Its normal to observe a \"Stream closed\" I/O error on\n+          // command timeouts destroying the underlying process\n+          // so only log a WARN if the command didn\u0027t time out\n+          if (!isTimedOut()) {\n+            LOG.warn(\"Error reading the error stream\", ioe);\n+          } else {\n+            LOG.debug(\"Error reading the error stream due to shell \"\n+                + \"command timeout\", ioe);\n+          }\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) {\n     } catch (OutOfMemoryError oe) {\n       LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n           + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n           + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n       throw oe;\n     }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) {\n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n       iie.initCause(ie);\n       throw iie;\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         // JDK 7 tries to automatically drain the input streams for us\n         // when the process exits, but since close is not synchronized,\n         // it creates a race if we close the stream first and the same\n         // fd is recycled.  the stream draining thread will attempt to\n         // drain that fd!!  it may block, OOM, or cause bizarre behavior\n         // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n         //      issue is fixed in build 7u60\n         InputStream stdout \u003d process.getInputStream();\n         synchronized (stdout) {\n           inReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n         InputStream stderr \u003d process.getErrorStream();\n         synchronized (stderr) {\n           errReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       waitingThread \u003d null;\n       CHILD_SHELLS.remove(this);\n       lastTime \u003d Time.monotonicNow();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException {\n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut.set(false);\n    completed.set(false);\n\n    // Remove all env vars from the Builder to prevent leaking of env vars from\n    // the parent process.\n    if (!inheritParentEnv) {\n      builder.environment().clear();\n    }\n\n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n\n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    waitingThread \u003d Thread.currentThread();\n    CHILD_SHELLS.put(this, null);\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getErrorStream(), Charset.defaultCharset()));\n    BufferedReader inReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getInputStream(), Charset.defaultCharset()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n\n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          // Its normal to observe a \"Stream closed\" I/O error on\n          // command timeouts destroying the underlying process\n          // so only log a WARN if the command didn\u0027t time out\n          if (!isTimedOut()) {\n            LOG.warn(\"Error reading the error stream\", ioe);\n          } else {\n            LOG.debug(\"Error reading the error stream due to shell \"\n                + \"command timeout\", ioe);\n          }\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) {\n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n      iie.initCause(ie);\n      throw iie;\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      waitingThread \u003d null;\n      CHILD_SHELLS.remove(this);\n      lastTime \u003d Time.monotonicNow();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "9e19f758c1950cbcfcd1969461a8a910efca0767": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5641. Localizer leaves behind tarballs after container is complete. Contributed by Eric Badger\n",
      "commitDate": "25/01/17 1:41 PM",
      "commitName": "9e19f758c1950cbcfcd1969461a8a910efca0767",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "15/12/16 12:52 PM",
      "commitNameOld": "631f1daee3507a1adbc68b937cca31c27dbe8d3d",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 41.03,
      "commitsBetweenForRepo": 190,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,139 @@\n   private void runCommand() throws IOException {\n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut.set(false);\n     completed.set(false);\n \n     // Remove all env vars from the Builder to prevent leaking of env vars from\n     // the parent process.\n     if (!inheritParentEnv) {\n       builder.environment().clear();\n     }\n \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n \n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n-    CHILD_PROCESSES.put(process, null);\n+\n+    waitingThread \u003d Thread.currentThread();\n+    CHILD_SHELLS.put(this, null);\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getErrorStream(), Charset.defaultCharset()));\n     BufferedReader inReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getInputStream(), Charset.defaultCharset()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) {\n     } catch (OutOfMemoryError oe) {\n       LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n           + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n           + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n       throw oe;\n     }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) {\n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n       iie.initCause(ie);\n       throw iie;\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         // JDK 7 tries to automatically drain the input streams for us\n         // when the process exits, but since close is not synchronized,\n         // it creates a race if we close the stream first and the same\n         // fd is recycled.  the stream draining thread will attempt to\n         // drain that fd!!  it may block, OOM, or cause bizarre behavior\n         // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n         //      issue is fixed in build 7u60\n         InputStream stdout \u003d process.getInputStream();\n         synchronized (stdout) {\n           inReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n         InputStream stderr \u003d process.getErrorStream();\n         synchronized (stderr) {\n           errReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n-      CHILD_PROCESSES.remove(process);\n+      waitingThread \u003d null;\n+      CHILD_SHELLS.remove(this);\n       lastTime \u003d Time.monotonicNow();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException {\n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut.set(false);\n    completed.set(false);\n\n    // Remove all env vars from the Builder to prevent leaking of env vars from\n    // the parent process.\n    if (!inheritParentEnv) {\n      builder.environment().clear();\n    }\n\n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n\n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    waitingThread \u003d Thread.currentThread();\n    CHILD_SHELLS.put(this, null);\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getErrorStream(), Charset.defaultCharset()));\n    BufferedReader inReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getInputStream(), Charset.defaultCharset()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n\n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) {\n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n      iie.initCause(ie);\n      throw iie;\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      waitingThread \u003d null;\n      CHILD_SHELLS.remove(this);\n      lastTime \u003d Time.monotonicNow();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "631f1daee3507a1adbc68b937cca31c27dbe8d3d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13709. Ability to clean up subprocesses spawned by Shell when the process exits. Contributed by Eric Badger\n",
      "commitDate": "15/12/16 12:52 PM",
      "commitName": "631f1daee3507a1adbc68b937cca31c27dbe8d3d",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "15/12/16 12:51 PM",
      "commitNameOld": "169bfc09037595610eb000fd3a0cb63cc9deca06",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,136 @@\n   private void runCommand() throws IOException {\n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut.set(false);\n     completed.set(false);\n \n     // Remove all env vars from the Builder to prevent leaking of env vars from\n     // the parent process.\n     if (!inheritParentEnv) {\n       builder.environment().clear();\n     }\n \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n \n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n+    CHILD_PROCESSES.put(process, null);\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getErrorStream(), Charset.defaultCharset()));\n     BufferedReader inReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getInputStream(), Charset.defaultCharset()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) {\n     } catch (OutOfMemoryError oe) {\n       LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n           + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n           + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n       throw oe;\n     }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) {\n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n       iie.initCause(ie);\n       throw iie;\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         // JDK 7 tries to automatically drain the input streams for us\n         // when the process exits, but since close is not synchronized,\n         // it creates a race if we close the stream first and the same\n         // fd is recycled.  the stream draining thread will attempt to\n         // drain that fd!!  it may block, OOM, or cause bizarre behavior\n         // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n         //      issue is fixed in build 7u60\n         InputStream stdout \u003d process.getInputStream();\n         synchronized (stdout) {\n           inReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n         InputStream stderr \u003d process.getErrorStream();\n         synchronized (stderr) {\n           errReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n+      CHILD_PROCESSES.remove(process);\n       lastTime \u003d Time.monotonicNow();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException {\n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut.set(false);\n    completed.set(false);\n\n    // Remove all env vars from the Builder to prevent leaking of env vars from\n    // the parent process.\n    if (!inheritParentEnv) {\n      builder.environment().clear();\n    }\n\n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n\n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n    CHILD_PROCESSES.put(process, null);\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getErrorStream(), Charset.defaultCharset()));\n    BufferedReader inReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getInputStream(), Charset.defaultCharset()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n\n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) {\n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n      iie.initCause(ie);\n      throw iie;\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      CHILD_PROCESSES.remove(process);\n      lastTime \u003d Time.monotonicNow();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "169bfc09037595610eb000fd3a0cb63cc9deca06": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13709. Ability to clean up subprocesses spawned by Shell when the process exits. Contributed by Eric Badger\"\n\nThis reverts commit 9947aeb60c3dd075544866fd6e4dab0ad8b4afa2.\n",
      "commitDate": "15/12/16 12:51 PM",
      "commitName": "169bfc09037595610eb000fd3a0cb63cc9deca06",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "13/12/16 2:55 PM",
      "commitNameOld": "9947aeb60c3dd075544866fd6e4dab0ad8b4afa2",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 1.91,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,134 @@\n   private void runCommand() throws IOException {\n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut.set(false);\n     completed.set(false);\n \n     // Remove all env vars from the Builder to prevent leaking of env vars from\n     // the parent process.\n     if (!inheritParentEnv) {\n       builder.environment().clear();\n     }\n \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n \n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n-    CHILD_PROCESSES.put(process, null);\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getErrorStream(), Charset.defaultCharset()));\n     BufferedReader inReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getInputStream(), Charset.defaultCharset()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) {\n     } catch (OutOfMemoryError oe) {\n       LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n           + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n           + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n       throw oe;\n     }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) {\n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n       iie.initCause(ie);\n       throw iie;\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         // JDK 7 tries to automatically drain the input streams for us\n         // when the process exits, but since close is not synchronized,\n         // it creates a race if we close the stream first and the same\n         // fd is recycled.  the stream draining thread will attempt to\n         // drain that fd!!  it may block, OOM, or cause bizarre behavior\n         // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n         //      issue is fixed in build 7u60\n         InputStream stdout \u003d process.getInputStream();\n         synchronized (stdout) {\n           inReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n         InputStream stderr \u003d process.getErrorStream();\n         synchronized (stderr) {\n           errReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n-      CHILD_PROCESSES.remove(process);\n       lastTime \u003d Time.monotonicNow();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException {\n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut.set(false);\n    completed.set(false);\n\n    // Remove all env vars from the Builder to prevent leaking of env vars from\n    // the parent process.\n    if (!inheritParentEnv) {\n      builder.environment().clear();\n    }\n\n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n\n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getErrorStream(), Charset.defaultCharset()));\n    BufferedReader inReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getInputStream(), Charset.defaultCharset()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n\n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) {\n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n      iie.initCause(ie);\n      throw iie;\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.monotonicNow();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "9947aeb60c3dd075544866fd6e4dab0ad8b4afa2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13709. Ability to clean up subprocesses spawned by Shell when the process exits. Contributed by Eric Badger\n",
      "commitDate": "13/12/16 2:55 PM",
      "commitName": "9947aeb60c3dd075544866fd6e4dab0ad8b4afa2",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "07/11/16 4:36 AM",
      "commitNameOld": "f76895573d0166b4b582ff69c3f9c159ab14661f",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 36.43,
      "commitsBetweenForRepo": 230,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,136 @@\n   private void runCommand() throws IOException {\n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut.set(false);\n     completed.set(false);\n \n     // Remove all env vars from the Builder to prevent leaking of env vars from\n     // the parent process.\n     if (!inheritParentEnv) {\n       builder.environment().clear();\n     }\n \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n \n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n+    CHILD_PROCESSES.put(process, null);\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getErrorStream(), Charset.defaultCharset()));\n     BufferedReader inReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getInputStream(), Charset.defaultCharset()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) {\n     } catch (OutOfMemoryError oe) {\n       LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n           + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n           + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n       throw oe;\n     }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) {\n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n       iie.initCause(ie);\n       throw iie;\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         // JDK 7 tries to automatically drain the input streams for us\n         // when the process exits, but since close is not synchronized,\n         // it creates a race if we close the stream first and the same\n         // fd is recycled.  the stream draining thread will attempt to\n         // drain that fd!!  it may block, OOM, or cause bizarre behavior\n         // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n         //      issue is fixed in build 7u60\n         InputStream stdout \u003d process.getInputStream();\n         synchronized (stdout) {\n           inReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n         InputStream stderr \u003d process.getErrorStream();\n         synchronized (stderr) {\n           errReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n+      CHILD_PROCESSES.remove(process);\n       lastTime \u003d Time.monotonicNow();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException {\n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut.set(false);\n    completed.set(false);\n\n    // Remove all env vars from the Builder to prevent leaking of env vars from\n    // the parent process.\n    if (!inheritParentEnv) {\n      builder.environment().clear();\n    }\n\n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n\n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n    CHILD_PROCESSES.put(process, null);\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getErrorStream(), Charset.defaultCharset()));\n    BufferedReader inReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getInputStream(), Charset.defaultCharset()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n\n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) {\n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n      iie.initCause(ie);\n      throw iie;\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      CHILD_PROCESSES.remove(process);\n      lastTime \u003d Time.monotonicNow();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "9d4d30243b0fc9630da51a2c17b543ef671d035c": {
      "type": "Ybodychange",
      "commitMessage": "Remove parent\u0027s env vars from child processes\n",
      "commitDate": "29/04/16 9:25 AM",
      "commitName": "9d4d30243b0fc9630da51a2c17b543ef671d035c",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "16/03/16 7:31 AM",
      "commitNameOld": "5a725f0ab8ef9e2a8b08f088ba4e87531ae4530d",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 44.08,
      "commitsBetweenForRepo": 267,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,134 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut.set(false);\n     completed.set(false);\n \n+    // Remove all env vars from the Builder to prevent leaking of env vars from\n+    // the parent process.\n+    if (!inheritParentEnv) {\n+      builder.environment().clear();\n+    }\n+\n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n+\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n     \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(\n                 process.getErrorStream(), Charset.defaultCharset()));\n     BufferedReader inReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getInputStream(), Charset.defaultCharset()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) {\n     } catch (OutOfMemoryError oe) {\n       LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n           + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n           + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n       throw oe;\n     }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n       iie.initCause(ie);\n       throw iie;\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         // JDK 7 tries to automatically drain the input streams for us\n         // when the process exits, but since close is not synchronized,\n         // it creates a race if we close the stream first and the same\n         // fd is recycled.  the stream draining thread will attempt to\n         // drain that fd!!  it may block, OOM, or cause bizarre behavior\n         // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n         //      issue is fixed in build 7u60\n         InputStream stdout \u003d process.getInputStream();\n         synchronized (stdout) {\n           inReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n         InputStream stderr \u003d process.getErrorStream();\n         synchronized (stderr) {\n           errReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       lastTime \u003d Time.monotonicNow();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut.set(false);\n    completed.set(false);\n\n    // Remove all env vars from the Builder to prevent leaking of env vars from\n    // the parent process.\n    if (!inheritParentEnv) {\n      builder.environment().clear();\n    }\n\n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n    \n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(\n                process.getErrorStream(), Charset.defaultCharset()));\n    BufferedReader inReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getInputStream(), Charset.defaultCharset()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n\n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n      iie.initCause(ie);\n      throw iie;\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.monotonicNow();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "c59af2fdf8f7f53117c626a895dab7fd78cf08ec": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10775. Shell operations to fail with meaningful errors on windows if winutils.exe not found. (stevel)\n",
      "commitDate": "13/10/15 1:49 PM",
      "commitName": "c59af2fdf8f7f53117c626a895dab7fd78cf08ec",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/10/15 10:56 AM",
      "commitNameOld": "f1c19b9365cbac88e45a9eed516fbfc6c9aa9947",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 8.12,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,127 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n-    timedOut \u003d new AtomicBoolean(false);\n-    completed \u003d new AtomicBoolean(false);\n-    \n+    timedOut.set(false);\n+    completed.set(false);\n+\n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n     \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(\n                 process.getErrorStream(), Charset.defaultCharset()));\n-    BufferedReader inReader \u003d \n+    BufferedReader inReader \u003d\n             new BufferedReader(new InputStreamReader(\n                 process.getInputStream(), Charset.defaultCharset()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n-    \n+\n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) {\n     } catch (OutOfMemoryError oe) {\n       LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n           + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n           + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n       throw oe;\n     }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n       iie.initCause(ie);\n       throw iie;\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         // JDK 7 tries to automatically drain the input streams for us\n         // when the process exits, but since close is not synchronized,\n         // it creates a race if we close the stream first and the same\n         // fd is recycled.  the stream draining thread will attempt to\n         // drain that fd!!  it may block, OOM, or cause bizarre behavior\n         // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n         //      issue is fixed in build 7u60\n         InputStream stdout \u003d process.getInputStream();\n         synchronized (stdout) {\n           inReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n         InputStream stderr \u003d process.getErrorStream();\n         synchronized (stderr) {\n           errReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       lastTime \u003d Time.monotonicNow();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut.set(false);\n    completed.set(false);\n\n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n    \n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(\n                process.getErrorStream(), Charset.defaultCharset()));\n    BufferedReader inReader \u003d\n            new BufferedReader(new InputStreamReader(\n                process.getInputStream(), Charset.defaultCharset()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n\n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n      iie.initCause(ie);\n      throw iie;\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.monotonicNow();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "95c73d49b1bb459b626a9ac52acadb8f5fa724de": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12074. in Shell.java#runCommand() rethrow InterruptedException as InterruptedIOException (Contributed by Lavkesh Lahngir)\n",
      "commitDate": "10/06/15 11:21 PM",
      "commitName": "95c73d49b1bb459b626a9ac52acadb8f5fa724de",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "04/06/15 11:38 AM",
      "commitNameOld": "9f6d67844da3c6ca1de66d426790e741e77f8038",
      "commitAuthorOld": "Gera Shegalov",
      "daysBetweenCommits": 6.49,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,127 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut \u003d new AtomicBoolean(false);\n     completed \u003d new AtomicBoolean(false);\n     \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n     \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(\n                 process.getErrorStream(), Charset.defaultCharset()));\n     BufferedReader inReader \u003d \n             new BufferedReader(new InputStreamReader(\n                 process.getInputStream(), Charset.defaultCharset()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) {\n     } catch (OutOfMemoryError oe) {\n       LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n           + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n           + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n       throw oe;\n     }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n-      throw new IOException(ie.toString());\n+      InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n+      iie.initCause(ie);\n+      throw iie;\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         // JDK 7 tries to automatically drain the input streams for us\n         // when the process exits, but since close is not synchronized,\n         // it creates a race if we close the stream first and the same\n         // fd is recycled.  the stream draining thread will attempt to\n         // drain that fd!!  it may block, OOM, or cause bizarre behavior\n         // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n         //      issue is fixed in build 7u60\n         InputStream stdout \u003d process.getInputStream();\n         synchronized (stdout) {\n           inReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n         InputStream stderr \u003d process.getErrorStream();\n         synchronized (stderr) {\n           errReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       lastTime \u003d Time.monotonicNow();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n    \n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(\n                process.getErrorStream(), Charset.defaultCharset()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(\n                process.getInputStream(), Charset.defaultCharset()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      InterruptedIOException iie \u003d new InterruptedIOException(ie.toString());\n      iie.initCause(ie);\n      throw iie;\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.monotonicNow();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "5b9fcedb4d116d91d70aaad6cbf59093eeee36df": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11389. Clean up byte to string encoding issues in hadoop-common. Contributed by Haohui Mai.\n",
      "commitDate": "11/12/14 4:42 PM",
      "commitName": "5b9fcedb4d116d91d70aaad6cbf59093eeee36df",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "05/11/14 1:17 AM",
      "commitNameOld": "8e9502e05d09e31b76fda7cc6691e78a39db8de6",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 36.64,
      "commitsBetweenForRepo": 285,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut \u003d new AtomicBoolean(false);\n     completed \u003d new AtomicBoolean(false);\n     \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n     \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n-            new BufferedReader(new InputStreamReader(process\n-                                                     .getErrorStream()));\n+            new BufferedReader(new InputStreamReader(\n+                process.getErrorStream(), Charset.defaultCharset()));\n     BufferedReader inReader \u003d \n-            new BufferedReader(new InputStreamReader(process\n-                                                     .getInputStream()));\n+            new BufferedReader(new InputStreamReader(\n+                process.getInputStream(), Charset.defaultCharset()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) {\n     } catch (OutOfMemoryError oe) {\n       LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n           + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n           + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n       throw oe;\n     }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       throw new IOException(ie.toString());\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         // JDK 7 tries to automatically drain the input streams for us\n         // when the process exits, but since close is not synchronized,\n         // it creates a race if we close the stream first and the same\n         // fd is recycled.  the stream draining thread will attempt to\n         // drain that fd!!  it may block, OOM, or cause bizarre behavior\n         // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n         //      issue is fixed in build 7u60\n         InputStream stdout \u003d process.getInputStream();\n         synchronized (stdout) {\n           inReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n         InputStream stderr \u003d process.getErrorStream();\n         synchronized (stderr) {\n           errReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       lastTime \u003d Time.monotonicNow();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n    \n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(\n                process.getErrorStream(), Charset.defaultCharset()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(\n                process.getInputStream(), Charset.defaultCharset()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.monotonicNow();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "8e9502e05d09e31b76fda7cc6691e78a39db8de6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11271. Use Time.monotonicNow() in Shell.java instead of Time.now() (Contributed by Vinayakumar B)\n",
      "commitDate": "05/11/14 1:17 AM",
      "commitName": "8e9502e05d09e31b76fda7cc6691e78a39db8de6",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "27/10/14 12:15 PM",
      "commitNameOld": "5b1dfe78b8b06335bed0bcb83f12bb936d4c021b",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 8.59,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut \u003d new AtomicBoolean(false);\n     completed \u003d new AtomicBoolean(false);\n     \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n     \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getErrorStream()));\n     BufferedReader inReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getInputStream()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) {\n     } catch (OutOfMemoryError oe) {\n       LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n           + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n           + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n       throw oe;\n     }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       throw new IOException(ie.toString());\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         // JDK 7 tries to automatically drain the input streams for us\n         // when the process exits, but since close is not synchronized,\n         // it creates a race if we close the stream first and the same\n         // fd is recycled.  the stream draining thread will attempt to\n         // drain that fd!!  it may block, OOM, or cause bizarre behavior\n         // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n         //      issue is fixed in build 7u60\n         InputStream stdout \u003d process.getInputStream();\n         synchronized (stdout) {\n           inReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n         InputStream stderr \u003d process.getErrorStream();\n         synchronized (stderr) {\n           errReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n-      lastTime \u003d Time.now();\n+      lastTime \u003d Time.monotonicNow();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n    \n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.monotonicNow();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "4b2834898cbcc66ffbf01b2fb10375e79a50d538": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11172. Improve error message in Shell#runCommand on OutOfMemoryError. (Yongjun Zhang via wang)\n",
      "commitDate": "07/10/14 2:57 PM",
      "commitName": "4b2834898cbcc66ffbf01b2fb10375e79a50d538",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "03/07/14 4:28 AM",
      "commitNameOld": "362ae5143c845e90ec27bf578084bf91947e3bca",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 96.44,
      "commitsBetweenForRepo": 942,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,125 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut \u003d new AtomicBoolean(false);\n     completed \u003d new AtomicBoolean(false);\n     \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n     \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getErrorStream()));\n     BufferedReader inReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getInputStream()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n-    } catch (IllegalStateException ise) { }\n+    } catch (IllegalStateException ise) {\n+    } catch (OutOfMemoryError oe) {\n+      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n+          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n+          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n+      throw oe;\n+    }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       // make sure that the error thread exits\n       joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       throw new IOException(ie.toString());\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         // JDK 7 tries to automatically drain the input streams for us\n         // when the process exits, but since close is not synchronized,\n         // it creates a race if we close the stream first and the same\n         // fd is recycled.  the stream draining thread will attempt to\n         // drain that fd!!  it may block, OOM, or cause bizarre behavior\n         // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n         //      issue is fixed in build 7u60\n         InputStream stdout \u003d process.getInputStream();\n         synchronized (stdout) {\n           inReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n         joinThread(errThread);\n       }\n       try {\n         InputStream stderr \u003d process.getErrorStream();\n         synchronized (stderr) {\n           errReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       lastTime \u003d Time.now();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n    \n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) {\n    } catch (OutOfMemoryError oe) {\n      LOG.error(\"Caught \" + oe + \". One possible reason is that ulimit\"\n          + \" setting of \u0027max user processes\u0027 is too low. If so, do\"\n          + \" \u0027ulimit -u \u003clargerNum\u003e\u0027 and try again.\");\n      throw oe;\n    }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.now();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "1758f3146ae582493ca02be9babfaf24fb612613": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10622. Shell.runCommand can deadlock. Contributed by Gera Shegalov\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1602033 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/14 3:05 PM",
      "commitName": "1758f3146ae582493ca02be9babfaf24fb612613",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "14/05/14 2:01 PM",
      "commitNameOld": "f099fa4cd474060455dcf5d437ffa0849ca9f95a",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 28.04,
      "commitsBetweenForRepo": 147,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,119 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut \u003d new AtomicBoolean(false);\n     completed \u003d new AtomicBoolean(false);\n     \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n     \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getErrorStream()));\n     BufferedReader inReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getInputStream()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) { }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n-      try {\n-        // make sure that the error thread exits\n-        errThread.join();\n-      } catch (InterruptedException ie) {\n-        LOG.warn(\"Interrupted while reading the error stream\", ie);\n-      }\n+      // make sure that the error thread exits\n+      joinThread(errThread);\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       throw new IOException(ie.toString());\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         // JDK 7 tries to automatically drain the input streams for us\n         // when the process exits, but since close is not synchronized,\n         // it creates a race if we close the stream first and the same\n         // fd is recycled.  the stream draining thread will attempt to\n         // drain that fd!!  it may block, OOM, or cause bizarre behavior\n         // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n         //      issue is fixed in build 7u60\n         InputStream stdout \u003d process.getInputStream();\n         synchronized (stdout) {\n           inReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n-      try {\n-        if (!completed.get()) {\n-          errThread.interrupt();\n-          errThread.join();\n-        }\n-      } catch (InterruptedException ie) {\n-        LOG.warn(\"Interrupted while joining errThread\");\n+      if (!completed.get()) {\n+        errThread.interrupt();\n+        joinThread(errThread);\n       }\n       try {\n         InputStream stderr \u003d process.getErrorStream();\n         synchronized (stderr) {\n           errReader.close();\n         }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       lastTime \u003d Time.now();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n    \n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) { }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      // make sure that the error thread exits\n      joinThread(errThread);\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n        joinThread(errThread);\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.now();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "5421725907267d88609442c220aed3f32ccf6ad1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10146. Workaround JDK7 Process fd close bug (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1558883 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/01/14 10:54 AM",
      "commitName": "5421725907267d88609442c220aed3f32ccf6ad1",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "29/08/13 5:32 PM",
      "commitNameOld": "87e449fd239b68339f9008897a74ee155e98f2ba",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 139.77,
      "commitsBetweenForRepo": 839,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,127 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut \u003d new AtomicBoolean(false);\n     completed \u003d new AtomicBoolean(false);\n     \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n     \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getErrorStream()));\n     BufferedReader inReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getInputStream()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) { }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       try {\n         // make sure that the error thread exits\n         errThread.join();\n       } catch (InterruptedException ie) {\n         LOG.warn(\"Interrupted while reading the error stream\", ie);\n       }\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       throw new IOException(ie.toString());\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n-        inReader.close();\n+        // JDK 7 tries to automatically drain the input streams for us\n+        // when the process exits, but since close is not synchronized,\n+        // it creates a race if we close the stream first and the same\n+        // fd is recycled.  the stream draining thread will attempt to\n+        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n+        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n+        //      issue is fixed in build 7u60\n+        InputStream stdout \u003d process.getInputStream();\n+        synchronized (stdout) {\n+          inReader.close();\n+        }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       try {\n         if (!completed.get()) {\n           errThread.interrupt();\n           errThread.join();\n         }\n       } catch (InterruptedException ie) {\n         LOG.warn(\"Interrupted while joining errThread\");\n       }\n       try {\n-        errReader.close();\n+        InputStream stderr \u003d process.getErrorStream();\n+        synchronized (stderr) {\n+          errReader.close();\n+        }\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       lastTime \u003d Time.now();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n    \n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) { }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      try {\n        // make sure that the error thread exits\n        errThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while reading the error stream\", ie);\n      }\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        // JDK 7 tries to automatically drain the input streams for us\n        // when the process exits, but since close is not synchronized,\n        // it creates a race if we close the stream first and the same\n        // fd is recycled.  the stream draining thread will attempt to\n        // drain that fd!!  it may block, OOM, or cause bizarre behavior\n        // see: https://bugs.openjdk.java.net/browse/JDK-8024521\n        //      issue is fixed in build 7u60\n        InputStream stdout \u003d process.getInputStream();\n        synchronized (stdout) {\n          inReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      try {\n        if (!completed.get()) {\n          errThread.interrupt();\n          errThread.join();\n        }\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while joining errThread\");\n      }\n      try {\n        InputStream stderr \u003d process.getErrorStream();\n        synchronized (stderr) {\n          errReader.close();\n        }\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.now();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "4ba7a5e5642af2db82d8ab0af8ae65758297c1ad": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9894.  Race condition in Shell leads to logged error stream handling exceptions (Arpit Agarwal)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1518420 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/08/13 5:06 PM",
      "commitName": "4ba7a5e5642af2db82d8ab0af8ae65758297c1ad",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "14/08/13 4:12 PM",
      "commitNameOld": "fdba5fac263f9bf79fccf566c36bbc42ef67e875",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 14.04,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,114 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut \u003d new AtomicBoolean(false);\n     completed \u003d new AtomicBoolean(false);\n     \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n \n     builder.redirectErrorStream(redirectErrorStream);\n     \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getErrorStream()));\n     BufferedReader inReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getInputStream()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) { }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       try {\n         // make sure that the error thread exits\n         errThread.join();\n       } catch (InterruptedException ie) {\n         LOG.warn(\"Interrupted while reading the error stream\", ie);\n       }\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       throw new IOException(ie.toString());\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         inReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n-      if (!completed.get()) {\n-        errThread.interrupt();\n+      try {\n+        if (!completed.get()) {\n+          errThread.interrupt();\n+          errThread.join();\n+        }\n+      } catch (InterruptedException ie) {\n+        LOG.warn(\"Interrupted while joining errThread\");\n       }\n       try {\n         errReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       lastTime \u003d Time.now();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n    \n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) { }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      try {\n        // make sure that the error thread exits\n        errThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while reading the error stream\", ie);\n      }\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        inReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      try {\n        if (!completed.get()) {\n          errThread.interrupt();\n          errThread.join();\n        }\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while joining errThread\");\n      }\n      try {\n        errReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.now();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "fdba5fac263f9bf79fccf566c36bbc42ef67e875": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9652.  RawLocalFs#getFileLinkStatus does not fill in the link owner and mode.  (Andrew Wang via Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1514088 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/13 4:12 PM",
      "commitName": "fdba5fac263f9bf79fccf566c36bbc42ef67e875",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "06/08/13 1:35 PM",
      "commitNameOld": "f2942687d44caaaedae98132024f8fc1dc4a884a",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 8.11,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,109 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut \u003d new AtomicBoolean(false);\n     completed \u003d new AtomicBoolean(false);\n     \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n+\n+    builder.redirectErrorStream(redirectErrorStream);\n     \n     if (Shell.WINDOWS) {\n       synchronized (WindowsProcessLaunchLock) {\n         // To workaround the race condition issue with child processes\n         // inheriting unintended handles during process launch that can\n         // lead to hangs on reading output and error streams, we\n         // serialize process creation. More info available at:\n         // http://support.microsoft.com/kb/315939\n         process \u003d builder.start();\n       }\n     } else {\n       process \u003d builder.start();\n     }\n \n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getErrorStream()));\n     BufferedReader inReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getInputStream()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) { }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       try {\n         // make sure that the error thread exits\n         errThread.join();\n       } catch (InterruptedException ie) {\n         LOG.warn(\"Interrupted while reading the error stream\", ie);\n       }\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       throw new IOException(ie.toString());\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         inReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n       }\n       try {\n         errReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       lastTime \u003d Time.now();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n\n    builder.redirectErrorStream(redirectErrorStream);\n    \n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) { }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      try {\n        // make sure that the error thread exits\n        errThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while reading the error stream\", ie);\n      }\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        inReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n      }\n      try {\n        errReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.now();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "638801cce16fc1dc3259c541dc30a599faaddda1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8952. Enhancements to support Hadoop on Windows Server and Windows Azure environments. Contributed by Ivan Mitic, Chuan Liu, Ramya Sunil, Bikas Saha, Kanna Karanam, John Gordon, Brandon Li, Chris Nauroth, David Lao, Sumadhur Reddy Bolli, Arpit Agarwal, Ahmed El Baz, Mike Liddell, Jing Zhao, Thejas Nair, Steve Maine, Ganeshan Iyer, Raja Aluri, Giridharan Kesavan, Ramya Bharathi Nimmagadda.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1453486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/03/13 11:15 AM",
      "commitName": "638801cce16fc1dc3259c541dc30a599faaddda1",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "24/08/12 6:03 PM",
      "commitNameOld": "deead78e35b0cb81af875b5a8032cbd06c9a2dae",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 193.76,
      "commitsBetweenForRepo": 940,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,107 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut \u003d new AtomicBoolean(false);\n     completed \u003d new AtomicBoolean(false);\n     \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n     \n-    process \u003d builder.start();\n+    if (Shell.WINDOWS) {\n+      synchronized (WindowsProcessLaunchLock) {\n+        // To workaround the race condition issue with child processes\n+        // inheriting unintended handles during process launch that can\n+        // lead to hangs on reading output and error streams, we\n+        // serialize process creation. More info available at:\n+        // http://support.microsoft.com/kb/315939\n+        process \u003d builder.start();\n+      }\n+    } else {\n+      process \u003d builder.start();\n+    }\n+\n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getErrorStream()));\n     BufferedReader inReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getInputStream()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) { }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       try {\n         // make sure that the error thread exits\n         errThread.join();\n       } catch (InterruptedException ie) {\n         LOG.warn(\"Interrupted while reading the error stream\", ie);\n       }\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       throw new IOException(ie.toString());\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         inReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n       }\n       try {\n         errReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       lastTime \u003d Time.now();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n    \n    if (Shell.WINDOWS) {\n      synchronized (WindowsProcessLaunchLock) {\n        // To workaround the race condition issue with child processes\n        // inheriting unintended handles during process launch that can\n        // lead to hangs on reading output and error streams, we\n        // serialize process creation. More info available at:\n        // http://support.microsoft.com/kb/315939\n        process \u003d builder.start();\n      }\n    } else {\n      process \u003d builder.start();\n    }\n\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) { }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      try {\n        // make sure that the error thread exits\n        errThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while reading the error stream\", ie);\n      }\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        inReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n      }\n      try {\n        errReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.now();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3641. Move server Util time methods to common and use now instead of System#currentTimeMillis. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1360858 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 12:01 PM",
      "commitName": "4a5ba3b7bd2360fd9605863630b477d362874e1e",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "19/04/12 9:05 AM",
      "commitNameOld": "f6cadd8610d9ca371d8278f486f17144a76c7bbf",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 84.12,
      "commitsBetweenForRepo": 444,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,95 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut \u003d new AtomicBoolean(false);\n     completed \u003d new AtomicBoolean(false);\n     \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n     \n     process \u003d builder.start();\n     if (timeOutInterval \u003e 0) {\n       timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getErrorStream()));\n     BufferedReader inReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getInputStream()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) { }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       try {\n         // make sure that the error thread exits\n         errThread.join();\n       } catch (InterruptedException ie) {\n         LOG.warn(\"Interrupted while reading the error stream\", ie);\n       }\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       throw new IOException(ie.toString());\n     } finally {\n       if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         inReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n       }\n       try {\n         errReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n-      lastTime \u003d System.currentTimeMillis();\n+      lastTime \u003d Time.now();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n    \n    process \u003d builder.start();\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) { }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      try {\n        // make sure that the error thread exits\n        errThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while reading the error stream\", ie);\n      }\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        inReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n      }\n      try {\n        errReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d Time.now();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n    \n    process \u003d builder.start();\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) { }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      try {\n        // make sure that the error thread exits\n        errThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while reading the error stream\", ie);\n      }\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        inReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n      }\n      try {\n        errReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d System.currentTimeMillis();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n    \n    process \u003d builder.start();\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) { }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      try {\n        // make sure that the error thread exits\n        errThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while reading the error stream\", ie);\n      }\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        inReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n      }\n      try {\n        errReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d System.currentTimeMillis();\n    }\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/util/Shell.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/util/Shell.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n    \n    process \u003d builder.start();\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) { }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      try {\n        // make sure that the error thread exits\n        errThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while reading the error stream\", ie);\n      }\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        inReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n      }\n      try {\n        errReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d System.currentTimeMillis();\n    }\n  }",
      "path": "common/src/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/util/Shell.java",
        "newPath": "common/src/java/org/apache/hadoop/util/Shell.java"
      }
    },
    "c60feead5eb3d2de111ac97bdc9f1a95cfbc5263": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7122. Fix thread leak when shell commands time out. Contributed by Todd Lipcon\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1064403 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/01/11 5:12 PM",
      "commitName": "c60feead5eb3d2de111ac97bdc9f1a95cfbc5263",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "23/12/10 4:45 PM",
      "commitNameOld": "23da8fe75e474f2ece36bc23c7368f12bc9a56cc",
      "commitAuthorOld": "Boris Shkolnik",
      "daysBetweenCommits": 35.02,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,95 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n     Timer timeOutTimer \u003d null;\n     ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n     timedOut \u003d new AtomicBoolean(false);\n     completed \u003d new AtomicBoolean(false);\n     \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n     \n     process \u003d builder.start();\n     if (timeOutInterval \u003e 0) {\n-      timeOutTimer \u003d new Timer();\n+      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n       timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n           this);\n       //One time scheduling.\n       timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n     }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getErrorStream()));\n     BufferedReader inReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getInputStream()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) { }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n       exitCode  \u003d process.waitFor();\n       try {\n         // make sure that the error thread exits\n         errThread.join();\n       } catch (InterruptedException ie) {\n         LOG.warn(\"Interrupted while reading the error stream\", ie);\n       }\n       completed.set(true);\n       //the timeout thread handling\n       //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       throw new IOException(ie.toString());\n     } finally {\n-      if ((timeOutTimer!\u003dnull) \u0026\u0026 !timedOut.get()) {\n+      if (timeOutTimer !\u003d null) {\n         timeOutTimer.cancel();\n       }\n       // close the input stream\n       try {\n         inReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n       if (!completed.get()) {\n         errThread.interrupt();\n       }\n       try {\n         errReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       lastTime \u003d System.currentTimeMillis();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n    \n    process \u003d builder.start();\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer(\"Shell command timeout\");\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) { }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      try {\n        // make sure that the error thread exits\n        errThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while reading the error stream\", ie);\n      }\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if (timeOutTimer !\u003d null) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        inReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n      }\n      try {\n        errReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d System.currentTimeMillis();\n    }\n  }",
      "path": "src/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "b089f4448db4196d32ccf8561ed682d42c6b45ba": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6106. Provides an option in ShellCommandExecutor to timeout commands that do not complete within a certain amount of time. Contributed by Sreekanth Ramakrishnan.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@788600 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/06/09 11:18 PM",
      "commitName": "b089f4448db4196d32ccf8561ed682d42c6b45ba",
      "commitAuthor": "Hemanth Yamijala",
      "commitDateOld": "01/06/09 2:10 PM",
      "commitNameOld": "5c7b7adacb47242fe4c82e982cb06e6276f6f862",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 24.38,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,95 @@\n   private void runCommand() throws IOException { \n     ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n-    boolean completed \u003d false;\n+    Timer timeOutTimer \u003d null;\n+    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n+    timedOut \u003d new AtomicBoolean(false);\n+    completed \u003d new AtomicBoolean(false);\n     \n     if (environment !\u003d null) {\n       builder.environment().putAll(this.environment);\n     }\n     if (dir !\u003d null) {\n       builder.directory(this.dir);\n     }\n     \n     process \u003d builder.start();\n+    if (timeOutInterval \u003e 0) {\n+      timeOutTimer \u003d new Timer();\n+      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n+          this);\n+      //One time scheduling.\n+      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n+    }\n     final BufferedReader errReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getErrorStream()));\n     BufferedReader inReader \u003d \n             new BufferedReader(new InputStreamReader(process\n                                                      .getInputStream()));\n     final StringBuffer errMsg \u003d new StringBuffer();\n     \n     // read error and input streams as this would free up the buffers\n     // free the error stream buffer\n     Thread errThread \u003d new Thread() {\n       @Override\n       public void run() {\n         try {\n           String line \u003d errReader.readLine();\n           while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n             errMsg.append(line);\n             errMsg.append(System.getProperty(\"line.separator\"));\n             line \u003d errReader.readLine();\n           }\n         } catch(IOException ioe) {\n           LOG.warn(\"Error reading the error stream\", ioe);\n         }\n       }\n     };\n     try {\n       errThread.start();\n     } catch (IllegalStateException ise) { }\n     try {\n       parseExecResult(inReader); // parse the output\n       // clear the input stream buffer\n       String line \u003d inReader.readLine();\n       while(line !\u003d null) { \n         line \u003d inReader.readLine();\n       }\n       // wait for the process to finish and check the exit code\n-      exitCode \u003d process.waitFor();\n+      exitCode  \u003d process.waitFor();\n       try {\n         // make sure that the error thread exits\n         errThread.join();\n       } catch (InterruptedException ie) {\n         LOG.warn(\"Interrupted while reading the error stream\", ie);\n       }\n-      completed \u003d true;\n+      completed.set(true);\n+      //the timeout thread handling\n+      //taken care in finally block\n       if (exitCode !\u003d 0) {\n         throw new ExitCodeException(exitCode, errMsg.toString());\n       }\n     } catch (InterruptedException ie) {\n       throw new IOException(ie.toString());\n     } finally {\n+      if ((timeOutTimer!\u003dnull) \u0026\u0026 !timedOut.get()) {\n+        timeOutTimer.cancel();\n+      }\n       // close the input stream\n       try {\n         inReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the input stream\", ioe);\n       }\n-      if (!completed) {\n+      if (!completed.get()) {\n         errThread.interrupt();\n       }\n       try {\n         errReader.close();\n       } catch (IOException ioe) {\n         LOG.warn(\"Error while closing the error stream\", ioe);\n       }\n       process.destroy();\n       lastTime \u003d System.currentTimeMillis();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    Timer timeOutTimer \u003d null;\n    ShellTimeoutTimerTask timeoutTimerTask \u003d null;\n    timedOut \u003d new AtomicBoolean(false);\n    completed \u003d new AtomicBoolean(false);\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n    \n    process \u003d builder.start();\n    if (timeOutInterval \u003e 0) {\n      timeOutTimer \u003d new Timer();\n      timeoutTimerTask \u003d new ShellTimeoutTimerTask(\n          this);\n      //One time scheduling.\n      timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);\n    }\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) { }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode  \u003d process.waitFor();\n      try {\n        // make sure that the error thread exits\n        errThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while reading the error stream\", ie);\n      }\n      completed.set(true);\n      //the timeout thread handling\n      //taken care in finally block\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      if ((timeOutTimer!\u003dnull) \u0026\u0026 !timedOut.get()) {\n        timeOutTimer.cancel();\n      }\n      // close the input stream\n      try {\n        inReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed.get()) {\n        errThread.interrupt();\n      }\n      try {\n        errReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d System.currentTimeMillis();\n    }\n  }",
      "path": "src/java/org/apache/hadoop/util/Shell.java",
      "extendedDetails": {}
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,80 @@\n+  private void runCommand() throws IOException { \n+    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n+    boolean completed \u003d false;\n+    \n+    if (environment !\u003d null) {\n+      builder.environment().putAll(this.environment);\n+    }\n+    if (dir !\u003d null) {\n+      builder.directory(this.dir);\n+    }\n+    \n+    process \u003d builder.start();\n+    final BufferedReader errReader \u003d \n+            new BufferedReader(new InputStreamReader(process\n+                                                     .getErrorStream()));\n+    BufferedReader inReader \u003d \n+            new BufferedReader(new InputStreamReader(process\n+                                                     .getInputStream()));\n+    final StringBuffer errMsg \u003d new StringBuffer();\n+    \n+    // read error and input streams as this would free up the buffers\n+    // free the error stream buffer\n+    Thread errThread \u003d new Thread() {\n+      @Override\n+      public void run() {\n+        try {\n+          String line \u003d errReader.readLine();\n+          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n+            errMsg.append(line);\n+            errMsg.append(System.getProperty(\"line.separator\"));\n+            line \u003d errReader.readLine();\n+          }\n+        } catch(IOException ioe) {\n+          LOG.warn(\"Error reading the error stream\", ioe);\n+        }\n+      }\n+    };\n+    try {\n+      errThread.start();\n+    } catch (IllegalStateException ise) { }\n+    try {\n+      parseExecResult(inReader); // parse the output\n+      // clear the input stream buffer\n+      String line \u003d inReader.readLine();\n+      while(line !\u003d null) { \n+        line \u003d inReader.readLine();\n+      }\n+      // wait for the process to finish and check the exit code\n+      exitCode \u003d process.waitFor();\n+      try {\n+        // make sure that the error thread exits\n+        errThread.join();\n+      } catch (InterruptedException ie) {\n+        LOG.warn(\"Interrupted while reading the error stream\", ie);\n+      }\n+      completed \u003d true;\n+      if (exitCode !\u003d 0) {\n+        throw new ExitCodeException(exitCode, errMsg.toString());\n+      }\n+    } catch (InterruptedException ie) {\n+      throw new IOException(ie.toString());\n+    } finally {\n+      // close the input stream\n+      try {\n+        inReader.close();\n+      } catch (IOException ioe) {\n+        LOG.warn(\"Error while closing the input stream\", ioe);\n+      }\n+      if (!completed) {\n+        errThread.interrupt();\n+      }\n+      try {\n+        errReader.close();\n+      } catch (IOException ioe) {\n+        LOG.warn(\"Error while closing the error stream\", ioe);\n+      }\n+      process.destroy();\n+      lastTime \u003d System.currentTimeMillis();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void runCommand() throws IOException { \n    ProcessBuilder builder \u003d new ProcessBuilder(getExecString());\n    boolean completed \u003d false;\n    \n    if (environment !\u003d null) {\n      builder.environment().putAll(this.environment);\n    }\n    if (dir !\u003d null) {\n      builder.directory(this.dir);\n    }\n    \n    process \u003d builder.start();\n    final BufferedReader errReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getErrorStream()));\n    BufferedReader inReader \u003d \n            new BufferedReader(new InputStreamReader(process\n                                                     .getInputStream()));\n    final StringBuffer errMsg \u003d new StringBuffer();\n    \n    // read error and input streams as this would free up the buffers\n    // free the error stream buffer\n    Thread errThread \u003d new Thread() {\n      @Override\n      public void run() {\n        try {\n          String line \u003d errReader.readLine();\n          while((line !\u003d null) \u0026\u0026 !isInterrupted()) {\n            errMsg.append(line);\n            errMsg.append(System.getProperty(\"line.separator\"));\n            line \u003d errReader.readLine();\n          }\n        } catch(IOException ioe) {\n          LOG.warn(\"Error reading the error stream\", ioe);\n        }\n      }\n    };\n    try {\n      errThread.start();\n    } catch (IllegalStateException ise) { }\n    try {\n      parseExecResult(inReader); // parse the output\n      // clear the input stream buffer\n      String line \u003d inReader.readLine();\n      while(line !\u003d null) { \n        line \u003d inReader.readLine();\n      }\n      // wait for the process to finish and check the exit code\n      exitCode \u003d process.waitFor();\n      try {\n        // make sure that the error thread exits\n        errThread.join();\n      } catch (InterruptedException ie) {\n        LOG.warn(\"Interrupted while reading the error stream\", ie);\n      }\n      completed \u003d true;\n      if (exitCode !\u003d 0) {\n        throw new ExitCodeException(exitCode, errMsg.toString());\n      }\n    } catch (InterruptedException ie) {\n      throw new IOException(ie.toString());\n    } finally {\n      // close the input stream\n      try {\n        inReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the input stream\", ioe);\n      }\n      if (!completed) {\n        errThread.interrupt();\n      }\n      try {\n        errReader.close();\n      } catch (IOException ioe) {\n        LOG.warn(\"Error while closing the error stream\", ioe);\n      }\n      process.destroy();\n      lastTime \u003d System.currentTimeMillis();\n    }\n  }",
      "path": "src/java/org/apache/hadoop/util/Shell.java"
    }
  }
}