{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StageAllocatorLowCostAligned.java",
  "functionName": "computeStageAllocation",
  "functionId": "computeStageAllocation___plan-Plan__planLoads-RLESparseResourceAllocation__planModifications-RLESparseResourceAllocation__rr-ReservationRequest__stageArrival-long__stageDeadline-long__period-long__user-String__oldId-ReservationId",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
  "functionStartLine": 70,
  "functionEndLine": 214,
  "numCommitsSeen": 23,
  "timeTaken": 9448,
  "changeHistory": [
    "e6e614e380ed1d746973b50f666a9c40d272073e",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
    "e3345e985bff93c6c74a76747e45376c6027f42c",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
    "a3a615eeab8c14ccdc548311097e62a916963dc5",
    "742632e346604fd2b263bd42367165638fcf2416",
    "da1016365aba1cee9c06771ab142d077379f27af",
    "156f24ead00436faad5d4aeef327a546392cd265",
    "0e602fa3a1529134214452fba10a90307d9c2072",
    "f66ffcf832235e0da0bb050fff08e248b547c360"
  ],
  "changeHistoryShort": {
    "e6e614e380ed1d746973b50f666a9c40d272073e": "Ymultichange(Yparameterchange,Ybodychange)",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": "Ybodychange",
    "e3345e985bff93c6c74a76747e45376c6027f42c": "Ybodychange",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": "Ybodychange",
    "a3a615eeab8c14ccdc548311097e62a916963dc5": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "742632e346604fd2b263bd42367165638fcf2416": "Ymultichange(Yparameterchange,Ybodychange)",
    "da1016365aba1cee9c06771ab142d077379f27af": "Ybodychange",
    "156f24ead00436faad5d4aeef327a546392cd265": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange,Yrename,Yparameterchange)",
    "0e602fa3a1529134214452fba10a90307d9c2072": "Ybodychange",
    "f66ffcf832235e0da0bb050fff08e248b547c360": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e6e614e380ed1d746973b50f666a9c40d272073e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
      "commitDate": "04/10/17 7:28 PM",
      "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
      "commitAuthor": "Subru Krishnan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
          "commitDate": "04/10/17 7:28 PM",
          "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "06/09/17 4:46 PM",
          "commitNameOld": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 28.11,
          "commitsBetweenForRepo": 262,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,145 +1,145 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageArrival, long stageDeadline, String user, ReservationId oldId)\n-      throws PlanningException {\n+      long stageArrival, long stageDeadline, long period, String user,\n+      ReservationId oldId) throws PlanningException {\n \n     // Initialize\n     ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n     Resource capacity \u003d plan.getTotalCapacity();\n \n     RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n-        user, oldId, stageArrival, stageDeadline, 0);\n+        user, oldId, stageArrival, stageDeadline, period);\n \n     long step \u003d plan.getStep();\n \n     // Create allocationRequestsearlies\n     RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Initialize parameters\n     long duration \u003d stepRoundUp(rr.getDuration(), step);\n     int windowSizeInDurations \u003d\n         (int) ((stageDeadline - stageArrival) / duration);\n     int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n     int numContainersPerGang \u003d rr.getConcurrency();\n     Resource gang \u003d\n         Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n     // Set maxGangsPerUnit\n     int maxGangsPerUnit \u003d (int) Math\n         .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n     maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n     // If window size is too small, return null\n     if (windowSizeInDurations \u003c\u003d 0) {\n       return null;\n     }\n \n     final int preferLeft \u003d allocateLeft ? 1 : -1;\n \n     // Initialize tree sorted by costs\n     TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n         new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n           @Override\n           public int compare(DurationInterval val1, DurationInterval val2) {\n \n             int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n             if (cmp !\u003d 0) {\n               return cmp;\n             }\n \n             return preferLeft\n                 * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n         });\n \n     List\u003cLong\u003e intervalEndTimes \u003d\n         computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n \n     // Add durationIntervals that end at (endTime - n*duration) for some n.\n     for (long intervalEnd : intervalEndTimes) {\n \n       long intervalStart \u003d intervalEnd - duration;\n \n       // Get duration interval [intervalStart,intervalEnd)\n       DurationInterval durationInterval \u003d\n           getDurationInterval(intervalStart, intervalEnd, planLoads,\n               planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // If the interval can fit a gang, add it to the tree\n       if (durationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n     // Allocate\n     int remainingGangs \u003d totalGangs;\n     while (remainingGangs \u003e 0) {\n \n       // If no durationInterval can fit a gang, break and return null\n       if (durationIntervalsSortedByCost.isEmpty()) {\n         break;\n       }\n \n       // Get best duration interval\n       DurationInterval bestDurationInterval \u003d\n           durationIntervalsSortedByCost.first();\n       int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n       numGangsToAllocate \u003d\n           Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n       // Add it\n       remainingGangs -\u003d numGangsToAllocate;\n \n       ReservationInterval reservationInt \u003d\n           new ReservationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getEndTime());\n \n       Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n           rr.getConcurrency() * numGangsToAllocate);\n \n       planModifications.addInterval(reservationInt, reservationRes);\n       allocationRequests.addInterval(reservationInt, reservationRes);\n \n       // Remove from tree\n       durationIntervalsSortedByCost.remove(bestDurationInterval);\n \n       // Get updated interval\n       DurationInterval updatedDurationInterval \u003d\n           getDurationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getStartTime() + duration, planLoads,\n               planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // Add to tree, if possible\n       if (updatedDurationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(updatedDurationInterval);\n       }\n \n     }\n \n     // Get the final allocation\n     Map\u003cReservationInterval, Resource\u003e allocations \u003d\n         allocationRequests.toIntervalMap();\n \n     // If no gangs are left to place we succeed and return the allocation\n     if (remainingGangs \u003c\u003d 0) {\n       return allocations;\n     } else {\n \n       // If we are here is because we did not manage to satisfy this\n       // request.\n       // We remove unwanted side-effect from planModifications (needed for\n       // ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n           .entrySet()) {\n \n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n \n       }\n       // Return null to signal failure in this allocation\n       return null;\n \n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageArrival, long stageDeadline, long period, String user,\n      ReservationId oldId) throws PlanningException {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n\n    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n        user, oldId, stageArrival, stageDeadline, period);\n\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageArrival) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d (int) Math\n        .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    final int preferLeft \u003d allocateLeft ? 1 : -1;\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return preferLeft\n                * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    List\u003cLong\u003e intervalEndTimes \u003d\n        computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd : intervalEndTimes) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n      numGangsToAllocate \u003d\n          Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n          rr.getConcurrency() * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this\n      // request.\n      // We remove unwanted side-effect from planModifications (needed for\n      // ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n          .entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {
            "oldValue": "[plan-Plan, planLoads-RLESparseResourceAllocation, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageArrival-long, stageDeadline-long, user-String, oldId-ReservationId]",
            "newValue": "[plan-Plan, planLoads-RLESparseResourceAllocation, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageArrival-long, stageDeadline-long, period-long, user-String, oldId-ReservationId]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
          "commitDate": "04/10/17 7:28 PM",
          "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "06/09/17 4:46 PM",
          "commitNameOld": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 28.11,
          "commitsBetweenForRepo": 262,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,145 +1,145 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageArrival, long stageDeadline, String user, ReservationId oldId)\n-      throws PlanningException {\n+      long stageArrival, long stageDeadline, long period, String user,\n+      ReservationId oldId) throws PlanningException {\n \n     // Initialize\n     ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n     Resource capacity \u003d plan.getTotalCapacity();\n \n     RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n-        user, oldId, stageArrival, stageDeadline, 0);\n+        user, oldId, stageArrival, stageDeadline, period);\n \n     long step \u003d plan.getStep();\n \n     // Create allocationRequestsearlies\n     RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Initialize parameters\n     long duration \u003d stepRoundUp(rr.getDuration(), step);\n     int windowSizeInDurations \u003d\n         (int) ((stageDeadline - stageArrival) / duration);\n     int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n     int numContainersPerGang \u003d rr.getConcurrency();\n     Resource gang \u003d\n         Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n     // Set maxGangsPerUnit\n     int maxGangsPerUnit \u003d (int) Math\n         .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n     maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n     // If window size is too small, return null\n     if (windowSizeInDurations \u003c\u003d 0) {\n       return null;\n     }\n \n     final int preferLeft \u003d allocateLeft ? 1 : -1;\n \n     // Initialize tree sorted by costs\n     TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n         new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n           @Override\n           public int compare(DurationInterval val1, DurationInterval val2) {\n \n             int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n             if (cmp !\u003d 0) {\n               return cmp;\n             }\n \n             return preferLeft\n                 * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n         });\n \n     List\u003cLong\u003e intervalEndTimes \u003d\n         computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n \n     // Add durationIntervals that end at (endTime - n*duration) for some n.\n     for (long intervalEnd : intervalEndTimes) {\n \n       long intervalStart \u003d intervalEnd - duration;\n \n       // Get duration interval [intervalStart,intervalEnd)\n       DurationInterval durationInterval \u003d\n           getDurationInterval(intervalStart, intervalEnd, planLoads,\n               planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // If the interval can fit a gang, add it to the tree\n       if (durationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n     // Allocate\n     int remainingGangs \u003d totalGangs;\n     while (remainingGangs \u003e 0) {\n \n       // If no durationInterval can fit a gang, break and return null\n       if (durationIntervalsSortedByCost.isEmpty()) {\n         break;\n       }\n \n       // Get best duration interval\n       DurationInterval bestDurationInterval \u003d\n           durationIntervalsSortedByCost.first();\n       int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n       numGangsToAllocate \u003d\n           Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n       // Add it\n       remainingGangs -\u003d numGangsToAllocate;\n \n       ReservationInterval reservationInt \u003d\n           new ReservationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getEndTime());\n \n       Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n           rr.getConcurrency() * numGangsToAllocate);\n \n       planModifications.addInterval(reservationInt, reservationRes);\n       allocationRequests.addInterval(reservationInt, reservationRes);\n \n       // Remove from tree\n       durationIntervalsSortedByCost.remove(bestDurationInterval);\n \n       // Get updated interval\n       DurationInterval updatedDurationInterval \u003d\n           getDurationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getStartTime() + duration, planLoads,\n               planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // Add to tree, if possible\n       if (updatedDurationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(updatedDurationInterval);\n       }\n \n     }\n \n     // Get the final allocation\n     Map\u003cReservationInterval, Resource\u003e allocations \u003d\n         allocationRequests.toIntervalMap();\n \n     // If no gangs are left to place we succeed and return the allocation\n     if (remainingGangs \u003c\u003d 0) {\n       return allocations;\n     } else {\n \n       // If we are here is because we did not manage to satisfy this\n       // request.\n       // We remove unwanted side-effect from planModifications (needed for\n       // ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n           .entrySet()) {\n \n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n \n       }\n       // Return null to signal failure in this allocation\n       return null;\n \n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageArrival, long stageDeadline, long period, String user,\n      ReservationId oldId) throws PlanningException {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n\n    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n        user, oldId, stageArrival, stageDeadline, period);\n\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageArrival) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d (int) Math\n        .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    final int preferLeft \u003d allocateLeft ? 1 : -1;\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return preferLeft\n                * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    List\u003cLong\u003e intervalEndTimes \u003d\n        computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd : intervalEndTimes) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n      numGangsToAllocate \u003d\n          Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n          rr.getConcurrency() * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this\n      // request.\n      // We remove unwanted side-effect from planModifications (needed for\n      // ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n          .entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {}
        }
      ]
    },
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5328. Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "06/09/17 4:46 PM",
      "commitName": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "06/09/17 4:39 PM",
      "commitNameOld": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,145 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageArrival, long stageDeadline, String user, ReservationId oldId)\n       throws PlanningException {\n \n     // Initialize\n     ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n     Resource capacity \u003d plan.getTotalCapacity();\n \n-    RLESparseResourceAllocation netRLERes \u003d plan\n-        .getAvailableResourceOverTime(user, oldId, stageArrival, stageDeadline);\n+    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n+        user, oldId, stageArrival, stageDeadline, 0);\n \n     long step \u003d plan.getStep();\n \n     // Create allocationRequestsearlies\n     RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Initialize parameters\n     long duration \u003d stepRoundUp(rr.getDuration(), step);\n     int windowSizeInDurations \u003d\n         (int) ((stageDeadline - stageArrival) / duration);\n     int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n     int numContainersPerGang \u003d rr.getConcurrency();\n     Resource gang \u003d\n         Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n     // Set maxGangsPerUnit\n     int maxGangsPerUnit \u003d (int) Math\n         .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n     maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n     // If window size is too small, return null\n     if (windowSizeInDurations \u003c\u003d 0) {\n       return null;\n     }\n \n     final int preferLeft \u003d allocateLeft ? 1 : -1;\n \n     // Initialize tree sorted by costs\n     TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n         new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n           @Override\n           public int compare(DurationInterval val1, DurationInterval val2) {\n \n             int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n             if (cmp !\u003d 0) {\n               return cmp;\n             }\n \n             return preferLeft\n                 * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n         });\n \n     List\u003cLong\u003e intervalEndTimes \u003d\n         computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n \n     // Add durationIntervals that end at (endTime - n*duration) for some n.\n     for (long intervalEnd : intervalEndTimes) {\n \n       long intervalStart \u003d intervalEnd - duration;\n \n       // Get duration interval [intervalStart,intervalEnd)\n       DurationInterval durationInterval \u003d\n           getDurationInterval(intervalStart, intervalEnd, planLoads,\n               planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // If the interval can fit a gang, add it to the tree\n       if (durationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n     // Allocate\n     int remainingGangs \u003d totalGangs;\n     while (remainingGangs \u003e 0) {\n \n       // If no durationInterval can fit a gang, break and return null\n       if (durationIntervalsSortedByCost.isEmpty()) {\n         break;\n       }\n \n       // Get best duration interval\n       DurationInterval bestDurationInterval \u003d\n           durationIntervalsSortedByCost.first();\n       int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n       numGangsToAllocate \u003d\n           Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n       // Add it\n       remainingGangs -\u003d numGangsToAllocate;\n \n       ReservationInterval reservationInt \u003d\n           new ReservationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getEndTime());\n \n       Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n           rr.getConcurrency() * numGangsToAllocate);\n \n       planModifications.addInterval(reservationInt, reservationRes);\n       allocationRequests.addInterval(reservationInt, reservationRes);\n \n       // Remove from tree\n       durationIntervalsSortedByCost.remove(bestDurationInterval);\n \n       // Get updated interval\n       DurationInterval updatedDurationInterval \u003d\n           getDurationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getStartTime() + duration, planLoads,\n               planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // Add to tree, if possible\n       if (updatedDurationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(updatedDurationInterval);\n       }\n \n     }\n \n     // Get the final allocation\n     Map\u003cReservationInterval, Resource\u003e allocations \u003d\n         allocationRequests.toIntervalMap();\n \n     // If no gangs are left to place we succeed and return the allocation\n     if (remainingGangs \u003c\u003d 0) {\n       return allocations;\n     } else {\n \n       // If we are here is because we did not manage to satisfy this\n       // request.\n       // We remove unwanted side-effect from planModifications (needed for\n       // ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n           .entrySet()) {\n \n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n \n       }\n       // Return null to signal failure in this allocation\n       return null;\n \n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageArrival, long stageDeadline, String user, ReservationId oldId)\n      throws PlanningException {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n\n    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n        user, oldId, stageArrival, stageDeadline, 0);\n\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageArrival) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d (int) Math\n        .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    final int preferLeft \u003d allocateLeft ? 1 : -1;\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return preferLeft\n                * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    List\u003cLong\u003e intervalEndTimes \u003d\n        computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd : intervalEndTimes) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n      numGangsToAllocate \u003d\n          Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n          rr.getConcurrency() * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this\n      // request.\n      // We remove unwanted side-effect from planModifications (needed for\n      // ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n          .entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
      "extendedDetails": {}
    },
    "e3345e985bff93c6c74a76747e45376c6027f42c": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\"\n\nThis reverts commit 7996eca7dcfaa1bdf970e32022274f2699bef8a1.\n",
      "commitDate": "06/09/17 4:39 PM",
      "commitName": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/09/17 3:16 PM",
      "commitNameOld": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 5.06,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,145 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageArrival, long stageDeadline, String user, ReservationId oldId)\n       throws PlanningException {\n \n     // Initialize\n     ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n     Resource capacity \u003d plan.getTotalCapacity();\n \n-    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n-        user, oldId, stageArrival, stageDeadline, 0);\n+    RLESparseResourceAllocation netRLERes \u003d plan\n+        .getAvailableResourceOverTime(user, oldId, stageArrival, stageDeadline);\n \n     long step \u003d plan.getStep();\n \n     // Create allocationRequestsearlies\n     RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Initialize parameters\n     long duration \u003d stepRoundUp(rr.getDuration(), step);\n     int windowSizeInDurations \u003d\n         (int) ((stageDeadline - stageArrival) / duration);\n     int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n     int numContainersPerGang \u003d rr.getConcurrency();\n     Resource gang \u003d\n         Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n     // Set maxGangsPerUnit\n     int maxGangsPerUnit \u003d (int) Math\n         .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n     maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n     // If window size is too small, return null\n     if (windowSizeInDurations \u003c\u003d 0) {\n       return null;\n     }\n \n     final int preferLeft \u003d allocateLeft ? 1 : -1;\n \n     // Initialize tree sorted by costs\n     TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n         new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n           @Override\n           public int compare(DurationInterval val1, DurationInterval val2) {\n \n             int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n             if (cmp !\u003d 0) {\n               return cmp;\n             }\n \n             return preferLeft\n                 * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n         });\n \n     List\u003cLong\u003e intervalEndTimes \u003d\n         computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n \n     // Add durationIntervals that end at (endTime - n*duration) for some n.\n     for (long intervalEnd : intervalEndTimes) {\n \n       long intervalStart \u003d intervalEnd - duration;\n \n       // Get duration interval [intervalStart,intervalEnd)\n       DurationInterval durationInterval \u003d\n           getDurationInterval(intervalStart, intervalEnd, planLoads,\n               planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // If the interval can fit a gang, add it to the tree\n       if (durationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n     // Allocate\n     int remainingGangs \u003d totalGangs;\n     while (remainingGangs \u003e 0) {\n \n       // If no durationInterval can fit a gang, break and return null\n       if (durationIntervalsSortedByCost.isEmpty()) {\n         break;\n       }\n \n       // Get best duration interval\n       DurationInterval bestDurationInterval \u003d\n           durationIntervalsSortedByCost.first();\n       int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n       numGangsToAllocate \u003d\n           Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n       // Add it\n       remainingGangs -\u003d numGangsToAllocate;\n \n       ReservationInterval reservationInt \u003d\n           new ReservationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getEndTime());\n \n       Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n           rr.getConcurrency() * numGangsToAllocate);\n \n       planModifications.addInterval(reservationInt, reservationRes);\n       allocationRequests.addInterval(reservationInt, reservationRes);\n \n       // Remove from tree\n       durationIntervalsSortedByCost.remove(bestDurationInterval);\n \n       // Get updated interval\n       DurationInterval updatedDurationInterval \u003d\n           getDurationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getStartTime() + duration, planLoads,\n               planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // Add to tree, if possible\n       if (updatedDurationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(updatedDurationInterval);\n       }\n \n     }\n \n     // Get the final allocation\n     Map\u003cReservationInterval, Resource\u003e allocations \u003d\n         allocationRequests.toIntervalMap();\n \n     // If no gangs are left to place we succeed and return the allocation\n     if (remainingGangs \u003c\u003d 0) {\n       return allocations;\n     } else {\n \n       // If we are here is because we did not manage to satisfy this\n       // request.\n       // We remove unwanted side-effect from planModifications (needed for\n       // ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n           .entrySet()) {\n \n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n \n       }\n       // Return null to signal failure in this allocation\n       return null;\n \n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageArrival, long stageDeadline, String user, ReservationId oldId)\n      throws PlanningException {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n\n    RLESparseResourceAllocation netRLERes \u003d plan\n        .getAvailableResourceOverTime(user, oldId, stageArrival, stageDeadline);\n\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageArrival) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d (int) Math\n        .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    final int preferLeft \u003d allocateLeft ? 1 : -1;\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return preferLeft\n                * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    List\u003cLong\u003e intervalEndTimes \u003d\n        computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd : intervalEndTimes) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n      numGangsToAllocate \u003d\n          Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n          rr.getConcurrency() * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this\n      // request.\n      // We remove unwanted side-effect from planModifications (needed for\n      // ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n          .entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
      "extendedDetails": {}
    },
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": {
      "type": "Ybodychange",
      "commitMessage": "Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "01/09/17 3:16 PM",
      "commitName": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/05/17 4:01 PM",
      "commitNameOld": "a3a615eeab8c14ccdc548311097e62a916963dc5",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 122.97,
      "commitsBetweenForRepo": 775,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,145 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageArrival, long stageDeadline, String user, ReservationId oldId)\n       throws PlanningException {\n \n     // Initialize\n     ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n     Resource capacity \u003d plan.getTotalCapacity();\n \n-    RLESparseResourceAllocation netRLERes \u003d plan\n-        .getAvailableResourceOverTime(user, oldId, stageArrival, stageDeadline);\n+    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n+        user, oldId, stageArrival, stageDeadline, 0);\n \n     long step \u003d plan.getStep();\n \n     // Create allocationRequestsearlies\n     RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Initialize parameters\n     long duration \u003d stepRoundUp(rr.getDuration(), step);\n     int windowSizeInDurations \u003d\n         (int) ((stageDeadline - stageArrival) / duration);\n     int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n     int numContainersPerGang \u003d rr.getConcurrency();\n     Resource gang \u003d\n         Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n     // Set maxGangsPerUnit\n     int maxGangsPerUnit \u003d (int) Math\n         .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n     maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n     // If window size is too small, return null\n     if (windowSizeInDurations \u003c\u003d 0) {\n       return null;\n     }\n \n     final int preferLeft \u003d allocateLeft ? 1 : -1;\n \n     // Initialize tree sorted by costs\n     TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n         new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n           @Override\n           public int compare(DurationInterval val1, DurationInterval val2) {\n \n             int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n             if (cmp !\u003d 0) {\n               return cmp;\n             }\n \n             return preferLeft\n                 * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n         });\n \n     List\u003cLong\u003e intervalEndTimes \u003d\n         computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n \n     // Add durationIntervals that end at (endTime - n*duration) for some n.\n     for (long intervalEnd : intervalEndTimes) {\n \n       long intervalStart \u003d intervalEnd - duration;\n \n       // Get duration interval [intervalStart,intervalEnd)\n       DurationInterval durationInterval \u003d\n           getDurationInterval(intervalStart, intervalEnd, planLoads,\n               planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // If the interval can fit a gang, add it to the tree\n       if (durationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n     // Allocate\n     int remainingGangs \u003d totalGangs;\n     while (remainingGangs \u003e 0) {\n \n       // If no durationInterval can fit a gang, break and return null\n       if (durationIntervalsSortedByCost.isEmpty()) {\n         break;\n       }\n \n       // Get best duration interval\n       DurationInterval bestDurationInterval \u003d\n           durationIntervalsSortedByCost.first();\n       int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n       numGangsToAllocate \u003d\n           Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n       // Add it\n       remainingGangs -\u003d numGangsToAllocate;\n \n       ReservationInterval reservationInt \u003d\n           new ReservationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getEndTime());\n \n       Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n           rr.getConcurrency() * numGangsToAllocate);\n \n       planModifications.addInterval(reservationInt, reservationRes);\n       allocationRequests.addInterval(reservationInt, reservationRes);\n \n       // Remove from tree\n       durationIntervalsSortedByCost.remove(bestDurationInterval);\n \n       // Get updated interval\n       DurationInterval updatedDurationInterval \u003d\n           getDurationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getStartTime() + duration, planLoads,\n               planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // Add to tree, if possible\n       if (updatedDurationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(updatedDurationInterval);\n       }\n \n     }\n \n     // Get the final allocation\n     Map\u003cReservationInterval, Resource\u003e allocations \u003d\n         allocationRequests.toIntervalMap();\n \n     // If no gangs are left to place we succeed and return the allocation\n     if (remainingGangs \u003c\u003d 0) {\n       return allocations;\n     } else {\n \n       // If we are here is because we did not manage to satisfy this\n       // request.\n       // We remove unwanted side-effect from planModifications (needed for\n       // ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n           .entrySet()) {\n \n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n \n       }\n       // Return null to signal failure in this allocation\n       return null;\n \n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageArrival, long stageDeadline, String user, ReservationId oldId)\n      throws PlanningException {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n\n    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n        user, oldId, stageArrival, stageDeadline, 0);\n\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageArrival) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d (int) Math\n        .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    final int preferLeft \u003d allocateLeft ? 1 : -1;\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return preferLeft\n                * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    List\u003cLong\u003e intervalEndTimes \u003d\n        computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd : intervalEndTimes) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n      numGangsToAllocate \u003d\n          Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n          rr.getConcurrency() * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this\n      // request.\n      // We remove unwanted side-effect from planModifications (needed for\n      // ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n          .entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
      "extendedDetails": {}
    },
    "a3a615eeab8c14ccdc548311097e62a916963dc5": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-4359. Update LowCost agents logic to take advantage of YARN-4358. (Jonathan Yaniv and Ishai Menache via Subru).\n",
      "commitDate": "01/05/17 4:01 PM",
      "commitName": "a3a615eeab8c14ccdc548311097e62a916963dc5",
      "commitAuthor": "Subru Krishnan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4359. Update LowCost agents logic to take advantage of YARN-4358. (Jonathan Yaniv and Ishai Menache via Subru).\n",
          "commitDate": "01/05/17 4:01 PM",
          "commitName": "a3a615eeab8c14ccdc548311097e62a916963dc5",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "05/12/15 9:26 PM",
          "commitNameOld": "742632e346604fd2b263bd42367165638fcf2416",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 512.73,
          "commitsBetweenForRepo": 3348,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,137 +1,145 @@\n-  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n-      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n+      RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageEarliestStart, long stageDeadline, String user,\n-      ReservationId oldId) {\n+      long stageArrival, long stageDeadline, String user, ReservationId oldId)\n+      throws PlanningException {\n \n     // Initialize\n     ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n     Resource capacity \u003d plan.getTotalCapacity();\n+\n+    RLESparseResourceAllocation netRLERes \u003d plan\n+        .getAvailableResourceOverTime(user, oldId, stageArrival, stageDeadline);\n+\n     long step \u003d plan.getStep();\n \n     // Create allocationRequestsearlies\n     RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Initialize parameters\n     long duration \u003d stepRoundUp(rr.getDuration(), step);\n     int windowSizeInDurations \u003d\n-        (int) ((stageDeadline - stageEarliestStart) / duration);\n+        (int) ((stageDeadline - stageArrival) / duration);\n     int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n     int numContainersPerGang \u003d rr.getConcurrency();\n     Resource gang \u003d\n         Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n     // Set maxGangsPerUnit\n-    int maxGangsPerUnit \u003d\n-        (int) Math.max(\n-            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n+    int maxGangsPerUnit \u003d (int) Math\n+        .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n     maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n     // If window size is too small, return null\n     if (windowSizeInDurations \u003c\u003d 0) {\n       return null;\n     }\n \n+    final int preferLeft \u003d allocateLeft ? 1 : -1;\n+\n     // Initialize tree sorted by costs\n     TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n         new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n           @Override\n           public int compare(DurationInterval val1, DurationInterval val2) {\n \n             int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n             if (cmp !\u003d 0) {\n               return cmp;\n             }\n \n-            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n+            return preferLeft\n+                * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n         });\n \n+    List\u003cLong\u003e intervalEndTimes \u003d\n+        computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n+\n     // Add durationIntervals that end at (endTime - n*duration) for some n.\n-    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n-        + duration; intervalEnd -\u003d duration) {\n+    for (long intervalEnd : intervalEndTimes) {\n \n       long intervalStart \u003d intervalEnd - duration;\n \n       // Get duration interval [intervalStart,intervalEnd)\n       DurationInterval durationInterval \u003d\n           getDurationInterval(intervalStart, intervalEnd, planLoads,\n-              planModifications, capacity, resCalc, step);\n+              planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // If the interval can fit a gang, add it to the tree\n-      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n+      if (durationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n     // Allocate\n     int remainingGangs \u003d totalGangs;\n     while (remainingGangs \u003e 0) {\n \n       // If no durationInterval can fit a gang, break and return null\n       if (durationIntervalsSortedByCost.isEmpty()) {\n         break;\n       }\n \n       // Get best duration interval\n       DurationInterval bestDurationInterval \u003d\n           durationIntervalsSortedByCost.first();\n       int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n       numGangsToAllocate \u003d\n-          Math.min(numGangsToAllocate,\n-              bestDurationInterval.numCanFit(gang, capacity, resCalc));\n+          Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n       // Add it\n       remainingGangs -\u003d numGangsToAllocate;\n \n       ReservationInterval reservationInt \u003d\n           new ReservationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getEndTime());\n \n-      Resource reservationRes \u003d\n-          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n-              * numGangsToAllocate);\n+      Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n+          rr.getConcurrency() * numGangsToAllocate);\n \n       planModifications.addInterval(reservationInt, reservationRes);\n       allocationRequests.addInterval(reservationInt, reservationRes);\n \n       // Remove from tree\n       durationIntervalsSortedByCost.remove(bestDurationInterval);\n \n       // Get updated interval\n       DurationInterval updatedDurationInterval \u003d\n           getDurationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getStartTime() + duration, planLoads,\n-              planModifications, capacity, resCalc, step);\n+              planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // Add to tree, if possible\n-      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n+      if (updatedDurationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(updatedDurationInterval);\n       }\n \n     }\n \n     // Get the final allocation\n     Map\u003cReservationInterval, Resource\u003e allocations \u003d\n         allocationRequests.toIntervalMap();\n \n     // If no gangs are left to place we succeed and return the allocation\n     if (remainingGangs \u003c\u003d 0) {\n       return allocations;\n     } else {\n \n-      // If we are here is because we did not manage to satisfy this request.\n-      // We remove unwanted side-effect from planModifications (needed for ANY).\n-      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n-          : allocations.entrySet()) {\n+      // If we are here is because we did not manage to satisfy this\n+      // request.\n+      // We remove unwanted side-effect from planModifications (needed for\n+      // ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n+          .entrySet()) {\n \n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n \n       }\n       // Return null to signal failure in this allocation\n       return null;\n \n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageArrival, long stageDeadline, String user, ReservationId oldId)\n      throws PlanningException {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n\n    RLESparseResourceAllocation netRLERes \u003d plan\n        .getAvailableResourceOverTime(user, oldId, stageArrival, stageDeadline);\n\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageArrival) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d (int) Math\n        .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    final int preferLeft \u003d allocateLeft ? 1 : -1;\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return preferLeft\n                * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    List\u003cLong\u003e intervalEndTimes \u003d\n        computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd : intervalEndTimes) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n      numGangsToAllocate \u003d\n          Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n          rr.getConcurrency() * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this\n      // request.\n      // We remove unwanted side-effect from planModifications (needed for\n      // ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n          .entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {
            "oldValue": "[plan-Plan, planLoads-Map\u003cLong,Resource\u003e, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long, user-String, oldId-ReservationId]",
            "newValue": "[plan-Plan, planLoads-RLESparseResourceAllocation, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageArrival-long, stageDeadline-long, user-String, oldId-ReservationId]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-4359. Update LowCost agents logic to take advantage of YARN-4358. (Jonathan Yaniv and Ishai Menache via Subru).\n",
          "commitDate": "01/05/17 4:01 PM",
          "commitName": "a3a615eeab8c14ccdc548311097e62a916963dc5",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "05/12/15 9:26 PM",
          "commitNameOld": "742632e346604fd2b263bd42367165638fcf2416",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 512.73,
          "commitsBetweenForRepo": 3348,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,137 +1,145 @@\n-  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n-      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n+      RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageEarliestStart, long stageDeadline, String user,\n-      ReservationId oldId) {\n+      long stageArrival, long stageDeadline, String user, ReservationId oldId)\n+      throws PlanningException {\n \n     // Initialize\n     ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n     Resource capacity \u003d plan.getTotalCapacity();\n+\n+    RLESparseResourceAllocation netRLERes \u003d plan\n+        .getAvailableResourceOverTime(user, oldId, stageArrival, stageDeadline);\n+\n     long step \u003d plan.getStep();\n \n     // Create allocationRequestsearlies\n     RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Initialize parameters\n     long duration \u003d stepRoundUp(rr.getDuration(), step);\n     int windowSizeInDurations \u003d\n-        (int) ((stageDeadline - stageEarliestStart) / duration);\n+        (int) ((stageDeadline - stageArrival) / duration);\n     int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n     int numContainersPerGang \u003d rr.getConcurrency();\n     Resource gang \u003d\n         Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n     // Set maxGangsPerUnit\n-    int maxGangsPerUnit \u003d\n-        (int) Math.max(\n-            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n+    int maxGangsPerUnit \u003d (int) Math\n+        .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n     maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n     // If window size is too small, return null\n     if (windowSizeInDurations \u003c\u003d 0) {\n       return null;\n     }\n \n+    final int preferLeft \u003d allocateLeft ? 1 : -1;\n+\n     // Initialize tree sorted by costs\n     TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n         new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n           @Override\n           public int compare(DurationInterval val1, DurationInterval val2) {\n \n             int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n             if (cmp !\u003d 0) {\n               return cmp;\n             }\n \n-            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n+            return preferLeft\n+                * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n         });\n \n+    List\u003cLong\u003e intervalEndTimes \u003d\n+        computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n+\n     // Add durationIntervals that end at (endTime - n*duration) for some n.\n-    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n-        + duration; intervalEnd -\u003d duration) {\n+    for (long intervalEnd : intervalEndTimes) {\n \n       long intervalStart \u003d intervalEnd - duration;\n \n       // Get duration interval [intervalStart,intervalEnd)\n       DurationInterval durationInterval \u003d\n           getDurationInterval(intervalStart, intervalEnd, planLoads,\n-              planModifications, capacity, resCalc, step);\n+              planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // If the interval can fit a gang, add it to the tree\n-      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n+      if (durationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n     // Allocate\n     int remainingGangs \u003d totalGangs;\n     while (remainingGangs \u003e 0) {\n \n       // If no durationInterval can fit a gang, break and return null\n       if (durationIntervalsSortedByCost.isEmpty()) {\n         break;\n       }\n \n       // Get best duration interval\n       DurationInterval bestDurationInterval \u003d\n           durationIntervalsSortedByCost.first();\n       int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n       numGangsToAllocate \u003d\n-          Math.min(numGangsToAllocate,\n-              bestDurationInterval.numCanFit(gang, capacity, resCalc));\n+          Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n       // Add it\n       remainingGangs -\u003d numGangsToAllocate;\n \n       ReservationInterval reservationInt \u003d\n           new ReservationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getEndTime());\n \n-      Resource reservationRes \u003d\n-          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n-              * numGangsToAllocate);\n+      Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n+          rr.getConcurrency() * numGangsToAllocate);\n \n       planModifications.addInterval(reservationInt, reservationRes);\n       allocationRequests.addInterval(reservationInt, reservationRes);\n \n       // Remove from tree\n       durationIntervalsSortedByCost.remove(bestDurationInterval);\n \n       // Get updated interval\n       DurationInterval updatedDurationInterval \u003d\n           getDurationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getStartTime() + duration, planLoads,\n-              planModifications, capacity, resCalc, step);\n+              planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // Add to tree, if possible\n-      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n+      if (updatedDurationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(updatedDurationInterval);\n       }\n \n     }\n \n     // Get the final allocation\n     Map\u003cReservationInterval, Resource\u003e allocations \u003d\n         allocationRequests.toIntervalMap();\n \n     // If no gangs are left to place we succeed and return the allocation\n     if (remainingGangs \u003c\u003d 0) {\n       return allocations;\n     } else {\n \n-      // If we are here is because we did not manage to satisfy this request.\n-      // We remove unwanted side-effect from planModifications (needed for ANY).\n-      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n-          : allocations.entrySet()) {\n+      // If we are here is because we did not manage to satisfy this\n+      // request.\n+      // We remove unwanted side-effect from planModifications (needed for\n+      // ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n+          .entrySet()) {\n \n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n \n       }\n       // Return null to signal failure in this allocation\n       return null;\n \n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageArrival, long stageDeadline, String user, ReservationId oldId)\n      throws PlanningException {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n\n    RLESparseResourceAllocation netRLERes \u003d plan\n        .getAvailableResourceOverTime(user, oldId, stageArrival, stageDeadline);\n\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageArrival) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d (int) Math\n        .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    final int preferLeft \u003d allocateLeft ? 1 : -1;\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return preferLeft\n                * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    List\u003cLong\u003e intervalEndTimes \u003d\n        computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd : intervalEndTimes) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n      numGangsToAllocate \u003d\n          Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n          rr.getConcurrency() * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this\n      // request.\n      // We remove unwanted side-effect from planModifications (needed for\n      // ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n          .entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[PlanningException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4359. Update LowCost agents logic to take advantage of YARN-4358. (Jonathan Yaniv and Ishai Menache via Subru).\n",
          "commitDate": "01/05/17 4:01 PM",
          "commitName": "a3a615eeab8c14ccdc548311097e62a916963dc5",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "05/12/15 9:26 PM",
          "commitNameOld": "742632e346604fd2b263bd42367165638fcf2416",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 512.73,
          "commitsBetweenForRepo": 3348,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,137 +1,145 @@\n-  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n-      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n+      RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageEarliestStart, long stageDeadline, String user,\n-      ReservationId oldId) {\n+      long stageArrival, long stageDeadline, String user, ReservationId oldId)\n+      throws PlanningException {\n \n     // Initialize\n     ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n     Resource capacity \u003d plan.getTotalCapacity();\n+\n+    RLESparseResourceAllocation netRLERes \u003d plan\n+        .getAvailableResourceOverTime(user, oldId, stageArrival, stageDeadline);\n+\n     long step \u003d plan.getStep();\n \n     // Create allocationRequestsearlies\n     RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Initialize parameters\n     long duration \u003d stepRoundUp(rr.getDuration(), step);\n     int windowSizeInDurations \u003d\n-        (int) ((stageDeadline - stageEarliestStart) / duration);\n+        (int) ((stageDeadline - stageArrival) / duration);\n     int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n     int numContainersPerGang \u003d rr.getConcurrency();\n     Resource gang \u003d\n         Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n     // Set maxGangsPerUnit\n-    int maxGangsPerUnit \u003d\n-        (int) Math.max(\n-            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n+    int maxGangsPerUnit \u003d (int) Math\n+        .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n     maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n     // If window size is too small, return null\n     if (windowSizeInDurations \u003c\u003d 0) {\n       return null;\n     }\n \n+    final int preferLeft \u003d allocateLeft ? 1 : -1;\n+\n     // Initialize tree sorted by costs\n     TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n         new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n           @Override\n           public int compare(DurationInterval val1, DurationInterval val2) {\n \n             int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n             if (cmp !\u003d 0) {\n               return cmp;\n             }\n \n-            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n+            return preferLeft\n+                * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n         });\n \n+    List\u003cLong\u003e intervalEndTimes \u003d\n+        computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n+\n     // Add durationIntervals that end at (endTime - n*duration) for some n.\n-    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n-        + duration; intervalEnd -\u003d duration) {\n+    for (long intervalEnd : intervalEndTimes) {\n \n       long intervalStart \u003d intervalEnd - duration;\n \n       // Get duration interval [intervalStart,intervalEnd)\n       DurationInterval durationInterval \u003d\n           getDurationInterval(intervalStart, intervalEnd, planLoads,\n-              planModifications, capacity, resCalc, step);\n+              planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // If the interval can fit a gang, add it to the tree\n-      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n+      if (durationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n     // Allocate\n     int remainingGangs \u003d totalGangs;\n     while (remainingGangs \u003e 0) {\n \n       // If no durationInterval can fit a gang, break and return null\n       if (durationIntervalsSortedByCost.isEmpty()) {\n         break;\n       }\n \n       // Get best duration interval\n       DurationInterval bestDurationInterval \u003d\n           durationIntervalsSortedByCost.first();\n       int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n       numGangsToAllocate \u003d\n-          Math.min(numGangsToAllocate,\n-              bestDurationInterval.numCanFit(gang, capacity, resCalc));\n+          Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n       // Add it\n       remainingGangs -\u003d numGangsToAllocate;\n \n       ReservationInterval reservationInt \u003d\n           new ReservationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getEndTime());\n \n-      Resource reservationRes \u003d\n-          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n-              * numGangsToAllocate);\n+      Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n+          rr.getConcurrency() * numGangsToAllocate);\n \n       planModifications.addInterval(reservationInt, reservationRes);\n       allocationRequests.addInterval(reservationInt, reservationRes);\n \n       // Remove from tree\n       durationIntervalsSortedByCost.remove(bestDurationInterval);\n \n       // Get updated interval\n       DurationInterval updatedDurationInterval \u003d\n           getDurationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getStartTime() + duration, planLoads,\n-              planModifications, capacity, resCalc, step);\n+              planModifications, capacity, netRLERes, resCalc, step, gang);\n \n       // Add to tree, if possible\n-      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n+      if (updatedDurationInterval.canAllocate()) {\n         durationIntervalsSortedByCost.add(updatedDurationInterval);\n       }\n \n     }\n \n     // Get the final allocation\n     Map\u003cReservationInterval, Resource\u003e allocations \u003d\n         allocationRequests.toIntervalMap();\n \n     // If no gangs are left to place we succeed and return the allocation\n     if (remainingGangs \u003c\u003d 0) {\n       return allocations;\n     } else {\n \n-      // If we are here is because we did not manage to satisfy this request.\n-      // We remove unwanted side-effect from planModifications (needed for ANY).\n-      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n-          : allocations.entrySet()) {\n+      // If we are here is because we did not manage to satisfy this\n+      // request.\n+      // We remove unwanted side-effect from planModifications (needed for\n+      // ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n+          .entrySet()) {\n \n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n \n       }\n       // Return null to signal failure in this allocation\n       return null;\n \n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageArrival, long stageDeadline, String user, ReservationId oldId)\n      throws PlanningException {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n\n    RLESparseResourceAllocation netRLERes \u003d plan\n        .getAvailableResourceOverTime(user, oldId, stageArrival, stageDeadline);\n\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageArrival) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d (int) Math\n        .max(Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    final int preferLeft \u003d allocateLeft ? 1 : -1;\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return preferLeft\n                * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    List\u003cLong\u003e intervalEndTimes \u003d\n        computeIntervalEndTimes(stageArrival, stageDeadline, duration);\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd : intervalEndTimes) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n      numGangsToAllocate \u003d\n          Math.min(numGangsToAllocate, bestDurationInterval.numCanFit());\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d Resources.multiply(rr.getCapability(),\n          rr.getConcurrency() * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, netRLERes, resCalc, step, gang);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate()) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this\n      // request.\n      // We remove unwanted side-effect from planModifications (needed for\n      // ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation : allocations\n          .entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {}
        }
      ]
    },
    "742632e346604fd2b263bd42367165638fcf2416": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
      "commitDate": "05/12/15 9:26 PM",
      "commitName": "742632e346604fd2b263bd42367165638fcf2416",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
          "commitDate": "05/12/15 9:26 PM",
          "commitName": "742632e346604fd2b263bd42367165638fcf2416",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "21/11/15 9:59 AM",
          "commitNameOld": "da1016365aba1cee9c06771ab142d077379f27af",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 14.48,
          "commitsBetweenForRepo": 112,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,134 +1,137 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n       Plan plan, Map\u003cLong, Resource\u003e planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageEarliestStart, long stageDeadline) {\n+      long stageEarliestStart, long stageDeadline, String user,\n+      ReservationId oldId) {\n \n     // Initialize\n     ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n     Resource capacity \u003d plan.getTotalCapacity();\n     long step \u003d plan.getStep();\n \n     // Create allocationRequestsearlies\n     RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Initialize parameters\n     long duration \u003d stepRoundUp(rr.getDuration(), step);\n     int windowSizeInDurations \u003d\n         (int) ((stageDeadline - stageEarliestStart) / duration);\n     int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n     int numContainersPerGang \u003d rr.getConcurrency();\n     Resource gang \u003d\n         Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n     // Set maxGangsPerUnit\n     int maxGangsPerUnit \u003d\n         (int) Math.max(\n             Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n     maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n     // If window size is too small, return null\n     if (windowSizeInDurations \u003c\u003d 0) {\n       return null;\n     }\n \n     // Initialize tree sorted by costs\n     TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n         new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n           @Override\n           public int compare(DurationInterval val1, DurationInterval val2) {\n \n             int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n             if (cmp !\u003d 0) {\n               return cmp;\n             }\n \n             return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n         });\n \n     // Add durationIntervals that end at (endTime - n*duration) for some n.\n     for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n         + duration; intervalEnd -\u003d duration) {\n \n       long intervalStart \u003d intervalEnd - duration;\n \n       // Get duration interval [intervalStart,intervalEnd)\n       DurationInterval durationInterval \u003d\n           getDurationInterval(intervalStart, intervalEnd, planLoads,\n               planModifications, capacity, resCalc, step);\n \n       // If the interval can fit a gang, add it to the tree\n       if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n         durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n     // Allocate\n     int remainingGangs \u003d totalGangs;\n     while (remainingGangs \u003e 0) {\n \n       // If no durationInterval can fit a gang, break and return null\n       if (durationIntervalsSortedByCost.isEmpty()) {\n         break;\n       }\n \n       // Get best duration interval\n       DurationInterval bestDurationInterval \u003d\n           durationIntervalsSortedByCost.first();\n       int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n-\n+      numGangsToAllocate \u003d\n+          Math.min(numGangsToAllocate,\n+              bestDurationInterval.numCanFit(gang, capacity, resCalc));\n       // Add it\n       remainingGangs -\u003d numGangsToAllocate;\n \n       ReservationInterval reservationInt \u003d\n           new ReservationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getEndTime());\n \n       Resource reservationRes \u003d\n           Resources.multiply(rr.getCapability(), rr.getConcurrency()\n               * numGangsToAllocate);\n \n       planModifications.addInterval(reservationInt, reservationRes);\n       allocationRequests.addInterval(reservationInt, reservationRes);\n \n       // Remove from tree\n       durationIntervalsSortedByCost.remove(bestDurationInterval);\n \n       // Get updated interval\n       DurationInterval updatedDurationInterval \u003d\n           getDurationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getStartTime() + duration, planLoads,\n               planModifications, capacity, resCalc, step);\n \n       // Add to tree, if possible\n       if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n         durationIntervalsSortedByCost.add(updatedDurationInterval);\n       }\n \n     }\n \n     // Get the final allocation\n     Map\u003cReservationInterval, Resource\u003e allocations \u003d\n         allocationRequests.toIntervalMap();\n \n     // If no gangs are left to place we succeed and return the allocation\n     if (remainingGangs \u003c\u003d 0) {\n       return allocations;\n     } else {\n \n       // If we are here is because we did not manage to satisfy this request.\n       // We remove unwanted side-effect from planModifications (needed for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n           : allocations.entrySet()) {\n \n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n \n       }\n       // Return null to signal failure in this allocation\n       return null;\n \n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageEarliestStart) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d\n        (int) Math.max(\n            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n        + duration; intervalEnd -\u003d duration) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n      numGangsToAllocate \u003d\n          Math.min(numGangsToAllocate,\n              bestDurationInterval.numCanFit(gang, capacity, resCalc));\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d\n          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n              * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this request.\n      // We remove unwanted side-effect from planModifications (needed for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocations.entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {
            "oldValue": "[plan-Plan, planLoads-Map\u003cLong,Resource\u003e, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long]",
            "newValue": "[plan-Plan, planLoads-Map\u003cLong,Resource\u003e, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long, user-String, oldId-ReservationId]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
          "commitDate": "05/12/15 9:26 PM",
          "commitName": "742632e346604fd2b263bd42367165638fcf2416",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "21/11/15 9:59 AM",
          "commitNameOld": "da1016365aba1cee9c06771ab142d077379f27af",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 14.48,
          "commitsBetweenForRepo": 112,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,134 +1,137 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n       Plan plan, Map\u003cLong, Resource\u003e planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageEarliestStart, long stageDeadline) {\n+      long stageEarliestStart, long stageDeadline, String user,\n+      ReservationId oldId) {\n \n     // Initialize\n     ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n     Resource capacity \u003d plan.getTotalCapacity();\n     long step \u003d plan.getStep();\n \n     // Create allocationRequestsearlies\n     RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Initialize parameters\n     long duration \u003d stepRoundUp(rr.getDuration(), step);\n     int windowSizeInDurations \u003d\n         (int) ((stageDeadline - stageEarliestStart) / duration);\n     int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n     int numContainersPerGang \u003d rr.getConcurrency();\n     Resource gang \u003d\n         Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n     // Set maxGangsPerUnit\n     int maxGangsPerUnit \u003d\n         (int) Math.max(\n             Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n     maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n     // If window size is too small, return null\n     if (windowSizeInDurations \u003c\u003d 0) {\n       return null;\n     }\n \n     // Initialize tree sorted by costs\n     TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n         new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n           @Override\n           public int compare(DurationInterval val1, DurationInterval val2) {\n \n             int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n             if (cmp !\u003d 0) {\n               return cmp;\n             }\n \n             return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n         });\n \n     // Add durationIntervals that end at (endTime - n*duration) for some n.\n     for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n         + duration; intervalEnd -\u003d duration) {\n \n       long intervalStart \u003d intervalEnd - duration;\n \n       // Get duration interval [intervalStart,intervalEnd)\n       DurationInterval durationInterval \u003d\n           getDurationInterval(intervalStart, intervalEnd, planLoads,\n               planModifications, capacity, resCalc, step);\n \n       // If the interval can fit a gang, add it to the tree\n       if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n         durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n     // Allocate\n     int remainingGangs \u003d totalGangs;\n     while (remainingGangs \u003e 0) {\n \n       // If no durationInterval can fit a gang, break and return null\n       if (durationIntervalsSortedByCost.isEmpty()) {\n         break;\n       }\n \n       // Get best duration interval\n       DurationInterval bestDurationInterval \u003d\n           durationIntervalsSortedByCost.first();\n       int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n-\n+      numGangsToAllocate \u003d\n+          Math.min(numGangsToAllocate,\n+              bestDurationInterval.numCanFit(gang, capacity, resCalc));\n       // Add it\n       remainingGangs -\u003d numGangsToAllocate;\n \n       ReservationInterval reservationInt \u003d\n           new ReservationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getEndTime());\n \n       Resource reservationRes \u003d\n           Resources.multiply(rr.getCapability(), rr.getConcurrency()\n               * numGangsToAllocate);\n \n       planModifications.addInterval(reservationInt, reservationRes);\n       allocationRequests.addInterval(reservationInt, reservationRes);\n \n       // Remove from tree\n       durationIntervalsSortedByCost.remove(bestDurationInterval);\n \n       // Get updated interval\n       DurationInterval updatedDurationInterval \u003d\n           getDurationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getStartTime() + duration, planLoads,\n               planModifications, capacity, resCalc, step);\n \n       // Add to tree, if possible\n       if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n         durationIntervalsSortedByCost.add(updatedDurationInterval);\n       }\n \n     }\n \n     // Get the final allocation\n     Map\u003cReservationInterval, Resource\u003e allocations \u003d\n         allocationRequests.toIntervalMap();\n \n     // If no gangs are left to place we succeed and return the allocation\n     if (remainingGangs \u003c\u003d 0) {\n       return allocations;\n     } else {\n \n       // If we are here is because we did not manage to satisfy this request.\n       // We remove unwanted side-effect from planModifications (needed for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n           : allocations.entrySet()) {\n \n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n \n       }\n       // Return null to signal failure in this allocation\n       return null;\n \n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageEarliestStart) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d\n        (int) Math.max(\n            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n        + duration; intervalEnd -\u003d duration) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n      numGangsToAllocate \u003d\n          Math.min(numGangsToAllocate,\n              bestDurationInterval.numCanFit(gang, capacity, resCalc));\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d\n          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n              * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this request.\n      // We remove unwanted side-effect from planModifications (needed for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocations.entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {}
        }
      ]
    },
    "da1016365aba1cee9c06771ab142d077379f27af": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3454. Add efficient merge operation to RLESparseResourceAllocation (Carlo Curino via asuresh)\n",
      "commitDate": "21/11/15 9:59 AM",
      "commitName": "da1016365aba1cee9c06771ab142d077379f27af",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "25/07/15 7:39 AM",
      "commitNameOld": "156f24ead00436faad5d4aeef327a546392cd265",
      "commitAuthorOld": "ccurino",
      "daysBetweenCommits": 119.14,
      "commitsBetweenForRepo": 803,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,134 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n       Plan plan, Map\u003cLong, Resource\u003e planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageEarliestStart, long stageDeadline) {\n \n     // Initialize\n     ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n     Resource capacity \u003d plan.getTotalCapacity();\n     long step \u003d plan.getStep();\n \n     // Create allocationRequestsearlies\n     RLESparseResourceAllocation allocationRequests \u003d\n-        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n-            plan.getMinimumAllocation());\n+        new RLESparseResourceAllocation(plan.getResourceCalculator());\n \n     // Initialize parameters\n     long duration \u003d stepRoundUp(rr.getDuration(), step);\n     int windowSizeInDurations \u003d\n         (int) ((stageDeadline - stageEarliestStart) / duration);\n     int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n     int numContainersPerGang \u003d rr.getConcurrency();\n     Resource gang \u003d\n         Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n     // Set maxGangsPerUnit\n     int maxGangsPerUnit \u003d\n         (int) Math.max(\n             Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n     maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n     // If window size is too small, return null\n     if (windowSizeInDurations \u003c\u003d 0) {\n       return null;\n     }\n \n     // Initialize tree sorted by costs\n     TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n         new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n           @Override\n           public int compare(DurationInterval val1, DurationInterval val2) {\n \n             int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n             if (cmp !\u003d 0) {\n               return cmp;\n             }\n \n             return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n         });\n \n     // Add durationIntervals that end at (endTime - n*duration) for some n.\n     for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n         + duration; intervalEnd -\u003d duration) {\n \n       long intervalStart \u003d intervalEnd - duration;\n \n       // Get duration interval [intervalStart,intervalEnd)\n       DurationInterval durationInterval \u003d\n           getDurationInterval(intervalStart, intervalEnd, planLoads,\n               planModifications, capacity, resCalc, step);\n \n       // If the interval can fit a gang, add it to the tree\n       if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n         durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n     // Allocate\n     int remainingGangs \u003d totalGangs;\n     while (remainingGangs \u003e 0) {\n \n       // If no durationInterval can fit a gang, break and return null\n       if (durationIntervalsSortedByCost.isEmpty()) {\n         break;\n       }\n \n       // Get best duration interval\n       DurationInterval bestDurationInterval \u003d\n           durationIntervalsSortedByCost.first();\n       int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n \n       // Add it\n       remainingGangs -\u003d numGangsToAllocate;\n \n       ReservationInterval reservationInt \u003d\n           new ReservationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getEndTime());\n \n       Resource reservationRes \u003d\n           Resources.multiply(rr.getCapability(), rr.getConcurrency()\n               * numGangsToAllocate);\n \n       planModifications.addInterval(reservationInt, reservationRes);\n       allocationRequests.addInterval(reservationInt, reservationRes);\n \n       // Remove from tree\n       durationIntervalsSortedByCost.remove(bestDurationInterval);\n \n       // Get updated interval\n       DurationInterval updatedDurationInterval \u003d\n           getDurationInterval(bestDurationInterval.getStartTime(),\n               bestDurationInterval.getStartTime() + duration, planLoads,\n               planModifications, capacity, resCalc, step);\n \n       // Add to tree, if possible\n       if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n         durationIntervalsSortedByCost.add(updatedDurationInterval);\n       }\n \n     }\n \n     // Get the final allocation\n     Map\u003cReservationInterval, Resource\u003e allocations \u003d\n         allocationRequests.toIntervalMap();\n \n     // If no gangs are left to place we succeed and return the allocation\n     if (remainingGangs \u003c\u003d 0) {\n       return allocations;\n     } else {\n \n       // If we are here is because we did not manage to satisfy this request.\n       // We remove unwanted side-effect from planModifications (needed for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n           : allocations.entrySet()) {\n \n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n \n       }\n       // Return null to signal failure in this allocation\n       return null;\n \n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageEarliestStart) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d\n        (int) Math.max(\n            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n        + duration; intervalEnd -\u003d duration) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d\n          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n              * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this request.\n      // We remove unwanted side-effect from planModifications (needed for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocations.entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
      "extendedDetails": {}
    },
    "156f24ead00436faad5d4aeef327a546392cd265": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange,Yrename,Yparameterchange)",
      "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
      "commitDate": "25/07/15 7:39 AM",
      "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
      "commitAuthor": "ccurino",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,135 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n+      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n-\n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n+    // Initialize\n+    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n+    Resource capacity \u003d plan.getTotalCapacity();\n     long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create allocationRequestsearlies\n+    RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Initialize parameters\n+    long duration \u003d stepRoundUp(rr.getDuration(), step);\n+    int windowSizeInDurations \u003d\n+        (int) ((stageDeadline - stageEarliestStart) / duration);\n+    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n+    int numContainersPerGang \u003d rr.getConcurrency();\n+    Resource gang \u003d\n+        Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n-    boolean hasGang \u003d false;\n+    // Set maxGangsPerUnit\n+    int maxGangsPerUnit \u003d\n+        (int) Math.max(\n+            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n+    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // If window size is too small, return null\n+    if (windowSizeInDurations \u003c\u003d 0) {\n+      return null;\n+    }\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Initialize tree sorted by costs\n+    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n+        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n+          @Override\n+          public int compare(DurationInterval val1, DurationInterval val2) {\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n-\n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n-\n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n-\n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n-\n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n-\n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n+            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n+            if (cmp !\u003d 0) {\n+              return cmp;\n             }\n+\n+            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n+        });\n+\n+    // Add durationIntervals that end at (endTime - n*duration) for some n.\n+    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n+        + duration; intervalEnd -\u003d duration) {\n+\n+      long intervalStart \u003d intervalEnd - duration;\n+\n+      // Get duration interval [intervalStart,intervalEnd)\n+      DurationInterval durationInterval \u003d\n+          getDurationInterval(intervalStart, intervalEnd, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // If the interval can fit a gang, add it to the tree\n+      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+    // Allocate\n+    int remainingGangs \u003d totalGangs;\n+    while (remainingGangs \u003e 0) {\n+\n+      // If no durationInterval can fit a gang, break and return null\n+      if (durationIntervalsSortedByCost.isEmpty()) {\n+        break;\n+      }\n+\n+      // Get best duration interval\n+      DurationInterval bestDurationInterval \u003d\n+          durationIntervalsSortedByCost.first();\n+      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n+\n+      // Add it\n+      remainingGangs -\u003d numGangsToAllocate;\n+\n+      ReservationInterval reservationInt \u003d\n+          new ReservationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getEndTime());\n+\n+      Resource reservationRes \u003d\n+          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+              * numGangsToAllocate);\n+\n+      planModifications.addInterval(reservationInt, reservationRes);\n+      allocationRequests.addInterval(reservationInt, reservationRes);\n+\n+      // Remove from tree\n+      durationIntervalsSortedByCost.remove(bestDurationInterval);\n+\n+      // Get updated interval\n+      DurationInterval updatedDurationInterval \u003d\n+          getDurationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getStartTime() + duration, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // Add to tree, if possible\n+      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(updatedDurationInterval);\n+      }\n+\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    // Get the final allocation\n+    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+        allocationRequests.toIntervalMap();\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // If no gangs are left to place we succeed and return the allocation\n+    if (remainingGangs \u003c\u003d 0) {\n+      return allocations;\n     } else {\n-      return plan.addReservation(capReservation);\n+\n+      // If we are here is because we did not manage to satisfy this request.\n+      // We remove unwanted side-effect from planModifications (needed for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocations.entrySet()) {\n+\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+\n+      }\n+      // Return null to signal failure in this allocation\n+      return null;\n+\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageEarliestStart) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d\n        (int) Math.max(\n            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n        + duration; intervalEnd -\u003d duration) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d\n          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n              * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this request.\n      // We remove unwanted side-effect from planModifications (needed for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocations.entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/GreedyReservationAgent.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
            "oldMethodName": "computeAllocation",
            "newMethodName": "computeStageAllocation"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,135 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n+      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n-\n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n+    // Initialize\n+    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n+    Resource capacity \u003d plan.getTotalCapacity();\n     long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create allocationRequestsearlies\n+    RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Initialize parameters\n+    long duration \u003d stepRoundUp(rr.getDuration(), step);\n+    int windowSizeInDurations \u003d\n+        (int) ((stageDeadline - stageEarliestStart) / duration);\n+    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n+    int numContainersPerGang \u003d rr.getConcurrency();\n+    Resource gang \u003d\n+        Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n-    boolean hasGang \u003d false;\n+    // Set maxGangsPerUnit\n+    int maxGangsPerUnit \u003d\n+        (int) Math.max(\n+            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n+    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // If window size is too small, return null\n+    if (windowSizeInDurations \u003c\u003d 0) {\n+      return null;\n+    }\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Initialize tree sorted by costs\n+    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n+        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n+          @Override\n+          public int compare(DurationInterval val1, DurationInterval val2) {\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n-\n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n-\n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n-\n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n-\n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n-\n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n+            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n+            if (cmp !\u003d 0) {\n+              return cmp;\n             }\n+\n+            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n+        });\n+\n+    // Add durationIntervals that end at (endTime - n*duration) for some n.\n+    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n+        + duration; intervalEnd -\u003d duration) {\n+\n+      long intervalStart \u003d intervalEnd - duration;\n+\n+      // Get duration interval [intervalStart,intervalEnd)\n+      DurationInterval durationInterval \u003d\n+          getDurationInterval(intervalStart, intervalEnd, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // If the interval can fit a gang, add it to the tree\n+      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+    // Allocate\n+    int remainingGangs \u003d totalGangs;\n+    while (remainingGangs \u003e 0) {\n+\n+      // If no durationInterval can fit a gang, break and return null\n+      if (durationIntervalsSortedByCost.isEmpty()) {\n+        break;\n+      }\n+\n+      // Get best duration interval\n+      DurationInterval bestDurationInterval \u003d\n+          durationIntervalsSortedByCost.first();\n+      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n+\n+      // Add it\n+      remainingGangs -\u003d numGangsToAllocate;\n+\n+      ReservationInterval reservationInt \u003d\n+          new ReservationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getEndTime());\n+\n+      Resource reservationRes \u003d\n+          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+              * numGangsToAllocate);\n+\n+      planModifications.addInterval(reservationInt, reservationRes);\n+      allocationRequests.addInterval(reservationInt, reservationRes);\n+\n+      // Remove from tree\n+      durationIntervalsSortedByCost.remove(bestDurationInterval);\n+\n+      // Get updated interval\n+      DurationInterval updatedDurationInterval \u003d\n+          getDurationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getStartTime() + duration, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // Add to tree, if possible\n+      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(updatedDurationInterval);\n+      }\n+\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    // Get the final allocation\n+    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+        allocationRequests.toIntervalMap();\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // If no gangs are left to place we succeed and return the allocation\n+    if (remainingGangs \u003c\u003d 0) {\n+      return allocations;\n     } else {\n-      return plan.addReservation(capReservation);\n+\n+      // If we are here is because we did not manage to satisfy this request.\n+      // We remove unwanted side-effect from planModifications (needed for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocations.entrySet()) {\n+\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+\n+      }\n+      // Return null to signal failure in this allocation\n+      return null;\n+\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageEarliestStart) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d\n        (int) Math.max(\n            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n        + duration; intervalEnd -\u003d duration) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d\n          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n              * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this request.\n      // We remove unwanted side-effect from planModifications (needed for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocations.entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {
            "oldValue": "boolean",
            "newValue": "Map\u003cReservationInterval,Resource\u003e"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,135 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n+      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n-\n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n+    // Initialize\n+    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n+    Resource capacity \u003d plan.getTotalCapacity();\n     long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create allocationRequestsearlies\n+    RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Initialize parameters\n+    long duration \u003d stepRoundUp(rr.getDuration(), step);\n+    int windowSizeInDurations \u003d\n+        (int) ((stageDeadline - stageEarliestStart) / duration);\n+    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n+    int numContainersPerGang \u003d rr.getConcurrency();\n+    Resource gang \u003d\n+        Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n-    boolean hasGang \u003d false;\n+    // Set maxGangsPerUnit\n+    int maxGangsPerUnit \u003d\n+        (int) Math.max(\n+            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n+    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // If window size is too small, return null\n+    if (windowSizeInDurations \u003c\u003d 0) {\n+      return null;\n+    }\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Initialize tree sorted by costs\n+    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n+        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n+          @Override\n+          public int compare(DurationInterval val1, DurationInterval val2) {\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n-\n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n-\n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n-\n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n-\n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n-\n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n+            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n+            if (cmp !\u003d 0) {\n+              return cmp;\n             }\n+\n+            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n+        });\n+\n+    // Add durationIntervals that end at (endTime - n*duration) for some n.\n+    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n+        + duration; intervalEnd -\u003d duration) {\n+\n+      long intervalStart \u003d intervalEnd - duration;\n+\n+      // Get duration interval [intervalStart,intervalEnd)\n+      DurationInterval durationInterval \u003d\n+          getDurationInterval(intervalStart, intervalEnd, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // If the interval can fit a gang, add it to the tree\n+      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+    // Allocate\n+    int remainingGangs \u003d totalGangs;\n+    while (remainingGangs \u003e 0) {\n+\n+      // If no durationInterval can fit a gang, break and return null\n+      if (durationIntervalsSortedByCost.isEmpty()) {\n+        break;\n+      }\n+\n+      // Get best duration interval\n+      DurationInterval bestDurationInterval \u003d\n+          durationIntervalsSortedByCost.first();\n+      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n+\n+      // Add it\n+      remainingGangs -\u003d numGangsToAllocate;\n+\n+      ReservationInterval reservationInt \u003d\n+          new ReservationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getEndTime());\n+\n+      Resource reservationRes \u003d\n+          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+              * numGangsToAllocate);\n+\n+      planModifications.addInterval(reservationInt, reservationRes);\n+      allocationRequests.addInterval(reservationInt, reservationRes);\n+\n+      // Remove from tree\n+      durationIntervalsSortedByCost.remove(bestDurationInterval);\n+\n+      // Get updated interval\n+      DurationInterval updatedDurationInterval \u003d\n+          getDurationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getStartTime() + duration, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // Add to tree, if possible\n+      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(updatedDurationInterval);\n+      }\n+\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    // Get the final allocation\n+    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+        allocationRequests.toIntervalMap();\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // If no gangs are left to place we succeed and return the allocation\n+    if (remainingGangs \u003c\u003d 0) {\n+      return allocations;\n     } else {\n-      return plan.addReservation(capReservation);\n+\n+      // If we are here is because we did not manage to satisfy this request.\n+      // We remove unwanted side-effect from planModifications (needed for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocations.entrySet()) {\n+\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+\n+      }\n+      // Return null to signal failure in this allocation\n+      return null;\n+\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageEarliestStart) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d\n        (int) Math.max(\n            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n        + duration; intervalEnd -\u003d duration) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d\n          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n              * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this request.\n      // We remove unwanted side-effect from planModifications (needed for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocations.entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,135 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n+      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n-\n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n+    // Initialize\n+    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n+    Resource capacity \u003d plan.getTotalCapacity();\n     long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create allocationRequestsearlies\n+    RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Initialize parameters\n+    long duration \u003d stepRoundUp(rr.getDuration(), step);\n+    int windowSizeInDurations \u003d\n+        (int) ((stageDeadline - stageEarliestStart) / duration);\n+    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n+    int numContainersPerGang \u003d rr.getConcurrency();\n+    Resource gang \u003d\n+        Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n-    boolean hasGang \u003d false;\n+    // Set maxGangsPerUnit\n+    int maxGangsPerUnit \u003d\n+        (int) Math.max(\n+            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n+    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // If window size is too small, return null\n+    if (windowSizeInDurations \u003c\u003d 0) {\n+      return null;\n+    }\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Initialize tree sorted by costs\n+    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n+        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n+          @Override\n+          public int compare(DurationInterval val1, DurationInterval val2) {\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n-\n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n-\n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n-\n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n-\n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n-\n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n+            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n+            if (cmp !\u003d 0) {\n+              return cmp;\n             }\n+\n+            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n+        });\n+\n+    // Add durationIntervals that end at (endTime - n*duration) for some n.\n+    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n+        + duration; intervalEnd -\u003d duration) {\n+\n+      long intervalStart \u003d intervalEnd - duration;\n+\n+      // Get duration interval [intervalStart,intervalEnd)\n+      DurationInterval durationInterval \u003d\n+          getDurationInterval(intervalStart, intervalEnd, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // If the interval can fit a gang, add it to the tree\n+      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+    // Allocate\n+    int remainingGangs \u003d totalGangs;\n+    while (remainingGangs \u003e 0) {\n+\n+      // If no durationInterval can fit a gang, break and return null\n+      if (durationIntervalsSortedByCost.isEmpty()) {\n+        break;\n+      }\n+\n+      // Get best duration interval\n+      DurationInterval bestDurationInterval \u003d\n+          durationIntervalsSortedByCost.first();\n+      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n+\n+      // Add it\n+      remainingGangs -\u003d numGangsToAllocate;\n+\n+      ReservationInterval reservationInt \u003d\n+          new ReservationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getEndTime());\n+\n+      Resource reservationRes \u003d\n+          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+              * numGangsToAllocate);\n+\n+      planModifications.addInterval(reservationInt, reservationRes);\n+      allocationRequests.addInterval(reservationInt, reservationRes);\n+\n+      // Remove from tree\n+      durationIntervalsSortedByCost.remove(bestDurationInterval);\n+\n+      // Get updated interval\n+      DurationInterval updatedDurationInterval \u003d\n+          getDurationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getStartTime() + duration, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // Add to tree, if possible\n+      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(updatedDurationInterval);\n+      }\n+\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    // Get the final allocation\n+    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+        allocationRequests.toIntervalMap();\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // If no gangs are left to place we succeed and return the allocation\n+    if (remainingGangs \u003c\u003d 0) {\n+      return allocations;\n     } else {\n-      return plan.addReservation(capReservation);\n+\n+      // If we are here is because we did not manage to satisfy this request.\n+      // We remove unwanted side-effect from planModifications (needed for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocations.entrySet()) {\n+\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+\n+      }\n+      // Return null to signal failure in this allocation\n+      return null;\n+\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageEarliestStart) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d\n        (int) Math.max(\n            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n        + duration; intervalEnd -\u003d duration) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d\n          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n              * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this request.\n      // We remove unwanted side-effect from planModifications (needed for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocations.entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {
            "oldValue": "[PlanningException, ContractValidationException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,135 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n+      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n-\n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n+    // Initialize\n+    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n+    Resource capacity \u003d plan.getTotalCapacity();\n     long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create allocationRequestsearlies\n+    RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Initialize parameters\n+    long duration \u003d stepRoundUp(rr.getDuration(), step);\n+    int windowSizeInDurations \u003d\n+        (int) ((stageDeadline - stageEarliestStart) / duration);\n+    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n+    int numContainersPerGang \u003d rr.getConcurrency();\n+    Resource gang \u003d\n+        Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n-    boolean hasGang \u003d false;\n+    // Set maxGangsPerUnit\n+    int maxGangsPerUnit \u003d\n+        (int) Math.max(\n+            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n+    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // If window size is too small, return null\n+    if (windowSizeInDurations \u003c\u003d 0) {\n+      return null;\n+    }\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Initialize tree sorted by costs\n+    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n+        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n+          @Override\n+          public int compare(DurationInterval val1, DurationInterval val2) {\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n-\n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n-\n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n-\n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n-\n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n-\n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n+            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n+            if (cmp !\u003d 0) {\n+              return cmp;\n             }\n+\n+            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n+        });\n+\n+    // Add durationIntervals that end at (endTime - n*duration) for some n.\n+    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n+        + duration; intervalEnd -\u003d duration) {\n+\n+      long intervalStart \u003d intervalEnd - duration;\n+\n+      // Get duration interval [intervalStart,intervalEnd)\n+      DurationInterval durationInterval \u003d\n+          getDurationInterval(intervalStart, intervalEnd, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // If the interval can fit a gang, add it to the tree\n+      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+    // Allocate\n+    int remainingGangs \u003d totalGangs;\n+    while (remainingGangs \u003e 0) {\n+\n+      // If no durationInterval can fit a gang, break and return null\n+      if (durationIntervalsSortedByCost.isEmpty()) {\n+        break;\n+      }\n+\n+      // Get best duration interval\n+      DurationInterval bestDurationInterval \u003d\n+          durationIntervalsSortedByCost.first();\n+      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n+\n+      // Add it\n+      remainingGangs -\u003d numGangsToAllocate;\n+\n+      ReservationInterval reservationInt \u003d\n+          new ReservationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getEndTime());\n+\n+      Resource reservationRes \u003d\n+          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+              * numGangsToAllocate);\n+\n+      planModifications.addInterval(reservationInt, reservationRes);\n+      allocationRequests.addInterval(reservationInt, reservationRes);\n+\n+      // Remove from tree\n+      durationIntervalsSortedByCost.remove(bestDurationInterval);\n+\n+      // Get updated interval\n+      DurationInterval updatedDurationInterval \u003d\n+          getDurationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getStartTime() + duration, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // Add to tree, if possible\n+      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(updatedDurationInterval);\n+      }\n+\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    // Get the final allocation\n+    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+        allocationRequests.toIntervalMap();\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // If no gangs are left to place we succeed and return the allocation\n+    if (remainingGangs \u003c\u003d 0) {\n+      return allocations;\n     } else {\n-      return plan.addReservation(capReservation);\n+\n+      // If we are here is because we did not manage to satisfy this request.\n+      // We remove unwanted side-effect from planModifications (needed for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocations.entrySet()) {\n+\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+\n+      }\n+      // Return null to signal failure in this allocation\n+      return null;\n+\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageEarliestStart) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d\n        (int) Math.max(\n            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n        + duration; intervalEnd -\u003d duration) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d\n          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n              * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this request.\n      // We remove unwanted side-effect from planModifications (needed for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocations.entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {}
        },
        {
          "type": "Yrename",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,135 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n+      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n-\n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n+    // Initialize\n+    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n+    Resource capacity \u003d plan.getTotalCapacity();\n     long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create allocationRequestsearlies\n+    RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Initialize parameters\n+    long duration \u003d stepRoundUp(rr.getDuration(), step);\n+    int windowSizeInDurations \u003d\n+        (int) ((stageDeadline - stageEarliestStart) / duration);\n+    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n+    int numContainersPerGang \u003d rr.getConcurrency();\n+    Resource gang \u003d\n+        Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n-    boolean hasGang \u003d false;\n+    // Set maxGangsPerUnit\n+    int maxGangsPerUnit \u003d\n+        (int) Math.max(\n+            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n+    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // If window size is too small, return null\n+    if (windowSizeInDurations \u003c\u003d 0) {\n+      return null;\n+    }\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Initialize tree sorted by costs\n+    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n+        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n+          @Override\n+          public int compare(DurationInterval val1, DurationInterval val2) {\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n-\n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n-\n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n-\n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n-\n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n-\n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n+            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n+            if (cmp !\u003d 0) {\n+              return cmp;\n             }\n+\n+            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n+        });\n+\n+    // Add durationIntervals that end at (endTime - n*duration) for some n.\n+    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n+        + duration; intervalEnd -\u003d duration) {\n+\n+      long intervalStart \u003d intervalEnd - duration;\n+\n+      // Get duration interval [intervalStart,intervalEnd)\n+      DurationInterval durationInterval \u003d\n+          getDurationInterval(intervalStart, intervalEnd, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // If the interval can fit a gang, add it to the tree\n+      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+    // Allocate\n+    int remainingGangs \u003d totalGangs;\n+    while (remainingGangs \u003e 0) {\n+\n+      // If no durationInterval can fit a gang, break and return null\n+      if (durationIntervalsSortedByCost.isEmpty()) {\n+        break;\n+      }\n+\n+      // Get best duration interval\n+      DurationInterval bestDurationInterval \u003d\n+          durationIntervalsSortedByCost.first();\n+      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n+\n+      // Add it\n+      remainingGangs -\u003d numGangsToAllocate;\n+\n+      ReservationInterval reservationInt \u003d\n+          new ReservationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getEndTime());\n+\n+      Resource reservationRes \u003d\n+          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+              * numGangsToAllocate);\n+\n+      planModifications.addInterval(reservationInt, reservationRes);\n+      allocationRequests.addInterval(reservationInt, reservationRes);\n+\n+      // Remove from tree\n+      durationIntervalsSortedByCost.remove(bestDurationInterval);\n+\n+      // Get updated interval\n+      DurationInterval updatedDurationInterval \u003d\n+          getDurationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getStartTime() + duration, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // Add to tree, if possible\n+      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(updatedDurationInterval);\n+      }\n+\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    // Get the final allocation\n+    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+        allocationRequests.toIntervalMap();\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // If no gangs are left to place we succeed and return the allocation\n+    if (remainingGangs \u003c\u003d 0) {\n+      return allocations;\n     } else {\n-      return plan.addReservation(capReservation);\n+\n+      // If we are here is because we did not manage to satisfy this request.\n+      // We remove unwanted side-effect from planModifications (needed for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocations.entrySet()) {\n+\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+\n+      }\n+      // Return null to signal failure in this allocation\n+      return null;\n+\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageEarliestStart) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d\n        (int) Math.max(\n            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n        + duration; intervalEnd -\u003d duration) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d\n          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n              * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this request.\n      // We remove unwanted side-effect from planModifications (needed for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocations.entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {
            "oldValue": "computeAllocation",
            "newValue": "computeStageAllocation"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
          "commitDate": "25/07/15 7:39 AM",
          "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
          "commitAuthor": "ccurino",
          "commitDateOld": "24/07/15 6:31 PM",
          "commitNameOld": "adcf5dd94052481f66deaf402ac4ace1ffc06f49",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 0.55,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,139 +1,135 @@\n-  private boolean computeAllocation(ReservationId reservationId, String user,\n-      Plan plan, ReservationDefinition contract,\n-      ReservationAllocation oldReservation) throws PlanningException,\n-      ContractValidationException {\n-    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n+      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline) {\n \n-    Resource totalCapacity \u003d plan.getTotalCapacity();\n-\n-    // Here we can addd logic to adjust the ResourceDefinition to account for\n-    // system \"imperfections\" (e.g., scheduling delays for large containers).\n-\n-    // Align with plan step conservatively (i.e., ceil arrival, and floor\n-    // deadline)\n-    long earliestStart \u003d contract.getArrival();\n+    // Initialize\n+    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n+    Resource capacity \u003d plan.getTotalCapacity();\n     long step \u003d plan.getStep();\n-    if (earliestStart % step !\u003d 0) {\n-      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n-    }\n-    long deadline \u003d\n-        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n-    // setup temporary variables to handle time-relations between stages and\n-    // intermediate answers\n-    long curDeadline \u003d deadline;\n-    long oldDeadline \u003d -1;\n-\n-    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, Resource\u003e();\n-    RLESparseResourceAllocation tempAssigned \u003d\n+    // Create allocationRequestsearlies\n+    RLESparseResourceAllocation allocationRequests \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n-    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n-        .getReservationResources();\n-    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n-        .getInterpreter();\n+    // Initialize parameters\n+    long duration \u003d stepRoundUp(rr.getDuration(), step);\n+    int windowSizeInDurations \u003d\n+        (int) ((stageDeadline - stageEarliestStart) / duration);\n+    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n+    int numContainersPerGang \u003d rr.getConcurrency();\n+    Resource gang \u003d\n+        Resources.multiply(rr.getCapability(), numContainersPerGang);\n \n-    boolean hasGang \u003d false;\n+    // Set maxGangsPerUnit\n+    int maxGangsPerUnit \u003d\n+        (int) Math.max(\n+            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n+    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n \n-    // Iterate the stages in backward from deadline\n-    for (ListIterator\u003cReservationRequest\u003e li \u003d \n-        stages.listIterator(stages.size()); li.hasPrevious();) {\n+    // If window size is too small, return null\n+    if (windowSizeInDurations \u003c\u003d 0) {\n+      return null;\n+    }\n \n-      ReservationRequest currentReservationStage \u003d li.previous();\n+    // Initialize tree sorted by costs\n+    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n+        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n+          @Override\n+          public int compare(DurationInterval val1, DurationInterval val2) {\n \n-      // validate the RR respect basic constraints\n-      validateInput(plan, currentReservationStage, totalCapacity);\n-\n-      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n-\n-      // run allocation for a single stage\n-      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n-          placeSingleStage(plan, tempAssigned, currentReservationStage,\n-              earliestStart, curDeadline, oldReservation, totalCapacity);\n-\n-      if (curAlloc \u003d\u003d null) {\n-        // if we did not find an allocation for the currentReservationStage\n-        // return null, unless the ReservationDefinition we are placing is of\n-        // type ANY\n-        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n-          throw new PlanningException(\"The GreedyAgent\"\n-              + \" couldn\u0027t find a valid allocation for your request\");\n-        } else {\n-          continue;\n-        }\n-      } else {\n-\n-        // if we did find an allocation add it to the set of allocations\n-        allocations.putAll(curAlloc);\n-\n-        // if this request is of type ANY we are done searching (greedy)\n-        // and can return the current allocation (break-out of the search)\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n-          break;\n-        }\n-\n-        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n-        // round of allocation to precede the current allocation, by setting\n-        // curDeadline\n-        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n-            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n-          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n-\n-          // for ORDER_NO_GAP verify that the allocation found so far has no\n-          // gap, return null otherwise (the greedy procedure failed to find a\n-          // no-gap\n-          // allocation)\n-          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n-              \u0026\u0026 oldDeadline \u003e 0) {\n-            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n-                .getStep()) {\n-              throw new PlanningException(\"The GreedyAgent\"\n-                  + \" couldn\u0027t find a valid allocation for your request\");\n+            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n+            if (cmp !\u003d 0) {\n+              return cmp;\n             }\n+\n+            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n           }\n-          // keep the variable oldDeadline pointing to the last deadline we\n-          // found\n-          oldDeadline \u003d curDeadline;\n-        }\n+        });\n+\n+    // Add durationIntervals that end at (endTime - n*duration) for some n.\n+    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n+        + duration; intervalEnd -\u003d duration) {\n+\n+      long intervalStart \u003d intervalEnd - duration;\n+\n+      // Get duration interval [intervalStart,intervalEnd)\n+      DurationInterval durationInterval \u003d\n+          getDurationInterval(intervalStart, intervalEnd, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // If the interval can fit a gang, add it to the tree\n+      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(durationInterval);\n       }\n     }\n \n-    // / If we got here is because we failed to find an allocation for the\n-    // ReservationDefinition give-up and report failure to the user\n-    if (allocations.isEmpty()) {\n-      throw new PlanningException(\"The GreedyAgent\"\n-          + \" couldn\u0027t find a valid allocation for your request\");\n+    // Allocate\n+    int remainingGangs \u003d totalGangs;\n+    while (remainingGangs \u003e 0) {\n+\n+      // If no durationInterval can fit a gang, break and return null\n+      if (durationIntervalsSortedByCost.isEmpty()) {\n+        break;\n+      }\n+\n+      // Get best duration interval\n+      DurationInterval bestDurationInterval \u003d\n+          durationIntervalsSortedByCost.first();\n+      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n+\n+      // Add it\n+      remainingGangs -\u003d numGangsToAllocate;\n+\n+      ReservationInterval reservationInt \u003d\n+          new ReservationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getEndTime());\n+\n+      Resource reservationRes \u003d\n+          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n+              * numGangsToAllocate);\n+\n+      planModifications.addInterval(reservationInt, reservationRes);\n+      allocationRequests.addInterval(reservationInt, reservationRes);\n+\n+      // Remove from tree\n+      durationIntervalsSortedByCost.remove(bestDurationInterval);\n+\n+      // Get updated interval\n+      DurationInterval updatedDurationInterval \u003d\n+          getDurationInterval(bestDurationInterval.getStartTime(),\n+              bestDurationInterval.getStartTime() + duration, planLoads,\n+              planModifications, capacity, resCalc, step);\n+\n+      // Add to tree, if possible\n+      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n+        durationIntervalsSortedByCost.add(updatedDurationInterval);\n+      }\n+\n     }\n \n-    // create reservation with above allocations if not null/empty\n+    // Get the final allocation\n+    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+        allocationRequests.toIntervalMap();\n \n-    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n-\n-    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n-    \n-    // add zero-padding from arrival up to the first non-null allocation\n-    // to guarantee that the reservation exists starting at arrival\n-    if (firstStartTime \u003e earliestStart) {\n-      allocations.put(new ReservationInterval(earliestStart,\n-          firstStartTime), ZERO_RES);\n-      firstStartTime \u003d earliestStart;\n-      // consider to add trailing zeros at the end for simmetry\n-    }\n-\n-    // Actually add/update the reservation in the plan.\n-    // This is subject to validation as other agents might be placing\n-    // in parallel and there might be sharing policies the agent is not\n-    // aware off.\n-    ReservationAllocation capReservation \u003d\n-        new InMemoryReservationAllocation(reservationId, contract, user,\n-            plan.getQueueName(), firstStartTime,\n-            findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n-    if (oldReservation !\u003d null) {\n-      return plan.updateReservation(capReservation);\n+    // If no gangs are left to place we succeed and return the allocation\n+    if (remainingGangs \u003c\u003d 0) {\n+      return allocations;\n     } else {\n-      return plan.addReservation(capReservation);\n+\n+      // If we are here is because we did not manage to satisfy this request.\n+      // We remove unwanted side-effect from planModifications (needed for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n+          : allocations.entrySet()) {\n+\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+\n+      }\n+      // Return null to signal failure in this allocation\n+      return null;\n+\n     }\n+\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(\n      Plan plan, Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline) {\n\n    // Initialize\n    ResourceCalculator resCalc \u003d plan.getResourceCalculator();\n    Resource capacity \u003d plan.getTotalCapacity();\n    long step \u003d plan.getStep();\n\n    // Create allocationRequestsearlies\n    RLESparseResourceAllocation allocationRequests \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    // Initialize parameters\n    long duration \u003d stepRoundUp(rr.getDuration(), step);\n    int windowSizeInDurations \u003d\n        (int) ((stageDeadline - stageEarliestStart) / duration);\n    int totalGangs \u003d rr.getNumContainers() / rr.getConcurrency();\n    int numContainersPerGang \u003d rr.getConcurrency();\n    Resource gang \u003d\n        Resources.multiply(rr.getCapability(), numContainersPerGang);\n\n    // Set maxGangsPerUnit\n    int maxGangsPerUnit \u003d\n        (int) Math.max(\n            Math.floor(((double) totalGangs) / windowSizeInDurations), 1);\n    maxGangsPerUnit \u003d Math.max(maxGangsPerUnit / smoothnessFactor, 1);\n\n    // If window size is too small, return null\n    if (windowSizeInDurations \u003c\u003d 0) {\n      return null;\n    }\n\n    // Initialize tree sorted by costs\n    TreeSet\u003cDurationInterval\u003e durationIntervalsSortedByCost \u003d\n        new TreeSet\u003cDurationInterval\u003e(new Comparator\u003cDurationInterval\u003e() {\n          @Override\n          public int compare(DurationInterval val1, DurationInterval val2) {\n\n            int cmp \u003d Double.compare(val1.getTotalCost(), val2.getTotalCost());\n            if (cmp !\u003d 0) {\n              return cmp;\n            }\n\n            return (-1) * Long.compare(val1.getEndTime(), val2.getEndTime());\n          }\n        });\n\n    // Add durationIntervals that end at (endTime - n*duration) for some n.\n    for (long intervalEnd \u003d stageDeadline; intervalEnd \u003e\u003d stageEarliestStart\n        + duration; intervalEnd -\u003d duration) {\n\n      long intervalStart \u003d intervalEnd - duration;\n\n      // Get duration interval [intervalStart,intervalEnd)\n      DurationInterval durationInterval \u003d\n          getDurationInterval(intervalStart, intervalEnd, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // If the interval can fit a gang, add it to the tree\n      if (durationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(durationInterval);\n      }\n    }\n\n    // Allocate\n    int remainingGangs \u003d totalGangs;\n    while (remainingGangs \u003e 0) {\n\n      // If no durationInterval can fit a gang, break and return null\n      if (durationIntervalsSortedByCost.isEmpty()) {\n        break;\n      }\n\n      // Get best duration interval\n      DurationInterval bestDurationInterval \u003d\n          durationIntervalsSortedByCost.first();\n      int numGangsToAllocate \u003d Math.min(maxGangsPerUnit, remainingGangs);\n\n      // Add it\n      remainingGangs -\u003d numGangsToAllocate;\n\n      ReservationInterval reservationInt \u003d\n          new ReservationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getEndTime());\n\n      Resource reservationRes \u003d\n          Resources.multiply(rr.getCapability(), rr.getConcurrency()\n              * numGangsToAllocate);\n\n      planModifications.addInterval(reservationInt, reservationRes);\n      allocationRequests.addInterval(reservationInt, reservationRes);\n\n      // Remove from tree\n      durationIntervalsSortedByCost.remove(bestDurationInterval);\n\n      // Get updated interval\n      DurationInterval updatedDurationInterval \u003d\n          getDurationInterval(bestDurationInterval.getStartTime(),\n              bestDurationInterval.getStartTime() + duration, planLoads,\n              planModifications, capacity, resCalc, step);\n\n      // Add to tree, if possible\n      if (updatedDurationInterval.canAllocate(gang, capacity, resCalc)) {\n        durationIntervalsSortedByCost.add(updatedDurationInterval);\n      }\n\n    }\n\n    // Get the final allocation\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        allocationRequests.toIntervalMap();\n\n    // If no gangs are left to place we succeed and return the allocation\n    if (remainingGangs \u003c\u003d 0) {\n      return allocations;\n    } else {\n\n      // If we are here is because we did not manage to satisfy this request.\n      // We remove unwanted side-effect from planModifications (needed for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation\n          : allocations.entrySet()) {\n\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n\n      }\n      // Return null to signal failure in this allocation\n      return null;\n\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorLowCostAligned.java",
          "extendedDetails": {
            "oldValue": "[reservationId-ReservationId, user-String, plan-Plan, contract-ReservationDefinition, oldReservation-ReservationAllocation]",
            "newValue": "[plan-Plan, planLoads-Map\u003cLong,Resource\u003e, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long]"
          }
        }
      ]
    },
    "0e602fa3a1529134214452fba10a90307d9c2072": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3800. Reduce storage footprint for ReservationAllocation. Contributed by Anubhav Dhoot.\n",
      "commitDate": "09/07/15 4:51 PM",
      "commitName": "0e602fa3a1529134214452fba10a90307d9c2072",
      "commitAuthor": "carlo curino",
      "commitDateOld": "03/10/14 3:43 PM",
      "commitNameOld": "5e10a13bb4759984494c6a870c7f08fb6693c9c0",
      "commitAuthorOld": "subru",
      "daysBetweenCommits": 279.05,
      "commitsBetweenForRepo": 2292,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,139 @@\n   private boolean computeAllocation(ReservationId reservationId, String user,\n       Plan plan, ReservationDefinition contract,\n       ReservationAllocation oldReservation) throws PlanningException,\n       ContractValidationException {\n     LOG.info(\"placing the following ReservationRequest: \" + contract);\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     // Here we can addd logic to adjust the ResourceDefinition to account for\n     // system \"imperfections\" (e.g., scheduling delays for large containers).\n \n     // Align with plan step conservatively (i.e., ceil arrival, and floor\n     // deadline)\n     long earliestStart \u003d contract.getArrival();\n     long step \u003d plan.getStep();\n     if (earliestStart % step !\u003d 0) {\n       earliestStart \u003d earliestStart + (step - (earliestStart % step));\n     }\n     long deadline \u003d\n         contract.getDeadline() - contract.getDeadline() % plan.getStep();\n \n     // setup temporary variables to handle time-relations between stages and\n     // intermediate answers\n     long curDeadline \u003d deadline;\n     long oldDeadline \u003d -1;\n \n-    Map\u003cReservationInterval, ReservationRequest\u003e allocations \u003d\n-        new HashMap\u003cReservationInterval, ReservationRequest\u003e();\n+    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n+        new HashMap\u003cReservationInterval, Resource\u003e();\n     RLESparseResourceAllocation tempAssigned \u003d\n         new RLESparseResourceAllocation(plan.getResourceCalculator(),\n             plan.getMinimumAllocation());\n \n     List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n         .getReservationResources();\n     ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n         .getInterpreter();\n \n+    boolean hasGang \u003d false;\n+\n     // Iterate the stages in backward from deadline\n     for (ListIterator\u003cReservationRequest\u003e li \u003d \n         stages.listIterator(stages.size()); li.hasPrevious();) {\n \n       ReservationRequest currentReservationStage \u003d li.previous();\n \n       // validate the RR respect basic constraints\n       validateInput(plan, currentReservationStage, totalCapacity);\n \n+      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n+\n       // run allocation for a single stage\n-      Map\u003cReservationInterval, ReservationRequest\u003e curAlloc \u003d\n+      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n           placeSingleStage(plan, tempAssigned, currentReservationStage,\n               earliestStart, curDeadline, oldReservation, totalCapacity);\n \n       if (curAlloc \u003d\u003d null) {\n         // if we did not find an allocation for the currentReservationStage\n         // return null, unless the ReservationDefinition we are placing is of\n         // type ANY\n         if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n           throw new PlanningException(\"The GreedyAgent\"\n               + \" couldn\u0027t find a valid allocation for your request\");\n         } else {\n           continue;\n         }\n       } else {\n \n         // if we did find an allocation add it to the set of allocations\n         allocations.putAll(curAlloc);\n \n         // if this request is of type ANY we are done searching (greedy)\n         // and can return the current allocation (break-out of the search)\n         if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n           break;\n         }\n \n         // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n         // round of allocation to precede the current allocation, by setting\n         // curDeadline\n         if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n             || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n           curDeadline \u003d findEarliestTime(curAlloc.keySet());\n \n           // for ORDER_NO_GAP verify that the allocation found so far has no\n           // gap, return null otherwise (the greedy procedure failed to find a\n           // no-gap\n           // allocation)\n           if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n               \u0026\u0026 oldDeadline \u003e 0) {\n             if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n                 .getStep()) {\n               throw new PlanningException(\"The GreedyAgent\"\n                   + \" couldn\u0027t find a valid allocation for your request\");\n             }\n           }\n           // keep the variable oldDeadline pointing to the last deadline we\n           // found\n           oldDeadline \u003d curDeadline;\n         }\n       }\n     }\n \n     // / If we got here is because we failed to find an allocation for the\n     // ReservationDefinition give-up and report failure to the user\n     if (allocations.isEmpty()) {\n       throw new PlanningException(\"The GreedyAgent\"\n           + \" couldn\u0027t find a valid allocation for your request\");\n     }\n \n     // create reservation with above allocations if not null/empty\n \n-    ReservationRequest ZERO_RES \u003d\n-        ReservationRequest.newInstance(Resource.newInstance(0, 0), 0);\n+    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n \n     long firstStartTime \u003d findEarliestTime(allocations.keySet());\n     \n     // add zero-padding from arrival up to the first non-null allocation\n     // to guarantee that the reservation exists starting at arrival\n     if (firstStartTime \u003e earliestStart) {\n       allocations.put(new ReservationInterval(earliestStart,\n           firstStartTime), ZERO_RES);\n       firstStartTime \u003d earliestStart;\n       // consider to add trailing zeros at the end for simmetry\n     }\n \n     // Actually add/update the reservation in the plan.\n     // This is subject to validation as other agents might be placing\n     // in parallel and there might be sharing policies the agent is not\n     // aware off.\n     ReservationAllocation capReservation \u003d\n         new InMemoryReservationAllocation(reservationId, contract, user,\n             plan.getQueueName(), firstStartTime,\n             findLatestTime(allocations.keySet()), allocations,\n-            plan.getResourceCalculator(), plan.getMinimumAllocation());\n+            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n     if (oldReservation !\u003d null) {\n       return plan.updateReservation(capReservation);\n     } else {\n       return plan.addReservation(capReservation);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean computeAllocation(ReservationId reservationId, String user,\n      Plan plan, ReservationDefinition contract,\n      ReservationAllocation oldReservation) throws PlanningException,\n      ContractValidationException {\n    LOG.info(\"placing the following ReservationRequest: \" + contract);\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // Here we can addd logic to adjust the ResourceDefinition to account for\n    // system \"imperfections\" (e.g., scheduling delays for large containers).\n\n    // Align with plan step conservatively (i.e., ceil arrival, and floor\n    // deadline)\n    long earliestStart \u003d contract.getArrival();\n    long step \u003d plan.getStep();\n    if (earliestStart % step !\u003d 0) {\n      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n    }\n    long deadline \u003d\n        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n\n    // setup temporary variables to handle time-relations between stages and\n    // intermediate answers\n    long curDeadline \u003d deadline;\n    long oldDeadline \u003d -1;\n\n    Map\u003cReservationInterval, Resource\u003e allocations \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n    RLESparseResourceAllocation tempAssigned \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n        .getReservationResources();\n    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n        .getInterpreter();\n\n    boolean hasGang \u003d false;\n\n    // Iterate the stages in backward from deadline\n    for (ListIterator\u003cReservationRequest\u003e li \u003d \n        stages.listIterator(stages.size()); li.hasPrevious();) {\n\n      ReservationRequest currentReservationStage \u003d li.previous();\n\n      // validate the RR respect basic constraints\n      validateInput(plan, currentReservationStage, totalCapacity);\n\n      hasGang |\u003d currentReservationStage.getConcurrency() \u003e 1;\n\n      // run allocation for a single stage\n      Map\u003cReservationInterval, Resource\u003e curAlloc \u003d\n          placeSingleStage(plan, tempAssigned, currentReservationStage,\n              earliestStart, curDeadline, oldReservation, totalCapacity);\n\n      if (curAlloc \u003d\u003d null) {\n        // if we did not find an allocation for the currentReservationStage\n        // return null, unless the ReservationDefinition we are placing is of\n        // type ANY\n        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n          throw new PlanningException(\"The GreedyAgent\"\n              + \" couldn\u0027t find a valid allocation for your request\");\n        } else {\n          continue;\n        }\n      } else {\n\n        // if we did find an allocation add it to the set of allocations\n        allocations.putAll(curAlloc);\n\n        // if this request is of type ANY we are done searching (greedy)\n        // and can return the current allocation (break-out of the search)\n        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          break;\n        }\n\n        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n        // round of allocation to precede the current allocation, by setting\n        // curDeadline\n        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n\n          // for ORDER_NO_GAP verify that the allocation found so far has no\n          // gap, return null otherwise (the greedy procedure failed to find a\n          // no-gap\n          // allocation)\n          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n              \u0026\u0026 oldDeadline \u003e 0) {\n            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n                .getStep()) {\n              throw new PlanningException(\"The GreedyAgent\"\n                  + \" couldn\u0027t find a valid allocation for your request\");\n            }\n          }\n          // keep the variable oldDeadline pointing to the last deadline we\n          // found\n          oldDeadline \u003d curDeadline;\n        }\n      }\n    }\n\n    // / If we got here is because we failed to find an allocation for the\n    // ReservationDefinition give-up and report failure to the user\n    if (allocations.isEmpty()) {\n      throw new PlanningException(\"The GreedyAgent\"\n          + \" couldn\u0027t find a valid allocation for your request\");\n    }\n\n    // create reservation with above allocations if not null/empty\n\n    Resource ZERO_RES \u003d Resource.newInstance(0, 0);\n\n    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n    \n    // add zero-padding from arrival up to the first non-null allocation\n    // to guarantee that the reservation exists starting at arrival\n    if (firstStartTime \u003e earliestStart) {\n      allocations.put(new ReservationInterval(earliestStart,\n          firstStartTime), ZERO_RES);\n      firstStartTime \u003d earliestStart;\n      // consider to add trailing zeros at the end for simmetry\n    }\n\n    // Actually add/update the reservation in the plan.\n    // This is subject to validation as other agents might be placing\n    // in parallel and there might be sharing policies the agent is not\n    // aware off.\n    ReservationAllocation capReservation \u003d\n        new InMemoryReservationAllocation(reservationId, contract, user,\n            plan.getQueueName(), firstStartTime,\n            findLatestTime(allocations.keySet()), allocations,\n            plan.getResourceCalculator(), plan.getMinimumAllocation(), hasGang);\n    if (oldReservation !\u003d null) {\n      return plan.updateReservation(capReservation);\n    } else {\n      return plan.addReservation(capReservation);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/GreedyReservationAgent.java",
      "extendedDetails": {}
    },
    "f66ffcf832235e0da0bb050fff08e248b547c360": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1710. Logic to find allocations within a Plan that satisfy user ReservationRequest(s). Contributed by Carlo Curino and Subru Krishnan.\n(cherry picked from commit aef7928899b37262773f3dc117157bb746bf8918)\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "f66ffcf832235e0da0bb050fff08e248b547c360",
      "commitAuthor": "carlo curino",
      "diff": "@@ -0,0 +1,136 @@\n+  private boolean computeAllocation(ReservationId reservationId, String user,\n+      Plan plan, ReservationDefinition contract,\n+      ReservationAllocation oldReservation) throws PlanningException,\n+      ContractValidationException {\n+    LOG.info(\"placing the following ReservationRequest: \" + contract);\n+\n+    Resource totalCapacity \u003d plan.getTotalCapacity();\n+\n+    // Here we can addd logic to adjust the ResourceDefinition to account for\n+    // system \"imperfections\" (e.g., scheduling delays for large containers).\n+\n+    // Align with plan step conservatively (i.e., ceil arrival, and floor\n+    // deadline)\n+    long earliestStart \u003d contract.getArrival();\n+    long step \u003d plan.getStep();\n+    if (earliestStart % step !\u003d 0) {\n+      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n+    }\n+    long deadline \u003d\n+        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n+\n+    // setup temporary variables to handle time-relations between stages and\n+    // intermediate answers\n+    long curDeadline \u003d deadline;\n+    long oldDeadline \u003d -1;\n+\n+    Map\u003cReservationInterval, ReservationRequest\u003e allocations \u003d\n+        new HashMap\u003cReservationInterval, ReservationRequest\u003e();\n+    RLESparseResourceAllocation tempAssigned \u003d\n+        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n+            plan.getMinimumAllocation());\n+\n+    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n+        .getReservationResources();\n+    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n+        .getInterpreter();\n+\n+    // Iterate the stages in backward from deadline\n+    for (ListIterator\u003cReservationRequest\u003e li \u003d \n+        stages.listIterator(stages.size()); li.hasPrevious();) {\n+\n+      ReservationRequest currentReservationStage \u003d li.previous();\n+\n+      // validate the RR respect basic constraints\n+      validateInput(plan, currentReservationStage, totalCapacity);\n+\n+      // run allocation for a single stage\n+      Map\u003cReservationInterval, ReservationRequest\u003e curAlloc \u003d\n+          placeSingleStage(plan, tempAssigned, currentReservationStage,\n+              earliestStart, curDeadline, oldReservation, totalCapacity);\n+\n+      if (curAlloc \u003d\u003d null) {\n+        // if we did not find an allocation for the currentReservationStage\n+        // return null, unless the ReservationDefinition we are placing is of\n+        // type ANY\n+        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n+          throw new PlanningException(\"The GreedyAgent\"\n+              + \" couldn\u0027t find a valid allocation for your request\");\n+        } else {\n+          continue;\n+        }\n+      } else {\n+\n+        // if we did find an allocation add it to the set of allocations\n+        allocations.putAll(curAlloc);\n+\n+        // if this request is of type ANY we are done searching (greedy)\n+        // and can return the current allocation (break-out of the search)\n+        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n+          break;\n+        }\n+\n+        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n+        // round of allocation to precede the current allocation, by setting\n+        // curDeadline\n+        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n+            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n+          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n+\n+          // for ORDER_NO_GAP verify that the allocation found so far has no\n+          // gap, return null otherwise (the greedy procedure failed to find a\n+          // no-gap\n+          // allocation)\n+          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n+              \u0026\u0026 oldDeadline \u003e 0) {\n+            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n+                .getStep()) {\n+              throw new PlanningException(\"The GreedyAgent\"\n+                  + \" couldn\u0027t find a valid allocation for your request\");\n+            }\n+          }\n+          // keep the variable oldDeadline pointing to the last deadline we\n+          // found\n+          oldDeadline \u003d curDeadline;\n+        }\n+      }\n+    }\n+\n+    // / If we got here is because we failed to find an allocation for the\n+    // ReservationDefinition give-up and report failure to the user\n+    if (allocations.isEmpty()) {\n+      throw new PlanningException(\"The GreedyAgent\"\n+          + \" couldn\u0027t find a valid allocation for your request\");\n+    }\n+\n+    // create reservation with above allocations if not null/empty\n+\n+    ReservationRequest ZERO_RES \u003d\n+        ReservationRequest.newInstance(Resource.newInstance(0, 0), 0);\n+\n+    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n+    \n+    // add zero-padding from arrival up to the first non-null allocation\n+    // to guarantee that the reservation exists starting at arrival\n+    if (firstStartTime \u003e earliestStart) {\n+      allocations.put(new ReservationInterval(earliestStart,\n+          firstStartTime), ZERO_RES);\n+      firstStartTime \u003d earliestStart;\n+      // consider to add trailing zeros at the end for simmetry\n+    }\n+\n+    // Actually add/update the reservation in the plan.\n+    // This is subject to validation as other agents might be placing\n+    // in parallel and there might be sharing policies the agent is not\n+    // aware off.\n+    ReservationAllocation capReservation \u003d\n+        new InMemoryReservationAllocation(reservationId, contract, user,\n+            plan.getQueueName(), firstStartTime,\n+            findLatestTime(allocations.keySet()), allocations,\n+            plan.getResourceCalculator(), plan.getMinimumAllocation());\n+    if (oldReservation !\u003d null) {\n+      return plan.updateReservation(capReservation);\n+    } else {\n+      return plan.addReservation(capReservation);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean computeAllocation(ReservationId reservationId, String user,\n      Plan plan, ReservationDefinition contract,\n      ReservationAllocation oldReservation) throws PlanningException,\n      ContractValidationException {\n    LOG.info(\"placing the following ReservationRequest: \" + contract);\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // Here we can addd logic to adjust the ResourceDefinition to account for\n    // system \"imperfections\" (e.g., scheduling delays for large containers).\n\n    // Align with plan step conservatively (i.e., ceil arrival, and floor\n    // deadline)\n    long earliestStart \u003d contract.getArrival();\n    long step \u003d plan.getStep();\n    if (earliestStart % step !\u003d 0) {\n      earliestStart \u003d earliestStart + (step - (earliestStart % step));\n    }\n    long deadline \u003d\n        contract.getDeadline() - contract.getDeadline() % plan.getStep();\n\n    // setup temporary variables to handle time-relations between stages and\n    // intermediate answers\n    long curDeadline \u003d deadline;\n    long oldDeadline \u003d -1;\n\n    Map\u003cReservationInterval, ReservationRequest\u003e allocations \u003d\n        new HashMap\u003cReservationInterval, ReservationRequest\u003e();\n    RLESparseResourceAllocation tempAssigned \u003d\n        new RLESparseResourceAllocation(plan.getResourceCalculator(),\n            plan.getMinimumAllocation());\n\n    List\u003cReservationRequest\u003e stages \u003d contract.getReservationRequests()\n        .getReservationResources();\n    ReservationRequestInterpreter type \u003d contract.getReservationRequests()\n        .getInterpreter();\n\n    // Iterate the stages in backward from deadline\n    for (ListIterator\u003cReservationRequest\u003e li \u003d \n        stages.listIterator(stages.size()); li.hasPrevious();) {\n\n      ReservationRequest currentReservationStage \u003d li.previous();\n\n      // validate the RR respect basic constraints\n      validateInput(plan, currentReservationStage, totalCapacity);\n\n      // run allocation for a single stage\n      Map\u003cReservationInterval, ReservationRequest\u003e curAlloc \u003d\n          placeSingleStage(plan, tempAssigned, currentReservationStage,\n              earliestStart, curDeadline, oldReservation, totalCapacity);\n\n      if (curAlloc \u003d\u003d null) {\n        // if we did not find an allocation for the currentReservationStage\n        // return null, unless the ReservationDefinition we are placing is of\n        // type ANY\n        if (type !\u003d ReservationRequestInterpreter.R_ANY) {\n          throw new PlanningException(\"The GreedyAgent\"\n              + \" couldn\u0027t find a valid allocation for your request\");\n        } else {\n          continue;\n        }\n      } else {\n\n        // if we did find an allocation add it to the set of allocations\n        allocations.putAll(curAlloc);\n\n        // if this request is of type ANY we are done searching (greedy)\n        // and can return the current allocation (break-out of the search)\n        if (type \u003d\u003d ReservationRequestInterpreter.R_ANY) {\n          break;\n        }\n\n        // if the request is of ORDER or ORDER_NO_GAP we constraint the next\n        // round of allocation to precede the current allocation, by setting\n        // curDeadline\n        if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER\n            || type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP) {\n          curDeadline \u003d findEarliestTime(curAlloc.keySet());\n\n          // for ORDER_NO_GAP verify that the allocation found so far has no\n          // gap, return null otherwise (the greedy procedure failed to find a\n          // no-gap\n          // allocation)\n          if (type \u003d\u003d ReservationRequestInterpreter.R_ORDER_NO_GAP\n              \u0026\u0026 oldDeadline \u003e 0) {\n            if (oldDeadline - findLatestTime(curAlloc.keySet()) \u003e plan\n                .getStep()) {\n              throw new PlanningException(\"The GreedyAgent\"\n                  + \" couldn\u0027t find a valid allocation for your request\");\n            }\n          }\n          // keep the variable oldDeadline pointing to the last deadline we\n          // found\n          oldDeadline \u003d curDeadline;\n        }\n      }\n    }\n\n    // / If we got here is because we failed to find an allocation for the\n    // ReservationDefinition give-up and report failure to the user\n    if (allocations.isEmpty()) {\n      throw new PlanningException(\"The GreedyAgent\"\n          + \" couldn\u0027t find a valid allocation for your request\");\n    }\n\n    // create reservation with above allocations if not null/empty\n\n    ReservationRequest ZERO_RES \u003d\n        ReservationRequest.newInstance(Resource.newInstance(0, 0), 0);\n\n    long firstStartTime \u003d findEarliestTime(allocations.keySet());\n    \n    // add zero-padding from arrival up to the first non-null allocation\n    // to guarantee that the reservation exists starting at arrival\n    if (firstStartTime \u003e earliestStart) {\n      allocations.put(new ReservationInterval(earliestStart,\n          firstStartTime), ZERO_RES);\n      firstStartTime \u003d earliestStart;\n      // consider to add trailing zeros at the end for simmetry\n    }\n\n    // Actually add/update the reservation in the plan.\n    // This is subject to validation as other agents might be placing\n    // in parallel and there might be sharing policies the agent is not\n    // aware off.\n    ReservationAllocation capReservation \u003d\n        new InMemoryReservationAllocation(reservationId, contract, user,\n            plan.getQueueName(), firstStartTime,\n            findLatestTime(allocations.keySet()), allocations,\n            plan.getResourceCalculator(), plan.getMinimumAllocation());\n    if (oldReservation !\u003d null) {\n      return plan.updateReservation(capReservation);\n    } else {\n      return plan.addReservation(capReservation);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/GreedyReservationAgent.java"
    }
  }
}