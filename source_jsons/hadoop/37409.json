{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ClientRMService.java",
  "functionName": "moveApplicationAcrossQueues",
  "functionId": "moveApplicationAcrossQueues___request-MoveApplicationAcrossQueuesRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
  "functionStartLine": 1199,
  "functionEndLine": 1249,
  "numCommitsSeen": 128,
  "timeTaken": 4123,
  "changeHistory": [
    "cffea251be4b73ca16e5e11f0be2d22651330f73",
    "a207aa9930e7ee4f10228e2db4b4e733794eb8ea",
    "7979939428ad5df213846e11bc1489bdf94ed9f8",
    "563480dccd0136d82730f4228f1df44449ed5822",
    "1079c371289cd31478ed4bc123c1c4dd846c76ee",
    "67cbde300811289692b4746ceb6f180f2003667b"
  ],
  "changeHistoryShort": {
    "cffea251be4b73ca16e5e11f0be2d22651330f73": "Ybodychange",
    "a207aa9930e7ee4f10228e2db4b4e733794eb8ea": "Ybodychange",
    "7979939428ad5df213846e11bc1489bdf94ed9f8": "Ybodychange",
    "563480dccd0136d82730f4228f1df44449ed5822": "Ybodychange",
    "1079c371289cd31478ed4bc123c1c4dd846c76ee": "Ybodychange",
    "67cbde300811289692b4746ceb6f180f2003667b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cffea251be4b73ca16e5e11f0be2d22651330f73": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5956. Refactor ClientRMService for unify error handling across apis. Contributed by Kai Sasaki.\n",
      "commitDate": "25/03/17 9:56 AM",
      "commitName": "cffea251be4b73ca16e5e11f0be2d22651330f73",
      "commitAuthor": "Sunil G",
      "commitDateOld": "28/02/17 11:04 AM",
      "commitNameOld": "e0bb867c3fa638c9f689ee0b044b400481cf02b5",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 24.91,
      "commitsBetweenForRepo": 150,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,51 @@\n   public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(\n       MoveApplicationAcrossQueuesRequest request) throws YarnException {\n     ApplicationId applicationId \u003d request.getApplicationId();\n \n-    UserGroupInformation callerUGI;\n-    try {\n-      callerUGI \u003d UserGroupInformation.getCurrentUser();\n-    } catch (IOException ie) {\n-      LOG.info(\"Error getting UGI \", ie);\n-      RMAuditLogger.logFailure(\"UNKNOWN\", AuditConstants.MOVE_APP_REQUEST,\n-          \"UNKNOWN\", \"ClientRMService\" , \"Error getting UGI\",\n-          applicationId);\n-      throw RPCUtil.getRemoteException(ie);\n-    }\n-\n-    RMApp application \u003d this.rmContext.getRMApps().get(applicationId);\n-    if (application \u003d\u003d null) {\n-      RMAuditLogger.logFailure(callerUGI.getUserName(),\n-          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n-          \"Trying to move an absent application\", applicationId);\n-      throw new ApplicationNotFoundException(\"Trying to move an absent\"\n-          + \" application \" + applicationId);\n-    }\n-\n-    if (!checkAccess(callerUGI, application.getUser(),\n-        ApplicationAccessType.MODIFY_APP, application)) {\n-      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n-          AuditConstants.MOVE_APP_REQUEST,\n-          \"User doesn\u0027t have permissions to \"\n-              + ApplicationAccessType.MODIFY_APP.toString(), \"ClientRMService\",\n-          AuditConstants.UNAUTHORIZED_USER, applicationId);\n-      throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n-          + callerUGI.getShortUserName() + \" cannot perform operation \"\n-          + ApplicationAccessType.MODIFY_APP.name() + \" on \" + applicationId));\n-    }\n+    UserGroupInformation callerUGI \u003d getCallerUgi(applicationId,\n+        AuditConstants.MOVE_APP_REQUEST);\n+    RMApp application \u003d verifyUserAccessForRMApp(applicationId, callerUGI,\n+        AuditConstants.MOVE_APP_REQUEST, ApplicationAccessType.MODIFY_APP,\n+        true);\n \n     String targetQueue \u003d request.getTargetQueue();\n     if (!accessToTargetQueueAllowed(callerUGI, application, targetQueue)) {\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"Target queue doesn\u0027t exist or user\"\n               + \" doesn\u0027t have permissions to submit to target queue: \"\n               + targetQueue, \"ClientRMService\",\n           AuditConstants.UNAUTHORIZED_USER, applicationId);\n       throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n           + callerUGI.getShortUserName() + \" cannot submit applications to\"\n           + \" target queue or the target queue doesn\u0027t exist: \"\n           + targetQueue + \" while moving \" + applicationId));\n     }\n \n     // Moves only allowed when app is in a state that means it is tracked by\n     // the scheduler. Introducing SUBMITTED state also to this list as there\n     // could be a corner scenario that app may not be in Scheduler in SUBMITTED\n     // state.\n     if (!ACTIVE_APP_STATES.contains(application.getState())) {\n       String msg \u003d \"App in \" + application.getState() +\n           \" state cannot be moved.\";\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\", msg);\n       throw new YarnException(msg);\n     }\n \n     try {\n       this.rmAppManager.moveApplicationAcrossQueue(\n           application.getApplicationId(),\n           request.getTargetQueue());\n     } catch (YarnException ex) {\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n           ex.getMessage());\n       throw ex;\n     }\n \n     RMAuditLogger.logSuccess(callerUGI.getShortUserName(), \n         AuditConstants.MOVE_APP_REQUEST, \"ClientRMService\" , applicationId);\n-    MoveApplicationAcrossQueuesResponse response \u003d recordFactory\n+    return recordFactory\n         .newRecordInstance(MoveApplicationAcrossQueuesResponse.class);\n-    return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(\n      MoveApplicationAcrossQueuesRequest request) throws YarnException {\n    ApplicationId applicationId \u003d request.getApplicationId();\n\n    UserGroupInformation callerUGI \u003d getCallerUgi(applicationId,\n        AuditConstants.MOVE_APP_REQUEST);\n    RMApp application \u003d verifyUserAccessForRMApp(applicationId, callerUGI,\n        AuditConstants.MOVE_APP_REQUEST, ApplicationAccessType.MODIFY_APP,\n        true);\n\n    String targetQueue \u003d request.getTargetQueue();\n    if (!accessToTargetQueueAllowed(callerUGI, application, targetQueue)) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"Target queue doesn\u0027t exist or user\"\n              + \" doesn\u0027t have permissions to submit to target queue: \"\n              + targetQueue, \"ClientRMService\",\n          AuditConstants.UNAUTHORIZED_USER, applicationId);\n      throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n          + callerUGI.getShortUserName() + \" cannot submit applications to\"\n          + \" target queue or the target queue doesn\u0027t exist: \"\n          + targetQueue + \" while moving \" + applicationId));\n    }\n\n    // Moves only allowed when app is in a state that means it is tracked by\n    // the scheduler. Introducing SUBMITTED state also to this list as there\n    // could be a corner scenario that app may not be in Scheduler in SUBMITTED\n    // state.\n    if (!ACTIVE_APP_STATES.contains(application.getState())) {\n      String msg \u003d \"App in \" + application.getState() +\n          \" state cannot be moved.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\", msg);\n      throw new YarnException(msg);\n    }\n\n    try {\n      this.rmAppManager.moveApplicationAcrossQueue(\n          application.getApplicationId(),\n          request.getTargetQueue());\n    } catch (YarnException ex) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n          ex.getMessage());\n      throw ex;\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getShortUserName(), \n        AuditConstants.MOVE_APP_REQUEST, \"ClientRMService\" , applicationId);\n    return recordFactory\n        .newRecordInstance(MoveApplicationAcrossQueuesResponse.class);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "a207aa9930e7ee4f10228e2db4b4e733794eb8ea": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6211. Synchronization improvement for moveApplicationAcrossQueues and updateApplicationPriority. Contributed by Bibin A Chundatt.\n",
      "commitDate": "23/02/17 12:49 AM",
      "commitName": "a207aa9930e7ee4f10228e2db4b4e733794eb8ea",
      "commitAuthor": "Sunil G",
      "commitDateOld": "22/02/17 11:17 AM",
      "commitNameOld": "1a6ca75f3872587fb34c995a4b372b8cd6366d7d",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,78 @@\n   public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(\n       MoveApplicationAcrossQueuesRequest request) throws YarnException {\n     ApplicationId applicationId \u003d request.getApplicationId();\n \n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       RMAuditLogger.logFailure(\"UNKNOWN\", AuditConstants.MOVE_APP_REQUEST,\n           \"UNKNOWN\", \"ClientRMService\" , \"Error getting UGI\",\n           applicationId);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     RMApp application \u003d this.rmContext.getRMApps().get(applicationId);\n     if (application \u003d\u003d null) {\n       RMAuditLogger.logFailure(callerUGI.getUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n           \"Trying to move an absent application\", applicationId);\n       throw new ApplicationNotFoundException(\"Trying to move an absent\"\n           + \" application \" + applicationId);\n     }\n \n     if (!checkAccess(callerUGI, application.getUser(),\n         ApplicationAccessType.MODIFY_APP, application)) {\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST,\n           \"User doesn\u0027t have permissions to \"\n               + ApplicationAccessType.MODIFY_APP.toString(), \"ClientRMService\",\n           AuditConstants.UNAUTHORIZED_USER, applicationId);\n       throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n           + callerUGI.getShortUserName() + \" cannot perform operation \"\n           + ApplicationAccessType.MODIFY_APP.name() + \" on \" + applicationId));\n     }\n \n     String targetQueue \u003d request.getTargetQueue();\n     if (!accessToTargetQueueAllowed(callerUGI, application, targetQueue)) {\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"Target queue doesn\u0027t exist or user\"\n               + \" doesn\u0027t have permissions to submit to target queue: \"\n               + targetQueue, \"ClientRMService\",\n           AuditConstants.UNAUTHORIZED_USER, applicationId);\n       throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n           + callerUGI.getShortUserName() + \" cannot submit applications to\"\n           + \" target queue or the target queue doesn\u0027t exist: \"\n           + targetQueue + \" while moving \" + applicationId));\n     }\n \n     // Moves only allowed when app is in a state that means it is tracked by\n     // the scheduler. Introducing SUBMITTED state also to this list as there\n     // could be a corner scenario that app may not be in Scheduler in SUBMITTED\n     // state.\n     if (!ACTIVE_APP_STATES.contains(application.getState())) {\n       String msg \u003d \"App in \" + application.getState() +\n           \" state cannot be moved.\";\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\", msg);\n       throw new YarnException(msg);\n     }\n \n     try {\n-      this.rmAppManager.moveApplicationAcrossQueue(applicationId,\n+      this.rmAppManager.moveApplicationAcrossQueue(\n+          application.getApplicationId(),\n           request.getTargetQueue());\n     } catch (YarnException ex) {\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n           ex.getMessage());\n       throw ex;\n     }\n \n     RMAuditLogger.logSuccess(callerUGI.getShortUserName(), \n         AuditConstants.MOVE_APP_REQUEST, \"ClientRMService\" , applicationId);\n     MoveApplicationAcrossQueuesResponse response \u003d recordFactory\n         .newRecordInstance(MoveApplicationAcrossQueuesResponse.class);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(\n      MoveApplicationAcrossQueuesRequest request) throws YarnException {\n    ApplicationId applicationId \u003d request.getApplicationId();\n\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      RMAuditLogger.logFailure(\"UNKNOWN\", AuditConstants.MOVE_APP_REQUEST,\n          \"UNKNOWN\", \"ClientRMService\" , \"Error getting UGI\",\n          applicationId);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    RMApp application \u003d this.rmContext.getRMApps().get(applicationId);\n    if (application \u003d\u003d null) {\n      RMAuditLogger.logFailure(callerUGI.getUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n          \"Trying to move an absent application\", applicationId);\n      throw new ApplicationNotFoundException(\"Trying to move an absent\"\n          + \" application \" + applicationId);\n    }\n\n    if (!checkAccess(callerUGI, application.getUser(),\n        ApplicationAccessType.MODIFY_APP, application)) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST,\n          \"User doesn\u0027t have permissions to \"\n              + ApplicationAccessType.MODIFY_APP.toString(), \"ClientRMService\",\n          AuditConstants.UNAUTHORIZED_USER, applicationId);\n      throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n          + callerUGI.getShortUserName() + \" cannot perform operation \"\n          + ApplicationAccessType.MODIFY_APP.name() + \" on \" + applicationId));\n    }\n\n    String targetQueue \u003d request.getTargetQueue();\n    if (!accessToTargetQueueAllowed(callerUGI, application, targetQueue)) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"Target queue doesn\u0027t exist or user\"\n              + \" doesn\u0027t have permissions to submit to target queue: \"\n              + targetQueue, \"ClientRMService\",\n          AuditConstants.UNAUTHORIZED_USER, applicationId);\n      throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n          + callerUGI.getShortUserName() + \" cannot submit applications to\"\n          + \" target queue or the target queue doesn\u0027t exist: \"\n          + targetQueue + \" while moving \" + applicationId));\n    }\n\n    // Moves only allowed when app is in a state that means it is tracked by\n    // the scheduler. Introducing SUBMITTED state also to this list as there\n    // could be a corner scenario that app may not be in Scheduler in SUBMITTED\n    // state.\n    if (!ACTIVE_APP_STATES.contains(application.getState())) {\n      String msg \u003d \"App in \" + application.getState() +\n          \" state cannot be moved.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\", msg);\n      throw new YarnException(msg);\n    }\n\n    try {\n      this.rmAppManager.moveApplicationAcrossQueue(\n          application.getApplicationId(),\n          request.getTargetQueue());\n    } catch (YarnException ex) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n          ex.getMessage());\n      throw ex;\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getShortUserName(), \n        AuditConstants.MOVE_APP_REQUEST, \"ClientRMService\" , applicationId);\n    MoveApplicationAcrossQueuesResponse response \u003d recordFactory\n        .newRecordInstance(MoveApplicationAcrossQueuesResponse.class);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "7979939428ad5df213846e11bc1489bdf94ed9f8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5554. MoveApplicationAcrossQueues does not check user permission on the target queue\n(Contributed by Wilfred Spiegelenburg via Daniel Templeton)\n",
      "commitDate": "11/01/17 2:34 PM",
      "commitName": "7979939428ad5df213846e11bc1489bdf94ed9f8",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "09/01/17 8:40 AM",
      "commitNameOld": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 2.25,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,77 @@\n   public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(\n       MoveApplicationAcrossQueuesRequest request) throws YarnException {\n     ApplicationId applicationId \u003d request.getApplicationId();\n \n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       RMAuditLogger.logFailure(\"UNKNOWN\", AuditConstants.MOVE_APP_REQUEST,\n           \"UNKNOWN\", \"ClientRMService\" , \"Error getting UGI\",\n           applicationId);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     RMApp application \u003d this.rmContext.getRMApps().get(applicationId);\n     if (application \u003d\u003d null) {\n       RMAuditLogger.logFailure(callerUGI.getUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n           \"Trying to move an absent application\", applicationId);\n       throw new ApplicationNotFoundException(\"Trying to move an absent\"\n           + \" application \" + applicationId);\n     }\n \n     if (!checkAccess(callerUGI, application.getUser(),\n         ApplicationAccessType.MODIFY_APP, application)) {\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST,\n           \"User doesn\u0027t have permissions to \"\n               + ApplicationAccessType.MODIFY_APP.toString(), \"ClientRMService\",\n           AuditConstants.UNAUTHORIZED_USER, applicationId);\n       throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n           + callerUGI.getShortUserName() + \" cannot perform operation \"\n           + ApplicationAccessType.MODIFY_APP.name() + \" on \" + applicationId));\n     }\n-    \n+\n+    String targetQueue \u003d request.getTargetQueue();\n+    if (!accessToTargetQueueAllowed(callerUGI, application, targetQueue)) {\n+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n+          AuditConstants.MOVE_APP_REQUEST, \"Target queue doesn\u0027t exist or user\"\n+              + \" doesn\u0027t have permissions to submit to target queue: \"\n+              + targetQueue, \"ClientRMService\",\n+          AuditConstants.UNAUTHORIZED_USER, applicationId);\n+      throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n+          + callerUGI.getShortUserName() + \" cannot submit applications to\"\n+          + \" target queue or the target queue doesn\u0027t exist: \"\n+          + targetQueue + \" while moving \" + applicationId));\n+    }\n+\n     // Moves only allowed when app is in a state that means it is tracked by\n     // the scheduler. Introducing SUBMITTED state also to this list as there\n     // could be a corner scenario that app may not be in Scheduler in SUBMITTED\n     // state.\n     if (!ACTIVE_APP_STATES.contains(application.getState())) {\n-      String msg \u003d \"App in \" + application.getState() + \" state cannot be moved.\";\n+      String msg \u003d \"App in \" + application.getState() +\n+          \" state cannot be moved.\";\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\", msg);\n       throw new YarnException(msg);\n     }\n \n     try {\n-      this.rmAppManager.moveApplicationAcrossQueue(applicationId, request.getTargetQueue());\n+      this.rmAppManager.moveApplicationAcrossQueue(applicationId,\n+          request.getTargetQueue());\n     } catch (YarnException ex) {\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n           ex.getMessage());\n       throw ex;\n     }\n \n     RMAuditLogger.logSuccess(callerUGI.getShortUserName(), \n         AuditConstants.MOVE_APP_REQUEST, \"ClientRMService\" , applicationId);\n     MoveApplicationAcrossQueuesResponse response \u003d recordFactory\n         .newRecordInstance(MoveApplicationAcrossQueuesResponse.class);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(\n      MoveApplicationAcrossQueuesRequest request) throws YarnException {\n    ApplicationId applicationId \u003d request.getApplicationId();\n\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      RMAuditLogger.logFailure(\"UNKNOWN\", AuditConstants.MOVE_APP_REQUEST,\n          \"UNKNOWN\", \"ClientRMService\" , \"Error getting UGI\",\n          applicationId);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    RMApp application \u003d this.rmContext.getRMApps().get(applicationId);\n    if (application \u003d\u003d null) {\n      RMAuditLogger.logFailure(callerUGI.getUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n          \"Trying to move an absent application\", applicationId);\n      throw new ApplicationNotFoundException(\"Trying to move an absent\"\n          + \" application \" + applicationId);\n    }\n\n    if (!checkAccess(callerUGI, application.getUser(),\n        ApplicationAccessType.MODIFY_APP, application)) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST,\n          \"User doesn\u0027t have permissions to \"\n              + ApplicationAccessType.MODIFY_APP.toString(), \"ClientRMService\",\n          AuditConstants.UNAUTHORIZED_USER, applicationId);\n      throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n          + callerUGI.getShortUserName() + \" cannot perform operation \"\n          + ApplicationAccessType.MODIFY_APP.name() + \" on \" + applicationId));\n    }\n\n    String targetQueue \u003d request.getTargetQueue();\n    if (!accessToTargetQueueAllowed(callerUGI, application, targetQueue)) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"Target queue doesn\u0027t exist or user\"\n              + \" doesn\u0027t have permissions to submit to target queue: \"\n              + targetQueue, \"ClientRMService\",\n          AuditConstants.UNAUTHORIZED_USER, applicationId);\n      throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n          + callerUGI.getShortUserName() + \" cannot submit applications to\"\n          + \" target queue or the target queue doesn\u0027t exist: \"\n          + targetQueue + \" while moving \" + applicationId));\n    }\n\n    // Moves only allowed when app is in a state that means it is tracked by\n    // the scheduler. Introducing SUBMITTED state also to this list as there\n    // could be a corner scenario that app may not be in Scheduler in SUBMITTED\n    // state.\n    if (!ACTIVE_APP_STATES.contains(application.getState())) {\n      String msg \u003d \"App in \" + application.getState() +\n          \" state cannot be moved.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\", msg);\n      throw new YarnException(msg);\n    }\n\n    try {\n      this.rmAppManager.moveApplicationAcrossQueue(applicationId,\n          request.getTargetQueue());\n    } catch (YarnException ex) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n          ex.getMessage());\n      throw ex;\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getShortUserName(), \n        AuditConstants.MOVE_APP_REQUEST, \"ClientRMService\" , applicationId);\n    MoveApplicationAcrossQueuesResponse response \u003d recordFactory\n        .newRecordInstance(MoveApplicationAcrossQueuesResponse.class);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "563480dccd0136d82730f4228f1df44449ed5822": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5932. Retrospect moveApplicationToQueue in align with YARN-5611. Contributed by Sunil G.\n",
      "commitDate": "06/12/16 9:09 PM",
      "commitName": "563480dccd0136d82730f4228f1df44449ed5822",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "23/11/16 4:25 PM",
      "commitNameOld": "1f12867a69544a1642aa986d4f9a8249be495434",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 13.2,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,62 @@\n   public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(\n       MoveApplicationAcrossQueuesRequest request) throws YarnException {\n     ApplicationId applicationId \u003d request.getApplicationId();\n \n     UserGroupInformation callerUGI;\n     try {\n       callerUGI \u003d UserGroupInformation.getCurrentUser();\n     } catch (IOException ie) {\n       LOG.info(\"Error getting UGI \", ie);\n       RMAuditLogger.logFailure(\"UNKNOWN\", AuditConstants.MOVE_APP_REQUEST,\n           \"UNKNOWN\", \"ClientRMService\" , \"Error getting UGI\",\n           applicationId);\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     RMApp application \u003d this.rmContext.getRMApps().get(applicationId);\n     if (application \u003d\u003d null) {\n       RMAuditLogger.logFailure(callerUGI.getUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n           \"Trying to move an absent application\", applicationId);\n       throw new ApplicationNotFoundException(\"Trying to move an absent\"\n           + \" application \" + applicationId);\n     }\n \n     if (!checkAccess(callerUGI, application.getUser(),\n         ApplicationAccessType.MODIFY_APP, application)) {\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST,\n           \"User doesn\u0027t have permissions to \"\n               + ApplicationAccessType.MODIFY_APP.toString(), \"ClientRMService\",\n           AuditConstants.UNAUTHORIZED_USER, applicationId);\n       throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n           + callerUGI.getShortUserName() + \" cannot perform operation \"\n           + ApplicationAccessType.MODIFY_APP.name() + \" on \" + applicationId));\n     }\n     \n     // Moves only allowed when app is in a state that means it is tracked by\n-    // the scheduler\n-    if (EnumSet.of(RMAppState.NEW, RMAppState.NEW_SAVING, RMAppState.FAILED,\n-        RMAppState.FINAL_SAVING, RMAppState.FINISHING, RMAppState.FINISHED,\n-        RMAppState.KILLED, RMAppState.KILLING, RMAppState.FAILED)\n-        .contains(application.getState())) {\n+    // the scheduler. Introducing SUBMITTED state also to this list as there\n+    // could be a corner scenario that app may not be in Scheduler in SUBMITTED\n+    // state.\n+    if (!ACTIVE_APP_STATES.contains(application.getState())) {\n       String msg \u003d \"App in \" + application.getState() + \" state cannot be moved.\";\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\", msg);\n       throw new YarnException(msg);\n     }\n \n-    SettableFuture\u003cObject\u003e future \u003d SettableFuture.create();\n-    this.rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppMoveEvent(applicationId, request.getTargetQueue(), future));\n-    \n     try {\n-      Futures.get(future, YarnException.class);\n+      this.rmAppManager.moveApplicationAcrossQueue(applicationId, request.getTargetQueue());\n     } catch (YarnException ex) {\n       RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n           AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n           ex.getMessage());\n       throw ex;\n     }\n \n     RMAuditLogger.logSuccess(callerUGI.getShortUserName(), \n         AuditConstants.MOVE_APP_REQUEST, \"ClientRMService\" , applicationId);\n     MoveApplicationAcrossQueuesResponse response \u003d recordFactory\n         .newRecordInstance(MoveApplicationAcrossQueuesResponse.class);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(\n      MoveApplicationAcrossQueuesRequest request) throws YarnException {\n    ApplicationId applicationId \u003d request.getApplicationId();\n\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      RMAuditLogger.logFailure(\"UNKNOWN\", AuditConstants.MOVE_APP_REQUEST,\n          \"UNKNOWN\", \"ClientRMService\" , \"Error getting UGI\",\n          applicationId);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    RMApp application \u003d this.rmContext.getRMApps().get(applicationId);\n    if (application \u003d\u003d null) {\n      RMAuditLogger.logFailure(callerUGI.getUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n          \"Trying to move an absent application\", applicationId);\n      throw new ApplicationNotFoundException(\"Trying to move an absent\"\n          + \" application \" + applicationId);\n    }\n\n    if (!checkAccess(callerUGI, application.getUser(),\n        ApplicationAccessType.MODIFY_APP, application)) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST,\n          \"User doesn\u0027t have permissions to \"\n              + ApplicationAccessType.MODIFY_APP.toString(), \"ClientRMService\",\n          AuditConstants.UNAUTHORIZED_USER, applicationId);\n      throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n          + callerUGI.getShortUserName() + \" cannot perform operation \"\n          + ApplicationAccessType.MODIFY_APP.name() + \" on \" + applicationId));\n    }\n    \n    // Moves only allowed when app is in a state that means it is tracked by\n    // the scheduler. Introducing SUBMITTED state also to this list as there\n    // could be a corner scenario that app may not be in Scheduler in SUBMITTED\n    // state.\n    if (!ACTIVE_APP_STATES.contains(application.getState())) {\n      String msg \u003d \"App in \" + application.getState() + \" state cannot be moved.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\", msg);\n      throw new YarnException(msg);\n    }\n\n    try {\n      this.rmAppManager.moveApplicationAcrossQueue(applicationId, request.getTargetQueue());\n    } catch (YarnException ex) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n          ex.getMessage());\n      throw ex;\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getShortUserName(), \n        AuditConstants.MOVE_APP_REQUEST, \"ClientRMService\" , applicationId);\n    MoveApplicationAcrossQueuesResponse response \u003d recordFactory\n        .newRecordInstance(MoveApplicationAcrossQueuesResponse.class);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "1079c371289cd31478ed4bc123c1c4dd846c76ee": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1504. RM changes for moving apps between queues (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1563371 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/01/14 8:03 PM",
      "commitName": "1079c371289cd31478ed4bc123c1c4dd846c76ee",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "17/01/14 12:56 AM",
      "commitNameOld": "67cbde300811289692b4746ceb6f180f2003667b",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 14.8,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,4 +1,67 @@\n   public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(\n       MoveApplicationAcrossQueuesRequest request) throws YarnException {\n-    throw new UnsupportedOperationException(\"Move not yet supported\");\n+    ApplicationId applicationId \u003d request.getApplicationId();\n+\n+    UserGroupInformation callerUGI;\n+    try {\n+      callerUGI \u003d UserGroupInformation.getCurrentUser();\n+    } catch (IOException ie) {\n+      LOG.info(\"Error getting UGI \", ie);\n+      RMAuditLogger.logFailure(\"UNKNOWN\", AuditConstants.MOVE_APP_REQUEST,\n+          \"UNKNOWN\", \"ClientRMService\" , \"Error getting UGI\",\n+          applicationId);\n+      throw RPCUtil.getRemoteException(ie);\n+    }\n+\n+    RMApp application \u003d this.rmContext.getRMApps().get(applicationId);\n+    if (application \u003d\u003d null) {\n+      RMAuditLogger.logFailure(callerUGI.getUserName(),\n+          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n+          \"Trying to move an absent application\", applicationId);\n+      throw new ApplicationNotFoundException(\"Trying to move an absent\"\n+          + \" application \" + applicationId);\n+    }\n+\n+    if (!checkAccess(callerUGI, application.getUser(),\n+        ApplicationAccessType.MODIFY_APP, application)) {\n+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n+          AuditConstants.MOVE_APP_REQUEST,\n+          \"User doesn\u0027t have permissions to \"\n+              + ApplicationAccessType.MODIFY_APP.toString(), \"ClientRMService\",\n+          AuditConstants.UNAUTHORIZED_USER, applicationId);\n+      throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n+          + callerUGI.getShortUserName() + \" cannot perform operation \"\n+          + ApplicationAccessType.MODIFY_APP.name() + \" on \" + applicationId));\n+    }\n+    \n+    // Moves only allowed when app is in a state that means it is tracked by\n+    // the scheduler\n+    if (EnumSet.of(RMAppState.NEW, RMAppState.NEW_SAVING, RMAppState.FAILED,\n+        RMAppState.FINAL_SAVING, RMAppState.FINISHING, RMAppState.FINISHED,\n+        RMAppState.KILLED, RMAppState.KILLING, RMAppState.FAILED)\n+        .contains(application.getState())) {\n+      String msg \u003d \"App in \" + application.getState() + \" state cannot be moved.\";\n+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n+          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\", msg);\n+      throw new YarnException(msg);\n+    }\n+\n+    SettableFuture\u003cObject\u003e future \u003d SettableFuture.create();\n+    this.rmContext.getDispatcher().getEventHandler().handle(\n+        new RMAppMoveEvent(applicationId, request.getTargetQueue(), future));\n+    \n+    try {\n+      Futures.get(future, YarnException.class);\n+    } catch (YarnException ex) {\n+      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n+          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n+          ex.getMessage());\n+      throw ex;\n+    }\n+\n+    RMAuditLogger.logSuccess(callerUGI.getShortUserName(), \n+        AuditConstants.MOVE_APP_REQUEST, \"ClientRMService\" , applicationId);\n+    MoveApplicationAcrossQueuesResponse response \u003d recordFactory\n+        .newRecordInstance(MoveApplicationAcrossQueuesResponse.class);\n+    return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(\n      MoveApplicationAcrossQueuesRequest request) throws YarnException {\n    ApplicationId applicationId \u003d request.getApplicationId();\n\n    UserGroupInformation callerUGI;\n    try {\n      callerUGI \u003d UserGroupInformation.getCurrentUser();\n    } catch (IOException ie) {\n      LOG.info(\"Error getting UGI \", ie);\n      RMAuditLogger.logFailure(\"UNKNOWN\", AuditConstants.MOVE_APP_REQUEST,\n          \"UNKNOWN\", \"ClientRMService\" , \"Error getting UGI\",\n          applicationId);\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    RMApp application \u003d this.rmContext.getRMApps().get(applicationId);\n    if (application \u003d\u003d null) {\n      RMAuditLogger.logFailure(callerUGI.getUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n          \"Trying to move an absent application\", applicationId);\n      throw new ApplicationNotFoundException(\"Trying to move an absent\"\n          + \" application \" + applicationId);\n    }\n\n    if (!checkAccess(callerUGI, application.getUser(),\n        ApplicationAccessType.MODIFY_APP, application)) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST,\n          \"User doesn\u0027t have permissions to \"\n              + ApplicationAccessType.MODIFY_APP.toString(), \"ClientRMService\",\n          AuditConstants.UNAUTHORIZED_USER, applicationId);\n      throw RPCUtil.getRemoteException(new AccessControlException(\"User \"\n          + callerUGI.getShortUserName() + \" cannot perform operation \"\n          + ApplicationAccessType.MODIFY_APP.name() + \" on \" + applicationId));\n    }\n    \n    // Moves only allowed when app is in a state that means it is tracked by\n    // the scheduler\n    if (EnumSet.of(RMAppState.NEW, RMAppState.NEW_SAVING, RMAppState.FAILED,\n        RMAppState.FINAL_SAVING, RMAppState.FINISHING, RMAppState.FINISHED,\n        RMAppState.KILLED, RMAppState.KILLING, RMAppState.FAILED)\n        .contains(application.getState())) {\n      String msg \u003d \"App in \" + application.getState() + \" state cannot be moved.\";\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\", msg);\n      throw new YarnException(msg);\n    }\n\n    SettableFuture\u003cObject\u003e future \u003d SettableFuture.create();\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppMoveEvent(applicationId, request.getTargetQueue(), future));\n    \n    try {\n      Futures.get(future, YarnException.class);\n    } catch (YarnException ex) {\n      RMAuditLogger.logFailure(callerUGI.getShortUserName(),\n          AuditConstants.MOVE_APP_REQUEST, \"UNKNOWN\", \"ClientRMService\",\n          ex.getMessage());\n      throw ex;\n    }\n\n    RMAuditLogger.logSuccess(callerUGI.getShortUserName(), \n        AuditConstants.MOVE_APP_REQUEST, \"ClientRMService\" , applicationId);\n    MoveApplicationAcrossQueuesResponse response \u003d recordFactory\n        .newRecordInstance(MoveApplicationAcrossQueuesResponse.class);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java",
      "extendedDetails": {}
    },
    "67cbde300811289692b4746ceb6f180f2003667b": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1496. Protocol additions to allow moving apps between queues (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1559050 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/01/14 12:56 AM",
      "commitName": "67cbde300811289692b4746ceb6f180f2003667b",
      "commitAuthor": "Sanford Ryza",
      "diff": "@@ -0,0 +1,4 @@\n+  public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(\n+      MoveApplicationAcrossQueuesRequest request) throws YarnException {\n+    throw new UnsupportedOperationException(\"Move not yet supported\");\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public MoveApplicationAcrossQueuesResponse moveApplicationAcrossQueues(\n      MoveApplicationAcrossQueuesRequest request) throws YarnException {\n    throw new UnsupportedOperationException(\"Move not yet supported\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ClientRMService.java"
    }
  }
}