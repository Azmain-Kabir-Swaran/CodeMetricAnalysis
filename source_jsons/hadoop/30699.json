{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RollingLevelDBTimelineStore.java",
  "functionName": "getEntityTimelines",
  "functionId": "getEntityTimelines___entityType-String__entityIds-SortedSet__String____limit-Long__windowStart-Long__windowEnd-Long__eventType-Set__String__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
  "functionStartLine": 541,
  "functionEndLine": 625,
  "numCommitsSeen": 12,
  "timeTaken": 1366,
  "changeHistory": [
    "01aca54a22c8586d232a8f79fe9977aeb8d09b83",
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f"
  ],
  "changeHistoryShort": {
    "01aca54a22c8586d232a8f79fe9977aeb8d09b83": "Ybodychange",
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "01aca54a22c8586d232a8f79fe9977aeb8d09b83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5368. Memory leak in timeline server (Jonathan Eagles via Varun Saxena)\n",
      "commitDate": "28/03/17 1:23 PM",
      "commitName": "01aca54a22c8586d232a8f79fe9977aeb8d09b83",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "20/07/16 8:36 AM",
      "commitNameOld": "1c9d2ab503ea5a3f16757351af9603041059b390",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 251.2,
      "commitsBetweenForRepo": 1583,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,85 @@\n   public TimelineEvents getEntityTimelines(String entityType,\n       SortedSet\u003cString\u003e entityIds, Long limit, Long windowStart,\n       Long windowEnd, Set\u003cString\u003e eventType) throws IOException {\n     TimelineEvents events \u003d new TimelineEvents();\n     if (entityIds \u003d\u003d null || entityIds.isEmpty()) {\n       return events;\n     }\n     // create a lexicographically-ordered map from start time to entities\n     Map\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e startTimeMap \u003d\n         new TreeMap\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e(\n         new Comparator\u003cbyte[]\u003e() {\n           @Override\n           public int compare(byte[] o1, byte[] o2) {\n             return WritableComparator.compareBytes(o1, 0, o1.length, o2, 0,\n                 o2.length);\n           }\n         });\n-    DBIterator iterator \u003d null;\n-    try {\n+\n       // look up start times for the specified entities\n       // skip entities with no start time\n-      for (String entityId : entityIds) {\n-        byte[] startTime \u003d getStartTime(entityId, entityType);\n-        if (startTime !\u003d null) {\n-          List\u003cEntityIdentifier\u003e entities \u003d startTimeMap.get(startTime);\n-          if (entities \u003d\u003d null) {\n-            entities \u003d new ArrayList\u003cEntityIdentifier\u003e();\n-            startTimeMap.put(startTime, entities);\n-          }\n-          entities.add(new EntityIdentifier(entityId, entityType));\n+    for (String entityId : entityIds) {\n+      byte[] startTime \u003d getStartTime(entityId, entityType);\n+      if (startTime !\u003d null) {\n+        List\u003cEntityIdentifier\u003e entities \u003d startTimeMap.get(startTime);\n+        if (entities \u003d\u003d null) {\n+          entities \u003d new ArrayList\u003cEntityIdentifier\u003e();\n+          startTimeMap.put(startTime, entities);\n         }\n+        entities.add(new EntityIdentifier(entityId, entityType));\n       }\n-      for (Entry\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e entry : startTimeMap\n+    }\n+    for (Entry\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e entry : startTimeMap\n           .entrySet()) {\n-        // look up the events matching the given parameters (limit,\n-        // start time, end time, event types) for entities whose start times\n-        // were found and add the entities to the return list\n-        byte[] revStartTime \u003d entry.getKey();\n-        for (EntityIdentifier entityIdentifier : entry.getValue()) {\n-          EventsOfOneEntity entity \u003d new EventsOfOneEntity();\n-          entity.setEntityId(entityIdentifier.getId());\n-          entity.setEntityType(entityType);\n-          events.addEvent(entity);\n-          KeyBuilder kb \u003d KeyBuilder.newInstance().add(entityType)\n-              .add(revStartTime).add(entityIdentifier.getId())\n-              .add(EVENTS_COLUMN);\n-          byte[] prefix \u003d kb.getBytesForLookup();\n-          if (windowEnd \u003d\u003d null) {\n-            windowEnd \u003d Long.MAX_VALUE;\n-          }\n-          byte[] revts \u003d writeReverseOrderedLong(windowEnd);\n-          kb.add(revts);\n-          byte[] first \u003d kb.getBytesForLookup();\n-          byte[] last \u003d null;\n-          if (windowStart !\u003d null) {\n-            last \u003d KeyBuilder.newInstance().add(prefix)\n-                .add(writeReverseOrderedLong(windowStart)).getBytesForLookup();\n-          }\n-          if (limit \u003d\u003d null) {\n-            limit \u003d DEFAULT_LIMIT;\n-          }\n-          DB db \u003d entitydb.getDBForStartTime(readReverseOrderedLong(\n-              revStartTime, 0));\n-          if (db \u003d\u003d null) {\n-            continue;\n-          }\n-          iterator \u003d db.iterator();\n+      // look up the events matching the given parameters (limit,\n+      // start time, end time, event types) for entities whose start times\n+      // were found and add the entities to the return list\n+      byte[] revStartTime \u003d entry.getKey();\n+      for (EntityIdentifier entityIdentifier : entry.getValue()) {\n+        EventsOfOneEntity entity \u003d new EventsOfOneEntity();\n+        entity.setEntityId(entityIdentifier.getId());\n+        entity.setEntityType(entityType);\n+        events.addEvent(entity);\n+        KeyBuilder kb \u003d KeyBuilder.newInstance().add(entityType)\n+            .add(revStartTime).add(entityIdentifier.getId())\n+            .add(EVENTS_COLUMN);\n+        byte[] prefix \u003d kb.getBytesForLookup();\n+        if (windowEnd \u003d\u003d null) {\n+          windowEnd \u003d Long.MAX_VALUE;\n+        }\n+        byte[] revts \u003d writeReverseOrderedLong(windowEnd);\n+        kb.add(revts);\n+        byte[] first \u003d kb.getBytesForLookup();\n+        byte[] last \u003d null;\n+        if (windowStart !\u003d null) {\n+          last \u003d KeyBuilder.newInstance().add(prefix)\n+              .add(writeReverseOrderedLong(windowStart)).getBytesForLookup();\n+        }\n+        if (limit \u003d\u003d null) {\n+          limit \u003d DEFAULT_LIMIT;\n+        }\n+        DB db \u003d entitydb.getDBForStartTime(readReverseOrderedLong(\n+            revStartTime, 0));\n+        if (db \u003d\u003d null) {\n+          continue;\n+        }\n+        try (DBIterator iterator \u003d db.iterator()) {\n           for (iterator.seek(first); entity.getEvents().size() \u003c limit\n               \u0026\u0026 iterator.hasNext(); iterator.next()) {\n             byte[] key \u003d iterator.peekNext().getKey();\n             if (!prefixMatches(prefix, prefix.length, key)\n                 || (last !\u003d null \u0026\u0026 WritableComparator.compareBytes(key, 0,\n-                    key.length, last, 0, last.length) \u003e 0)) {\n+                key.length, last, 0, last.length) \u003e 0)) {\n               break;\n             }\n             TimelineEvent event \u003d getEntityEvent(eventType, key, prefix.length,\n                 iterator.peekNext().getValue());\n             if (event !\u003d null) {\n               entity.addEvent(event);\n             }\n           }\n         }\n       }\n-    } finally {\n-      IOUtils.cleanup(LOG, iterator);\n     }\n     return events;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelineEvents getEntityTimelines(String entityType,\n      SortedSet\u003cString\u003e entityIds, Long limit, Long windowStart,\n      Long windowEnd, Set\u003cString\u003e eventType) throws IOException {\n    TimelineEvents events \u003d new TimelineEvents();\n    if (entityIds \u003d\u003d null || entityIds.isEmpty()) {\n      return events;\n    }\n    // create a lexicographically-ordered map from start time to entities\n    Map\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e startTimeMap \u003d\n        new TreeMap\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e(\n        new Comparator\u003cbyte[]\u003e() {\n          @Override\n          public int compare(byte[] o1, byte[] o2) {\n            return WritableComparator.compareBytes(o1, 0, o1.length, o2, 0,\n                o2.length);\n          }\n        });\n\n      // look up start times for the specified entities\n      // skip entities with no start time\n    for (String entityId : entityIds) {\n      byte[] startTime \u003d getStartTime(entityId, entityType);\n      if (startTime !\u003d null) {\n        List\u003cEntityIdentifier\u003e entities \u003d startTimeMap.get(startTime);\n        if (entities \u003d\u003d null) {\n          entities \u003d new ArrayList\u003cEntityIdentifier\u003e();\n          startTimeMap.put(startTime, entities);\n        }\n        entities.add(new EntityIdentifier(entityId, entityType));\n      }\n    }\n    for (Entry\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e entry : startTimeMap\n          .entrySet()) {\n      // look up the events matching the given parameters (limit,\n      // start time, end time, event types) for entities whose start times\n      // were found and add the entities to the return list\n      byte[] revStartTime \u003d entry.getKey();\n      for (EntityIdentifier entityIdentifier : entry.getValue()) {\n        EventsOfOneEntity entity \u003d new EventsOfOneEntity();\n        entity.setEntityId(entityIdentifier.getId());\n        entity.setEntityType(entityType);\n        events.addEvent(entity);\n        KeyBuilder kb \u003d KeyBuilder.newInstance().add(entityType)\n            .add(revStartTime).add(entityIdentifier.getId())\n            .add(EVENTS_COLUMN);\n        byte[] prefix \u003d kb.getBytesForLookup();\n        if (windowEnd \u003d\u003d null) {\n          windowEnd \u003d Long.MAX_VALUE;\n        }\n        byte[] revts \u003d writeReverseOrderedLong(windowEnd);\n        kb.add(revts);\n        byte[] first \u003d kb.getBytesForLookup();\n        byte[] last \u003d null;\n        if (windowStart !\u003d null) {\n          last \u003d KeyBuilder.newInstance().add(prefix)\n              .add(writeReverseOrderedLong(windowStart)).getBytesForLookup();\n        }\n        if (limit \u003d\u003d null) {\n          limit \u003d DEFAULT_LIMIT;\n        }\n        DB db \u003d entitydb.getDBForStartTime(readReverseOrderedLong(\n            revStartTime, 0));\n        if (db \u003d\u003d null) {\n          continue;\n        }\n        try (DBIterator iterator \u003d db.iterator()) {\n          for (iterator.seek(first); entity.getEvents().size() \u003c limit\n              \u0026\u0026 iterator.hasNext(); iterator.next()) {\n            byte[] key \u003d iterator.peekNext().getKey();\n            if (!prefixMatches(prefix, prefix.length, key)\n                || (last !\u003d null \u0026\u0026 WritableComparator.compareBytes(key, 0,\n                key.length, last, 0, last.length) \u003e 0)) {\n              break;\n            }\n            TimelineEvent event \u003d getEntityEvent(eventType, key, prefix.length,\n                iterator.peekNext().getValue());\n            if (event !\u003d null) {\n              entity.addEvent(event);\n            }\n          }\n        }\n      }\n    }\n    return events;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
      "extendedDetails": {}
    },
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3448. Added a rolling time-to-live LevelDB timeline store implementation. Contributed by Jonathan Eagles.\n",
      "commitDate": "07/05/15 10:01 AM",
      "commitName": "daf3e4ef8bf73cbe4a799d51b4765809cd81089f",
      "commitAuthor": "Zhijie Shen",
      "diff": "@@ -0,0 +1,88 @@\n+  public TimelineEvents getEntityTimelines(String entityType,\n+      SortedSet\u003cString\u003e entityIds, Long limit, Long windowStart,\n+      Long windowEnd, Set\u003cString\u003e eventType) throws IOException {\n+    TimelineEvents events \u003d new TimelineEvents();\n+    if (entityIds \u003d\u003d null || entityIds.isEmpty()) {\n+      return events;\n+    }\n+    // create a lexicographically-ordered map from start time to entities\n+    Map\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e startTimeMap \u003d\n+        new TreeMap\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e(\n+        new Comparator\u003cbyte[]\u003e() {\n+          @Override\n+          public int compare(byte[] o1, byte[] o2) {\n+            return WritableComparator.compareBytes(o1, 0, o1.length, o2, 0,\n+                o2.length);\n+          }\n+        });\n+    DBIterator iterator \u003d null;\n+    try {\n+      // look up start times for the specified entities\n+      // skip entities with no start time\n+      for (String entityId : entityIds) {\n+        byte[] startTime \u003d getStartTime(entityId, entityType);\n+        if (startTime !\u003d null) {\n+          List\u003cEntityIdentifier\u003e entities \u003d startTimeMap.get(startTime);\n+          if (entities \u003d\u003d null) {\n+            entities \u003d new ArrayList\u003cEntityIdentifier\u003e();\n+            startTimeMap.put(startTime, entities);\n+          }\n+          entities.add(new EntityIdentifier(entityId, entityType));\n+        }\n+      }\n+      for (Entry\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e entry : startTimeMap\n+          .entrySet()) {\n+        // look up the events matching the given parameters (limit,\n+        // start time, end time, event types) for entities whose start times\n+        // were found and add the entities to the return list\n+        byte[] revStartTime \u003d entry.getKey();\n+        for (EntityIdentifier entityIdentifier : entry.getValue()) {\n+          EventsOfOneEntity entity \u003d new EventsOfOneEntity();\n+          entity.setEntityId(entityIdentifier.getId());\n+          entity.setEntityType(entityType);\n+          events.addEvent(entity);\n+          KeyBuilder kb \u003d KeyBuilder.newInstance().add(entityType)\n+              .add(revStartTime).add(entityIdentifier.getId())\n+              .add(EVENTS_COLUMN);\n+          byte[] prefix \u003d kb.getBytesForLookup();\n+          if (windowEnd \u003d\u003d null) {\n+            windowEnd \u003d Long.MAX_VALUE;\n+          }\n+          byte[] revts \u003d writeReverseOrderedLong(windowEnd);\n+          kb.add(revts);\n+          byte[] first \u003d kb.getBytesForLookup();\n+          byte[] last \u003d null;\n+          if (windowStart !\u003d null) {\n+            last \u003d KeyBuilder.newInstance().add(prefix)\n+                .add(writeReverseOrderedLong(windowStart)).getBytesForLookup();\n+          }\n+          if (limit \u003d\u003d null) {\n+            limit \u003d DEFAULT_LIMIT;\n+          }\n+          DB db \u003d entitydb.getDBForStartTime(readReverseOrderedLong(\n+              revStartTime, 0));\n+          if (db \u003d\u003d null) {\n+            continue;\n+          }\n+          iterator \u003d db.iterator();\n+          for (iterator.seek(first); entity.getEvents().size() \u003c limit\n+              \u0026\u0026 iterator.hasNext(); iterator.next()) {\n+            byte[] key \u003d iterator.peekNext().getKey();\n+            if (!prefixMatches(prefix, prefix.length, key)\n+                || (last !\u003d null \u0026\u0026 WritableComparator.compareBytes(key, 0,\n+                    key.length, last, 0, last.length) \u003e 0)) {\n+              break;\n+            }\n+            TimelineEvent event \u003d getEntityEvent(eventType, key, prefix.length,\n+                iterator.peekNext().getValue());\n+            if (event !\u003d null) {\n+              entity.addEvent(event);\n+            }\n+          }\n+        }\n+      }\n+    } finally {\n+      IOUtils.cleanup(LOG, iterator);\n+    }\n+    return events;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public TimelineEvents getEntityTimelines(String entityType,\n      SortedSet\u003cString\u003e entityIds, Long limit, Long windowStart,\n      Long windowEnd, Set\u003cString\u003e eventType) throws IOException {\n    TimelineEvents events \u003d new TimelineEvents();\n    if (entityIds \u003d\u003d null || entityIds.isEmpty()) {\n      return events;\n    }\n    // create a lexicographically-ordered map from start time to entities\n    Map\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e startTimeMap \u003d\n        new TreeMap\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e(\n        new Comparator\u003cbyte[]\u003e() {\n          @Override\n          public int compare(byte[] o1, byte[] o2) {\n            return WritableComparator.compareBytes(o1, 0, o1.length, o2, 0,\n                o2.length);\n          }\n        });\n    DBIterator iterator \u003d null;\n    try {\n      // look up start times for the specified entities\n      // skip entities with no start time\n      for (String entityId : entityIds) {\n        byte[] startTime \u003d getStartTime(entityId, entityType);\n        if (startTime !\u003d null) {\n          List\u003cEntityIdentifier\u003e entities \u003d startTimeMap.get(startTime);\n          if (entities \u003d\u003d null) {\n            entities \u003d new ArrayList\u003cEntityIdentifier\u003e();\n            startTimeMap.put(startTime, entities);\n          }\n          entities.add(new EntityIdentifier(entityId, entityType));\n        }\n      }\n      for (Entry\u003cbyte[], List\u003cEntityIdentifier\u003e\u003e entry : startTimeMap\n          .entrySet()) {\n        // look up the events matching the given parameters (limit,\n        // start time, end time, event types) for entities whose start times\n        // were found and add the entities to the return list\n        byte[] revStartTime \u003d entry.getKey();\n        for (EntityIdentifier entityIdentifier : entry.getValue()) {\n          EventsOfOneEntity entity \u003d new EventsOfOneEntity();\n          entity.setEntityId(entityIdentifier.getId());\n          entity.setEntityType(entityType);\n          events.addEvent(entity);\n          KeyBuilder kb \u003d KeyBuilder.newInstance().add(entityType)\n              .add(revStartTime).add(entityIdentifier.getId())\n              .add(EVENTS_COLUMN);\n          byte[] prefix \u003d kb.getBytesForLookup();\n          if (windowEnd \u003d\u003d null) {\n            windowEnd \u003d Long.MAX_VALUE;\n          }\n          byte[] revts \u003d writeReverseOrderedLong(windowEnd);\n          kb.add(revts);\n          byte[] first \u003d kb.getBytesForLookup();\n          byte[] last \u003d null;\n          if (windowStart !\u003d null) {\n            last \u003d KeyBuilder.newInstance().add(prefix)\n                .add(writeReverseOrderedLong(windowStart)).getBytesForLookup();\n          }\n          if (limit \u003d\u003d null) {\n            limit \u003d DEFAULT_LIMIT;\n          }\n          DB db \u003d entitydb.getDBForStartTime(readReverseOrderedLong(\n              revStartTime, 0));\n          if (db \u003d\u003d null) {\n            continue;\n          }\n          iterator \u003d db.iterator();\n          for (iterator.seek(first); entity.getEvents().size() \u003c limit\n              \u0026\u0026 iterator.hasNext(); iterator.next()) {\n            byte[] key \u003d iterator.peekNext().getKey();\n            if (!prefixMatches(prefix, prefix.length, key)\n                || (last !\u003d null \u0026\u0026 WritableComparator.compareBytes(key, 0,\n                    key.length, last, 0, last.length) \u003e 0)) {\n              break;\n            }\n            TimelineEvent event \u003d getEntityEvent(eventType, key, prefix.length,\n                iterator.peekNext().getValue());\n            if (event !\u003d null) {\n              entity.addEvent(event);\n            }\n          }\n        }\n      }\n    } finally {\n      IOUtils.cleanup(LOG, iterator);\n    }\n    return events;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java"
    }
  }
}