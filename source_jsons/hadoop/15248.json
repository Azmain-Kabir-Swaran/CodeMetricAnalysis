{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DFSAdmin.java",
  "functionName": "genericRefresh",
  "functionId": "genericRefresh___argv-String[]__i-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
  "functionStartLine": 2029,
  "functionEndLine": 2082,
  "numCommitsSeen": 114,
  "timeTaken": 3001,
  "changeHistory": [
    "b53fd7163bc3a4eef4632afb55e5513c7c592fcf",
    "34e9173c00f7e1ae55dec365850849c793cde8e3"
  ],
  "changeHistoryShort": {
    "b53fd7163bc3a4eef4632afb55e5513c7c592fcf": "Ybodychange",
    "34e9173c00f7e1ae55dec365850849c793cde8e3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b53fd7163bc3a4eef4632afb55e5513c7c592fcf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7008. xlator should be closed upon exit from DFSAdmin#genericRefresh(). (ozawa)\n",
      "commitDate": "24/02/15 6:59 AM",
      "commitName": "b53fd7163bc3a4eef4632afb55e5513c7c592fcf",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "21/02/15 3:38 PM",
      "commitNameOld": "8b465b4b8caed31ca9daeaae108f9a868a30a455",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 2.64,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,54 @@\n   public int genericRefresh(String[] argv, int i) throws IOException {\n     String hostport \u003d argv[i++];\n     String identifier \u003d argv[i++];\n     String[] args \u003d Arrays.copyOfRange(argv, i, argv.length);\n \n     // Get the current configuration\n     Configuration conf \u003d getConf();\n \n     // for security authorization\n     // server principal for this call\n     // should be NN\u0027s one.\n     conf.set(CommonConfigurationKeys.HADOOP_SECURITY_SERVICE_USER_NAME_KEY,\n       conf.get(DFSConfigKeys.DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY, \"\"));\n \n     // Create the client\n     Class\u003c?\u003e xface \u003d GenericRefreshProtocolPB.class;\n     InetSocketAddress address \u003d NetUtils.createSocketAddr(hostport);\n     UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n \n     RPC.setProtocolEngine(conf, xface, ProtobufRpcEngine.class);\n     GenericRefreshProtocolPB proxy \u003d (GenericRefreshProtocolPB)\n       RPC.getProxy(xface, RPC.getProtocolVersion(xface), address,\n         ugi, conf, NetUtils.getDefaultSocketFactory(conf), 0);\n \n-    GenericRefreshProtocol xlator \u003d\n-      new GenericRefreshProtocolClientSideTranslatorPB(proxy);\n+    Collection\u003cRefreshResponse\u003e responses \u003d null;\n+    try (GenericRefreshProtocolClientSideTranslatorPB xlator \u003d\n+        new GenericRefreshProtocolClientSideTranslatorPB(proxy);) {\n+      // Refresh\n+      responses \u003d xlator.refresh(identifier, args);\n \n-    // Refresh\n-    Collection\u003cRefreshResponse\u003e responses \u003d xlator.refresh(identifier, args);\n+      int returnCode \u003d 0;\n \n-    int returnCode \u003d 0;\n+      // Print refresh responses\n+      System.out.println(\"Refresh Responses:\\n\");\n+      for (RefreshResponse response : responses) {\n+        System.out.println(response.toString());\n \n-    // Print refresh responses\n-    System.out.println(\"Refresh Responses:\\n\");\n-    for (RefreshResponse response : responses) {\n-      System.out.println(response.toString());\n-\n-      if (returnCode \u003d\u003d 0 \u0026\u0026 response.getReturnCode() !\u003d 0) {\n-        // This is the first non-zero return code, so we should return this\n-        returnCode \u003d response.getReturnCode();\n-      } else if (returnCode !\u003d 0 \u0026\u0026 response.getReturnCode() !\u003d 0) {\n-        // Then now we have multiple non-zero return codes,\n-        // so we merge them into -1\n-        returnCode \u003d -1;\n+        if (returnCode \u003d\u003d 0 \u0026\u0026 response.getReturnCode() !\u003d 0) {\n+          // This is the first non-zero return code, so we should return this\n+          returnCode \u003d response.getReturnCode();\n+        } else if (returnCode !\u003d 0 \u0026\u0026 response.getReturnCode() !\u003d 0) {\n+          // Then now we have multiple non-zero return codes,\n+          // so we merge them into -1\n+          returnCode \u003d - 1;\n+        }\n+      }\n+      return returnCode;\n+    } finally {\n+      if (responses \u003d\u003d null) {\n+        System.out.println(\"Failed to get response.\\n\");\n+        return -1;\n       }\n     }\n-\n-    return returnCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int genericRefresh(String[] argv, int i) throws IOException {\n    String hostport \u003d argv[i++];\n    String identifier \u003d argv[i++];\n    String[] args \u003d Arrays.copyOfRange(argv, i, argv.length);\n\n    // Get the current configuration\n    Configuration conf \u003d getConf();\n\n    // for security authorization\n    // server principal for this call\n    // should be NN\u0027s one.\n    conf.set(CommonConfigurationKeys.HADOOP_SECURITY_SERVICE_USER_NAME_KEY,\n      conf.get(DFSConfigKeys.DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY, \"\"));\n\n    // Create the client\n    Class\u003c?\u003e xface \u003d GenericRefreshProtocolPB.class;\n    InetSocketAddress address \u003d NetUtils.createSocketAddr(hostport);\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n\n    RPC.setProtocolEngine(conf, xface, ProtobufRpcEngine.class);\n    GenericRefreshProtocolPB proxy \u003d (GenericRefreshProtocolPB)\n      RPC.getProxy(xface, RPC.getProtocolVersion(xface), address,\n        ugi, conf, NetUtils.getDefaultSocketFactory(conf), 0);\n\n    Collection\u003cRefreshResponse\u003e responses \u003d null;\n    try (GenericRefreshProtocolClientSideTranslatorPB xlator \u003d\n        new GenericRefreshProtocolClientSideTranslatorPB(proxy);) {\n      // Refresh\n      responses \u003d xlator.refresh(identifier, args);\n\n      int returnCode \u003d 0;\n\n      // Print refresh responses\n      System.out.println(\"Refresh Responses:\\n\");\n      for (RefreshResponse response : responses) {\n        System.out.println(response.toString());\n\n        if (returnCode \u003d\u003d 0 \u0026\u0026 response.getReturnCode() !\u003d 0) {\n          // This is the first non-zero return code, so we should return this\n          returnCode \u003d response.getReturnCode();\n        } else if (returnCode !\u003d 0 \u0026\u0026 response.getReturnCode() !\u003d 0) {\n          // Then now we have multiple non-zero return codes,\n          // so we merge them into -1\n          returnCode \u003d - 1;\n        }\n      }\n      return returnCode;\n    } finally {\n      if (responses \u003d\u003d null) {\n        System.out.println(\"Failed to get response.\\n\");\n        return -1;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java",
      "extendedDetails": {}
    },
    "34e9173c00f7e1ae55dec365850849c793cde8e3": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10376. Refactor refresh*Protocols into a single generic refreshConfigProtocol. (Contributed by Chris Li)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1602055 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/14 6:27 PM",
      "commitName": "34e9173c00f7e1ae55dec365850849c793cde8e3",
      "commitAuthor": "Arpit Agarwal",
      "diff": "@@ -0,0 +1,49 @@\n+  public int genericRefresh(String[] argv, int i) throws IOException {\n+    String hostport \u003d argv[i++];\n+    String identifier \u003d argv[i++];\n+    String[] args \u003d Arrays.copyOfRange(argv, i, argv.length);\n+\n+    // Get the current configuration\n+    Configuration conf \u003d getConf();\n+\n+    // for security authorization\n+    // server principal for this call\n+    // should be NN\u0027s one.\n+    conf.set(CommonConfigurationKeys.HADOOP_SECURITY_SERVICE_USER_NAME_KEY,\n+      conf.get(DFSConfigKeys.DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY, \"\"));\n+\n+    // Create the client\n+    Class\u003c?\u003e xface \u003d GenericRefreshProtocolPB.class;\n+    InetSocketAddress address \u003d NetUtils.createSocketAddr(hostport);\n+    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n+\n+    RPC.setProtocolEngine(conf, xface, ProtobufRpcEngine.class);\n+    GenericRefreshProtocolPB proxy \u003d (GenericRefreshProtocolPB)\n+      RPC.getProxy(xface, RPC.getProtocolVersion(xface), address,\n+        ugi, conf, NetUtils.getDefaultSocketFactory(conf), 0);\n+\n+    GenericRefreshProtocol xlator \u003d\n+      new GenericRefreshProtocolClientSideTranslatorPB(proxy);\n+\n+    // Refresh\n+    Collection\u003cRefreshResponse\u003e responses \u003d xlator.refresh(identifier, args);\n+\n+    int returnCode \u003d 0;\n+\n+    // Print refresh responses\n+    System.out.println(\"Refresh Responses:\\n\");\n+    for (RefreshResponse response : responses) {\n+      System.out.println(response.toString());\n+\n+      if (returnCode \u003d\u003d 0 \u0026\u0026 response.getReturnCode() !\u003d 0) {\n+        // This is the first non-zero return code, so we should return this\n+        returnCode \u003d response.getReturnCode();\n+      } else if (returnCode !\u003d 0 \u0026\u0026 response.getReturnCode() !\u003d 0) {\n+        // Then now we have multiple non-zero return codes,\n+        // so we merge them into -1\n+        returnCode \u003d -1;\n+      }\n+    }\n+\n+    return returnCode;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int genericRefresh(String[] argv, int i) throws IOException {\n    String hostport \u003d argv[i++];\n    String identifier \u003d argv[i++];\n    String[] args \u003d Arrays.copyOfRange(argv, i, argv.length);\n\n    // Get the current configuration\n    Configuration conf \u003d getConf();\n\n    // for security authorization\n    // server principal for this call\n    // should be NN\u0027s one.\n    conf.set(CommonConfigurationKeys.HADOOP_SECURITY_SERVICE_USER_NAME_KEY,\n      conf.get(DFSConfigKeys.DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY, \"\"));\n\n    // Create the client\n    Class\u003c?\u003e xface \u003d GenericRefreshProtocolPB.class;\n    InetSocketAddress address \u003d NetUtils.createSocketAddr(hostport);\n    UserGroupInformation ugi \u003d UserGroupInformation.getCurrentUser();\n\n    RPC.setProtocolEngine(conf, xface, ProtobufRpcEngine.class);\n    GenericRefreshProtocolPB proxy \u003d (GenericRefreshProtocolPB)\n      RPC.getProxy(xface, RPC.getProtocolVersion(xface), address,\n        ugi, conf, NetUtils.getDefaultSocketFactory(conf), 0);\n\n    GenericRefreshProtocol xlator \u003d\n      new GenericRefreshProtocolClientSideTranslatorPB(proxy);\n\n    // Refresh\n    Collection\u003cRefreshResponse\u003e responses \u003d xlator.refresh(identifier, args);\n\n    int returnCode \u003d 0;\n\n    // Print refresh responses\n    System.out.println(\"Refresh Responses:\\n\");\n    for (RefreshResponse response : responses) {\n      System.out.println(response.toString());\n\n      if (returnCode \u003d\u003d 0 \u0026\u0026 response.getReturnCode() !\u003d 0) {\n        // This is the first non-zero return code, so we should return this\n        returnCode \u003d response.getReturnCode();\n      } else if (returnCode !\u003d 0 \u0026\u0026 response.getReturnCode() !\u003d 0) {\n        // Then now we have multiple non-zero return codes,\n        // so we merge them into -1\n        returnCode \u003d -1;\n      }\n    }\n\n    return returnCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSAdmin.java"
    }
  }
}