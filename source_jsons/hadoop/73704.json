{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "WritableRpcEngine.java",
  "functionName": "call",
  "functionId": "call___server-org.apache.hadoop.ipc.RPC.Server__protocolName-String__rpcRequest-Writable__receivedTime-long",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/WritableRpcEngine.java",
  "functionStartLine": 484,
  "functionEndLine": 579,
  "numCommitsSeen": 37,
  "timeTaken": 2179,
  "changeHistory": [
    "f96a2df38d889f29314c57f4d94227b2e419a11f",
    "3d94da1e00fc6238fad458e415219f87920f1fc3",
    "93d8a7f2a2d72a1719d02b1ed90678397900b6ed"
  ],
  "changeHistoryShort": {
    "f96a2df38d889f29314c57f4d94227b2e419a11f": "Ybodychange",
    "3d94da1e00fc6238fad458e415219f87920f1fc3": "Ybodychange",
    "93d8a7f2a2d72a1719d02b1ed90678397900b6ed": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f96a2df38d889f29314c57f4d94227b2e419a11f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16266. Add more fine-grained processing time metrics to the RPC layer. Contributed by Christopher Gregorian.\n",
      "commitDate": "23/05/19 10:28 AM",
      "commitName": "f96a2df38d889f29314c57f4d94227b2e419a11f",
      "commitAuthor": "Christopher Gregorian",
      "commitDateOld": "11/01/19 10:54 AM",
      "commitNameOld": "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 131.94,
      "commitsBetweenForRepo": 924,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,96 @@\n       public Writable call(org.apache.hadoop.ipc.RPC.Server server,\n           String protocolName, Writable rpcRequest, long receivedTime)\n           throws IOException, RPC.VersionMismatch {\n \n         Invocation call \u003d (Invocation)rpcRequest;\n         if (server.verbose) log(\"Call: \" + call);\n \n         // Verify writable rpc version\n         if (call.getRpcVersion() !\u003d writableRpcVersion) {\n           // Client is using a different version of WritableRpc\n           throw new RpcServerException(\n               \"WritableRpc version mismatch, client side version\u003d\"\n                   + call.getRpcVersion() + \", server side version\u003d\"\n                   + writableRpcVersion);\n         }\n \n         long clientVersion \u003d call.getProtocolVersion();\n         final String protoName;\n         ProtoClassProtoImpl protocolImpl;\n         if (call.declaringClassProtocolName.equals(VersionedProtocol.class.getName())) {\n           // VersionProtocol methods are often used by client to figure out\n           // which version of protocol to use.\n           //\n           // Versioned protocol methods should go the protocolName protocol\n           // rather than the declaring class of the method since the\n           // the declaring class is VersionedProtocol which is not \n           // registered directly.\n           // Send the call to the highest  protocol version\n           VerProtocolImpl highest \u003d server.getHighestSupportedProtocol(\n               RPC.RpcKind.RPC_WRITABLE, protocolName);\n           if (highest \u003d\u003d null) {\n             throw new RpcServerException(\"Unknown protocol: \" + protocolName);\n           }\n           protocolImpl \u003d highest.protocolTarget;\n         } else {\n           protoName \u003d call.declaringClassProtocolName;\n \n           // Find the right impl for the protocol based on client version.\n           ProtoNameVer pv \u003d \n               new ProtoNameVer(call.declaringClassProtocolName, clientVersion);\n           protocolImpl \u003d \n               server.getProtocolImplMap(RPC.RpcKind.RPC_WRITABLE).get(pv);\n           if (protocolImpl \u003d\u003d null) { // no match for Protocol AND Version\n              VerProtocolImpl highest \u003d \n                  server.getHighestSupportedProtocol(RPC.RpcKind.RPC_WRITABLE, \n                      protoName);\n             if (highest \u003d\u003d null) {\n               throw new RpcServerException(\"Unknown protocol: \" + protoName);\n             } else { // protocol supported but not the version that client wants\n               throw new RPC.VersionMismatch(protoName, clientVersion,\n                 highest.version);\n             }\n           }\n         }\n \n         // Invoke the protocol method\n-        long startTime \u003d Time.now();\n-        int qTime \u003d (int) (startTime-receivedTime);\n         Exception exception \u003d null;\n+        Call currentCall \u003d Server.getCurCall().get();\n         try {\n           Method method \u003d\n               protocolImpl.protocolClass.getMethod(call.getMethodName(),\n               call.getParameterClasses());\n           method.setAccessible(true);\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n+          currentCall.setDetailedMetricsName(call.getMethodName());\n           Object value \u003d \n               method.invoke(protocolImpl.protocolImpl, call.getParameters());\n           if (server.verbose) log(\"Return: \"+value);\n           return new ObjectWritable(method.getReturnType(), value);\n \n         } catch (InvocationTargetException e) {\n           Throwable target \u003d e.getTargetException();\n           if (target instanceof IOException) {\n             exception \u003d (IOException)target;\n             throw (IOException)target;\n           } else {\n             IOException ioe \u003d new IOException(target.toString());\n             ioe.setStackTrace(target.getStackTrace());\n             exception \u003d ioe;\n             throw ioe;\n           }\n         } catch (Throwable e) {\n           if (!(e instanceof IOException)) {\n             LOG.error(\"Unexpected throwable object \", e);\n           }\n           IOException ioe \u003d new IOException(e.toString());\n           ioe.setStackTrace(e.getStackTrace());\n           exception \u003d ioe;\n           throw ioe;\n         } finally {\n-          int processingTime \u003d (int) (Time.now() - startTime);\n-          if (LOG.isDebugEnabled()) {\n-            String msg \u003d \"Served: \" + call.getMethodName() +\n-                \" queueTime\u003d \" + qTime + \" procesingTime\u003d \" + processingTime;\n-            if (exception !\u003d null) {\n-              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n-            }\n-            LOG.debug(msg);\n+          if (exception !\u003d null) {\n+            currentCall.setDetailedMetricsName(\n+                exception.getClass().getSimpleName());\n           }\n-          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n-              call.getMethodName() :\n-              exception.getClass().getSimpleName();\n-          server\n-              .updateMetrics(detailedMetricsName, qTime, processingTime, false);\n         }\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(org.apache.hadoop.ipc.RPC.Server server,\n          String protocolName, Writable rpcRequest, long receivedTime)\n          throws IOException, RPC.VersionMismatch {\n\n        Invocation call \u003d (Invocation)rpcRequest;\n        if (server.verbose) log(\"Call: \" + call);\n\n        // Verify writable rpc version\n        if (call.getRpcVersion() !\u003d writableRpcVersion) {\n          // Client is using a different version of WritableRpc\n          throw new RpcServerException(\n              \"WritableRpc version mismatch, client side version\u003d\"\n                  + call.getRpcVersion() + \", server side version\u003d\"\n                  + writableRpcVersion);\n        }\n\n        long clientVersion \u003d call.getProtocolVersion();\n        final String protoName;\n        ProtoClassProtoImpl protocolImpl;\n        if (call.declaringClassProtocolName.equals(VersionedProtocol.class.getName())) {\n          // VersionProtocol methods are often used by client to figure out\n          // which version of protocol to use.\n          //\n          // Versioned protocol methods should go the protocolName protocol\n          // rather than the declaring class of the method since the\n          // the declaring class is VersionedProtocol which is not \n          // registered directly.\n          // Send the call to the highest  protocol version\n          VerProtocolImpl highest \u003d server.getHighestSupportedProtocol(\n              RPC.RpcKind.RPC_WRITABLE, protocolName);\n          if (highest \u003d\u003d null) {\n            throw new RpcServerException(\"Unknown protocol: \" + protocolName);\n          }\n          protocolImpl \u003d highest.protocolTarget;\n        } else {\n          protoName \u003d call.declaringClassProtocolName;\n\n          // Find the right impl for the protocol based on client version.\n          ProtoNameVer pv \u003d \n              new ProtoNameVer(call.declaringClassProtocolName, clientVersion);\n          protocolImpl \u003d \n              server.getProtocolImplMap(RPC.RpcKind.RPC_WRITABLE).get(pv);\n          if (protocolImpl \u003d\u003d null) { // no match for Protocol AND Version\n             VerProtocolImpl highest \u003d \n                 server.getHighestSupportedProtocol(RPC.RpcKind.RPC_WRITABLE, \n                     protoName);\n            if (highest \u003d\u003d null) {\n              throw new RpcServerException(\"Unknown protocol: \" + protoName);\n            } else { // protocol supported but not the version that client wants\n              throw new RPC.VersionMismatch(protoName, clientVersion,\n                highest.version);\n            }\n          }\n        }\n\n        // Invoke the protocol method\n        Exception exception \u003d null;\n        Call currentCall \u003d Server.getCurCall().get();\n        try {\n          Method method \u003d\n              protocolImpl.protocolClass.getMethod(call.getMethodName(),\n              call.getParameterClasses());\n          method.setAccessible(true);\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          currentCall.setDetailedMetricsName(call.getMethodName());\n          Object value \u003d \n              method.invoke(protocolImpl.protocolImpl, call.getParameters());\n          if (server.verbose) log(\"Return: \"+value);\n          return new ObjectWritable(method.getReturnType(), value);\n\n        } catch (InvocationTargetException e) {\n          Throwable target \u003d e.getTargetException();\n          if (target instanceof IOException) {\n            exception \u003d (IOException)target;\n            throw (IOException)target;\n          } else {\n            IOException ioe \u003d new IOException(target.toString());\n            ioe.setStackTrace(target.getStackTrace());\n            exception \u003d ioe;\n            throw ioe;\n          }\n        } catch (Throwable e) {\n          if (!(e instanceof IOException)) {\n            LOG.error(\"Unexpected throwable object \", e);\n          }\n          IOException ioe \u003d new IOException(e.toString());\n          ioe.setStackTrace(e.getStackTrace());\n          exception \u003d ioe;\n          throw ioe;\n        } finally {\n          if (exception !\u003d null) {\n            currentCall.setDetailedMetricsName(\n                exception.getClass().getSimpleName());\n          }\n        }\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/WritableRpcEngine.java",
      "extendedDetails": {}
    },
    "3d94da1e00fc6238fad458e415219f87920f1fc3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11552. Allow handoff on the server side for RPC requests. Contributed by Siddharth Seth\n",
      "commitDate": "23/11/16 4:01 PM",
      "commitName": "3d94da1e00fc6238fad458e415219f87920f1fc3",
      "commitAuthor": "Jian He",
      "commitDateOld": "09/10/16 2:07 AM",
      "commitNameOld": "ec0b70716c8e6509654a3975d3ca139a0144cc8e",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 45.62,
      "commitsBetweenForRepo": 388,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,106 @@\n       public Writable call(org.apache.hadoop.ipc.RPC.Server server,\n           String protocolName, Writable rpcRequest, long receivedTime)\n           throws IOException, RPC.VersionMismatch {\n \n         Invocation call \u003d (Invocation)rpcRequest;\n         if (server.verbose) log(\"Call: \" + call);\n \n         // Verify writable rpc version\n         if (call.getRpcVersion() !\u003d writableRpcVersion) {\n           // Client is using a different version of WritableRpc\n           throw new RpcServerException(\n               \"WritableRpc version mismatch, client side version\u003d\"\n                   + call.getRpcVersion() + \", server side version\u003d\"\n                   + writableRpcVersion);\n         }\n \n         long clientVersion \u003d call.getProtocolVersion();\n         final String protoName;\n         ProtoClassProtoImpl protocolImpl;\n         if (call.declaringClassProtocolName.equals(VersionedProtocol.class.getName())) {\n           // VersionProtocol methods are often used by client to figure out\n           // which version of protocol to use.\n           //\n           // Versioned protocol methods should go the protocolName protocol\n           // rather than the declaring class of the method since the\n           // the declaring class is VersionedProtocol which is not \n           // registered directly.\n           // Send the call to the highest  protocol version\n           VerProtocolImpl highest \u003d server.getHighestSupportedProtocol(\n               RPC.RpcKind.RPC_WRITABLE, protocolName);\n           if (highest \u003d\u003d null) {\n             throw new RpcServerException(\"Unknown protocol: \" + protocolName);\n           }\n           protocolImpl \u003d highest.protocolTarget;\n         } else {\n           protoName \u003d call.declaringClassProtocolName;\n \n           // Find the right impl for the protocol based on client version.\n           ProtoNameVer pv \u003d \n               new ProtoNameVer(call.declaringClassProtocolName, clientVersion);\n           protocolImpl \u003d \n               server.getProtocolImplMap(RPC.RpcKind.RPC_WRITABLE).get(pv);\n           if (protocolImpl \u003d\u003d null) { // no match for Protocol AND Version\n              VerProtocolImpl highest \u003d \n                  server.getHighestSupportedProtocol(RPC.RpcKind.RPC_WRITABLE, \n                      protoName);\n             if (highest \u003d\u003d null) {\n               throw new RpcServerException(\"Unknown protocol: \" + protoName);\n             } else { // protocol supported but not the version that client wants\n               throw new RPC.VersionMismatch(protoName, clientVersion,\n                 highest.version);\n             }\n           }\n         }\n \n         // Invoke the protocol method\n         long startTime \u003d Time.now();\n         int qTime \u003d (int) (startTime-receivedTime);\n         Exception exception \u003d null;\n         try {\n           Method method \u003d\n               protocolImpl.protocolClass.getMethod(call.getMethodName(),\n               call.getParameterClasses());\n           method.setAccessible(true);\n           server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n           Object value \u003d \n               method.invoke(protocolImpl.protocolImpl, call.getParameters());\n           if (server.verbose) log(\"Return: \"+value);\n           return new ObjectWritable(method.getReturnType(), value);\n \n         } catch (InvocationTargetException e) {\n           Throwable target \u003d e.getTargetException();\n           if (target instanceof IOException) {\n             exception \u003d (IOException)target;\n             throw (IOException)target;\n           } else {\n             IOException ioe \u003d new IOException(target.toString());\n             ioe.setStackTrace(target.getStackTrace());\n             exception \u003d ioe;\n             throw ioe;\n           }\n         } catch (Throwable e) {\n           if (!(e instanceof IOException)) {\n             LOG.error(\"Unexpected throwable object \", e);\n           }\n           IOException ioe \u003d new IOException(e.toString());\n           ioe.setStackTrace(e.getStackTrace());\n           exception \u003d ioe;\n           throw ioe;\n         } finally {\n           int processingTime \u003d (int) (Time.now() - startTime);\n           if (LOG.isDebugEnabled()) {\n             String msg \u003d \"Served: \" + call.getMethodName() +\n                 \" queueTime\u003d \" + qTime + \" procesingTime\u003d \" + processingTime;\n             if (exception !\u003d null) {\n               msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n             }\n             LOG.debug(msg);\n           }\n           String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n               call.getMethodName() :\n               exception.getClass().getSimpleName();\n-          server.updateMetrics(detailedMetricsName, qTime, processingTime);\n+          server\n+              .updateMetrics(detailedMetricsName, qTime, processingTime, false);\n         }\n       }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(org.apache.hadoop.ipc.RPC.Server server,\n          String protocolName, Writable rpcRequest, long receivedTime)\n          throws IOException, RPC.VersionMismatch {\n\n        Invocation call \u003d (Invocation)rpcRequest;\n        if (server.verbose) log(\"Call: \" + call);\n\n        // Verify writable rpc version\n        if (call.getRpcVersion() !\u003d writableRpcVersion) {\n          // Client is using a different version of WritableRpc\n          throw new RpcServerException(\n              \"WritableRpc version mismatch, client side version\u003d\"\n                  + call.getRpcVersion() + \", server side version\u003d\"\n                  + writableRpcVersion);\n        }\n\n        long clientVersion \u003d call.getProtocolVersion();\n        final String protoName;\n        ProtoClassProtoImpl protocolImpl;\n        if (call.declaringClassProtocolName.equals(VersionedProtocol.class.getName())) {\n          // VersionProtocol methods are often used by client to figure out\n          // which version of protocol to use.\n          //\n          // Versioned protocol methods should go the protocolName protocol\n          // rather than the declaring class of the method since the\n          // the declaring class is VersionedProtocol which is not \n          // registered directly.\n          // Send the call to the highest  protocol version\n          VerProtocolImpl highest \u003d server.getHighestSupportedProtocol(\n              RPC.RpcKind.RPC_WRITABLE, protocolName);\n          if (highest \u003d\u003d null) {\n            throw new RpcServerException(\"Unknown protocol: \" + protocolName);\n          }\n          protocolImpl \u003d highest.protocolTarget;\n        } else {\n          protoName \u003d call.declaringClassProtocolName;\n\n          // Find the right impl for the protocol based on client version.\n          ProtoNameVer pv \u003d \n              new ProtoNameVer(call.declaringClassProtocolName, clientVersion);\n          protocolImpl \u003d \n              server.getProtocolImplMap(RPC.RpcKind.RPC_WRITABLE).get(pv);\n          if (protocolImpl \u003d\u003d null) { // no match for Protocol AND Version\n             VerProtocolImpl highest \u003d \n                 server.getHighestSupportedProtocol(RPC.RpcKind.RPC_WRITABLE, \n                     protoName);\n            if (highest \u003d\u003d null) {\n              throw new RpcServerException(\"Unknown protocol: \" + protoName);\n            } else { // protocol supported but not the version that client wants\n              throw new RPC.VersionMismatch(protoName, clientVersion,\n                highest.version);\n            }\n          }\n        }\n\n        // Invoke the protocol method\n        long startTime \u003d Time.now();\n        int qTime \u003d (int) (startTime-receivedTime);\n        Exception exception \u003d null;\n        try {\n          Method method \u003d\n              protocolImpl.protocolClass.getMethod(call.getMethodName(),\n              call.getParameterClasses());\n          method.setAccessible(true);\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          Object value \u003d \n              method.invoke(protocolImpl.protocolImpl, call.getParameters());\n          if (server.verbose) log(\"Return: \"+value);\n          return new ObjectWritable(method.getReturnType(), value);\n\n        } catch (InvocationTargetException e) {\n          Throwable target \u003d e.getTargetException();\n          if (target instanceof IOException) {\n            exception \u003d (IOException)target;\n            throw (IOException)target;\n          } else {\n            IOException ioe \u003d new IOException(target.toString());\n            ioe.setStackTrace(target.getStackTrace());\n            exception \u003d ioe;\n            throw ioe;\n          }\n        } catch (Throwable e) {\n          if (!(e instanceof IOException)) {\n            LOG.error(\"Unexpected throwable object \", e);\n          }\n          IOException ioe \u003d new IOException(e.toString());\n          ioe.setStackTrace(e.getStackTrace());\n          exception \u003d ioe;\n          throw ioe;\n        } finally {\n          int processingTime \u003d (int) (Time.now() - startTime);\n          if (LOG.isDebugEnabled()) {\n            String msg \u003d \"Served: \" + call.getMethodName() +\n                \" queueTime\u003d \" + qTime + \" procesingTime\u003d \" + processingTime;\n            if (exception !\u003d null) {\n              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n            }\n            LOG.debug(msg);\n          }\n          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n              call.getMethodName() :\n              exception.getClass().getSimpleName();\n          server\n              .updateMetrics(detailedMetricsName, qTime, processingTime, false);\n        }\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/WritableRpcEngine.java",
      "extendedDetails": {}
    },
    "93d8a7f2a2d72a1719d02b1ed90678397900b6ed": {
      "type": "Yintroduced",
      "commitMessage": "Revert \"HADOOP-12579. Deprecate and remove WriteableRPCEngine. Contributed by Kai Zheng\"\n\nThis reverts commit a6c79f92d503c664f2d109355b719124f29a30e5.\n",
      "commitDate": "31/05/16 5:41 PM",
      "commitName": "93d8a7f2a2d72a1719d02b1ed90678397900b6ed",
      "commitAuthor": "Kai Zheng",
      "diff": "@@ -0,0 +1,105 @@\n+      public Writable call(org.apache.hadoop.ipc.RPC.Server server,\n+          String protocolName, Writable rpcRequest, long receivedTime)\n+          throws IOException, RPC.VersionMismatch {\n+\n+        Invocation call \u003d (Invocation)rpcRequest;\n+        if (server.verbose) log(\"Call: \" + call);\n+\n+        // Verify writable rpc version\n+        if (call.getRpcVersion() !\u003d writableRpcVersion) {\n+          // Client is using a different version of WritableRpc\n+          throw new RpcServerException(\n+              \"WritableRpc version mismatch, client side version\u003d\"\n+                  + call.getRpcVersion() + \", server side version\u003d\"\n+                  + writableRpcVersion);\n+        }\n+\n+        long clientVersion \u003d call.getProtocolVersion();\n+        final String protoName;\n+        ProtoClassProtoImpl protocolImpl;\n+        if (call.declaringClassProtocolName.equals(VersionedProtocol.class.getName())) {\n+          // VersionProtocol methods are often used by client to figure out\n+          // which version of protocol to use.\n+          //\n+          // Versioned protocol methods should go the protocolName protocol\n+          // rather than the declaring class of the method since the\n+          // the declaring class is VersionedProtocol which is not \n+          // registered directly.\n+          // Send the call to the highest  protocol version\n+          VerProtocolImpl highest \u003d server.getHighestSupportedProtocol(\n+              RPC.RpcKind.RPC_WRITABLE, protocolName);\n+          if (highest \u003d\u003d null) {\n+            throw new RpcServerException(\"Unknown protocol: \" + protocolName);\n+          }\n+          protocolImpl \u003d highest.protocolTarget;\n+        } else {\n+          protoName \u003d call.declaringClassProtocolName;\n+\n+          // Find the right impl for the protocol based on client version.\n+          ProtoNameVer pv \u003d \n+              new ProtoNameVer(call.declaringClassProtocolName, clientVersion);\n+          protocolImpl \u003d \n+              server.getProtocolImplMap(RPC.RpcKind.RPC_WRITABLE).get(pv);\n+          if (protocolImpl \u003d\u003d null) { // no match for Protocol AND Version\n+             VerProtocolImpl highest \u003d \n+                 server.getHighestSupportedProtocol(RPC.RpcKind.RPC_WRITABLE, \n+                     protoName);\n+            if (highest \u003d\u003d null) {\n+              throw new RpcServerException(\"Unknown protocol: \" + protoName);\n+            } else { // protocol supported but not the version that client wants\n+              throw new RPC.VersionMismatch(protoName, clientVersion,\n+                highest.version);\n+            }\n+          }\n+        }\n+\n+        // Invoke the protocol method\n+        long startTime \u003d Time.now();\n+        int qTime \u003d (int) (startTime-receivedTime);\n+        Exception exception \u003d null;\n+        try {\n+          Method method \u003d\n+              protocolImpl.protocolClass.getMethod(call.getMethodName(),\n+              call.getParameterClasses());\n+          method.setAccessible(true);\n+          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n+          Object value \u003d \n+              method.invoke(protocolImpl.protocolImpl, call.getParameters());\n+          if (server.verbose) log(\"Return: \"+value);\n+          return new ObjectWritable(method.getReturnType(), value);\n+\n+        } catch (InvocationTargetException e) {\n+          Throwable target \u003d e.getTargetException();\n+          if (target instanceof IOException) {\n+            exception \u003d (IOException)target;\n+            throw (IOException)target;\n+          } else {\n+            IOException ioe \u003d new IOException(target.toString());\n+            ioe.setStackTrace(target.getStackTrace());\n+            exception \u003d ioe;\n+            throw ioe;\n+          }\n+        } catch (Throwable e) {\n+          if (!(e instanceof IOException)) {\n+            LOG.error(\"Unexpected throwable object \", e);\n+          }\n+          IOException ioe \u003d new IOException(e.toString());\n+          ioe.setStackTrace(e.getStackTrace());\n+          exception \u003d ioe;\n+          throw ioe;\n+        } finally {\n+          int processingTime \u003d (int) (Time.now() - startTime);\n+          if (LOG.isDebugEnabled()) {\n+            String msg \u003d \"Served: \" + call.getMethodName() +\n+                \" queueTime\u003d \" + qTime + \" procesingTime\u003d \" + processingTime;\n+            if (exception !\u003d null) {\n+              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n+            }\n+            LOG.debug(msg);\n+          }\n+          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n+              call.getMethodName() :\n+              exception.getClass().getSimpleName();\n+          server.updateMetrics(detailedMetricsName, qTime, processingTime);\n+        }\n+      }\n\\ No newline at end of file\n",
      "actualSource": "      public Writable call(org.apache.hadoop.ipc.RPC.Server server,\n          String protocolName, Writable rpcRequest, long receivedTime)\n          throws IOException, RPC.VersionMismatch {\n\n        Invocation call \u003d (Invocation)rpcRequest;\n        if (server.verbose) log(\"Call: \" + call);\n\n        // Verify writable rpc version\n        if (call.getRpcVersion() !\u003d writableRpcVersion) {\n          // Client is using a different version of WritableRpc\n          throw new RpcServerException(\n              \"WritableRpc version mismatch, client side version\u003d\"\n                  + call.getRpcVersion() + \", server side version\u003d\"\n                  + writableRpcVersion);\n        }\n\n        long clientVersion \u003d call.getProtocolVersion();\n        final String protoName;\n        ProtoClassProtoImpl protocolImpl;\n        if (call.declaringClassProtocolName.equals(VersionedProtocol.class.getName())) {\n          // VersionProtocol methods are often used by client to figure out\n          // which version of protocol to use.\n          //\n          // Versioned protocol methods should go the protocolName protocol\n          // rather than the declaring class of the method since the\n          // the declaring class is VersionedProtocol which is not \n          // registered directly.\n          // Send the call to the highest  protocol version\n          VerProtocolImpl highest \u003d server.getHighestSupportedProtocol(\n              RPC.RpcKind.RPC_WRITABLE, protocolName);\n          if (highest \u003d\u003d null) {\n            throw new RpcServerException(\"Unknown protocol: \" + protocolName);\n          }\n          protocolImpl \u003d highest.protocolTarget;\n        } else {\n          protoName \u003d call.declaringClassProtocolName;\n\n          // Find the right impl for the protocol based on client version.\n          ProtoNameVer pv \u003d \n              new ProtoNameVer(call.declaringClassProtocolName, clientVersion);\n          protocolImpl \u003d \n              server.getProtocolImplMap(RPC.RpcKind.RPC_WRITABLE).get(pv);\n          if (protocolImpl \u003d\u003d null) { // no match for Protocol AND Version\n             VerProtocolImpl highest \u003d \n                 server.getHighestSupportedProtocol(RPC.RpcKind.RPC_WRITABLE, \n                     protoName);\n            if (highest \u003d\u003d null) {\n              throw new RpcServerException(\"Unknown protocol: \" + protoName);\n            } else { // protocol supported but not the version that client wants\n              throw new RPC.VersionMismatch(protoName, clientVersion,\n                highest.version);\n            }\n          }\n        }\n\n        // Invoke the protocol method\n        long startTime \u003d Time.now();\n        int qTime \u003d (int) (startTime-receivedTime);\n        Exception exception \u003d null;\n        try {\n          Method method \u003d\n              protocolImpl.protocolClass.getMethod(call.getMethodName(),\n              call.getParameterClasses());\n          method.setAccessible(true);\n          server.rpcDetailedMetrics.init(protocolImpl.protocolClass);\n          Object value \u003d \n              method.invoke(protocolImpl.protocolImpl, call.getParameters());\n          if (server.verbose) log(\"Return: \"+value);\n          return new ObjectWritable(method.getReturnType(), value);\n\n        } catch (InvocationTargetException e) {\n          Throwable target \u003d e.getTargetException();\n          if (target instanceof IOException) {\n            exception \u003d (IOException)target;\n            throw (IOException)target;\n          } else {\n            IOException ioe \u003d new IOException(target.toString());\n            ioe.setStackTrace(target.getStackTrace());\n            exception \u003d ioe;\n            throw ioe;\n          }\n        } catch (Throwable e) {\n          if (!(e instanceof IOException)) {\n            LOG.error(\"Unexpected throwable object \", e);\n          }\n          IOException ioe \u003d new IOException(e.toString());\n          ioe.setStackTrace(e.getStackTrace());\n          exception \u003d ioe;\n          throw ioe;\n        } finally {\n          int processingTime \u003d (int) (Time.now() - startTime);\n          if (LOG.isDebugEnabled()) {\n            String msg \u003d \"Served: \" + call.getMethodName() +\n                \" queueTime\u003d \" + qTime + \" procesingTime\u003d \" + processingTime;\n            if (exception !\u003d null) {\n              msg +\u003d \" exception\u003d \" + exception.getClass().getSimpleName();\n            }\n            LOG.debug(msg);\n          }\n          String detailedMetricsName \u003d (exception \u003d\u003d null) ?\n              call.getMethodName() :\n              exception.getClass().getSimpleName();\n          server.updateMetrics(detailedMetricsName, qTime, processingTime);\n        }\n      }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/WritableRpcEngine.java"
    }
  }
}