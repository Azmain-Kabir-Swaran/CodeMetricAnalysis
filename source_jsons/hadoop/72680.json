{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "KMSClientProvider.java",
  "functionName": "createProvider",
  "functionId": "createProvider___providerUri-URI__conf-Configuration",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
  "functionStartLine": 279,
  "functionEndLine": 308,
  "numCommitsSeen": 101,
  "timeTaken": 4254,
  "changeHistory": [
    "5ec86b445cc492f52c33639efb6a09a0d2f27475",
    "a3a1552c33d5650fbd0a702369fccd21b8c9d3e2",
    "583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81",
    "25f31d9fc47d21ac2f3afd7042e2ced1b849da39",
    "fa6cc43edd3f6e886a40b90b062c9f16189c50d1",
    "0a6d5c0cf1d963da9131aa12326fc576f0e92d2c",
    "71385f9b70e22618db3f3d2b2c6dca3b1e82c317",
    "17d4fbbf0af9b93de9502afb274e91533140d1c6"
  ],
  "changeHistoryShort": {
    "5ec86b445cc492f52c33639efb6a09a0d2f27475": "Ybodychange",
    "a3a1552c33d5650fbd0a702369fccd21b8c9d3e2": "Ybodychange",
    "583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81": "Ybodychange",
    "25f31d9fc47d21ac2f3afd7042e2ced1b849da39": "Ybodychange",
    "fa6cc43edd3f6e886a40b90b062c9f16189c50d1": "Ybodychange",
    "0a6d5c0cf1d963da9131aa12326fc576f0e92d2c": "Ybodychange",
    "71385f9b70e22618db3f3d2b2c6dca3b1e82c317": "Ymultichange(Yparameterchange,Ybodychange)",
    "17d4fbbf0af9b93de9502afb274e91533140d1c6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5ec86b445cc492f52c33639efb6a09a0d2f27475": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14445. Use DelegationTokenIssuer to create KMS delegation tokens that can authenticate to all KMS instances.\nContributed by Daryn Sharp, Xiao Chen, Rushabh S Shah.\n",
      "commitDate": "12/10/18 9:35 AM",
      "commitName": "5ec86b445cc492f52c33639efb6a09a0d2f27475",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "10/10/18 9:51 PM",
      "commitNameOld": "7b57f2f71fbaa5af4897309597cca70a95b04edd",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 1.49,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,30 @@\n     public KeyProvider createProvider(URI providerUri, Configuration conf)\n         throws IOException {\n       if (SCHEME_NAME.equals(providerUri.getScheme())) {\n         URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n         String authority \u003d origUrl.getAuthority();\n         // check for \u0027;\u0027 which delimits the backup hosts\n         if (Strings.isNullOrEmpty(authority)) {\n           throw new IOException(\n               \"No valid authority in kms uri [\" + origUrl + \"]\");\n         }\n         // Check if port is present in authority\n         // In the current scheme, all hosts have to run on the same port\n         int port \u003d -1;\n         String hostsPart \u003d authority;\n         if (authority.contains(\":\")) {\n           String[] t \u003d authority.split(\":\");\n           try {\n             port \u003d Integer.parseInt(t[1]);\n           } catch (Exception e) {\n             throw new IOException(\n                 \"Could not parse port in kms uri [\" + origUrl + \"]\");\n           }\n           hostsPart \u003d t[0];\n         }\n-        return createProvider(conf, origUrl, port, hostsPart);\n+        KMSClientProvider[] providers \u003d\n+            createProviders(conf, origUrl, port, hostsPart);\n+        return new LoadBalancingKMSClientProvider(providerUri, providers, conf);\n       }\n       return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyProvider createProvider(URI providerUri, Configuration conf)\n        throws IOException {\n      if (SCHEME_NAME.equals(providerUri.getScheme())) {\n        URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n        String authority \u003d origUrl.getAuthority();\n        // check for \u0027;\u0027 which delimits the backup hosts\n        if (Strings.isNullOrEmpty(authority)) {\n          throw new IOException(\n              \"No valid authority in kms uri [\" + origUrl + \"]\");\n        }\n        // Check if port is present in authority\n        // In the current scheme, all hosts have to run on the same port\n        int port \u003d -1;\n        String hostsPart \u003d authority;\n        if (authority.contains(\":\")) {\n          String[] t \u003d authority.split(\":\");\n          try {\n            port \u003d Integer.parseInt(t[1]);\n          } catch (Exception e) {\n            throw new IOException(\n                \"Could not parse port in kms uri [\" + origUrl + \"]\");\n          }\n          hostsPart \u003d t[0];\n        }\n        KMSClientProvider[] providers \u003d\n            createProviders(conf, origUrl, port, hostsPart);\n        return new LoadBalancingKMSClientProvider(providerUri, providers, conf);\n      }\n      return null;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "a3a1552c33d5650fbd0a702369fccd21b8c9d3e2": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-14445. Delegation tokens are not shared between KMS instances. Contributed by Xiao Chen and Rushabh S Shah.\"\n\nThis reverts commit 583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81.\n\n Conflicts:\n\thadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSTokenRenewer.java\n\thadoop-common-project/hadoop-kms/src/test/java/org/apache/hadoop/crypto/key/kms/server/TestKMS.java\n",
      "commitDate": "07/05/18 1:32 PM",
      "commitName": "a3a1552c33d5650fbd0a702369fccd21b8c9d3e2",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "04/05/18 1:36 PM",
      "commitNameOld": "4cdbdce752e192b45c2b9756c2d4bd24ceffdabd",
      "commitAuthorOld": "Rushabh Shah",
      "daysBetweenCommits": 3.0,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n     public KeyProvider createProvider(URI providerUri, Configuration conf)\n         throws IOException {\n       if (SCHEME_NAME.equals(providerUri.getScheme())) {\n         URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n         String authority \u003d origUrl.getAuthority();\n         // check for \u0027;\u0027 which delimits the backup hosts\n         if (Strings.isNullOrEmpty(authority)) {\n           throw new IOException(\n               \"No valid authority in kms uri [\" + origUrl + \"]\");\n         }\n         // Check if port is present in authority\n         // In the current scheme, all hosts have to run on the same port\n         int port \u003d -1;\n         String hostsPart \u003d authority;\n         if (authority.contains(\":\")) {\n           String[] t \u003d authority.split(\":\");\n           try {\n             port \u003d Integer.parseInt(t[1]);\n           } catch (Exception e) {\n             throw new IOException(\n                 \"Could not parse port in kms uri [\" + origUrl + \"]\");\n           }\n           hostsPart \u003d t[0];\n         }\n-        return createProvider(conf, origUrl, port, hostsPart, providerUri);\n+        return createProvider(conf, origUrl, port, hostsPart);\n       }\n       return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyProvider createProvider(URI providerUri, Configuration conf)\n        throws IOException {\n      if (SCHEME_NAME.equals(providerUri.getScheme())) {\n        URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n        String authority \u003d origUrl.getAuthority();\n        // check for \u0027;\u0027 which delimits the backup hosts\n        if (Strings.isNullOrEmpty(authority)) {\n          throw new IOException(\n              \"No valid authority in kms uri [\" + origUrl + \"]\");\n        }\n        // Check if port is present in authority\n        // In the current scheme, all hosts have to run on the same port\n        int port \u003d -1;\n        String hostsPart \u003d authority;\n        if (authority.contains(\":\")) {\n          String[] t \u003d authority.split(\":\");\n          try {\n            port \u003d Integer.parseInt(t[1]);\n          } catch (Exception e) {\n            throw new IOException(\n                \"Could not parse port in kms uri [\" + origUrl + \"]\");\n          }\n          hostsPart \u003d t[0];\n        }\n        return createProvider(conf, origUrl, port, hostsPart);\n      }\n      return null;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14445. Delegation tokens are not shared between KMS instances. Contributed by Xiao Chen and Rushabh S Shah.\n",
      "commitDate": "10/04/18 3:38 PM",
      "commitName": "583fa6ed48ad3df40bcaa9c591d5ccd07ce3ea81",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "03/11/17 4:10 PM",
      "commitNameOld": "59d78a5088700350a5122c3a3ba5e76cd26d6a80",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 157.98,
      "commitsBetweenForRepo": 1162,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n     public KeyProvider createProvider(URI providerUri, Configuration conf)\n         throws IOException {\n       if (SCHEME_NAME.equals(providerUri.getScheme())) {\n         URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n         String authority \u003d origUrl.getAuthority();\n         // check for \u0027;\u0027 which delimits the backup hosts\n         if (Strings.isNullOrEmpty(authority)) {\n           throw new IOException(\n               \"No valid authority in kms uri [\" + origUrl + \"]\");\n         }\n         // Check if port is present in authority\n         // In the current scheme, all hosts have to run on the same port\n         int port \u003d -1;\n         String hostsPart \u003d authority;\n         if (authority.contains(\":\")) {\n           String[] t \u003d authority.split(\":\");\n           try {\n             port \u003d Integer.parseInt(t[1]);\n           } catch (Exception e) {\n             throw new IOException(\n                 \"Could not parse port in kms uri [\" + origUrl + \"]\");\n           }\n           hostsPart \u003d t[0];\n         }\n-        return createProvider(conf, origUrl, port, hostsPart);\n+        return createProvider(conf, origUrl, port, hostsPart, providerUri);\n       }\n       return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyProvider createProvider(URI providerUri, Configuration conf)\n        throws IOException {\n      if (SCHEME_NAME.equals(providerUri.getScheme())) {\n        URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n        String authority \u003d origUrl.getAuthority();\n        // check for \u0027;\u0027 which delimits the backup hosts\n        if (Strings.isNullOrEmpty(authority)) {\n          throw new IOException(\n              \"No valid authority in kms uri [\" + origUrl + \"]\");\n        }\n        // Check if port is present in authority\n        // In the current scheme, all hosts have to run on the same port\n        int port \u003d -1;\n        String hostsPart \u003d authority;\n        if (authority.contains(\":\")) {\n          String[] t \u003d authority.split(\":\");\n          try {\n            port \u003d Integer.parseInt(t[1]);\n          } catch (Exception e) {\n            throw new IOException(\n                \"Could not parse port in kms uri [\" + origUrl + \"]\");\n          }\n          hostsPart \u003d t[0];\n        }\n        return createProvider(conf, origUrl, port, hostsPart, providerUri);\n      }\n      return null;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "25f31d9fc47d21ac2f3afd7042e2ced1b849da39": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14521. KMS client needs retry logic. Contributed by Rushabh S Shah.\n",
      "commitDate": "05/10/17 7:46 PM",
      "commitName": "25f31d9fc47d21ac2f3afd7042e2ced1b849da39",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "22/09/17 3:45 PM",
      "commitNameOld": "e1b32e0959dea5f5a40055157476f9320519a618",
      "commitAuthorOld": "Anu Engineer",
      "daysBetweenCommits": 13.17,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n     public KeyProvider createProvider(URI providerUri, Configuration conf)\n         throws IOException {\n       if (SCHEME_NAME.equals(providerUri.getScheme())) {\n         URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n         String authority \u003d origUrl.getAuthority();\n         // check for \u0027;\u0027 which delimits the backup hosts\n         if (Strings.isNullOrEmpty(authority)) {\n           throw new IOException(\n               \"No valid authority in kms uri [\" + origUrl + \"]\");\n         }\n         // Check if port is present in authority\n         // In the current scheme, all hosts have to run on the same port\n         int port \u003d -1;\n         String hostsPart \u003d authority;\n         if (authority.contains(\":\")) {\n           String[] t \u003d authority.split(\":\");\n           try {\n             port \u003d Integer.parseInt(t[1]);\n           } catch (Exception e) {\n             throw new IOException(\n                 \"Could not parse port in kms uri [\" + origUrl + \"]\");\n           }\n           hostsPart \u003d t[0];\n         }\n-        return createProvider(providerUri, conf, origUrl, port, hostsPart);\n+        return createProvider(conf, origUrl, port, hostsPart);\n       }\n       return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyProvider createProvider(URI providerUri, Configuration conf)\n        throws IOException {\n      if (SCHEME_NAME.equals(providerUri.getScheme())) {\n        URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n        String authority \u003d origUrl.getAuthority();\n        // check for \u0027;\u0027 which delimits the backup hosts\n        if (Strings.isNullOrEmpty(authority)) {\n          throw new IOException(\n              \"No valid authority in kms uri [\" + origUrl + \"]\");\n        }\n        // Check if port is present in authority\n        // In the current scheme, all hosts have to run on the same port\n        int port \u003d -1;\n        String hostsPart \u003d authority;\n        if (authority.contains(\":\")) {\n          String[] t \u003d authority.split(\":\");\n          try {\n            port \u003d Integer.parseInt(t[1]);\n          } catch (Exception e) {\n            throw new IOException(\n                \"Could not parse port in kms uri [\" + origUrl + \"]\");\n          }\n          hostsPart \u003d t[0];\n        }\n        return createProvider(conf, origUrl, port, hostsPart);\n      }\n      return null;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "fa6cc43edd3f6e886a40b90b062c9f16189c50d1": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-14521. KMS client needs retry logic. Contributed by Rushabh S Shah.\"\n\nThis reverts commit 0a6d5c0cf1d963da9131aa12326fc576f0e92d2c.\n",
      "commitDate": "12/09/17 7:53 PM",
      "commitName": "fa6cc43edd3f6e886a40b90b062c9f16189c50d1",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "22/08/17 2:50 PM",
      "commitNameOld": "c3793102121767c46091805eae65ef3919a5f368",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 21.21,
      "commitsBetweenForRepo": 243,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n     public KeyProvider createProvider(URI providerUri, Configuration conf)\n         throws IOException {\n       if (SCHEME_NAME.equals(providerUri.getScheme())) {\n         URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n         String authority \u003d origUrl.getAuthority();\n         // check for \u0027;\u0027 which delimits the backup hosts\n         if (Strings.isNullOrEmpty(authority)) {\n           throw new IOException(\n               \"No valid authority in kms uri [\" + origUrl + \"]\");\n         }\n         // Check if port is present in authority\n         // In the current scheme, all hosts have to run on the same port\n         int port \u003d -1;\n         String hostsPart \u003d authority;\n         if (authority.contains(\":\")) {\n           String[] t \u003d authority.split(\":\");\n           try {\n             port \u003d Integer.parseInt(t[1]);\n           } catch (Exception e) {\n             throw new IOException(\n                 \"Could not parse port in kms uri [\" + origUrl + \"]\");\n           }\n           hostsPart \u003d t[0];\n         }\n-        return createProvider(conf, origUrl, port, hostsPart);\n+        return createProvider(providerUri, conf, origUrl, port, hostsPart);\n       }\n       return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyProvider createProvider(URI providerUri, Configuration conf)\n        throws IOException {\n      if (SCHEME_NAME.equals(providerUri.getScheme())) {\n        URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n        String authority \u003d origUrl.getAuthority();\n        // check for \u0027;\u0027 which delimits the backup hosts\n        if (Strings.isNullOrEmpty(authority)) {\n          throw new IOException(\n              \"No valid authority in kms uri [\" + origUrl + \"]\");\n        }\n        // Check if port is present in authority\n        // In the current scheme, all hosts have to run on the same port\n        int port \u003d -1;\n        String hostsPart \u003d authority;\n        if (authority.contains(\":\")) {\n          String[] t \u003d authority.split(\":\");\n          try {\n            port \u003d Integer.parseInt(t[1]);\n          } catch (Exception e) {\n            throw new IOException(\n                \"Could not parse port in kms uri [\" + origUrl + \"]\");\n          }\n          hostsPart \u003d t[0];\n        }\n        return createProvider(providerUri, conf, origUrl, port, hostsPart);\n      }\n      return null;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "0a6d5c0cf1d963da9131aa12326fc576f0e92d2c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14521. KMS client needs retry logic. Contributed by Rushabh S Shah.\n",
      "commitDate": "14/07/17 10:22 PM",
      "commitName": "0a6d5c0cf1d963da9131aa12326fc576f0e92d2c",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "08/06/17 9:34 PM",
      "commitNameOld": "0202480742b8539aa7aa1e94dc9cab75d863cc4e",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 36.03,
      "commitsBetweenForRepo": 169,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n     public KeyProvider createProvider(URI providerUri, Configuration conf)\n         throws IOException {\n       if (SCHEME_NAME.equals(providerUri.getScheme())) {\n         URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n         String authority \u003d origUrl.getAuthority();\n         // check for \u0027;\u0027 which delimits the backup hosts\n         if (Strings.isNullOrEmpty(authority)) {\n           throw new IOException(\n               \"No valid authority in kms uri [\" + origUrl + \"]\");\n         }\n         // Check if port is present in authority\n         // In the current scheme, all hosts have to run on the same port\n         int port \u003d -1;\n         String hostsPart \u003d authority;\n         if (authority.contains(\":\")) {\n           String[] t \u003d authority.split(\":\");\n           try {\n             port \u003d Integer.parseInt(t[1]);\n           } catch (Exception e) {\n             throw new IOException(\n                 \"Could not parse port in kms uri [\" + origUrl + \"]\");\n           }\n           hostsPart \u003d t[0];\n         }\n-        return createProvider(providerUri, conf, origUrl, port, hostsPart);\n+        return createProvider(conf, origUrl, port, hostsPart);\n       }\n       return null;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyProvider createProvider(URI providerUri, Configuration conf)\n        throws IOException {\n      if (SCHEME_NAME.equals(providerUri.getScheme())) {\n        URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n        String authority \u003d origUrl.getAuthority();\n        // check for \u0027;\u0027 which delimits the backup hosts\n        if (Strings.isNullOrEmpty(authority)) {\n          throw new IOException(\n              \"No valid authority in kms uri [\" + origUrl + \"]\");\n        }\n        // Check if port is present in authority\n        // In the current scheme, all hosts have to run on the same port\n        int port \u003d -1;\n        String hostsPart \u003d authority;\n        if (authority.contains(\":\")) {\n          String[] t \u003d authority.split(\":\");\n          try {\n            port \u003d Integer.parseInt(t[1]);\n          } catch (Exception e) {\n            throw new IOException(\n                \"Could not parse port in kms uri [\" + origUrl + \"]\");\n          }\n          hostsPart \u003d t[0];\n        }\n        return createProvider(conf, origUrl, port, hostsPart);\n      }\n      return null;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
      "extendedDetails": {}
    },
    "71385f9b70e22618db3f3d2b2c6dca3b1e82c317": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-11620. Add support for load balancing across a group of KMS for HA. Contributed by Arun Suresh.\n",
      "commitDate": "25/02/15 9:16 PM",
      "commitName": "71385f9b70e22618db3f3d2b2c6dca3b1e82c317",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-11620. Add support for load balancing across a group of KMS for HA. Contributed by Arun Suresh.\n",
          "commitDate": "25/02/15 9:16 PM",
          "commitName": "71385f9b70e22618db3f3d2b2c6dca3b1e82c317",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "23/01/15 12:11 PM",
          "commitNameOld": "4b00935643f6c3656ccbd7eeb54884738bc12c2e",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 33.38,
          "commitsBetweenForRepo": 334,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,7 +1,28 @@\n-    public KeyProvider createProvider(URI providerName, Configuration conf)\n+    public KeyProvider createProvider(URI providerUri, Configuration conf)\n         throws IOException {\n-      if (SCHEME_NAME.equals(providerName.getScheme())) {\n-        return new KMSClientProvider(providerName, conf);\n+      if (SCHEME_NAME.equals(providerUri.getScheme())) {\n+        URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n+        String authority \u003d origUrl.getAuthority();\n+        // check for \u0027;\u0027 which delimits the backup hosts\n+        if (Strings.isNullOrEmpty(authority)) {\n+          throw new IOException(\n+              \"No valid authority in kms uri [\" + origUrl + \"]\");\n+        }\n+        // Check if port is present in authority\n+        // In the current scheme, all hosts have to run on the same port\n+        int port \u003d -1;\n+        String hostsPart \u003d authority;\n+        if (authority.contains(\":\")) {\n+          String[] t \u003d authority.split(\":\");\n+          try {\n+            port \u003d Integer.parseInt(t[1]);\n+          } catch (Exception e) {\n+            throw new IOException(\n+                \"Could not parse port in kms uri [\" + origUrl + \"]\");\n+          }\n+          hostsPart \u003d t[0];\n+        }\n+        return createProvider(providerUri, conf, origUrl, port, hostsPart);\n       }\n       return null;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public KeyProvider createProvider(URI providerUri, Configuration conf)\n        throws IOException {\n      if (SCHEME_NAME.equals(providerUri.getScheme())) {\n        URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n        String authority \u003d origUrl.getAuthority();\n        // check for \u0027;\u0027 which delimits the backup hosts\n        if (Strings.isNullOrEmpty(authority)) {\n          throw new IOException(\n              \"No valid authority in kms uri [\" + origUrl + \"]\");\n        }\n        // Check if port is present in authority\n        // In the current scheme, all hosts have to run on the same port\n        int port \u003d -1;\n        String hostsPart \u003d authority;\n        if (authority.contains(\":\")) {\n          String[] t \u003d authority.split(\":\");\n          try {\n            port \u003d Integer.parseInt(t[1]);\n          } catch (Exception e) {\n            throw new IOException(\n                \"Could not parse port in kms uri [\" + origUrl + \"]\");\n          }\n          hostsPart \u003d t[0];\n        }\n        return createProvider(providerUri, conf, origUrl, port, hostsPart);\n      }\n      return null;\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
          "extendedDetails": {
            "oldValue": "[providerName-URI, conf-Configuration]",
            "newValue": "[providerUri-URI, conf-Configuration]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-11620. Add support for load balancing across a group of KMS for HA. Contributed by Arun Suresh.\n",
          "commitDate": "25/02/15 9:16 PM",
          "commitName": "71385f9b70e22618db3f3d2b2c6dca3b1e82c317",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "23/01/15 12:11 PM",
          "commitNameOld": "4b00935643f6c3656ccbd7eeb54884738bc12c2e",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 33.38,
          "commitsBetweenForRepo": 334,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,7 +1,28 @@\n-    public KeyProvider createProvider(URI providerName, Configuration conf)\n+    public KeyProvider createProvider(URI providerUri, Configuration conf)\n         throws IOException {\n-      if (SCHEME_NAME.equals(providerName.getScheme())) {\n-        return new KMSClientProvider(providerName, conf);\n+      if (SCHEME_NAME.equals(providerUri.getScheme())) {\n+        URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n+        String authority \u003d origUrl.getAuthority();\n+        // check for \u0027;\u0027 which delimits the backup hosts\n+        if (Strings.isNullOrEmpty(authority)) {\n+          throw new IOException(\n+              \"No valid authority in kms uri [\" + origUrl + \"]\");\n+        }\n+        // Check if port is present in authority\n+        // In the current scheme, all hosts have to run on the same port\n+        int port \u003d -1;\n+        String hostsPart \u003d authority;\n+        if (authority.contains(\":\")) {\n+          String[] t \u003d authority.split(\":\");\n+          try {\n+            port \u003d Integer.parseInt(t[1]);\n+          } catch (Exception e) {\n+            throw new IOException(\n+                \"Could not parse port in kms uri [\" + origUrl + \"]\");\n+          }\n+          hostsPart \u003d t[0];\n+        }\n+        return createProvider(providerUri, conf, origUrl, port, hostsPart);\n       }\n       return null;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public KeyProvider createProvider(URI providerUri, Configuration conf)\n        throws IOException {\n      if (SCHEME_NAME.equals(providerUri.getScheme())) {\n        URL origUrl \u003d new URL(extractKMSPath(providerUri).toString());\n        String authority \u003d origUrl.getAuthority();\n        // check for \u0027;\u0027 which delimits the backup hosts\n        if (Strings.isNullOrEmpty(authority)) {\n          throw new IOException(\n              \"No valid authority in kms uri [\" + origUrl + \"]\");\n        }\n        // Check if port is present in authority\n        // In the current scheme, all hosts have to run on the same port\n        int port \u003d -1;\n        String hostsPart \u003d authority;\n        if (authority.contains(\":\")) {\n          String[] t \u003d authority.split(\":\");\n          try {\n            port \u003d Integer.parseInt(t[1]);\n          } catch (Exception e) {\n            throw new IOException(\n                \"Could not parse port in kms uri [\" + origUrl + \"]\");\n          }\n          hostsPart \u003d t[0];\n        }\n        return createProvider(providerUri, conf, origUrl, port, hostsPart);\n      }\n      return null;\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java",
          "extendedDetails": {}
        }
      ]
    },
    "17d4fbbf0af9b93de9502afb274e91533140d1c6": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10433. Key Management Server based on KeyProvider API. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1592637 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/05/14 2:43 PM",
      "commitName": "17d4fbbf0af9b93de9502afb274e91533140d1c6",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,7 @@\n+    public KeyProvider createProvider(URI providerName, Configuration conf)\n+        throws IOException {\n+      if (SCHEME_NAME.equals(providerName.getScheme())) {\n+        return new KMSClientProvider(providerName, conf);\n+      }\n+      return null;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyProvider createProvider(URI providerName, Configuration conf)\n        throws IOException {\n      if (SCHEME_NAME.equals(providerName.getScheme())) {\n        return new KMSClientProvider(providerName, conf);\n      }\n      return null;\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/KMSClientProvider.java"
    }
  }
}