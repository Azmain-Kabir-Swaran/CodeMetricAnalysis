{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "INodesInPath.java",
  "functionName": "resolve",
  "functionId": "resolve___startingDir-INodeDirectory(modifiers-final)__components-byte[][](modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
  "functionStartLine": 133,
  "functionEndLine": 136,
  "numCommitsSeen": 66,
  "timeTaken": 5713,
  "changeHistory": [
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
    "ec252ce0fc0998ce13f31af3440c08a236328e5a",
    "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
    "22fc46d7659972ff016ccf1c6f781f0c160be26f",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
    "5776a41da08af653206bb94d7c76c9c4dcce059a",
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
    "76a621ffd2d66bf012a554f4400091a92a5b473e",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795",
    "44a6560b5da3f79d2299579a36e7a2a60a91f823",
    "496b80b28c35dbd52d3d919d16f4c75983f81a79",
    "3a3e0f573129c8308332d4b301a9319ee579d85a",
    "9280468b1acfa346250d0212b5cb7486dc83705c"
  ],
  "changeHistoryShort": {
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "ec252ce0fc0998ce13f31af3440c08a236328e5a": "Ybodychange",
    "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88": "Ybodychange",
    "22fc46d7659972ff016ccf1c6f781f0c160be26f": "Ybodychange",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": "Ymultichange(Yparameterchange,Ybodychange)",
    "5776a41da08af653206bb94d7c76c9c4dcce059a": "Ybodychange",
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2": "Ybodychange",
    "76a621ffd2d66bf012a554f4400091a92a5b473e": "Ybodychange",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": "Ybodychange",
    "44a6560b5da3f79d2299579a36e7a2a60a91f823": "Ybodychange",
    "496b80b28c35dbd52d3d919d16f4c75983f81a79": "Ybodychange",
    "3a3e0f573129c8308332d4b301a9319ee579d85a": "Ybodychange",
    "9280468b1acfa346250d0212b5cb7486dc83705c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
      "commitDate": "24/10/16 3:14 PM",
      "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
          "commitDate": "24/10/16 3:14 PM",
          "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/10/16 7:13 AM",
          "commitNameOld": "90020624b05230ad4a7fbd666d0177ecb107a4d6",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 21.33,
          "commitsBetweenForRepo": 153,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,4 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n-      final byte[][] components, final boolean resolveLink)\n-      throws UnresolvedLinkException {\n-    return resolve(startingDir, components, false, resolveLink);\n+      final byte[][] components) {\n+    return resolve(startingDir, components, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components) {\n    return resolve(startingDir, components, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
          "extendedDetails": {
            "oldValue": "[startingDir-INodeDirectory(modifiers-final), components-byte[][](modifiers-final), resolveLink-boolean(modifiers-final)]",
            "newValue": "[startingDir-INodeDirectory(modifiers-final), components-byte[][](modifiers-final)]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
          "commitDate": "24/10/16 3:14 PM",
          "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/10/16 7:13 AM",
          "commitNameOld": "90020624b05230ad4a7fbd666d0177ecb107a4d6",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 21.33,
          "commitsBetweenForRepo": 153,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,4 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n-      final byte[][] components, final boolean resolveLink)\n-      throws UnresolvedLinkException {\n-    return resolve(startingDir, components, false, resolveLink);\n+      final byte[][] components) {\n+    return resolve(startingDir, components, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components) {\n    return resolve(startingDir, components, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
          "extendedDetails": {
            "oldValue": "[UnresolvedLinkException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
          "commitDate": "24/10/16 3:14 PM",
          "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/10/16 7:13 AM",
          "commitNameOld": "90020624b05230ad4a7fbd666d0177ecb107a4d6",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 21.33,
          "commitsBetweenForRepo": 153,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,5 +1,4 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n-      final byte[][] components, final boolean resolveLink)\n-      throws UnresolvedLinkException {\n-    return resolve(startingDir, components, false, resolveLink);\n+      final byte[][] components) {\n+    return resolve(startingDir, components, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components) {\n    return resolve(startingDir, components, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
          "extendedDetails": {}
        }
      ]
    },
    "ec252ce0fc0998ce13f31af3440c08a236328e5a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10762. Pass IIP for file status related methods\n",
      "commitDate": "24/08/16 6:46 AM",
      "commitName": "ec252ce0fc0998ce13f31af3440c08a236328e5a",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "22/08/16 2:57 PM",
      "commitNameOld": "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,5 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n       final byte[][] components, final boolean resolveLink)\n       throws UnresolvedLinkException {\n-    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n-\n-    INode curNode \u003d startingDir;\n-    int count \u003d 0;\n-    int inodeNum \u003d 0;\n-    INode[] inodes \u003d new INode[components.length];\n-    boolean isSnapshot \u003d false;\n-    int snapshotId \u003d CURRENT_STATE_ID;\n-\n-    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n-      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n-      inodes[inodeNum++] \u003d curNode;\n-      final boolean isRef \u003d curNode.isReference();\n-      final boolean isDir \u003d curNode.isDirectory();\n-      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n-      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n-        //if the path is a non-snapshot path, update the latest snapshot.\n-        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n-            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n-            snapshotId)) {\n-          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n-        }\n-      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n-        // If the curNode is a reference node, need to check its dstSnapshot:\n-        // 1. if the existing snapshot is no later than the dstSnapshot (which\n-        // is the latest snapshot in dst before the rename), the changes \n-        // should be recorded in previous snapshots (belonging to src).\n-        // 2. however, if the ref node is already the last component, we still \n-        // need to know the latest snapshot among the ref node\u0027s ancestors, \n-        // in case of processing a deletion operation. Thus we do not overwrite\n-        // the latest snapshot if lastComp is true. In case of the operation is\n-        // a modification operation, we do a similar check in corresponding \n-        // recordModification method.\n-        if (!isSnapshot) {\n-          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n-          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n-              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n-               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n-            int lastSnapshot \u003d CURRENT_STATE_ID;\n-            DirectoryWithSnapshotFeature sf;\n-            if (curNode.isDirectory() \u0026\u0026 \n-                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n-              lastSnapshot \u003d sf.getLastSnapshotId();\n-            }\n-            snapshotId \u003d lastSnapshot;\n-          }\n-        }\n-      }\n-      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n-        final String path \u003d constructPath(components, 0, components.length);\n-        final String preceding \u003d constructPath(components, 0, count);\n-        final String remainder \u003d\n-          constructPath(components, count + 1, components.length);\n-        final String link \u003d DFSUtil.bytes2String(components[count]);\n-        final String target \u003d curNode.asSymlink().getSymlinkString();\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"UnresolvedPathException \" +\n-            \" path: \" + path + \" preceding: \" + preceding +\n-            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n-            \" remainder: \" + remainder);\n-        }\n-        throw new UnresolvedPathException(path, preceding, remainder, target);\n-      }\n-      if (lastComp || !isDir) {\n-        break;\n-      }\n-      final byte[] childName \u003d components[count + 1];\n-      \n-      // check if the next byte[] in components is for \".snapshot\"\n-      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n-        // skip the \".snapshot\" in components\n-        count++;\n-        isSnapshot \u003d true;\n-        // check if \".snapshot\" is the last element of components\n-        if (count \u003d\u003d components.length - 1) {\n-          break;\n-        }\n-        // Resolve snapshot root\n-        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n-        if (s \u003d\u003d null) {\n-          curNode \u003d null; // snapshot not found\n-        } else {\n-          curNode \u003d s.getRoot();\n-          snapshotId \u003d s.getId();\n-        }\n-      } else {\n-        // normal case, and also for resolving file/dir under snapshot root\n-        curNode \u003d dir.getChild(childName,\n-            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n-      }\n-      count++;\n-    }\n-    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n-      // for snapshot path shrink the inode array. however, for path ending with\n-      // .snapshot, still keep last the null inode in the array\n-      INode[] newNodes \u003d new INode[components.length - 1];\n-      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n-      inodes \u003d newNodes;\n-    }\n-    return new INodesInPath(inodes, components, isSnapshot, snapshotId);\n+    return resolve(startingDir, components, false, resolveLink);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final boolean resolveLink)\n      throws UnresolvedLinkException {\n    return resolve(startingDir, components, false, resolveLink);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
      "extendedDetails": {}
    },
    "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-10762. Pass IIP for file status related methods. Contributed by Daryn Sharp.\"\n\nThis reverts commit 22fc46d7659972ff016ccf1c6f781f0c160be26f.\n",
      "commitDate": "22/08/16 2:57 PM",
      "commitName": "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "22/08/16 1:37 PM",
      "commitNameOld": "22fc46d7659972ff016ccf1c6f781f0c160be26f",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,5 +1,104 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n       final byte[][] components, final boolean resolveLink)\n       throws UnresolvedLinkException {\n-    return resolve(startingDir, components, false, resolveLink);\n+    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n+\n+    INode curNode \u003d startingDir;\n+    int count \u003d 0;\n+    int inodeNum \u003d 0;\n+    INode[] inodes \u003d new INode[components.length];\n+    boolean isSnapshot \u003d false;\n+    int snapshotId \u003d CURRENT_STATE_ID;\n+\n+    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n+      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n+      inodes[inodeNum++] \u003d curNode;\n+      final boolean isRef \u003d curNode.isReference();\n+      final boolean isDir \u003d curNode.isDirectory();\n+      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n+      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n+        //if the path is a non-snapshot path, update the latest snapshot.\n+        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n+            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n+            snapshotId)) {\n+          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n+        }\n+      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n+        // If the curNode is a reference node, need to check its dstSnapshot:\n+        // 1. if the existing snapshot is no later than the dstSnapshot (which\n+        // is the latest snapshot in dst before the rename), the changes \n+        // should be recorded in previous snapshots (belonging to src).\n+        // 2. however, if the ref node is already the last component, we still \n+        // need to know the latest snapshot among the ref node\u0027s ancestors, \n+        // in case of processing a deletion operation. Thus we do not overwrite\n+        // the latest snapshot if lastComp is true. In case of the operation is\n+        // a modification operation, we do a similar check in corresponding \n+        // recordModification method.\n+        if (!isSnapshot) {\n+          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n+          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n+              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n+               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n+            int lastSnapshot \u003d CURRENT_STATE_ID;\n+            DirectoryWithSnapshotFeature sf;\n+            if (curNode.isDirectory() \u0026\u0026 \n+                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n+              lastSnapshot \u003d sf.getLastSnapshotId();\n+            }\n+            snapshotId \u003d lastSnapshot;\n+          }\n+        }\n+      }\n+      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n+        final String path \u003d constructPath(components, 0, components.length);\n+        final String preceding \u003d constructPath(components, 0, count);\n+        final String remainder \u003d\n+          constructPath(components, count + 1, components.length);\n+        final String link \u003d DFSUtil.bytes2String(components[count]);\n+        final String target \u003d curNode.asSymlink().getSymlinkString();\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"UnresolvedPathException \" +\n+            \" path: \" + path + \" preceding: \" + preceding +\n+            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n+            \" remainder: \" + remainder);\n+        }\n+        throw new UnresolvedPathException(path, preceding, remainder, target);\n+      }\n+      if (lastComp || !isDir) {\n+        break;\n+      }\n+      final byte[] childName \u003d components[count + 1];\n+      \n+      // check if the next byte[] in components is for \".snapshot\"\n+      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n+        // skip the \".snapshot\" in components\n+        count++;\n+        isSnapshot \u003d true;\n+        // check if \".snapshot\" is the last element of components\n+        if (count \u003d\u003d components.length - 1) {\n+          break;\n+        }\n+        // Resolve snapshot root\n+        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n+        if (s \u003d\u003d null) {\n+          curNode \u003d null; // snapshot not found\n+        } else {\n+          curNode \u003d s.getRoot();\n+          snapshotId \u003d s.getId();\n+        }\n+      } else {\n+        // normal case, and also for resolving file/dir under snapshot root\n+        curNode \u003d dir.getChild(childName,\n+            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n+      }\n+      count++;\n+    }\n+    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n+      // for snapshot path shrink the inode array. however, for path ending with\n+      // .snapshot, still keep last the null inode in the array\n+      INode[] newNodes \u003d new INode[components.length - 1];\n+      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n+      inodes \u003d newNodes;\n+    }\n+    return new INodesInPath(inodes, components, isSnapshot, snapshotId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final boolean resolveLink)\n      throws UnresolvedLinkException {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    int count \u003d 0;\n    int inodeNum \u003d 0;\n    INode[] inodes \u003d new INode[components.length];\n    boolean isSnapshot \u003d false;\n    int snapshotId \u003d CURRENT_STATE_ID;\n\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n      inodes[inodeNum++] \u003d curNode;\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n            snapshotId)) {\n          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!isSnapshot) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n            int lastSnapshot \u003d CURRENT_STATE_ID;\n            DirectoryWithSnapshotFeature sf;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshotId();\n            }\n            snapshotId \u003d lastSnapshot;\n          }\n        }\n      }\n      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n        final String path \u003d constructPath(components, 0, components.length);\n        final String preceding \u003d constructPath(components, 0, count);\n        final String remainder \u003d\n          constructPath(components, count + 1, components.length);\n        final String link \u003d DFSUtil.bytes2String(components[count]);\n        final String target \u003d curNode.asSymlink().getSymlinkString();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UnresolvedPathException \" +\n            \" path: \" + path + \" preceding: \" + preceding +\n            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n            \" remainder: \" + remainder);\n        }\n        throw new UnresolvedPathException(path, preceding, remainder, target);\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n      final byte[] childName \u003d components[count + 1];\n      \n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n        // skip the \".snapshot\" in components\n        count++;\n        isSnapshot \u003d true;\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n        if (s \u003d\u003d null) {\n          curNode \u003d null; // snapshot not found\n        } else {\n          curNode \u003d s.getRoot();\n          snapshotId \u003d s.getId();\n        }\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName,\n            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n      }\n      count++;\n    }\n    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n      // for snapshot path shrink the inode array. however, for path ending with\n      // .snapshot, still keep last the null inode in the array\n      INode[] newNodes \u003d new INode[components.length - 1];\n      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n      inodes \u003d newNodes;\n    }\n    return new INodesInPath(inodes, components, isSnapshot, snapshotId);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
      "extendedDetails": {}
    },
    "22fc46d7659972ff016ccf1c6f781f0c160be26f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10762. Pass IIP for file status related methods. Contributed by Daryn Sharp.\n",
      "commitDate": "22/08/16 1:37 PM",
      "commitName": "22fc46d7659972ff016ccf1c6f781f0c160be26f",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "17/08/16 1:53 PM",
      "commitNameOld": "869393643de23dcb010cc33091c8eb398de0fd6c",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 4.99,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,5 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n       final byte[][] components, final boolean resolveLink)\n       throws UnresolvedLinkException {\n-    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n-\n-    INode curNode \u003d startingDir;\n-    int count \u003d 0;\n-    int inodeNum \u003d 0;\n-    INode[] inodes \u003d new INode[components.length];\n-    boolean isSnapshot \u003d false;\n-    int snapshotId \u003d CURRENT_STATE_ID;\n-\n-    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n-      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n-      inodes[inodeNum++] \u003d curNode;\n-      final boolean isRef \u003d curNode.isReference();\n-      final boolean isDir \u003d curNode.isDirectory();\n-      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n-      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n-        //if the path is a non-snapshot path, update the latest snapshot.\n-        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n-            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n-            snapshotId)) {\n-          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n-        }\n-      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n-        // If the curNode is a reference node, need to check its dstSnapshot:\n-        // 1. if the existing snapshot is no later than the dstSnapshot (which\n-        // is the latest snapshot in dst before the rename), the changes \n-        // should be recorded in previous snapshots (belonging to src).\n-        // 2. however, if the ref node is already the last component, we still \n-        // need to know the latest snapshot among the ref node\u0027s ancestors, \n-        // in case of processing a deletion operation. Thus we do not overwrite\n-        // the latest snapshot if lastComp is true. In case of the operation is\n-        // a modification operation, we do a similar check in corresponding \n-        // recordModification method.\n-        if (!isSnapshot) {\n-          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n-          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n-              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n-               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n-            int lastSnapshot \u003d CURRENT_STATE_ID;\n-            DirectoryWithSnapshotFeature sf;\n-            if (curNode.isDirectory() \u0026\u0026 \n-                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n-              lastSnapshot \u003d sf.getLastSnapshotId();\n-            }\n-            snapshotId \u003d lastSnapshot;\n-          }\n-        }\n-      }\n-      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n-        final String path \u003d constructPath(components, 0, components.length);\n-        final String preceding \u003d constructPath(components, 0, count);\n-        final String remainder \u003d\n-          constructPath(components, count + 1, components.length);\n-        final String link \u003d DFSUtil.bytes2String(components[count]);\n-        final String target \u003d curNode.asSymlink().getSymlinkString();\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"UnresolvedPathException \" +\n-            \" path: \" + path + \" preceding: \" + preceding +\n-            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n-            \" remainder: \" + remainder);\n-        }\n-        throw new UnresolvedPathException(path, preceding, remainder, target);\n-      }\n-      if (lastComp || !isDir) {\n-        break;\n-      }\n-      final byte[] childName \u003d components[count + 1];\n-      \n-      // check if the next byte[] in components is for \".snapshot\"\n-      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n-        // skip the \".snapshot\" in components\n-        count++;\n-        isSnapshot \u003d true;\n-        // check if \".snapshot\" is the last element of components\n-        if (count \u003d\u003d components.length - 1) {\n-          break;\n-        }\n-        // Resolve snapshot root\n-        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n-        if (s \u003d\u003d null) {\n-          curNode \u003d null; // snapshot not found\n-        } else {\n-          curNode \u003d s.getRoot();\n-          snapshotId \u003d s.getId();\n-        }\n-      } else {\n-        // normal case, and also for resolving file/dir under snapshot root\n-        curNode \u003d dir.getChild(childName,\n-            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n-      }\n-      count++;\n-    }\n-    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n-      // for snapshot path shrink the inode array. however, for path ending with\n-      // .snapshot, still keep last the null inode in the array\n-      INode[] newNodes \u003d new INode[components.length - 1];\n-      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n-      inodes \u003d newNodes;\n-    }\n-    return new INodesInPath(inodes, components, isSnapshot, snapshotId);\n+    return resolve(startingDir, components, false, resolveLink);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final boolean resolveLink)\n      throws UnresolvedLinkException {\n    return resolve(startingDir, components, false, resolveLink);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
      "extendedDetails": {}
    },
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
      "commitDate": "12/12/14 3:13 PM",
      "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "09/12/14 11:37 AM",
          "commitNameOld": "5776a41da08af653206bb94d7c76c9c4dcce059a",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 3.15,
          "commitsBetweenForRepo": 33,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,115 +1,104 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n-      final byte[][] components, final int numOfINodes,\n-      final boolean resolveLink) throws UnresolvedLinkException {\n+      final byte[][] components, final boolean resolveLink)\n+      throws UnresolvedLinkException {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n     int count \u003d 0;\n-    int index \u003d numOfINodes \u003c\u003d components.length ?\n-        numOfINodes - components.length : 0;\n     int inodeNum \u003d 0;\n-    int capacity \u003d numOfINodes;\n-    INode[] inodes \u003d new INode[numOfINodes];\n+    INode[] inodes \u003d new INode[components.length];\n     boolean isSnapshot \u003d false;\n     int snapshotId \u003d CURRENT_STATE_ID;\n \n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n-      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n-      if (index \u003e\u003d 0) {\n-        inodes[inodeNum++] \u003d curNode;\n-      }\n+      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n+      inodes[inodeNum++] \u003d curNode;\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n-      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n+      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n       if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n         if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n             dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n             snapshotId)) {\n           snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n         if (!isSnapshot) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n           if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n               (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n                dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n             int lastSnapshot \u003d CURRENT_STATE_ID;\n             DirectoryWithSnapshotFeature sf;\n             if (curNode.isDirectory() \u0026\u0026 \n                 (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n               lastSnapshot \u003d sf.getLastSnapshotId();\n             }\n             snapshotId \u003d lastSnapshot;\n           }\n         }\n       }\n       if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n         final String path \u003d constructPath(components, 0, components.length);\n         final String preceding \u003d constructPath(components, 0, count);\n         final String remainder \u003d\n           constructPath(components, count + 1, components.length);\n         final String link \u003d DFSUtil.bytes2String(components[count]);\n         final String target \u003d curNode.asSymlink().getSymlinkString();\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UnresolvedPathException \" +\n             \" path: \" + path + \" preceding: \" + preceding +\n             \" count: \" + count + \" link: \" + link + \" target: \" + target +\n             \" remainder: \" + remainder);\n         }\n         throw new UnresolvedPathException(path, preceding, remainder, target);\n       }\n       if (lastComp || !isDir) {\n         break;\n       }\n       final byte[] childName \u003d components[count + 1];\n       \n       // check if the next byte[] in components is for \".snapshot\"\n       if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n         // skip the \".snapshot\" in components\n         count++;\n-        index++;\n         isSnapshot \u003d true;\n-        if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n-          capacity--;\n-        }\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n         final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n         if (s \u003d\u003d null) {\n           curNode \u003d null; // snapshot not found\n         } else {\n           curNode \u003d s.getRoot();\n           snapshotId \u003d s.getId();\n         }\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n         curNode \u003d dir.getChild(childName,\n             isSnapshot ? snapshotId : CURRENT_STATE_ID);\n       }\n       count++;\n-      index++;\n     }\n-    if (isSnapshot \u0026\u0026 capacity \u003c numOfINodes \u0026\u0026\n-        !isDotSnapshotDir(components[components.length - 1])) {\n+    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n       // for snapshot path shrink the inode array. however, for path ending with\n       // .snapshot, still keep last the null inode in the array\n-      INode[] newNodes \u003d new INode[capacity];\n-      System.arraycopy(inodes, 0, newNodes, 0, capacity);\n+      INode[] newNodes \u003d new INode[components.length - 1];\n+      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n       inodes \u003d newNodes;\n     }\n     return new INodesInPath(inodes, components, isSnapshot, snapshotId);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final boolean resolveLink)\n      throws UnresolvedLinkException {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    int count \u003d 0;\n    int inodeNum \u003d 0;\n    INode[] inodes \u003d new INode[components.length];\n    boolean isSnapshot \u003d false;\n    int snapshotId \u003d CURRENT_STATE_ID;\n\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n      inodes[inodeNum++] \u003d curNode;\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n            snapshotId)) {\n          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!isSnapshot) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n            int lastSnapshot \u003d CURRENT_STATE_ID;\n            DirectoryWithSnapshotFeature sf;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshotId();\n            }\n            snapshotId \u003d lastSnapshot;\n          }\n        }\n      }\n      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n        final String path \u003d constructPath(components, 0, components.length);\n        final String preceding \u003d constructPath(components, 0, count);\n        final String remainder \u003d\n          constructPath(components, count + 1, components.length);\n        final String link \u003d DFSUtil.bytes2String(components[count]);\n        final String target \u003d curNode.asSymlink().getSymlinkString();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UnresolvedPathException \" +\n            \" path: \" + path + \" preceding: \" + preceding +\n            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n            \" remainder: \" + remainder);\n        }\n        throw new UnresolvedPathException(path, preceding, remainder, target);\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n      final byte[] childName \u003d components[count + 1];\n      \n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n        // skip the \".snapshot\" in components\n        count++;\n        isSnapshot \u003d true;\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n        if (s \u003d\u003d null) {\n          curNode \u003d null; // snapshot not found\n        } else {\n          curNode \u003d s.getRoot();\n          snapshotId \u003d s.getId();\n        }\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName,\n            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n      }\n      count++;\n    }\n    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n      // for snapshot path shrink the inode array. however, for path ending with\n      // .snapshot, still keep last the null inode in the array\n      INode[] newNodes \u003d new INode[components.length - 1];\n      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n      inodes \u003d newNodes;\n    }\n    return new INodesInPath(inodes, components, isSnapshot, snapshotId);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
          "extendedDetails": {
            "oldValue": "[startingDir-INodeDirectory(modifiers-final), components-byte[][](modifiers-final), numOfINodes-int(modifiers-final), resolveLink-boolean(modifiers-final)]",
            "newValue": "[startingDir-INodeDirectory(modifiers-final), components-byte[][](modifiers-final), resolveLink-boolean(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
          "commitDate": "12/12/14 3:13 PM",
          "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "09/12/14 11:37 AM",
          "commitNameOld": "5776a41da08af653206bb94d7c76c9c4dcce059a",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 3.15,
          "commitsBetweenForRepo": 33,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,115 +1,104 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n-      final byte[][] components, final int numOfINodes,\n-      final boolean resolveLink) throws UnresolvedLinkException {\n+      final byte[][] components, final boolean resolveLink)\n+      throws UnresolvedLinkException {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n     int count \u003d 0;\n-    int index \u003d numOfINodes \u003c\u003d components.length ?\n-        numOfINodes - components.length : 0;\n     int inodeNum \u003d 0;\n-    int capacity \u003d numOfINodes;\n-    INode[] inodes \u003d new INode[numOfINodes];\n+    INode[] inodes \u003d new INode[components.length];\n     boolean isSnapshot \u003d false;\n     int snapshotId \u003d CURRENT_STATE_ID;\n \n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n-      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n-      if (index \u003e\u003d 0) {\n-        inodes[inodeNum++] \u003d curNode;\n-      }\n+      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n+      inodes[inodeNum++] \u003d curNode;\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n-      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n+      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n       if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n         if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n             dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n             snapshotId)) {\n           snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n         if (!isSnapshot) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n           if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n               (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n                dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n             int lastSnapshot \u003d CURRENT_STATE_ID;\n             DirectoryWithSnapshotFeature sf;\n             if (curNode.isDirectory() \u0026\u0026 \n                 (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n               lastSnapshot \u003d sf.getLastSnapshotId();\n             }\n             snapshotId \u003d lastSnapshot;\n           }\n         }\n       }\n       if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n         final String path \u003d constructPath(components, 0, components.length);\n         final String preceding \u003d constructPath(components, 0, count);\n         final String remainder \u003d\n           constructPath(components, count + 1, components.length);\n         final String link \u003d DFSUtil.bytes2String(components[count]);\n         final String target \u003d curNode.asSymlink().getSymlinkString();\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UnresolvedPathException \" +\n             \" path: \" + path + \" preceding: \" + preceding +\n             \" count: \" + count + \" link: \" + link + \" target: \" + target +\n             \" remainder: \" + remainder);\n         }\n         throw new UnresolvedPathException(path, preceding, remainder, target);\n       }\n       if (lastComp || !isDir) {\n         break;\n       }\n       final byte[] childName \u003d components[count + 1];\n       \n       // check if the next byte[] in components is for \".snapshot\"\n       if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n         // skip the \".snapshot\" in components\n         count++;\n-        index++;\n         isSnapshot \u003d true;\n-        if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n-          capacity--;\n-        }\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n         final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n         if (s \u003d\u003d null) {\n           curNode \u003d null; // snapshot not found\n         } else {\n           curNode \u003d s.getRoot();\n           snapshotId \u003d s.getId();\n         }\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n         curNode \u003d dir.getChild(childName,\n             isSnapshot ? snapshotId : CURRENT_STATE_ID);\n       }\n       count++;\n-      index++;\n     }\n-    if (isSnapshot \u0026\u0026 capacity \u003c numOfINodes \u0026\u0026\n-        !isDotSnapshotDir(components[components.length - 1])) {\n+    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n       // for snapshot path shrink the inode array. however, for path ending with\n       // .snapshot, still keep last the null inode in the array\n-      INode[] newNodes \u003d new INode[capacity];\n-      System.arraycopy(inodes, 0, newNodes, 0, capacity);\n+      INode[] newNodes \u003d new INode[components.length - 1];\n+      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n       inodes \u003d newNodes;\n     }\n     return new INodesInPath(inodes, components, isSnapshot, snapshotId);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final boolean resolveLink)\n      throws UnresolvedLinkException {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    int count \u003d 0;\n    int inodeNum \u003d 0;\n    INode[] inodes \u003d new INode[components.length];\n    boolean isSnapshot \u003d false;\n    int snapshotId \u003d CURRENT_STATE_ID;\n\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);\n      inodes[inodeNum++] \u003d curNode;\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;\n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n            snapshotId)) {\n          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!isSnapshot) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n            int lastSnapshot \u003d CURRENT_STATE_ID;\n            DirectoryWithSnapshotFeature sf;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshotId();\n            }\n            snapshotId \u003d lastSnapshot;\n          }\n        }\n      }\n      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n        final String path \u003d constructPath(components, 0, components.length);\n        final String preceding \u003d constructPath(components, 0, count);\n        final String remainder \u003d\n          constructPath(components, count + 1, components.length);\n        final String link \u003d DFSUtil.bytes2String(components[count]);\n        final String target \u003d curNode.asSymlink().getSymlinkString();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UnresolvedPathException \" +\n            \" path: \" + path + \" preceding: \" + preceding +\n            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n            \" remainder: \" + remainder);\n        }\n        throw new UnresolvedPathException(path, preceding, remainder, target);\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n      final byte[] childName \u003d components[count + 1];\n      \n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n        // skip the \".snapshot\" in components\n        count++;\n        isSnapshot \u003d true;\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n        if (s \u003d\u003d null) {\n          curNode \u003d null; // snapshot not found\n        } else {\n          curNode \u003d s.getRoot();\n          snapshotId \u003d s.getId();\n        }\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName,\n            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n      }\n      count++;\n    }\n    if (isSnapshot \u0026\u0026 !isDotSnapshotDir(components[components.length - 1])) {\n      // for snapshot path shrink the inode array. however, for path ending with\n      // .snapshot, still keep last the null inode in the array\n      INode[] newNodes \u003d new INode[components.length - 1];\n      System.arraycopy(inodes, 0, newNodes, 0, newNodes.length);\n      inodes \u003d newNodes;\n    }\n    return new INodesInPath(inodes, components, isSnapshot, snapshotId);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
          "extendedDetails": {}
        }
      ]
    },
    "5776a41da08af653206bb94d7c76c9c4dcce059a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7498. Simplify the logic in INodesInPath. Contributed by Jing Zhao.\n",
      "commitDate": "09/12/14 11:37 AM",
      "commitName": "5776a41da08af653206bb94d7c76c9c4dcce059a",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "05/12/14 2:17 PM",
      "commitNameOld": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 3.89,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,115 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n-      final byte[][] components, final int numOfINodes, \n+      final byte[][] components, final int numOfINodes,\n       final boolean resolveLink) throws UnresolvedLinkException {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n-    final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n     int count \u003d 0;\n-    int index \u003d numOfINodes - components.length;\n-    if (index \u003e 0) {\n-      index \u003d 0;\n-    }\n+    int index \u003d numOfINodes \u003c\u003d components.length ?\n+        numOfINodes - components.length : 0;\n+    int inodeNum \u003d 0;\n+    int capacity \u003d numOfINodes;\n+    INode[] inodes \u003d new INode[numOfINodes];\n+    boolean isSnapshot \u003d false;\n+    int snapshotId \u003d CURRENT_STATE_ID;\n+\n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n       final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n       if (index \u003e\u003d 0) {\n-        existing.addNode(curNode);\n+        inodes[inodeNum++] \u003d curNode;\n       }\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n       final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n       if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n-        if (!existing.isSnapshot()) {\n-          existing.updateLatestSnapshotId(dir.getDirectoryWithSnapshotFeature()\n-              .getLastSnapshotId());\n+        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n+            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n+            snapshotId)) {\n+          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n-        if (!existing.isSnapshot()) {\n+        if (!isSnapshot) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n-          int latest \u003d existing.getLatestSnapshotId();\n-          if (latest \u003d\u003d Snapshot.CURRENT_STATE_ID || // no snapshot in dst tree of rename\n-              (dstSnapshotId !\u003d Snapshot.CURRENT_STATE_ID \u0026\u0026 \n-                dstSnapshotId \u003e\u003d latest)) { // the above scenario \n-            int lastSnapshot \u003d Snapshot.CURRENT_STATE_ID;\n+          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n+              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n+               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n+            int lastSnapshot \u003d CURRENT_STATE_ID;\n             DirectoryWithSnapshotFeature sf;\n             if (curNode.isDirectory() \u0026\u0026 \n                 (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n               lastSnapshot \u003d sf.getLastSnapshotId();\n             }\n-            existing.setSnapshotId(lastSnapshot);\n+            snapshotId \u003d lastSnapshot;\n           }\n         }\n       }\n       if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n         final String path \u003d constructPath(components, 0, components.length);\n         final String preceding \u003d constructPath(components, 0, count);\n         final String remainder \u003d\n           constructPath(components, count + 1, components.length);\n         final String link \u003d DFSUtil.bytes2String(components[count]);\n         final String target \u003d curNode.asSymlink().getSymlinkString();\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UnresolvedPathException \" +\n             \" path: \" + path + \" preceding: \" + preceding +\n             \" count: \" + count + \" link: \" + link + \" target: \" + target +\n             \" remainder: \" + remainder);\n         }\n         throw new UnresolvedPathException(path, preceding, remainder, target);\n       }\n       if (lastComp || !isDir) {\n         break;\n       }\n       final byte[] childName \u003d components[count + 1];\n       \n       // check if the next byte[] in components is for \".snapshot\"\n       if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n         // skip the \".snapshot\" in components\n         count++;\n         index++;\n-        existing.isSnapshot \u003d true;\n+        isSnapshot \u003d true;\n         if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n-          existing.capacity--;\n+          capacity--;\n         }\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n         final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n         if (s \u003d\u003d null) {\n-          //snapshot not found\n-          curNode \u003d null;\n+          curNode \u003d null; // snapshot not found\n         } else {\n           curNode \u003d s.getRoot();\n-          existing.setSnapshotId(s.getId());\n-        }\n-        if (index \u003e\u003d -1) {\n-          existing.snapshotRootIndex \u003d existing.numNonNull;\n+          snapshotId \u003d s.getId();\n         }\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n-        curNode \u003d dir.getChild(childName, existing.getPathSnapshotId());\n+        curNode \u003d dir.getChild(childName,\n+            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n       }\n       count++;\n       index++;\n     }\n-    return existing;\n+    if (isSnapshot \u0026\u0026 capacity \u003c numOfINodes \u0026\u0026\n+        !isDotSnapshotDir(components[components.length - 1])) {\n+      // for snapshot path shrink the inode array. however, for path ending with\n+      // .snapshot, still keep last the null inode in the array\n+      INode[] newNodes \u003d new INode[capacity];\n+      System.arraycopy(inodes, 0, newNodes, 0, capacity);\n+      inodes \u003d newNodes;\n+    }\n+    return new INodesInPath(inodes, components, isSnapshot, snapshotId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final int numOfINodes,\n      final boolean resolveLink) throws UnresolvedLinkException {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    int count \u003d 0;\n    int index \u003d numOfINodes \u003c\u003d components.length ?\n        numOfINodes - components.length : 0;\n    int inodeNum \u003d 0;\n    int capacity \u003d numOfINodes;\n    INode[] inodes \u003d new INode[numOfINodes];\n    boolean isSnapshot \u003d false;\n    int snapshotId \u003d CURRENT_STATE_ID;\n\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n      if (index \u003e\u003d 0) {\n        inodes[inodeNum++] \u003d curNode;\n      }\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!isSnapshot \u0026\u0026 shouldUpdateLatestId(\n            dir.getDirectoryWithSnapshotFeature().getLastSnapshotId(),\n            snapshotId)) {\n          snapshotId \u003d dir.getDirectoryWithSnapshotFeature().getLastSnapshotId();\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!isSnapshot) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          if (snapshotId \u003d\u003d CURRENT_STATE_ID || // no snapshot in dst tree of rename\n              (dstSnapshotId !\u003d CURRENT_STATE_ID \u0026\u0026\n               dstSnapshotId \u003e\u003d snapshotId)) { // the above scenario\n            int lastSnapshot \u003d CURRENT_STATE_ID;\n            DirectoryWithSnapshotFeature sf;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshotId();\n            }\n            snapshotId \u003d lastSnapshot;\n          }\n        }\n      }\n      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n        final String path \u003d constructPath(components, 0, components.length);\n        final String preceding \u003d constructPath(components, 0, count);\n        final String remainder \u003d\n          constructPath(components, count + 1, components.length);\n        final String link \u003d DFSUtil.bytes2String(components[count]);\n        final String target \u003d curNode.asSymlink().getSymlinkString();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UnresolvedPathException \" +\n            \" path: \" + path + \" preceding: \" + preceding +\n            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n            \" remainder: \" + remainder);\n        }\n        throw new UnresolvedPathException(path, preceding, remainder, target);\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n      final byte[] childName \u003d components[count + 1];\n      \n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n        // skip the \".snapshot\" in components\n        count++;\n        index++;\n        isSnapshot \u003d true;\n        if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n          capacity--;\n        }\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n        if (s \u003d\u003d null) {\n          curNode \u003d null; // snapshot not found\n        } else {\n          curNode \u003d s.getRoot();\n          snapshotId \u003d s.getId();\n        }\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName,\n            isSnapshot ? snapshotId : CURRENT_STATE_ID);\n      }\n      count++;\n      index++;\n    }\n    if (isSnapshot \u0026\u0026 capacity \u003c numOfINodes \u0026\u0026\n        !isDotSnapshotDir(components[components.length - 1])) {\n      // for snapshot path shrink the inode array. however, for path ending with\n      // .snapshot, still keep last the null inode in the array\n      INode[] newNodes \u003d new INode[capacity];\n      System.arraycopy(inodes, 0, newNodes, 0, capacity);\n      inodes \u003d newNodes;\n    }\n    return new INodesInPath(inodes, components, isSnapshot, snapshotId);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
      "extendedDetails": {}
    },
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
      "commitDate": "05/12/14 2:17 PM",
      "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "29/09/14 12:58 PM",
      "commitNameOld": "f0293f11a85176afc04d809574c9126a80b700cc",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 67.1,
      "commitsBetweenForRepo": 581,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,107 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n       final byte[][] components, final int numOfINodes, \n       final boolean resolveLink) throws UnresolvedLinkException {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n     final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n     int count \u003d 0;\n     int index \u003d numOfINodes - components.length;\n     if (index \u003e 0) {\n       index \u003d 0;\n     }\n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n       final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n       if (index \u003e\u003d 0) {\n         existing.addNode(curNode);\n       }\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n       final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n       if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n         if (!existing.isSnapshot()) {\n           existing.updateLatestSnapshotId(dir.getDirectoryWithSnapshotFeature()\n               .getLastSnapshotId());\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n         if (!existing.isSnapshot()) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n           int latest \u003d existing.getLatestSnapshotId();\n           if (latest \u003d\u003d Snapshot.CURRENT_STATE_ID || // no snapshot in dst tree of rename\n               (dstSnapshotId !\u003d Snapshot.CURRENT_STATE_ID \u0026\u0026 \n                 dstSnapshotId \u003e\u003d latest)) { // the above scenario \n             int lastSnapshot \u003d Snapshot.CURRENT_STATE_ID;\n-            DirectoryWithSnapshotFeature sf \u003d null;\n+            DirectoryWithSnapshotFeature sf;\n             if (curNode.isDirectory() \u0026\u0026 \n                 (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n               lastSnapshot \u003d sf.getLastSnapshotId();\n             }\n             existing.setSnapshotId(lastSnapshot);\n           }\n         }\n       }\n-      if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n+      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n         final String path \u003d constructPath(components, 0, components.length);\n         final String preceding \u003d constructPath(components, 0, count);\n         final String remainder \u003d\n           constructPath(components, count + 1, components.length);\n         final String link \u003d DFSUtil.bytes2String(components[count]);\n         final String target \u003d curNode.asSymlink().getSymlinkString();\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UnresolvedPathException \" +\n             \" path: \" + path + \" preceding: \" + preceding +\n             \" count: \" + count + \" link: \" + link + \" target: \" + target +\n             \" remainder: \" + remainder);\n         }\n         throw new UnresolvedPathException(path, preceding, remainder, target);\n       }\n       if (lastComp || !isDir) {\n         break;\n       }\n       final byte[] childName \u003d components[count + 1];\n       \n       // check if the next byte[] in components is for \".snapshot\"\n-      if (isDotSnapshotDir(childName) \u0026\u0026 isDir \u0026\u0026 dir.isSnapshottable()) {\n+      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n         // skip the \".snapshot\" in components\n         count++;\n         index++;\n         existing.isSnapshot \u003d true;\n         if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n           existing.capacity--;\n         }\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n         final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n         if (s \u003d\u003d null) {\n           //snapshot not found\n           curNode \u003d null;\n         } else {\n           curNode \u003d s.getRoot();\n           existing.setSnapshotId(s.getId());\n         }\n         if (index \u003e\u003d -1) {\n           existing.snapshotRootIndex \u003d existing.numNonNull;\n         }\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n         curNode \u003d dir.getChild(childName, existing.getPathSnapshotId());\n       }\n       count++;\n       index++;\n     }\n     return existing;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final int numOfINodes, \n      final boolean resolveLink) throws UnresolvedLinkException {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n    int count \u003d 0;\n    int index \u003d numOfINodes - components.length;\n    if (index \u003e 0) {\n      index \u003d 0;\n    }\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n      if (index \u003e\u003d 0) {\n        existing.addNode(curNode);\n      }\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!existing.isSnapshot()) {\n          existing.updateLatestSnapshotId(dir.getDirectoryWithSnapshotFeature()\n              .getLastSnapshotId());\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!existing.isSnapshot()) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          int latest \u003d existing.getLatestSnapshotId();\n          if (latest \u003d\u003d Snapshot.CURRENT_STATE_ID || // no snapshot in dst tree of rename\n              (dstSnapshotId !\u003d Snapshot.CURRENT_STATE_ID \u0026\u0026 \n                dstSnapshotId \u003e\u003d latest)) { // the above scenario \n            int lastSnapshot \u003d Snapshot.CURRENT_STATE_ID;\n            DirectoryWithSnapshotFeature sf;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshotId();\n            }\n            existing.setSnapshotId(lastSnapshot);\n          }\n        }\n      }\n      if (curNode.isSymlink() \u0026\u0026 (!lastComp || resolveLink)) {\n        final String path \u003d constructPath(components, 0, components.length);\n        final String preceding \u003d constructPath(components, 0, count);\n        final String remainder \u003d\n          constructPath(components, count + 1, components.length);\n        final String link \u003d DFSUtil.bytes2String(components[count]);\n        final String target \u003d curNode.asSymlink().getSymlinkString();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UnresolvedPathException \" +\n            \" path: \" + path + \" preceding: \" + preceding +\n            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n            \" remainder: \" + remainder);\n        }\n        throw new UnresolvedPathException(path, preceding, remainder, target);\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n      final byte[] childName \u003d components[count + 1];\n      \n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName) \u0026\u0026 dir.isSnapshottable()) {\n        // skip the \".snapshot\" in components\n        count++;\n        index++;\n        existing.isSnapshot \u003d true;\n        if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n          existing.capacity--;\n        }\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n        if (s \u003d\u003d null) {\n          //snapshot not found\n          curNode \u003d null;\n        } else {\n          curNode \u003d s.getRoot();\n          existing.setSnapshotId(s.getId());\n        }\n        if (index \u003e\u003d -1) {\n          existing.snapshotRootIndex \u003d existing.numNonNull;\n        }\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName, existing.getPathSnapshotId());\n      }\n      count++;\n      index++;\n    }\n    return existing;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
      "extendedDetails": {}
    },
    "76a621ffd2d66bf012a554f4400091a92a5b473e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6609. Use DirectorySnapshottableFeature to represent a snapshottable directory. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1608631 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/07/14 5:08 PM",
      "commitName": "76a621ffd2d66bf012a554f4400091a92a5b473e",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "09/05/14 3:36 PM",
      "commitNameOld": "f131dba8a3d603a5d15c4f035ed3da75b4daf0dc",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 59.06,
      "commitsBetweenForRepo": 359,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,107 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n       final byte[][] components, final int numOfINodes, \n       final boolean resolveLink) throws UnresolvedLinkException {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n     final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n     int count \u003d 0;\n     int index \u003d numOfINodes - components.length;\n     if (index \u003e 0) {\n       index \u003d 0;\n     }\n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n       final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n       if (index \u003e\u003d 0) {\n         existing.addNode(curNode);\n       }\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n       final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n       if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n         if (!existing.isSnapshot()) {\n           existing.updateLatestSnapshotId(dir.getDirectoryWithSnapshotFeature()\n               .getLastSnapshotId());\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n         if (!existing.isSnapshot()) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n           int latest \u003d existing.getLatestSnapshotId();\n           if (latest \u003d\u003d Snapshot.CURRENT_STATE_ID || // no snapshot in dst tree of rename\n               (dstSnapshotId !\u003d Snapshot.CURRENT_STATE_ID \u0026\u0026 \n                 dstSnapshotId \u003e\u003d latest)) { // the above scenario \n             int lastSnapshot \u003d Snapshot.CURRENT_STATE_ID;\n             DirectoryWithSnapshotFeature sf \u003d null;\n             if (curNode.isDirectory() \u0026\u0026 \n                 (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n               lastSnapshot \u003d sf.getLastSnapshotId();\n             }\n             existing.setSnapshotId(lastSnapshot);\n           }\n         }\n       }\n       if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n         final String path \u003d constructPath(components, 0, components.length);\n         final String preceding \u003d constructPath(components, 0, count);\n         final String remainder \u003d\n           constructPath(components, count + 1, components.length);\n         final String link \u003d DFSUtil.bytes2String(components[count]);\n         final String target \u003d curNode.asSymlink().getSymlinkString();\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UnresolvedPathException \" +\n             \" path: \" + path + \" preceding: \" + preceding +\n             \" count: \" + count + \" link: \" + link + \" target: \" + target +\n             \" remainder: \" + remainder);\n         }\n         throw new UnresolvedPathException(path, preceding, remainder, target);\n       }\n       if (lastComp || !isDir) {\n         break;\n       }\n       final byte[] childName \u003d components[count + 1];\n       \n       // check if the next byte[] in components is for \".snapshot\"\n-      if (isDotSnapshotDir(childName)\n-          \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectorySnapshottable) {\n+      if (isDotSnapshotDir(childName) \u0026\u0026 isDir \u0026\u0026 dir.isSnapshottable()) {\n         // skip the \".snapshot\" in components\n         count++;\n         index++;\n         existing.isSnapshot \u003d true;\n         if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n           existing.capacity--;\n         }\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n-        final Snapshot s \u003d ((INodeDirectorySnapshottable)dir).getSnapshot(\n-            components[count + 1]);\n+        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n         if (s \u003d\u003d null) {\n           //snapshot not found\n           curNode \u003d null;\n         } else {\n           curNode \u003d s.getRoot();\n           existing.setSnapshotId(s.getId());\n         }\n         if (index \u003e\u003d -1) {\n           existing.snapshotRootIndex \u003d existing.numNonNull;\n         }\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n         curNode \u003d dir.getChild(childName, existing.getPathSnapshotId());\n       }\n       count++;\n       index++;\n     }\n     return existing;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final int numOfINodes, \n      final boolean resolveLink) throws UnresolvedLinkException {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n    int count \u003d 0;\n    int index \u003d numOfINodes - components.length;\n    if (index \u003e 0) {\n      index \u003d 0;\n    }\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n      if (index \u003e\u003d 0) {\n        existing.addNode(curNode);\n      }\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!existing.isSnapshot()) {\n          existing.updateLatestSnapshotId(dir.getDirectoryWithSnapshotFeature()\n              .getLastSnapshotId());\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!existing.isSnapshot()) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          int latest \u003d existing.getLatestSnapshotId();\n          if (latest \u003d\u003d Snapshot.CURRENT_STATE_ID || // no snapshot in dst tree of rename\n              (dstSnapshotId !\u003d Snapshot.CURRENT_STATE_ID \u0026\u0026 \n                dstSnapshotId \u003e\u003d latest)) { // the above scenario \n            int lastSnapshot \u003d Snapshot.CURRENT_STATE_ID;\n            DirectoryWithSnapshotFeature sf \u003d null;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshotId();\n            }\n            existing.setSnapshotId(lastSnapshot);\n          }\n        }\n      }\n      if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n        final String path \u003d constructPath(components, 0, components.length);\n        final String preceding \u003d constructPath(components, 0, count);\n        final String remainder \u003d\n          constructPath(components, count + 1, components.length);\n        final String link \u003d DFSUtil.bytes2String(components[count]);\n        final String target \u003d curNode.asSymlink().getSymlinkString();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UnresolvedPathException \" +\n            \" path: \" + path + \" preceding: \" + preceding +\n            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n            \" remainder: \" + remainder);\n        }\n        throw new UnresolvedPathException(path, preceding, remainder, target);\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n      final byte[] childName \u003d components[count + 1];\n      \n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName) \u0026\u0026 isDir \u0026\u0026 dir.isSnapshottable()) {\n        // skip the \".snapshot\" in components\n        count++;\n        index++;\n        existing.isSnapshot \u003d true;\n        if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n          existing.capacity--;\n        }\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d dir.getSnapshot(components[count + 1]);\n        if (s \u003d\u003d null) {\n          //snapshot not found\n          curNode \u003d null;\n        } else {\n          curNode \u003d s.getRoot();\n          existing.setSnapshotId(s.getId());\n        }\n        if (index \u003e\u003d -1) {\n          existing.snapshotRootIndex \u003d existing.numNonNull;\n        }\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName, existing.getPathSnapshotId());\n      }\n      count++;\n      index++;\n    }\n    return existing;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
      "extendedDetails": {}
    },
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5715. Use Snapshot ID to indicate the corresponding Snapshot for a FileDiff/DirectoryDiff. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/14 12:52 PM",
      "commitName": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "14/12/13 2:13 AM",
      "commitNameOld": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 24.44,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,109 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n       final byte[][] components, final int numOfINodes, \n       final boolean resolveLink) throws UnresolvedLinkException {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n     final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n     int count \u003d 0;\n     int index \u003d numOfINodes - components.length;\n     if (index \u003e 0) {\n       index \u003d 0;\n     }\n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n       final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n       if (index \u003e\u003d 0) {\n         existing.addNode(curNode);\n       }\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n       final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n       if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n         if (!existing.isSnapshot()) {\n-          existing.updateLatestSnapshot(dir.getDirectoryWithSnapshotFeature()\n-              .getLastSnapshot());\n+          existing.updateLatestSnapshotId(dir.getDirectoryWithSnapshotFeature()\n+              .getLastSnapshotId());\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n         if (!existing.isSnapshot()) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n-          Snapshot latest \u003d existing.getLatestSnapshot();\n-          if (latest \u003d\u003d null ||  // no snapshot in dst tree of rename\n-              dstSnapshotId \u003e\u003d latest.getId()) { // the above scenario \n-            Snapshot lastSnapshot \u003d null;\n+          int latest \u003d existing.getLatestSnapshotId();\n+          if (latest \u003d\u003d Snapshot.CURRENT_STATE_ID || // no snapshot in dst tree of rename\n+              (dstSnapshotId !\u003d Snapshot.CURRENT_STATE_ID \u0026\u0026 \n+                dstSnapshotId \u003e\u003d latest)) { // the above scenario \n+            int lastSnapshot \u003d Snapshot.CURRENT_STATE_ID;\n             DirectoryWithSnapshotFeature sf \u003d null;\n             if (curNode.isDirectory() \u0026\u0026 \n                 (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n-              lastSnapshot \u003d sf.getLastSnapshot();\n+              lastSnapshot \u003d sf.getLastSnapshotId();\n             }\n-            existing.setSnapshot(lastSnapshot);\n+            existing.setSnapshotId(lastSnapshot);\n           }\n         }\n       }\n       if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n         final String path \u003d constructPath(components, 0, components.length);\n         final String preceding \u003d constructPath(components, 0, count);\n         final String remainder \u003d\n           constructPath(components, count + 1, components.length);\n         final String link \u003d DFSUtil.bytes2String(components[count]);\n         final String target \u003d curNode.asSymlink().getSymlinkString();\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UnresolvedPathException \" +\n             \" path: \" + path + \" preceding: \" + preceding +\n             \" count: \" + count + \" link: \" + link + \" target: \" + target +\n             \" remainder: \" + remainder);\n         }\n         throw new UnresolvedPathException(path, preceding, remainder, target);\n       }\n       if (lastComp || !isDir) {\n         break;\n       }\n       final byte[] childName \u003d components[count + 1];\n       \n       // check if the next byte[] in components is for \".snapshot\"\n       if (isDotSnapshotDir(childName)\n           \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectorySnapshottable) {\n         // skip the \".snapshot\" in components\n         count++;\n         index++;\n         existing.isSnapshot \u003d true;\n         if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n           existing.capacity--;\n         }\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n         final Snapshot s \u003d ((INodeDirectorySnapshottable)dir).getSnapshot(\n             components[count + 1]);\n         if (s \u003d\u003d null) {\n           //snapshot not found\n           curNode \u003d null;\n         } else {\n           curNode \u003d s.getRoot();\n-          existing.setSnapshot(s);\n+          existing.setSnapshotId(s.getId());\n         }\n         if (index \u003e\u003d -1) {\n           existing.snapshotRootIndex \u003d existing.numNonNull;\n         }\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n-        curNode \u003d dir.getChild(childName, existing.getPathSnapshot());\n+        curNode \u003d dir.getChild(childName, existing.getPathSnapshotId());\n       }\n       count++;\n       index++;\n     }\n     return existing;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final int numOfINodes, \n      final boolean resolveLink) throws UnresolvedLinkException {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n    int count \u003d 0;\n    int index \u003d numOfINodes - components.length;\n    if (index \u003e 0) {\n      index \u003d 0;\n    }\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n      if (index \u003e\u003d 0) {\n        existing.addNode(curNode);\n      }\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!existing.isSnapshot()) {\n          existing.updateLatestSnapshotId(dir.getDirectoryWithSnapshotFeature()\n              .getLastSnapshotId());\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!existing.isSnapshot()) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          int latest \u003d existing.getLatestSnapshotId();\n          if (latest \u003d\u003d Snapshot.CURRENT_STATE_ID || // no snapshot in dst tree of rename\n              (dstSnapshotId !\u003d Snapshot.CURRENT_STATE_ID \u0026\u0026 \n                dstSnapshotId \u003e\u003d latest)) { // the above scenario \n            int lastSnapshot \u003d Snapshot.CURRENT_STATE_ID;\n            DirectoryWithSnapshotFeature sf \u003d null;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshotId();\n            }\n            existing.setSnapshotId(lastSnapshot);\n          }\n        }\n      }\n      if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n        final String path \u003d constructPath(components, 0, components.length);\n        final String preceding \u003d constructPath(components, 0, count);\n        final String remainder \u003d\n          constructPath(components, count + 1, components.length);\n        final String link \u003d DFSUtil.bytes2String(components[count]);\n        final String target \u003d curNode.asSymlink().getSymlinkString();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UnresolvedPathException \" +\n            \" path: \" + path + \" preceding: \" + preceding +\n            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n            \" remainder: \" + remainder);\n        }\n        throw new UnresolvedPathException(path, preceding, remainder, target);\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n      final byte[] childName \u003d components[count + 1];\n      \n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName)\n          \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectorySnapshottable) {\n        // skip the \".snapshot\" in components\n        count++;\n        index++;\n        existing.isSnapshot \u003d true;\n        if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n          existing.capacity--;\n        }\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d ((INodeDirectorySnapshottable)dir).getSnapshot(\n            components[count + 1]);\n        if (s \u003d\u003d null) {\n          //snapshot not found\n          curNode \u003d null;\n        } else {\n          curNode \u003d s.getRoot();\n          existing.setSnapshotId(s.getId());\n        }\n        if (index \u003e\u003d -1) {\n          existing.snapshotRootIndex \u003d existing.numNonNull;\n        }\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName, existing.getPathSnapshotId());\n      }\n      count++;\n      index++;\n    }\n    return existing;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
      "extendedDetails": {}
    },
    "44a6560b5da3f79d2299579a36e7a2a60a91f823": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5632. Flatten INodeDirectory hierarchy: Replace INodeDirectoryWithSnapshot with DirectoryWithSnapshotFeature.  Contributed by jing9 \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1550917 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/12/13 2:13 AM",
      "commitName": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "05/06/13 4:32 PM",
      "commitNameOld": "496b80b28c35dbd52d3d919d16f4c75983f81a79",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 191.44,
      "commitsBetweenForRepo": 1231,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,108 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n       final byte[][] components, final int numOfINodes, \n       final boolean resolveLink) throws UnresolvedLinkException {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n     final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n     int count \u003d 0;\n     int index \u003d numOfINodes - components.length;\n     if (index \u003e 0) {\n       index \u003d 0;\n     }\n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n       final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n       if (index \u003e\u003d 0) {\n         existing.addNode(curNode);\n       }\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n       final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n-      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectoryWithSnapshot) {\n+      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n         if (!existing.isSnapshot()) {\n-          existing.updateLatestSnapshot(\n-              ((INodeDirectoryWithSnapshot)dir).getLastSnapshot());\n+          existing.updateLatestSnapshot(dir.getDirectoryWithSnapshotFeature()\n+              .getLastSnapshot());\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n         if (!existing.isSnapshot()) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n           Snapshot latest \u003d existing.getLatestSnapshot();\n           if (latest \u003d\u003d null ||  // no snapshot in dst tree of rename\n               dstSnapshotId \u003e\u003d latest.getId()) { // the above scenario \n             Snapshot lastSnapshot \u003d null;\n-            if (curNode.isDirectory()\n-                \u0026\u0026 curNode.asDirectory() instanceof INodeDirectoryWithSnapshot) {\n-              lastSnapshot \u003d ((INodeDirectoryWithSnapshot) curNode\n-                  .asDirectory()).getLastSnapshot();\n+            DirectoryWithSnapshotFeature sf \u003d null;\n+            if (curNode.isDirectory() \u0026\u0026 \n+                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n+              lastSnapshot \u003d sf.getLastSnapshot();\n             }\n             existing.setSnapshot(lastSnapshot);\n           }\n         }\n       }\n       if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n         final String path \u003d constructPath(components, 0, components.length);\n         final String preceding \u003d constructPath(components, 0, count);\n         final String remainder \u003d\n           constructPath(components, count + 1, components.length);\n         final String link \u003d DFSUtil.bytes2String(components[count]);\n         final String target \u003d curNode.asSymlink().getSymlinkString();\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UnresolvedPathException \" +\n             \" path: \" + path + \" preceding: \" + preceding +\n             \" count: \" + count + \" link: \" + link + \" target: \" + target +\n             \" remainder: \" + remainder);\n         }\n         throw new UnresolvedPathException(path, preceding, remainder, target);\n       }\n       if (lastComp || !isDir) {\n         break;\n       }\n       final byte[] childName \u003d components[count + 1];\n       \n       // check if the next byte[] in components is for \".snapshot\"\n       if (isDotSnapshotDir(childName)\n           \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectorySnapshottable) {\n         // skip the \".snapshot\" in components\n         count++;\n         index++;\n         existing.isSnapshot \u003d true;\n         if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n           existing.capacity--;\n         }\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n         final Snapshot s \u003d ((INodeDirectorySnapshottable)dir).getSnapshot(\n             components[count + 1]);\n         if (s \u003d\u003d null) {\n           //snapshot not found\n           curNode \u003d null;\n         } else {\n           curNode \u003d s.getRoot();\n           existing.setSnapshot(s);\n         }\n         if (index \u003e\u003d -1) {\n           existing.snapshotRootIndex \u003d existing.numNonNull;\n         }\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n         curNode \u003d dir.getChild(childName, existing.getPathSnapshot());\n       }\n       count++;\n       index++;\n     }\n     return existing;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final int numOfINodes, \n      final boolean resolveLink) throws UnresolvedLinkException {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n    int count \u003d 0;\n    int index \u003d numOfINodes - components.length;\n    if (index \u003e 0) {\n      index \u003d 0;\n    }\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n      if (index \u003e\u003d 0) {\n        existing.addNode(curNode);\n      }\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir.isWithSnapshot()) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!existing.isSnapshot()) {\n          existing.updateLatestSnapshot(dir.getDirectoryWithSnapshotFeature()\n              .getLastSnapshot());\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!existing.isSnapshot()) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          Snapshot latest \u003d existing.getLatestSnapshot();\n          if (latest \u003d\u003d null ||  // no snapshot in dst tree of rename\n              dstSnapshotId \u003e\u003d latest.getId()) { // the above scenario \n            Snapshot lastSnapshot \u003d null;\n            DirectoryWithSnapshotFeature sf \u003d null;\n            if (curNode.isDirectory() \u0026\u0026 \n                (sf \u003d curNode.asDirectory().getDirectoryWithSnapshotFeature()) !\u003d null) {\n              lastSnapshot \u003d sf.getLastSnapshot();\n            }\n            existing.setSnapshot(lastSnapshot);\n          }\n        }\n      }\n      if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n        final String path \u003d constructPath(components, 0, components.length);\n        final String preceding \u003d constructPath(components, 0, count);\n        final String remainder \u003d\n          constructPath(components, count + 1, components.length);\n        final String link \u003d DFSUtil.bytes2String(components[count]);\n        final String target \u003d curNode.asSymlink().getSymlinkString();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UnresolvedPathException \" +\n            \" path: \" + path + \" preceding: \" + preceding +\n            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n            \" remainder: \" + remainder);\n        }\n        throw new UnresolvedPathException(path, preceding, remainder, target);\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n      final byte[] childName \u003d components[count + 1];\n      \n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName)\n          \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectorySnapshottable) {\n        // skip the \".snapshot\" in components\n        count++;\n        index++;\n        existing.isSnapshot \u003d true;\n        if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n          existing.capacity--;\n        }\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d ((INodeDirectorySnapshottable)dir).getSnapshot(\n            components[count + 1]);\n        if (s \u003d\u003d null) {\n          //snapshot not found\n          curNode \u003d null;\n        } else {\n          curNode \u003d s.getRoot();\n          existing.setSnapshot(s);\n        }\n        if (index \u003e\u003d -1) {\n          existing.snapshotRootIndex \u003d existing.numNonNull;\n        }\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName, existing.getPathSnapshot());\n      }\n      count++;\n      index++;\n    }\n    return existing;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
      "extendedDetails": {}
    },
    "496b80b28c35dbd52d3d919d16f4c75983f81a79": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4850. Fix OfflineImageViewer to work on fsimages with empty files or snapshots. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490080 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/06/13 4:32 PM",
      "commitName": "496b80b28c35dbd52d3d919d16f4c75983f81a79",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "30/04/13 2:05 PM",
      "commitNameOld": "3a3e0f573129c8308332d4b301a9319ee579d85a",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 36.1,
      "commitsBetweenForRepo": 210,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,108 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n       final byte[][] components, final int numOfINodes, \n       final boolean resolveLink) throws UnresolvedLinkException {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n     final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n     int count \u003d 0;\n     int index \u003d numOfINodes - components.length;\n     if (index \u003e 0) {\n       index \u003d 0;\n     }\n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n       final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n       if (index \u003e\u003d 0) {\n         existing.addNode(curNode);\n       }\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n       final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n       if (!isRef \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectoryWithSnapshot) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n         if (!existing.isSnapshot()) {\n           existing.updateLatestSnapshot(\n               ((INodeDirectoryWithSnapshot)dir).getLastSnapshot());\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n         if (!existing.isSnapshot()) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n           Snapshot latest \u003d existing.getLatestSnapshot();\n           if (latest \u003d\u003d null ||  // no snapshot in dst tree of rename\n               dstSnapshotId \u003e\u003d latest.getId()) { // the above scenario \n             Snapshot lastSnapshot \u003d null;\n             if (curNode.isDirectory()\n                 \u0026\u0026 curNode.asDirectory() instanceof INodeDirectoryWithSnapshot) {\n               lastSnapshot \u003d ((INodeDirectoryWithSnapshot) curNode\n                   .asDirectory()).getLastSnapshot();\n             }\n             existing.setSnapshot(lastSnapshot);\n           }\n         }\n       }\n       if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n         final String path \u003d constructPath(components, 0, components.length);\n         final String preceding \u003d constructPath(components, 0, count);\n         final String remainder \u003d\n           constructPath(components, count + 1, components.length);\n         final String link \u003d DFSUtil.bytes2String(components[count]);\n         final String target \u003d curNode.asSymlink().getSymlinkString();\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UnresolvedPathException \" +\n             \" path: \" + path + \" preceding: \" + preceding +\n             \" count: \" + count + \" link: \" + link + \" target: \" + target +\n             \" remainder: \" + remainder);\n         }\n         throw new UnresolvedPathException(path, preceding, remainder, target);\n       }\n       if (lastComp || !isDir) {\n         break;\n       }\n       final byte[] childName \u003d components[count + 1];\n       \n       // check if the next byte[] in components is for \".snapshot\"\n       if (isDotSnapshotDir(childName)\n-          \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectoryWithSnapshot) {\n+          \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectorySnapshottable) {\n         // skip the \".snapshot\" in components\n         count++;\n         index++;\n         existing.isSnapshot \u003d true;\n         if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n           existing.capacity--;\n         }\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n         final Snapshot s \u003d ((INodeDirectorySnapshottable)dir).getSnapshot(\n             components[count + 1]);\n         if (s \u003d\u003d null) {\n           //snapshot not found\n           curNode \u003d null;\n         } else {\n           curNode \u003d s.getRoot();\n           existing.setSnapshot(s);\n         }\n         if (index \u003e\u003d -1) {\n           existing.snapshotRootIndex \u003d existing.numNonNull;\n         }\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n         curNode \u003d dir.getChild(childName, existing.getPathSnapshot());\n       }\n       count++;\n       index++;\n     }\n     return existing;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final int numOfINodes, \n      final boolean resolveLink) throws UnresolvedLinkException {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n    int count \u003d 0;\n    int index \u003d numOfINodes - components.length;\n    if (index \u003e 0) {\n      index \u003d 0;\n    }\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n      if (index \u003e\u003d 0) {\n        existing.addNode(curNode);\n      }\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectoryWithSnapshot) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!existing.isSnapshot()) {\n          existing.updateLatestSnapshot(\n              ((INodeDirectoryWithSnapshot)dir).getLastSnapshot());\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!existing.isSnapshot()) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          Snapshot latest \u003d existing.getLatestSnapshot();\n          if (latest \u003d\u003d null ||  // no snapshot in dst tree of rename\n              dstSnapshotId \u003e\u003d latest.getId()) { // the above scenario \n            Snapshot lastSnapshot \u003d null;\n            if (curNode.isDirectory()\n                \u0026\u0026 curNode.asDirectory() instanceof INodeDirectoryWithSnapshot) {\n              lastSnapshot \u003d ((INodeDirectoryWithSnapshot) curNode\n                  .asDirectory()).getLastSnapshot();\n            }\n            existing.setSnapshot(lastSnapshot);\n          }\n        }\n      }\n      if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n        final String path \u003d constructPath(components, 0, components.length);\n        final String preceding \u003d constructPath(components, 0, count);\n        final String remainder \u003d\n          constructPath(components, count + 1, components.length);\n        final String link \u003d DFSUtil.bytes2String(components[count]);\n        final String target \u003d curNode.asSymlink().getSymlinkString();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UnresolvedPathException \" +\n            \" path: \" + path + \" preceding: \" + preceding +\n            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n            \" remainder: \" + remainder);\n        }\n        throw new UnresolvedPathException(path, preceding, remainder, target);\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n      final byte[] childName \u003d components[count + 1];\n      \n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName)\n          \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectorySnapshottable) {\n        // skip the \".snapshot\" in components\n        count++;\n        index++;\n        existing.isSnapshot \u003d true;\n        if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n          existing.capacity--;\n        }\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d ((INodeDirectorySnapshottable)dir).getSnapshot(\n            components[count + 1]);\n        if (s \u003d\u003d null) {\n          //snapshot not found\n          curNode \u003d null;\n        } else {\n          curNode \u003d s.getRoot();\n          existing.setSnapshot(s);\n        }\n        if (index \u003e\u003d -1) {\n          existing.snapshotRootIndex \u003d existing.numNonNull;\n        }\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName, existing.getPathSnapshot());\n      }\n      count++;\n      index++;\n    }\n    return existing;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
      "extendedDetails": {}
    },
    "3a3e0f573129c8308332d4b301a9319ee579d85a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4760. Update inodeMap after node replacement.  Contributed by Jing Zhao\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1477827 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/04/13 2:05 PM",
      "commitName": "3a3e0f573129c8308332d4b301a9319ee579d85a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "16/04/13 7:41 PM",
      "commitNameOld": "9280468b1acfa346250d0212b5cb7486dc83705c",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 13.77,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,108 @@\n   static INodesInPath resolve(final INodeDirectory startingDir,\n       final byte[][] components, final int numOfINodes, \n       final boolean resolveLink) throws UnresolvedLinkException {\n     Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n \n     INode curNode \u003d startingDir;\n     final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n     int count \u003d 0;\n     int index \u003d numOfINodes - components.length;\n     if (index \u003e 0) {\n       index \u003d 0;\n     }\n     while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n       final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n       if (index \u003e\u003d 0) {\n         existing.addNode(curNode);\n       }\n       final boolean isRef \u003d curNode.isReference();\n       final boolean isDir \u003d curNode.isDirectory();\n       final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n       if (!isRef \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectoryWithSnapshot) {\n         //if the path is a non-snapshot path, update the latest snapshot.\n         if (!existing.isSnapshot()) {\n           existing.updateLatestSnapshot(\n               ((INodeDirectoryWithSnapshot)dir).getLastSnapshot());\n         }\n       } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n         // If the curNode is a reference node, need to check its dstSnapshot:\n         // 1. if the existing snapshot is no later than the dstSnapshot (which\n         // is the latest snapshot in dst before the rename), the changes \n         // should be recorded in previous snapshots (belonging to src).\n         // 2. however, if the ref node is already the last component, we still \n         // need to know the latest snapshot among the ref node\u0027s ancestors, \n         // in case of processing a deletion operation. Thus we do not overwrite\n         // the latest snapshot if lastComp is true. In case of the operation is\n         // a modification operation, we do a similar check in corresponding \n         // recordModification method.\n         if (!existing.isSnapshot()) {\n           int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n           Snapshot latest \u003d existing.getLatestSnapshot();\n           if (latest \u003d\u003d null ||  // no snapshot in dst tree of rename\n               dstSnapshotId \u003e\u003d latest.getId()) { // the above scenario \n             Snapshot lastSnapshot \u003d null;\n             if (curNode.isDirectory()\n                 \u0026\u0026 curNode.asDirectory() instanceof INodeDirectoryWithSnapshot) {\n               lastSnapshot \u003d ((INodeDirectoryWithSnapshot) curNode\n                   .asDirectory()).getLastSnapshot();\n-            } else if (curNode.isFile()\n-                \u0026\u0026 curNode.asFile() instanceof INodeFileWithSnapshot) {\n-              lastSnapshot \u003d ((INodeFileWithSnapshot) curNode\n-                  .asFile()).getDiffs().getLastSnapshot();\n             }\n             existing.setSnapshot(lastSnapshot);\n           }\n         }\n       }\n       if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n         final String path \u003d constructPath(components, 0, components.length);\n         final String preceding \u003d constructPath(components, 0, count);\n         final String remainder \u003d\n           constructPath(components, count + 1, components.length);\n         final String link \u003d DFSUtil.bytes2String(components[count]);\n         final String target \u003d curNode.asSymlink().getSymlinkString();\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"UnresolvedPathException \" +\n             \" path: \" + path + \" preceding: \" + preceding +\n             \" count: \" + count + \" link: \" + link + \" target: \" + target +\n             \" remainder: \" + remainder);\n         }\n         throw new UnresolvedPathException(path, preceding, remainder, target);\n       }\n       if (lastComp || !isDir) {\n         break;\n       }\n       final byte[] childName \u003d components[count + 1];\n       \n       // check if the next byte[] in components is for \".snapshot\"\n       if (isDotSnapshotDir(childName)\n           \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectoryWithSnapshot) {\n         // skip the \".snapshot\" in components\n         count++;\n         index++;\n         existing.isSnapshot \u003d true;\n         if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n           existing.capacity--;\n         }\n         // check if \".snapshot\" is the last element of components\n         if (count \u003d\u003d components.length - 1) {\n           break;\n         }\n         // Resolve snapshot root\n         final Snapshot s \u003d ((INodeDirectorySnapshottable)dir).getSnapshot(\n             components[count + 1]);\n         if (s \u003d\u003d null) {\n           //snapshot not found\n           curNode \u003d null;\n         } else {\n           curNode \u003d s.getRoot();\n           existing.setSnapshot(s);\n         }\n         if (index \u003e\u003d -1) {\n           existing.snapshotRootIndex \u003d existing.numNonNull;\n         }\n       } else {\n         // normal case, and also for resolving file/dir under snapshot root\n         curNode \u003d dir.getChild(childName, existing.getPathSnapshot());\n       }\n       count++;\n       index++;\n     }\n     return existing;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final int numOfINodes, \n      final boolean resolveLink) throws UnresolvedLinkException {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n    int count \u003d 0;\n    int index \u003d numOfINodes - components.length;\n    if (index \u003e 0) {\n      index \u003d 0;\n    }\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n      if (index \u003e\u003d 0) {\n        existing.addNode(curNode);\n      }\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectoryWithSnapshot) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!existing.isSnapshot()) {\n          existing.updateLatestSnapshot(\n              ((INodeDirectoryWithSnapshot)dir).getLastSnapshot());\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!existing.isSnapshot()) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          Snapshot latest \u003d existing.getLatestSnapshot();\n          if (latest \u003d\u003d null ||  // no snapshot in dst tree of rename\n              dstSnapshotId \u003e\u003d latest.getId()) { // the above scenario \n            Snapshot lastSnapshot \u003d null;\n            if (curNode.isDirectory()\n                \u0026\u0026 curNode.asDirectory() instanceof INodeDirectoryWithSnapshot) {\n              lastSnapshot \u003d ((INodeDirectoryWithSnapshot) curNode\n                  .asDirectory()).getLastSnapshot();\n            }\n            existing.setSnapshot(lastSnapshot);\n          }\n        }\n      }\n      if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n        final String path \u003d constructPath(components, 0, components.length);\n        final String preceding \u003d constructPath(components, 0, count);\n        final String remainder \u003d\n          constructPath(components, count + 1, components.length);\n        final String link \u003d DFSUtil.bytes2String(components[count]);\n        final String target \u003d curNode.asSymlink().getSymlinkString();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UnresolvedPathException \" +\n            \" path: \" + path + \" preceding: \" + preceding +\n            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n            \" remainder: \" + remainder);\n        }\n        throw new UnresolvedPathException(path, preceding, remainder, target);\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n      final byte[] childName \u003d components[count + 1];\n      \n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName)\n          \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectoryWithSnapshot) {\n        // skip the \".snapshot\" in components\n        count++;\n        index++;\n        existing.isSnapshot \u003d true;\n        if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n          existing.capacity--;\n        }\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d ((INodeDirectorySnapshottable)dir).getSnapshot(\n            components[count + 1]);\n        if (s \u003d\u003d null) {\n          //snapshot not found\n          curNode \u003d null;\n        } else {\n          curNode \u003d s.getRoot();\n          existing.setSnapshot(s);\n        }\n        if (index \u003e\u003d -1) {\n          existing.snapshotRootIndex \u003d existing.numNonNull;\n        }\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName, existing.getPathSnapshot());\n      }\n      count++;\n      index++;\n    }\n    return existing;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java",
      "extendedDetails": {}
    },
    "9280468b1acfa346250d0212b5cb7486dc83705c": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-4550. Refactor INodeDirectory.INodesInPath to a standalone class.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2802@1468725 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/04/13 7:41 PM",
      "commitName": "9280468b1acfa346250d0212b5cb7486dc83705c",
      "commitAuthor": "Tsz-wo Sze",
      "diff": "@@ -0,0 +1,112 @@\n+  static INodesInPath resolve(final INodeDirectory startingDir,\n+      final byte[][] components, final int numOfINodes, \n+      final boolean resolveLink) throws UnresolvedLinkException {\n+    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n+\n+    INode curNode \u003d startingDir;\n+    final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n+    int count \u003d 0;\n+    int index \u003d numOfINodes - components.length;\n+    if (index \u003e 0) {\n+      index \u003d 0;\n+    }\n+    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n+      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n+      if (index \u003e\u003d 0) {\n+        existing.addNode(curNode);\n+      }\n+      final boolean isRef \u003d curNode.isReference();\n+      final boolean isDir \u003d curNode.isDirectory();\n+      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n+      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectoryWithSnapshot) {\n+        //if the path is a non-snapshot path, update the latest snapshot.\n+        if (!existing.isSnapshot()) {\n+          existing.updateLatestSnapshot(\n+              ((INodeDirectoryWithSnapshot)dir).getLastSnapshot());\n+        }\n+      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n+        // If the curNode is a reference node, need to check its dstSnapshot:\n+        // 1. if the existing snapshot is no later than the dstSnapshot (which\n+        // is the latest snapshot in dst before the rename), the changes \n+        // should be recorded in previous snapshots (belonging to src).\n+        // 2. however, if the ref node is already the last component, we still \n+        // need to know the latest snapshot among the ref node\u0027s ancestors, \n+        // in case of processing a deletion operation. Thus we do not overwrite\n+        // the latest snapshot if lastComp is true. In case of the operation is\n+        // a modification operation, we do a similar check in corresponding \n+        // recordModification method.\n+        if (!existing.isSnapshot()) {\n+          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n+          Snapshot latest \u003d existing.getLatestSnapshot();\n+          if (latest \u003d\u003d null ||  // no snapshot in dst tree of rename\n+              dstSnapshotId \u003e\u003d latest.getId()) { // the above scenario \n+            Snapshot lastSnapshot \u003d null;\n+            if (curNode.isDirectory()\n+                \u0026\u0026 curNode.asDirectory() instanceof INodeDirectoryWithSnapshot) {\n+              lastSnapshot \u003d ((INodeDirectoryWithSnapshot) curNode\n+                  .asDirectory()).getLastSnapshot();\n+            } else if (curNode.isFile()\n+                \u0026\u0026 curNode.asFile() instanceof INodeFileWithSnapshot) {\n+              lastSnapshot \u003d ((INodeFileWithSnapshot) curNode\n+                  .asFile()).getDiffs().getLastSnapshot();\n+            }\n+            existing.setSnapshot(lastSnapshot);\n+          }\n+        }\n+      }\n+      if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n+        final String path \u003d constructPath(components, 0, components.length);\n+        final String preceding \u003d constructPath(components, 0, count);\n+        final String remainder \u003d\n+          constructPath(components, count + 1, components.length);\n+        final String link \u003d DFSUtil.bytes2String(components[count]);\n+        final String target \u003d curNode.asSymlink().getSymlinkString();\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"UnresolvedPathException \" +\n+            \" path: \" + path + \" preceding: \" + preceding +\n+            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n+            \" remainder: \" + remainder);\n+        }\n+        throw new UnresolvedPathException(path, preceding, remainder, target);\n+      }\n+      if (lastComp || !isDir) {\n+        break;\n+      }\n+      final byte[] childName \u003d components[count + 1];\n+      \n+      // check if the next byte[] in components is for \".snapshot\"\n+      if (isDotSnapshotDir(childName)\n+          \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectoryWithSnapshot) {\n+        // skip the \".snapshot\" in components\n+        count++;\n+        index++;\n+        existing.isSnapshot \u003d true;\n+        if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n+          existing.capacity--;\n+        }\n+        // check if \".snapshot\" is the last element of components\n+        if (count \u003d\u003d components.length - 1) {\n+          break;\n+        }\n+        // Resolve snapshot root\n+        final Snapshot s \u003d ((INodeDirectorySnapshottable)dir).getSnapshot(\n+            components[count + 1]);\n+        if (s \u003d\u003d null) {\n+          //snapshot not found\n+          curNode \u003d null;\n+        } else {\n+          curNode \u003d s.getRoot();\n+          existing.setSnapshot(s);\n+        }\n+        if (index \u003e\u003d -1) {\n+          existing.snapshotRootIndex \u003d existing.numNonNull;\n+        }\n+      } else {\n+        // normal case, and also for resolving file/dir under snapshot root\n+        curNode \u003d dir.getChild(childName, existing.getPathSnapshot());\n+      }\n+      count++;\n+      index++;\n+    }\n+    return existing;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  static INodesInPath resolve(final INodeDirectory startingDir,\n      final byte[][] components, final int numOfINodes, \n      final boolean resolveLink) throws UnresolvedLinkException {\n    Preconditions.checkArgument(startingDir.compareTo(components[0]) \u003d\u003d 0);\n\n    INode curNode \u003d startingDir;\n    final INodesInPath existing \u003d new INodesInPath(components, numOfINodes);\n    int count \u003d 0;\n    int index \u003d numOfINodes - components.length;\n    if (index \u003e 0) {\n      index \u003d 0;\n    }\n    while (count \u003c components.length \u0026\u0026 curNode !\u003d null) {\n      final boolean lastComp \u003d (count \u003d\u003d components.length - 1);      \n      if (index \u003e\u003d 0) {\n        existing.addNode(curNode);\n      }\n      final boolean isRef \u003d curNode.isReference();\n      final boolean isDir \u003d curNode.isDirectory();\n      final INodeDirectory dir \u003d isDir? curNode.asDirectory(): null;  \n      if (!isRef \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectoryWithSnapshot) {\n        //if the path is a non-snapshot path, update the latest snapshot.\n        if (!existing.isSnapshot()) {\n          existing.updateLatestSnapshot(\n              ((INodeDirectoryWithSnapshot)dir).getLastSnapshot());\n        }\n      } else if (isRef \u0026\u0026 isDir \u0026\u0026 !lastComp) {\n        // If the curNode is a reference node, need to check its dstSnapshot:\n        // 1. if the existing snapshot is no later than the dstSnapshot (which\n        // is the latest snapshot in dst before the rename), the changes \n        // should be recorded in previous snapshots (belonging to src).\n        // 2. however, if the ref node is already the last component, we still \n        // need to know the latest snapshot among the ref node\u0027s ancestors, \n        // in case of processing a deletion operation. Thus we do not overwrite\n        // the latest snapshot if lastComp is true. In case of the operation is\n        // a modification operation, we do a similar check in corresponding \n        // recordModification method.\n        if (!existing.isSnapshot()) {\n          int dstSnapshotId \u003d curNode.asReference().getDstSnapshotId();\n          Snapshot latest \u003d existing.getLatestSnapshot();\n          if (latest \u003d\u003d null ||  // no snapshot in dst tree of rename\n              dstSnapshotId \u003e\u003d latest.getId()) { // the above scenario \n            Snapshot lastSnapshot \u003d null;\n            if (curNode.isDirectory()\n                \u0026\u0026 curNode.asDirectory() instanceof INodeDirectoryWithSnapshot) {\n              lastSnapshot \u003d ((INodeDirectoryWithSnapshot) curNode\n                  .asDirectory()).getLastSnapshot();\n            } else if (curNode.isFile()\n                \u0026\u0026 curNode.asFile() instanceof INodeFileWithSnapshot) {\n              lastSnapshot \u003d ((INodeFileWithSnapshot) curNode\n                  .asFile()).getDiffs().getLastSnapshot();\n            }\n            existing.setSnapshot(lastSnapshot);\n          }\n        }\n      }\n      if (curNode.isSymlink() \u0026\u0026 (!lastComp || (lastComp \u0026\u0026 resolveLink))) {\n        final String path \u003d constructPath(components, 0, components.length);\n        final String preceding \u003d constructPath(components, 0, count);\n        final String remainder \u003d\n          constructPath(components, count + 1, components.length);\n        final String link \u003d DFSUtil.bytes2String(components[count]);\n        final String target \u003d curNode.asSymlink().getSymlinkString();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"UnresolvedPathException \" +\n            \" path: \" + path + \" preceding: \" + preceding +\n            \" count: \" + count + \" link: \" + link + \" target: \" + target +\n            \" remainder: \" + remainder);\n        }\n        throw new UnresolvedPathException(path, preceding, remainder, target);\n      }\n      if (lastComp || !isDir) {\n        break;\n      }\n      final byte[] childName \u003d components[count + 1];\n      \n      // check if the next byte[] in components is for \".snapshot\"\n      if (isDotSnapshotDir(childName)\n          \u0026\u0026 isDir \u0026\u0026 dir instanceof INodeDirectoryWithSnapshot) {\n        // skip the \".snapshot\" in components\n        count++;\n        index++;\n        existing.isSnapshot \u003d true;\n        if (index \u003e\u003d 0) { // decrease the capacity by 1 to account for .snapshot\n          existing.capacity--;\n        }\n        // check if \".snapshot\" is the last element of components\n        if (count \u003d\u003d components.length - 1) {\n          break;\n        }\n        // Resolve snapshot root\n        final Snapshot s \u003d ((INodeDirectorySnapshottable)dir).getSnapshot(\n            components[count + 1]);\n        if (s \u003d\u003d null) {\n          //snapshot not found\n          curNode \u003d null;\n        } else {\n          curNode \u003d s.getRoot();\n          existing.setSnapshot(s);\n        }\n        if (index \u003e\u003d -1) {\n          existing.snapshotRootIndex \u003d existing.numNonNull;\n        }\n      } else {\n        // normal case, and also for resolving file/dir under snapshot root\n        curNode \u003d dir.getChild(childName, existing.getPathSnapshot());\n      }\n      count++;\n      index++;\n    }\n    return existing;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodesInPath.java"
    }
  }
}