{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FsDatasetImpl.java",
  "functionName": "moveBlockAcrossStorage",
  "functionId": "moveBlockAcrossStorage___block-ExtendedBlock__targetStorageType-StorageType__targetStorageId-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
  "functionStartLine": 1001,
  "functionEndLine": 1041,
  "numCommitsSeen": 352,
  "timeTaken": 11702,
  "changeHistory": [
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
    "a3954ccab148bddc290cb96528e63ff19799bcc9",
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
    "7820737cfa178d9de1bcbb1e99b9677d70901914",
    "342c9572bf6a623287f34c5cc0bc3be6038c191a",
    "14255786908f991fd2022480fe5575533a3dc7ce",
    "c992bcf9c136d3df686655a80e636bb7bb0664da",
    "4da8490b512a33a255ed27309860859388d7c168",
    "6e62a1a6728b1f782f64065424f92b292c3f163a",
    "c0af72c7f74b6925786e24543cac433b906dd6d3",
    "b7f4a3156c0f5c600816c469637237ba6c9b330c",
    "058af60c56207907f2bedf76df4284e86d923e0c"
  ],
  "changeHistoryShort": {
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8": "Ybodychange",
    "a3954ccab148bddc290cb96528e63ff19799bcc9": "Ymultichange(Yparameterchange,Ybodychange)",
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c": "Ybodychange",
    "7820737cfa178d9de1bcbb1e99b9677d70901914": "Ybodychange",
    "342c9572bf6a623287f34c5cc0bc3be6038c191a": "Ybodychange",
    "14255786908f991fd2022480fe5575533a3dc7ce": "Ybodychange",
    "c992bcf9c136d3df686655a80e636bb7bb0664da": "Ybodychange",
    "4da8490b512a33a255ed27309860859388d7c168": "Ybodychange",
    "6e62a1a6728b1f782f64065424f92b292c3f163a": "Ybodychange",
    "c0af72c7f74b6925786e24543cac433b906dd6d3": "Ybodychange",
    "b7f4a3156c0f5c600816c469637237ba6c9b330c": "Ybodychange",
    "058af60c56207907f2bedf76df4284e86d923e0c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15150. Introduce read write lock to Datanode. Contributed Stephen O\u0027Donnell.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "11/02/20 8:00 AM",
      "commitName": "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
      "commitAuthor": "Stephen O\u0027Donnell",
      "commitDateOld": "28/01/20 10:10 AM",
      "commitNameOld": "1839c467f60cbb8592d446694ec3d7710cda5142",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 13.91,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n       StorageType targetStorageType, String targetStorageId)\n       throws IOException {\n     ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n     if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n       throw new ReplicaNotFoundException(\n           ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n     }\n     if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n       throw new IOException(\"Corrupted replica \" + replicaInfo\n           + \" with a length of \" + replicaInfo.getNumBytes()\n           + \" expected length is \" + block.getNumBytes());\n     }\n     if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n       throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n           + \" already exists on storage \" + targetStorageType);\n     }\n \n     if (replicaInfo.isOnTransientStorage()) {\n       // Block movement from RAM_DISK will be done by LazyPersist mechanism\n       throw new IOException(\"Replica \" + replicaInfo\n           + \" cannot be moved from storageType : \"\n           + replicaInfo.getVolume().getStorageType());\n     }\n \n     FsVolumeReference volumeRef \u003d null;\n-    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n+    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n       volumeRef \u003d volumes.getNextVolume(targetStorageType, targetStorageId,\n           block.getNumBytes());\n     }\n     try {\n       moveBlock(block, replicaInfo, volumeRef);\n     } finally {\n       if (volumeRef !\u003d null) {\n         volumeRef.close();\n       }\n     }\n \n     // Replace the old block if any to reschedule the scanning.\n     return replicaInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType, String targetStorageId)\n      throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    FsVolumeReference volumeRef \u003d null;\n    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n      volumeRef \u003d volumes.getNextVolume(targetStorageType, targetStorageId,\n          block.getNumBytes());\n    }\n    try {\n      moveBlock(block, replicaInfo, volumeRef);\n    } finally {\n      if (volumeRef !\u003d null) {\n        volumeRef.close();\n      }\n    }\n\n    // Replace the old block if any to reschedule the scanning.\n    return replicaInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "a3954ccab148bddc290cb96528e63ff19799bcc9": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
      "commitDate": "05/05/17 12:01 PM",
      "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
      "commitAuthor": "Chris Douglas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
          "commitDate": "05/05/17 12:01 PM",
          "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "10/03/17 2:37 PM",
          "commitNameOld": "6d356b6b4d8ccb32397cacfb5d0357b21f6035fc",
          "commitAuthorOld": "Lei Xu",
          "daysBetweenCommits": 55.85,
          "commitsBetweenForRepo": 315,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,41 @@\n   public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n-      StorageType targetStorageType) throws IOException {\n+      StorageType targetStorageType, String targetStorageId)\n+      throws IOException {\n     ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n     if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n       throw new ReplicaNotFoundException(\n           ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n     }\n     if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n       throw new IOException(\"Corrupted replica \" + replicaInfo\n           + \" with a length of \" + replicaInfo.getNumBytes()\n           + \" expected length is \" + block.getNumBytes());\n     }\n     if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n       throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n           + \" already exists on storage \" + targetStorageType);\n     }\n \n     if (replicaInfo.isOnTransientStorage()) {\n       // Block movement from RAM_DISK will be done by LazyPersist mechanism\n       throw new IOException(\"Replica \" + replicaInfo\n           + \" cannot be moved from storageType : \"\n           + replicaInfo.getVolume().getStorageType());\n     }\n \n     FsVolumeReference volumeRef \u003d null;\n     try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n-      volumeRef \u003d volumes.getNextVolume(targetStorageType, block.getNumBytes());\n+      volumeRef \u003d volumes.getNextVolume(targetStorageType, targetStorageId,\n+          block.getNumBytes());\n     }\n     try {\n       moveBlock(block, replicaInfo, volumeRef);\n     } finally {\n       if (volumeRef !\u003d null) {\n         volumeRef.close();\n       }\n     }\n \n     // Replace the old block if any to reschedule the scanning.\n     return replicaInfo;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType, String targetStorageId)\n      throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    FsVolumeReference volumeRef \u003d null;\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      volumeRef \u003d volumes.getNextVolume(targetStorageType, targetStorageId,\n          block.getNumBytes());\n    }\n    try {\n      moveBlock(block, replicaInfo, volumeRef);\n    } finally {\n      if (volumeRef !\u003d null) {\n        volumeRef.close();\n      }\n    }\n\n    // Replace the old block if any to reschedule the scanning.\n    return replicaInfo;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldValue": "[block-ExtendedBlock, targetStorageType-StorageType]",
            "newValue": "[block-ExtendedBlock, targetStorageType-StorageType, targetStorageId-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
          "commitDate": "05/05/17 12:01 PM",
          "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "10/03/17 2:37 PM",
          "commitNameOld": "6d356b6b4d8ccb32397cacfb5d0357b21f6035fc",
          "commitAuthorOld": "Lei Xu",
          "daysBetweenCommits": 55.85,
          "commitsBetweenForRepo": 315,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,41 @@\n   public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n-      StorageType targetStorageType) throws IOException {\n+      StorageType targetStorageType, String targetStorageId)\n+      throws IOException {\n     ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n     if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n       throw new ReplicaNotFoundException(\n           ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n     }\n     if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n       throw new IOException(\"Corrupted replica \" + replicaInfo\n           + \" with a length of \" + replicaInfo.getNumBytes()\n           + \" expected length is \" + block.getNumBytes());\n     }\n     if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n       throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n           + \" already exists on storage \" + targetStorageType);\n     }\n \n     if (replicaInfo.isOnTransientStorage()) {\n       // Block movement from RAM_DISK will be done by LazyPersist mechanism\n       throw new IOException(\"Replica \" + replicaInfo\n           + \" cannot be moved from storageType : \"\n           + replicaInfo.getVolume().getStorageType());\n     }\n \n     FsVolumeReference volumeRef \u003d null;\n     try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n-      volumeRef \u003d volumes.getNextVolume(targetStorageType, block.getNumBytes());\n+      volumeRef \u003d volumes.getNextVolume(targetStorageType, targetStorageId,\n+          block.getNumBytes());\n     }\n     try {\n       moveBlock(block, replicaInfo, volumeRef);\n     } finally {\n       if (volumeRef !\u003d null) {\n         volumeRef.close();\n       }\n     }\n \n     // Replace the old block if any to reschedule the scanning.\n     return replicaInfo;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType, String targetStorageId)\n      throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    FsVolumeReference volumeRef \u003d null;\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      volumeRef \u003d volumes.getNextVolume(targetStorageType, targetStorageId,\n          block.getNumBytes());\n    }\n    try {\n      moveBlock(block, replicaInfo, volumeRef);\n    } finally {\n      if (volumeRef !\u003d null) {\n        volumeRef.close();\n      }\n    }\n\n    // Replace the old block if any to reschedule the scanning.\n    return replicaInfo;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10682. Replace FsDatasetImpl object lock with a separate lock object. (Chen Liang)\n",
      "commitDate": "08/08/16 12:02 PM",
      "commitName": "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "08/07/16 7:40 PM",
      "commitNameOld": "da6f1b88dd47e22b24d44f6fc8bbee73e85746f7",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 30.68,
      "commitsBetweenForRepo": 320,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n       StorageType targetStorageType) throws IOException {\n     ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n     if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n       throw new ReplicaNotFoundException(\n           ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n     }\n     if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n       throw new IOException(\"Corrupted replica \" + replicaInfo\n           + \" with a length of \" + replicaInfo.getNumBytes()\n           + \" expected length is \" + block.getNumBytes());\n     }\n     if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n       throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n           + \" already exists on storage \" + targetStorageType);\n     }\n \n     if (replicaInfo.isOnTransientStorage()) {\n       // Block movement from RAM_DISK will be done by LazyPersist mechanism\n       throw new IOException(\"Replica \" + replicaInfo\n           + \" cannot be moved from storageType : \"\n           + replicaInfo.getVolume().getStorageType());\n     }\n \n     FsVolumeReference volumeRef \u003d null;\n-    synchronized (this) {\n+    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       volumeRef \u003d volumes.getNextVolume(targetStorageType, block.getNumBytes());\n     }\n     try {\n       moveBlock(block, replicaInfo, volumeRef);\n     } finally {\n       if (volumeRef !\u003d null) {\n         volumeRef.close();\n       }\n     }\n \n     // Replace the old block if any to reschedule the scanning.\n     return replicaInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType) throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    FsVolumeReference volumeRef \u003d null;\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      volumeRef \u003d volumes.getNextVolume(targetStorageType, block.getNumBytes());\n    }\n    try {\n      moveBlock(block, replicaInfo, volumeRef);\n    } finally {\n      if (volumeRef !\u003d null) {\n        volumeRef.close();\n      }\n    }\n\n    // Replace the old block if any to reschedule the scanning.\n    return replicaInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "7820737cfa178d9de1bcbb1e99b9677d70901914": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9735. DiskBalancer : Refactor moveBlockAcrossStorage to be used by disk balancer. Contributed by Anu Engineer.\n",
      "commitDate": "23/06/16 6:20 PM",
      "commitName": "7820737cfa178d9de1bcbb1e99b9677d70901914",
      "commitAuthor": "Anu Engineer",
      "commitDateOld": "21/06/16 3:12 AM",
      "commitNameOld": "f2ac132d6a21c215093b7f87acf2843ac8123716",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 2.63,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,39 @@\n   public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n       StorageType targetStorageType) throws IOException {\n     ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n     if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n       throw new ReplicaNotFoundException(\n           ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n     }\n     if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n       throw new IOException(\"Corrupted replica \" + replicaInfo\n           + \" with a length of \" + replicaInfo.getNumBytes()\n           + \" expected length is \" + block.getNumBytes());\n     }\n     if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n       throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n           + \" already exists on storage \" + targetStorageType);\n     }\n \n     if (replicaInfo.isOnTransientStorage()) {\n       // Block movement from RAM_DISK will be done by LazyPersist mechanism\n       throw new IOException(\"Replica \" + replicaInfo\n           + \" cannot be moved from storageType : \"\n           + replicaInfo.getVolume().getStorageType());\n     }\n \n     FsVolumeReference volumeRef \u003d null;\n     synchronized (this) {\n       volumeRef \u003d volumes.getNextVolume(targetStorageType, block.getNumBytes());\n     }\n     try {\n-      File oldBlockFile \u003d replicaInfo.getBlockFile();\n-      File oldMetaFile \u003d replicaInfo.getMetaFile();\n-      FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n-      // Copy files to temp dir first\n-      File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n-          block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n-          targetVolume.getTmpDir(block.getBlockPoolId()),\n-          replicaInfo.isOnTransientStorage(), smallBufferSize, conf);\n-\n-      ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n-          replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n-          targetVolume, blockFiles[0].getParentFile(), 0);\n-      newReplicaInfo.setNumBytes(blockFiles[1].length());\n-      // Finalize the copied files\n-      newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n-      synchronized (this) {\n-        // Increment numBlocks here as this block moved without knowing to BPS\n-        FsVolumeImpl volume \u003d (FsVolumeImpl) newReplicaInfo.getVolume();\n-        volume.getBlockPoolSlice(block.getBlockPoolId()).incrNumBlocks();\n-      }\n-\n-      removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n-          oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n+      moveBlock(block, replicaInfo, volumeRef);\n     } finally {\n       if (volumeRef !\u003d null) {\n         volumeRef.close();\n       }\n     }\n \n     // Replace the old block if any to reschedule the scanning.\n     return replicaInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType) throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    FsVolumeReference volumeRef \u003d null;\n    synchronized (this) {\n      volumeRef \u003d volumes.getNextVolume(targetStorageType, block.getNumBytes());\n    }\n    try {\n      moveBlock(block, replicaInfo, volumeRef);\n    } finally {\n      if (volumeRef !\u003d null) {\n        volumeRef.close();\n      }\n    }\n\n    // Replace the old block if any to reschedule the scanning.\n    return replicaInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "342c9572bf6a623287f34c5cc0bc3be6038c191a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9425. Expose number of blocks per volume as a metric (Contributed by Brahma Reddy Battula)\n",
      "commitDate": "21/02/16 7:59 PM",
      "commitName": "342c9572bf6a623287f34c5cc0bc3be6038c191a",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "02/02/16 6:05 PM",
      "commitNameOld": "04375756a5ed6e907ee7548469c2c508aebbafb7",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 19.08,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,61 @@\n   public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n       StorageType targetStorageType) throws IOException {\n     ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n     if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n       throw new ReplicaNotFoundException(\n           ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n     }\n     if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n       throw new IOException(\"Corrupted replica \" + replicaInfo\n           + \" with a length of \" + replicaInfo.getNumBytes()\n           + \" expected length is \" + block.getNumBytes());\n     }\n     if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n       throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n           + \" already exists on storage \" + targetStorageType);\n     }\n \n     if (replicaInfo.isOnTransientStorage()) {\n       // Block movement from RAM_DISK will be done by LazyPersist mechanism\n       throw new IOException(\"Replica \" + replicaInfo\n           + \" cannot be moved from storageType : \"\n           + replicaInfo.getVolume().getStorageType());\n     }\n \n     FsVolumeReference volumeRef \u003d null;\n     synchronized (this) {\n       volumeRef \u003d volumes.getNextVolume(targetStorageType, block.getNumBytes());\n     }\n     try {\n       File oldBlockFile \u003d replicaInfo.getBlockFile();\n       File oldMetaFile \u003d replicaInfo.getMetaFile();\n       FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n       // Copy files to temp dir first\n       File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n           block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n           targetVolume.getTmpDir(block.getBlockPoolId()),\n           replicaInfo.isOnTransientStorage(), smallBufferSize, conf);\n \n       ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n           replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n           targetVolume, blockFiles[0].getParentFile(), 0);\n       newReplicaInfo.setNumBytes(blockFiles[1].length());\n       // Finalize the copied files\n       newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n+      synchronized (this) {\n+        // Increment numBlocks here as this block moved without knowing to BPS\n+        FsVolumeImpl volume \u003d (FsVolumeImpl) newReplicaInfo.getVolume();\n+        volume.getBlockPoolSlice(block.getBlockPoolId()).incrNumBlocks();\n+      }\n \n       removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n           oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n     } finally {\n       if (volumeRef !\u003d null) {\n         volumeRef.close();\n       }\n     }\n \n     // Replace the old block if any to reschedule the scanning.\n     return replicaInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType) throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    FsVolumeReference volumeRef \u003d null;\n    synchronized (this) {\n      volumeRef \u003d volumes.getNextVolume(targetStorageType, block.getNumBytes());\n    }\n    try {\n      File oldBlockFile \u003d replicaInfo.getBlockFile();\n      File oldMetaFile \u003d replicaInfo.getMetaFile();\n      FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n      // Copy files to temp dir first\n      File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n          block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n          targetVolume.getTmpDir(block.getBlockPoolId()),\n          replicaInfo.isOnTransientStorage(), smallBufferSize, conf);\n\n      ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n          replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n          targetVolume, blockFiles[0].getParentFile(), 0);\n      newReplicaInfo.setNumBytes(blockFiles[1].length());\n      // Finalize the copied files\n      newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n      synchronized (this) {\n        // Increment numBlocks here as this block moved without knowing to BPS\n        FsVolumeImpl volume \u003d (FsVolumeImpl) newReplicaInfo.getVolume();\n        volume.getBlockPoolSlice(block.getBlockPoolId()).incrNumBlocks();\n      }\n\n      removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n          oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n    } finally {\n      if (volumeRef !\u003d null) {\n        volumeRef.close();\n      }\n    }\n\n    // Replace the old block if any to reschedule the scanning.\n    return replicaInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "14255786908f991fd2022480fe5575533a3dc7ce": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9661. Deadlock in DN.FsDatasetImpl between moveBlockAcrossStorage and createRbw (Contributed by ade)\n",
      "commitDate": "20/01/16 7:34 AM",
      "commitName": "14255786908f991fd2022480fe5575533a3dc7ce",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "15/01/16 11:28 AM",
      "commitNameOld": "c07f7fa8ff752436726239d938e0461236839acf",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.84,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,56 @@\n   public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n       StorageType targetStorageType) throws IOException {\n     ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n     if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n       throw new ReplicaNotFoundException(\n           ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n     }\n     if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n       throw new IOException(\"Corrupted replica \" + replicaInfo\n           + \" with a length of \" + replicaInfo.getNumBytes()\n           + \" expected length is \" + block.getNumBytes());\n     }\n     if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n       throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n           + \" already exists on storage \" + targetStorageType);\n     }\n \n     if (replicaInfo.isOnTransientStorage()) {\n       // Block movement from RAM_DISK will be done by LazyPersist mechanism\n       throw new IOException(\"Replica \" + replicaInfo\n           + \" cannot be moved from storageType : \"\n           + replicaInfo.getVolume().getStorageType());\n     }\n \n-    try (FsVolumeReference volumeRef \u003d volumes.getNextVolume(\n-        targetStorageType, block.getNumBytes())) {\n+    FsVolumeReference volumeRef \u003d null;\n+    synchronized (this) {\n+      volumeRef \u003d volumes.getNextVolume(targetStorageType, block.getNumBytes());\n+    }\n+    try {\n       File oldBlockFile \u003d replicaInfo.getBlockFile();\n       File oldMetaFile \u003d replicaInfo.getMetaFile();\n       FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n       // Copy files to temp dir first\n       File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n           block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n           targetVolume.getTmpDir(block.getBlockPoolId()),\n           replicaInfo.isOnTransientStorage(), smallBufferSize, conf);\n \n       ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n           replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n           targetVolume, blockFiles[0].getParentFile(), 0);\n       newReplicaInfo.setNumBytes(blockFiles[1].length());\n       // Finalize the copied files\n       newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n \n       removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n           oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n+    } finally {\n+      if (volumeRef !\u003d null) {\n+        volumeRef.close();\n+      }\n     }\n \n     // Replace the old block if any to reschedule the scanning.\n     return replicaInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType) throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    FsVolumeReference volumeRef \u003d null;\n    synchronized (this) {\n      volumeRef \u003d volumes.getNextVolume(targetStorageType, block.getNumBytes());\n    }\n    try {\n      File oldBlockFile \u003d replicaInfo.getBlockFile();\n      File oldMetaFile \u003d replicaInfo.getMetaFile();\n      FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n      // Copy files to temp dir first\n      File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n          block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n          targetVolume.getTmpDir(block.getBlockPoolId()),\n          replicaInfo.isOnTransientStorage(), smallBufferSize, conf);\n\n      ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n          replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n          targetVolume, blockFiles[0].getParentFile(), 0);\n      newReplicaInfo.setNumBytes(blockFiles[1].length());\n      // Finalize the copied files\n      newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n\n      removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n          oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n    } finally {\n      if (volumeRef !\u003d null) {\n        volumeRef.close();\n      }\n    }\n\n    // Replace the old block if any to reschedule the scanning.\n    return replicaInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "c992bcf9c136d3df686655a80e636bb7bb0664da": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8951. Move the shortcircuit package to hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "26/08/15 2:02 PM",
      "commitName": "c992bcf9c136d3df686655a80e636bb7bb0664da",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "17/08/15 5:40 PM",
      "commitNameOld": "eee4d716b48074825e1afcd9c74038a393ddeb69",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 8.85,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n   public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n       StorageType targetStorageType) throws IOException {\n     ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n     if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n       throw new ReplicaNotFoundException(\n           ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n     }\n     if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n       throw new IOException(\"Corrupted replica \" + replicaInfo\n           + \" with a length of \" + replicaInfo.getNumBytes()\n           + \" expected length is \" + block.getNumBytes());\n     }\n     if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n       throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n           + \" already exists on storage \" + targetStorageType);\n     }\n \n     if (replicaInfo.isOnTransientStorage()) {\n       // Block movement from RAM_DISK will be done by LazyPersist mechanism\n       throw new IOException(\"Replica \" + replicaInfo\n           + \" cannot be moved from storageType : \"\n           + replicaInfo.getVolume().getStorageType());\n     }\n \n     try (FsVolumeReference volumeRef \u003d volumes.getNextVolume(\n         targetStorageType, block.getNumBytes())) {\n       File oldBlockFile \u003d replicaInfo.getBlockFile();\n       File oldMetaFile \u003d replicaInfo.getMetaFile();\n       FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n       // Copy files to temp dir first\n       File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n           block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n           targetVolume.getTmpDir(block.getBlockPoolId()),\n-          replicaInfo.isOnTransientStorage(), smallBufferSize);\n+          replicaInfo.isOnTransientStorage(), smallBufferSize, conf);\n \n       ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n           replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n           targetVolume, blockFiles[0].getParentFile(), 0);\n       newReplicaInfo.setNumBytes(blockFiles[1].length());\n       // Finalize the copied files\n       newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n \n       removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n           oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n     }\n \n     // Replace the old block if any to reschedule the scanning.\n     return replicaInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType) throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    try (FsVolumeReference volumeRef \u003d volumes.getNextVolume(\n        targetStorageType, block.getNumBytes())) {\n      File oldBlockFile \u003d replicaInfo.getBlockFile();\n      File oldMetaFile \u003d replicaInfo.getMetaFile();\n      FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n      // Copy files to temp dir first\n      File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n          block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n          targetVolume.getTmpDir(block.getBlockPoolId()),\n          replicaInfo.isOnTransientStorage(), smallBufferSize, conf);\n\n      ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n          replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n          targetVolume, blockFiles[0].getParentFile(), 0);\n      newReplicaInfo.setNumBytes(blockFiles[1].length());\n      // Finalize the copied files\n      newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n\n      removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n          oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n    }\n\n    // Replace the old block if any to reschedule the scanning.\n    return replicaInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "4da8490b512a33a255ed27309860859388d7c168": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8314. Move HdfsServerConstants#IO_FILE_BUFFER_SIZE and SMALL_BUFFER_SIZE to the users. Contributed by Li Lu.\n",
      "commitDate": "05/05/15 3:41 PM",
      "commitName": "4da8490b512a33a255ed27309860859388d7c168",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "05/05/15 11:08 AM",
      "commitNameOld": "24d3a2d4fdd836ac9a5bc755a7fb9354f7a582b1",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n   public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n       StorageType targetStorageType) throws IOException {\n     ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n     if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n       throw new ReplicaNotFoundException(\n           ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n     }\n     if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n       throw new IOException(\"Corrupted replica \" + replicaInfo\n           + \" with a length of \" + replicaInfo.getNumBytes()\n           + \" expected length is \" + block.getNumBytes());\n     }\n     if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n       throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n           + \" already exists on storage \" + targetStorageType);\n     }\n \n     if (replicaInfo.isOnTransientStorage()) {\n       // Block movement from RAM_DISK will be done by LazyPersist mechanism\n       throw new IOException(\"Replica \" + replicaInfo\n           + \" cannot be moved from storageType : \"\n           + replicaInfo.getVolume().getStorageType());\n     }\n \n     try (FsVolumeReference volumeRef \u003d volumes.getNextVolume(\n         targetStorageType, block.getNumBytes())) {\n       File oldBlockFile \u003d replicaInfo.getBlockFile();\n       File oldMetaFile \u003d replicaInfo.getMetaFile();\n       FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n       // Copy files to temp dir first\n       File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n           block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n           targetVolume.getTmpDir(block.getBlockPoolId()),\n-          replicaInfo.isOnTransientStorage());\n+          replicaInfo.isOnTransientStorage(), smallBufferSize);\n \n       ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n           replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n           targetVolume, blockFiles[0].getParentFile(), 0);\n       newReplicaInfo.setNumBytes(blockFiles[1].length());\n       // Finalize the copied files\n       newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n \n       removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n           oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n     }\n \n     // Replace the old block if any to reschedule the scanning.\n     return replicaInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType) throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    try (FsVolumeReference volumeRef \u003d volumes.getNextVolume(\n        targetStorageType, block.getNumBytes())) {\n      File oldBlockFile \u003d replicaInfo.getBlockFile();\n      File oldMetaFile \u003d replicaInfo.getMetaFile();\n      FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n      // Copy files to temp dir first\n      File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n          block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n          targetVolume.getTmpDir(block.getBlockPoolId()),\n          replicaInfo.isOnTransientStorage(), smallBufferSize);\n\n      ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n          replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n          targetVolume, blockFiles[0].getParentFile(), 0);\n      newReplicaInfo.setNumBytes(blockFiles[1].length());\n      // Finalize the copied files\n      newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n\n      removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n          oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n    }\n\n    // Replace the old block if any to reschedule the scanning.\n    return replicaInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "6e62a1a6728b1f782f64065424f92b292c3f163a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7430. Refactor the BlockScanner to use O(1) memory and use multiple threads (cmccabe)\n",
      "commitDate": "21/01/15 7:00 PM",
      "commitName": "6e62a1a6728b1f782f64065424f92b292c3f163a",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "21/01/15 12:41 PM",
      "commitNameOld": "c0af72c7f74b6925786e24543cac433b906dd6d3",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,49 @@\n   public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n       StorageType targetStorageType) throws IOException {\n     ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n     if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n       throw new ReplicaNotFoundException(\n           ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n     }\n     if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n       throw new IOException(\"Corrupted replica \" + replicaInfo\n           + \" with a length of \" + replicaInfo.getNumBytes()\n           + \" expected length is \" + block.getNumBytes());\n     }\n     if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n       throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n           + \" already exists on storage \" + targetStorageType);\n     }\n \n     if (replicaInfo.isOnTransientStorage()) {\n       // Block movement from RAM_DISK will be done by LazyPersist mechanism\n       throw new IOException(\"Replica \" + replicaInfo\n           + \" cannot be moved from storageType : \"\n           + replicaInfo.getVolume().getStorageType());\n     }\n \n     try (FsVolumeReference volumeRef \u003d volumes.getNextVolume(\n         targetStorageType, block.getNumBytes())) {\n       File oldBlockFile \u003d replicaInfo.getBlockFile();\n       File oldMetaFile \u003d replicaInfo.getMetaFile();\n       FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n       // Copy files to temp dir first\n       File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n           block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n           targetVolume.getTmpDir(block.getBlockPoolId()),\n           replicaInfo.isOnTransientStorage());\n \n       ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n           replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n           targetVolume, blockFiles[0].getParentFile(), 0);\n       newReplicaInfo.setNumBytes(blockFiles[1].length());\n       // Finalize the copied files\n       newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n \n       removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n           oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n     }\n \n     // Replace the old block if any to reschedule the scanning.\n-    datanode.getBlockScanner().addBlock(block, false);\n     return replicaInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType) throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    try (FsVolumeReference volumeRef \u003d volumes.getNextVolume(\n        targetStorageType, block.getNumBytes())) {\n      File oldBlockFile \u003d replicaInfo.getBlockFile();\n      File oldMetaFile \u003d replicaInfo.getMetaFile();\n      FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n      // Copy files to temp dir first\n      File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n          block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n          targetVolume.getTmpDir(block.getBlockPoolId()),\n          replicaInfo.isOnTransientStorage());\n\n      ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n          replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n          targetVolume, blockFiles[0].getParentFile(), 0);\n      newReplicaInfo.setNumBytes(blockFiles[1].length());\n      // Finalize the copied files\n      newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n\n      removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n          oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n    }\n\n    // Replace the old block if any to reschedule the scanning.\n    return replicaInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "c0af72c7f74b6925786e24543cac433b906dd6d3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7548. Corrupt block reporting delayed until datablock scanner thread detects it. Contributed by Rushabh Shah.\n",
      "commitDate": "21/01/15 12:41 PM",
      "commitName": "c0af72c7f74b6925786e24543cac433b906dd6d3",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "20/01/15 8:11 PM",
      "commitNameOld": "a17584936cc5141e3f5612ac3ecf35e27968e439",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n       StorageType targetStorageType) throws IOException {\n     ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n     if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n       throw new ReplicaNotFoundException(\n           ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n     }\n     if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n       throw new IOException(\"Corrupted replica \" + replicaInfo\n           + \" with a length of \" + replicaInfo.getNumBytes()\n           + \" expected length is \" + block.getNumBytes());\n     }\n     if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n       throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n           + \" already exists on storage \" + targetStorageType);\n     }\n \n     if (replicaInfo.isOnTransientStorage()) {\n       // Block movement from RAM_DISK will be done by LazyPersist mechanism\n       throw new IOException(\"Replica \" + replicaInfo\n           + \" cannot be moved from storageType : \"\n           + replicaInfo.getVolume().getStorageType());\n     }\n \n     try (FsVolumeReference volumeRef \u003d volumes.getNextVolume(\n         targetStorageType, block.getNumBytes())) {\n       File oldBlockFile \u003d replicaInfo.getBlockFile();\n       File oldMetaFile \u003d replicaInfo.getMetaFile();\n       FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n       // Copy files to temp dir first\n       File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n           block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n           targetVolume.getTmpDir(block.getBlockPoolId()),\n           replicaInfo.isOnTransientStorage());\n \n       ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n           replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n           targetVolume, blockFiles[0].getParentFile(), 0);\n       newReplicaInfo.setNumBytes(blockFiles[1].length());\n       // Finalize the copied files\n       newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n \n       removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n           oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n     }\n \n     // Replace the old block if any to reschedule the scanning.\n-    datanode.getBlockScanner().addBlock(block);\n+    datanode.getBlockScanner().addBlock(block, false);\n     return replicaInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType) throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    try (FsVolumeReference volumeRef \u003d volumes.getNextVolume(\n        targetStorageType, block.getNumBytes())) {\n      File oldBlockFile \u003d replicaInfo.getBlockFile();\n      File oldMetaFile \u003d replicaInfo.getMetaFile();\n      FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n      // Copy files to temp dir first\n      File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n          block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n          targetVolume.getTmpDir(block.getBlockPoolId()),\n          replicaInfo.isOnTransientStorage());\n\n      ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n          replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n          targetVolume, blockFiles[0].getParentFile(), 0);\n      newReplicaInfo.setNumBytes(blockFiles[1].length());\n      // Finalize the copied files\n      newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n\n      removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n          oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n    }\n\n    // Replace the old block if any to reschedule the scanning.\n    datanode.getBlockScanner().addBlock(block, false);\n    return replicaInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "b7f4a3156c0f5c600816c469637237ba6c9b330c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7496. Fix FsVolume removal race conditions on the DataNode by reference-counting the volume instances (lei via cmccabe)\n",
      "commitDate": "20/01/15 7:05 PM",
      "commitName": "b7f4a3156c0f5c600816c469637237ba6c9b330c",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "13/01/15 12:24 AM",
      "commitNameOld": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 7.78,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,50 @@\n   public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n       StorageType targetStorageType) throws IOException {\n     ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n     if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n       throw new ReplicaNotFoundException(\n           ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n     }\n     if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n       throw new IOException(\"Corrupted replica \" + replicaInfo\n           + \" with a length of \" + replicaInfo.getNumBytes()\n           + \" expected length is \" + block.getNumBytes());\n     }\n     if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n       throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n           + \" already exists on storage \" + targetStorageType);\n     }\n \n     if (replicaInfo.isOnTransientStorage()) {\n       // Block movement from RAM_DISK will be done by LazyPersist mechanism\n       throw new IOException(\"Replica \" + replicaInfo\n           + \" cannot be moved from storageType : \"\n           + replicaInfo.getVolume().getStorageType());\n     }\n \n-    FsVolumeImpl targetVolume \u003d volumes.getNextVolume(targetStorageType,\n-        block.getNumBytes());\n-    File oldBlockFile \u003d replicaInfo.getBlockFile();\n-    File oldMetaFile \u003d replicaInfo.getMetaFile();\n+    try (FsVolumeReference volumeRef \u003d volumes.getNextVolume(\n+        targetStorageType, block.getNumBytes())) {\n+      File oldBlockFile \u003d replicaInfo.getBlockFile();\n+      File oldMetaFile \u003d replicaInfo.getMetaFile();\n+      FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n+      // Copy files to temp dir first\n+      File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n+          block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n+          targetVolume.getTmpDir(block.getBlockPoolId()),\n+          replicaInfo.isOnTransientStorage());\n \n-    // Copy files to temp dir first\n-    File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n-        block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n-        targetVolume.getTmpDir(block.getBlockPoolId()),\n-        replicaInfo.isOnTransientStorage());\n+      ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n+          replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n+          targetVolume, blockFiles[0].getParentFile(), 0);\n+      newReplicaInfo.setNumBytes(blockFiles[1].length());\n+      // Finalize the copied files\n+      newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n \n-    ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n-        replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n-        targetVolume, blockFiles[0].getParentFile(), 0);\n-    newReplicaInfo.setNumBytes(blockFiles[1].length());\n-    // Finalize the copied files\n-    newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n-\n-    removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n-        oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n+      removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n+          oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n+    }\n \n     // Replace the old block if any to reschedule the scanning.\n     datanode.getBlockScanner().addBlock(block);\n     return replicaInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType) throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    try (FsVolumeReference volumeRef \u003d volumes.getNextVolume(\n        targetStorageType, block.getNumBytes())) {\n      File oldBlockFile \u003d replicaInfo.getBlockFile();\n      File oldMetaFile \u003d replicaInfo.getMetaFile();\n      FsVolumeImpl targetVolume \u003d (FsVolumeImpl) volumeRef.getVolume();\n      // Copy files to temp dir first\n      File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n          block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n          targetVolume.getTmpDir(block.getBlockPoolId()),\n          replicaInfo.isOnTransientStorage());\n\n      ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n          replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n          targetVolume, blockFiles[0].getParentFile(), 0);\n      newReplicaInfo.setNumBytes(blockFiles[1].length());\n      // Finalize the copied files\n      newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n\n      removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n          oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n    }\n\n    // Replace the old block if any to reschedule the scanning.\n    datanode.getBlockScanner().addBlock(block);\n    return replicaInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "058af60c56207907f2bedf76df4284e86d923e0c": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7310. Mover can give first priority to local DN if it has target storage type available in local DN. (Vinayakumar B via umamahesh)\n",
      "commitDate": "26/11/14 9:57 AM",
      "commitName": "058af60c56207907f2bedf76df4284e86d923e0c",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,49 @@\n+  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n+      StorageType targetStorageType) throws IOException {\n+    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n+    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n+      throw new ReplicaNotFoundException(\n+          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n+    }\n+    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n+      throw new IOException(\"Corrupted replica \" + replicaInfo\n+          + \" with a length of \" + replicaInfo.getNumBytes()\n+          + \" expected length is \" + block.getNumBytes());\n+    }\n+    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n+      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n+          + \" already exists on storage \" + targetStorageType);\n+    }\n+\n+    if (replicaInfo.isOnTransientStorage()) {\n+      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n+      throw new IOException(\"Replica \" + replicaInfo\n+          + \" cannot be moved from storageType : \"\n+          + replicaInfo.getVolume().getStorageType());\n+    }\n+\n+    FsVolumeImpl targetVolume \u003d volumes.getNextVolume(targetStorageType,\n+        block.getNumBytes());\n+    File oldBlockFile \u003d replicaInfo.getBlockFile();\n+    File oldMetaFile \u003d replicaInfo.getMetaFile();\n+\n+    // Copy files to temp dir first\n+    File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n+        block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n+        targetVolume.getTmpDir(block.getBlockPoolId()),\n+        replicaInfo.isOnTransientStorage());\n+\n+    ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n+        replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n+        targetVolume, blockFiles[0].getParentFile(), 0);\n+    newReplicaInfo.setNumBytes(blockFiles[1].length());\n+    // Finalize the copied files\n+    newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n+\n+    removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n+        oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n+\n+    // Replace the old block if any to reschedule the scanning.\n+    datanode.getBlockScanner().addBlock(block);\n+    return replicaInfo;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public ReplicaInfo moveBlockAcrossStorage(ExtendedBlock block,\n      StorageType targetStorageType) throws IOException {\n    ReplicaInfo replicaInfo \u003d getReplicaInfo(block);\n    if (replicaInfo.getState() !\u003d ReplicaState.FINALIZED) {\n      throw new ReplicaNotFoundException(\n          ReplicaNotFoundException.UNFINALIZED_REPLICA + block);\n    }\n    if (replicaInfo.getNumBytes() !\u003d block.getNumBytes()) {\n      throw new IOException(\"Corrupted replica \" + replicaInfo\n          + \" with a length of \" + replicaInfo.getNumBytes()\n          + \" expected length is \" + block.getNumBytes());\n    }\n    if (replicaInfo.getVolume().getStorageType() \u003d\u003d targetStorageType) {\n      throw new ReplicaAlreadyExistsException(\"Replica \" + replicaInfo\n          + \" already exists on storage \" + targetStorageType);\n    }\n\n    if (replicaInfo.isOnTransientStorage()) {\n      // Block movement from RAM_DISK will be done by LazyPersist mechanism\n      throw new IOException(\"Replica \" + replicaInfo\n          + \" cannot be moved from storageType : \"\n          + replicaInfo.getVolume().getStorageType());\n    }\n\n    FsVolumeImpl targetVolume \u003d volumes.getNextVolume(targetStorageType,\n        block.getNumBytes());\n    File oldBlockFile \u003d replicaInfo.getBlockFile();\n    File oldMetaFile \u003d replicaInfo.getMetaFile();\n\n    // Copy files to temp dir first\n    File[] blockFiles \u003d copyBlockFiles(block.getBlockId(),\n        block.getGenerationStamp(), oldMetaFile, oldBlockFile,\n        targetVolume.getTmpDir(block.getBlockPoolId()),\n        replicaInfo.isOnTransientStorage());\n\n    ReplicaInfo newReplicaInfo \u003d new ReplicaInPipeline(\n        replicaInfo.getBlockId(), replicaInfo.getGenerationStamp(),\n        targetVolume, blockFiles[0].getParentFile(), 0);\n    newReplicaInfo.setNumBytes(blockFiles[1].length());\n    // Finalize the copied files\n    newReplicaInfo \u003d finalizeReplica(block.getBlockPoolId(), newReplicaInfo);\n\n    removeOldReplica(replicaInfo, newReplicaInfo, oldBlockFile, oldMetaFile,\n        oldBlockFile.length(), oldMetaFile.length(), block.getBlockPoolId());\n\n    // Replace the old block if any to reschedule the scanning.\n    datanode.getBlockScanner().addBlock(block);\n    return replicaInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java"
    }
  }
}