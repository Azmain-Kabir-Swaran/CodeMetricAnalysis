{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ScriptBasedNodeAttributesProvider.java",
  "functionName": "parseOutput",
  "functionId": "parseOutput___scriptOutput-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/nodelabels/ScriptBasedNodeAttributesProvider.java",
  "functionStartLine": 99,
  "functionEndLine": 156,
  "numCommitsSeen": 3,
  "timeTaken": 1767,
  "changeHistory": [
    "440ff7f563df5e7db72dce020c3c3dc379f88c91",
    "ffcabd24c33fc8c663cc75b57d7562db4c199713",
    "d312b5cf9ffff016432ec5a7e64b81ab7a8c31f3"
  ],
  "changeHistoryShort": {
    "440ff7f563df5e7db72dce020c3c3dc379f88c91": "Ybodychange",
    "ffcabd24c33fc8c663cc75b57d7562db4c199713": "Ybodychange",
    "d312b5cf9ffff016432ec5a7e64b81ab7a8c31f3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "440ff7f563df5e7db72dce020c3c3dc379f88c91": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8094. Support configuration based Node Attribute provider. Contributed by Weiwei Yang.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "440ff7f563df5e7db72dce020c3c3dc379f88c91",
      "commitAuthor": "Sunil G",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "ffcabd24c33fc8c663cc75b57d7562db4c199713",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,58 @@\n     Set\u003cNodeAttribute\u003e parseOutput(String scriptOutput) throws IOException {\n       Set\u003cNodeAttribute\u003e attributeSet \u003d new HashSet\u003c\u003e();\n       // TODO finalize format\n \n       // each line is a record of ndoe attribute like following:\n       // NODE_ATTRIBUTE:ATTRIBUTE_NAME,ATTRIBUTE_TYPE,ATTRIBUTE_VALUE\n       String[] splits \u003d scriptOutput.split(\"\\n\");\n       for (String line : splits) {\n         String trimmedLine \u003d line.trim();\n         if (trimmedLine.startsWith(NODE_ATTRIBUTE_PATTERN)) {\n           String nodeAttribute \u003d trimmedLine\n               .substring(NODE_ATTRIBUTE_PATTERN.length());\n           String[] attributeStrs \u003d nodeAttribute\n               .split(NODE_ATTRIBUTE_DELIMITER);\n           if (attributeStrs.length !\u003d 3) {\n             throw new IOException(\"Malformed output, expecting format \"\n                 + NODE_ATTRIBUTE_PATTERN + \":\" + \"ATTRIBUTE_NAME\"\n                 + NODE_ATTRIBUTE_DELIMITER + \"ATTRIBUTE_TYPE\"\n                 + NODE_ATTRIBUTE_DELIMITER + \"ATTRIBUTE_VALUE; but get \"\n                 + nodeAttribute);\n           }\n+\n+          // We don\u0027t allow script to overwrite our dist prefix,\n+          // so disallow any prefix set in the script.\n+          if (attributeStrs[0].contains(\"/\")) {\n+            throw new IOException(\"Node attributes reported by script\"\n+                + \" should not contain any prefix.\");\n+          }\n+\n           // Automatically setup prefix for collected attributes\n           NodeAttribute na \u003d NodeAttribute\n               .newInstance(NodeAttribute.PREFIX_DISTRIBUTED,\n                   attributeStrs[0],\n                   NodeAttributeType.valueOf(attributeStrs[1]),\n                   attributeStrs[2]);\n \n           // Since a NodeAttribute is identical with another one as long as\n           // their prefix and name are same, to avoid attributes getting\n           // overwritten by ambiguous attribute, make sure it fails in such\n           // case.\n           if (!attributeSet.add(na)) {\n             throw new IOException(\"Ambiguous node attribute is found: \"\n                 + na.toString() + \", a same attribute already exists\");\n           }\n         }\n       }\n \n       // Before updating the attributes to the provider,\n       // verify if they are valid\n       try {\n         NodeLabelUtil.validateNodeAttributes(attributeSet);\n       } catch (IOException e) {\n         throw new IOException(\"Node attributes collected by the script \"\n             + \"contains some invalidate entries. Detail message: \"\n             + e.getMessage());\n       }\n       return attributeSet;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Set\u003cNodeAttribute\u003e parseOutput(String scriptOutput) throws IOException {\n      Set\u003cNodeAttribute\u003e attributeSet \u003d new HashSet\u003c\u003e();\n      // TODO finalize format\n\n      // each line is a record of ndoe attribute like following:\n      // NODE_ATTRIBUTE:ATTRIBUTE_NAME,ATTRIBUTE_TYPE,ATTRIBUTE_VALUE\n      String[] splits \u003d scriptOutput.split(\"\\n\");\n      for (String line : splits) {\n        String trimmedLine \u003d line.trim();\n        if (trimmedLine.startsWith(NODE_ATTRIBUTE_PATTERN)) {\n          String nodeAttribute \u003d trimmedLine\n              .substring(NODE_ATTRIBUTE_PATTERN.length());\n          String[] attributeStrs \u003d nodeAttribute\n              .split(NODE_ATTRIBUTE_DELIMITER);\n          if (attributeStrs.length !\u003d 3) {\n            throw new IOException(\"Malformed output, expecting format \"\n                + NODE_ATTRIBUTE_PATTERN + \":\" + \"ATTRIBUTE_NAME\"\n                + NODE_ATTRIBUTE_DELIMITER + \"ATTRIBUTE_TYPE\"\n                + NODE_ATTRIBUTE_DELIMITER + \"ATTRIBUTE_VALUE; but get \"\n                + nodeAttribute);\n          }\n\n          // We don\u0027t allow script to overwrite our dist prefix,\n          // so disallow any prefix set in the script.\n          if (attributeStrs[0].contains(\"/\")) {\n            throw new IOException(\"Node attributes reported by script\"\n                + \" should not contain any prefix.\");\n          }\n\n          // Automatically setup prefix for collected attributes\n          NodeAttribute na \u003d NodeAttribute\n              .newInstance(NodeAttribute.PREFIX_DISTRIBUTED,\n                  attributeStrs[0],\n                  NodeAttributeType.valueOf(attributeStrs[1]),\n                  attributeStrs[2]);\n\n          // Since a NodeAttribute is identical with another one as long as\n          // their prefix and name are same, to avoid attributes getting\n          // overwritten by ambiguous attribute, make sure it fails in such\n          // case.\n          if (!attributeSet.add(na)) {\n            throw new IOException(\"Ambiguous node attribute is found: \"\n                + na.toString() + \", a same attribute already exists\");\n          }\n        }\n      }\n\n      // Before updating the attributes to the provider,\n      // verify if they are valid\n      try {\n        NodeLabelUtil.validateNodeAttributes(attributeSet);\n      } catch (IOException e) {\n        throw new IOException(\"Node attributes collected by the script \"\n            + \"contains some invalidate entries. Detail message: \"\n            + e.getMessage());\n      }\n      return attributeSet;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/nodelabels/ScriptBasedNodeAttributesProvider.java",
      "extendedDetails": {}
    },
    "ffcabd24c33fc8c663cc75b57d7562db4c199713": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7856. Validate Node Attributes from NM. Contributed by Weiwei Yang.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "ffcabd24c33fc8c663cc75b57d7562db4c199713",
      "commitAuthor": "Sunil G",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "d312b5cf9ffff016432ec5a7e64b81ab7a8c31f3",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,50 @@\n     Set\u003cNodeAttribute\u003e parseOutput(String scriptOutput) throws IOException {\n       Set\u003cNodeAttribute\u003e attributeSet \u003d new HashSet\u003c\u003e();\n       // TODO finalize format\n \n       // each line is a record of ndoe attribute like following:\n       // NODE_ATTRIBUTE:ATTRIBUTE_NAME,ATTRIBUTE_TYPE,ATTRIBUTE_VALUE\n       String[] splits \u003d scriptOutput.split(\"\\n\");\n       for (String line : splits) {\n         String trimmedLine \u003d line.trim();\n         if (trimmedLine.startsWith(NODE_ATTRIBUTE_PATTERN)) {\n           String nodeAttribute \u003d trimmedLine\n               .substring(NODE_ATTRIBUTE_PATTERN.length());\n           String[] attributeStrs \u003d nodeAttribute\n               .split(NODE_ATTRIBUTE_DELIMITER);\n           if (attributeStrs.length !\u003d 3) {\n             throw new IOException(\"Malformed output, expecting format \"\n                 + NODE_ATTRIBUTE_PATTERN + \":\" + \"ATTRIBUTE_NAME\"\n                 + NODE_ATTRIBUTE_DELIMITER + \"ATTRIBUTE_TYPE\"\n                 + NODE_ATTRIBUTE_DELIMITER + \"ATTRIBUTE_VALUE; but get \"\n                 + nodeAttribute);\n           }\n+          // Automatically setup prefix for collected attributes\n           NodeAttribute na \u003d NodeAttribute\n-              .newInstance(attributeStrs[0],\n+              .newInstance(NodeAttribute.PREFIX_DISTRIBUTED,\n+                  attributeStrs[0],\n                   NodeAttributeType.valueOf(attributeStrs[1]),\n                   attributeStrs[2]);\n-          attributeSet.add(na);\n+\n+          // Since a NodeAttribute is identical with another one as long as\n+          // their prefix and name are same, to avoid attributes getting\n+          // overwritten by ambiguous attribute, make sure it fails in such\n+          // case.\n+          if (!attributeSet.add(na)) {\n+            throw new IOException(\"Ambiguous node attribute is found: \"\n+                + na.toString() + \", a same attribute already exists\");\n+          }\n         }\n       }\n+\n+      // Before updating the attributes to the provider,\n+      // verify if they are valid\n+      try {\n+        NodeLabelUtil.validateNodeAttributes(attributeSet);\n+      } catch (IOException e) {\n+        throw new IOException(\"Node attributes collected by the script \"\n+            + \"contains some invalidate entries. Detail message: \"\n+            + e.getMessage());\n+      }\n       return attributeSet;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Set\u003cNodeAttribute\u003e parseOutput(String scriptOutput) throws IOException {\n      Set\u003cNodeAttribute\u003e attributeSet \u003d new HashSet\u003c\u003e();\n      // TODO finalize format\n\n      // each line is a record of ndoe attribute like following:\n      // NODE_ATTRIBUTE:ATTRIBUTE_NAME,ATTRIBUTE_TYPE,ATTRIBUTE_VALUE\n      String[] splits \u003d scriptOutput.split(\"\\n\");\n      for (String line : splits) {\n        String trimmedLine \u003d line.trim();\n        if (trimmedLine.startsWith(NODE_ATTRIBUTE_PATTERN)) {\n          String nodeAttribute \u003d trimmedLine\n              .substring(NODE_ATTRIBUTE_PATTERN.length());\n          String[] attributeStrs \u003d nodeAttribute\n              .split(NODE_ATTRIBUTE_DELIMITER);\n          if (attributeStrs.length !\u003d 3) {\n            throw new IOException(\"Malformed output, expecting format \"\n                + NODE_ATTRIBUTE_PATTERN + \":\" + \"ATTRIBUTE_NAME\"\n                + NODE_ATTRIBUTE_DELIMITER + \"ATTRIBUTE_TYPE\"\n                + NODE_ATTRIBUTE_DELIMITER + \"ATTRIBUTE_VALUE; but get \"\n                + nodeAttribute);\n          }\n          // Automatically setup prefix for collected attributes\n          NodeAttribute na \u003d NodeAttribute\n              .newInstance(NodeAttribute.PREFIX_DISTRIBUTED,\n                  attributeStrs[0],\n                  NodeAttributeType.valueOf(attributeStrs[1]),\n                  attributeStrs[2]);\n\n          // Since a NodeAttribute is identical with another one as long as\n          // their prefix and name are same, to avoid attributes getting\n          // overwritten by ambiguous attribute, make sure it fails in such\n          // case.\n          if (!attributeSet.add(na)) {\n            throw new IOException(\"Ambiguous node attribute is found: \"\n                + na.toString() + \", a same attribute already exists\");\n          }\n        }\n      }\n\n      // Before updating the attributes to the provider,\n      // verify if they are valid\n      try {\n        NodeLabelUtil.validateNodeAttributes(attributeSet);\n      } catch (IOException e) {\n        throw new IOException(\"Node attributes collected by the script \"\n            + \"contains some invalidate entries. Detail message: \"\n            + e.getMessage());\n      }\n      return attributeSet;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/nodelabels/ScriptBasedNodeAttributesProvider.java",
      "extendedDetails": {}
    },
    "d312b5cf9ffff016432ec5a7e64b81ab7a8c31f3": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7757. Refactor NodeLabelsProvider to be more generic and reusable for node attributes providers. Contributed by Weiwei Yang.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "d312b5cf9ffff016432ec5a7e64b81ab7a8c31f3",
      "commitAuthor": "Naganarasimha",
      "diff": "@@ -0,0 +1,30 @@\n+    Set\u003cNodeAttribute\u003e parseOutput(String scriptOutput) throws IOException {\n+      Set\u003cNodeAttribute\u003e attributeSet \u003d new HashSet\u003c\u003e();\n+      // TODO finalize format\n+\n+      // each line is a record of ndoe attribute like following:\n+      // NODE_ATTRIBUTE:ATTRIBUTE_NAME,ATTRIBUTE_TYPE,ATTRIBUTE_VALUE\n+      String[] splits \u003d scriptOutput.split(\"\\n\");\n+      for (String line : splits) {\n+        String trimmedLine \u003d line.trim();\n+        if (trimmedLine.startsWith(NODE_ATTRIBUTE_PATTERN)) {\n+          String nodeAttribute \u003d trimmedLine\n+              .substring(NODE_ATTRIBUTE_PATTERN.length());\n+          String[] attributeStrs \u003d nodeAttribute\n+              .split(NODE_ATTRIBUTE_DELIMITER);\n+          if (attributeStrs.length !\u003d 3) {\n+            throw new IOException(\"Malformed output, expecting format \"\n+                + NODE_ATTRIBUTE_PATTERN + \":\" + \"ATTRIBUTE_NAME\"\n+                + NODE_ATTRIBUTE_DELIMITER + \"ATTRIBUTE_TYPE\"\n+                + NODE_ATTRIBUTE_DELIMITER + \"ATTRIBUTE_VALUE; but get \"\n+                + nodeAttribute);\n+          }\n+          NodeAttribute na \u003d NodeAttribute\n+              .newInstance(attributeStrs[0],\n+                  NodeAttributeType.valueOf(attributeStrs[1]),\n+                  attributeStrs[2]);\n+          attributeSet.add(na);\n+        }\n+      }\n+      return attributeSet;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    Set\u003cNodeAttribute\u003e parseOutput(String scriptOutput) throws IOException {\n      Set\u003cNodeAttribute\u003e attributeSet \u003d new HashSet\u003c\u003e();\n      // TODO finalize format\n\n      // each line is a record of ndoe attribute like following:\n      // NODE_ATTRIBUTE:ATTRIBUTE_NAME,ATTRIBUTE_TYPE,ATTRIBUTE_VALUE\n      String[] splits \u003d scriptOutput.split(\"\\n\");\n      for (String line : splits) {\n        String trimmedLine \u003d line.trim();\n        if (trimmedLine.startsWith(NODE_ATTRIBUTE_PATTERN)) {\n          String nodeAttribute \u003d trimmedLine\n              .substring(NODE_ATTRIBUTE_PATTERN.length());\n          String[] attributeStrs \u003d nodeAttribute\n              .split(NODE_ATTRIBUTE_DELIMITER);\n          if (attributeStrs.length !\u003d 3) {\n            throw new IOException(\"Malformed output, expecting format \"\n                + NODE_ATTRIBUTE_PATTERN + \":\" + \"ATTRIBUTE_NAME\"\n                + NODE_ATTRIBUTE_DELIMITER + \"ATTRIBUTE_TYPE\"\n                + NODE_ATTRIBUTE_DELIMITER + \"ATTRIBUTE_VALUE; but get \"\n                + nodeAttribute);\n          }\n          NodeAttribute na \u003d NodeAttribute\n              .newInstance(attributeStrs[0],\n                  NodeAttributeType.valueOf(attributeStrs[1]),\n                  attributeStrs[2]);\n          attributeSet.add(na);\n        }\n      }\n      return attributeSet;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/nodelabels/ScriptBasedNodeAttributesProvider.java"
    }
  }
}