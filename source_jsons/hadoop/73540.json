{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Client.java",
  "functionName": "call",
  "functionId": "call___rpcKind-RPC.RpcKind__rpcRequest-Writable__remoteId-ConnectionId__serviceClass-int__fallbackToSimpleAuth-AtomicBoolean",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
  "functionStartLine": 1423,
  "functionEndLine": 1429,
  "numCommitsSeen": 125,
  "timeTaken": 7216,
  "changeHistory": [
    "e880660a204b6fd0e5a0799393a4d36359765a54",
    "35f255b03b1bb5c94063ec1818af1d253ceee991",
    "574dcd34c0da1903d25e37dc5757642a584dc3d0",
    "aa20fa150d522b9fe469dd99a8e24d7e27d888ea",
    "eded3d109e4c5225d8c5cd3c2d82e7ac93841263",
    "106234d873c60fa52cd0d812fb1cdc0c6b998a6d",
    "4d36b221a24e3b626bb91093b0bb0fd377061cae",
    "e4450d47f19131818e1c040b6bd8d85ae8250475",
    "5360da8bd9f720384860f411bee081aef13b4bd4",
    "83f2f78c118a7e52aba5104bd97b0acedc96be7b",
    "42c22f7e3d6e88bf1115f617f6e803288886d1ac",
    "1b9f18623ab55507bea94888317c7d63d0f4a6f2",
    "fc94810d3f537e51e826fc21ade7867892b9d8dc",
    "a62637a413ad88c4273d3251892b8fc1c05afa34",
    "1898810cda83e6d273a2963b56ed499c0fb91118",
    "6144e0137bb51bd04b46ea5ce42c59c2d4f7657d",
    "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5"
  ],
  "changeHistoryShort": {
    "e880660a204b6fd0e5a0799393a4d36359765a54": "Ybodychange",
    "35f255b03b1bb5c94063ec1818af1d253ceee991": "Ybodychange",
    "574dcd34c0da1903d25e37dc5757642a584dc3d0": "Ybodychange",
    "aa20fa150d522b9fe469dd99a8e24d7e27d888ea": "Ybodychange",
    "eded3d109e4c5225d8c5cd3c2d82e7ac93841263": "Ybodychange",
    "106234d873c60fa52cd0d812fb1cdc0c6b998a6d": "Ybodychange",
    "4d36b221a24e3b626bb91093b0bb0fd377061cae": "Ybodychange",
    "e4450d47f19131818e1c040b6bd8d85ae8250475": "Ybodychange",
    "5360da8bd9f720384860f411bee081aef13b4bd4": "Ybodychange",
    "83f2f78c118a7e52aba5104bd97b0acedc96be7b": "Ybodychange",
    "42c22f7e3d6e88bf1115f617f6e803288886d1ac": "Ybodychange",
    "1b9f18623ab55507bea94888317c7d63d0f4a6f2": "Ybodychange",
    "fc94810d3f537e51e826fc21ade7867892b9d8dc": "Ybodychange",
    "a62637a413ad88c4273d3251892b8fc1c05afa34": "Ybodychange",
    "1898810cda83e6d273a2963b56ed499c0fb91118": "Ymodifierchange",
    "6144e0137bb51bd04b46ea5ce42c59c2d4f7657d": "Ybodychange",
    "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e880660a204b6fd0e5a0799393a4d36359765a54": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13399. [SBN read] Make Client field AlignmentContext non-static. Contributed by Plamen Jeliazkov.",
      "commitDate": "24/12/18 9:33 AM",
      "commitName": "e880660a204b6fd0e5a0799393a4d36359765a54",
      "commitAuthor": "Plamen Jeliazkov",
      "commitDateOld": "24/12/18 9:33 AM",
      "commitNameOld": "9bf0696c7348879678693176da0071628ca42566",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,7 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n-      ConnectionId remoteId, int serviceClass,\n-      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n-    final Call call \u003d createCall(rpcKind, rpcRequest);\n-    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n-        fallbackToSimpleAuth);\n-\n-    try {\n-      checkAsyncCall();\n-      try {\n-        connection.sendRpcRequest(call);                 // send the rpc request\n-      } catch (RejectedExecutionException e) {\n-        throw new IOException(\"connection has been closed\", e);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-        LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n-        throw new IOException(e);\n-      }\n-    } catch(Exception e) {\n-      if (isAsynchronousMode()) {\n-        releaseAsyncCall();\n-      }\n-      throw e;\n-    }\n-\n-    if (isAsynchronousMode()) {\n-      final AsyncGet\u003cWritable, IOException\u003e asyncGet\n-          \u003d new AsyncGet\u003cWritable, IOException\u003e() {\n-        @Override\n-        public Writable get(long timeout, TimeUnit unit)\n-            throws IOException, TimeoutException{\n-          boolean done \u003d true;\n-          try {\n-            final Writable w \u003d getRpcResponse(call, connection, timeout, unit);\n-            if (w \u003d\u003d null) {\n-              done \u003d false;\n-              throw new TimeoutException(call + \" timed out \"\n-                  + timeout + \" \" + unit);\n-            }\n-            return w;\n-          } finally {\n-            if (done) {\n-              releaseAsyncCall();\n-            }\n-          }\n-        }\n-\n-        @Override\n-        public boolean isDone() {\n-          synchronized (call) {\n-            return call.done;\n-          }\n-        }\n-      };\n-\n-      ASYNC_RPC_RESPONSE.set(asyncGet);\n-      return null;\n-    } else {\n-      return getRpcResponse(call, connection, -1, null);\n-    }\n+                ConnectionId remoteId, int serviceClass,\n+                AtomicBoolean fallbackToSimpleAuth)\n+      throws IOException {\n+    return call(rpcKind, rpcRequest, remoteId, serviceClass,\n+        fallbackToSimpleAuth, null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n                ConnectionId remoteId, int serviceClass,\n                AtomicBoolean fallbackToSimpleAuth)\n      throws IOException {\n    return call(rpcKind, rpcRequest, remoteId, serviceClass,\n        fallbackToSimpleAuth, null);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "35f255b03b1bb5c94063ec1818af1d253ceee991": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Revert \"HADOOP-13226 Support async call retry and failover.\"\"\n\nThis reverts commit 5360da8bd9f720384860f411bee081aef13b4bd4.\n",
      "commitDate": "06/06/16 1:31 AM",
      "commitName": "35f255b03b1bb5c94063ec1818af1d253ceee991",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "06/06/16 1:31 AM",
      "commitNameOld": "574dcd34c0da1903d25e37dc5757642a584dc3d0",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,61 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n         fallbackToSimpleAuth);\n \n     try {\n       checkAsyncCall();\n       try {\n         connection.sendRpcRequest(call);                 // send the rpc request\n       } catch (RejectedExecutionException e) {\n         throw new IOException(\"connection has been closed\", e);\n       } catch (InterruptedException e) {\n         Thread.currentThread().interrupt();\n         LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n         throw new IOException(e);\n       }\n     } catch(Exception e) {\n       if (isAsynchronousMode()) {\n         releaseAsyncCall();\n       }\n       throw e;\n     }\n \n     if (isAsynchronousMode()) {\n       final AsyncGet\u003cWritable, IOException\u003e asyncGet\n           \u003d new AsyncGet\u003cWritable, IOException\u003e() {\n         @Override\n         public Writable get(long timeout, TimeUnit unit)\n             throws IOException, TimeoutException{\n           boolean done \u003d true;\n           try {\n             final Writable w \u003d getRpcResponse(call, connection, timeout, unit);\n             if (w \u003d\u003d null) {\n               done \u003d false;\n               throw new TimeoutException(call + \" timed out \"\n                   + timeout + \" \" + unit);\n             }\n             return w;\n           } finally {\n             if (done) {\n               releaseAsyncCall();\n             }\n           }\n         }\n+\n+        @Override\n+        public boolean isDone() {\n+          synchronized (call) {\n+            return call.done;\n+          }\n+        }\n       };\n \n-      ASYNC_RPC_RESPONSE.set(new AsyncGetFuture\u003c\u003e(asyncGet));\n+      ASYNC_RPC_RESPONSE.set(asyncGet);\n       return null;\n     } else {\n       return getRpcResponse(call, connection, -1, null);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n\n    try {\n      checkAsyncCall();\n      try {\n        connection.sendRpcRequest(call);                 // send the rpc request\n      } catch (RejectedExecutionException e) {\n        throw new IOException(\"connection has been closed\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n        throw new IOException(e);\n      }\n    } catch(Exception e) {\n      if (isAsynchronousMode()) {\n        releaseAsyncCall();\n      }\n      throw e;\n    }\n\n    if (isAsynchronousMode()) {\n      final AsyncGet\u003cWritable, IOException\u003e asyncGet\n          \u003d new AsyncGet\u003cWritable, IOException\u003e() {\n        @Override\n        public Writable get(long timeout, TimeUnit unit)\n            throws IOException, TimeoutException{\n          boolean done \u003d true;\n          try {\n            final Writable w \u003d getRpcResponse(call, connection, timeout, unit);\n            if (w \u003d\u003d null) {\n              done \u003d false;\n              throw new TimeoutException(call + \" timed out \"\n                  + timeout + \" \" + unit);\n            }\n            return w;\n          } finally {\n            if (done) {\n              releaseAsyncCall();\n            }\n          }\n        }\n\n        @Override\n        public boolean isDone() {\n          synchronized (call) {\n            return call.done;\n          }\n        }\n      };\n\n      ASYNC_RPC_RESPONSE.set(asyncGet);\n      return null;\n    } else {\n      return getRpcResponse(call, connection, -1, null);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "574dcd34c0da1903d25e37dc5757642a584dc3d0": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Revert \"HADOOP-13168. Support Future.get with timeout in ipc async calls.\"\"\n\nThis reverts commit e4450d47f19131818e1c040b6bd8d85ae8250475.\n",
      "commitDate": "06/06/16 1:31 AM",
      "commitName": "574dcd34c0da1903d25e37dc5757642a584dc3d0",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "06/06/16 1:28 AM",
      "commitNameOld": "aa20fa150d522b9fe469dd99a8e24d7e27d888ea",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,54 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n         fallbackToSimpleAuth);\n \n     try {\n       checkAsyncCall();\n       try {\n         connection.sendRpcRequest(call);                 // send the rpc request\n       } catch (RejectedExecutionException e) {\n         throw new IOException(\"connection has been closed\", e);\n       } catch (InterruptedException e) {\n         Thread.currentThread().interrupt();\n         LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n         throw new IOException(e);\n       }\n     } catch(Exception e) {\n       if (isAsynchronousMode()) {\n         releaseAsyncCall();\n       }\n       throw e;\n     }\n \n     if (isAsynchronousMode()) {\n-      Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n-        private final AtomicBoolean callled \u003d new AtomicBoolean(false);\n+      final AsyncGet\u003cWritable, IOException\u003e asyncGet\n+          \u003d new AsyncGet\u003cWritable, IOException\u003e() {\n         @Override\n-        public Writable get() throws InterruptedException, ExecutionException {\n-          if (callled.compareAndSet(false, true)) {\n-            try {\n-              set(getRpcResponse(call, connection));\n-            } catch (IOException ie) {\n-              setException(ie);\n-            } finally {\n+        public Writable get(long timeout, TimeUnit unit)\n+            throws IOException, TimeoutException{\n+          boolean done \u003d true;\n+          try {\n+            final Writable w \u003d getRpcResponse(call, connection, timeout, unit);\n+            if (w \u003d\u003d null) {\n+              done \u003d false;\n+              throw new TimeoutException(call + \" timed out \"\n+                  + timeout + \" \" + unit);\n+            }\n+            return w;\n+          } finally {\n+            if (done) {\n               releaseAsyncCall();\n             }\n           }\n-          return super.get();\n         }\n       };\n \n-      RETURN_RPC_RESPONSE.set(returnFuture);\n+      ASYNC_RPC_RESPONSE.set(new AsyncGetFuture\u003c\u003e(asyncGet));\n       return null;\n     } else {\n-      return getRpcResponse(call, connection);\n+      return getRpcResponse(call, connection, -1, null);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n\n    try {\n      checkAsyncCall();\n      try {\n        connection.sendRpcRequest(call);                 // send the rpc request\n      } catch (RejectedExecutionException e) {\n        throw new IOException(\"connection has been closed\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n        throw new IOException(e);\n      }\n    } catch(Exception e) {\n      if (isAsynchronousMode()) {\n        releaseAsyncCall();\n      }\n      throw e;\n    }\n\n    if (isAsynchronousMode()) {\n      final AsyncGet\u003cWritable, IOException\u003e asyncGet\n          \u003d new AsyncGet\u003cWritable, IOException\u003e() {\n        @Override\n        public Writable get(long timeout, TimeUnit unit)\n            throws IOException, TimeoutException{\n          boolean done \u003d true;\n          try {\n            final Writable w \u003d getRpcResponse(call, connection, timeout, unit);\n            if (w \u003d\u003d null) {\n              done \u003d false;\n              throw new TimeoutException(call + \" timed out \"\n                  + timeout + \" \" + unit);\n            }\n            return w;\n          } finally {\n            if (done) {\n              releaseAsyncCall();\n            }\n          }\n        }\n      };\n\n      ASYNC_RPC_RESPONSE.set(new AsyncGetFuture\u003c\u003e(asyncGet));\n      return null;\n    } else {\n      return getRpcResponse(call, connection, -1, null);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "aa20fa150d522b9fe469dd99a8e24d7e27d888ea": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Revert \"HADOOP-12957. Limit the number of outstanding async calls.  Contributed by Xiaobing Zhou\"\"\n\nThis reverts commit 4d36b221a24e3b626bb91093b0bb0fd377061cae.\n",
      "commitDate": "06/06/16 1:28 AM",
      "commitName": "aa20fa150d522b9fe469dd99a8e24d7e27d888ea",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "06/06/16 1:28 AM",
      "commitNameOld": "eded3d109e4c5225d8c5cd3c2d82e7ac93841263",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,49 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n         fallbackToSimpleAuth);\n+\n     try {\n-      connection.sendRpcRequest(call);                 // send the rpc request\n-    } catch (RejectedExecutionException e) {\n-      throw new IOException(\"connection has been closed\", e);\n-    } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-      LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n-      throw new IOException(e);\n+      checkAsyncCall();\n+      try {\n+        connection.sendRpcRequest(call);                 // send the rpc request\n+      } catch (RejectedExecutionException e) {\n+        throw new IOException(\"connection has been closed\", e);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n+        throw new IOException(e);\n+      }\n+    } catch(Exception e) {\n+      if (isAsynchronousMode()) {\n+        releaseAsyncCall();\n+      }\n+      throw e;\n     }\n \n     if (isAsynchronousMode()) {\n       Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n+        private final AtomicBoolean callled \u003d new AtomicBoolean(false);\n         @Override\n         public Writable get() throws InterruptedException, ExecutionException {\n-          try {\n-            set(getRpcResponse(call, connection));\n-          } catch (IOException ie) {\n-            setException(ie);\n+          if (callled.compareAndSet(false, true)) {\n+            try {\n+              set(getRpcResponse(call, connection));\n+            } catch (IOException ie) {\n+              setException(ie);\n+            } finally {\n+              releaseAsyncCall();\n+            }\n           }\n           return super.get();\n         }\n       };\n \n       RETURN_RPC_RESPONSE.set(returnFuture);\n       return null;\n     } else {\n       return getRpcResponse(call, connection);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n\n    try {\n      checkAsyncCall();\n      try {\n        connection.sendRpcRequest(call);                 // send the rpc request\n      } catch (RejectedExecutionException e) {\n        throw new IOException(\"connection has been closed\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n        throw new IOException(e);\n      }\n    } catch(Exception e) {\n      if (isAsynchronousMode()) {\n        releaseAsyncCall();\n      }\n      throw e;\n    }\n\n    if (isAsynchronousMode()) {\n      Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n        private final AtomicBoolean callled \u003d new AtomicBoolean(false);\n        @Override\n        public Writable get() throws InterruptedException, ExecutionException {\n          if (callled.compareAndSet(false, true)) {\n            try {\n              set(getRpcResponse(call, connection));\n            } catch (IOException ie) {\n              setException(ie);\n            } finally {\n              releaseAsyncCall();\n            }\n          }\n          return super.get();\n        }\n      };\n\n      RETURN_RPC_RESPONSE.set(returnFuture);\n      return null;\n    } else {\n      return getRpcResponse(call, connection);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "eded3d109e4c5225d8c5cd3c2d82e7ac93841263": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Revert \"HDFS-10224. Implement asynchronous rename for DistributedFileSystem.  Contributed by Xiaobing Zhou\"\"\n\nThis reverts commit 106234d873c60fa52cd0d812fb1cdc0c6b998a6d.\n",
      "commitDate": "06/06/16 1:28 AM",
      "commitName": "eded3d109e4c5225d8c5cd3c2d82e7ac93841263",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "03/06/16 6:09 PM",
      "commitNameOld": "106234d873c60fa52cd0d812fb1cdc0c6b998a6d",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 2.3,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n         fallbackToSimpleAuth);\n     try {\n       connection.sendRpcRequest(call);                 // send the rpc request\n     } catch (RejectedExecutionException e) {\n       throw new IOException(\"connection has been closed\", e);\n     } catch (InterruptedException e) {\n       Thread.currentThread().interrupt();\n       LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n       throw new IOException(e);\n     }\n \n     if (isAsynchronousMode()) {\n       Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n         @Override\n         public Writable get() throws InterruptedException, ExecutionException {\n           try {\n             set(getRpcResponse(call, connection));\n           } catch (IOException ie) {\n             setException(ie);\n           }\n           return super.get();\n         }\n       };\n \n-      returnValue.set(returnFuture);\n+      RETURN_RPC_RESPONSE.set(returnFuture);\n       return null;\n     } else {\n       return getRpcResponse(call, connection);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n    try {\n      connection.sendRpcRequest(call);                 // send the rpc request\n    } catch (RejectedExecutionException e) {\n      throw new IOException(\"connection has been closed\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n      throw new IOException(e);\n    }\n\n    if (isAsynchronousMode()) {\n      Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n        @Override\n        public Writable get() throws InterruptedException, ExecutionException {\n          try {\n            set(getRpcResponse(call, connection));\n          } catch (IOException ie) {\n            setException(ie);\n          }\n          return super.get();\n        }\n      };\n\n      RETURN_RPC_RESPONSE.set(returnFuture);\n      return null;\n    } else {\n      return getRpcResponse(call, connection);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "106234d873c60fa52cd0d812fb1cdc0c6b998a6d": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-10224. Implement asynchronous rename for DistributedFileSystem.  Contributed by Xiaobing Zhou\"\n\nThis reverts commit fc94810d3f537e51e826fc21ade7867892b9d8dc.\n",
      "commitDate": "03/06/16 6:09 PM",
      "commitName": "106234d873c60fa52cd0d812fb1cdc0c6b998a6d",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "03/06/16 6:09 PM",
      "commitNameOld": "4d36b221a24e3b626bb91093b0bb0fd377061cae",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n         fallbackToSimpleAuth);\n     try {\n       connection.sendRpcRequest(call);                 // send the rpc request\n     } catch (RejectedExecutionException e) {\n       throw new IOException(\"connection has been closed\", e);\n     } catch (InterruptedException e) {\n       Thread.currentThread().interrupt();\n       LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n       throw new IOException(e);\n     }\n \n     if (isAsynchronousMode()) {\n       Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n         @Override\n         public Writable get() throws InterruptedException, ExecutionException {\n           try {\n             set(getRpcResponse(call, connection));\n           } catch (IOException ie) {\n             setException(ie);\n           }\n           return super.get();\n         }\n       };\n \n-      RETURN_RPC_RESPONSE.set(returnFuture);\n+      returnValue.set(returnFuture);\n       return null;\n     } else {\n       return getRpcResponse(call, connection);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n    try {\n      connection.sendRpcRequest(call);                 // send the rpc request\n    } catch (RejectedExecutionException e) {\n      throw new IOException(\"connection has been closed\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n      throw new IOException(e);\n    }\n\n    if (isAsynchronousMode()) {\n      Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n        @Override\n        public Writable get() throws InterruptedException, ExecutionException {\n          try {\n            set(getRpcResponse(call, connection));\n          } catch (IOException ie) {\n            setException(ie);\n          }\n          return super.get();\n        }\n      };\n\n      returnValue.set(returnFuture);\n      return null;\n    } else {\n      return getRpcResponse(call, connection);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "4d36b221a24e3b626bb91093b0bb0fd377061cae": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-12957. Limit the number of outstanding async calls.  Contributed by Xiaobing Zhou\"\n\nThis reverts commit 1b9f18623ab55507bea94888317c7d63d0f4a6f2.\n",
      "commitDate": "03/06/16 6:09 PM",
      "commitName": "4d36b221a24e3b626bb91093b0bb0fd377061cae",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "03/06/16 6:09 PM",
      "commitNameOld": "e4450d47f19131818e1c040b6bd8d85ae8250475",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,35 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n         fallbackToSimpleAuth);\n-\n     try {\n-      checkAsyncCall();\n-      try {\n-        connection.sendRpcRequest(call);                 // send the rpc request\n-      } catch (RejectedExecutionException e) {\n-        throw new IOException(\"connection has been closed\", e);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-        LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n-        throw new IOException(e);\n-      }\n-    } catch(Exception e) {\n-      if (isAsynchronousMode()) {\n-        releaseAsyncCall();\n-      }\n-      throw e;\n+      connection.sendRpcRequest(call);                 // send the rpc request\n+    } catch (RejectedExecutionException e) {\n+      throw new IOException(\"connection has been closed\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n+      throw new IOException(e);\n     }\n \n     if (isAsynchronousMode()) {\n       Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n-        private final AtomicBoolean callled \u003d new AtomicBoolean(false);\n         @Override\n         public Writable get() throws InterruptedException, ExecutionException {\n-          if (callled.compareAndSet(false, true)) {\n-            try {\n-              set(getRpcResponse(call, connection));\n-            } catch (IOException ie) {\n-              setException(ie);\n-            } finally {\n-              releaseAsyncCall();\n-            }\n+          try {\n+            set(getRpcResponse(call, connection));\n+          } catch (IOException ie) {\n+            setException(ie);\n           }\n           return super.get();\n         }\n       };\n \n       RETURN_RPC_RESPONSE.set(returnFuture);\n       return null;\n     } else {\n       return getRpcResponse(call, connection);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n    try {\n      connection.sendRpcRequest(call);                 // send the rpc request\n    } catch (RejectedExecutionException e) {\n      throw new IOException(\"connection has been closed\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n      throw new IOException(e);\n    }\n\n    if (isAsynchronousMode()) {\n      Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n        @Override\n        public Writable get() throws InterruptedException, ExecutionException {\n          try {\n            set(getRpcResponse(call, connection));\n          } catch (IOException ie) {\n            setException(ie);\n          }\n          return super.get();\n        }\n      };\n\n      RETURN_RPC_RESPONSE.set(returnFuture);\n      return null;\n    } else {\n      return getRpcResponse(call, connection);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "e4450d47f19131818e1c040b6bd8d85ae8250475": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13168. Support Future.get with timeout in ipc async calls.\"\n\nThis reverts commit 42c22f7e3d6e88bf1115f617f6e803288886d1ac.\n",
      "commitDate": "03/06/16 6:09 PM",
      "commitName": "e4450d47f19131818e1c040b6bd8d85ae8250475",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "03/06/16 6:09 PM",
      "commitNameOld": "5360da8bd9f720384860f411bee081aef13b4bd4",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,49 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n         fallbackToSimpleAuth);\n \n     try {\n       checkAsyncCall();\n       try {\n         connection.sendRpcRequest(call);                 // send the rpc request\n       } catch (RejectedExecutionException e) {\n         throw new IOException(\"connection has been closed\", e);\n       } catch (InterruptedException e) {\n         Thread.currentThread().interrupt();\n         LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n         throw new IOException(e);\n       }\n     } catch(Exception e) {\n       if (isAsynchronousMode()) {\n         releaseAsyncCall();\n       }\n       throw e;\n     }\n \n     if (isAsynchronousMode()) {\n-      final AsyncGet\u003cWritable, IOException\u003e asyncGet\n-          \u003d new AsyncGet\u003cWritable, IOException\u003e() {\n+      Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n+        private final AtomicBoolean callled \u003d new AtomicBoolean(false);\n         @Override\n-        public Writable get(long timeout, TimeUnit unit)\n-            throws IOException, TimeoutException{\n-          boolean done \u003d true;\n-          try {\n-            final Writable w \u003d getRpcResponse(call, connection, timeout, unit);\n-            if (w \u003d\u003d null) {\n-              done \u003d false;\n-              throw new TimeoutException(call + \" timed out \"\n-                  + timeout + \" \" + unit);\n-            }\n-            return w;\n-          } finally {\n-            if (done) {\n+        public Writable get() throws InterruptedException, ExecutionException {\n+          if (callled.compareAndSet(false, true)) {\n+            try {\n+              set(getRpcResponse(call, connection));\n+            } catch (IOException ie) {\n+              setException(ie);\n+            } finally {\n               releaseAsyncCall();\n             }\n           }\n+          return super.get();\n         }\n       };\n \n-      ASYNC_RPC_RESPONSE.set(new AsyncGetFuture\u003c\u003e(asyncGet));\n+      RETURN_RPC_RESPONSE.set(returnFuture);\n       return null;\n     } else {\n-      return getRpcResponse(call, connection, -1, null);\n+      return getRpcResponse(call, connection);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n\n    try {\n      checkAsyncCall();\n      try {\n        connection.sendRpcRequest(call);                 // send the rpc request\n      } catch (RejectedExecutionException e) {\n        throw new IOException(\"connection has been closed\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n        throw new IOException(e);\n      }\n    } catch(Exception e) {\n      if (isAsynchronousMode()) {\n        releaseAsyncCall();\n      }\n      throw e;\n    }\n\n    if (isAsynchronousMode()) {\n      Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n        private final AtomicBoolean callled \u003d new AtomicBoolean(false);\n        @Override\n        public Writable get() throws InterruptedException, ExecutionException {\n          if (callled.compareAndSet(false, true)) {\n            try {\n              set(getRpcResponse(call, connection));\n            } catch (IOException ie) {\n              setException(ie);\n            } finally {\n              releaseAsyncCall();\n            }\n          }\n          return super.get();\n        }\n      };\n\n      RETURN_RPC_RESPONSE.set(returnFuture);\n      return null;\n    } else {\n      return getRpcResponse(call, connection);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "5360da8bd9f720384860f411bee081aef13b4bd4": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13226 Support async call retry and failover.\"\n\nThis reverts commit 83f2f78c118a7e52aba5104bd97b0acedc96be7b.\n",
      "commitDate": "03/06/16 6:09 PM",
      "commitName": "5360da8bd9f720384860f411bee081aef13b4bd4",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "31/05/16 4:30 PM",
      "commitNameOld": "83f2f78c118a7e52aba5104bd97b0acedc96be7b",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 3.07,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,54 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n         fallbackToSimpleAuth);\n \n     try {\n       checkAsyncCall();\n       try {\n         connection.sendRpcRequest(call);                 // send the rpc request\n       } catch (RejectedExecutionException e) {\n         throw new IOException(\"connection has been closed\", e);\n       } catch (InterruptedException e) {\n         Thread.currentThread().interrupt();\n         LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n         throw new IOException(e);\n       }\n     } catch(Exception e) {\n       if (isAsynchronousMode()) {\n         releaseAsyncCall();\n       }\n       throw e;\n     }\n \n     if (isAsynchronousMode()) {\n       final AsyncGet\u003cWritable, IOException\u003e asyncGet\n           \u003d new AsyncGet\u003cWritable, IOException\u003e() {\n         @Override\n         public Writable get(long timeout, TimeUnit unit)\n             throws IOException, TimeoutException{\n           boolean done \u003d true;\n           try {\n             final Writable w \u003d getRpcResponse(call, connection, timeout, unit);\n             if (w \u003d\u003d null) {\n               done \u003d false;\n               throw new TimeoutException(call + \" timed out \"\n                   + timeout + \" \" + unit);\n             }\n             return w;\n           } finally {\n             if (done) {\n               releaseAsyncCall();\n             }\n           }\n         }\n-\n-        @Override\n-        public boolean isDone() {\n-          synchronized (call) {\n-            return call.done;\n-          }\n-        }\n       };\n \n-      ASYNC_RPC_RESPONSE.set(asyncGet);\n+      ASYNC_RPC_RESPONSE.set(new AsyncGetFuture\u003c\u003e(asyncGet));\n       return null;\n     } else {\n       return getRpcResponse(call, connection, -1, null);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n\n    try {\n      checkAsyncCall();\n      try {\n        connection.sendRpcRequest(call);                 // send the rpc request\n      } catch (RejectedExecutionException e) {\n        throw new IOException(\"connection has been closed\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n        throw new IOException(e);\n      }\n    } catch(Exception e) {\n      if (isAsynchronousMode()) {\n        releaseAsyncCall();\n      }\n      throw e;\n    }\n\n    if (isAsynchronousMode()) {\n      final AsyncGet\u003cWritable, IOException\u003e asyncGet\n          \u003d new AsyncGet\u003cWritable, IOException\u003e() {\n        @Override\n        public Writable get(long timeout, TimeUnit unit)\n            throws IOException, TimeoutException{\n          boolean done \u003d true;\n          try {\n            final Writable w \u003d getRpcResponse(call, connection, timeout, unit);\n            if (w \u003d\u003d null) {\n              done \u003d false;\n              throw new TimeoutException(call + \" timed out \"\n                  + timeout + \" \" + unit);\n            }\n            return w;\n          } finally {\n            if (done) {\n              releaseAsyncCall();\n            }\n          }\n        }\n      };\n\n      ASYNC_RPC_RESPONSE.set(new AsyncGetFuture\u003c\u003e(asyncGet));\n      return null;\n    } else {\n      return getRpcResponse(call, connection, -1, null);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "83f2f78c118a7e52aba5104bd97b0acedc96be7b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13226 Support async call retry and failover.\n",
      "commitDate": "31/05/16 4:30 PM",
      "commitName": "83f2f78c118a7e52aba5104bd97b0acedc96be7b",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "19/05/16 3:34 PM",
      "commitNameOld": "42c22f7e3d6e88bf1115f617f6e803288886d1ac",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 12.04,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,61 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n         fallbackToSimpleAuth);\n \n     try {\n       checkAsyncCall();\n       try {\n         connection.sendRpcRequest(call);                 // send the rpc request\n       } catch (RejectedExecutionException e) {\n         throw new IOException(\"connection has been closed\", e);\n       } catch (InterruptedException e) {\n         Thread.currentThread().interrupt();\n         LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n         throw new IOException(e);\n       }\n     } catch(Exception e) {\n       if (isAsynchronousMode()) {\n         releaseAsyncCall();\n       }\n       throw e;\n     }\n \n     if (isAsynchronousMode()) {\n       final AsyncGet\u003cWritable, IOException\u003e asyncGet\n           \u003d new AsyncGet\u003cWritable, IOException\u003e() {\n         @Override\n         public Writable get(long timeout, TimeUnit unit)\n             throws IOException, TimeoutException{\n           boolean done \u003d true;\n           try {\n             final Writable w \u003d getRpcResponse(call, connection, timeout, unit);\n             if (w \u003d\u003d null) {\n               done \u003d false;\n               throw new TimeoutException(call + \" timed out \"\n                   + timeout + \" \" + unit);\n             }\n             return w;\n           } finally {\n             if (done) {\n               releaseAsyncCall();\n             }\n           }\n         }\n+\n+        @Override\n+        public boolean isDone() {\n+          synchronized (call) {\n+            return call.done;\n+          }\n+        }\n       };\n \n-      ASYNC_RPC_RESPONSE.set(new AsyncGetFuture\u003c\u003e(asyncGet));\n+      ASYNC_RPC_RESPONSE.set(asyncGet);\n       return null;\n     } else {\n       return getRpcResponse(call, connection, -1, null);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n\n    try {\n      checkAsyncCall();\n      try {\n        connection.sendRpcRequest(call);                 // send the rpc request\n      } catch (RejectedExecutionException e) {\n        throw new IOException(\"connection has been closed\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n        throw new IOException(e);\n      }\n    } catch(Exception e) {\n      if (isAsynchronousMode()) {\n        releaseAsyncCall();\n      }\n      throw e;\n    }\n\n    if (isAsynchronousMode()) {\n      final AsyncGet\u003cWritable, IOException\u003e asyncGet\n          \u003d new AsyncGet\u003cWritable, IOException\u003e() {\n        @Override\n        public Writable get(long timeout, TimeUnit unit)\n            throws IOException, TimeoutException{\n          boolean done \u003d true;\n          try {\n            final Writable w \u003d getRpcResponse(call, connection, timeout, unit);\n            if (w \u003d\u003d null) {\n              done \u003d false;\n              throw new TimeoutException(call + \" timed out \"\n                  + timeout + \" \" + unit);\n            }\n            return w;\n          } finally {\n            if (done) {\n              releaseAsyncCall();\n            }\n          }\n        }\n\n        @Override\n        public boolean isDone() {\n          synchronized (call) {\n            return call.done;\n          }\n        }\n      };\n\n      ASYNC_RPC_RESPONSE.set(asyncGet);\n      return null;\n    } else {\n      return getRpcResponse(call, connection, -1, null);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "42c22f7e3d6e88bf1115f617f6e803288886d1ac": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13168. Support Future.get with timeout in ipc async calls.\n",
      "commitDate": "19/05/16 3:34 PM",
      "commitName": "42c22f7e3d6e88bf1115f617f6e803288886d1ac",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "02/05/16 11:16 AM",
      "commitNameOld": "1b9f18623ab55507bea94888317c7d63d0f4a6f2",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 17.18,
      "commitsBetweenForRepo": 134,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,54 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n         fallbackToSimpleAuth);\n \n     try {\n       checkAsyncCall();\n       try {\n         connection.sendRpcRequest(call);                 // send the rpc request\n       } catch (RejectedExecutionException e) {\n         throw new IOException(\"connection has been closed\", e);\n       } catch (InterruptedException e) {\n         Thread.currentThread().interrupt();\n         LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n         throw new IOException(e);\n       }\n     } catch(Exception e) {\n       if (isAsynchronousMode()) {\n         releaseAsyncCall();\n       }\n       throw e;\n     }\n \n     if (isAsynchronousMode()) {\n-      Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n-        private final AtomicBoolean callled \u003d new AtomicBoolean(false);\n+      final AsyncGet\u003cWritable, IOException\u003e asyncGet\n+          \u003d new AsyncGet\u003cWritable, IOException\u003e() {\n         @Override\n-        public Writable get() throws InterruptedException, ExecutionException {\n-          if (callled.compareAndSet(false, true)) {\n-            try {\n-              set(getRpcResponse(call, connection));\n-            } catch (IOException ie) {\n-              setException(ie);\n-            } finally {\n+        public Writable get(long timeout, TimeUnit unit)\n+            throws IOException, TimeoutException{\n+          boolean done \u003d true;\n+          try {\n+            final Writable w \u003d getRpcResponse(call, connection, timeout, unit);\n+            if (w \u003d\u003d null) {\n+              done \u003d false;\n+              throw new TimeoutException(call + \" timed out \"\n+                  + timeout + \" \" + unit);\n+            }\n+            return w;\n+          } finally {\n+            if (done) {\n               releaseAsyncCall();\n             }\n           }\n-          return super.get();\n         }\n       };\n \n-      RETURN_RPC_RESPONSE.set(returnFuture);\n+      ASYNC_RPC_RESPONSE.set(new AsyncGetFuture\u003c\u003e(asyncGet));\n       return null;\n     } else {\n-      return getRpcResponse(call, connection);\n+      return getRpcResponse(call, connection, -1, null);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n\n    try {\n      checkAsyncCall();\n      try {\n        connection.sendRpcRequest(call);                 // send the rpc request\n      } catch (RejectedExecutionException e) {\n        throw new IOException(\"connection has been closed\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n        throw new IOException(e);\n      }\n    } catch(Exception e) {\n      if (isAsynchronousMode()) {\n        releaseAsyncCall();\n      }\n      throw e;\n    }\n\n    if (isAsynchronousMode()) {\n      final AsyncGet\u003cWritable, IOException\u003e asyncGet\n          \u003d new AsyncGet\u003cWritable, IOException\u003e() {\n        @Override\n        public Writable get(long timeout, TimeUnit unit)\n            throws IOException, TimeoutException{\n          boolean done \u003d true;\n          try {\n            final Writable w \u003d getRpcResponse(call, connection, timeout, unit);\n            if (w \u003d\u003d null) {\n              done \u003d false;\n              throw new TimeoutException(call + \" timed out \"\n                  + timeout + \" \" + unit);\n            }\n            return w;\n          } finally {\n            if (done) {\n              releaseAsyncCall();\n            }\n          }\n        }\n      };\n\n      ASYNC_RPC_RESPONSE.set(new AsyncGetFuture\u003c\u003e(asyncGet));\n      return null;\n    } else {\n      return getRpcResponse(call, connection, -1, null);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "1b9f18623ab55507bea94888317c7d63d0f4a6f2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12957. Limit the number of outstanding async calls.  Contributed by Xiaobing Zhou\n",
      "commitDate": "02/05/16 11:16 AM",
      "commitName": "1b9f18623ab55507bea94888317c7d63d0f4a6f2",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "26/04/16 5:10 PM",
      "commitNameOld": "fc94810d3f537e51e826fc21ade7867892b9d8dc",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 5.75,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,49 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n         fallbackToSimpleAuth);\n+\n     try {\n-      connection.sendRpcRequest(call);                 // send the rpc request\n-    } catch (RejectedExecutionException e) {\n-      throw new IOException(\"connection has been closed\", e);\n-    } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-      LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n-      throw new IOException(e);\n+      checkAsyncCall();\n+      try {\n+        connection.sendRpcRequest(call);                 // send the rpc request\n+      } catch (RejectedExecutionException e) {\n+        throw new IOException(\"connection has been closed\", e);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n+        throw new IOException(e);\n+      }\n+    } catch(Exception e) {\n+      if (isAsynchronousMode()) {\n+        releaseAsyncCall();\n+      }\n+      throw e;\n     }\n \n     if (isAsynchronousMode()) {\n       Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n+        private final AtomicBoolean callled \u003d new AtomicBoolean(false);\n         @Override\n         public Writable get() throws InterruptedException, ExecutionException {\n-          try {\n-            set(getRpcResponse(call, connection));\n-          } catch (IOException ie) {\n-            setException(ie);\n+          if (callled.compareAndSet(false, true)) {\n+            try {\n+              set(getRpcResponse(call, connection));\n+            } catch (IOException ie) {\n+              setException(ie);\n+            } finally {\n+              releaseAsyncCall();\n+            }\n           }\n           return super.get();\n         }\n       };\n \n       RETURN_RPC_RESPONSE.set(returnFuture);\n       return null;\n     } else {\n       return getRpcResponse(call, connection);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n\n    try {\n      checkAsyncCall();\n      try {\n        connection.sendRpcRequest(call);                 // send the rpc request\n      } catch (RejectedExecutionException e) {\n        throw new IOException(\"connection has been closed\", e);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n        throw new IOException(e);\n      }\n    } catch(Exception e) {\n      if (isAsynchronousMode()) {\n        releaseAsyncCall();\n      }\n      throw e;\n    }\n\n    if (isAsynchronousMode()) {\n      Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n        private final AtomicBoolean callled \u003d new AtomicBoolean(false);\n        @Override\n        public Writable get() throws InterruptedException, ExecutionException {\n          if (callled.compareAndSet(false, true)) {\n            try {\n              set(getRpcResponse(call, connection));\n            } catch (IOException ie) {\n              setException(ie);\n            } finally {\n              releaseAsyncCall();\n            }\n          }\n          return super.get();\n        }\n      };\n\n      RETURN_RPC_RESPONSE.set(returnFuture);\n      return null;\n    } else {\n      return getRpcResponse(call, connection);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "fc94810d3f537e51e826fc21ade7867892b9d8dc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10224. Implement asynchronous rename for DistributedFileSystem.  Contributed by Xiaobing Zhou\n",
      "commitDate": "26/04/16 5:10 PM",
      "commitName": "fc94810d3f537e51e826fc21ade7867892b9d8dc",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "14/04/16 2:35 AM",
      "commitNameOld": "40211d1f0a3e4546eab076e10be8937853490e5e",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 12.61,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n         fallbackToSimpleAuth);\n     try {\n       connection.sendRpcRequest(call);                 // send the rpc request\n     } catch (RejectedExecutionException e) {\n       throw new IOException(\"connection has been closed\", e);\n     } catch (InterruptedException e) {\n       Thread.currentThread().interrupt();\n       LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n       throw new IOException(e);\n     }\n \n     if (isAsynchronousMode()) {\n       Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n         @Override\n         public Writable get() throws InterruptedException, ExecutionException {\n           try {\n             set(getRpcResponse(call, connection));\n           } catch (IOException ie) {\n             setException(ie);\n           }\n           return super.get();\n         }\n       };\n \n-      returnValue.set(returnFuture);\n+      RETURN_RPC_RESPONSE.set(returnFuture);\n       return null;\n     } else {\n       return getRpcResponse(call, connection);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n    try {\n      connection.sendRpcRequest(call);                 // send the rpc request\n    } catch (RejectedExecutionException e) {\n      throw new IOException(\"connection has been closed\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n      throw new IOException(e);\n    }\n\n    if (isAsynchronousMode()) {\n      Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n        @Override\n        public Writable get() throws InterruptedException, ExecutionException {\n          try {\n            set(getRpcResponse(call, connection));\n          } catch (IOException ie) {\n            setException(ie);\n          }\n          return super.get();\n        }\n      };\n\n      RETURN_RPC_RESPONSE.set(returnFuture);\n      return null;\n    } else {\n      return getRpcResponse(call, connection);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "a62637a413ad88c4273d3251892b8fc1c05afa34": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12909. Change ipc.Client to support asynchronous calls.  Contributed by  Xiaobing Zhou\n",
      "commitDate": "06/04/16 11:02 PM",
      "commitName": "a62637a413ad88c4273d3251892b8fc1c05afa34",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "05/04/16 11:22 AM",
      "commitNameOld": "85ec5573eb9fd746a9295ecc6fe1ae683073aaf5",
      "commitAuthorOld": "Masatake Iwasaki",
      "daysBetweenCommits": 1.49,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,35 @@\n   Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n-    Connection connection \u003d getConnection(remoteId, call, serviceClass,\n-      fallbackToSimpleAuth);\n+    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n+        fallbackToSimpleAuth);\n     try {\n       connection.sendRpcRequest(call);                 // send the rpc request\n     } catch (RejectedExecutionException e) {\n       throw new IOException(\"connection has been closed\", e);\n     } catch (InterruptedException e) {\n       Thread.currentThread().interrupt();\n       LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n       throw new IOException(e);\n     }\n \n-    synchronized (call) {\n-      while (!call.done) {\n-        try {\n-          call.wait();                           // wait for the result\n-        } catch (InterruptedException ie) {\n-          Thread.currentThread().interrupt();\n-          throw new InterruptedIOException(\"Call interrupted\");\n+    if (isAsynchronousMode()) {\n+      Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n+        @Override\n+        public Writable get() throws InterruptedException, ExecutionException {\n+          try {\n+            set(getRpcResponse(call, connection));\n+          } catch (IOException ie) {\n+            setException(ie);\n+          }\n+          return super.get();\n         }\n-      }\n+      };\n \n-      if (call.error !\u003d null) {\n-        if (call.error instanceof RemoteException) {\n-          call.error.fillInStackTrace();\n-          throw call.error;\n-        } else { // local exception\n-          InetSocketAddress address \u003d connection.getRemoteAddress();\n-          throw NetUtils.wrapException(address.getHostName(),\n-                  address.getPort(),\n-                  NetUtils.getHostname(),\n-                  0,\n-                  call.error);\n-        }\n-      } else {\n-        return call.getRpcResponse();\n-      }\n+      returnValue.set(returnFuture);\n+      return null;\n+    } else {\n+      return getRpcResponse(call, connection);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    final Connection connection \u003d getConnection(remoteId, call, serviceClass,\n        fallbackToSimpleAuth);\n    try {\n      connection.sendRpcRequest(call);                 // send the rpc request\n    } catch (RejectedExecutionException e) {\n      throw new IOException(\"connection has been closed\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n      throw new IOException(e);\n    }\n\n    if (isAsynchronousMode()) {\n      Future\u003cWritable\u003e returnFuture \u003d new AbstractFuture\u003cWritable\u003e() {\n        @Override\n        public Writable get() throws InterruptedException, ExecutionException {\n          try {\n            set(getRpcResponse(call, connection));\n          } catch (IOException ie) {\n            setException(ie);\n          }\n          return super.get();\n        }\n      };\n\n      returnValue.set(returnFuture);\n      return null;\n    } else {\n      return getRpcResponse(call, connection);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "1898810cda83e6d273a2963b56ed499c0fb91118": {
      "type": "Ymodifierchange",
      "commitMessage": "HADOOP-12923. Move the test code in ipc.Client to test.\n",
      "commitDate": "14/03/16 3:48 PM",
      "commitName": "1898810cda83e6d273a2963b56ed499c0fb91118",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "11/03/16 9:00 AM",
      "commitNameOld": "754299695b778b9b602e46836c35a3ac9474d7f8",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 3.24,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n-  public Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n+  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     Connection connection \u003d getConnection(remoteId, call, serviceClass,\n       fallbackToSimpleAuth);\n     try {\n       connection.sendRpcRequest(call);                 // send the rpc request\n     } catch (RejectedExecutionException e) {\n       throw new IOException(\"connection has been closed\", e);\n     } catch (InterruptedException e) {\n       Thread.currentThread().interrupt();\n       LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n       throw new IOException(e);\n     }\n \n     synchronized (call) {\n       while (!call.done) {\n         try {\n           call.wait();                           // wait for the result\n         } catch (InterruptedException ie) {\n           Thread.currentThread().interrupt();\n           throw new InterruptedIOException(\"Call interrupted\");\n         }\n       }\n \n       if (call.error !\u003d null) {\n         if (call.error instanceof RemoteException) {\n           call.error.fillInStackTrace();\n           throw call.error;\n         } else { // local exception\n           InetSocketAddress address \u003d connection.getRemoteAddress();\n           throw NetUtils.wrapException(address.getHostName(),\n                   address.getPort(),\n                   NetUtils.getHostname(),\n                   0,\n                   call.error);\n         }\n       } else {\n         return call.getRpcResponse();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    Connection connection \u003d getConnection(remoteId, call, serviceClass,\n      fallbackToSimpleAuth);\n    try {\n      connection.sendRpcRequest(call);                 // send the rpc request\n    } catch (RejectedExecutionException e) {\n      throw new IOException(\"connection has been closed\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n      throw new IOException(e);\n    }\n\n    synchronized (call) {\n      while (!call.done) {\n        try {\n          call.wait();                           // wait for the result\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          throw new InterruptedIOException(\"Call interrupted\");\n        }\n      }\n\n      if (call.error !\u003d null) {\n        if (call.error instanceof RemoteException) {\n          call.error.fillInStackTrace();\n          throw call.error;\n        } else { // local exception\n          InetSocketAddress address \u003d connection.getRemoteAddress();\n          throw NetUtils.wrapException(address.getHostName(),\n                  address.getPort(),\n                  NetUtils.getHostname(),\n                  0,\n                  call.error);\n        }\n      } else {\n        return call.getRpcResponse();\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[]"
      }
    },
    "6144e0137bb51bd04b46ea5ce42c59c2d4f7657d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12464. Interrupted client may try to fail-over and retry. Contributed by Kihwal Lee.\n",
      "commitDate": "19/10/15 8:52 AM",
      "commitName": "6144e0137bb51bd04b46ea5ce42c59c2d4f7657d",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "15/10/15 11:43 AM",
      "commitNameOld": "8d2d3eb7bb938cc06ea3cc74040cfe0be13a2ba8",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 3.88,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,43 @@\n   public Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n       ConnectionId remoteId, int serviceClass,\n       AtomicBoolean fallbackToSimpleAuth) throws IOException {\n     final Call call \u003d createCall(rpcKind, rpcRequest);\n     Connection connection \u003d getConnection(remoteId, call, serviceClass,\n       fallbackToSimpleAuth);\n     try {\n       connection.sendRpcRequest(call);                 // send the rpc request\n     } catch (RejectedExecutionException e) {\n       throw new IOException(\"connection has been closed\", e);\n     } catch (InterruptedException e) {\n       Thread.currentThread().interrupt();\n       LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n       throw new IOException(e);\n     }\n \n-    boolean interrupted \u003d false;\n     synchronized (call) {\n       while (!call.done) {\n         try {\n           call.wait();                           // wait for the result\n         } catch (InterruptedException ie) {\n-          // save the fact that we were interrupted\n-          interrupted \u003d true;\n+          Thread.currentThread().interrupt();\n+          throw new InterruptedIOException(\"Call interrupted\");\n         }\n       }\n \n-      if (interrupted) {\n-        // set the interrupt flag now that we are done waiting\n-        Thread.currentThread().interrupt();\n-      }\n-\n       if (call.error !\u003d null) {\n         if (call.error instanceof RemoteException) {\n           call.error.fillInStackTrace();\n           throw call.error;\n         } else { // local exception\n           InetSocketAddress address \u003d connection.getRemoteAddress();\n           throw NetUtils.wrapException(address.getHostName(),\n                   address.getPort(),\n                   NetUtils.getHostname(),\n                   0,\n                   call.error);\n         }\n       } else {\n         return call.getRpcResponse();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    Connection connection \u003d getConnection(remoteId, call, serviceClass,\n      fallbackToSimpleAuth);\n    try {\n      connection.sendRpcRequest(call);                 // send the rpc request\n    } catch (RejectedExecutionException e) {\n      throw new IOException(\"connection has been closed\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n      throw new IOException(e);\n    }\n\n    synchronized (call) {\n      while (!call.done) {\n        try {\n          call.wait();                           // wait for the result\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          throw new InterruptedIOException(\"Call interrupted\");\n        }\n      }\n\n      if (call.error !\u003d null) {\n        if (call.error instanceof RemoteException) {\n          call.error.fillInStackTrace();\n          throw call.error;\n        } else { // local exception\n          InetSocketAddress address \u003d connection.getRemoteAddress();\n          throw NetUtils.wrapException(address.getHostName(),\n                  address.getPort(),\n                  NetUtils.getHostname(),\n                  0,\n                  call.error);\n        }\n      } else {\n        return call.getRpcResponse();\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java",
      "extendedDetails": {}
    },
    "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7073. Allow falling back to a non-SASL connection on DataTransferProtocol in several edge cases. Contributed by Chris Nauroth.\n",
      "commitDate": "19/09/14 9:23 PM",
      "commitName": "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5",
      "commitAuthor": "cnauroth",
      "diff": "@@ -0,0 +1,49 @@\n+  public Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n+      ConnectionId remoteId, int serviceClass,\n+      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n+    final Call call \u003d createCall(rpcKind, rpcRequest);\n+    Connection connection \u003d getConnection(remoteId, call, serviceClass,\n+      fallbackToSimpleAuth);\n+    try {\n+      connection.sendRpcRequest(call);                 // send the rpc request\n+    } catch (RejectedExecutionException e) {\n+      throw new IOException(\"connection has been closed\", e);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n+      throw new IOException(e);\n+    }\n+\n+    boolean interrupted \u003d false;\n+    synchronized (call) {\n+      while (!call.done) {\n+        try {\n+          call.wait();                           // wait for the result\n+        } catch (InterruptedException ie) {\n+          // save the fact that we were interrupted\n+          interrupted \u003d true;\n+        }\n+      }\n+\n+      if (interrupted) {\n+        // set the interrupt flag now that we are done waiting\n+        Thread.currentThread().interrupt();\n+      }\n+\n+      if (call.error !\u003d null) {\n+        if (call.error instanceof RemoteException) {\n+          call.error.fillInStackTrace();\n+          throw call.error;\n+        } else { // local exception\n+          InetSocketAddress address \u003d connection.getRemoteAddress();\n+          throw NetUtils.wrapException(address.getHostName(),\n+                  address.getPort(),\n+                  NetUtils.getHostname(),\n+                  0,\n+                  call.error);\n+        }\n+      } else {\n+        return call.getRpcResponse();\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Writable call(RPC.RpcKind rpcKind, Writable rpcRequest,\n      ConnectionId remoteId, int serviceClass,\n      AtomicBoolean fallbackToSimpleAuth) throws IOException {\n    final Call call \u003d createCall(rpcKind, rpcRequest);\n    Connection connection \u003d getConnection(remoteId, call, serviceClass,\n      fallbackToSimpleAuth);\n    try {\n      connection.sendRpcRequest(call);                 // send the rpc request\n    } catch (RejectedExecutionException e) {\n      throw new IOException(\"connection has been closed\", e);\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n      LOG.warn(\"interrupted waiting to send rpc request to server\", e);\n      throw new IOException(e);\n    }\n\n    boolean interrupted \u003d false;\n    synchronized (call) {\n      while (!call.done) {\n        try {\n          call.wait();                           // wait for the result\n        } catch (InterruptedException ie) {\n          // save the fact that we were interrupted\n          interrupted \u003d true;\n        }\n      }\n\n      if (interrupted) {\n        // set the interrupt flag now that we are done waiting\n        Thread.currentThread().interrupt();\n      }\n\n      if (call.error !\u003d null) {\n        if (call.error instanceof RemoteException) {\n          call.error.fillInStackTrace();\n          throw call.error;\n        } else { // local exception\n          InetSocketAddress address \u003d connection.getRemoteAddress();\n          throw NetUtils.wrapException(address.getHostName(),\n                  address.getPort(),\n                  NetUtils.getHostname(),\n                  0,\n                  call.error);\n        }\n      } else {\n        return call.getRpcResponse();\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java"
    }
  }
}