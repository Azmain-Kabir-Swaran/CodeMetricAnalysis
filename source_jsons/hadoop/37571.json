{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "QueueACLsManager.java",
  "functionName": "checkAccess",
  "functionId": "checkAccess___callerUGI-UserGroupInformation__acl-QueueACL__app-RMApp__remoteAddress-String__forwardedAddresses-List__String____targetQueue-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/QueueACLsManager.java",
  "functionStartLine": 110,
  "functionEndLine": 155,
  "numCommitsSeen": 9,
  "timeTaken": 2749,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "6bd130ea459f2327f344e7c04c616e30defc24dd",
    "7979939428ad5df213846e11bc1489bdf94ed9f8"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "6bd130ea459f2327f344e7c04c616e30defc24dd": "Ybodychange",
    "7979939428ad5df213846e11bc1489bdf94ed9f8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 386.26,
      "commitsBetweenForRepo": 2298,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,46 @@\n   public boolean checkAccess(UserGroupInformation callerUGI, QueueACL acl,\n       RMApp app, String remoteAddress, List\u003cString\u003e forwardedAddresses,\n       String targetQueue) {\n     if (!isACLsEnable) {\n       return true;\n     }\n \n     // Based on the discussion in YARN-5554 detail on why there are two\n     // versions:\n     // The access check inside these calls is currently scheduler dependent.\n     // This is due to the extra parameters needed for the CS case which are not\n     // in the version defined in the YarnScheduler interface. The second\n     // version is added for the moving the application case. The check has\n     // extra logging to distinguish between the queue not existing in the\n     // application move request case and the real access denied case.\n     if (scheduler instanceof CapacityScheduler) {\n-      CSQueue queue \u003d ((CapacityScheduler) scheduler).getQueue(targetQueue);\n+      CapacityScheduler cs \u003d ((CapacityScheduler) scheduler);\n+      CSQueue queue \u003d cs.getQueue(targetQueue);\n       if (queue \u003d\u003d null) {\n         LOG.warn(\"Target queue \" + targetQueue\n-            + \" does not exist while trying to move \"\n+            + (cs.isAmbiguous(targetQueue) ?\n+                \" is ambiguous while trying to move \" :\n+                \" does not exist while trying to move \")\n             + app.getApplicationId());\n         return false;\n       }\n       return authorizer.checkPermission(\n           new AccessRequest(queue.getPrivilegedEntity(), callerUGI,\n               SchedulerUtils.toAccessType(acl),\n               app.getApplicationId().toString(), app.getName(),\n               remoteAddress, forwardedAddresses));\n     } else if (scheduler instanceof FairScheduler) {\n       FSQueue queue \u003d ((FairScheduler) scheduler).getQueueManager().\n           getQueue(targetQueue);\n       if (queue \u003d\u003d null) {\n         LOG.warn(\"Target queue \" + targetQueue\n             + \" does not exist while trying to move \"\n             + app.getApplicationId());\n         return false;\n       }\n       return scheduler.checkAccess(callerUGI, acl, targetQueue);\n     } else {\n       // Any other scheduler just try\n       return scheduler.checkAccess(callerUGI, acl, targetQueue);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean checkAccess(UserGroupInformation callerUGI, QueueACL acl,\n      RMApp app, String remoteAddress, List\u003cString\u003e forwardedAddresses,\n      String targetQueue) {\n    if (!isACLsEnable) {\n      return true;\n    }\n\n    // Based on the discussion in YARN-5554 detail on why there are two\n    // versions:\n    // The access check inside these calls is currently scheduler dependent.\n    // This is due to the extra parameters needed for the CS case which are not\n    // in the version defined in the YarnScheduler interface. The second\n    // version is added for the moving the application case. The check has\n    // extra logging to distinguish between the queue not existing in the\n    // application move request case and the real access denied case.\n    if (scheduler instanceof CapacityScheduler) {\n      CapacityScheduler cs \u003d ((CapacityScheduler) scheduler);\n      CSQueue queue \u003d cs.getQueue(targetQueue);\n      if (queue \u003d\u003d null) {\n        LOG.warn(\"Target queue \" + targetQueue\n            + (cs.isAmbiguous(targetQueue) ?\n                \" is ambiguous while trying to move \" :\n                \" does not exist while trying to move \")\n            + app.getApplicationId());\n        return false;\n      }\n      return authorizer.checkPermission(\n          new AccessRequest(queue.getPrivilegedEntity(), callerUGI,\n              SchedulerUtils.toAccessType(acl),\n              app.getApplicationId().toString(), app.getName(),\n              remoteAddress, forwardedAddresses));\n    } else if (scheduler instanceof FairScheduler) {\n      FSQueue queue \u003d ((FairScheduler) scheduler).getQueueManager().\n          getQueue(targetQueue);\n      if (queue \u003d\u003d null) {\n        LOG.warn(\"Target queue \" + targetQueue\n            + \" does not exist while trying to move \"\n            + app.getApplicationId());\n        return false;\n      }\n      return scheduler.checkAccess(callerUGI, acl, targetQueue);\n    } else {\n      // Any other scheduler just try\n      return scheduler.checkAccess(callerUGI, acl, targetQueue);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/QueueACLsManager.java",
      "extendedDetails": {}
    },
    "6bd130ea459f2327f344e7c04c616e30defc24dd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8028. Support authorizeUserAccessToQueue in RMWebServices. Contributed by Wangda Tan.\n",
      "commitDate": "17/03/18 10:30 PM",
      "commitName": "6bd130ea459f2327f344e7c04c616e30defc24dd",
      "commitAuthor": "Sunil G",
      "commitDateOld": "11/01/17 2:34 PM",
      "commitNameOld": "7979939428ad5df213846e11bc1489bdf94ed9f8",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 430.29,
      "commitsBetweenForRepo": 2785,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,43 @@\n   public boolean checkAccess(UserGroupInformation callerUGI, QueueACL acl,\n       RMApp app, String remoteAddress, List\u003cString\u003e forwardedAddresses,\n       String targetQueue) {\n     if (!isACLsEnable) {\n       return true;\n     }\n \n     // Based on the discussion in YARN-5554 detail on why there are two\n     // versions:\n     // The access check inside these calls is currently scheduler dependent.\n     // This is due to the extra parameters needed for the CS case which are not\n     // in the version defined in the YarnScheduler interface. The second\n     // version is added for the moving the application case. The check has\n     // extra logging to distinguish between the queue not existing in the\n     // application move request case and the real access denied case.\n-\n     if (scheduler instanceof CapacityScheduler) {\n       CSQueue queue \u003d ((CapacityScheduler) scheduler).getQueue(targetQueue);\n       if (queue \u003d\u003d null) {\n         LOG.warn(\"Target queue \" + targetQueue\n             + \" does not exist while trying to move \"\n             + app.getApplicationId());\n         return false;\n       }\n       return authorizer.checkPermission(\n           new AccessRequest(queue.getPrivilegedEntity(), callerUGI,\n               SchedulerUtils.toAccessType(acl),\n               app.getApplicationId().toString(), app.getName(),\n               remoteAddress, forwardedAddresses));\n     } else if (scheduler instanceof FairScheduler) {\n       FSQueue queue \u003d ((FairScheduler) scheduler).getQueueManager().\n           getQueue(targetQueue);\n       if (queue \u003d\u003d null) {\n         LOG.warn(\"Target queue \" + targetQueue\n             + \" does not exist while trying to move \"\n             + app.getApplicationId());\n         return false;\n       }\n       return scheduler.checkAccess(callerUGI, acl, targetQueue);\n     } else {\n       // Any other scheduler just try\n       return scheduler.checkAccess(callerUGI, acl, targetQueue);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean checkAccess(UserGroupInformation callerUGI, QueueACL acl,\n      RMApp app, String remoteAddress, List\u003cString\u003e forwardedAddresses,\n      String targetQueue) {\n    if (!isACLsEnable) {\n      return true;\n    }\n\n    // Based on the discussion in YARN-5554 detail on why there are two\n    // versions:\n    // The access check inside these calls is currently scheduler dependent.\n    // This is due to the extra parameters needed for the CS case which are not\n    // in the version defined in the YarnScheduler interface. The second\n    // version is added for the moving the application case. The check has\n    // extra logging to distinguish between the queue not existing in the\n    // application move request case and the real access denied case.\n    if (scheduler instanceof CapacityScheduler) {\n      CSQueue queue \u003d ((CapacityScheduler) scheduler).getQueue(targetQueue);\n      if (queue \u003d\u003d null) {\n        LOG.warn(\"Target queue \" + targetQueue\n            + \" does not exist while trying to move \"\n            + app.getApplicationId());\n        return false;\n      }\n      return authorizer.checkPermission(\n          new AccessRequest(queue.getPrivilegedEntity(), callerUGI,\n              SchedulerUtils.toAccessType(acl),\n              app.getApplicationId().toString(), app.getName(),\n              remoteAddress, forwardedAddresses));\n    } else if (scheduler instanceof FairScheduler) {\n      FSQueue queue \u003d ((FairScheduler) scheduler).getQueueManager().\n          getQueue(targetQueue);\n      if (queue \u003d\u003d null) {\n        LOG.warn(\"Target queue \" + targetQueue\n            + \" does not exist while trying to move \"\n            + app.getApplicationId());\n        return false;\n      }\n      return scheduler.checkAccess(callerUGI, acl, targetQueue);\n    } else {\n      // Any other scheduler just try\n      return scheduler.checkAccess(callerUGI, acl, targetQueue);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/QueueACLsManager.java",
      "extendedDetails": {}
    },
    "7979939428ad5df213846e11bc1489bdf94ed9f8": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5554. MoveApplicationAcrossQueues does not check user permission on the target queue\n(Contributed by Wilfred Spiegelenburg via Daniel Templeton)\n",
      "commitDate": "11/01/17 2:34 PM",
      "commitName": "7979939428ad5df213846e11bc1489bdf94ed9f8",
      "commitAuthor": "Daniel Templeton",
      "diff": "@@ -0,0 +1,44 @@\n+  public boolean checkAccess(UserGroupInformation callerUGI, QueueACL acl,\n+      RMApp app, String remoteAddress, List\u003cString\u003e forwardedAddresses,\n+      String targetQueue) {\n+    if (!isACLsEnable) {\n+      return true;\n+    }\n+\n+    // Based on the discussion in YARN-5554 detail on why there are two\n+    // versions:\n+    // The access check inside these calls is currently scheduler dependent.\n+    // This is due to the extra parameters needed for the CS case which are not\n+    // in the version defined in the YarnScheduler interface. The second\n+    // version is added for the moving the application case. The check has\n+    // extra logging to distinguish between the queue not existing in the\n+    // application move request case and the real access denied case.\n+\n+    if (scheduler instanceof CapacityScheduler) {\n+      CSQueue queue \u003d ((CapacityScheduler) scheduler).getQueue(targetQueue);\n+      if (queue \u003d\u003d null) {\n+        LOG.warn(\"Target queue \" + targetQueue\n+            + \" does not exist while trying to move \"\n+            + app.getApplicationId());\n+        return false;\n+      }\n+      return authorizer.checkPermission(\n+          new AccessRequest(queue.getPrivilegedEntity(), callerUGI,\n+              SchedulerUtils.toAccessType(acl),\n+              app.getApplicationId().toString(), app.getName(),\n+              remoteAddress, forwardedAddresses));\n+    } else if (scheduler instanceof FairScheduler) {\n+      FSQueue queue \u003d ((FairScheduler) scheduler).getQueueManager().\n+          getQueue(targetQueue);\n+      if (queue \u003d\u003d null) {\n+        LOG.warn(\"Target queue \" + targetQueue\n+            + \" does not exist while trying to move \"\n+            + app.getApplicationId());\n+        return false;\n+      }\n+      return scheduler.checkAccess(callerUGI, acl, targetQueue);\n+    } else {\n+      // Any other scheduler just try\n+      return scheduler.checkAccess(callerUGI, acl, targetQueue);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean checkAccess(UserGroupInformation callerUGI, QueueACL acl,\n      RMApp app, String remoteAddress, List\u003cString\u003e forwardedAddresses,\n      String targetQueue) {\n    if (!isACLsEnable) {\n      return true;\n    }\n\n    // Based on the discussion in YARN-5554 detail on why there are two\n    // versions:\n    // The access check inside these calls is currently scheduler dependent.\n    // This is due to the extra parameters needed for the CS case which are not\n    // in the version defined in the YarnScheduler interface. The second\n    // version is added for the moving the application case. The check has\n    // extra logging to distinguish between the queue not existing in the\n    // application move request case and the real access denied case.\n\n    if (scheduler instanceof CapacityScheduler) {\n      CSQueue queue \u003d ((CapacityScheduler) scheduler).getQueue(targetQueue);\n      if (queue \u003d\u003d null) {\n        LOG.warn(\"Target queue \" + targetQueue\n            + \" does not exist while trying to move \"\n            + app.getApplicationId());\n        return false;\n      }\n      return authorizer.checkPermission(\n          new AccessRequest(queue.getPrivilegedEntity(), callerUGI,\n              SchedulerUtils.toAccessType(acl),\n              app.getApplicationId().toString(), app.getName(),\n              remoteAddress, forwardedAddresses));\n    } else if (scheduler instanceof FairScheduler) {\n      FSQueue queue \u003d ((FairScheduler) scheduler).getQueueManager().\n          getQueue(targetQueue);\n      if (queue \u003d\u003d null) {\n        LOG.warn(\"Target queue \" + targetQueue\n            + \" does not exist while trying to move \"\n            + app.getApplicationId());\n        return false;\n      }\n      return scheduler.checkAccess(callerUGI, acl, targetQueue);\n    } else {\n      // Any other scheduler just try\n      return scheduler.checkAccess(callerUGI, acl, targetQueue);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/security/QueueACLsManager.java"
    }
  }
}