{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NameNode.java",
  "functionName": "initializeSharedEdits",
  "functionId": "initializeSharedEdits___conf-Configuration__force-boolean__interactive-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
  "functionStartLine": 1331,
  "functionEndLine": 1407,
  "numCommitsSeen": 210,
  "timeTaken": 6049,
  "changeHistory": [
    "96c4575d7373079becfa3e3db29ba98e6fb86388",
    "9eee97508f350ed4629abb04e7781514ffa04070",
    "3ae38ec7dfa1aaf451cf889cec6cf862379af32a",
    "a5b37c6ed14e92f5a7f7dd76a9a82b3f859fb6dd",
    "7186000367df5a994e0270690a95ca49fa7b23a0",
    "969e84decbc976bd98f1050aead695d15a024ab6",
    "df801074c929d5414b92cc9fc0cc8a2794e02751",
    "b38bd555e837569672dfd48ea1b60e60efc71648",
    "9d0f8792a9a1d3d2b24adfc2c213247a099e7ad1",
    "7accbabdee0b7619ff83514c173e815d290b33bf",
    "07a436744588d131d8ef31abab3093aa59b4d531",
    "9597c81f35c17f6ee8bd2cef85f76af306478e6b",
    "ba688e11c195327d3832610789fdd0cf81a3d0a1"
  ],
  "changeHistoryShort": {
    "96c4575d7373079becfa3e3db29ba98e6fb86388": "Ybodychange",
    "9eee97508f350ed4629abb04e7781514ffa04070": "Ybodychange",
    "3ae38ec7dfa1aaf451cf889cec6cf862379af32a": "Ybodychange",
    "a5b37c6ed14e92f5a7f7dd76a9a82b3f859fb6dd": "Ybodychange",
    "7186000367df5a994e0270690a95ca49fa7b23a0": "Ybodychange",
    "969e84decbc976bd98f1050aead695d15a024ab6": "Ybodychange",
    "df801074c929d5414b92cc9fc0cc8a2794e02751": "Ymultichange(Yexceptionschange,Ybodychange)",
    "b38bd555e837569672dfd48ea1b60e60efc71648": "Ybodychange",
    "9d0f8792a9a1d3d2b24adfc2c213247a099e7ad1": "Ybodychange",
    "7accbabdee0b7619ff83514c173e815d290b33bf": "Ybodychange",
    "07a436744588d131d8ef31abab3093aa59b4d531": "Ybodychange",
    "9597c81f35c17f6ee8bd2cef85f76af306478e6b": "Ybodychange",
    "ba688e11c195327d3832610789fdd0cf81a3d0a1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "96c4575d7373079becfa3e3db29ba98e6fb86388": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13805. Journal Nodes should allow to format non-empty directories with -force option. Contributed by Surendra Singh Lilhore.\n",
      "commitDate": "23/08/18 7:44 PM",
      "commitName": "96c4575d7373079becfa3e3db29ba98e6fb86388",
      "commitAuthor": "Surendra Singh Lilhore",
      "commitDateOld": "12/08/18 3:06 AM",
      "commitNameOld": "2acc50b826fa8b00f2b09d9546c4b3215b89d46d",
      "commitAuthorOld": "Rakesh Radhakrishnan",
      "daysBetweenCommits": 11.69,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n       boolean force, boolean interactive) throws IOException {\n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n     initializeGenericKeys(conf, nsId, namenodeId);\n     \n     if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n       LOG.error(\"No shared edits directory configured for namespace \" +\n           nsId + \" namenode \" + namenodeId);\n       return false;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       InetSocketAddress socAddr \u003d DFSUtilClient.getNNAddress(conf);\n       SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n           DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY, socAddr.getHostName());\n     }\n \n     NNStorage existingStorage \u003d null;\n     FSImage sharedEditsImage \u003d null;\n     try {\n       FSNamesystem fsns \u003d\n           FSNamesystem.loadFromDisk(getConfigurationWithoutSharedEdits(conf));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n       NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n       \n       List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n       \n       sharedEditsImage \u003d new FSImage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n       sharedEditsImage.getEditLog().initJournalsForWrite();\n       \n       if (!sharedEditsImage.confirmFormat(force, interactive)) {\n         return true; // abort\n       }\n       \n       NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n       // Call Storage.format instead of FSImage.format here, since we don\u0027t\n       // actually want to save a checkpoint - just prime the dirs with\n       // the existing namespace info\n       newSharedStorage.format(nsInfo);\n-      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n+      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo, force);\n \n       // Need to make sure the edit log segments are in good shape to initialize\n       // the shared edits dir.\n       fsns.getFSImage().getEditLog().close();\n       fsns.getFSImage().getEditLog().initJournalsForWrite();\n       fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n \n       copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n           conf);\n     } catch (IOException ioe) {\n       LOG.error(\"Could not initialize shared edits dir\", ioe);\n       return true; // aborted\n     } finally {\n       if (sharedEditsImage !\u003d null) {\n         try {\n           sharedEditsImage.close();\n         }  catch (IOException ioe) {\n           LOG.warn(\"Could not close sharedEditsImage\", ioe);\n         }\n       }\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) throws IOException {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    \n    if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n      LOG.error(\"No shared edits directory configured for namespace \" +\n          nsId + \" namenode \" + namenodeId);\n      return false;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      InetSocketAddress socAddr \u003d DFSUtilClient.getNNAddress(conf);\n      SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n          DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY, socAddr.getHostName());\n    }\n\n    NNStorage existingStorage \u003d null;\n    FSImage sharedEditsImage \u003d null;\n    try {\n      FSNamesystem fsns \u003d\n          FSNamesystem.loadFromDisk(getConfigurationWithoutSharedEdits(conf));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n      \n      List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      \n      sharedEditsImage \u003d new FSImage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      sharedEditsImage.getEditLog().initJournalsForWrite();\n      \n      if (!sharedEditsImage.confirmFormat(force, interactive)) {\n        return true; // abort\n      }\n      \n      NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n      // Call Storage.format instead of FSImage.format here, since we don\u0027t\n      // actually want to save a checkpoint - just prime the dirs with\n      // the existing namespace info\n      newSharedStorage.format(nsInfo);\n      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo, force);\n\n      // Need to make sure the edit log segments are in good shape to initialize\n      // the shared edits dir.\n      fsns.getFSImage().getEditLog().close();\n      fsns.getFSImage().getEditLog().initJournalsForWrite();\n      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n\n      copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n          conf);\n    } catch (IOException ioe) {\n      LOG.error(\"Could not initialize shared edits dir\", ioe);\n      return true; // aborted\n    } finally {\n      if (sharedEditsImage !\u003d null) {\n        try {\n          sharedEditsImage.close();\n        }  catch (IOException ioe) {\n          LOG.warn(\"Could not close sharedEditsImage\", ioe);\n        }\n      }\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "9eee97508f350ed4629abb04e7781514ffa04070": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9022. Move NameNode.getAddress() and NameNode.getUri() to hadoop-hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "17/09/15 2:18 PM",
      "commitName": "9eee97508f350ed4629abb04e7781514ffa04070",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "15/09/15 11:48 AM",
      "commitNameOld": "ce69c9b54c642cfbe789fc661cfc7dcbb07b4ac5",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 2.1,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n       boolean force, boolean interactive) throws IOException {\n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n     initializeGenericKeys(conf, nsId, namenodeId);\n     \n     if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n       LOG.error(\"No shared edits directory configured for namespace \" +\n           nsId + \" namenode \" + namenodeId);\n       return false;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n-      InetSocketAddress socAddr \u003d getAddress(conf);\n+      InetSocketAddress socAddr \u003d DFSUtilClient.getNNAddress(conf);\n       SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n           DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY, socAddr.getHostName());\n     }\n \n     NNStorage existingStorage \u003d null;\n     FSImage sharedEditsImage \u003d null;\n     try {\n       FSNamesystem fsns \u003d\n           FSNamesystem.loadFromDisk(getConfigurationWithoutSharedEdits(conf));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n       NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n       \n       List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n       \n       sharedEditsImage \u003d new FSImage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n       sharedEditsImage.getEditLog().initJournalsForWrite();\n       \n       if (!sharedEditsImage.confirmFormat(force, interactive)) {\n         return true; // abort\n       }\n       \n       NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n       // Call Storage.format instead of FSImage.format here, since we don\u0027t\n       // actually want to save a checkpoint - just prime the dirs with\n       // the existing namespace info\n       newSharedStorage.format(nsInfo);\n       sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n \n       // Need to make sure the edit log segments are in good shape to initialize\n       // the shared edits dir.\n       fsns.getFSImage().getEditLog().close();\n       fsns.getFSImage().getEditLog().initJournalsForWrite();\n       fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n \n       copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n           conf);\n     } catch (IOException ioe) {\n       LOG.error(\"Could not initialize shared edits dir\", ioe);\n       return true; // aborted\n     } finally {\n       if (sharedEditsImage !\u003d null) {\n         try {\n           sharedEditsImage.close();\n         }  catch (IOException ioe) {\n           LOG.warn(\"Could not close sharedEditsImage\", ioe);\n         }\n       }\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) throws IOException {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    \n    if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n      LOG.error(\"No shared edits directory configured for namespace \" +\n          nsId + \" namenode \" + namenodeId);\n      return false;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      InetSocketAddress socAddr \u003d DFSUtilClient.getNNAddress(conf);\n      SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n          DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY, socAddr.getHostName());\n    }\n\n    NNStorage existingStorage \u003d null;\n    FSImage sharedEditsImage \u003d null;\n    try {\n      FSNamesystem fsns \u003d\n          FSNamesystem.loadFromDisk(getConfigurationWithoutSharedEdits(conf));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n      \n      List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      \n      sharedEditsImage \u003d new FSImage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      sharedEditsImage.getEditLog().initJournalsForWrite();\n      \n      if (!sharedEditsImage.confirmFormat(force, interactive)) {\n        return true; // abort\n      }\n      \n      NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n      // Call Storage.format instead of FSImage.format here, since we don\u0027t\n      // actually want to save a checkpoint - just prime the dirs with\n      // the existing namespace info\n      newSharedStorage.format(nsInfo);\n      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n\n      // Need to make sure the edit log segments are in good shape to initialize\n      // the shared edits dir.\n      fsns.getFSImage().getEditLog().close();\n      fsns.getFSImage().getEditLog().initJournalsForWrite();\n      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n\n      copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n          conf);\n    } catch (IOException ioe) {\n      LOG.error(\"Could not initialize shared edits dir\", ioe);\n      return true; // aborted\n    } finally {\n      if (sharedEditsImage !\u003d null) {\n        try {\n          sharedEditsImage.close();\n        }  catch (IOException ioe) {\n          LOG.warn(\"Could not close sharedEditsImage\", ioe);\n        }\n      }\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "3ae38ec7dfa1aaf451cf889cec6cf862379af32a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7712. Switch blockStateChangeLog to use slf4j.\n",
      "commitDate": "03/02/15 3:01 PM",
      "commitName": "3ae38ec7dfa1aaf451cf889cec6cf862379af32a",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/01/15 11:33 AM",
      "commitNameOld": "db334bb8625da97c7e518cbcf477530c7ba7001e",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 13.14,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n       boolean force, boolean interactive) throws IOException {\n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n     initializeGenericKeys(conf, nsId, namenodeId);\n     \n     if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n-      LOG.fatal(\"No shared edits directory configured for namespace \" +\n+      LOG.error(\"No shared edits directory configured for namespace \" +\n           nsId + \" namenode \" + namenodeId);\n       return false;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       InetSocketAddress socAddr \u003d getAddress(conf);\n       SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n           DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY, socAddr.getHostName());\n     }\n \n     NNStorage existingStorage \u003d null;\n     FSImage sharedEditsImage \u003d null;\n     try {\n       FSNamesystem fsns \u003d\n           FSNamesystem.loadFromDisk(getConfigurationWithoutSharedEdits(conf));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n       NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n       \n       List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n       \n       sharedEditsImage \u003d new FSImage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n       sharedEditsImage.getEditLog().initJournalsForWrite();\n       \n       if (!sharedEditsImage.confirmFormat(force, interactive)) {\n         return true; // abort\n       }\n       \n       NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n       // Call Storage.format instead of FSImage.format here, since we don\u0027t\n       // actually want to save a checkpoint - just prime the dirs with\n       // the existing namespace info\n       newSharedStorage.format(nsInfo);\n       sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n \n       // Need to make sure the edit log segments are in good shape to initialize\n       // the shared edits dir.\n       fsns.getFSImage().getEditLog().close();\n       fsns.getFSImage().getEditLog().initJournalsForWrite();\n       fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n \n       copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n           conf);\n     } catch (IOException ioe) {\n       LOG.error(\"Could not initialize shared edits dir\", ioe);\n       return true; // aborted\n     } finally {\n       if (sharedEditsImage !\u003d null) {\n         try {\n           sharedEditsImage.close();\n         }  catch (IOException ioe) {\n           LOG.warn(\"Could not close sharedEditsImage\", ioe);\n         }\n       }\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) throws IOException {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    \n    if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n      LOG.error(\"No shared edits directory configured for namespace \" +\n          nsId + \" namenode \" + namenodeId);\n      return false;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      InetSocketAddress socAddr \u003d getAddress(conf);\n      SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n          DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY, socAddr.getHostName());\n    }\n\n    NNStorage existingStorage \u003d null;\n    FSImage sharedEditsImage \u003d null;\n    try {\n      FSNamesystem fsns \u003d\n          FSNamesystem.loadFromDisk(getConfigurationWithoutSharedEdits(conf));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n      \n      List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      \n      sharedEditsImage \u003d new FSImage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      sharedEditsImage.getEditLog().initJournalsForWrite();\n      \n      if (!sharedEditsImage.confirmFormat(force, interactive)) {\n        return true; // abort\n      }\n      \n      NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n      // Call Storage.format instead of FSImage.format here, since we don\u0027t\n      // actually want to save a checkpoint - just prime the dirs with\n      // the existing namespace info\n      newSharedStorage.format(nsInfo);\n      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n\n      // Need to make sure the edit log segments are in good shape to initialize\n      // the shared edits dir.\n      fsns.getFSImage().getEditLog().close();\n      fsns.getFSImage().getEditLog().initJournalsForWrite();\n      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n\n      copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n          conf);\n    } catch (IOException ioe) {\n      LOG.error(\"Could not initialize shared edits dir\", ioe);\n      return true; // aborted\n    } finally {\n      if (sharedEditsImage !\u003d null) {\n        try {\n          sharedEditsImage.close();\n        }  catch (IOException ioe) {\n          LOG.warn(\"Could not close sharedEditsImage\", ioe);\n        }\n      }\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "a5b37c6ed14e92f5a7f7dd76a9a82b3f859fb6dd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6181. Fix the wrong property names in NFS user guide. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1585563 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/04/14 11:55 AM",
      "commitName": "a5b37c6ed14e92f5a7f7dd76a9a82b3f859fb6dd",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "02/04/14 10:28 AM",
      "commitNameOld": "fb1d7fb596b8e8bb9a5f141c89acb1949bade87a",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 5.06,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n       boolean force, boolean interactive) throws IOException {\n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n     initializeGenericKeys(conf, nsId, namenodeId);\n     \n     if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n       LOG.fatal(\"No shared edits directory configured for namespace \" +\n           nsId + \" namenode \" + namenodeId);\n       return false;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       InetSocketAddress socAddr \u003d getAddress(conf);\n       SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n-          DFS_NAMENODE_USER_NAME_KEY, socAddr.getHostName());\n+          DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY, socAddr.getHostName());\n     }\n \n     NNStorage existingStorage \u003d null;\n     FSImage sharedEditsImage \u003d null;\n     try {\n       FSNamesystem fsns \u003d\n           FSNamesystem.loadFromDisk(getConfigurationWithoutSharedEdits(conf));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n       NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n       \n       List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n       \n       sharedEditsImage \u003d new FSImage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n       sharedEditsImage.getEditLog().initJournalsForWrite();\n       \n       if (!sharedEditsImage.confirmFormat(force, interactive)) {\n         return true; // abort\n       }\n       \n       NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n       // Call Storage.format instead of FSImage.format here, since we don\u0027t\n       // actually want to save a checkpoint - just prime the dirs with\n       // the existing namespace info\n       newSharedStorage.format(nsInfo);\n       sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n \n       // Need to make sure the edit log segments are in good shape to initialize\n       // the shared edits dir.\n       fsns.getFSImage().getEditLog().close();\n       fsns.getFSImage().getEditLog().initJournalsForWrite();\n       fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n \n       copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n           conf);\n     } catch (IOException ioe) {\n       LOG.error(\"Could not initialize shared edits dir\", ioe);\n       return true; // aborted\n     } finally {\n       if (sharedEditsImage !\u003d null) {\n         try {\n           sharedEditsImage.close();\n         }  catch (IOException ioe) {\n           LOG.warn(\"Could not close sharedEditsImage\", ioe);\n         }\n       }\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) throws IOException {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    \n    if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n      LOG.fatal(\"No shared edits directory configured for namespace \" +\n          nsId + \" namenode \" + namenodeId);\n      return false;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      InetSocketAddress socAddr \u003d getAddress(conf);\n      SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n          DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY, socAddr.getHostName());\n    }\n\n    NNStorage existingStorage \u003d null;\n    FSImage sharedEditsImage \u003d null;\n    try {\n      FSNamesystem fsns \u003d\n          FSNamesystem.loadFromDisk(getConfigurationWithoutSharedEdits(conf));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n      \n      List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      \n      sharedEditsImage \u003d new FSImage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      sharedEditsImage.getEditLog().initJournalsForWrite();\n      \n      if (!sharedEditsImage.confirmFormat(force, interactive)) {\n        return true; // abort\n      }\n      \n      NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n      // Call Storage.format instead of FSImage.format here, since we don\u0027t\n      // actually want to save a checkpoint - just prime the dirs with\n      // the existing namespace info\n      newSharedStorage.format(nsInfo);\n      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n\n      // Need to make sure the edit log segments are in good shape to initialize\n      // the shared edits dir.\n      fsns.getFSImage().getEditLog().close();\n      fsns.getFSImage().getEditLog().initJournalsForWrite();\n      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n\n      copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n          conf);\n    } catch (IOException ioe) {\n      LOG.error(\"Could not initialize shared edits dir\", ioe);\n      return true; // aborted\n    } finally {\n      if (sharedEditsImage !\u003d null) {\n        try {\n          sharedEditsImage.close();\n        }  catch (IOException ioe) {\n          LOG.warn(\"Could not close sharedEditsImage\", ioe);\n        }\n      }\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "7186000367df5a994e0270690a95ca49fa7b23a0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5721. sharedEditsImage in Namenode#initializeSharedEdits() should be closed before method returns. (Ted Yu via junping_du)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556803 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/14 5:33 AM",
      "commitName": "7186000367df5a994e0270690a95ca49fa7b23a0",
      "commitAuthor": "Junping Du",
      "commitDateOld": "06/01/14 10:59 AM",
      "commitNameOld": "2a1ecd00dadb1577da9e02822469e8194f1d3cee",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 2.77,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,77 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n       boolean force, boolean interactive) throws IOException {\n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n     initializeGenericKeys(conf, nsId, namenodeId);\n     \n     if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n       LOG.fatal(\"No shared edits directory configured for namespace \" +\n           nsId + \" namenode \" + namenodeId);\n       return false;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       InetSocketAddress socAddr \u003d getAddress(conf);\n       SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n           DFS_NAMENODE_USER_NAME_KEY, socAddr.getHostName());\n     }\n \n     NNStorage existingStorage \u003d null;\n+    FSImage sharedEditsImage \u003d null;\n     try {\n       FSNamesystem fsns \u003d\n           FSNamesystem.loadFromDisk(getConfigurationWithoutSharedEdits(conf));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n       NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n       \n       List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n       \n-      FSImage sharedEditsImage \u003d new FSImage(conf,\n+      sharedEditsImage \u003d new FSImage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n       sharedEditsImage.getEditLog().initJournalsForWrite();\n       \n       if (!sharedEditsImage.confirmFormat(force, interactive)) {\n         return true; // abort\n       }\n       \n       NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n       // Call Storage.format instead of FSImage.format here, since we don\u0027t\n       // actually want to save a checkpoint - just prime the dirs with\n       // the existing namespace info\n       newSharedStorage.format(nsInfo);\n       sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n \n       // Need to make sure the edit log segments are in good shape to initialize\n       // the shared edits dir.\n       fsns.getFSImage().getEditLog().close();\n       fsns.getFSImage().getEditLog().initJournalsForWrite();\n       fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n \n       copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n           conf);\n     } catch (IOException ioe) {\n       LOG.error(\"Could not initialize shared edits dir\", ioe);\n       return true; // aborted\n     } finally {\n+      if (sharedEditsImage !\u003d null) {\n+        try {\n+          sharedEditsImage.close();\n+        }  catch (IOException ioe) {\n+          LOG.warn(\"Could not close sharedEditsImage\", ioe);\n+        }\n+      }\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) throws IOException {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    \n    if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n      LOG.fatal(\"No shared edits directory configured for namespace \" +\n          nsId + \" namenode \" + namenodeId);\n      return false;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      InetSocketAddress socAddr \u003d getAddress(conf);\n      SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n          DFS_NAMENODE_USER_NAME_KEY, socAddr.getHostName());\n    }\n\n    NNStorage existingStorage \u003d null;\n    FSImage sharedEditsImage \u003d null;\n    try {\n      FSNamesystem fsns \u003d\n          FSNamesystem.loadFromDisk(getConfigurationWithoutSharedEdits(conf));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n      \n      List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      \n      sharedEditsImage \u003d new FSImage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      sharedEditsImage.getEditLog().initJournalsForWrite();\n      \n      if (!sharedEditsImage.confirmFormat(force, interactive)) {\n        return true; // abort\n      }\n      \n      NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n      // Call Storage.format instead of FSImage.format here, since we don\u0027t\n      // actually want to save a checkpoint - just prime the dirs with\n      // the existing namespace info\n      newSharedStorage.format(nsInfo);\n      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n\n      // Need to make sure the edit log segments are in good shape to initialize\n      // the shared edits dir.\n      fsns.getFSImage().getEditLog().close();\n      fsns.getFSImage().getEditLog().initJournalsForWrite();\n      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n\n      copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n          conf);\n    } catch (IOException ioe) {\n      LOG.error(\"Could not initialize shared edits dir\", ioe);\n      return true; // aborted\n    } finally {\n      if (sharedEditsImage !\u003d null) {\n        try {\n          sharedEditsImage.close();\n        }  catch (IOException ioe) {\n          LOG.warn(\"Could not close sharedEditsImage\", ioe);\n        }\n      }\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "969e84decbc976bd98f1050aead695d15a024ab6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4342. Directories configured in dfs.namenode.edits.dir.required but not in dfs.namenode.edits.dir are silently ignored.  Contributed by Arpit Agarwal\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1445006 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/02/13 4:50 PM",
      "commitName": "969e84decbc976bd98f1050aead695d15a024ab6",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "07/12/12 3:52 PM",
      "commitNameOld": "e7cb3fd39cd367f45e4e1cb563cb3d8fbc698e6c",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 66.04,
      "commitsBetweenForRepo": 290,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,69 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n       boolean force, boolean interactive) throws IOException {\n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n     initializeGenericKeys(conf, nsId, namenodeId);\n     \n     if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n       LOG.fatal(\"No shared edits directory configured for namespace \" +\n           nsId + \" namenode \" + namenodeId);\n       return false;\n     }\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       InetSocketAddress socAddr \u003d getAddress(conf);\n       SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n           DFS_NAMENODE_USER_NAME_KEY, socAddr.getHostName());\n     }\n \n     NNStorage existingStorage \u003d null;\n     try {\n-      Configuration confWithoutShared \u003d new Configuration(conf);\n-      confWithoutShared.unset(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY);\n-      FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(confWithoutShared,\n-          FSNamesystem.getNamespaceDirs(conf),\n-          FSNamesystem.getNamespaceEditsDirs(conf, false));\n+      FSNamesystem fsns \u003d\n+          FSNamesystem.loadFromDisk(getConfigurationWithoutSharedEdits(conf));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n       NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n       \n       List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n       \n       FSImage sharedEditsImage \u003d new FSImage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n       sharedEditsImage.getEditLog().initJournalsForWrite();\n       \n       if (!sharedEditsImage.confirmFormat(force, interactive)) {\n         return true; // abort\n       }\n       \n       NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n       // Call Storage.format instead of FSImage.format here, since we don\u0027t\n       // actually want to save a checkpoint - just prime the dirs with\n       // the existing namespace info\n       newSharedStorage.format(nsInfo);\n       sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n \n       // Need to make sure the edit log segments are in good shape to initialize\n       // the shared edits dir.\n       fsns.getFSImage().getEditLog().close();\n       fsns.getFSImage().getEditLog().initJournalsForWrite();\n       fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n \n       copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n           conf);\n     } catch (IOException ioe) {\n       LOG.error(\"Could not initialize shared edits dir\", ioe);\n       return true; // aborted\n     } finally {\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) throws IOException {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    \n    if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n      LOG.fatal(\"No shared edits directory configured for namespace \" +\n          nsId + \" namenode \" + namenodeId);\n      return false;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      InetSocketAddress socAddr \u003d getAddress(conf);\n      SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n          DFS_NAMENODE_USER_NAME_KEY, socAddr.getHostName());\n    }\n\n    NNStorage existingStorage \u003d null;\n    try {\n      FSNamesystem fsns \u003d\n          FSNamesystem.loadFromDisk(getConfigurationWithoutSharedEdits(conf));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n      \n      List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      \n      FSImage sharedEditsImage \u003d new FSImage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      sharedEditsImage.getEditLog().initJournalsForWrite();\n      \n      if (!sharedEditsImage.confirmFormat(force, interactive)) {\n        return true; // abort\n      }\n      \n      NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n      // Call Storage.format instead of FSImage.format here, since we don\u0027t\n      // actually want to save a checkpoint - just prime the dirs with\n      // the existing namespace info\n      newSharedStorage.format(nsInfo);\n      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n\n      // Need to make sure the edit log segments are in good shape to initialize\n      // the shared edits dir.\n      fsns.getFSImage().getEditLog().close();\n      fsns.getFSImage().getEditLog().initJournalsForWrite();\n      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n\n      copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n          conf);\n    } catch (IOException ioe) {\n      LOG.error(\"Could not initialize shared edits dir\", ioe);\n      return true; // aborted\n    } finally {\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "df801074c929d5414b92cc9fc0cc8a2794e02751": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-3893. QJM: Make QJM work with security enabled. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1381770 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/12 2:42 PM",
      "commitName": "df801074c929d5414b92cc9fc0cc8a2794e02751",
      "commitAuthor": "Aaron Myers",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-3893. QJM: Make QJM work with security enabled. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1381770 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/09/12 2:42 PM",
          "commitName": "df801074c929d5414b92cc9fc0cc8a2794e02751",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "01/09/12 12:22 PM",
          "commitNameOld": "54e612bfb9f877e58f7f153c43cb4147876826d3",
          "commitAuthorOld": "Harsh J",
          "daysBetweenCommits": 5.1,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,72 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n-      boolean force, boolean interactive) {\n+      boolean force, boolean interactive) throws IOException {\n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n     initializeGenericKeys(conf, nsId, namenodeId);\n     \n     if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n       LOG.fatal(\"No shared edits directory configured for namespace \" +\n           nsId + \" namenode \" + namenodeId);\n       return false;\n     }\n \n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      InetSocketAddress socAddr \u003d getAddress(conf);\n+      SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n+          DFS_NAMENODE_USER_NAME_KEY, socAddr.getHostName());\n+    }\n+\n     NNStorage existingStorage \u003d null;\n     try {\n       Configuration confWithoutShared \u003d new Configuration(conf);\n       confWithoutShared.unset(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY);\n       FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(confWithoutShared,\n           FSNamesystem.getNamespaceDirs(conf),\n           FSNamesystem.getNamespaceEditsDirs(conf, false));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n       NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n       \n       List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n       \n       FSImage sharedEditsImage \u003d new FSImage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n       sharedEditsImage.getEditLog().initJournalsForWrite();\n       \n       if (!sharedEditsImage.confirmFormat(force, interactive)) {\n         return true; // abort\n       }\n       \n       NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n       // Call Storage.format instead of FSImage.format here, since we don\u0027t\n       // actually want to save a checkpoint - just prime the dirs with\n       // the existing namespace info\n       newSharedStorage.format(nsInfo);\n       sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n \n       // Need to make sure the edit log segments are in good shape to initialize\n       // the shared edits dir.\n       fsns.getFSImage().getEditLog().close();\n       fsns.getFSImage().getEditLog().initJournalsForWrite();\n       fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n \n       copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n           conf);\n     } catch (IOException ioe) {\n       LOG.error(\"Could not initialize shared edits dir\", ioe);\n       return true; // aborted\n     } finally {\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) throws IOException {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    \n    if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n      LOG.fatal(\"No shared edits directory configured for namespace \" +\n          nsId + \" namenode \" + namenodeId);\n      return false;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      InetSocketAddress socAddr \u003d getAddress(conf);\n      SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n          DFS_NAMENODE_USER_NAME_KEY, socAddr.getHostName());\n    }\n\n    NNStorage existingStorage \u003d null;\n    try {\n      Configuration confWithoutShared \u003d new Configuration(conf);\n      confWithoutShared.unset(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY);\n      FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(confWithoutShared,\n          FSNamesystem.getNamespaceDirs(conf),\n          FSNamesystem.getNamespaceEditsDirs(conf, false));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n      \n      List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      \n      FSImage sharedEditsImage \u003d new FSImage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      sharedEditsImage.getEditLog().initJournalsForWrite();\n      \n      if (!sharedEditsImage.confirmFormat(force, interactive)) {\n        return true; // abort\n      }\n      \n      NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n      // Call Storage.format instead of FSImage.format here, since we don\u0027t\n      // actually want to save a checkpoint - just prime the dirs with\n      // the existing namespace info\n      newSharedStorage.format(nsInfo);\n      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n\n      // Need to make sure the edit log segments are in good shape to initialize\n      // the shared edits dir.\n      fsns.getFSImage().getEditLog().close();\n      fsns.getFSImage().getEditLog().initJournalsForWrite();\n      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n\n      copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n          conf);\n    } catch (IOException ioe) {\n      LOG.error(\"Could not initialize shared edits dir\", ioe);\n      return true; // aborted\n    } finally {\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3893. QJM: Make QJM work with security enabled. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1381770 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/09/12 2:42 PM",
          "commitName": "df801074c929d5414b92cc9fc0cc8a2794e02751",
          "commitAuthor": "Aaron Myers",
          "commitDateOld": "01/09/12 12:22 PM",
          "commitNameOld": "54e612bfb9f877e58f7f153c43cb4147876826d3",
          "commitAuthorOld": "Harsh J",
          "daysBetweenCommits": 5.1,
          "commitsBetweenForRepo": 21,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,72 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n-      boolean force, boolean interactive) {\n+      boolean force, boolean interactive) throws IOException {\n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n     initializeGenericKeys(conf, nsId, namenodeId);\n     \n     if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n       LOG.fatal(\"No shared edits directory configured for namespace \" +\n           nsId + \" namenode \" + namenodeId);\n       return false;\n     }\n \n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      InetSocketAddress socAddr \u003d getAddress(conf);\n+      SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n+          DFS_NAMENODE_USER_NAME_KEY, socAddr.getHostName());\n+    }\n+\n     NNStorage existingStorage \u003d null;\n     try {\n       Configuration confWithoutShared \u003d new Configuration(conf);\n       confWithoutShared.unset(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY);\n       FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(confWithoutShared,\n           FSNamesystem.getNamespaceDirs(conf),\n           FSNamesystem.getNamespaceEditsDirs(conf, false));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n       NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n       \n       List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n       \n       FSImage sharedEditsImage \u003d new FSImage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n       sharedEditsImage.getEditLog().initJournalsForWrite();\n       \n       if (!sharedEditsImage.confirmFormat(force, interactive)) {\n         return true; // abort\n       }\n       \n       NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n       // Call Storage.format instead of FSImage.format here, since we don\u0027t\n       // actually want to save a checkpoint - just prime the dirs with\n       // the existing namespace info\n       newSharedStorage.format(nsInfo);\n       sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n \n       // Need to make sure the edit log segments are in good shape to initialize\n       // the shared edits dir.\n       fsns.getFSImage().getEditLog().close();\n       fsns.getFSImage().getEditLog().initJournalsForWrite();\n       fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n \n       copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n           conf);\n     } catch (IOException ioe) {\n       LOG.error(\"Could not initialize shared edits dir\", ioe);\n       return true; // aborted\n     } finally {\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) throws IOException {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    \n    if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n      LOG.fatal(\"No shared edits directory configured for namespace \" +\n          nsId + \" namenode \" + namenodeId);\n      return false;\n    }\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      InetSocketAddress socAddr \u003d getAddress(conf);\n      SecurityUtil.login(conf, DFS_NAMENODE_KEYTAB_FILE_KEY,\n          DFS_NAMENODE_USER_NAME_KEY, socAddr.getHostName());\n    }\n\n    NNStorage existingStorage \u003d null;\n    try {\n      Configuration confWithoutShared \u003d new Configuration(conf);\n      confWithoutShared.unset(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY);\n      FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(confWithoutShared,\n          FSNamesystem.getNamespaceDirs(conf),\n          FSNamesystem.getNamespaceEditsDirs(conf, false));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n      \n      List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      \n      FSImage sharedEditsImage \u003d new FSImage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      sharedEditsImage.getEditLog().initJournalsForWrite();\n      \n      if (!sharedEditsImage.confirmFormat(force, interactive)) {\n        return true; // abort\n      }\n      \n      NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n      // Call Storage.format instead of FSImage.format here, since we don\u0027t\n      // actually want to save a checkpoint - just prime the dirs with\n      // the existing namespace info\n      newSharedStorage.format(nsInfo);\n      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n\n      // Need to make sure the edit log segments are in good shape to initialize\n      // the shared edits dir.\n      fsns.getFSImage().getEditLog().close();\n      fsns.getFSImage().getEditLog().initJournalsForWrite();\n      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n\n      copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n          conf);\n    } catch (IOException ioe) {\n      LOG.error(\"Could not initialize shared edits dir\", ioe);\n      return true; // aborted\n    } finally {\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
          "extendedDetails": {}
        }
      ]
    },
    "b38bd555e837569672dfd48ea1b60e60efc71648": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3765. namenode -initializeSharedEdits should be able to initialize all shared storages. Contributed by Vinay and Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1373061 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/12 1:11 PM",
      "commitName": "b38bd555e837569672dfd48ea1b60e60efc71648",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "13/08/12 2:26 PM",
      "commitNameOld": "c93185df660aa4fbb7885794550177286f9f3029",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,66 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n       boolean force, boolean interactive) {\n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n     initializeGenericKeys(conf, nsId, namenodeId);\n+    \n+    if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n+      LOG.fatal(\"No shared edits directory configured for namespace \" +\n+          nsId + \" namenode \" + namenodeId);\n+      return false;\n+    }\n+\n     NNStorage existingStorage \u003d null;\n     try {\n-      FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(conf,\n+      Configuration confWithoutShared \u003d new Configuration(conf);\n+      confWithoutShared.unset(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY);\n+      FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(confWithoutShared,\n           FSNamesystem.getNamespaceDirs(conf),\n           FSNamesystem.getNamespaceEditsDirs(conf, false));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n       NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n       \n       List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n       \n       FSImage sharedEditsImage \u003d new FSImage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n       sharedEditsImage.getEditLog().initJournalsForWrite();\n       \n       if (!sharedEditsImage.confirmFormat(force, interactive)) {\n         return true; // abort\n       }\n       \n       NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n       // Call Storage.format instead of FSImage.format here, since we don\u0027t\n       // actually want to save a checkpoint - just prime the dirs with\n       // the existing namespace info\n       newSharedStorage.format(nsInfo);\n       sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n \n       // Need to make sure the edit log segments are in good shape to initialize\n       // the shared edits dir.\n       fsns.getFSImage().getEditLog().close();\n       fsns.getFSImage().getEditLog().initJournalsForWrite();\n       fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n-      \n-      if (copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs,\n-          newSharedStorage, conf)) {\n-        return true; // aborted\n-      }\n+\n+      copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n+          conf);\n     } catch (IOException ioe) {\n       LOG.error(\"Could not initialize shared edits dir\", ioe);\n       return true; // aborted\n     } finally {\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    \n    if (conf.get(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY) \u003d\u003d null) {\n      LOG.fatal(\"No shared edits directory configured for namespace \" +\n          nsId + \" namenode \" + namenodeId);\n      return false;\n    }\n\n    NNStorage existingStorage \u003d null;\n    try {\n      Configuration confWithoutShared \u003d new Configuration(conf);\n      confWithoutShared.unset(DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY);\n      FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(confWithoutShared,\n          FSNamesystem.getNamespaceDirs(conf),\n          FSNamesystem.getNamespaceEditsDirs(conf, false));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n      \n      List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      \n      FSImage sharedEditsImage \u003d new FSImage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      sharedEditsImage.getEditLog().initJournalsForWrite();\n      \n      if (!sharedEditsImage.confirmFormat(force, interactive)) {\n        return true; // abort\n      }\n      \n      NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n      // Call Storage.format instead of FSImage.format here, since we don\u0027t\n      // actually want to save a checkpoint - just prime the dirs with\n      // the existing namespace info\n      newSharedStorage.format(nsInfo);\n      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n\n      // Need to make sure the edit log segments are in good shape to initialize\n      // the shared edits dir.\n      fsns.getFSImage().getEditLog().close();\n      fsns.getFSImage().getEditLog().initJournalsForWrite();\n      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n\n      copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs, newSharedStorage,\n          conf);\n    } catch (IOException ioe) {\n      LOG.error(\"Could not initialize shared edits dir\", ioe);\n      return true; // aborted\n    } finally {\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "9d0f8792a9a1d3d2b24adfc2c213247a099e7ad1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3695. Genericize format() to non-file JournalManagers. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1371513 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/08/12 3:13 PM",
      "commitName": "9d0f8792a9a1d3d2b24adfc2c213247a099e7ad1",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "17/07/12 10:05 PM",
      "commitNameOld": "6981b14003d3ff99fd719515ac08d748fc5f44bd",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 22.71,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,59 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n       boolean force, boolean interactive) {\n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n     initializeGenericKeys(conf, nsId, namenodeId);\n     NNStorage existingStorage \u003d null;\n     try {\n       FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(conf,\n           FSNamesystem.getNamespaceDirs(conf),\n           FSNamesystem.getNamespaceEditsDirs(conf, false));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n+      NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n       \n-      Collection\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n-      if (!confirmFormat(sharedEditsDirs, force, interactive)) {\n-        return true; // aborted\n-      }\n-      NNStorage newSharedStorage \u003d new NNStorage(conf,\n+      List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n+      \n+      FSImage sharedEditsImage \u003d new FSImage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n+      sharedEditsImage.getEditLog().initJournalsForWrite();\n       \n-      newSharedStorage.format(existingStorage.getNamespaceInfo());\n+      if (!sharedEditsImage.confirmFormat(force, interactive)) {\n+        return true; // abort\n+      }\n       \n+      NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n+      // Call Storage.format instead of FSImage.format here, since we don\u0027t\n+      // actually want to save a checkpoint - just prime the dirs with\n+      // the existing namespace info\n+      newSharedStorage.format(nsInfo);\n+      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n+\n       // Need to make sure the edit log segments are in good shape to initialize\n       // the shared edits dir.\n       fsns.getFSImage().getEditLog().close();\n       fsns.getFSImage().getEditLog().initJournalsForWrite();\n       fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n       \n       if (copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs,\n           newSharedStorage, conf)) {\n         return true; // aborted\n       }\n     } catch (IOException ioe) {\n       LOG.error(\"Could not initialize shared edits dir\", ioe);\n       return true; // aborted\n     } finally {\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    NNStorage existingStorage \u003d null;\n    try {\n      FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(conf,\n          FSNamesystem.getNamespaceDirs(conf),\n          FSNamesystem.getNamespaceEditsDirs(conf, false));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      NamespaceInfo nsInfo \u003d existingStorage.getNamespaceInfo();\n      \n      List\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      \n      FSImage sharedEditsImage \u003d new FSImage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      sharedEditsImage.getEditLog().initJournalsForWrite();\n      \n      if (!sharedEditsImage.confirmFormat(force, interactive)) {\n        return true; // abort\n      }\n      \n      NNStorage newSharedStorage \u003d sharedEditsImage.getStorage();\n      // Call Storage.format instead of FSImage.format here, since we don\u0027t\n      // actually want to save a checkpoint - just prime the dirs with\n      // the existing namespace info\n      newSharedStorage.format(nsInfo);\n      sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);\n\n      // Need to make sure the edit log segments are in good shape to initialize\n      // the shared edits dir.\n      fsns.getFSImage().getEditLog().close();\n      fsns.getFSImage().getEditLog().initJournalsForWrite();\n      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n      \n      if (copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs,\n          newSharedStorage, conf)) {\n        return true; // aborted\n      }\n    } catch (IOException ioe) {\n      LOG.error(\"Could not initialize shared edits dir\", ioe);\n      return true; // aborted\n    } finally {\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "7accbabdee0b7619ff83514c173e815d290b33bf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3573. Supply NamespaceInfo when instantiating JournalManagers. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1356388 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/07/12 11:21 AM",
      "commitName": "7accbabdee0b7619ff83514c173e815d290b33bf",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "27/06/12 6:25 PM",
      "commitNameOld": "f105784d6a28d2a0cedb619f0951de93d995e9da",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 4.71,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,50 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n       boolean force, boolean interactive) {\n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n     initializeGenericKeys(conf, nsId, namenodeId);\n     NNStorage existingStorage \u003d null;\n     try {\n       FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(conf,\n           FSNamesystem.getNamespaceDirs(conf),\n           FSNamesystem.getNamespaceEditsDirs(conf, false));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n       \n       Collection\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n       if (!confirmFormat(sharedEditsDirs, force, interactive)) {\n         return true; // aborted\n       }\n       NNStorage newSharedStorage \u003d new NNStorage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n       \n-      newSharedStorage.format(new NamespaceInfo(\n-          existingStorage.getNamespaceID(),\n-          existingStorage.getClusterID(),\n-          existingStorage.getBlockPoolID(),\n-          existingStorage.getCTime(),\n-          existingStorage.getDistributedUpgradeVersion()));\n+      newSharedStorage.format(existingStorage.getNamespaceInfo());\n       \n       // Need to make sure the edit log segments are in good shape to initialize\n       // the shared edits dir.\n       fsns.getFSImage().getEditLog().close();\n       fsns.getFSImage().getEditLog().initJournalsForWrite();\n       fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n       \n       if (copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs,\n           newSharedStorage, conf)) {\n         return true; // aborted\n       }\n     } catch (IOException ioe) {\n       LOG.error(\"Could not initialize shared edits dir\", ioe);\n       return true; // aborted\n     } finally {\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    NNStorage existingStorage \u003d null;\n    try {\n      FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(conf,\n          FSNamesystem.getNamespaceDirs(conf),\n          FSNamesystem.getNamespaceEditsDirs(conf, false));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      \n      Collection\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      if (!confirmFormat(sharedEditsDirs, force, interactive)) {\n        return true; // aborted\n      }\n      NNStorage newSharedStorage \u003d new NNStorage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      \n      newSharedStorage.format(existingStorage.getNamespaceInfo());\n      \n      // Need to make sure the edit log segments are in good shape to initialize\n      // the shared edits dir.\n      fsns.getFSImage().getEditLog().close();\n      fsns.getFSImage().getEditLog().initJournalsForWrite();\n      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n      \n      if (copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs,\n          newSharedStorage, conf)) {\n        return true; // aborted\n      }\n    } catch (IOException ioe) {\n      LOG.error(\"Could not initialize shared edits dir\", ioe);\n      return true; // aborted\n    } finally {\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "07a436744588d131d8ef31abab3093aa59b4d531": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3259. NameNode#initializeSharedEdits should populate shared edits dir with edit log segments. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1325518 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/04/12 2:11 PM",
      "commitName": "07a436744588d131d8ef31abab3093aa59b4d531",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "10/04/12 10:28 PM",
      "commitNameOld": "dab66bee5559a75f6d3756fc224fcda9cd4d598d",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 1.65,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,55 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n       boolean force, boolean interactive) {\n     String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n     String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n     initializeGenericKeys(conf, nsId, namenodeId);\n     NNStorage existingStorage \u003d null;\n     try {\n       FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(conf,\n           FSNamesystem.getNamespaceDirs(conf),\n           FSNamesystem.getNamespaceEditsDirs(conf, false));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n       \n       Collection\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n       if (!confirmFormat(sharedEditsDirs, force, interactive)) {\n         return true; // aborted\n       }\n       NNStorage newSharedStorage \u003d new NNStorage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n       \n       newSharedStorage.format(new NamespaceInfo(\n           existingStorage.getNamespaceID(),\n           existingStorage.getClusterID(),\n           existingStorage.getBlockPoolID(),\n           existingStorage.getCTime(),\n           existingStorage.getDistributedUpgradeVersion()));\n-    } catch (Exception e) {\n-      LOG.error(\"Could not format shared edits dir\", e);\n+      \n+      // Need to make sure the edit log segments are in good shape to initialize\n+      // the shared edits dir.\n+      fsns.getFSImage().getEditLog().close();\n+      fsns.getFSImage().getEditLog().initJournalsForWrite();\n+      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n+      \n+      if (copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs,\n+          newSharedStorage, conf)) {\n+        return true; // aborted\n+      }\n+    } catch (IOException ioe) {\n+      LOG.error(\"Could not initialize shared edits dir\", ioe);\n       return true; // aborted\n     } finally {\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    NNStorage existingStorage \u003d null;\n    try {\n      FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(conf,\n          FSNamesystem.getNamespaceDirs(conf),\n          FSNamesystem.getNamespaceEditsDirs(conf, false));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      \n      Collection\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      if (!confirmFormat(sharedEditsDirs, force, interactive)) {\n        return true; // aborted\n      }\n      NNStorage newSharedStorage \u003d new NNStorage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      \n      newSharedStorage.format(new NamespaceInfo(\n          existingStorage.getNamespaceID(),\n          existingStorage.getClusterID(),\n          existingStorage.getBlockPoolID(),\n          existingStorage.getCTime(),\n          existingStorage.getDistributedUpgradeVersion()));\n      \n      // Need to make sure the edit log segments are in good shape to initialize\n      // the shared edits dir.\n      fsns.getFSImage().getEditLog().close();\n      fsns.getFSImage().getEditLog().initJournalsForWrite();\n      fsns.getFSImage().getEditLog().recoverUnclosedStreams();\n      \n      if (copyEditLogSegmentsToSharedDir(fsns, sharedEditsDirs,\n          newSharedStorage, conf)) {\n        return true; // aborted\n      }\n    } catch (IOException ioe) {\n      LOG.error(\"Could not initialize shared edits dir\", ioe);\n      return true; // aborted\n    } finally {\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "9597c81f35c17f6ee8bd2cef85f76af306478e6b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3236. NameNode does not initialize generic conf keys when started with -initializeSharedEditsDir. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1311554 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/04/12 7:17 PM",
      "commitName": "9597c81f35c17f6ee8bd2cef85f76af306478e6b",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "09/04/12 12:39 PM",
      "commitNameOld": "706394d03992b394e9f907aff2155df493e4ea4e",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.28,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,44 @@\n   private static boolean initializeSharedEdits(Configuration conf,\n       boolean force, boolean interactive) {\n+    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n+    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n+    initializeGenericKeys(conf, nsId, namenodeId);\n     NNStorage existingStorage \u003d null;\n     try {\n       FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(conf,\n           FSNamesystem.getNamespaceDirs(conf),\n           FSNamesystem.getNamespaceEditsDirs(conf, false));\n       \n       existingStorage \u003d fsns.getFSImage().getStorage();\n       \n       Collection\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n       if (!confirmFormat(sharedEditsDirs, force, interactive)) {\n         return true; // aborted\n       }\n       NNStorage newSharedStorage \u003d new NNStorage(conf,\n           Lists.\u003cURI\u003enewArrayList(),\n           sharedEditsDirs);\n       \n       newSharedStorage.format(new NamespaceInfo(\n           existingStorage.getNamespaceID(),\n           existingStorage.getClusterID(),\n           existingStorage.getBlockPoolID(),\n           existingStorage.getCTime(),\n           existingStorage.getDistributedUpgradeVersion()));\n     } catch (Exception e) {\n       LOG.error(\"Could not format shared edits dir\", e);\n       return true; // aborted\n     } finally {\n       // Have to unlock storage explicitly for the case when we\u0027re running in a\n       // unit test, which runs in the same JVM as NNs.\n       if (existingStorage !\u003d null) {\n         try {\n           existingStorage.unlockAll();\n         } catch (IOException ioe) {\n           LOG.warn(\"Could not unlock storage directories\", ioe);\n           return true; // aborted\n         }\n       }\n     }\n     return false; // did not abort\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) {\n    String nsId \u003d DFSUtil.getNamenodeNameServiceId(conf);\n    String namenodeId \u003d HAUtil.getNameNodeId(conf, nsId);\n    initializeGenericKeys(conf, nsId, namenodeId);\n    NNStorage existingStorage \u003d null;\n    try {\n      FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(conf,\n          FSNamesystem.getNamespaceDirs(conf),\n          FSNamesystem.getNamespaceEditsDirs(conf, false));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      \n      Collection\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      if (!confirmFormat(sharedEditsDirs, force, interactive)) {\n        return true; // aborted\n      }\n      NNStorage newSharedStorage \u003d new NNStorage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      \n      newSharedStorage.format(new NamespaceInfo(\n          existingStorage.getNamespaceID(),\n          existingStorage.getClusterID(),\n          existingStorage.getBlockPoolID(),\n          existingStorage.getCTime(),\n          existingStorage.getDistributedUpgradeVersion()));\n    } catch (Exception e) {\n      LOG.error(\"Could not format shared edits dir\", e);\n      return true; // aborted\n    } finally {\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "ba688e11c195327d3832610789fdd0cf81a3d0a1": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3102. Add CLI tool to initialize the shared-edits dir. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1309580 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/04/12 1:15 PM",
      "commitName": "ba688e11c195327d3832610789fdd0cf81a3d0a1",
      "commitAuthor": "Aaron Myers",
      "diff": "@@ -0,0 +1,41 @@\n+  private static boolean initializeSharedEdits(Configuration conf,\n+      boolean force, boolean interactive) {\n+    NNStorage existingStorage \u003d null;\n+    try {\n+      FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(conf,\n+          FSNamesystem.getNamespaceDirs(conf),\n+          FSNamesystem.getNamespaceEditsDirs(conf, false));\n+      \n+      existingStorage \u003d fsns.getFSImage().getStorage();\n+      \n+      Collection\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n+      if (!confirmFormat(sharedEditsDirs, force, interactive)) {\n+        return true; // aborted\n+      }\n+      NNStorage newSharedStorage \u003d new NNStorage(conf,\n+          Lists.\u003cURI\u003enewArrayList(),\n+          sharedEditsDirs);\n+      \n+      newSharedStorage.format(new NamespaceInfo(\n+          existingStorage.getNamespaceID(),\n+          existingStorage.getClusterID(),\n+          existingStorage.getBlockPoolID(),\n+          existingStorage.getCTime(),\n+          existingStorage.getDistributedUpgradeVersion()));\n+    } catch (Exception e) {\n+      LOG.error(\"Could not format shared edits dir\", e);\n+      return true; // aborted\n+    } finally {\n+      // Have to unlock storage explicitly for the case when we\u0027re running in a\n+      // unit test, which runs in the same JVM as NNs.\n+      if (existingStorage !\u003d null) {\n+        try {\n+          existingStorage.unlockAll();\n+        } catch (IOException ioe) {\n+          LOG.warn(\"Could not unlock storage directories\", ioe);\n+          return true; // aborted\n+        }\n+      }\n+    }\n+    return false; // did not abort\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static boolean initializeSharedEdits(Configuration conf,\n      boolean force, boolean interactive) {\n    NNStorage existingStorage \u003d null;\n    try {\n      FSNamesystem fsns \u003d FSNamesystem.loadFromDisk(conf,\n          FSNamesystem.getNamespaceDirs(conf),\n          FSNamesystem.getNamespaceEditsDirs(conf, false));\n      \n      existingStorage \u003d fsns.getFSImage().getStorage();\n      \n      Collection\u003cURI\u003e sharedEditsDirs \u003d FSNamesystem.getSharedEditsDirs(conf);\n      if (!confirmFormat(sharedEditsDirs, force, interactive)) {\n        return true; // aborted\n      }\n      NNStorage newSharedStorage \u003d new NNStorage(conf,\n          Lists.\u003cURI\u003enewArrayList(),\n          sharedEditsDirs);\n      \n      newSharedStorage.format(new NamespaceInfo(\n          existingStorage.getNamespaceID(),\n          existingStorage.getClusterID(),\n          existingStorage.getBlockPoolID(),\n          existingStorage.getCTime(),\n          existingStorage.getDistributedUpgradeVersion()));\n    } catch (Exception e) {\n      LOG.error(\"Could not format shared edits dir\", e);\n      return true; // aborted\n    } finally {\n      // Have to unlock storage explicitly for the case when we\u0027re running in a\n      // unit test, which runs in the same JVM as NNs.\n      if (existingStorage !\u003d null) {\n        try {\n          existingStorage.unlockAll();\n        } catch (IOException ioe) {\n          LOG.warn(\"Could not unlock storage directories\", ioe);\n          return true; // aborted\n        }\n      }\n    }\n    return false; // did not abort\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java"
    }
  }
}