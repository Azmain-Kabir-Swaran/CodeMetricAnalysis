{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RLESparseResourceAllocation.java",
  "functionName": "merge",
  "functionId": "merge___resCalc-ResourceCalculator__clusterResource-Resource__a-NavigableMap__Long,Resource____b-NavigableMap__Long,Resource____start-long__end-long__operator-RLEOperator",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/RLESparseResourceAllocation.java",
  "functionStartLine": 316,
  "functionEndLine": 400,
  "numCommitsSeen": 11,
  "timeTaken": 1442,
  "changeHistory": [
    "da1016365aba1cee9c06771ab142d077379f27af"
  ],
  "changeHistoryShort": {
    "da1016365aba1cee9c06771ab142d077379f27af": "Yintroduced"
  },
  "changeHistoryDetails": {
    "da1016365aba1cee9c06771ab142d077379f27af": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3454. Add efficient merge operation to RLESparseResourceAllocation (Carlo Curino via asuresh)\n",
      "commitDate": "21/11/15 9:59 AM",
      "commitName": "da1016365aba1cee9c06771ab142d077379f27af",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,85 @@\n+  private static NavigableMap\u003cLong, Resource\u003e merge(ResourceCalculator resCalc,\n+      Resource clusterResource, NavigableMap\u003cLong, Resource\u003e a,\n+      NavigableMap\u003cLong, Resource\u003e b, long start, long end,\n+      RLEOperator operator) throws PlanningException {\n+\n+    // handle special cases of empty input\n+    if (a \u003d\u003d null || a.isEmpty()) {\n+      if (operator \u003d\u003d RLEOperator.subtract\n+          || operator \u003d\u003d RLEOperator.subtractTestNonNegative) {\n+        return negate(operator, b);\n+      } else {\n+        return b;\n+      }\n+    }\n+    if (b \u003d\u003d null || b.isEmpty()) {\n+      return a;\n+    }\n+\n+    // define iterators and support variables\n+    Iterator\u003cEntry\u003cLong, Resource\u003e\u003e aIt \u003d a.entrySet().iterator();\n+    Iterator\u003cEntry\u003cLong, Resource\u003e\u003e bIt \u003d b.entrySet().iterator();\n+    Entry\u003cLong, Resource\u003e curA \u003d aIt.next();\n+    Entry\u003cLong, Resource\u003e curB \u003d bIt.next();\n+    Entry\u003cLong, Resource\u003e lastA \u003d null;\n+    Entry\u003cLong, Resource\u003e lastB \u003d null;\n+    boolean aIsDone \u003d false;\n+    boolean bIsDone \u003d false;\n+\n+    TreeMap\u003cLong, Resource\u003e out \u003d new TreeMap\u003cLong, Resource\u003e();\n+\n+    while (!(curA.equals(lastA) \u0026\u0026 curB.equals(lastB))) {\n+\n+      Resource outRes;\n+      long time \u003d -1;\n+\n+      // curA is smaller than curB\n+      if (bIsDone || (curA.getKey() \u003c curB.getKey() \u0026\u0026 !aIsDone)) {\n+        outRes \u003d combineValue(operator, resCalc, clusterResource, curA, lastB);\n+        time \u003d (curA.getKey() \u003c start) ? start : curA.getKey();\n+        lastA \u003d curA;\n+        if (aIt.hasNext()) {\n+          curA \u003d aIt.next();\n+        } else {\n+          aIsDone \u003d true;\n+        }\n+\n+      } else {\n+        // curB is smaller than curA\n+        if (aIsDone || (curA.getKey() \u003e curB.getKey() \u0026\u0026 !bIsDone)) {\n+          outRes \u003d\n+              combineValue(operator, resCalc, clusterResource, lastA, curB);\n+          time \u003d (curB.getKey() \u003c start) ? start : curB.getKey();\n+          lastB \u003d curB;\n+          if (bIt.hasNext()) {\n+            curB \u003d bIt.next();\n+          } else {\n+            bIsDone \u003d true;\n+          }\n+\n+        } else {\n+          // curA is equal to curB\n+          outRes \u003d combineValue(operator, resCalc, clusterResource, curA, curB);\n+          time \u003d (curA.getKey() \u003c start) ? start : curA.getKey();\n+          lastA \u003d curA;\n+          if (aIt.hasNext()) {\n+            curA \u003d aIt.next();\n+          } else {\n+            aIsDone \u003d true;\n+          }\n+          lastB \u003d curB;\n+          if (bIt.hasNext()) {\n+            curB \u003d bIt.next();\n+          } else {\n+            bIsDone \u003d true;\n+          }\n+        }\n+      }\n+\n+      // add to out if not redundant\n+      addIfNeeded(out, time, outRes);\n+    }\n+    addIfNeeded(out, end, null);\n+\n+    return out;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static NavigableMap\u003cLong, Resource\u003e merge(ResourceCalculator resCalc,\n      Resource clusterResource, NavigableMap\u003cLong, Resource\u003e a,\n      NavigableMap\u003cLong, Resource\u003e b, long start, long end,\n      RLEOperator operator) throws PlanningException {\n\n    // handle special cases of empty input\n    if (a \u003d\u003d null || a.isEmpty()) {\n      if (operator \u003d\u003d RLEOperator.subtract\n          || operator \u003d\u003d RLEOperator.subtractTestNonNegative) {\n        return negate(operator, b);\n      } else {\n        return b;\n      }\n    }\n    if (b \u003d\u003d null || b.isEmpty()) {\n      return a;\n    }\n\n    // define iterators and support variables\n    Iterator\u003cEntry\u003cLong, Resource\u003e\u003e aIt \u003d a.entrySet().iterator();\n    Iterator\u003cEntry\u003cLong, Resource\u003e\u003e bIt \u003d b.entrySet().iterator();\n    Entry\u003cLong, Resource\u003e curA \u003d aIt.next();\n    Entry\u003cLong, Resource\u003e curB \u003d bIt.next();\n    Entry\u003cLong, Resource\u003e lastA \u003d null;\n    Entry\u003cLong, Resource\u003e lastB \u003d null;\n    boolean aIsDone \u003d false;\n    boolean bIsDone \u003d false;\n\n    TreeMap\u003cLong, Resource\u003e out \u003d new TreeMap\u003cLong, Resource\u003e();\n\n    while (!(curA.equals(lastA) \u0026\u0026 curB.equals(lastB))) {\n\n      Resource outRes;\n      long time \u003d -1;\n\n      // curA is smaller than curB\n      if (bIsDone || (curA.getKey() \u003c curB.getKey() \u0026\u0026 !aIsDone)) {\n        outRes \u003d combineValue(operator, resCalc, clusterResource, curA, lastB);\n        time \u003d (curA.getKey() \u003c start) ? start : curA.getKey();\n        lastA \u003d curA;\n        if (aIt.hasNext()) {\n          curA \u003d aIt.next();\n        } else {\n          aIsDone \u003d true;\n        }\n\n      } else {\n        // curB is smaller than curA\n        if (aIsDone || (curA.getKey() \u003e curB.getKey() \u0026\u0026 !bIsDone)) {\n          outRes \u003d\n              combineValue(operator, resCalc, clusterResource, lastA, curB);\n          time \u003d (curB.getKey() \u003c start) ? start : curB.getKey();\n          lastB \u003d curB;\n          if (bIt.hasNext()) {\n            curB \u003d bIt.next();\n          } else {\n            bIsDone \u003d true;\n          }\n\n        } else {\n          // curA is equal to curB\n          outRes \u003d combineValue(operator, resCalc, clusterResource, curA, curB);\n          time \u003d (curA.getKey() \u003c start) ? start : curA.getKey();\n          lastA \u003d curA;\n          if (aIt.hasNext()) {\n            curA \u003d aIt.next();\n          } else {\n            aIsDone \u003d true;\n          }\n          lastB \u003d curB;\n          if (bIt.hasNext()) {\n            curB \u003d bIt.next();\n          } else {\n            bIsDone \u003d true;\n          }\n        }\n      }\n\n      // add to out if not redundant\n      addIfNeeded(out, time, outRes);\n    }\n    addIfNeeded(out, end, null);\n\n    return out;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/RLESparseResourceAllocation.java"
    }
  }
}